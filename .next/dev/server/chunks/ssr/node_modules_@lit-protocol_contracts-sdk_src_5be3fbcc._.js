module.exports = [
"[project]/node_modules/@lit-protocol/contracts-sdk/src/lib/hex2dec.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// @ts-nocheck
/**
 * A function for converting hex <-> dec w/o loss of precision.
 *
 * The problem is that parseInt("0x12345...") isn't precise enough to convert
 * 64-bit integers correctly.
 *
 * Internally, this uses arrays to encode decimal digits starting with the least
 * significant:
 * 8 = [8]
 * 16 = [6, 1]
 * 1024 = [4, 2, 0, 1]
 *
 * Source: http://www.danvk.org/hex2dec.html
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.intToIP = void 0;
exports.add = add;
exports.multiplyByNumber = multiplyByNumber;
exports.parseToDigitsArray = parseToDigitsArray;
exports.convertBase = convertBase;
exports.decToHex = decToHex;
exports.hexToDec = hexToDec;
// Adds two arrays for the given base (10 or 16), returning the result.
// This turns out to be the only "primitive" operation we need.
function add(x, y, base) {
    var z = [];
    var n = Math.max(x.length, y.length);
    var carry = 0;
    var i = 0;
    while(i < n || carry){
        var xi = i < x.length ? x[i] : 0;
        var yi = i < y.length ? y[i] : 0;
        var zi = carry + xi + yi;
        z.push(zi % base);
        carry = Math.floor(zi / base);
        i++;
    }
    return z;
}
// Returns a*x, where x is an array of decimal digits and a is an ordinary
// JavaScript number. base is the number base of the array x.
function multiplyByNumber(num, x, base) {
    if (num < 0) return null;
    if (num == 0) return [];
    var result = [];
    var power = x;
    while(true){
        if (num & 1) {
            result = add(result, power, base);
        }
        num = num >> 1;
        if (num === 0) break;
        power = add(power, power, base);
    }
    return result;
}
function parseToDigitsArray(str, base) {
    var digits = str.split('');
    var ary = [];
    for(var i = digits.length - 1; i >= 0; i--){
        var n = parseInt(digits[i], base);
        if (isNaN(n)) return null;
        ary.push(n);
    }
    return ary;
}
function convertBase(str, fromBase, toBase) {
    var digits = parseToDigitsArray(str, fromBase);
    if (digits === null) return null;
    var outArray = [];
    var power = [
        1
    ];
    for(var i = 0; i < digits.length; i++){
        // invariant: at this point, fromBase^i = power
        if (digits[i]) {
            outArray = add(outArray, multiplyByNumber(digits[i], power, toBase), toBase);
        }
        power = multiplyByNumber(fromBase, power, toBase);
    }
    var out = '';
    for(var i = outArray.length - 1; i >= 0; i--){
        out += outArray[i].toString(toBase);
    }
    if (out === '') {
        out = '0';
    }
    return out;
}
function decToHex(decStr, opts) {
    var hidePrefix = opts && opts.prefix === false;
    var hex = convertBase(decStr, 10, 16);
    return hex ? hidePrefix ? hex : '0x' + hex : null;
}
function hexToDec(hexStr) {
    if (hexStr.substring(0, 2) === '0x') hexStr = hexStr.substring(2);
    hexStr = hexStr.toLowerCase();
    return convertBase(hexStr, 16, 10);
}
const intToIP = (ip)=>{
    // -- ip
    // Convert integer to binary string and pad with leading zeros to make it 32-bit
    const binaryString = ip.toString(2).padStart(32, '0');
    // Split into octets and convert each one to decimal
    const ipArray = [];
    for(let i = 0; i < 32; i += 8){
        ipArray.push(parseInt(binaryString.substring(i, i + 8), 2));
    }
    // Join the octets with dots to form the IP address
    return ipArray.join('.');
};
exports.intToIP = intToIP; //# sourceMappingURL=hex2dec.js.map
}),
"[project]/node_modules/@lit-protocol/contracts-sdk/src/abis/Allowlist.sol/AllowlistData.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.AllowlistData = void 0;
exports.AllowlistData = {
    date: '2023-11-14T15:45:41Z',
    address: '0xfc7Bebd150b36921549595A776D7723fBC4Bb2D9',
    contractName: 'Allowlist',
    abi: [
        {
            inputs: [],
            stateMutability: 'nonpayable',
            type: 'constructor'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'newAdmin',
                    type: 'address'
                }
            ],
            name: 'AdminAdded',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'newAdmin',
                    type: 'address'
                }
            ],
            name: 'AdminRemoved',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'bytes32',
                    name: 'key',
                    type: 'bytes32'
                }
            ],
            name: 'ItemAllowed',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'bytes32',
                    name: 'key',
                    type: 'bytes32'
                }
            ],
            name: 'ItemNotAllowed',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'previousOwner',
                    type: 'address'
                },
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'newOwner',
                    type: 'address'
                }
            ],
            name: 'OwnershipTransferred',
            type: 'event'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'newAdmin',
                    type: 'address'
                }
            ],
            name: 'addAdmin',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [],
            name: 'allowAll',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes32',
                    name: '',
                    type: 'bytes32'
                }
            ],
            name: 'allowedItems',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes32',
                    name: 'key',
                    type: 'bytes32'
                }
            ],
            name: 'isAllowed',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'owner',
            outputs: [
                {
                    internalType: 'address',
                    name: '',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'newAdmin',
                    type: 'address'
                }
            ],
            name: 'removeAdmin',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [],
            name: 'renounceOwnership',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bool',
                    name: '_allowAll',
                    type: 'bool'
                }
            ],
            name: 'setAllowAll',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes32',
                    name: 'key',
                    type: 'bytes32'
                }
            ],
            name: 'setAllowed',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes32',
                    name: 'key',
                    type: 'bytes32'
                }
            ],
            name: 'setNotAllowed',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'newOwner',
                    type: 'address'
                }
            ],
            name: 'transferOwnership',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        }
    ]
}; //# sourceMappingURL=AllowlistData.js.map
}),
"[project]/node_modules/@lit-protocol/contracts-sdk/src/abis/LITToken.sol/LITTokenData.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LITTokenData = void 0;
exports.LITTokenData = {
    date: '2023-10-02T18:22:38.000Z',
    address: '0x53695556f8a1a064EdFf91767f15652BbfaFaD04',
    contractName: 'LITToken',
    abi: [
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'cap',
                    type: 'uint256'
                }
            ],
            stateMutability: 'nonpayable',
            type: 'constructor'
        },
        {
            inputs: [],
            name: 'InvalidShortString',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'string',
                    name: 'str',
                    type: 'string'
                }
            ],
            name: 'StringTooLong',
            type: 'error'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'owner',
                    type: 'address'
                },
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'spender',
                    type: 'address'
                },
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'value',
                    type: 'uint256'
                }
            ],
            name: 'Approval',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'delegator',
                    type: 'address'
                },
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'fromDelegate',
                    type: 'address'
                },
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'toDelegate',
                    type: 'address'
                }
            ],
            name: 'DelegateChanged',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'delegate',
                    type: 'address'
                },
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'previousBalance',
                    type: 'uint256'
                },
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'newBalance',
                    type: 'uint256'
                }
            ],
            name: 'DelegateVotesChanged',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [],
            name: 'EIP712DomainChanged',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: false,
                    internalType: 'address',
                    name: 'account',
                    type: 'address'
                }
            ],
            name: 'Paused',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'bytes32',
                    name: 'role',
                    type: 'bytes32'
                },
                {
                    indexed: true,
                    internalType: 'bytes32',
                    name: 'previousAdminRole',
                    type: 'bytes32'
                },
                {
                    indexed: true,
                    internalType: 'bytes32',
                    name: 'newAdminRole',
                    type: 'bytes32'
                }
            ],
            name: 'RoleAdminChanged',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'bytes32',
                    name: 'role',
                    type: 'bytes32'
                },
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'account',
                    type: 'address'
                },
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'sender',
                    type: 'address'
                }
            ],
            name: 'RoleGranted',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'bytes32',
                    name: 'role',
                    type: 'bytes32'
                },
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'account',
                    type: 'address'
                },
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'sender',
                    type: 'address'
                }
            ],
            name: 'RoleRevoked',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'from',
                    type: 'address'
                },
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'to',
                    type: 'address'
                },
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'value',
                    type: 'uint256'
                }
            ],
            name: 'Transfer',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: false,
                    internalType: 'address',
                    name: 'account',
                    type: 'address'
                }
            ],
            name: 'Unpaused',
            type: 'event'
        },
        {
            inputs: [],
            name: 'ADMIN_ROLE',
            outputs: [
                {
                    internalType: 'bytes32',
                    name: '',
                    type: 'bytes32'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'CLOCK_MODE',
            outputs: [
                {
                    internalType: 'string',
                    name: '',
                    type: 'string'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'DEFAULT_ADMIN_ROLE',
            outputs: [
                {
                    internalType: 'bytes32',
                    name: '',
                    type: 'bytes32'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'DOMAIN_SEPARATOR',
            outputs: [
                {
                    internalType: 'bytes32',
                    name: '',
                    type: 'bytes32'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'MINTER_ROLE',
            outputs: [
                {
                    internalType: 'bytes32',
                    name: '',
                    type: 'bytes32'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'PAUSER_ROLE',
            outputs: [
                {
                    internalType: 'bytes32',
                    name: '',
                    type: 'bytes32'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'owner',
                    type: 'address'
                },
                {
                    internalType: 'address',
                    name: 'spender',
                    type: 'address'
                }
            ],
            name: 'allowance',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'spender',
                    type: 'address'
                },
                {
                    internalType: 'uint256',
                    name: 'amount',
                    type: 'uint256'
                }
            ],
            name: 'approve',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'account',
                    type: 'address'
                }
            ],
            name: 'balanceOf',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'amount',
                    type: 'uint256'
                }
            ],
            name: 'burn',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'account',
                    type: 'address'
                },
                {
                    internalType: 'uint256',
                    name: 'amount',
                    type: 'uint256'
                }
            ],
            name: 'burnFrom',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [],
            name: 'cap',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'account',
                    type: 'address'
                },
                {
                    internalType: 'uint32',
                    name: 'pos',
                    type: 'uint32'
                }
            ],
            name: 'checkpoints',
            outputs: [
                {
                    components: [
                        {
                            internalType: 'uint32',
                            name: 'fromBlock',
                            type: 'uint32'
                        },
                        {
                            internalType: 'uint224',
                            name: 'votes',
                            type: 'uint224'
                        }
                    ],
                    internalType: 'struct ERC20Votes.Checkpoint',
                    name: '',
                    type: 'tuple'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'clock',
            outputs: [
                {
                    internalType: 'uint48',
                    name: '',
                    type: 'uint48'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'decimals',
            outputs: [
                {
                    internalType: 'uint8',
                    name: '',
                    type: 'uint8'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'spender',
                    type: 'address'
                },
                {
                    internalType: 'uint256',
                    name: 'subtractedValue',
                    type: 'uint256'
                }
            ],
            name: 'decreaseAllowance',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'delegatee',
                    type: 'address'
                }
            ],
            name: 'delegate',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'delegatee',
                    type: 'address'
                },
                {
                    internalType: 'uint256',
                    name: 'nonce',
                    type: 'uint256'
                },
                {
                    internalType: 'uint256',
                    name: 'expiry',
                    type: 'uint256'
                },
                {
                    internalType: 'uint8',
                    name: 'v',
                    type: 'uint8'
                },
                {
                    internalType: 'bytes32',
                    name: 'r',
                    type: 'bytes32'
                },
                {
                    internalType: 'bytes32',
                    name: 's',
                    type: 'bytes32'
                }
            ],
            name: 'delegateBySig',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'account',
                    type: 'address'
                }
            ],
            name: 'delegates',
            outputs: [
                {
                    internalType: 'address',
                    name: '',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'eip712Domain',
            outputs: [
                {
                    internalType: 'bytes1',
                    name: 'fields',
                    type: 'bytes1'
                },
                {
                    internalType: 'string',
                    name: 'name',
                    type: 'string'
                },
                {
                    internalType: 'string',
                    name: 'version',
                    type: 'string'
                },
                {
                    internalType: 'uint256',
                    name: 'chainId',
                    type: 'uint256'
                },
                {
                    internalType: 'address',
                    name: 'verifyingContract',
                    type: 'address'
                },
                {
                    internalType: 'bytes32',
                    name: 'salt',
                    type: 'bytes32'
                },
                {
                    internalType: 'uint256[]',
                    name: 'extensions',
                    type: 'uint256[]'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'timepoint',
                    type: 'uint256'
                }
            ],
            name: 'getPastTotalSupply',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'account',
                    type: 'address'
                },
                {
                    internalType: 'uint256',
                    name: 'timepoint',
                    type: 'uint256'
                }
            ],
            name: 'getPastVotes',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes32',
                    name: 'role',
                    type: 'bytes32'
                }
            ],
            name: 'getRoleAdmin',
            outputs: [
                {
                    internalType: 'bytes32',
                    name: '',
                    type: 'bytes32'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'account',
                    type: 'address'
                }
            ],
            name: 'getVotes',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes32',
                    name: 'role',
                    type: 'bytes32'
                },
                {
                    internalType: 'address',
                    name: 'account',
                    type: 'address'
                }
            ],
            name: 'grantRole',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes32',
                    name: 'role',
                    type: 'bytes32'
                },
                {
                    internalType: 'address',
                    name: 'account',
                    type: 'address'
                }
            ],
            name: 'hasRole',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'spender',
                    type: 'address'
                },
                {
                    internalType: 'uint256',
                    name: 'addedValue',
                    type: 'uint256'
                }
            ],
            name: 'increaseAllowance',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_recipient',
                    type: 'address'
                },
                {
                    internalType: 'uint256',
                    name: '_amount',
                    type: 'uint256'
                }
            ],
            name: 'mint',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [],
            name: 'name',
            outputs: [
                {
                    internalType: 'string',
                    name: '',
                    type: 'string'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'owner',
                    type: 'address'
                }
            ],
            name: 'nonces',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'account',
                    type: 'address'
                }
            ],
            name: 'numCheckpoints',
            outputs: [
                {
                    internalType: 'uint32',
                    name: '',
                    type: 'uint32'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'pause',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [],
            name: 'paused',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'owner',
                    type: 'address'
                },
                {
                    internalType: 'address',
                    name: 'spender',
                    type: 'address'
                },
                {
                    internalType: 'uint256',
                    name: 'value',
                    type: 'uint256'
                },
                {
                    internalType: 'uint256',
                    name: 'deadline',
                    type: 'uint256'
                },
                {
                    internalType: 'uint8',
                    name: 'v',
                    type: 'uint8'
                },
                {
                    internalType: 'bytes32',
                    name: 'r',
                    type: 'bytes32'
                },
                {
                    internalType: 'bytes32',
                    name: 's',
                    type: 'bytes32'
                }
            ],
            name: 'permit',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes32',
                    name: 'role',
                    type: 'bytes32'
                },
                {
                    internalType: 'address',
                    name: 'account',
                    type: 'address'
                }
            ],
            name: 'renounceRole',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes32',
                    name: 'role',
                    type: 'bytes32'
                },
                {
                    internalType: 'address',
                    name: 'account',
                    type: 'address'
                }
            ],
            name: 'revokeRole',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: 'interfaceId',
                    type: 'bytes4'
                }
            ],
            name: 'supportsInterface',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'symbol',
            outputs: [
                {
                    internalType: 'string',
                    name: '',
                    type: 'string'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'totalSupply',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'to',
                    type: 'address'
                },
                {
                    internalType: 'uint256',
                    name: 'amount',
                    type: 'uint256'
                }
            ],
            name: 'transfer',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'from',
                    type: 'address'
                },
                {
                    internalType: 'address',
                    name: 'to',
                    type: 'address'
                },
                {
                    internalType: 'uint256',
                    name: 'amount',
                    type: 'uint256'
                }
            ],
            name: 'transferFrom',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [],
            name: 'unpause',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        }
    ]
}; //# sourceMappingURL=LITTokenData.js.map
}),
"[project]/node_modules/@lit-protocol/contracts-sdk/src/abis/Multisender.sol/MultisenderData.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MultisenderData = void 0;
exports.MultisenderData = {
    date: '2023-11-14T15:45:41Z',
    address: '0xD4e3D27d21D6D6d596b6524610C486F8A9c70958',
    contractName: 'Multisender',
    abi: [
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'previousOwner',
                    type: 'address'
                },
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'newOwner',
                    type: 'address'
                }
            ],
            name: 'OwnershipTransferred',
            type: 'event'
        },
        {
            inputs: [],
            name: 'owner',
            outputs: [
                {
                    internalType: 'address',
                    name: '',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'renounceOwnership',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address[]',
                    name: '_recipients',
                    type: 'address[]'
                }
            ],
            name: 'sendEth',
            outputs: [],
            stateMutability: 'payable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address[]',
                    name: '_recipients',
                    type: 'address[]'
                },
                {
                    internalType: 'address',
                    name: 'tokenContract',
                    type: 'address'
                }
            ],
            name: 'sendTokens',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'newOwner',
                    type: 'address'
                }
            ],
            name: 'transferOwnership',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [],
            name: 'withdraw',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'tokenContract',
                    type: 'address'
                }
            ],
            name: 'withdrawTokens',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        }
    ]
}; //# sourceMappingURL=MultisenderData.js.map
}),
"[project]/node_modules/@lit-protocol/contracts-sdk/src/abis/PKPHelper.sol/PKPHelperData.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PKPHelperData = void 0;
exports.PKPHelperData = {
    date: '2023-11-14T15:45:41Z',
    address: '0xF02b6D6b0970DB3810963300a6Ad38D8429c4cdb',
    contractName: 'PKPHelper',
    abi: [
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_resolver',
                    type: 'address'
                },
                {
                    internalType: 'enum ContractResolver.Env',
                    name: '_env',
                    type: 'uint8'
                }
            ],
            stateMutability: 'nonpayable',
            type: 'constructor'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: false,
                    internalType: 'address',
                    name: 'newResolverAddress',
                    type: 'address'
                }
            ],
            name: 'ContractResolverAddressSet',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'previousOwner',
                    type: 'address'
                },
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'newOwner',
                    type: 'address'
                }
            ],
            name: 'OwnershipTransferred',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'bytes32',
                    name: 'role',
                    type: 'bytes32'
                },
                {
                    indexed: true,
                    internalType: 'bytes32',
                    name: 'previousAdminRole',
                    type: 'bytes32'
                },
                {
                    indexed: true,
                    internalType: 'bytes32',
                    name: 'newAdminRole',
                    type: 'bytes32'
                }
            ],
            name: 'RoleAdminChanged',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'bytes32',
                    name: 'role',
                    type: 'bytes32'
                },
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'account',
                    type: 'address'
                },
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'sender',
                    type: 'address'
                }
            ],
            name: 'RoleGranted',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'bytes32',
                    name: 'role',
                    type: 'bytes32'
                },
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'account',
                    type: 'address'
                },
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'sender',
                    type: 'address'
                }
            ],
            name: 'RoleRevoked',
            type: 'event'
        },
        {
            inputs: [],
            name: 'DEFAULT_ADMIN_ROLE',
            outputs: [
                {
                    internalType: 'bytes32',
                    name: '',
                    type: 'bytes32'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    components: [
                        {
                            internalType: 'uint256',
                            name: 'keyType',
                            type: 'uint256'
                        },
                        {
                            internalType: 'bytes32',
                            name: 'derivedKeyId',
                            type: 'bytes32'
                        },
                        {
                            components: [
                                {
                                    internalType: 'bytes32',
                                    name: 'r',
                                    type: 'bytes32'
                                },
                                {
                                    internalType: 'bytes32',
                                    name: 's',
                                    type: 'bytes32'
                                },
                                {
                                    internalType: 'uint8',
                                    name: 'v',
                                    type: 'uint8'
                                }
                            ],
                            internalType: 'struct IPubkeyRouter.Signature[]',
                            name: 'signatures',
                            type: 'tuple[]'
                        }
                    ],
                    internalType: 'struct LibPKPNFTStorage.ClaimMaterial',
                    name: 'claimMaterial',
                    type: 'tuple'
                },
                {
                    components: [
                        {
                            internalType: 'uint256',
                            name: 'keyType',
                            type: 'uint256'
                        },
                        {
                            internalType: 'bytes[]',
                            name: 'permittedIpfsCIDs',
                            type: 'bytes[]'
                        },
                        {
                            internalType: 'uint256[][]',
                            name: 'permittedIpfsCIDScopes',
                            type: 'uint256[][]'
                        },
                        {
                            internalType: 'address[]',
                            name: 'permittedAddresses',
                            type: 'address[]'
                        },
                        {
                            internalType: 'uint256[][]',
                            name: 'permittedAddressScopes',
                            type: 'uint256[][]'
                        },
                        {
                            internalType: 'uint256[]',
                            name: 'permittedAuthMethodTypes',
                            type: 'uint256[]'
                        },
                        {
                            internalType: 'bytes[]',
                            name: 'permittedAuthMethodIds',
                            type: 'bytes[]'
                        },
                        {
                            internalType: 'bytes[]',
                            name: 'permittedAuthMethodPubkeys',
                            type: 'bytes[]'
                        },
                        {
                            internalType: 'uint256[][]',
                            name: 'permittedAuthMethodScopes',
                            type: 'uint256[][]'
                        },
                        {
                            internalType: 'bool',
                            name: 'addPkpEthAddressAsPermittedAddress',
                            type: 'bool'
                        },
                        {
                            internalType: 'bool',
                            name: 'sendPkpToItself',
                            type: 'bool'
                        }
                    ],
                    internalType: 'struct PKPHelper.AuthMethodData',
                    name: 'authMethodData',
                    type: 'tuple'
                }
            ],
            name: 'claimAndMintNextAndAddAuthMethods',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'payable',
            type: 'function'
        },
        {
            inputs: [
                {
                    components: [
                        {
                            internalType: 'uint256',
                            name: 'keyType',
                            type: 'uint256'
                        },
                        {
                            internalType: 'bytes32',
                            name: 'derivedKeyId',
                            type: 'bytes32'
                        },
                        {
                            components: [
                                {
                                    internalType: 'bytes32',
                                    name: 'r',
                                    type: 'bytes32'
                                },
                                {
                                    internalType: 'bytes32',
                                    name: 's',
                                    type: 'bytes32'
                                },
                                {
                                    internalType: 'uint8',
                                    name: 'v',
                                    type: 'uint8'
                                }
                            ],
                            internalType: 'struct IPubkeyRouter.Signature[]',
                            name: 'signatures',
                            type: 'tuple[]'
                        }
                    ],
                    internalType: 'struct LibPKPNFTStorage.ClaimMaterial',
                    name: 'claimMaterial',
                    type: 'tuple'
                },
                {
                    components: [
                        {
                            internalType: 'uint256',
                            name: 'keyType',
                            type: 'uint256'
                        },
                        {
                            internalType: 'bytes[]',
                            name: 'permittedIpfsCIDs',
                            type: 'bytes[]'
                        },
                        {
                            internalType: 'uint256[][]',
                            name: 'permittedIpfsCIDScopes',
                            type: 'uint256[][]'
                        },
                        {
                            internalType: 'address[]',
                            name: 'permittedAddresses',
                            type: 'address[]'
                        },
                        {
                            internalType: 'uint256[][]',
                            name: 'permittedAddressScopes',
                            type: 'uint256[][]'
                        },
                        {
                            internalType: 'uint256[]',
                            name: 'permittedAuthMethodTypes',
                            type: 'uint256[]'
                        },
                        {
                            internalType: 'bytes[]',
                            name: 'permittedAuthMethodIds',
                            type: 'bytes[]'
                        },
                        {
                            internalType: 'bytes[]',
                            name: 'permittedAuthMethodPubkeys',
                            type: 'bytes[]'
                        },
                        {
                            internalType: 'uint256[][]',
                            name: 'permittedAuthMethodScopes',
                            type: 'uint256[][]'
                        },
                        {
                            internalType: 'bool',
                            name: 'addPkpEthAddressAsPermittedAddress',
                            type: 'bool'
                        },
                        {
                            internalType: 'bool',
                            name: 'sendPkpToItself',
                            type: 'bool'
                        }
                    ],
                    internalType: 'struct PKPHelper.AuthMethodData',
                    name: 'authMethodData',
                    type: 'tuple'
                }
            ],
            name: 'claimAndMintNextAndAddAuthMethodsWithTypes',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'payable',
            type: 'function'
        },
        {
            inputs: [],
            name: 'contractResolver',
            outputs: [
                {
                    internalType: 'contract ContractResolver',
                    name: '',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'env',
            outputs: [
                {
                    internalType: 'enum ContractResolver.Env',
                    name: '',
                    type: 'uint8'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'getDomainWalletRegistry',
            outputs: [
                {
                    internalType: 'address',
                    name: '',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'getPKPNftMetdataAddress',
            outputs: [
                {
                    internalType: 'address',
                    name: '',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'getPkpNftAddress',
            outputs: [
                {
                    internalType: 'address',
                    name: '',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'getPkpPermissionsAddress',
            outputs: [
                {
                    internalType: 'address',
                    name: '',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes32',
                    name: 'role',
                    type: 'bytes32'
                }
            ],
            name: 'getRoleAdmin',
            outputs: [
                {
                    internalType: 'bytes32',
                    name: '',
                    type: 'bytes32'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes32',
                    name: 'role',
                    type: 'bytes32'
                },
                {
                    internalType: 'address',
                    name: 'account',
                    type: 'address'
                }
            ],
            name: 'grantRole',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes32',
                    name: 'role',
                    type: 'bytes32'
                },
                {
                    internalType: 'address',
                    name: 'account',
                    type: 'address'
                }
            ],
            name: 'hasRole',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'keyType',
                    type: 'uint256'
                },
                {
                    internalType: 'uint256[]',
                    name: 'permittedAuthMethodTypes',
                    type: 'uint256[]'
                },
                {
                    internalType: 'bytes[]',
                    name: 'permittedAuthMethodIds',
                    type: 'bytes[]'
                },
                {
                    internalType: 'bytes[]',
                    name: 'permittedAuthMethodPubkeys',
                    type: 'bytes[]'
                },
                {
                    internalType: 'uint256[][]',
                    name: 'permittedAuthMethodScopes',
                    type: 'uint256[][]'
                },
                {
                    internalType: 'bool',
                    name: 'addPkpEthAddressAsPermittedAddress',
                    type: 'bool'
                },
                {
                    internalType: 'bool',
                    name: 'sendPkpToItself',
                    type: 'bool'
                }
            ],
            name: 'mintNextAndAddAuthMethods',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'payable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'keyType',
                    type: 'uint256'
                },
                {
                    internalType: 'bytes[]',
                    name: 'permittedIpfsCIDs',
                    type: 'bytes[]'
                },
                {
                    internalType: 'uint256[][]',
                    name: 'permittedIpfsCIDScopes',
                    type: 'uint256[][]'
                },
                {
                    internalType: 'address[]',
                    name: 'permittedAddresses',
                    type: 'address[]'
                },
                {
                    internalType: 'uint256[][]',
                    name: 'permittedAddressScopes',
                    type: 'uint256[][]'
                },
                {
                    internalType: 'uint256[]',
                    name: 'permittedAuthMethodTypes',
                    type: 'uint256[]'
                },
                {
                    internalType: 'bytes[]',
                    name: 'permittedAuthMethodIds',
                    type: 'bytes[]'
                },
                {
                    internalType: 'bytes[]',
                    name: 'permittedAuthMethodPubkeys',
                    type: 'bytes[]'
                },
                {
                    internalType: 'uint256[][]',
                    name: 'permittedAuthMethodScopes',
                    type: 'uint256[][]'
                },
                {
                    internalType: 'bool',
                    name: 'addPkpEthAddressAsPermittedAddress',
                    type: 'bool'
                },
                {
                    internalType: 'bool',
                    name: 'sendPkpToItself',
                    type: 'bool'
                }
            ],
            name: 'mintNextAndAddAuthMethodsWithTypes',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'payable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'keyType',
                    type: 'uint256'
                },
                {
                    internalType: 'uint256[]',
                    name: 'permittedAuthMethodTypes',
                    type: 'uint256[]'
                },
                {
                    internalType: 'bytes[]',
                    name: 'permittedAuthMethodIds',
                    type: 'bytes[]'
                },
                {
                    internalType: 'bytes[]',
                    name: 'permittedAuthMethodPubkeys',
                    type: 'bytes[]'
                },
                {
                    internalType: 'uint256[][]',
                    name: 'permittedAuthMethodScopes',
                    type: 'uint256[][]'
                },
                {
                    internalType: 'string[]',
                    name: 'nftMetadata',
                    type: 'string[]'
                },
                {
                    internalType: 'bool',
                    name: 'addPkpEthAddressAsPermittedAddress',
                    type: 'bool'
                },
                {
                    internalType: 'bool',
                    name: 'sendPkpToItself',
                    type: 'bool'
                }
            ],
            name: 'mintNextAndAddDomainWalletMetadata',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'payable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '',
                    type: 'address'
                },
                {
                    internalType: 'address',
                    name: '',
                    type: 'address'
                },
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                },
                {
                    internalType: 'bytes',
                    name: '',
                    type: 'bytes'
                }
            ],
            name: 'onERC721Received',
            outputs: [
                {
                    internalType: 'bytes4',
                    name: '',
                    type: 'bytes4'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'owner',
            outputs: [
                {
                    internalType: 'address',
                    name: '',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                }
            ],
            name: 'removePkpMetadata',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [],
            name: 'renounceOwnership',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes32',
                    name: 'role',
                    type: 'bytes32'
                },
                {
                    internalType: 'address',
                    name: 'account',
                    type: 'address'
                }
            ],
            name: 'renounceRole',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes32',
                    name: 'role',
                    type: 'bytes32'
                },
                {
                    internalType: 'address',
                    name: 'account',
                    type: 'address'
                }
            ],
            name: 'revokeRole',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'newResolverAddress',
                    type: 'address'
                }
            ],
            name: 'setContractResolver',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                },
                {
                    internalType: 'string[]',
                    name: 'nftMetadata',
                    type: 'string[]'
                }
            ],
            name: 'setPkpMetadata',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: 'interfaceId',
                    type: 'bytes4'
                }
            ],
            name: 'supportsInterface',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'newOwner',
                    type: 'address'
                }
            ],
            name: 'transferOwnership',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        }
    ]
}; //# sourceMappingURL=PKPHelperData.js.map
}),
"[project]/node_modules/@lit-protocol/contracts-sdk/src/abis/PKPNFT.sol/PKPNFTData.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PKPNFTData = void 0;
exports.PKPNFTData = {
    date: '2023-11-14T15:45:41Z',
    address: '0x58582b93d978F30b4c4E812A16a7b31C035A69f7',
    contractName: 'PKPNFT',
    abi: [
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_selector',
                    type: 'bytes4'
                }
            ],
            name: 'CannotAddFunctionToDiamondThatAlreadyExists',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4[]',
                    name: '_selectors',
                    type: 'bytes4[]'
                }
            ],
            name: 'CannotAddSelectorsToZeroAddress',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_selector',
                    type: 'bytes4'
                }
            ],
            name: 'CannotRemoveFunctionThatDoesNotExist',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_selector',
                    type: 'bytes4'
                }
            ],
            name: 'CannotRemoveImmutableFunction',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_selector',
                    type: 'bytes4'
                }
            ],
            name: 'CannotReplaceFunctionThatDoesNotExists',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_selector',
                    type: 'bytes4'
                }
            ],
            name: 'CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4[]',
                    name: '_selectors',
                    type: 'bytes4[]'
                }
            ],
            name: 'CannotReplaceFunctionsFromFacetWithZeroAddress',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_selector',
                    type: 'bytes4'
                }
            ],
            name: 'CannotReplaceImmutableFunction',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'uint8',
                    name: '_action',
                    type: 'uint8'
                }
            ],
            name: 'IncorrectFacetCutAction',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_initializationContractAddress',
                    type: 'address'
                },
                {
                    internalType: 'bytes',
                    name: '_calldata',
                    type: 'bytes'
                }
            ],
            name: 'InitializationFunctionReverted',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_contractAddress',
                    type: 'address'
                },
                {
                    internalType: 'string',
                    name: '_message',
                    type: 'string'
                }
            ],
            name: 'NoBytecodeAtAddress',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_facetAddress',
                    type: 'address'
                }
            ],
            name: 'NoSelectorsProvidedForFacetForCut',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_user',
                    type: 'address'
                },
                {
                    internalType: 'address',
                    name: '_contractOwner',
                    type: 'address'
                }
            ],
            name: 'NotContractOwner',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_facetAddress',
                    type: 'address'
                }
            ],
            name: 'RemoveFacetAddressMustBeZeroAddress',
            type: 'error'
        },
        {
            anonymous: false,
            inputs: [
                {
                    components: [
                        {
                            internalType: 'address',
                            name: 'facetAddress',
                            type: 'address'
                        },
                        {
                            internalType: 'enum IDiamond.FacetCutAction',
                            name: 'action',
                            type: 'uint8'
                        },
                        {
                            internalType: 'bytes4[]',
                            name: 'functionSelectors',
                            type: 'bytes4[]'
                        }
                    ],
                    indexed: false,
                    internalType: 'struct IDiamond.FacetCut[]',
                    name: '_diamondCut',
                    type: 'tuple[]'
                },
                {
                    indexed: false,
                    internalType: 'address',
                    name: '_init',
                    type: 'address'
                },
                {
                    indexed: false,
                    internalType: 'bytes',
                    name: '_calldata',
                    type: 'bytes'
                }
            ],
            name: 'DiamondCut',
            type: 'event'
        },
        {
            inputs: [
                {
                    components: [
                        {
                            internalType: 'address',
                            name: 'facetAddress',
                            type: 'address'
                        },
                        {
                            internalType: 'enum IDiamond.FacetCutAction',
                            name: 'action',
                            type: 'uint8'
                        },
                        {
                            internalType: 'bytes4[]',
                            name: 'functionSelectors',
                            type: 'bytes4[]'
                        }
                    ],
                    internalType: 'struct IDiamond.FacetCut[]',
                    name: '_diamondCut',
                    type: 'tuple[]'
                },
                {
                    internalType: 'address',
                    name: '_init',
                    type: 'address'
                },
                {
                    internalType: 'bytes',
                    name: '_calldata',
                    type: 'bytes'
                }
            ],
            name: 'diamondCut',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_functionSelector',
                    type: 'bytes4'
                }
            ],
            name: 'facetAddress',
            outputs: [
                {
                    internalType: 'address',
                    name: 'facetAddress_',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'facetAddresses',
            outputs: [
                {
                    internalType: 'address[]',
                    name: 'facetAddresses_',
                    type: 'address[]'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_facet',
                    type: 'address'
                }
            ],
            name: 'facetFunctionSelectors',
            outputs: [
                {
                    internalType: 'bytes4[]',
                    name: '_facetFunctionSelectors',
                    type: 'bytes4[]'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'facets',
            outputs: [
                {
                    components: [
                        {
                            internalType: 'address',
                            name: 'facetAddress',
                            type: 'address'
                        },
                        {
                            internalType: 'bytes4[]',
                            name: 'functionSelectors',
                            type: 'bytes4[]'
                        }
                    ],
                    internalType: 'struct IDiamondLoupe.Facet[]',
                    name: 'facets_',
                    type: 'tuple[]'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'previousOwner',
                    type: 'address'
                },
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'newOwner',
                    type: 'address'
                }
            ],
            name: 'OwnershipTransferred',
            type: 'event'
        },
        {
            inputs: [],
            name: 'owner',
            outputs: [
                {
                    internalType: 'address',
                    name: 'owner_',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_newOwner',
                    type: 'address'
                }
            ],
            name: 'transferOwnership',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [],
            name: 'CallerNotOwner',
            type: 'error'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'owner',
                    type: 'address'
                },
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'approved',
                    type: 'address'
                },
                {
                    indexed: true,
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                }
            ],
            name: 'Approval',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'owner',
                    type: 'address'
                },
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'operator',
                    type: 'address'
                },
                {
                    indexed: false,
                    internalType: 'bool',
                    name: 'approved',
                    type: 'bool'
                }
            ],
            name: 'ApprovalForAll',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: false,
                    internalType: 'address',
                    name: 'newResolverAddress',
                    type: 'address'
                }
            ],
            name: 'ContractResolverAddressSet',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'newFreeMintSigner',
                    type: 'address'
                }
            ],
            name: 'FreeMintSignerSet',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: false,
                    internalType: 'uint8',
                    name: 'version',
                    type: 'uint8'
                }
            ],
            name: 'Initialized',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'newMintCost',
                    type: 'uint256'
                }
            ],
            name: 'MintCostSet',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                },
                {
                    indexed: false,
                    internalType: 'bytes',
                    name: 'pubkey',
                    type: 'bytes'
                }
            ],
            name: 'PKPMinted',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'from',
                    type: 'address'
                },
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'to',
                    type: 'address'
                },
                {
                    indexed: true,
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                }
            ],
            name: 'Transfer',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'amount',
                    type: 'uint256'
                }
            ],
            name: 'Withdrew',
            type: 'event'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'to',
                    type: 'address'
                },
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                }
            ],
            name: 'approve',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'owner',
                    type: 'address'
                }
            ],
            name: 'balanceOf',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                }
            ],
            name: 'burn',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'keyType',
                    type: 'uint256'
                },
                {
                    internalType: 'bytes32',
                    name: 'derivedKeyId',
                    type: 'bytes32'
                },
                {
                    components: [
                        {
                            internalType: 'bytes32',
                            name: 'r',
                            type: 'bytes32'
                        },
                        {
                            internalType: 'bytes32',
                            name: 's',
                            type: 'bytes32'
                        },
                        {
                            internalType: 'uint8',
                            name: 'v',
                            type: 'uint8'
                        }
                    ],
                    internalType: 'struct IPubkeyRouter.Signature[]',
                    name: 'signatures',
                    type: 'tuple[]'
                }
            ],
            name: 'claimAndMint',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'payable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                }
            ],
            name: 'exists',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'freeMintSigner',
            outputs: [
                {
                    internalType: 'address',
                    name: '',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                }
            ],
            name: 'getApproved',
            outputs: [
                {
                    internalType: 'address',
                    name: '',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                }
            ],
            name: 'getEthAddress',
            outputs: [
                {
                    internalType: 'address',
                    name: '',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'getNextDerivedKeyId',
            outputs: [
                {
                    internalType: 'bytes32',
                    name: '',
                    type: 'bytes32'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'getPkpNftMetadataAddress',
            outputs: [
                {
                    internalType: 'address',
                    name: '',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'getPkpPermissionsAddress',
            outputs: [
                {
                    internalType: 'address',
                    name: '',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                }
            ],
            name: 'getPubkey',
            outputs: [
                {
                    internalType: 'bytes',
                    name: '',
                    type: 'bytes'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'getRouterAddress',
            outputs: [
                {
                    internalType: 'address',
                    name: '',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'getStakingAddress',
            outputs: [
                {
                    internalType: 'address',
                    name: '',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'initialize',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'owner',
                    type: 'address'
                },
                {
                    internalType: 'address',
                    name: 'operator',
                    type: 'address'
                }
            ],
            name: 'isApprovedForAll',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'mintCost',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'keyType',
                    type: 'uint256'
                },
                {
                    internalType: 'bytes',
                    name: 'ipfsCID',
                    type: 'bytes'
                }
            ],
            name: 'mintGrantAndBurnNext',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'payable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'keyType',
                    type: 'uint256'
                }
            ],
            name: 'mintNext',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'payable',
            type: 'function'
        },
        {
            inputs: [],
            name: 'name',
            outputs: [
                {
                    internalType: 'string',
                    name: '',
                    type: 'string'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                }
            ],
            name: 'ownerOf',
            outputs: [
                {
                    internalType: 'address',
                    name: '',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes32',
                    name: 'hash',
                    type: 'bytes32'
                }
            ],
            name: 'prefixed',
            outputs: [
                {
                    internalType: 'bytes32',
                    name: '',
                    type: 'bytes32'
                }
            ],
            stateMutability: 'pure',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                }
            ],
            name: 'redeemedFreeMintIds',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'from',
                    type: 'address'
                },
                {
                    internalType: 'address',
                    name: 'to',
                    type: 'address'
                },
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                }
            ],
            name: 'safeTransferFrom',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'from',
                    type: 'address'
                },
                {
                    internalType: 'address',
                    name: 'to',
                    type: 'address'
                },
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                },
                {
                    internalType: 'bytes',
                    name: 'data',
                    type: 'bytes'
                }
            ],
            name: 'safeTransferFrom',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'operator',
                    type: 'address'
                },
                {
                    internalType: 'bool',
                    name: 'approved',
                    type: 'bool'
                }
            ],
            name: 'setApprovalForAll',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'newResolverAddress',
                    type: 'address'
                }
            ],
            name: 'setContractResolver',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'newFreeMintSigner',
                    type: 'address'
                }
            ],
            name: 'setFreeMintSigner',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'newMintCost',
                    type: 'uint256'
                }
            ],
            name: 'setMintCost',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: 'interfaceId',
                    type: 'bytes4'
                }
            ],
            name: 'supportsInterface',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'symbol',
            outputs: [
                {
                    internalType: 'string',
                    name: '',
                    type: 'string'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'index',
                    type: 'uint256'
                }
            ],
            name: 'tokenByIndex',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'owner',
                    type: 'address'
                },
                {
                    internalType: 'uint256',
                    name: 'index',
                    type: 'uint256'
                }
            ],
            name: 'tokenOfOwnerByIndex',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                }
            ],
            name: 'tokenURI',
            outputs: [
                {
                    internalType: 'string',
                    name: '',
                    type: 'string'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'totalSupply',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'from',
                    type: 'address'
                },
                {
                    internalType: 'address',
                    name: 'to',
                    type: 'address'
                },
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                }
            ],
            name: 'transferFrom',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [],
            name: 'withdraw',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        }
    ]
}; //# sourceMappingURL=PKPNFTData.js.map
}),
"[project]/node_modules/@lit-protocol/contracts-sdk/src/abis/PKPNFTMetadata.sol/PKPNFTMetadataData.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PKPNFTMetadataData = void 0;
exports.PKPNFTMetadataData = {
    date: '2023-11-14T15:45:41Z',
    address: '0xeD46dDcbFF662ad89b0987E0DFE2949901498Da6',
    contractName: 'PKPNFTMetadata',
    abi: [
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_resolver',
                    type: 'address'
                },
                {
                    internalType: 'enum ContractResolver.Env',
                    name: '_env',
                    type: 'uint8'
                }
            ],
            stateMutability: 'nonpayable',
            type: 'constructor'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'bytes32',
                    name: 'role',
                    type: 'bytes32'
                },
                {
                    indexed: true,
                    internalType: 'bytes32',
                    name: 'previousAdminRole',
                    type: 'bytes32'
                },
                {
                    indexed: true,
                    internalType: 'bytes32',
                    name: 'newAdminRole',
                    type: 'bytes32'
                }
            ],
            name: 'RoleAdminChanged',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'bytes32',
                    name: 'role',
                    type: 'bytes32'
                },
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'account',
                    type: 'address'
                },
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'sender',
                    type: 'address'
                }
            ],
            name: 'RoleGranted',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'bytes32',
                    name: 'role',
                    type: 'bytes32'
                },
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'account',
                    type: 'address'
                },
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'sender',
                    type: 'address'
                }
            ],
            name: 'RoleRevoked',
            type: 'event'
        },
        {
            inputs: [],
            name: 'ADMIN_ROLE',
            outputs: [
                {
                    internalType: 'bytes32',
                    name: '',
                    type: 'bytes32'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'DEFAULT_ADMIN_ROLE',
            outputs: [
                {
                    internalType: 'bytes32',
                    name: '',
                    type: 'bytes32'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'WRITER_ROLE',
            outputs: [
                {
                    internalType: 'bytes32',
                    name: '',
                    type: 'bytes32'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes',
                    name: 'buffer',
                    type: 'bytes'
                }
            ],
            name: 'bytesToHex',
            outputs: [
                {
                    internalType: 'string',
                    name: '',
                    type: 'string'
                }
            ],
            stateMutability: 'pure',
            type: 'function'
        },
        {
            inputs: [],
            name: 'contractResolver',
            outputs: [
                {
                    internalType: 'contract ContractResolver',
                    name: '',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'env',
            outputs: [
                {
                    internalType: 'enum ContractResolver.Env',
                    name: '',
                    type: 'uint8'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes32',
                    name: 'role',
                    type: 'bytes32'
                }
            ],
            name: 'getRoleAdmin',
            outputs: [
                {
                    internalType: 'bytes32',
                    name: '',
                    type: 'bytes32'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes32',
                    name: 'role',
                    type: 'bytes32'
                },
                {
                    internalType: 'address',
                    name: 'account',
                    type: 'address'
                }
            ],
            name: 'grantRole',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes32',
                    name: 'role',
                    type: 'bytes32'
                },
                {
                    internalType: 'address',
                    name: 'account',
                    type: 'address'
                }
            ],
            name: 'hasRole',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                }
            ],
            name: 'removeProfileForPkp',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                }
            ],
            name: 'removeUrlForPKP',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes32',
                    name: 'role',
                    type: 'bytes32'
                },
                {
                    internalType: 'address',
                    name: 'account',
                    type: 'address'
                }
            ],
            name: 'renounceRole',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes32',
                    name: 'role',
                    type: 'bytes32'
                },
                {
                    internalType: 'address',
                    name: 'account',
                    type: 'address'
                }
            ],
            name: 'revokeRole',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'pkpHelperWriterAddress',
                    type: 'address'
                }
            ],
            name: 'setPKPHelperWriterAddress',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                },
                {
                    internalType: 'string',
                    name: 'imgUrl',
                    type: 'string'
                }
            ],
            name: 'setProfileForPKP',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                },
                {
                    internalType: 'string',
                    name: 'url',
                    type: 'string'
                }
            ],
            name: 'setUrlForPKP',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: 'interfaceId',
                    type: 'bytes4'
                }
            ],
            name: 'supportsInterface',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                },
                {
                    internalType: 'bytes',
                    name: 'pubKey',
                    type: 'bytes'
                },
                {
                    internalType: 'address',
                    name: 'ethAddress',
                    type: 'address'
                }
            ],
            name: 'tokenURI',
            outputs: [
                {
                    internalType: 'string',
                    name: '',
                    type: 'string'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        }
    ]
}; //# sourceMappingURL=PKPNFTMetadataData.js.map
}),
"[project]/node_modules/@lit-protocol/contracts-sdk/src/abis/PKPPermissions.sol/PKPPermissionsData.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PKPPermissionsData = void 0;
exports.PKPPermissionsData = {
    date: '2023-11-14T15:45:41Z',
    address: '0xD01c9C30f8F6fa443721629775e1CC7DD9c9e209',
    contractName: 'PKPPermissions',
    abi: [
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_selector',
                    type: 'bytes4'
                }
            ],
            name: 'CannotAddFunctionToDiamondThatAlreadyExists',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4[]',
                    name: '_selectors',
                    type: 'bytes4[]'
                }
            ],
            name: 'CannotAddSelectorsToZeroAddress',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_selector',
                    type: 'bytes4'
                }
            ],
            name: 'CannotRemoveFunctionThatDoesNotExist',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_selector',
                    type: 'bytes4'
                }
            ],
            name: 'CannotRemoveImmutableFunction',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_selector',
                    type: 'bytes4'
                }
            ],
            name: 'CannotReplaceFunctionThatDoesNotExists',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_selector',
                    type: 'bytes4'
                }
            ],
            name: 'CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4[]',
                    name: '_selectors',
                    type: 'bytes4[]'
                }
            ],
            name: 'CannotReplaceFunctionsFromFacetWithZeroAddress',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_selector',
                    type: 'bytes4'
                }
            ],
            name: 'CannotReplaceImmutableFunction',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'uint8',
                    name: '_action',
                    type: 'uint8'
                }
            ],
            name: 'IncorrectFacetCutAction',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_initializationContractAddress',
                    type: 'address'
                },
                {
                    internalType: 'bytes',
                    name: '_calldata',
                    type: 'bytes'
                }
            ],
            name: 'InitializationFunctionReverted',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_contractAddress',
                    type: 'address'
                },
                {
                    internalType: 'string',
                    name: '_message',
                    type: 'string'
                }
            ],
            name: 'NoBytecodeAtAddress',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_facetAddress',
                    type: 'address'
                }
            ],
            name: 'NoSelectorsProvidedForFacetForCut',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_user',
                    type: 'address'
                },
                {
                    internalType: 'address',
                    name: '_contractOwner',
                    type: 'address'
                }
            ],
            name: 'NotContractOwner',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_facetAddress',
                    type: 'address'
                }
            ],
            name: 'RemoveFacetAddressMustBeZeroAddress',
            type: 'error'
        },
        {
            anonymous: false,
            inputs: [
                {
                    components: [
                        {
                            internalType: 'address',
                            name: 'facetAddress',
                            type: 'address'
                        },
                        {
                            internalType: 'enum IDiamond.FacetCutAction',
                            name: 'action',
                            type: 'uint8'
                        },
                        {
                            internalType: 'bytes4[]',
                            name: 'functionSelectors',
                            type: 'bytes4[]'
                        }
                    ],
                    indexed: false,
                    internalType: 'struct IDiamond.FacetCut[]',
                    name: '_diamondCut',
                    type: 'tuple[]'
                },
                {
                    indexed: false,
                    internalType: 'address',
                    name: '_init',
                    type: 'address'
                },
                {
                    indexed: false,
                    internalType: 'bytes',
                    name: '_calldata',
                    type: 'bytes'
                }
            ],
            name: 'DiamondCut',
            type: 'event'
        },
        {
            inputs: [
                {
                    components: [
                        {
                            internalType: 'address',
                            name: 'facetAddress',
                            type: 'address'
                        },
                        {
                            internalType: 'enum IDiamond.FacetCutAction',
                            name: 'action',
                            type: 'uint8'
                        },
                        {
                            internalType: 'bytes4[]',
                            name: 'functionSelectors',
                            type: 'bytes4[]'
                        }
                    ],
                    internalType: 'struct IDiamond.FacetCut[]',
                    name: '_diamondCut',
                    type: 'tuple[]'
                },
                {
                    internalType: 'address',
                    name: '_init',
                    type: 'address'
                },
                {
                    internalType: 'bytes',
                    name: '_calldata',
                    type: 'bytes'
                }
            ],
            name: 'diamondCut',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_functionSelector',
                    type: 'bytes4'
                }
            ],
            name: 'facetAddress',
            outputs: [
                {
                    internalType: 'address',
                    name: 'facetAddress_',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'facetAddresses',
            outputs: [
                {
                    internalType: 'address[]',
                    name: 'facetAddresses_',
                    type: 'address[]'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_facet',
                    type: 'address'
                }
            ],
            name: 'facetFunctionSelectors',
            outputs: [
                {
                    internalType: 'bytes4[]',
                    name: '_facetFunctionSelectors',
                    type: 'bytes4[]'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'facets',
            outputs: [
                {
                    components: [
                        {
                            internalType: 'address',
                            name: 'facetAddress',
                            type: 'address'
                        },
                        {
                            internalType: 'bytes4[]',
                            name: 'functionSelectors',
                            type: 'bytes4[]'
                        }
                    ],
                    internalType: 'struct IDiamondLoupe.Facet[]',
                    name: 'facets_',
                    type: 'tuple[]'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_interfaceId',
                    type: 'bytes4'
                }
            ],
            name: 'supportsInterface',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'previousOwner',
                    type: 'address'
                },
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'newOwner',
                    type: 'address'
                }
            ],
            name: 'OwnershipTransferred',
            type: 'event'
        },
        {
            inputs: [],
            name: 'owner',
            outputs: [
                {
                    internalType: 'address',
                    name: 'owner_',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_newOwner',
                    type: 'address'
                }
            ],
            name: 'transferOwnership',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [],
            name: 'CallerNotOwner',
            type: 'error'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: false,
                    internalType: 'address',
                    name: 'newResolverAddress',
                    type: 'address'
                }
            ],
            name: 'ContractResolverAddressSet',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                },
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'authMethodType',
                    type: 'uint256'
                },
                {
                    indexed: false,
                    internalType: 'bytes',
                    name: 'id',
                    type: 'bytes'
                },
                {
                    indexed: false,
                    internalType: 'bytes',
                    name: 'userPubkey',
                    type: 'bytes'
                }
            ],
            name: 'PermittedAuthMethodAdded',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                },
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'authMethodType',
                    type: 'uint256'
                },
                {
                    indexed: false,
                    internalType: 'bytes',
                    name: 'id',
                    type: 'bytes'
                }
            ],
            name: 'PermittedAuthMethodRemoved',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                },
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'authMethodType',
                    type: 'uint256'
                },
                {
                    indexed: false,
                    internalType: 'bytes',
                    name: 'id',
                    type: 'bytes'
                },
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'scopeId',
                    type: 'uint256'
                }
            ],
            name: 'PermittedAuthMethodScopeAdded',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                },
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'authMethodType',
                    type: 'uint256'
                },
                {
                    indexed: false,
                    internalType: 'bytes',
                    name: 'id',
                    type: 'bytes'
                },
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'scopeId',
                    type: 'uint256'
                }
            ],
            name: 'PermittedAuthMethodScopeRemoved',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                },
                {
                    indexed: true,
                    internalType: 'uint256',
                    name: 'group',
                    type: 'uint256'
                },
                {
                    indexed: false,
                    internalType: 'bytes32',
                    name: 'root',
                    type: 'bytes32'
                }
            ],
            name: 'RootHashUpdated',
            type: 'event'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                },
                {
                    internalType: 'bytes',
                    name: 'ipfsCID',
                    type: 'bytes'
                },
                {
                    internalType: 'uint256[]',
                    name: 'scopes',
                    type: 'uint256[]'
                }
            ],
            name: 'addPermittedAction',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                },
                {
                    internalType: 'address',
                    name: 'user',
                    type: 'address'
                },
                {
                    internalType: 'uint256[]',
                    name: 'scopes',
                    type: 'uint256[]'
                }
            ],
            name: 'addPermittedAddress',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                },
                {
                    components: [
                        {
                            internalType: 'uint256',
                            name: 'authMethodType',
                            type: 'uint256'
                        },
                        {
                            internalType: 'bytes',
                            name: 'id',
                            type: 'bytes'
                        },
                        {
                            internalType: 'bytes',
                            name: 'userPubkey',
                            type: 'bytes'
                        }
                    ],
                    internalType: 'struct LibPKPPermissionsStorage.AuthMethod',
                    name: 'authMethod',
                    type: 'tuple'
                },
                {
                    internalType: 'uint256[]',
                    name: 'scopes',
                    type: 'uint256[]'
                }
            ],
            name: 'addPermittedAuthMethod',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                },
                {
                    internalType: 'uint256',
                    name: 'authMethodType',
                    type: 'uint256'
                },
                {
                    internalType: 'bytes',
                    name: 'id',
                    type: 'bytes'
                },
                {
                    internalType: 'uint256',
                    name: 'scopeId',
                    type: 'uint256'
                }
            ],
            name: 'addPermittedAuthMethodScope',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                },
                {
                    internalType: 'uint256[]',
                    name: 'permittedAuthMethodTypesToAdd',
                    type: 'uint256[]'
                },
                {
                    internalType: 'bytes[]',
                    name: 'permittedAuthMethodIdsToAdd',
                    type: 'bytes[]'
                },
                {
                    internalType: 'bytes[]',
                    name: 'permittedAuthMethodPubkeysToAdd',
                    type: 'bytes[]'
                },
                {
                    internalType: 'uint256[][]',
                    name: 'permittedAuthMethodScopesToAdd',
                    type: 'uint256[][]'
                },
                {
                    internalType: 'uint256[]',
                    name: 'permittedAuthMethodTypesToRemove',
                    type: 'uint256[]'
                },
                {
                    internalType: 'bytes[]',
                    name: 'permittedAuthMethodIdsToRemove',
                    type: 'bytes[]'
                }
            ],
            name: 'batchAddRemoveAuthMethods',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'authMethodType',
                    type: 'uint256'
                },
                {
                    internalType: 'bytes',
                    name: 'id',
                    type: 'bytes'
                }
            ],
            name: 'getAuthMethodId',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'pure',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                }
            ],
            name: 'getEthAddress',
            outputs: [
                {
                    internalType: 'address',
                    name: '',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                }
            ],
            name: 'getPermittedActions',
            outputs: [
                {
                    internalType: 'bytes[]',
                    name: '',
                    type: 'bytes[]'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                }
            ],
            name: 'getPermittedAddresses',
            outputs: [
                {
                    internalType: 'address[]',
                    name: '',
                    type: 'address[]'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                },
                {
                    internalType: 'uint256',
                    name: 'authMethodType',
                    type: 'uint256'
                },
                {
                    internalType: 'bytes',
                    name: 'id',
                    type: 'bytes'
                },
                {
                    internalType: 'uint256',
                    name: 'maxScopeId',
                    type: 'uint256'
                }
            ],
            name: 'getPermittedAuthMethodScopes',
            outputs: [
                {
                    internalType: 'bool[]',
                    name: '',
                    type: 'bool[]'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                }
            ],
            name: 'getPermittedAuthMethods',
            outputs: [
                {
                    components: [
                        {
                            internalType: 'uint256',
                            name: 'authMethodType',
                            type: 'uint256'
                        },
                        {
                            internalType: 'bytes',
                            name: 'id',
                            type: 'bytes'
                        },
                        {
                            internalType: 'bytes',
                            name: 'userPubkey',
                            type: 'bytes'
                        }
                    ],
                    internalType: 'struct LibPKPPermissionsStorage.AuthMethod[]',
                    name: '',
                    type: 'tuple[]'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'getPkpNftAddress',
            outputs: [
                {
                    internalType: 'address',
                    name: '',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                }
            ],
            name: 'getPubkey',
            outputs: [
                {
                    internalType: 'bytes',
                    name: '',
                    type: 'bytes'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'getRouterAddress',
            outputs: [
                {
                    internalType: 'address',
                    name: '',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'authMethodType',
                    type: 'uint256'
                },
                {
                    internalType: 'bytes',
                    name: 'id',
                    type: 'bytes'
                }
            ],
            name: 'getTokenIdsForAuthMethod',
            outputs: [
                {
                    internalType: 'uint256[]',
                    name: '',
                    type: 'uint256[]'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'authMethodType',
                    type: 'uint256'
                },
                {
                    internalType: 'bytes',
                    name: 'id',
                    type: 'bytes'
                }
            ],
            name: 'getUserPubkeyForAuthMethod',
            outputs: [
                {
                    internalType: 'bytes',
                    name: '',
                    type: 'bytes'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                },
                {
                    internalType: 'bytes',
                    name: 'ipfsCID',
                    type: 'bytes'
                }
            ],
            name: 'isPermittedAction',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                },
                {
                    internalType: 'address',
                    name: 'user',
                    type: 'address'
                }
            ],
            name: 'isPermittedAddress',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                },
                {
                    internalType: 'uint256',
                    name: 'authMethodType',
                    type: 'uint256'
                },
                {
                    internalType: 'bytes',
                    name: 'id',
                    type: 'bytes'
                }
            ],
            name: 'isPermittedAuthMethod',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                },
                {
                    internalType: 'uint256',
                    name: 'authMethodType',
                    type: 'uint256'
                },
                {
                    internalType: 'bytes',
                    name: 'id',
                    type: 'bytes'
                },
                {
                    internalType: 'uint256',
                    name: 'scopeId',
                    type: 'uint256'
                }
            ],
            name: 'isPermittedAuthMethodScopePresent',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                },
                {
                    internalType: 'bytes',
                    name: 'ipfsCID',
                    type: 'bytes'
                }
            ],
            name: 'removePermittedAction',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                },
                {
                    internalType: 'address',
                    name: 'user',
                    type: 'address'
                }
            ],
            name: 'removePermittedAddress',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                },
                {
                    internalType: 'uint256',
                    name: 'authMethodType',
                    type: 'uint256'
                },
                {
                    internalType: 'bytes',
                    name: 'id',
                    type: 'bytes'
                }
            ],
            name: 'removePermittedAuthMethod',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                },
                {
                    internalType: 'uint256',
                    name: 'authMethodType',
                    type: 'uint256'
                },
                {
                    internalType: 'bytes',
                    name: 'id',
                    type: 'bytes'
                },
                {
                    internalType: 'uint256',
                    name: 'scopeId',
                    type: 'uint256'
                }
            ],
            name: 'removePermittedAuthMethodScope',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'newResolverAddress',
                    type: 'address'
                }
            ],
            name: 'setContractResolver',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                },
                {
                    internalType: 'uint256',
                    name: 'group',
                    type: 'uint256'
                },
                {
                    internalType: 'bytes32',
                    name: 'root',
                    type: 'bytes32'
                }
            ],
            name: 'setRootHash',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                },
                {
                    internalType: 'uint256',
                    name: 'group',
                    type: 'uint256'
                },
                {
                    internalType: 'bytes32[]',
                    name: 'proof',
                    type: 'bytes32[]'
                },
                {
                    internalType: 'bytes32',
                    name: 'leaf',
                    type: 'bytes32'
                }
            ],
            name: 'verifyState',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                },
                {
                    internalType: 'uint256',
                    name: 'group',
                    type: 'uint256'
                },
                {
                    internalType: 'bytes32[]',
                    name: 'proof',
                    type: 'bytes32[]'
                },
                {
                    internalType: 'bool[]',
                    name: 'proofFlags',
                    type: 'bool[]'
                },
                {
                    internalType: 'bytes32[]',
                    name: 'leaves',
                    type: 'bytes32[]'
                }
            ],
            name: 'verifyStates',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        }
    ]
}; //# sourceMappingURL=PKPPermissionsData.js.map
}),
"[project]/node_modules/@lit-protocol/contracts-sdk/src/abis/PubkeyRouter.sol/PubkeyRouterData.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.PubkeyRouterData = void 0;
exports.PubkeyRouterData = {
    date: '2023-11-14T15:45:41Z',
    address: '0x4B5E97F2D811520e031A8F924e698B329ad83E29',
    contractName: 'PubkeyRouter',
    abi: [
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_selector',
                    type: 'bytes4'
                }
            ],
            name: 'CannotAddFunctionToDiamondThatAlreadyExists',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4[]',
                    name: '_selectors',
                    type: 'bytes4[]'
                }
            ],
            name: 'CannotAddSelectorsToZeroAddress',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_selector',
                    type: 'bytes4'
                }
            ],
            name: 'CannotRemoveFunctionThatDoesNotExist',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_selector',
                    type: 'bytes4'
                }
            ],
            name: 'CannotRemoveImmutableFunction',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_selector',
                    type: 'bytes4'
                }
            ],
            name: 'CannotReplaceFunctionThatDoesNotExists',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_selector',
                    type: 'bytes4'
                }
            ],
            name: 'CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4[]',
                    name: '_selectors',
                    type: 'bytes4[]'
                }
            ],
            name: 'CannotReplaceFunctionsFromFacetWithZeroAddress',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_selector',
                    type: 'bytes4'
                }
            ],
            name: 'CannotReplaceImmutableFunction',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'uint8',
                    name: '_action',
                    type: 'uint8'
                }
            ],
            name: 'IncorrectFacetCutAction',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_initializationContractAddress',
                    type: 'address'
                },
                {
                    internalType: 'bytes',
                    name: '_calldata',
                    type: 'bytes'
                }
            ],
            name: 'InitializationFunctionReverted',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_contractAddress',
                    type: 'address'
                },
                {
                    internalType: 'string',
                    name: '_message',
                    type: 'string'
                }
            ],
            name: 'NoBytecodeAtAddress',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_facetAddress',
                    type: 'address'
                }
            ],
            name: 'NoSelectorsProvidedForFacetForCut',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_user',
                    type: 'address'
                },
                {
                    internalType: 'address',
                    name: '_contractOwner',
                    type: 'address'
                }
            ],
            name: 'NotContractOwner',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_facetAddress',
                    type: 'address'
                }
            ],
            name: 'RemoveFacetAddressMustBeZeroAddress',
            type: 'error'
        },
        {
            anonymous: false,
            inputs: [
                {
                    components: [
                        {
                            internalType: 'address',
                            name: 'facetAddress',
                            type: 'address'
                        },
                        {
                            internalType: 'enum IDiamond.FacetCutAction',
                            name: 'action',
                            type: 'uint8'
                        },
                        {
                            internalType: 'bytes4[]',
                            name: 'functionSelectors',
                            type: 'bytes4[]'
                        }
                    ],
                    indexed: false,
                    internalType: 'struct IDiamond.FacetCut[]',
                    name: '_diamondCut',
                    type: 'tuple[]'
                },
                {
                    indexed: false,
                    internalType: 'address',
                    name: '_init',
                    type: 'address'
                },
                {
                    indexed: false,
                    internalType: 'bytes',
                    name: '_calldata',
                    type: 'bytes'
                }
            ],
            name: 'DiamondCut',
            type: 'event'
        },
        {
            inputs: [
                {
                    components: [
                        {
                            internalType: 'address',
                            name: 'facetAddress',
                            type: 'address'
                        },
                        {
                            internalType: 'enum IDiamond.FacetCutAction',
                            name: 'action',
                            type: 'uint8'
                        },
                        {
                            internalType: 'bytes4[]',
                            name: 'functionSelectors',
                            type: 'bytes4[]'
                        }
                    ],
                    internalType: 'struct IDiamond.FacetCut[]',
                    name: '_diamondCut',
                    type: 'tuple[]'
                },
                {
                    internalType: 'address',
                    name: '_init',
                    type: 'address'
                },
                {
                    internalType: 'bytes',
                    name: '_calldata',
                    type: 'bytes'
                }
            ],
            name: 'diamondCut',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_functionSelector',
                    type: 'bytes4'
                }
            ],
            name: 'facetAddress',
            outputs: [
                {
                    internalType: 'address',
                    name: 'facetAddress_',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'facetAddresses',
            outputs: [
                {
                    internalType: 'address[]',
                    name: 'facetAddresses_',
                    type: 'address[]'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_facet',
                    type: 'address'
                }
            ],
            name: 'facetFunctionSelectors',
            outputs: [
                {
                    internalType: 'bytes4[]',
                    name: '_facetFunctionSelectors',
                    type: 'bytes4[]'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'facets',
            outputs: [
                {
                    components: [
                        {
                            internalType: 'address',
                            name: 'facetAddress',
                            type: 'address'
                        },
                        {
                            internalType: 'bytes4[]',
                            name: 'functionSelectors',
                            type: 'bytes4[]'
                        }
                    ],
                    internalType: 'struct IDiamondLoupe.Facet[]',
                    name: 'facets_',
                    type: 'tuple[]'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_interfaceId',
                    type: 'bytes4'
                }
            ],
            name: 'supportsInterface',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'previousOwner',
                    type: 'address'
                },
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'newOwner',
                    type: 'address'
                }
            ],
            name: 'OwnershipTransferred',
            type: 'event'
        },
        {
            inputs: [],
            name: 'owner',
            outputs: [
                {
                    internalType: 'address',
                    name: 'owner_',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_newOwner',
                    type: 'address'
                }
            ],
            name: 'transferOwnership',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [],
            name: 'CallerNotOwner',
            type: 'error'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: false,
                    internalType: 'address',
                    name: 'newResolverAddress',
                    type: 'address'
                }
            ],
            name: 'ContractResolverAddressSet',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                },
                {
                    indexed: false,
                    internalType: 'bytes',
                    name: 'pubkey',
                    type: 'bytes'
                },
                {
                    indexed: false,
                    internalType: 'address',
                    name: 'stakingContract',
                    type: 'address'
                },
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'keyType',
                    type: 'uint256'
                },
                {
                    indexed: false,
                    internalType: 'bytes32',
                    name: 'derivedKeyId',
                    type: 'bytes32'
                }
            ],
            name: 'PubkeyRoutingDataSet',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: false,
                    internalType: 'address',
                    name: 'stakingContract',
                    type: 'address'
                },
                {
                    components: [
                        {
                            internalType: 'bytes',
                            name: 'pubkey',
                            type: 'bytes'
                        },
                        {
                            internalType: 'uint256',
                            name: 'keyType',
                            type: 'uint256'
                        }
                    ],
                    indexed: false,
                    internalType: 'struct IPubkeyRouter.RootKey',
                    name: 'rootKey',
                    type: 'tuple'
                }
            ],
            name: 'RootKeySet',
            type: 'event'
        },
        {
            inputs: [
                {
                    components: [
                        {
                            internalType: 'bytes32',
                            name: 'r',
                            type: 'bytes32'
                        },
                        {
                            internalType: 'bytes32',
                            name: 's',
                            type: 'bytes32'
                        },
                        {
                            internalType: 'uint8',
                            name: 'v',
                            type: 'uint8'
                        }
                    ],
                    internalType: 'struct IPubkeyRouter.Signature[]',
                    name: 'signatures',
                    type: 'tuple[]'
                },
                {
                    internalType: 'bytes',
                    name: 'signedMessage',
                    type: 'bytes'
                },
                {
                    internalType: 'address',
                    name: 'stakingContractAddress',
                    type: 'address'
                }
            ],
            name: 'checkNodeSignatures',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes',
                    name: 'pubkey',
                    type: 'bytes'
                }
            ],
            name: 'deriveEthAddressFromPubkey',
            outputs: [
                {
                    internalType: 'address',
                    name: '',
                    type: 'address'
                }
            ],
            stateMutability: 'pure',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'ethAddress',
                    type: 'address'
                }
            ],
            name: 'ethAddressToPkpId',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'stakingContract',
                    type: 'address'
                },
                {
                    internalType: 'bytes32',
                    name: 'derivedKeyId',
                    type: 'bytes32'
                }
            ],
            name: 'getDerivedPubkey',
            outputs: [
                {
                    internalType: 'bytes',
                    name: '',
                    type: 'bytes'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                }
            ],
            name: 'getEthAddress',
            outputs: [
                {
                    internalType: 'address',
                    name: '',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'getPkpNftAddress',
            outputs: [
                {
                    internalType: 'address',
                    name: '',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                }
            ],
            name: 'getPubkey',
            outputs: [
                {
                    internalType: 'bytes',
                    name: '',
                    type: 'bytes'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'stakingContract',
                    type: 'address'
                }
            ],
            name: 'getRootKeys',
            outputs: [
                {
                    components: [
                        {
                            internalType: 'bytes',
                            name: 'pubkey',
                            type: 'bytes'
                        },
                        {
                            internalType: 'uint256',
                            name: 'keyType',
                            type: 'uint256'
                        }
                    ],
                    internalType: 'struct IPubkeyRouter.RootKey[]',
                    name: '',
                    type: 'tuple[]'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                }
            ],
            name: 'getRoutingData',
            outputs: [
                {
                    components: [
                        {
                            internalType: 'bytes',
                            name: 'pubkey',
                            type: 'bytes'
                        },
                        {
                            internalType: 'uint256',
                            name: 'keyType',
                            type: 'uint256'
                        },
                        {
                            internalType: 'bytes32',
                            name: 'derivedKeyId',
                            type: 'bytes32'
                        }
                    ],
                    internalType: 'struct LibPubkeyRouterStorage.PubkeyRoutingData',
                    name: '',
                    type: 'tuple'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                }
            ],
            name: 'isRouted',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                }
            ],
            name: 'pubkeys',
            outputs: [
                {
                    components: [
                        {
                            internalType: 'bytes',
                            name: 'pubkey',
                            type: 'bytes'
                        },
                        {
                            internalType: 'uint256',
                            name: 'keyType',
                            type: 'uint256'
                        },
                        {
                            internalType: 'bytes32',
                            name: 'derivedKeyId',
                            type: 'bytes32'
                        }
                    ],
                    internalType: 'struct LibPubkeyRouterStorage.PubkeyRoutingData',
                    name: '',
                    type: 'tuple'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'newResolverAddress',
                    type: 'address'
                }
            ],
            name: 'setContractResolver',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                },
                {
                    internalType: 'bytes',
                    name: 'pubkey',
                    type: 'bytes'
                },
                {
                    internalType: 'address',
                    name: 'stakingContractAddress',
                    type: 'address'
                },
                {
                    internalType: 'uint256',
                    name: 'keyType',
                    type: 'uint256'
                },
                {
                    internalType: 'bytes32',
                    name: 'derivedKeyId',
                    type: 'bytes32'
                }
            ],
            name: 'setRoutingData',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                },
                {
                    internalType: 'bytes',
                    name: 'pubkey',
                    type: 'bytes'
                },
                {
                    internalType: 'address',
                    name: 'stakingContract',
                    type: 'address'
                },
                {
                    internalType: 'uint256',
                    name: 'keyType',
                    type: 'uint256'
                },
                {
                    internalType: 'bytes32',
                    name: 'derivedKeyId',
                    type: 'bytes32'
                }
            ],
            name: 'setRoutingDataAsAdmin',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'stakingContractAddress',
                    type: 'address'
                },
                {
                    components: [
                        {
                            internalType: 'bytes',
                            name: 'pubkey',
                            type: 'bytes'
                        },
                        {
                            internalType: 'uint256',
                            name: 'keyType',
                            type: 'uint256'
                        }
                    ],
                    internalType: 'struct IPubkeyRouter.RootKey[]',
                    name: 'newRootKeys',
                    type: 'tuple[]'
                }
            ],
            name: 'voteForRootKeys',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        }
    ]
}; //# sourceMappingURL=PubkeyRouterData.js.map
}),
"[project]/node_modules/@lit-protocol/contracts-sdk/src/abis/RateLimitNFT.sol/RateLimitNFTData.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RateLimitNFTData = void 0;
exports.RateLimitNFTData = {
    date: '2023-11-14T15:45:41Z',
    address: '0x19593CbBC56Ddd339Fde26278A544a25166C2388',
    contractName: 'RateLimitNFT',
    abi: [
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_selector',
                    type: 'bytes4'
                }
            ],
            name: 'CannotAddFunctionToDiamondThatAlreadyExists',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4[]',
                    name: '_selectors',
                    type: 'bytes4[]'
                }
            ],
            name: 'CannotAddSelectorsToZeroAddress',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_selector',
                    type: 'bytes4'
                }
            ],
            name: 'CannotRemoveFunctionThatDoesNotExist',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_selector',
                    type: 'bytes4'
                }
            ],
            name: 'CannotRemoveImmutableFunction',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_selector',
                    type: 'bytes4'
                }
            ],
            name: 'CannotReplaceFunctionThatDoesNotExists',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_selector',
                    type: 'bytes4'
                }
            ],
            name: 'CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4[]',
                    name: '_selectors',
                    type: 'bytes4[]'
                }
            ],
            name: 'CannotReplaceFunctionsFromFacetWithZeroAddress',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_selector',
                    type: 'bytes4'
                }
            ],
            name: 'CannotReplaceImmutableFunction',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'uint8',
                    name: '_action',
                    type: 'uint8'
                }
            ],
            name: 'IncorrectFacetCutAction',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_initializationContractAddress',
                    type: 'address'
                },
                {
                    internalType: 'bytes',
                    name: '_calldata',
                    type: 'bytes'
                }
            ],
            name: 'InitializationFunctionReverted',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_contractAddress',
                    type: 'address'
                },
                {
                    internalType: 'string',
                    name: '_message',
                    type: 'string'
                }
            ],
            name: 'NoBytecodeAtAddress',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_facetAddress',
                    type: 'address'
                }
            ],
            name: 'NoSelectorsProvidedForFacetForCut',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_user',
                    type: 'address'
                },
                {
                    internalType: 'address',
                    name: '_contractOwner',
                    type: 'address'
                }
            ],
            name: 'NotContractOwner',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_facetAddress',
                    type: 'address'
                }
            ],
            name: 'RemoveFacetAddressMustBeZeroAddress',
            type: 'error'
        },
        {
            anonymous: false,
            inputs: [
                {
                    components: [
                        {
                            internalType: 'address',
                            name: 'facetAddress',
                            type: 'address'
                        },
                        {
                            internalType: 'enum IDiamond.FacetCutAction',
                            name: 'action',
                            type: 'uint8'
                        },
                        {
                            internalType: 'bytes4[]',
                            name: 'functionSelectors',
                            type: 'bytes4[]'
                        }
                    ],
                    indexed: false,
                    internalType: 'struct IDiamond.FacetCut[]',
                    name: '_diamondCut',
                    type: 'tuple[]'
                },
                {
                    indexed: false,
                    internalType: 'address',
                    name: '_init',
                    type: 'address'
                },
                {
                    indexed: false,
                    internalType: 'bytes',
                    name: '_calldata',
                    type: 'bytes'
                }
            ],
            name: 'DiamondCut',
            type: 'event'
        },
        {
            inputs: [
                {
                    components: [
                        {
                            internalType: 'address',
                            name: 'facetAddress',
                            type: 'address'
                        },
                        {
                            internalType: 'enum IDiamond.FacetCutAction',
                            name: 'action',
                            type: 'uint8'
                        },
                        {
                            internalType: 'bytes4[]',
                            name: 'functionSelectors',
                            type: 'bytes4[]'
                        }
                    ],
                    internalType: 'struct IDiamond.FacetCut[]',
                    name: '_diamondCut',
                    type: 'tuple[]'
                },
                {
                    internalType: 'address',
                    name: '_init',
                    type: 'address'
                },
                {
                    internalType: 'bytes',
                    name: '_calldata',
                    type: 'bytes'
                }
            ],
            name: 'diamondCut',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_functionSelector',
                    type: 'bytes4'
                }
            ],
            name: 'facetAddress',
            outputs: [
                {
                    internalType: 'address',
                    name: 'facetAddress_',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'facetAddresses',
            outputs: [
                {
                    internalType: 'address[]',
                    name: 'facetAddresses_',
                    type: 'address[]'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_facet',
                    type: 'address'
                }
            ],
            name: 'facetFunctionSelectors',
            outputs: [
                {
                    internalType: 'bytes4[]',
                    name: '_facetFunctionSelectors',
                    type: 'bytes4[]'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'facets',
            outputs: [
                {
                    components: [
                        {
                            internalType: 'address',
                            name: 'facetAddress',
                            type: 'address'
                        },
                        {
                            internalType: 'bytes4[]',
                            name: 'functionSelectors',
                            type: 'bytes4[]'
                        }
                    ],
                    internalType: 'struct IDiamondLoupe.Facet[]',
                    name: 'facets_',
                    type: 'tuple[]'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'previousOwner',
                    type: 'address'
                },
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'newOwner',
                    type: 'address'
                }
            ],
            name: 'OwnershipTransferred',
            type: 'event'
        },
        {
            inputs: [],
            name: 'owner',
            outputs: [
                {
                    internalType: 'address',
                    name: 'owner_',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_newOwner',
                    type: 'address'
                }
            ],
            name: 'transferOwnership',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [],
            name: 'CallerNotOwner',
            type: 'error'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'newAdditionalRequestsPerKilosecondCost',
                    type: 'uint256'
                }
            ],
            name: 'AdditionalRequestsPerKilosecondCostSet',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'owner',
                    type: 'address'
                },
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'approved',
                    type: 'address'
                },
                {
                    indexed: true,
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                }
            ],
            name: 'Approval',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'owner',
                    type: 'address'
                },
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'operator',
                    type: 'address'
                },
                {
                    indexed: false,
                    internalType: 'bool',
                    name: 'approved',
                    type: 'bool'
                }
            ],
            name: 'ApprovalForAll',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'newFreeMintSigner',
                    type: 'address'
                }
            ],
            name: 'FreeMintSignerSet',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'newFreeRequestsPerRateLimitWindow',
                    type: 'uint256'
                }
            ],
            name: 'FreeRequestsPerRateLimitWindowSet',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: false,
                    internalType: 'uint8',
                    name: 'version',
                    type: 'uint8'
                }
            ],
            name: 'Initialized',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'newRLIHolderRateLimitWindowSeconds',
                    type: 'uint256'
                }
            ],
            name: 'RLIHolderRateLimitWindowSecondsSet',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'newRateLimitWindowSeconds',
                    type: 'uint256'
                }
            ],
            name: 'RateLimitWindowSecondsSet',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'from',
                    type: 'address'
                },
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'to',
                    type: 'address'
                },
                {
                    indexed: true,
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                }
            ],
            name: 'Transfer',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'amount',
                    type: 'uint256'
                }
            ],
            name: 'Withdrew',
            type: 'event'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'to',
                    type: 'address'
                },
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                }
            ],
            name: 'approve',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'owner',
                    type: 'address'
                }
            ],
            name: 'balanceOf',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                }
            ],
            name: 'burn',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'expiresAt',
                    type: 'uint256'
                },
                {
                    internalType: 'uint256',
                    name: 'requestsPerKilosecond',
                    type: 'uint256'
                },
                {
                    internalType: 'bytes32',
                    name: 'msgHash',
                    type: 'bytes32'
                },
                {
                    internalType: 'uint8',
                    name: 'v',
                    type: 'uint8'
                },
                {
                    internalType: 'bytes32',
                    name: 'r',
                    type: 'bytes32'
                },
                {
                    internalType: 'bytes32',
                    name: 'sVal',
                    type: 'bytes32'
                }
            ],
            name: 'freeMint',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                }
            ],
            name: 'getApproved',
            outputs: [
                {
                    internalType: 'address',
                    name: '',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'initialize',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'owner',
                    type: 'address'
                },
                {
                    internalType: 'address',
                    name: 'operator',
                    type: 'address'
                }
            ],
            name: 'isApprovedForAll',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'expiresAt',
                    type: 'uint256'
                }
            ],
            name: 'mint',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'payable',
            type: 'function'
        },
        {
            inputs: [],
            name: 'name',
            outputs: [
                {
                    internalType: 'string',
                    name: '',
                    type: 'string'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                }
            ],
            name: 'ownerOf',
            outputs: [
                {
                    internalType: 'address',
                    name: '',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'from',
                    type: 'address'
                },
                {
                    internalType: 'address',
                    name: 'to',
                    type: 'address'
                },
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                }
            ],
            name: 'safeTransferFrom',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'from',
                    type: 'address'
                },
                {
                    internalType: 'address',
                    name: 'to',
                    type: 'address'
                },
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                },
                {
                    internalType: 'bytes',
                    name: 'data',
                    type: 'bytes'
                }
            ],
            name: 'safeTransferFrom',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'newAdditionalRequestsPerKilosecondCost',
                    type: 'uint256'
                }
            ],
            name: 'setAdditionalRequestsPerKilosecondCost',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'operator',
                    type: 'address'
                },
                {
                    internalType: 'bool',
                    name: 'approved',
                    type: 'bool'
                }
            ],
            name: 'setApprovalForAll',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'newFreeMintSigner',
                    type: 'address'
                }
            ],
            name: 'setFreeMintSigner',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'newFreeRequestsPerRateLimitWindow',
                    type: 'uint256'
                }
            ],
            name: 'setFreeRequestsPerRateLimitWindow',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'newMaxExpirationSeconds',
                    type: 'uint256'
                }
            ],
            name: 'setMaxExpirationSeconds',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'newMaxRequestsPerKilosecond',
                    type: 'uint256'
                }
            ],
            name: 'setMaxRequestsPerKilosecond',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'newRLIHolderRateLimitWindowSeconds',
                    type: 'uint256'
                }
            ],
            name: 'setRLIHolderRateLimitWindowSeconds',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'newRateLimitWindowSeconds',
                    type: 'uint256'
                }
            ],
            name: 'setRateLimitWindowSeconds',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: 'interfaceId',
                    type: 'bytes4'
                }
            ],
            name: 'supportsInterface',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'symbol',
            outputs: [
                {
                    internalType: 'string',
                    name: '',
                    type: 'string'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'index',
                    type: 'uint256'
                }
            ],
            name: 'tokenByIndex',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'owner',
                    type: 'address'
                },
                {
                    internalType: 'uint256',
                    name: 'index',
                    type: 'uint256'
                }
            ],
            name: 'tokenOfOwnerByIndex',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                }
            ],
            name: 'tokenURI',
            outputs: [
                {
                    internalType: 'string',
                    name: '',
                    type: 'string'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'totalSupply',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'from',
                    type: 'address'
                },
                {
                    internalType: 'address',
                    name: 'to',
                    type: 'address'
                },
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                }
            ],
            name: 'transferFrom',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [],
            name: 'withdraw',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [],
            name: 'RLIHolderRateLimitWindowSeconds',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'additionalRequestsPerKilosecondCost',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'requestsPerKilosecond',
                    type: 'uint256'
                },
                {
                    internalType: 'uint256',
                    name: 'expiresAt',
                    type: 'uint256'
                }
            ],
            name: 'calculateCost',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'payingAmount',
                    type: 'uint256'
                },
                {
                    internalType: 'uint256',
                    name: 'expiresAt',
                    type: 'uint256'
                }
            ],
            name: 'calculateRequestsPerKilosecond',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                }
            ],
            name: 'capacity',
            outputs: [
                {
                    components: [
                        {
                            internalType: 'uint256',
                            name: 'requestsPerKilosecond',
                            type: 'uint256'
                        },
                        {
                            internalType: 'uint256',
                            name: 'expiresAt',
                            type: 'uint256'
                        }
                    ],
                    internalType: 'struct LibRateLimitNFTStorage.RateLimit',
                    name: '',
                    type: 'tuple'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'requestedRequestsPerKilosecond',
                    type: 'uint256'
                }
            ],
            name: 'checkBelowMaxRequestsPerKilosecond',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'currentSoldRequestsPerKilosecond',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'defaultRateLimitWindowSeconds',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'expiresAt',
                    type: 'uint256'
                },
                {
                    internalType: 'uint256',
                    name: 'requestsPerKilosecond',
                    type: 'uint256'
                },
                {
                    internalType: 'bytes32',
                    name: 'msgHash',
                    type: 'bytes32'
                },
                {
                    internalType: 'uint8',
                    name: 'v',
                    type: 'uint8'
                },
                {
                    internalType: 'bytes32',
                    name: 'r',
                    type: 'bytes32'
                },
                {
                    internalType: 'bytes32',
                    name: 'sVal',
                    type: 'bytes32'
                }
            ],
            name: 'freeMintSigTest',
            outputs: [],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'freeMintSigner',
            outputs: [
                {
                    internalType: 'address',
                    name: '',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'freeRequestsPerRateLimitWindow',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                }
            ],
            name: 'isExpired',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'maxExpirationSeconds',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'maxRequestsPerKilosecond',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes32',
                    name: 'hash',
                    type: 'bytes32'
                }
            ],
            name: 'prefixed',
            outputs: [
                {
                    internalType: 'bytes32',
                    name: '',
                    type: 'bytes32'
                }
            ],
            stateMutability: 'pure',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes32',
                    name: 'msgHash',
                    type: 'bytes32'
                }
            ],
            name: 'redeemedFreeMints',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'tokenIdCounter',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'tokenId',
                    type: 'uint256'
                }
            ],
            name: 'tokenSVG',
            outputs: [
                {
                    internalType: 'string',
                    name: '',
                    type: 'string'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'expiresAt',
                    type: 'uint256'
                }
            ],
            name: 'totalSoldRequestsPerKilosecondByExpirationTime',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        }
    ]
}; //# sourceMappingURL=RateLimitNFTData.js.map
}),
"[project]/node_modules/@lit-protocol/contracts-sdk/src/abis/Staking.sol/StakingData.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StakingData = void 0;
exports.StakingData = {
    date: '2023-11-14T15:45:41Z',
    address: '0x5bFa704aF947b3b0f966e4248DED7bfa6edeF952',
    contractName: 'Staking',
    abi: [
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_selector',
                    type: 'bytes4'
                }
            ],
            name: 'CannotAddFunctionToDiamondThatAlreadyExists',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4[]',
                    name: '_selectors',
                    type: 'bytes4[]'
                }
            ],
            name: 'CannotAddSelectorsToZeroAddress',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_selector',
                    type: 'bytes4'
                }
            ],
            name: 'CannotRemoveFunctionThatDoesNotExist',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_selector',
                    type: 'bytes4'
                }
            ],
            name: 'CannotRemoveImmutableFunction',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_selector',
                    type: 'bytes4'
                }
            ],
            name: 'CannotReplaceFunctionThatDoesNotExists',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_selector',
                    type: 'bytes4'
                }
            ],
            name: 'CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4[]',
                    name: '_selectors',
                    type: 'bytes4[]'
                }
            ],
            name: 'CannotReplaceFunctionsFromFacetWithZeroAddress',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_selector',
                    type: 'bytes4'
                }
            ],
            name: 'CannotReplaceImmutableFunction',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'uint8',
                    name: '_action',
                    type: 'uint8'
                }
            ],
            name: 'IncorrectFacetCutAction',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_initializationContractAddress',
                    type: 'address'
                },
                {
                    internalType: 'bytes',
                    name: '_calldata',
                    type: 'bytes'
                }
            ],
            name: 'InitializationFunctionReverted',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_contractAddress',
                    type: 'address'
                },
                {
                    internalType: 'string',
                    name: '_message',
                    type: 'string'
                }
            ],
            name: 'NoBytecodeAtAddress',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_facetAddress',
                    type: 'address'
                }
            ],
            name: 'NoSelectorsProvidedForFacetForCut',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_user',
                    type: 'address'
                },
                {
                    internalType: 'address',
                    name: '_contractOwner',
                    type: 'address'
                }
            ],
            name: 'NotContractOwner',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_facetAddress',
                    type: 'address'
                }
            ],
            name: 'RemoveFacetAddressMustBeZeroAddress',
            type: 'error'
        },
        {
            anonymous: false,
            inputs: [
                {
                    components: [
                        {
                            internalType: 'address',
                            name: 'facetAddress',
                            type: 'address'
                        },
                        {
                            internalType: 'enum IDiamond.FacetCutAction',
                            name: 'action',
                            type: 'uint8'
                        },
                        {
                            internalType: 'bytes4[]',
                            name: 'functionSelectors',
                            type: 'bytes4[]'
                        }
                    ],
                    indexed: false,
                    internalType: 'struct IDiamond.FacetCut[]',
                    name: '_diamondCut',
                    type: 'tuple[]'
                },
                {
                    indexed: false,
                    internalType: 'address',
                    name: '_init',
                    type: 'address'
                },
                {
                    indexed: false,
                    internalType: 'bytes',
                    name: '_calldata',
                    type: 'bytes'
                }
            ],
            name: 'DiamondCut',
            type: 'event'
        },
        {
            inputs: [
                {
                    components: [
                        {
                            internalType: 'address',
                            name: 'facetAddress',
                            type: 'address'
                        },
                        {
                            internalType: 'enum IDiamond.FacetCutAction',
                            name: 'action',
                            type: 'uint8'
                        },
                        {
                            internalType: 'bytes4[]',
                            name: 'functionSelectors',
                            type: 'bytes4[]'
                        }
                    ],
                    internalType: 'struct IDiamond.FacetCut[]',
                    name: '_diamondCut',
                    type: 'tuple[]'
                },
                {
                    internalType: 'address',
                    name: '_init',
                    type: 'address'
                },
                {
                    internalType: 'bytes',
                    name: '_calldata',
                    type: 'bytes'
                }
            ],
            name: 'diamondCut',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_functionSelector',
                    type: 'bytes4'
                }
            ],
            name: 'facetAddress',
            outputs: [
                {
                    internalType: 'address',
                    name: 'facetAddress_',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'facetAddresses',
            outputs: [
                {
                    internalType: 'address[]',
                    name: 'facetAddresses_',
                    type: 'address[]'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_facet',
                    type: 'address'
                }
            ],
            name: 'facetFunctionSelectors',
            outputs: [
                {
                    internalType: 'bytes4[]',
                    name: '_facetFunctionSelectors',
                    type: 'bytes4[]'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'facets',
            outputs: [
                {
                    components: [
                        {
                            internalType: 'address',
                            name: 'facetAddress',
                            type: 'address'
                        },
                        {
                            internalType: 'bytes4[]',
                            name: 'functionSelectors',
                            type: 'bytes4[]'
                        }
                    ],
                    internalType: 'struct IDiamondLoupe.Facet[]',
                    name: 'facets_',
                    type: 'tuple[]'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_interfaceId',
                    type: 'bytes4'
                }
            ],
            name: 'supportsInterface',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'previousOwner',
                    type: 'address'
                },
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'newOwner',
                    type: 'address'
                }
            ],
            name: 'OwnershipTransferred',
            type: 'event'
        },
        {
            inputs: [],
            name: 'owner',
            outputs: [
                {
                    internalType: 'address',
                    name: 'owner_',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_newOwner',
                    type: 'address'
                }
            ],
            name: 'transferOwnership',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [],
            name: 'ActiveValidatorsCannotLeave',
            type: 'error'
        },
        {
            inputs: [],
            name: 'CallerNotOwner',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'stakingAddress',
                    type: 'address'
                }
            ],
            name: 'CannotRejoinUntilNextEpochBecauseKicked',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'senderPubKey',
                    type: 'uint256'
                },
                {
                    internalType: 'uint256',
                    name: 'receiverPubKey',
                    type: 'uint256'
                }
            ],
            name: 'CannotReuseCommsKeys',
            type: 'error'
        },
        {
            inputs: [],
            name: 'CannotStakeZero',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'stakerAddress',
                    type: 'address'
                }
            ],
            name: 'CannotVoteTwice',
            type: 'error'
        },
        {
            inputs: [],
            name: 'CannotWithdrawZero',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'nodeAddress',
                    type: 'address'
                }
            ],
            name: 'CouldNotMapNodeAddressToStakerAddress',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'enum LibStakingStorage.States',
                    name: 'state',
                    type: 'uint8'
                }
            ],
            name: 'MustBeInActiveOrUnlockedOrPausedState',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'enum LibStakingStorage.States',
                    name: 'state',
                    type: 'uint8'
                }
            ],
            name: 'MustBeInActiveOrUnlockedState',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'enum LibStakingStorage.States',
                    name: 'state',
                    type: 'uint8'
                }
            ],
            name: 'MustBeInNextValidatorSetLockedOrReadyForNextEpochOrRestoreState',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'enum LibStakingStorage.States',
                    name: 'state',
                    type: 'uint8'
                }
            ],
            name: 'MustBeInNextValidatorSetLockedState',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'enum LibStakingStorage.States',
                    name: 'state',
                    type: 'uint8'
                }
            ],
            name: 'MustBeInReadyForNextEpochState',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'stakerAddress',
                    type: 'address'
                }
            ],
            name: 'MustBeValidatorInNextEpochToKick',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'currentTimestamp',
                    type: 'uint256'
                },
                {
                    internalType: 'uint256',
                    name: 'epochEndTime',
                    type: 'uint256'
                },
                {
                    internalType: 'uint256',
                    name: 'timeout',
                    type: 'uint256'
                }
            ],
            name: 'NotEnoughTimeElapsedForTimeoutSinceLastEpoch',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'currentTimestamp',
                    type: 'uint256'
                },
                {
                    internalType: 'uint256',
                    name: 'epochEndTime',
                    type: 'uint256'
                }
            ],
            name: 'NotEnoughTimeElapsedSinceLastEpoch',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'validatorCount',
                    type: 'uint256'
                },
                {
                    internalType: 'uint256',
                    name: 'minimumValidatorCount',
                    type: 'uint256'
                }
            ],
            name: 'NotEnoughValidatorsInNextEpoch',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'currentReadyValidatorCount',
                    type: 'uint256'
                },
                {
                    internalType: 'uint256',
                    name: 'nextReadyValidatorCount',
                    type: 'uint256'
                },
                {
                    internalType: 'uint256',
                    name: 'minimumValidatorCountToBeReady',
                    type: 'uint256'
                }
            ],
            name: 'NotEnoughValidatorsReadyForNextEpoch',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'currentEpochNumber',
                    type: 'uint256'
                },
                {
                    internalType: 'uint256',
                    name: 'receivedEpochNumber',
                    type: 'uint256'
                }
            ],
            name: 'SignaledReadyForWrongEpochNumber',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'stakerAddress',
                    type: 'address'
                }
            ],
            name: 'StakerNotPermitted',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'yourBalance',
                    type: 'uint256'
                },
                {
                    internalType: 'uint256',
                    name: 'requestedWithdrawlAmount',
                    type: 'uint256'
                }
            ],
            name: 'TryingToWithdrawMoreThanStaked',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'validator',
                    type: 'address'
                },
                {
                    internalType: 'address[]',
                    name: 'validatorsInNextEpoch',
                    type: 'address[]'
                }
            ],
            name: 'ValidatorIsNotInNextEpoch',
            type: 'error'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'newTokenRewardPerTokenPerEpoch',
                    type: 'uint256'
                },
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'newComplaintTolerance',
                    type: 'uint256'
                },
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'newComplaintIntervalSecs',
                    type: 'uint256'
                },
                {
                    indexed: false,
                    internalType: 'uint256[]',
                    name: 'newKeyTypes',
                    type: 'uint256[]'
                },
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'newMinimumValidatorCount',
                    type: 'uint256'
                }
            ],
            name: 'ConfigSet',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'newEpochEndTime',
                    type: 'uint256'
                }
            ],
            name: 'EpochEndTimeSet',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'newEpochLength',
                    type: 'uint256'
                }
            ],
            name: 'EpochLengthSet',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'newEpochTimeout',
                    type: 'uint256'
                }
            ],
            name: 'EpochTimeoutSet',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'reason',
                    type: 'uint256'
                },
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'newKickPenaltyPercent',
                    type: 'uint256'
                }
            ],
            name: 'KickPenaltyPercentSet',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'staker',
                    type: 'address'
                },
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'epochNumber',
                    type: 'uint256'
                }
            ],
            name: 'ReadyForNextEpoch',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: false,
                    internalType: 'address',
                    name: 'token',
                    type: 'address'
                },
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'amount',
                    type: 'uint256'
                }
            ],
            name: 'Recovered',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'staker',
                    type: 'address'
                }
            ],
            name: 'RequestToJoin',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'staker',
                    type: 'address'
                }
            ],
            name: 'RequestToLeave',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: false,
                    internalType: 'address',
                    name: 'newResolverContractAddress',
                    type: 'address'
                }
            ],
            name: 'ResolverContractAddressSet',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'newDuration',
                    type: 'uint256'
                }
            ],
            name: 'RewardsDurationUpdated',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: false,
                    internalType: 'address',
                    name: 'newStakingTokenAddress',
                    type: 'address'
                }
            ],
            name: 'StakingTokenSet',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: false,
                    internalType: 'enum LibStakingStorage.States',
                    name: 'newState',
                    type: 'uint8'
                }
            ],
            name: 'StateChanged',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'staker',
                    type: 'address'
                },
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'amountBurned',
                    type: 'uint256'
                }
            ],
            name: 'ValidatorKickedFromNextEpoch',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: false,
                    internalType: 'address',
                    name: 'staker',
                    type: 'address'
                }
            ],
            name: 'ValidatorRejoinedNextEpoch',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'reporter',
                    type: 'address'
                },
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'validatorStakerAddress',
                    type: 'address'
                },
                {
                    indexed: true,
                    internalType: 'uint256',
                    name: 'reason',
                    type: 'uint256'
                },
                {
                    indexed: false,
                    internalType: 'bytes',
                    name: 'data',
                    type: 'bytes'
                }
            ],
            name: 'VotedToKickValidatorInNextEpoch',
            type: 'event'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'validatorStakerAddress',
                    type: 'address'
                }
            ],
            name: 'adminKickValidatorInNextEpoch',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'staker',
                    type: 'address'
                }
            ],
            name: 'adminRejoinValidator',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'validatorStakerAddress',
                    type: 'address'
                },
                {
                    internalType: 'uint256',
                    name: 'amountToPenalize',
                    type: 'uint256'
                }
            ],
            name: 'adminSlashValidator',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [],
            name: 'advanceEpoch',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [],
            name: 'exit',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [],
            name: 'getReward',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'validatorStakerAddress',
                    type: 'address'
                },
                {
                    internalType: 'uint256',
                    name: 'reason',
                    type: 'uint256'
                },
                {
                    internalType: 'bytes',
                    name: 'data',
                    type: 'bytes'
                }
            ],
            name: 'kickValidatorInNextEpoch',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [],
            name: 'lockValidatorsForNextEpoch',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint32',
                    name: 'ip',
                    type: 'uint32'
                },
                {
                    internalType: 'uint128',
                    name: 'ipv6',
                    type: 'uint128'
                },
                {
                    internalType: 'uint32',
                    name: 'port',
                    type: 'uint32'
                },
                {
                    internalType: 'address',
                    name: 'nodeAddress',
                    type: 'address'
                },
                {
                    internalType: 'uint256',
                    name: 'senderPubKey',
                    type: 'uint256'
                },
                {
                    internalType: 'uint256',
                    name: 'receiverPubKey',
                    type: 'uint256'
                }
            ],
            name: 'requestToJoin',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [],
            name: 'requestToLeave',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'newTokenRewardPerTokenPerEpoch',
                    type: 'uint256'
                },
                {
                    internalType: 'uint256',
                    name: 'newComplaintTolerance',
                    type: 'uint256'
                },
                {
                    internalType: 'uint256',
                    name: 'newComplaintIntervalSecs',
                    type: 'uint256'
                },
                {
                    internalType: 'uint256[]',
                    name: 'newKeyTypes',
                    type: 'uint256[]'
                },
                {
                    internalType: 'uint256',
                    name: 'newMinimumValidatorCount',
                    type: 'uint256'
                }
            ],
            name: 'setConfig',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'newResolverAddress',
                    type: 'address'
                }
            ],
            name: 'setContractResolver',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'newEpochEndTime',
                    type: 'uint256'
                }
            ],
            name: 'setEpochEndTime',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'newEpochLength',
                    type: 'uint256'
                }
            ],
            name: 'setEpochLength',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'enum LibStakingStorage.States',
                    name: 'newState',
                    type: 'uint8'
                }
            ],
            name: 'setEpochState',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'newEpochTimeout',
                    type: 'uint256'
                }
            ],
            name: 'setEpochTimeout',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint32',
                    name: 'ip',
                    type: 'uint32'
                },
                {
                    internalType: 'uint128',
                    name: 'ipv6',
                    type: 'uint128'
                },
                {
                    internalType: 'uint32',
                    name: 'port',
                    type: 'uint32'
                },
                {
                    internalType: 'address',
                    name: 'nodeAddress',
                    type: 'address'
                },
                {
                    internalType: 'uint256',
                    name: 'senderPubKey',
                    type: 'uint256'
                },
                {
                    internalType: 'uint256',
                    name: 'receiverPubKey',
                    type: 'uint256'
                }
            ],
            name: 'setIpPortNodeAddressAndCommunicationPubKeys',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'reason',
                    type: 'uint256'
                },
                {
                    internalType: 'uint256',
                    name: 'newKickPenaltyPercent',
                    type: 'uint256'
                }
            ],
            name: 'setKickPenaltyPercent',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'epochNumber',
                    type: 'uint256'
                }
            ],
            name: 'signalReadyForNextEpoch',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'amount',
                    type: 'uint256'
                }
            ],
            name: 'stake',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'amount',
                    type: 'uint256'
                },
                {
                    internalType: 'uint32',
                    name: 'ip',
                    type: 'uint32'
                },
                {
                    internalType: 'uint128',
                    name: 'ipv6',
                    type: 'uint128'
                },
                {
                    internalType: 'uint32',
                    name: 'port',
                    type: 'uint32'
                },
                {
                    internalType: 'address',
                    name: 'nodeAddress',
                    type: 'address'
                },
                {
                    internalType: 'uint256',
                    name: 'senderPubKey',
                    type: 'uint256'
                },
                {
                    internalType: 'uint256',
                    name: 'receiverPubKey',
                    type: 'uint256'
                }
            ],
            name: 'stakeAndJoin',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [],
            name: 'unlockValidatorsForNextEpoch',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'amount',
                    type: 'uint256'
                }
            ],
            name: 'withdraw',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    components: [
                        {
                            internalType: 'uint256',
                            name: 'major',
                            type: 'uint256'
                        },
                        {
                            internalType: 'uint256',
                            name: 'minor',
                            type: 'uint256'
                        },
                        {
                            internalType: 'uint256',
                            name: 'patch',
                            type: 'uint256'
                        }
                    ],
                    internalType: 'struct LibStakingStorage.Version',
                    name: 'version',
                    type: 'tuple'
                }
            ],
            name: 'checkVersion',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'getMaxVersion',
            outputs: [
                {
                    components: [
                        {
                            internalType: 'uint256',
                            name: 'major',
                            type: 'uint256'
                        },
                        {
                            internalType: 'uint256',
                            name: 'minor',
                            type: 'uint256'
                        },
                        {
                            internalType: 'uint256',
                            name: 'patch',
                            type: 'uint256'
                        }
                    ],
                    internalType: 'struct LibStakingStorage.Version',
                    name: '',
                    type: 'tuple'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'getMaxVersionString',
            outputs: [
                {
                    internalType: 'string',
                    name: '',
                    type: 'string'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'getMinVersion',
            outputs: [
                {
                    components: [
                        {
                            internalType: 'uint256',
                            name: 'major',
                            type: 'uint256'
                        },
                        {
                            internalType: 'uint256',
                            name: 'minor',
                            type: 'uint256'
                        },
                        {
                            internalType: 'uint256',
                            name: 'patch',
                            type: 'uint256'
                        }
                    ],
                    internalType: 'struct LibStakingStorage.Version',
                    name: '',
                    type: 'tuple'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'getMinVersionString',
            outputs: [
                {
                    internalType: 'string',
                    name: '',
                    type: 'string'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    components: [
                        {
                            internalType: 'uint256',
                            name: 'major',
                            type: 'uint256'
                        },
                        {
                            internalType: 'uint256',
                            name: 'minor',
                            type: 'uint256'
                        },
                        {
                            internalType: 'uint256',
                            name: 'patch',
                            type: 'uint256'
                        }
                    ],
                    internalType: 'struct LibStakingStorage.Version',
                    name: 'version',
                    type: 'tuple'
                }
            ],
            name: 'setMaxVersion',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    components: [
                        {
                            internalType: 'uint256',
                            name: 'major',
                            type: 'uint256'
                        },
                        {
                            internalType: 'uint256',
                            name: 'minor',
                            type: 'uint256'
                        },
                        {
                            internalType: 'uint256',
                            name: 'patch',
                            type: 'uint256'
                        }
                    ],
                    internalType: 'struct LibStakingStorage.Version',
                    name: 'version',
                    type: 'tuple'
                }
            ],
            name: 'setMinVersion',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [],
            name: 'config',
            outputs: [
                {
                    components: [
                        {
                            internalType: 'uint256',
                            name: 'tokenRewardPerTokenPerEpoch',
                            type: 'uint256'
                        },
                        {
                            internalType: 'uint256',
                            name: 'complaintTolerance',
                            type: 'uint256'
                        },
                        {
                            internalType: 'uint256',
                            name: 'complaintIntervalSecs',
                            type: 'uint256'
                        },
                        {
                            internalType: 'uint256[]',
                            name: 'keyTypes',
                            type: 'uint256[]'
                        },
                        {
                            internalType: 'uint256',
                            name: 'minimumValidatorCount',
                            type: 'uint256'
                        }
                    ],
                    internalType: 'struct LibStakingStorage.Config',
                    name: '',
                    type: 'tuple'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'contractResolver',
            outputs: [
                {
                    internalType: 'address',
                    name: '',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'countOfCurrentValidatorsReadyForNextEpoch',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'countOfNextValidatorsReadyForNextEpoch',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'currentValidatorCountForConsensus',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'epoch',
            outputs: [
                {
                    components: [
                        {
                            internalType: 'uint256',
                            name: 'epochLength',
                            type: 'uint256'
                        },
                        {
                            internalType: 'uint256',
                            name: 'number',
                            type: 'uint256'
                        },
                        {
                            internalType: 'uint256',
                            name: 'endTime',
                            type: 'uint256'
                        },
                        {
                            internalType: 'uint256',
                            name: 'retries',
                            type: 'uint256'
                        },
                        {
                            internalType: 'uint256',
                            name: 'timeout',
                            type: 'uint256'
                        }
                    ],
                    internalType: 'struct LibStakingStorage.Epoch',
                    name: '',
                    type: 'tuple'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'getKeyTypes',
            outputs: [
                {
                    internalType: 'uint256[]',
                    name: '',
                    type: 'uint256[]'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'getKickedValidators',
            outputs: [
                {
                    internalType: 'address[]',
                    name: '',
                    type: 'address[]'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address[]',
                    name: 'addresses',
                    type: 'address[]'
                }
            ],
            name: 'getNodeStakerAddressMappings',
            outputs: [
                {
                    components: [
                        {
                            internalType: 'address',
                            name: 'nodeAddress',
                            type: 'address'
                        },
                        {
                            internalType: 'address',
                            name: 'stakerAddress',
                            type: 'address'
                        }
                    ],
                    internalType: 'struct LibStakingStorage.AddressMapping[]',
                    name: '',
                    type: 'tuple[]'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'getStakingBalancesAddress',
            outputs: [
                {
                    internalType: 'address',
                    name: '',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'getTokenAddress',
            outputs: [
                {
                    internalType: 'address',
                    name: '',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'getValidatorsInCurrentEpoch',
            outputs: [
                {
                    internalType: 'address[]',
                    name: '',
                    type: 'address[]'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'getValidatorsInCurrentEpochLength',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'getValidatorsInNextEpoch',
            outputs: [
                {
                    internalType: 'address[]',
                    name: '',
                    type: 'address[]'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address[]',
                    name: 'addresses',
                    type: 'address[]'
                }
            ],
            name: 'getValidatorsStructs',
            outputs: [
                {
                    components: [
                        {
                            internalType: 'uint32',
                            name: 'ip',
                            type: 'uint32'
                        },
                        {
                            internalType: 'uint128',
                            name: 'ipv6',
                            type: 'uint128'
                        },
                        {
                            internalType: 'uint32',
                            name: 'port',
                            type: 'uint32'
                        },
                        {
                            internalType: 'address',
                            name: 'nodeAddress',
                            type: 'address'
                        },
                        {
                            internalType: 'uint256',
                            name: 'reward',
                            type: 'uint256'
                        },
                        {
                            internalType: 'uint256',
                            name: 'senderPubKey',
                            type: 'uint256'
                        },
                        {
                            internalType: 'uint256',
                            name: 'receiverPubKey',
                            type: 'uint256'
                        }
                    ],
                    internalType: 'struct LibStakingStorage.Validator[]',
                    name: '',
                    type: 'tuple[]'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'getValidatorsStructsInCurrentEpoch',
            outputs: [
                {
                    components: [
                        {
                            internalType: 'uint32',
                            name: 'ip',
                            type: 'uint32'
                        },
                        {
                            internalType: 'uint128',
                            name: 'ipv6',
                            type: 'uint128'
                        },
                        {
                            internalType: 'uint32',
                            name: 'port',
                            type: 'uint32'
                        },
                        {
                            internalType: 'address',
                            name: 'nodeAddress',
                            type: 'address'
                        },
                        {
                            internalType: 'uint256',
                            name: 'reward',
                            type: 'uint256'
                        },
                        {
                            internalType: 'uint256',
                            name: 'senderPubKey',
                            type: 'uint256'
                        },
                        {
                            internalType: 'uint256',
                            name: 'receiverPubKey',
                            type: 'uint256'
                        }
                    ],
                    internalType: 'struct LibStakingStorage.Validator[]',
                    name: '',
                    type: 'tuple[]'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'getValidatorsStructsInNextEpoch',
            outputs: [
                {
                    components: [
                        {
                            internalType: 'uint32',
                            name: 'ip',
                            type: 'uint32'
                        },
                        {
                            internalType: 'uint128',
                            name: 'ipv6',
                            type: 'uint128'
                        },
                        {
                            internalType: 'uint32',
                            name: 'port',
                            type: 'uint32'
                        },
                        {
                            internalType: 'address',
                            name: 'nodeAddress',
                            type: 'address'
                        },
                        {
                            internalType: 'uint256',
                            name: 'reward',
                            type: 'uint256'
                        },
                        {
                            internalType: 'uint256',
                            name: 'senderPubKey',
                            type: 'uint256'
                        },
                        {
                            internalType: 'uint256',
                            name: 'receiverPubKey',
                            type: 'uint256'
                        }
                    ],
                    internalType: 'struct LibStakingStorage.Validator[]',
                    name: '',
                    type: 'tuple[]'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'epochNumber',
                    type: 'uint256'
                },
                {
                    internalType: 'address',
                    name: 'validatorStakerAddress',
                    type: 'address'
                },
                {
                    internalType: 'address',
                    name: 'voterStakerAddress',
                    type: 'address'
                }
            ],
            name: 'getVotingStatusToKickValidator',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                },
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'account',
                    type: 'address'
                }
            ],
            name: 'isActiveValidator',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'account',
                    type: 'address'
                }
            ],
            name: 'isActiveValidatorByNodeAddress',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'isReadyForNextEpoch',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'reason',
                    type: 'uint256'
                }
            ],
            name: 'kickPenaltyPercentByReason',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'nextValidatorCountForConsensus',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'nodeAddress',
                    type: 'address'
                }
            ],
            name: 'nodeAddressToStakerAddress',
            outputs: [
                {
                    internalType: 'address',
                    name: '',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'stakerAddress',
                    type: 'address'
                }
            ],
            name: 'readyForNextEpoch',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'stakerAddress',
                    type: 'address'
                }
            ],
            name: 'shouldKickValidator',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'state',
            outputs: [
                {
                    internalType: 'enum LibStakingStorage.States',
                    name: '',
                    type: 'uint8'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'stakerAddress',
                    type: 'address'
                }
            ],
            name: 'validators',
            outputs: [
                {
                    components: [
                        {
                            internalType: 'uint32',
                            name: 'ip',
                            type: 'uint32'
                        },
                        {
                            internalType: 'uint128',
                            name: 'ipv6',
                            type: 'uint128'
                        },
                        {
                            internalType: 'uint32',
                            name: 'port',
                            type: 'uint32'
                        },
                        {
                            internalType: 'address',
                            name: 'nodeAddress',
                            type: 'address'
                        },
                        {
                            internalType: 'uint256',
                            name: 'reward',
                            type: 'uint256'
                        },
                        {
                            internalType: 'uint256',
                            name: 'senderPubKey',
                            type: 'uint256'
                        },
                        {
                            internalType: 'uint256',
                            name: 'receiverPubKey',
                            type: 'uint256'
                        }
                    ],
                    internalType: 'struct LibStakingStorage.Validator',
                    name: '',
                    type: 'tuple'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        }
    ]
}; //# sourceMappingURL=StakingData.js.map
}),
"[project]/node_modules/@lit-protocol/contracts-sdk/src/abis/StakingBalances.sol/StakingBalancesData.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StakingBalancesData = void 0;
exports.StakingBalancesData = {
    date: '2023-11-14T15:45:41Z',
    address: '0x095251de2aD2A78aDe96F2a11F7feAA7CF93e6B5',
    contractName: 'StakingBalances',
    abi: [
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_selector',
                    type: 'bytes4'
                }
            ],
            name: 'CannotAddFunctionToDiamondThatAlreadyExists',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4[]',
                    name: '_selectors',
                    type: 'bytes4[]'
                }
            ],
            name: 'CannotAddSelectorsToZeroAddress',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_selector',
                    type: 'bytes4'
                }
            ],
            name: 'CannotRemoveFunctionThatDoesNotExist',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_selector',
                    type: 'bytes4'
                }
            ],
            name: 'CannotRemoveImmutableFunction',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_selector',
                    type: 'bytes4'
                }
            ],
            name: 'CannotReplaceFunctionThatDoesNotExists',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_selector',
                    type: 'bytes4'
                }
            ],
            name: 'CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4[]',
                    name: '_selectors',
                    type: 'bytes4[]'
                }
            ],
            name: 'CannotReplaceFunctionsFromFacetWithZeroAddress',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_selector',
                    type: 'bytes4'
                }
            ],
            name: 'CannotReplaceImmutableFunction',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'uint8',
                    name: '_action',
                    type: 'uint8'
                }
            ],
            name: 'IncorrectFacetCutAction',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_initializationContractAddress',
                    type: 'address'
                },
                {
                    internalType: 'bytes',
                    name: '_calldata',
                    type: 'bytes'
                }
            ],
            name: 'InitializationFunctionReverted',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_contractAddress',
                    type: 'address'
                },
                {
                    internalType: 'string',
                    name: '_message',
                    type: 'string'
                }
            ],
            name: 'NoBytecodeAtAddress',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_facetAddress',
                    type: 'address'
                }
            ],
            name: 'NoSelectorsProvidedForFacetForCut',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_user',
                    type: 'address'
                },
                {
                    internalType: 'address',
                    name: '_contractOwner',
                    type: 'address'
                }
            ],
            name: 'NotContractOwner',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_facetAddress',
                    type: 'address'
                }
            ],
            name: 'RemoveFacetAddressMustBeZeroAddress',
            type: 'error'
        },
        {
            anonymous: false,
            inputs: [
                {
                    components: [
                        {
                            internalType: 'address',
                            name: 'facetAddress',
                            type: 'address'
                        },
                        {
                            internalType: 'enum IDiamond.FacetCutAction',
                            name: 'action',
                            type: 'uint8'
                        },
                        {
                            internalType: 'bytes4[]',
                            name: 'functionSelectors',
                            type: 'bytes4[]'
                        }
                    ],
                    indexed: false,
                    internalType: 'struct IDiamond.FacetCut[]',
                    name: '_diamondCut',
                    type: 'tuple[]'
                },
                {
                    indexed: false,
                    internalType: 'address',
                    name: '_init',
                    type: 'address'
                },
                {
                    indexed: false,
                    internalType: 'bytes',
                    name: '_calldata',
                    type: 'bytes'
                }
            ],
            name: 'DiamondCut',
            type: 'event'
        },
        {
            inputs: [
                {
                    components: [
                        {
                            internalType: 'address',
                            name: 'facetAddress',
                            type: 'address'
                        },
                        {
                            internalType: 'enum IDiamond.FacetCutAction',
                            name: 'action',
                            type: 'uint8'
                        },
                        {
                            internalType: 'bytes4[]',
                            name: 'functionSelectors',
                            type: 'bytes4[]'
                        }
                    ],
                    internalType: 'struct IDiamond.FacetCut[]',
                    name: '_diamondCut',
                    type: 'tuple[]'
                },
                {
                    internalType: 'address',
                    name: '_init',
                    type: 'address'
                },
                {
                    internalType: 'bytes',
                    name: '_calldata',
                    type: 'bytes'
                }
            ],
            name: 'diamondCut',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_functionSelector',
                    type: 'bytes4'
                }
            ],
            name: 'facetAddress',
            outputs: [
                {
                    internalType: 'address',
                    name: 'facetAddress_',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'facetAddresses',
            outputs: [
                {
                    internalType: 'address[]',
                    name: 'facetAddresses_',
                    type: 'address[]'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_facet',
                    type: 'address'
                }
            ],
            name: 'facetFunctionSelectors',
            outputs: [
                {
                    internalType: 'bytes4[]',
                    name: '_facetFunctionSelectors',
                    type: 'bytes4[]'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'facets',
            outputs: [
                {
                    components: [
                        {
                            internalType: 'address',
                            name: 'facetAddress',
                            type: 'address'
                        },
                        {
                            internalType: 'bytes4[]',
                            name: 'functionSelectors',
                            type: 'bytes4[]'
                        }
                    ],
                    internalType: 'struct IDiamondLoupe.Facet[]',
                    name: 'facets_',
                    type: 'tuple[]'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bytes4',
                    name: '_interfaceId',
                    type: 'bytes4'
                }
            ],
            name: 'supportsInterface',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'previousOwner',
                    type: 'address'
                },
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'newOwner',
                    type: 'address'
                }
            ],
            name: 'OwnershipTransferred',
            type: 'event'
        },
        {
            inputs: [],
            name: 'owner',
            outputs: [
                {
                    internalType: 'address',
                    name: 'owner_',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: '_newOwner',
                    type: 'address'
                }
            ],
            name: 'transferOwnership',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [],
            name: 'ActiveValidatorsCannotLeave',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'aliasAccount',
                    type: 'address'
                },
                {
                    internalType: 'address',
                    name: 'stakerAddress',
                    type: 'address'
                }
            ],
            name: 'AliasNotOwnedBySender',
            type: 'error'
        },
        {
            inputs: [],
            name: 'CallerNotOwner',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'aliasAccount',
                    type: 'address'
                }
            ],
            name: 'CannotRemoveAliasOfActiveValidator',
            type: 'error'
        },
        {
            inputs: [],
            name: 'CannotStakeZero',
            type: 'error'
        },
        {
            inputs: [],
            name: 'CannotWithdrawZero',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'aliasCount',
                    type: 'uint256'
                }
            ],
            name: 'MaxAliasCountReached',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'sender',
                    type: 'address'
                }
            ],
            name: 'OnlyStakingContract',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'amountStaked',
                    type: 'uint256'
                },
                {
                    internalType: 'uint256',
                    name: 'minimumStake',
                    type: 'uint256'
                }
            ],
            name: 'StakeMustBeGreaterThanMinimumStake',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'amountStaked',
                    type: 'uint256'
                },
                {
                    internalType: 'uint256',
                    name: 'maximumStake',
                    type: 'uint256'
                }
            ],
            name: 'StakeMustBeLessThanMaximumStake',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'stakerAddress',
                    type: 'address'
                }
            ],
            name: 'StakerNotPermitted',
            type: 'error'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'yourBalance',
                    type: 'uint256'
                },
                {
                    internalType: 'uint256',
                    name: 'requestedWithdrawlAmount',
                    type: 'uint256'
                }
            ],
            name: 'TryingToWithdrawMoreThanStaked',
            type: 'error'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'staker',
                    type: 'address'
                },
                {
                    indexed: false,
                    internalType: 'address',
                    name: 'aliasAccount',
                    type: 'address'
                }
            ],
            name: 'AliasAdded',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'staker',
                    type: 'address'
                },
                {
                    indexed: false,
                    internalType: 'address',
                    name: 'aliasAccount',
                    type: 'address'
                }
            ],
            name: 'AliasRemoved',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'newMaxAliasCount',
                    type: 'uint256'
                }
            ],
            name: 'MaxAliasCountSet',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'newMaximumStake',
                    type: 'uint256'
                }
            ],
            name: 'MaximumStakeSet',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'newMinimumStake',
                    type: 'uint256'
                }
            ],
            name: 'MinimumStakeSet',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: false,
                    internalType: 'address',
                    name: 'staker',
                    type: 'address'
                }
            ],
            name: 'PermittedStakerAdded',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: false,
                    internalType: 'address',
                    name: 'staker',
                    type: 'address'
                }
            ],
            name: 'PermittedStakerRemoved',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: false,
                    internalType: 'bool',
                    name: 'permittedStakersOn',
                    type: 'bool'
                }
            ],
            name: 'PermittedStakersOnChanged',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: false,
                    internalType: 'address',
                    name: 'newResolverAddress',
                    type: 'address'
                }
            ],
            name: 'ResolverContractAddressSet',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'staker',
                    type: 'address'
                },
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'reward',
                    type: 'uint256'
                }
            ],
            name: 'RewardPaid',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'staker',
                    type: 'address'
                },
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'amount',
                    type: 'uint256'
                }
            ],
            name: 'Staked',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'newTokenRewardPerTokenPerEpoch',
                    type: 'uint256'
                }
            ],
            name: 'TokenRewardPerTokenPerEpochSet',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'staker',
                    type: 'address'
                },
                {
                    indexed: false,
                    internalType: 'address',
                    name: 'aliasAccount',
                    type: 'address'
                }
            ],
            name: 'ValidatorNotRewardedBecauseAlias',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'staker',
                    type: 'address'
                },
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'amount',
                    type: 'uint256'
                }
            ],
            name: 'ValidatorRewarded',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'staker',
                    type: 'address'
                },
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'amount',
                    type: 'uint256'
                }
            ],
            name: 'ValidatorTokensPenalized',
            type: 'event'
        },
        {
            anonymous: false,
            inputs: [
                {
                    indexed: true,
                    internalType: 'address',
                    name: 'staker',
                    type: 'address'
                },
                {
                    indexed: false,
                    internalType: 'uint256',
                    name: 'amount',
                    type: 'uint256'
                }
            ],
            name: 'Withdrawn',
            type: 'event'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'aliasAccount',
                    type: 'address'
                }
            ],
            name: 'addAlias',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'staker',
                    type: 'address'
                }
            ],
            name: 'addPermittedStaker',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address[]',
                    name: 'stakers',
                    type: 'address[]'
                }
            ],
            name: 'addPermittedStakers',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'account',
                    type: 'address'
                }
            ],
            name: 'balanceOf',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'account',
                    type: 'address'
                }
            ],
            name: 'checkStakingAmounts',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'account',
                    type: 'address'
                }
            ],
            name: 'getReward',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [],
            name: 'getStakingAddress',
            outputs: [
                {
                    internalType: 'address',
                    name: '',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'getTokenAddress',
            outputs: [
                {
                    internalType: 'address',
                    name: '',
                    type: 'address'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'staker',
                    type: 'address'
                }
            ],
            name: 'isPermittedStaker',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'maximumStake',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [],
            name: 'minimumStake',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'amount',
                    type: 'uint256'
                },
                {
                    internalType: 'address',
                    name: 'account',
                    type: 'address'
                }
            ],
            name: 'penalizeTokens',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [],
            name: 'permittedStakersOn',
            outputs: [
                {
                    internalType: 'bool',
                    name: '',
                    type: 'bool'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'aliasAccount',
                    type: 'address'
                }
            ],
            name: 'removeAlias',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'staker',
                    type: 'address'
                }
            ],
            name: 'removePermittedStaker',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'staker',
                    type: 'address'
                },
                {
                    internalType: 'uint256',
                    name: 'balance',
                    type: 'uint256'
                }
            ],
            name: 'restakePenaltyTokens',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'account',
                    type: 'address'
                }
            ],
            name: 'rewardOf',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'amount',
                    type: 'uint256'
                },
                {
                    internalType: 'address',
                    name: 'account',
                    type: 'address'
                }
            ],
            name: 'rewardValidator',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'address',
                    name: 'newResolverAddress',
                    type: 'address'
                }
            ],
            name: 'setContractResolver',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'newMaxAliasCount',
                    type: 'uint256'
                }
            ],
            name: 'setMaxAliasCount',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'newMaximumStake',
                    type: 'uint256'
                }
            ],
            name: 'setMaximumStake',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'newMinimumStake',
                    type: 'uint256'
                }
            ],
            name: 'setMinimumStake',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'bool',
                    name: 'permitted',
                    type: 'bool'
                }
            ],
            name: 'setPermittedStakersOn',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'amount',
                    type: 'uint256'
                },
                {
                    internalType: 'address',
                    name: 'account',
                    type: 'address'
                }
            ],
            name: 'stake',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [],
            name: 'totalStaked',
            outputs: [
                {
                    internalType: 'uint256',
                    name: '',
                    type: 'uint256'
                }
            ],
            stateMutability: 'view',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'balance',
                    type: 'uint256'
                },
                {
                    internalType: 'address',
                    name: 'recipient',
                    type: 'address'
                }
            ],
            name: 'transferPenaltyTokens',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'amount',
                    type: 'uint256'
                },
                {
                    internalType: 'address',
                    name: 'account',
                    type: 'address'
                }
            ],
            name: 'withdraw',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [],
            name: 'withdraw',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        },
        {
            inputs: [
                {
                    internalType: 'uint256',
                    name: 'balance',
                    type: 'uint256'
                }
            ],
            name: 'withdrawPenaltyTokens',
            outputs: [],
            stateMutability: 'nonpayable',
            type: 'function'
        }
    ]
}; //# sourceMappingURL=StakingBalancesData.js.map
}),
"[project]/node_modules/@lit-protocol/contracts-sdk/src/lib/auth-utils.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.stringToArrayify = exports.totpAuthFactorParser = exports.whatsAppOtpAuthFactorParser = exports.smsOtpAuthFactorParser = exports.emailOtpAuthFactorParser = void 0;
exports.getAuthIdByAuthMethod = getAuthIdByAuthMethod;
exports.getEthAuthMethodId = getEthAuthMethodId;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/contracts-sdk/node_modules/tslib/tslib.es6.js [app-ssr] (ecmascript)");
const constants_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/contracts-sdk/node_modules/@lit-protocol/constants/src/index.js [app-ssr] (ecmascript)");
const ethers_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-ssr] (ecmascript)");
const jose = tslib_1.__importStar(__turbopack_context__.r("[project]/node_modules/jose/dist/node/cjs/index.js [app-ssr] (ecmascript)"));
/**
 * Code here is ported from `packages/lit-auth-client` due to circular dep errors
 */ async function getAuthIdByAuthMethod(authMethod) {
    let authMethodId;
    switch(authMethod.authMethodType){
        case 1:
            authMethodId = getEthAuthMethodId(authMethod);
            break;
        case 4:
            authMethodId = await getDiscordAuthId(authMethod);
            break;
        case 3:
            authMethodId = await getWebauthnAuthId(authMethod);
            break;
        case 6:
            authMethodId = await getGoogleJwtAuthId(authMethod);
            break;
        case 9:
            authMethodId = await getStytchAuthId(authMethod);
            break;
        case 10:
        case 11:
        case 12:
        case 13:
            authMethodId = await getStytchFactorAuthMethodId(authMethod);
            break;
        default:
            throw new constants_1.InvalidArgumentException({
                info: {
                    authMethod
                }
            }, `Unsupported auth method type: ${authMethod.authMethodType}`);
    }
    return authMethodId;
}
/**
 * Get the auth method id for an eth auth method, the access token can either be an auth sig or a session sigs object
 * @param authMethod
 * @returns
 */ function getEthAuthMethodId(authMethod) {
    let accessToken;
    // -- try if access token can be parsed as JSON object first
    try {
        accessToken = JSON.parse(authMethod.accessToken);
    } catch (err) {
        throw new constants_1.InvalidArgumentException({
            info: {
                authMethod
            },
            cause: err
        }, 'Unable to parse access token as JSON object');
    }
    const address = accessToken.address;
    // -- check if address is empty
    if (!address) {
        throw new constants_1.NoWalletException({
            info: {
                authMethod
            }
        }, 'No address found in access token');
    }
    return ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes(`${address}:lit`));
}
async function getDiscordAuthId(authMethod) {
    const _clientId = '1052874239658692668';
    // -- get user id from access token
    let userId;
    const meResponse = await fetch('https://discord.com/api/users/@me', {
        method: 'GET',
        headers: {
            authorization: `Bearer ${authMethod.accessToken}`
        }
    });
    if (meResponse.ok) {
        const user = await meResponse.json();
        userId = user.id;
    } else {
        throw new constants_1.NetworkError({
            info: {
                authMethod
            }
        }, 'Unable to verify Discord account');
    }
    // -- get auth method id
    const authMethodId = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes(`${userId}:${_clientId}`));
    return authMethodId;
}
async function getWebauthnAuthId(authMethod) {
    let credentialId;
    const rpNameToUse = 'lit';
    try {
        credentialId = JSON.parse(authMethod.accessToken).rawId;
    } catch (err) {
        throw new constants_1.InvalidArgumentException({
            info: {
                authMethod
            },
            cause: err
        }, `Error when parsing auth method to generate auth method ID for WebAuthn`);
    }
    const authMethodId = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes(`${credentialId}:${rpNameToUse}`));
    return authMethodId;
}
async function getStytchAuthId(authMethod) {
    try {
        const tokenBody = _parseJWT(authMethod.accessToken);
        const userId = tokenBody['sub'];
        const orgId = tokenBody['aud'][0];
        const authMethodId = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes(`${userId.toLowerCase()}:${orgId.toLowerCase()}`));
        return authMethodId;
    } catch (err) {
        throw new constants_1.InvalidArgumentException({
            info: {
                authMethod
            },
            cause: err
        }, `Error while parsing auth method to generate auth method id for Stytch OTP`);
    }
}
/**
 * Get auth method id that can be used to look up and interact with
 * PKPs associated with the given auth method.
 * Will parse out the given `authentication factor` and use the transport
 * for the otp code as the `user identifier` for the given auth method.
 * @param {AuthMethod} authMethod - Auth method object
 *
 * @returns {Promise<string>} - Auth method id
 */ function getStytchFactorAuthMethodId(authMethod) {
    return new Promise((resolve, reject)=>{
        const accessToken = authMethod.accessToken;
        const parsedToken = _parseJWT(accessToken);
        let factor = 'email';
        switch(authMethod.authMethodType){
            case 10:
                factor = 'email';
                break;
            case 11:
                factor = 'sms';
                break;
            case 12:
                factor = 'whatsApp';
                break;
            case 13:
                factor = 'totp';
                break;
            default:
                throw new constants_1.InvalidArgumentException({
                    info: {
                        authMethod
                    }
                }, `Unsupport stytch auth type`);
        }
        const factorParser = _resolveAuthFactor(factor).parser;
        try {
            resolve(factorParser(parsedToken, 'https://stytch.com/session'));
        } catch (e) {
            reject(e);
        }
    });
}
async function getGoogleJwtAuthId(authMethod) {
    const tokenPayload = jose.decodeJwt(authMethod.accessToken);
    const userId = tokenPayload['sub'];
    const audience = tokenPayload['aud'];
    const authMethodId = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes(`${userId}:${audience}`));
    return authMethodId;
}
/**
 *
 * @param jwt token to parse
 * @returns {string}- userId contained within the token message
 */ function _parseJWT(jwt) {
    const parts = jwt.split('.');
    if (parts.length !== 3) {
        throw new constants_1.WrongParamFormat({
            info: {
                jwt
            }
        }, 'Invalid token length');
    }
    const body = Buffer.from(parts[1], 'base64');
    const parsedBody = JSON.parse(body.toString('ascii'));
    console.log('JWT body: ', parsedBody);
    return parsedBody;
}
const emailOtpAuthFactorParser = (parsedToken, provider)=>{
    const session = parsedToken[provider];
    const authFactors = session['authentication_factors'];
    const authFactor = authFactors.find((value, _index, _obj)=>{
        if (value.email_factor) return value;
    });
    if (!authFactor) {
        throw new constants_1.InvalidArgumentException({
            info: {
                parsedToken,
                provider
            }
        }, 'Could not find email authentication info in session');
    }
    const audience = parsedToken['aud'][0];
    if (!audience) {
        throw new constants_1.InvalidArgumentException({
            info: {
                parsedToken,
                provider
            }
        }, 'Token does not contain an audience (project identifier), aborting');
    }
    const userId = authFactor.email_factor.email_address;
    const authMethodId = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes(`${userId.toLowerCase()}:${audience.toLowerCase()}`));
    return authMethodId;
};
exports.emailOtpAuthFactorParser = emailOtpAuthFactorParser;
const smsOtpAuthFactorParser = (parsedToken, provider)=>{
    const session = parsedToken[provider];
    const authFactors = session['authentication_factors'];
    let authFactor = authFactors.find((value, _index, _obj)=>{
        if (value.phone_number_factor) return value;
    });
    if (!authFactor) {
        throw new constants_1.InvalidArgumentException({
            info: {
                parsedToken,
                provider
            }
        }, 'Could not find email authentication info in session');
    }
    const audience = parsedToken['aud'][0];
    if (!audience) {
        throw new constants_1.InvalidArgumentException({
            info: {
                parsedToken,
                provider
            }
        }, 'Token does not contain an audience (project identifier), aborting');
    }
    const userId = authFactor.phone_number_factor.phone_number;
    const authMethodId = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes(`${userId.toLowerCase()}:${audience.toLowerCase()}`));
    return authMethodId;
};
exports.smsOtpAuthFactorParser = smsOtpAuthFactorParser;
const whatsAppOtpAuthFactorParser = (parsedToken, provider)=>{
    const session = parsedToken[provider];
    const authFactors = session['authentication_factors'];
    let authFactor = authFactors.find((value, _index, _obj)=>{
        if (value.phone_number_factor) return value;
    });
    if (!authFactor) {
        throw new constants_1.InvalidArgumentException({
            info: {
                parsedToken,
                provider
            }
        }, 'Could not find email authentication info in session');
    }
    const audience = parsedToken['aud'][0];
    if (!audience) {
        throw new constants_1.InvalidArgumentException({
            info: {
                parsedToken,
                provider
            }
        }, 'Token does not contain an audience (project identifier), aborting');
    }
    const userId = authFactor.phone_number_factor.phone_number;
    const authMethodId = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes(`${userId.toLowerCase()}:${audience.toLowerCase()}`));
    return authMethodId;
};
exports.whatsAppOtpAuthFactorParser = whatsAppOtpAuthFactorParser;
const totpAuthFactorParser = (parsedToken, provider)=>{
    const session = parsedToken[provider];
    const authFactors = session['authentication_factors'];
    let authFactor = authFactors.find((value, _index, _obj)=>{
        if (value.phone_number_factor) return value;
    });
    if (!authFactor) {
        throw new constants_1.InvalidArgumentException({
            info: {
                parsedToken,
                provider
            }
        }, 'Could not find email authentication info in session');
    }
    const audience = parsedToken['aud'][0];
    if (!audience) {
        throw new constants_1.InvalidArgumentException({
            info: {
                parsedToken,
                provider
            }
        }, 'Token does not contain an audience (project identifier), aborting');
    }
    const userId = authFactor.authenticator_app_factor.totp_id;
    const authMethodId = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes(`${userId.toLowerCase()}:${audience.toLowerCase()}`));
    return authMethodId;
};
exports.totpAuthFactorParser = totpAuthFactorParser;
function _resolveAuthFactor(factor) {
    switch(factor){
        case 'email':
            return {
                parser: exports.emailOtpAuthFactorParser,
                authMethodType: 10
            };
        case 'sms':
            return {
                parser: exports.smsOtpAuthFactorParser,
                authMethodType: 11
            };
        case 'whatsApp':
            return {
                parser: exports.whatsAppOtpAuthFactorParser,
                authMethodType: 12
            };
        case 'totp':
            return {
                parser: exports.totpAuthFactorParser,
                authMethodType: 13
            };
    }
    throw new constants_1.InvalidArgumentException({
        info: {
            factor
        }
    }, `Error could not find auth with factor ${factor}`);
}
/**
 * Converts a string into a byte array (arrayified value)
 * @param str - The input string to be converted.
 * @returns A Uint8Array representing the arrayified value of the string.
 */ const stringToArrayify = (str)=>{
    try {
        // Convert the string to a UTF-8 encoded byte array
        const encoder = new TextEncoder();
        return encoder.encode(str);
    } catch (e) {
        throw new constants_1.InvalidParamType({
            info: {
                str
            }
        }, `Error converting string to arrayify`);
    }
};
exports.stringToArrayify = stringToArrayify; //# sourceMappingURL=auth-utils.js.map
}),
"[project]/node_modules/@lit-protocol/contracts-sdk/src/lib/helpers/getBytes32FromMultihash.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getBytes32FromMultihash = void 0;
const constants_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/contracts-sdk/node_modules/@lit-protocol/constants/src/index.js [app-ssr] (ecmascript)");
/**
 * NOTE: This function requires the "multiformats/cid" package in order to work
 *
 * Partition multihash string into object representing multihash
 *
 * @param {string} ipfsId A base58 encoded multihash string
 * @param {CIDParser} CID The CID object from the "multiformats/cid" package
 *
 * @example
 * const CID = require('multiformats/cid')
 * const ipfsId = 'QmZKLGf3vgYsboM7WVUS9X56cJSdLzQVacNp841wmEDRkW'
 * const {digest, hashFunction, size} = getBytes32FromMultihash(ipfsId, CID)
 * console.log(digest) // string
 * console.log(hashFunction) // number
 * console.log(size) // number
 *
 * @returns {IPFSHash}
 */ const getBytes32FromMultihash = (ipfsId, CID)=>{
    if (!CID) {
        throw new constants_1.ParamsMissingError({
            info: {
                ipfsId,
                CID
            }
        }, 'CID is required. Please import from "multiformats/cid" package, and pass the CID object to the function.');
    }
    if (!ipfsId) {
        throw new constants_1.ParamsMissingError({
            info: {
                ipfsId
            }
        }, 'ipfsId is required');
    }
    let cid;
    try {
        cid = CID.parse(ipfsId);
    } catch (e) {
        throw new constants_1.InvalidArgumentException({
            info: {
                ipfsId,
                CID
            }
        }, 'Error parsing CID');
    }
    const hashFunction = cid.multihash.code;
    const size = cid.multihash.size;
    const digest = '0x' + Buffer.from(cid.multihash.digest).toString('hex');
    const ipfsHash = {
        digest,
        hashFunction,
        size
    };
    return ipfsHash;
};
exports.getBytes32FromMultihash = getBytes32FromMultihash; //# sourceMappingURL=getBytes32FromMultihash.js.map
}),
"[project]/node_modules/@lit-protocol/contracts-sdk/src/lib/utils.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.convertRequestsPerDayToPerSecond = convertRequestsPerDayToPerSecond;
exports.calculateUTCMidnightExpiration = calculateUTCMidnightExpiration;
exports.requestsToKilosecond = requestsToKilosecond;
exports.requestsToDay = requestsToDay;
exports.requestsToSecond = requestsToSecond;
const constants_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/contracts-sdk/node_modules/@lit-protocol/constants/src/index.js [app-ssr] (ecmascript)");
// Converts the number of requests per day to requests per second.
function convertRequestsPerDayToPerSecond(requestsPerDay) {
    const secondsInADay = 86400; // 24 hours * 60 minutes * 60 seconds
    return requestsPerDay / secondsInADay;
}
// Calculates the expiration timestamp in UTC for a given number of days from now.
// The expiration time is set to midnight (00:00:00) UTC of the target day.
function calculateUTCMidnightExpiration(daysFromNow) {
    // Create a Date object for the current time in UTC
    const now = new Date();
    const utcNow = Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate());
    // Create a future Date object in UTC, adding the specified number of days
    const futureDate = new Date(utcNow);
    futureDate.setUTCDate(futureDate.getUTCDate() + daysFromNow);
    futureDate.setUTCHours(0, 0, 0, 0); // Set to midnight UTC
    return Math.floor(futureDate.getTime() / 1000);
}
function requestsToKilosecond({ period, requests }) {
    const secondsPerDay = 86400; // Total seconds in a day
    const kilosecondsPerDay = secondsPerDay / 1000; // Convert seconds in a day to kiloseconds
    switch(period){
        case 'day':
            return Math.round(requests / kilosecondsPerDay);
        case 'second':
            return Math.round(requests * 1000);
        default:
            throw new constants_1.InvalidArgumentException({
                info: {
                    period,
                    requests
                }
            }, 'Invalid period');
    }
}
function requestsToDay({ period, requests }) {
    const secondsPerDay = 86400; // Total seconds in a day
    switch(period){
        case 'second':
            return Math.round(requests * secondsPerDay);
        case 'kilosecond':
            return Math.round(requests * 86);
        default:
            throw new constants_1.InvalidArgumentException({
                info: {
                    period,
                    requests
                }
            }, 'Invalid period');
    }
}
function requestsToSecond({ period, requests }) {
    const secondsPerDay = 86400; // Total seconds in a day
    switch(period){
        case 'day':
            return Math.round(requests / secondsPerDay);
        case 'kilosecond':
            return Math.round(requests * 1000);
        default:
            throw new constants_1.InvalidArgumentException({
                info: {
                    period,
                    requests
                }
            }, 'Invalid period');
    }
} //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/@lit-protocol/contracts-sdk/src/lib/contracts-sdk.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LitContracts = exports.asyncForEachReturn = void 0;
/* eslint-disable import/order */ const misc_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/misc/src/index.js [app-ssr] (ecmascript)");
const ethers_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-ssr] (ecmascript)");
const hex2dec_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/contracts-sdk/src/lib/hex2dec.js [app-ssr] (ecmascript)");
// ----- autogen:import-data:start  -----
// Generated at 2023-11-07T01:50:52.460Z
const AllowlistData_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/contracts-sdk/src/abis/Allowlist.sol/AllowlistData.js [app-ssr] (ecmascript)");
const LITTokenData_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/contracts-sdk/src/abis/LITToken.sol/LITTokenData.js [app-ssr] (ecmascript)");
const MultisenderData_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/contracts-sdk/src/abis/Multisender.sol/MultisenderData.js [app-ssr] (ecmascript)");
const PKPHelperData_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/contracts-sdk/src/abis/PKPHelper.sol/PKPHelperData.js [app-ssr] (ecmascript)");
const PKPNFTData_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/contracts-sdk/src/abis/PKPNFT.sol/PKPNFTData.js [app-ssr] (ecmascript)");
const PKPNFTMetadataData_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/contracts-sdk/src/abis/PKPNFTMetadata.sol/PKPNFTMetadataData.js [app-ssr] (ecmascript)");
const PKPPermissionsData_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/contracts-sdk/src/abis/PKPPermissions.sol/PKPPermissionsData.js [app-ssr] (ecmascript)");
const PubkeyRouterData_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/contracts-sdk/src/abis/PubkeyRouter.sol/PubkeyRouterData.js [app-ssr] (ecmascript)");
const RateLimitNFTData_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/contracts-sdk/src/abis/RateLimitNFT.sol/RateLimitNFTData.js [app-ssr] (ecmascript)");
const StakingData_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/contracts-sdk/src/abis/Staking.sol/StakingData.js [app-ssr] (ecmascript)");
const StakingBalancesData_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/contracts-sdk/src/abis/StakingBalances.sol/StakingBalancesData.js [app-ssr] (ecmascript)");
// ----- autogen:imports:end  -----
const constants_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/contracts-sdk/node_modules/@lit-protocol/constants/src/index.js [app-ssr] (ecmascript)");
const logger_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/logger/src/index.js [app-ssr] (ecmascript)");
const misc_2 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/misc/src/index.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib/utils.js [app-ssr] (ecmascript)");
const auth_utils_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/contracts-sdk/src/lib/auth-utils.js [app-ssr] (ecmascript)");
const getBytes32FromMultihash_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/contracts-sdk/src/lib/helpers/getBytes32FromMultihash.js [app-ssr] (ecmascript)");
const utils_2 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/contracts-sdk/src/lib/utils.js [app-ssr] (ecmascript)");
// const DEFAULT_RPC = 'https://lit-protocol.calderachain.xyz/replica-http';
// const DEFAULT_READ_RPC = 'https://lit-protocol.calderachain.xyz/replica-http';
// This function asynchronously executes a provided callback function for each item in the given array.
// The callback function is awaited before continuing to the next iteration.
// The resulting array of callback return values is then returned.
//
// @param {Array<any>} array - The array to iterate over
// @param {Function} callback - The function to execute for each item in the array. This function
//                              must be asynchronous and should take the following parameters:
//                              - currentValue: The current item being processed in the array
//                              - index: The index of the current item being processed in the array
//                              - array: The array being iterated over
// @return {Array<any>} The array of callback return values
const asyncForEachReturn = async (array, callback)=>{
    const list = [];
    for(let index = 0; index < array.length; index++){
        const item = await callback(array[index], index, array);
        list.push(item);
    }
    return list;
};
exports.asyncForEachReturn = asyncForEachReturn;
// Due to the usage of arbitrum stylus contracts the gas limit is increased by 10% to avoid reverts due to out of gas errors
const GAS_LIMIT_INCREASE_PERCENTAGE = 10;
const GAS_LIMIT_ADJUSTMENT = ethers_1.ethers.BigNumber.from(100).add(GAS_LIMIT_INCREASE_PERCENTAGE);
// This code defines a LitContracts class that acts as a container for a collection of smart contracts. The class has a constructor that accepts an optional args object with provider and rpc properties. If no provider is specified, the class will create a default provider using the specified rpc URL. If no rpc URL is specified, the class will use a default URL.
// The class has a number of properties that represent the smart contract instances, such as accessControlConditionsContract, litTokenContract, pkpNftContract, etc. These smart contract instances are created by passing the contract address, ABI, and provider to the ethers.Contract constructor.
// The class also has a utils object with helper functions for converting between hexadecimal and decimal representation of numbers, as well as functions for working with multihashes and timestamps.
class LitContracts {
    // ----- autogen:declares:end  -----
    // make the constructor args optional
    constructor(args){
        this.randomPrivateKey = false;
        this.connected = false;
        this.isPKP = false;
        this.debug = false;
        /**
         * Logs a message to the console.
         *
         * @param {any} [args] An optional value to log with the message.
         */ this.log = (...args)=>{
            if (this.debug) {
                _a.logger.debug(...args);
            }
        };
        this.connect = async ()=>{
            // =======================================
            //          SETTING UP PROVIDER
            // =======================================
            // -------------------------------------------------
            //          (Browser) Setting up Provider
            // -------------------------------------------------
            let wallet;
            let SETUP_DONE = false;
            if (this.provider) {
                this.log('Using provided provider');
            } else if ((0, misc_1.isBrowser)() && !this.signer) {
                this.log("----- We're in the browser! -----");
                const web3Provider = window.ethereum;
                if (!web3Provider) {
                    const msg = 'No web3 provider found. Please install Brave, MetaMask or another web3 provider.';
                    alert(msg);
                    throw new constants_1.InitError({
                        info: {
                            web3Provider
                        }
                    }, msg);
                }
                function _decimalToHex(decimal) {
                    return '0x' + decimal.toString(16);
                }
                const chainInfo = constants_1.METAMASK_CHAIN_INFO_BY_NETWORK[this.network];
                const metamaskChainInfo = {
                    ...chainInfo,
                    chainId: _decimalToHex(chainInfo.chainId)
                };
                try {
                    await web3Provider.send('wallet_switchEthereumChain', [
                        {
                            chainId: metamaskChainInfo.chainId
                        }
                    ]);
                } catch (e) {
                    await web3Provider.request({
                        method: 'wallet_addEthereumChain',
                        params: [
                            metamaskChainInfo
                        ]
                    });
                }
                wallet = new ethers_1.ethers.providers.Web3Provider(web3Provider);
                await wallet.send('eth_requestAccounts', []);
                // this will ask metamask to connect to the wallet
                // this.signer = wallet.getSigner();
                this.provider = wallet;
            } else if ((0, misc_1.isNode)()) {
                this.log("----- We're in node! -----");
                this.provider = new ethers_1.ethers.providers.StaticJsonRpcProvider({
                    url: this.rpc,
                    skipFetchSetup: true
                });
            }
            // ======================================
            //          CUSTOM PRIVATE KEY
            // ======================================
            if (this.privateKey) {
                this.log('Using your own private key');
                this.signer = new ethers_1.ethers.Wallet(this.privateKey, this.provider);
                this.provider = this.signer.provider;
                SETUP_DONE = true;
            }
            // =====================================
            //          SETTING UP SIGNER
            // =====================================
            if (!this.privateKey && this.randomPrivateKey || this.options?.storeOrUseStorageKey) {
                this.log('THIS.SIGNER:', this.signer);
                const STORAGE_KEY = 'lit-contracts-sdk-private-key';
                this.log("Let's see if you have a private key in your local storage!");
                // -- find private key in local storage
                let storagePrivateKey;
                try {
                    storagePrivateKey = localStorage.getItem(STORAGE_KEY);
                } catch (e) {
                // swallow
                // this.log('Not a problem.');
                }
                // -- (NOT FOUND) no private key found
                if (!storagePrivateKey) {
                    this.log('Not a problem, we will generate a random private key');
                    storagePrivateKey = ethers_1.ethers.utils.hexlify(ethers_1.ethers.utils.randomBytes(32));
                } else {
                    this.log("Found your private key in local storage. Let's use it!");
                }
                this.signer = new ethers_1.ethers.Wallet(storagePrivateKey, this.provider);
                this.log('- Your private key:', storagePrivateKey);
                this.log('- Your address:', await this.signer.getAddress());
                this.log('- this.signer:', this.signer);
                this.log('- this.provider.getSigner():', this.provider.getSigner());
                // -- (OPTION) store private key in local storage
                if (this.options?.storeOrUseStorageKey) {
                    this.log("You've set the option to store your private key in local storage.");
                    localStorage.setItem(STORAGE_KEY, storagePrivateKey);
                }
            } else {
                // ----------------------------------------
                //          Ask Metamask to sign
                // ----------------------------------------
                if ((0, misc_1.isBrowser)() && wallet && !SETUP_DONE) {
                    // this.log('HERE????');
                    this.log('this.signer:', this.signer);
                    this.signer = wallet.getSigner();
                }
            }
            if (this.signer !== undefined && this.signer !== null) {
                if ('litNodeClient' in this.signer && 'rpcProvider' in this.signer) {
                    this.log(`
  // ***********************************************************************************************
  //          THIS IS A PKP WALLET, USING IT AS A SIGNER AND ITS RPC PROVIDER AS PROVIDER
  // ***********************************************************************************************
        `);
                    // @ts-ignore
                    this.provider = this.signer.rpcProvider;
                    this.isPKP = true;
                }
            }
            this.log('Your Signer:', this.signer);
            this.log('Your Provider:', this.provider?.connection);
            if (!this.provider) {
                this.log('No provider found. Will try to use the one from the signer.');
                this.provider = this.signer.provider;
                this.log('Your Provider(from signer):', this.provider?.connection);
            }
            const addresses = await _a.getContractAddresses(this.network, this.customContext?.provider ?? this.provider, this.customContext);
            const logAddresses = Object.entries(addresses).reduce((output, [key, val])=>{
                // @ts-expect-error since the object hash returned by `getContractAddresses` is `any`, we have no types here
                output[key] = val.address;
                return output;
            }, {});
            this.log('resolved contract addresses for: ', this.network, logAddresses);
            if (addresses.Allowlist.abi) {
                this.allowlistContract = {
                    read: new ethers_1.ethers.Contract(addresses.Allowlist.address, addresses.Allowlist.abi, this.provider),
                    write: new ethers_1.ethers.Contract(addresses.Allowlist.address, addresses.Allowlist.abi, this.signer)
                };
            }
            if (addresses.LITToken.abi) {
                this.litTokenContract = {
                    read: new ethers_1.ethers.Contract(addresses.LITToken.address, addresses.LITToken.abi, this.provider),
                    write: new ethers_1.ethers.Contract(addresses.LITToken.address, addresses.LITToken.abi, this.signer)
                };
            }
            if (addresses.Multisender.abi) {
                this.multisenderContract = {
                    read: new ethers_1.ethers.Contract(addresses.Multisender.address, addresses.Multisender.abi, this.provider),
                    write: new ethers_1.ethers.Contract(addresses.Multisender.address, addresses.Multisender.abi, this.signer)
                };
            }
            if (addresses.PKPHelper.abi) {
                this.pkpHelperContract = {
                    read: new ethers_1.ethers.Contract(addresses.PKPHelper.address, addresses.PKPHelper.abi, this.provider),
                    write: new ethers_1.ethers.Contract(addresses.PKPHelper.address, addresses.PKPHelper.abi, this.signer)
                };
            }
            if (addresses.PKPNFT.abi) {
                this.pkpNftContract = {
                    read: new ethers_1.ethers.Contract(addresses.PKPNFT.address, addresses.PKPNFT.abi, this.provider),
                    write: new ethers_1.ethers.Contract(addresses.PKPNFT.address, addresses.PKPNFT.abi, this.signer)
                };
            }
            if (addresses.PKPNFTMetadata.abi) {
                this.pkpNftMetadataContract = {
                    read: new ethers_1.ethers.Contract(addresses.PKPNFTMetadata.address, addresses.PKPNFTMetadata.abi, this.provider),
                    write: new ethers_1.ethers.Contract(addresses.PKPNFTMetadata.address, addresses.PKPNFTMetadata.abi, this.signer)
                };
            }
            if (addresses.PKPPermissions.abi) {
                this.pkpPermissionsContract = {
                    read: new ethers_1.ethers.Contract(addresses.PKPPermissions.address, addresses.PKPPermissions.abi, this.provider),
                    write: new ethers_1.ethers.Contract(addresses.PKPPermissions.address, addresses.PKPPermissions.abi, this.signer)
                };
            }
            if (addresses.PubkeyRouter.abi) {
                this.pubkeyRouterContract = {
                    read: new ethers_1.ethers.Contract(addresses.PubkeyRouter.address, addresses.PubkeyRouter.abi, this.provider),
                    write: new ethers_1.ethers.Contract(addresses.PubkeyRouter.address, addresses.PubkeyRouter.abi, this.signer)
                };
            }
            if (addresses.RateLimitNFT.abi) {
                this.rateLimitNftContract = {
                    read: new ethers_1.ethers.Contract(addresses.RateLimitNFT.address, addresses.RateLimitNFT.abi, this.provider),
                    write: new ethers_1.ethers.Contract(addresses.RateLimitNFT.address, addresses.RateLimitNFT.abi, this.signer)
                };
            }
            if (addresses.Staking.abi) {
                this.stakingContract = {
                    read: new ethers_1.ethers.Contract(addresses.Staking.address, addresses.Staking.abi, this.provider),
                    write: new ethers_1.ethers.Contract(addresses.Staking.address, addresses.Staking.abi, this.signer)
                };
            }
            if (addresses.StakingBalances.abi) {
                this.stakingBalancesContract = {
                    read: new ethers_1.ethers.Contract(addresses.StakingBalances.address, addresses.StakingBalances.abi, this.provider),
                    write: new ethers_1.ethers.Contract(addresses.StakingBalances.address, addresses.StakingBalances.abi, this.signer)
                };
            }
            this.connected = true;
        };
        /**
         * Mints a new token with authentication.
         *
         * @param authMethod - The authentication method.
         * @param scopes - The permission scopes.
         * @param pubkey - The public key.
         * @param authMethodId - (optional) The authentication ID.
         * @param gasLimit - (optional) The gas limit.
         * @returns An object containing the PKP information and the transaction receipt.
         * @throws Error if the contracts are not connected, the contract is not available, authMethodType or accessToken is missing, or permission scopes are required.
         */ this.mintWithAuth = async ({ authMethod, scopes, pubkey, authMethodId, gasLimit })=>{
            // -- validate
            if (!this.connected) {
                throw new constants_1.InitError({
                    info: {
                        connected: this.connected
                    }
                }, 'Contracts are not connected. Please call connect() first');
            }
            if (!this.pkpNftContract) {
                throw new constants_1.InitError({
                    info: {
                        pkpNftContract: this.pkpNftContract
                    }
                }, 'Contract is not available');
            }
            if (authMethod && !authMethod?.authMethodType) {
                throw new constants_1.ParamsMissingError({
                    info: {
                        authMethod
                    }
                }, 'authMethodType is required');
            }
            if (authMethod && !authMethod?.accessToken && authMethod?.accessToken !== 'custom-auth') {
                throw new constants_1.ParamsMissingError({
                    info: {
                        authMethod
                    }
                }, 'accessToken is required');
            }
            if (scopes.length <= 0) {
                throw new constants_1.InvalidArgumentException({
                    info: {
                        scopes
                    }
                }, ` Permission scopes are required!
[0] No Permissions
[1] Sign Anything
[2] Only Sign Messages
Read more here:
https://developer.litprotocol.com/v3/sdk/wallets/auth-methods/#auth-method-scopes
      `);
            }
            // -- prepare
            const _pubkey = pubkey ?? '0x';
            // if scopes are list of strings, turn them into numbers
            const _scopes = scopes.map((scope)=>{
                if (typeof scope === 'string') {
                    return ethers_1.ethers.BigNumber.from(scope);
                }
                if (typeof scope === 'number') {
                    return ethers_1.ethers.BigNumber.from(scope.toString());
                }
                return scope;
            });
            const _authMethodId = authMethodId ?? await (0, auth_utils_1.getAuthIdByAuthMethod)(authMethod);
            // -- go
            const mintCost = await this.pkpNftContract.read.mintCost();
            // -- start minting
            const tx = await this._callWithAdjustedOverrides(this.pkpHelperContract.write, 'mintNextAndAddAuthMethods', [
                2,
                [
                    authMethod.authMethodType
                ],
                [
                    _authMethodId
                ],
                [
                    _pubkey
                ],
                [
                    [
                        ..._scopes
                    ]
                ],
                true,
                true
            ], {
                value: mintCost,
                gasLimit
            });
            const receipt = await tx.wait();
            const events = 'events' in receipt ? receipt.events : receipt.logs;
            if (!events || events.length <= 0) {
                throw new constants_1.TransactionError({
                    info: {
                        events,
                        receipt
                    }
                }, 'No events found in receipt');
            }
            if (!events[0].topics || events[0].topics.length < 1) {
                throw new constants_1.TransactionError({
                    info: {
                        events,
                        receipt
                    }
                }, `No topics found in events, cannot derive pkp information. Transaction hash: ${receipt.transactionHash} If you are using your own contracts please use ethers directly`);
            }
            const tokenId = events[0].topics[1];
            this.log('tokenId:', tokenId);
            let tries = 0;
            const maxAttempts = 10;
            let publicKey = '';
            while(tries < maxAttempts){
                publicKey = await this.pkpNftContract.read.getPubkey(tokenId);
                this.log('pkp pub key: ', publicKey);
                if (publicKey !== '0x') {
                    break;
                }
                tries++;
                await new Promise((resolve)=>{
                    setTimeout(resolve, 10000);
                });
            }
            if (publicKey.startsWith('0x')) {
                publicKey = publicKey.slice(2);
            }
            const pubkeyBuffer = Buffer.from(publicKey, 'hex');
            const ethAddress = (0, utils_1.computeAddress)(pubkeyBuffer);
            return {
                pkp: {
                    tokenId,
                    publicKey,
                    ethAddress
                },
                tx: receipt
            };
        };
        /**
         * Mints a new token with customer authentication.
         *
         * @param { Object } params - The parameters for minting a new token with customer authentication.
         * @param { string } params.authMethodId - The authentication method id.
         * @param { string[] | number[] } params.scopes - The permission scopes.
         * @param { string } params.authMethodType - The authentication method type.
         * @returns { Promise<MintWithAuthResponse<ContractReceipt>> } - An object containing the PKP information and the transaction receipt.
         * @throws { Error } - If the contracts are not connected, the contract is not available, authMethodType, or permission scopes are required.
         *
         */ this.mintWithCustomAuth = async (params)=>{
            const authMethodId = typeof params.authMethodId === 'string' ? (0, auth_utils_1.stringToArrayify)(params.authMethodId) : params.authMethodId;
            return this.mintWithAuth({
                ...params,
                authMethodId,
                authMethod: {
                    authMethodType: params.authMethodType,
                    accessToken: 'custom-auth'
                }
            });
        };
        /**
         * Adds a permitted authentication method for a given PKP token.
         *
         * @param {Object} params - The parameters for adding the permitted authentication method.
         * @param {string} params.pkpTokenId - The ID of the PKP token.
         * @param {AUTH_METHOD_TYPE_VALUES | number} params.authMethodType - The type of the authentication method.
         * @param {string | Uint8Array} params.authMethodId - The ID of the authentication method.
         * @param {AuthMethodScope[]} params.authMethodScopes - The scopes of the authentication method.
         * @param {string} [params.webAuthnPubkey] - The public key for WebAuthn.
         * @returns {Promise<any>} - A promise that resolves with the result of adding the permitted authentication method.
         * @throws {Error} - If an error occurs while adding the permitted authentication method.
         */ this.addPermittedAuthMethod = async ({ pkpTokenId, authMethodType, authMethodId, authMethodScopes, webAuthnPubkey })=>{
            const _authMethodId = typeof authMethodId === 'string' ? (0, auth_utils_1.stringToArrayify)(authMethodId) : authMethodId;
            const _webAuthnPubkey = webAuthnPubkey ?? '0x';
            try {
                const res = await this._callWithAdjustedOverrides(this.pkpPermissionsContract.write, 'addPermittedAuthMethod', [
                    pkpTokenId,
                    {
                        authMethodType: authMethodType,
                        id: _authMethodId,
                        userPubkey: _webAuthnPubkey
                    },
                    authMethodScopes
                ]);
                const receipt = await res.wait();
                return receipt;
            } catch (e) {
                throw new constants_1.TransactionError({
                    info: {
                        pkpTokenId,
                        authMethodType,
                        authMethodId,
                        authMethodScopes,
                        webAuthnPubkey
                    },
                    cause: e
                }, 'Adding permitted action failed');
            }
        };
        /**
         * Adds a permitted action to the PKP permissions contract.
         *
         * @param ipfsId - The IPFS ID of the action.
         * @param pkpTokenId - The PKP token ID.
         * @param authMethodScopes - Optional array of authentication method scopes.
         * @returns A promise that resolves to the result of the write operation.
         * @throws If an error occurs during the write operation.
         */ this.addPermittedAction = async ({ ipfsId, pkpTokenId, authMethodScopes })=>{
            const ipfsIdBytes = this.utils.getBytesFromMultihash(ipfsId);
            const scopes = authMethodScopes ?? [];
            try {
                const res = await this._callWithAdjustedOverrides(this.pkpPermissionsContract.write, 'addPermittedAction', [
                    pkpTokenId,
                    ipfsIdBytes,
                    scopes
                ]);
                const receipt = await res.wait();
                return receipt;
            } catch (e) {
                throw new constants_1.TransactionError({
                    info: {
                        pkpTokenId,
                        ipfsIdBytes,
                        scopes
                    },
                    cause: e
                }, 'Adding permitted action failed');
            }
        };
        /**
         * Mint a Capacity Credits NFT (RLI) token with the specified daily request rate and expiration period. The expiration date is calculated to be at midnight UTC, a specific number of days from now.
         *
         * @param {MintCapacityCreditsContext} context - The minting context.
         * @returns {Promise<MintCapacityCreditsRes>} - A promise that resolves to the minted capacity credits NFT response.
         * @throws {Error} - If the input parameters are invalid or an error occurs during the minting process.
         */ this.mintCapacityCreditsNFT = async ({ requestsPerDay, requestsPerSecond, requestsPerKilosecond, daysUntilUTCMidnightExpiration, gasLimit })=>{
            this.log('Minting Capacity Credits NFT...');
            // Validate input: at least one of the request parameters must be provided and more than 0
            if ((requestsPerDay === null || requestsPerDay === undefined || requestsPerDay <= 0) && (requestsPerSecond === null || requestsPerSecond === undefined || requestsPerSecond <= 0) && (requestsPerKilosecond === null || requestsPerKilosecond === undefined || requestsPerKilosecond <= 0)) {
                throw new constants_1.InvalidArgumentException({
                    info: {
                        requestsPerDay,
                        requestsPerSecond,
                        requestsPerKilosecond
                    }
                }, `At least one of requestsPerDay, requestsPerSecond, or requestsPerKilosecond is required and must be more than 0`);
            }
            // Calculate effectiveRequestsPerKilosecond based on provided parameters
            let effectiveRequestsPerKilosecond;
            // Determine the effective requests per kilosecond based on the input
            // -- requestsPerDay
            if (requestsPerDay !== undefined) {
                effectiveRequestsPerKilosecond = (0, utils_2.requestsToKilosecond)({
                    period: 'day',
                    requests: requestsPerDay
                });
            // -- requestsPerSecond
            } else if (requestsPerSecond !== undefined) {
                effectiveRequestsPerKilosecond = (0, utils_2.requestsToKilosecond)({
                    period: 'second',
                    requests: requestsPerSecond
                });
            // -- requestsPerKilosecond
            } else if (requestsPerKilosecond !== undefined) {
                effectiveRequestsPerKilosecond = requestsPerKilosecond;
            }
            // Check if effectiveRequestsPerKilosecond was successfully set
            if (effectiveRequestsPerKilosecond === undefined || effectiveRequestsPerKilosecond <= 0) {
                throw new constants_1.InvalidArgumentException({
                    info: {
                        effectiveRequestsPerKilosecond
                    }
                }, `Effective requests per kilosecond is required and must be more than 0`);
            }
            const expiresAt = (0, utils_2.calculateUTCMidnightExpiration)(daysUntilUTCMidnightExpiration);
            let mintCost;
            try {
                mintCost = await this.rateLimitNftContract.read.calculateCost(effectiveRequestsPerKilosecond, expiresAt);
            } catch (e) {
                this.log('Error calculating mint cost:', e);
                throw e;
            }
            this.log('Capacity Credits NFT mint cost:', mintCost.toString());
            if (requestsPerDay) this.log('Requests per day:', requestsPerDay);
            if (requestsPerSecond) this.log('Requests per second:', requestsPerSecond);
            this.log('Effective requests per kilosecond:', effectiveRequestsPerKilosecond);
            this.log(`Expires at (Unix Timestamp): ${expiresAt}`);
            const expirationDate = new Date(expiresAt * 1000);
            this.log('Expiration Date (UTC):', expirationDate.toUTCString());
            try {
                const res = await this._callWithAdjustedOverrides(this.rateLimitNftContract.write, 'mint', [
                    expiresAt
                ], {
                    value: mintCost,
                    gasLimit
                });
                const txHash = res.hash;
                const tx = await res.wait();
                this.log('xx Transaction:', tx);
                const tokenId = ethers_1.ethers.BigNumber.from(tx.logs[0].topics[3]);
                return {
                    rliTxHash: txHash,
                    capacityTokenId: tokenId,
                    capacityTokenIdStr: tokenId.toString()
                };
            } catch (e) {
                throw new constants_1.TransactionError({
                    info: {
                        requestsPerDay,
                        requestsPerSecond,
                        requestsPerKilosecond,
                        expiresAt
                    },
                    cause: e
                }, 'Minting capacity credits NFT failed');
            }
        };
        // getRandomPrivateKeySignerProvider = () => {
        //   const privateKey = ethers.utils.hexlify(ethers.utils.randomBytes(32));
        //   let provider;
        //   if (isBrowser()) {
        //     provider = new ethers.providers.Web3Provider(window.ethereum, 'any');
        //   } else {
        //     provider = new ethers.providers.StaticJsonRpcProvider({
        //       url: this.rpc,
        //       skipFetchSetup: true,
        //     });
        //   }
        //   const signer = new ethers.Wallet(privateKey, provider);
        //   return { privateKey, signer, provider };
        // };
        // getPrivateKeySignerProvider = (privateKey: string) => {
        //   let provider;
        //   if (isBrowser()) {
        //     provider = new ethers.providers.Web3Provider(window.ethereum, 'any');
        //   } else {
        //     provider = new ethers.providers.StaticJsonRpcProvider({
        //       url: this.rpc,
        //       skipFetchSetup: true,
        //     });
        //   }
        //   const signer = new ethers.Wallet(privateKey, provider);
        //   return { privateKey, signer, provider };
        // };
        this.utils = {
            hexToDec: hex2dec_1.hexToDec,
            decToHex: hex2dec_1.decToHex,
            /**
             * Partition multihash string into object representing multihash
             *
             * @param {string} multihash A base58 encoded multihash string
             * @returns {string}
             */ getBytesFromMultihash: (multihash)=>{
                const decoded = ethers_1.ethers.utils.base58.decode(multihash);
                return `0x${Buffer.from(decoded).toString('hex')}`;
            },
            /**
             *
             * Convert bytes32 to IPFS ID
             * @param { string } byte32 0x1220baa0d1e91f2a22fef53659418ddc3ac92da2a76d994041b86ed62c0c999de477
             * @returns { string } QmZKLGf3vgYsboM7WVUS9X56cJSdLzQVacNp841wmEDRkW
             */ getMultihashFromBytes: (byte32)=>{
                const text = byte32.replace('0x', '');
                // const hashFunction = parseInt(text.slice(0, 2), 16);
                const digestSize = parseInt(text.slice(2, 4), 16);
                const digest = text.slice(4, 4 + digestSize * 2);
                const multihash = ethers_1.ethers.utils.base58.encode(Buffer.from(`1220${digest}`, 'hex'));
                return multihash;
            },
            /**
             * NOTE: This function requires the "multiformats/cid" package in order to work
             *
             * Partition multihash string into object representing multihash
             *
             * @param {string} ipfsId A base58 encoded multihash string
             * @param {CIDParser} CID The CID object from the "multiformats/cid" package
             *
             * @example
             * const CID = require('multiformats/cid')
             * const ipfsId = 'QmZKLGf3vgYsboM7WVUS9X56cJSdLzQVacNp841wmEDRkW'
             * const bytes32 = getBytes32FromMultihash(ipfsId, CID)
             * console.log(bytes32)
             *
             * @returns {IPFSHash}
             */ getBytes32FromMultihash: (ipfsId, CID)=>{
                return (0, getBytes32FromMultihash_1.getBytes32FromMultihash)(ipfsId, CID);
            },
            // convert timestamp to YYYY/MM/DD format
            timestamp2Date: (timestamp)=>{
                const date = __turbopack_context__.r("[project]/node_modules/date-and-time/date-and-time.js [app-ssr] (ecmascript)");
                const format = 'YYYY/MM/DD HH:mm:ss';
                const timestampFormatted = new Date(parseInt(timestamp) * 1000);
                return date.format(timestampFormatted, format);
            }
        };
        this.pkpNftContractUtils = {
            read: {
                /**
                 * (IERC721Enumerable)
                 *
                 * Get all PKPs by a given address
                 *
                 * @param { string } ownerAddress
                 * @retu
                 * */ getTokensByAddress: async (ownerAddress)=>{
                    if (!this.connected) {
                        throw new constants_1.InitError({
                            info: {
                                connected: this.connected
                            }
                        }, 'Contracts are not connected. Please call connect() first');
                    }
                    if (!this.pkpNftContract) {
                        throw new constants_1.InitError({
                            info: {
                                pkpNftContract: this.pkpNftContract
                            }
                        }, 'Contract is not available');
                    }
                    // -- validate
                    if (!ethers_1.ethers.utils.isAddress(ownerAddress)) {
                        throw new constants_1.InvalidArgumentException({
                            info: {
                                ownerAddress
                            }
                        }, `Given string is not a valid address "${ownerAddress}"`);
                    }
                    const tokens = [];
                    for(let i = 0;; i++){
                        let token;
                        try {
                            token = await this.pkpNftContract.read.tokenOfOwnerByIndex(ownerAddress, i);
                            token = this.utils.hexToDec(token.toHexString());
                            tokens.push(token);
                        } catch (e) {
                            this.log(`[getTokensByAddress] Ended search on index: ${i}`);
                            break;
                        }
                    }
                    return tokens;
                },
                /**
                 * (IERC721Enumerable)
                 *
                 * Get the x latest number of tokens
                 *
                 * @param { number } latestNumberOfTokens
                 *
                 * @returns { Array<string> } a list of PKP NFTs
                 *
                 */ getTokens: async (latestNumberOfTokens)=>{
                    if (!this.connected) {
                        throw new constants_1.InitError({
                            info: {
                                connected: this.connected
                            }
                        }, 'Contracts are not connected. Please call connect() first');
                    }
                    if (!this.pkpNftContract) {
                        throw new constants_1.InitError({
                            info: {
                                pkpNftContract: this.pkpNftContract
                            }
                        }, 'Contract is not available');
                    }
                    const tokens = [];
                    for(let i = 0;; i++){
                        if (i >= latestNumberOfTokens) {
                            break;
                        }
                        let token;
                        try {
                            token = await this.pkpNftContract.read.tokenByIndex(i);
                            token = this.utils.hexToDec(token.toHexString());
                            tokens.push(token);
                        } catch (e) {
                            this.log(`[getTokensByAddress] Ended search on index: ${i}`);
                            break;
                        }
                    }
                    return tokens;
                },
                /**
                 * Get info of all PKPs by a given address
                 */ getTokensInfoByAddress: async (ownerAddress)=>{
                    const tokenIds = await this.pkpNftContractUtils.read.getTokensByAddress(ownerAddress);
                    const arr = [];
                    // for each pkp
                    for(let i = 0; i < tokenIds.length; i++){
                        const tokenId = tokenIds[i];
                        const pubKey = await this.pkpNftContract.read.getPubkey(tokenId);
                        const addrs = await (0, misc_2.derivedAddresses)({
                            publicKey: pubKey
                        });
                        if (!addrs.tokenId) {
                            addrs.tokenId = tokenId;
                        }
                        arr.push(addrs);
                    }
                    return arr;
                }
            },
            write: {
                mint: async (param)=>{
                    if (!this.connected) {
                        throw new constants_1.InitError({
                            info: {
                                connected: this.connected
                            }
                        }, 'Contracts are not connected. Please call connect() first');
                    }
                    if (!this.pkpNftContract) {
                        throw new constants_1.InitError({
                            info: {
                                pkpNftContract: this.pkpNftContract
                            }
                        }, 'Contract is not available');
                    }
                    let mintCost;
                    try {
                        mintCost = await this.pkpNftContract.read.mintCost();
                    } catch (e) {
                        throw new constants_1.TransactionError({
                            info: {
                                mintCost
                            },
                            cause: e
                        }, 'Could not get mint cost');
                    }
                    if (this.isPKP) {
                        this.log("This is a PKP wallet, so we'll use the PKP wallet to sign the tx");
                    }
                    this.log('...signing and sending tx');
                    const sentTx = await this._callWithAdjustedOverrides(this.pkpNftContract.write, 'mintNext', [
                        2
                    ], {
                        value: mintCost,
                        ...param
                    });
                    this.log('sentTx:', sentTx);
                    const res = await sentTx.wait();
                    this.log('res:', res);
                    const events = 'events' in res ? res.events : res.logs;
                    const tokenIdFromEvent = events[0].topics[1];
                    this.log('tokenIdFromEvent:', tokenIdFromEvent);
                    let tries = 0;
                    const maxAttempts = 10;
                    let publicKey = '';
                    while(tries < maxAttempts){
                        publicKey = await this.pkpNftContract.read.getPubkey(tokenIdFromEvent);
                        this.log('pkp pub key: ', publicKey);
                        if (publicKey !== '0x') {
                            break;
                        }
                        tries++;
                        await new Promise((resolve)=>{
                            setTimeout(resolve, 10000);
                        });
                    }
                    this.log('public key from token id', publicKey);
                    if (publicKey.startsWith('0x')) {
                        publicKey = publicKey.slice(2);
                    }
                    const pubkeyBuffer = Buffer.from(publicKey, 'hex');
                    const ethAddress = (0, utils_1.computeAddress)(pubkeyBuffer);
                    return {
                        pkp: {
                            tokenId: tokenIdFromEvent,
                            publicKey,
                            ethAddress
                        },
                        tx: sentTx,
                        tokenId: tokenIdFromEvent,
                        res
                    };
                },
                claimAndMint: async (derivedKeyId, signatures, txOpts = {})=>{
                    try {
                        const tx = await this._callWithAdjustedOverrides(this.pkpNftContract.write, 'claimAndMint', [
                            2,
                            derivedKeyId,
                            signatures
                        ], {
                            ...txOpts,
                            value: txOpts.value ?? await this.pkpNftContract.read.mintCost()
                        });
                        const txRec = await tx.wait();
                        const events = 'events' in txRec ? txRec.events : txRec.logs;
                        const tokenId = events[1].topics[1];
                        return {
                            tx,
                            res: txRec,
                            tokenId
                        };
                    } catch (e) {
                        this.log(`[claimAndMint] error: ${e.message}`);
                        throw new constants_1.TransactionError({
                            info: {
                                derivedKeyId,
                                signatures,
                                txOpts
                            },
                            cause: e
                        }, 'claimAndMint failed');
                    }
                }
            }
        };
        this.pkpPermissionsContractUtils = {
            read: {
                /**
                 *
                 * Check if an address is permitted
                 *
                 * @param { string } tokenId
                 * @param { string } address
                 *
                 * @returns { Promise<boolean> }
                 */ isPermittedAddress: async (tokenId, address)=>{
                    if (!this.connected) {
                        throw new constants_1.InitError({
                            info: {
                                connected: this.connected
                            }
                        }, 'Contracts are not connected. Please call connect() first');
                    }
                    if (!this.pkpPermissionsContract) {
                        throw new constants_1.InitError({
                            info: {
                                pkpPermissionsContract: this.pkpPermissionsContract
                            }
                        }, 'Contract is not available');
                    }
                    const pkpIdHex = this.utils.decToHex(tokenId, null);
                    const bool = await this.pkpPermissionsContract.read.isPermittedAddress(pkpIdHex, address);
                    return bool;
                },
                /**
                 * Get permitted addresses
                 *
                 * @param { string } tokenId
                 *
                 * @returns { Promise<Array<string>> }
                 *
                 */ getPermittedAddresses: async (tokenId)=>{
                    if (!this.connected) {
                        throw new constants_1.InitError({
                            info: {
                                connected: this.connected
                            }
                        }, 'Contracts are not connected. Please call connect() first');
                    }
                    if (!this.pkpPermissionsContract) {
                        throw new constants_1.InitError({
                            info: {
                                pkpPermissionsContract: this.pkpPermissionsContract
                            }
                        }, 'Contract is not available');
                    }
                    this.log('[getPermittedAddresses] input<tokenId>:', tokenId);
                    let addresses = [];
                    const maxTries = 5;
                    let tries = 0;
                    while(tries < maxTries){
                        try {
                            addresses = await this.pkpPermissionsContract.read.getPermittedAddresses(tokenId);
                            if (addresses.length <= 0) {
                                await new Promise((resolve)=>setTimeout(resolve, 1000));
                                tries++;
                                continue;
                            } else {
                                break;
                            }
                        } catch (e) {
                            this.log(`[getPermittedAddresses] error<e.message | ${tries}>:`, e.message);
                            tries++;
                        }
                    }
                    return addresses;
                },
                /**
                 *
                 * Get permitted action
                 *
                 * @param { any } tokenId
                 *
                 * @returns { Promise<Array<string>> }
                 *
                 */ getPermittedActions: async (tokenId)=>{
                    if (!this.connected) {
                        throw new constants_1.InitError({
                            info: {
                                connected: this.connected
                            }
                        }, 'Contracts are not connected. Please call connect() first');
                    }
                    if (!this.pkpPermissionsContract) {
                        throw new constants_1.InitError({
                            info: {
                                pkpPermissionsContract: this.pkpPermissionsContract
                            }
                        }, 'Contract is not available');
                    }
                    let actions = [];
                    const maxTries = 5;
                    let tries = 0;
                    while(tries < maxTries){
                        try {
                            actions = await this.pkpPermissionsContract.read.getPermittedActions(tokenId);
                            if (actions.length <= 0) {
                                await new Promise((resolve)=>setTimeout(resolve, 1000));
                                tries++;
                                continue;
                            } else {
                                break;
                            }
                        } catch (e) {
                            this.log(`[getPermittedActions] error<e.message | ${tries}>:`, e.message);
                            tries++;
                        }
                    }
                    return actions;
                },
                /**
                 *
                 * Check if an action is permitted given the pkpid and ipfsId
                 *
                 * @param { string } pkpId 103309008291725705563022469659474510532358692659842796086905702509072063991354
                 * @param { string } ipfsId  QmZKLGf3vgYsboM7WVUS9X56cJSdLzQVacNp841wmEDRkW
                 *
                 * @return { object } transaction
                 */ isPermittedAction: async (pkpId, ipfsId)=>{
                    if (!this.connected) {
                        throw new constants_1.InitError({
                            info: {
                                connected: this.connected
                            }
                        }, 'Contracts are not connected. Please call connect() first');
                    }
                    if (!this.pkpPermissionsContract) {
                        throw new constants_1.InitError({
                            info: {
                                pkpPermissionsContract: this.pkpPermissionsContract
                            }
                        }, 'Contract is not available');
                    }
                    this.log('[isPermittedAction] input<pkpId>:', pkpId);
                    this.log('[isPermittedAction] input<ipfsId>:', ipfsId);
                    const ipfsHash = this.utils.getBytesFromMultihash(ipfsId);
                    this.log('[isPermittedAction] converted<ipfsHash>:', ipfsHash);
                    const bool = await this.pkpPermissionsContract.read.isPermittedAction(pkpId, ipfsHash);
                    return bool;
                }
            },
            write: {
                /**
                 *
                 * Add permitted action to a given PKP id & ipfsId
                 *
                 * @param { string } pkpId 103309008291725705563022469659474510532358692659842796086905702509072063991354
                 * @param { string } ipfsId  QmZKLGf3vgYsboM7WVUS9X56cJSdLzQVacNp841wmEDRkW
                 *
                 * @return { object } transaction
                 */ addPermittedAction: async (pkpId, ipfsId)=>{
                    if (!this.connected) {
                        throw new constants_1.InitError({
                            info: {
                                connected: this.connected
                            }
                        }, 'Contracts are not connected. Please call connect() first');
                    }
                    if (!this.pkpPermissionsContract || !this.pubkeyRouterContract) {
                        throw new constants_1.InitError({
                            info: {
                                pkpPermissionsContract: this.pkpPermissionsContract,
                                pubkeyRouterContract: this.pubkeyRouterContract
                            }
                        }, 'Contract is not available');
                    }
                    this.log('[addPermittedAction] input<pkpId>:', pkpId);
                    const pubKey = await this.pubkeyRouterContract.read.getPubkey(pkpId);
                    this.log('[addPermittedAction] converted<pubKey>:', pubKey);
                    const pubKeyHash = ethers_1.ethers.utils.keccak256(pubKey);
                    this.log('[addPermittedAction] converted<pubKeyHash>:', pubKeyHash);
                    const tokenId = ethers_1.ethers.BigNumber.from(pubKeyHash);
                    this.log('[addPermittedAction] converted<tokenId>:', tokenId);
                    this.log('[addPermittedAction] input<ipfsId>:', ipfsId);
                    const ipfsIdBytes = this.utils.getBytesFromMultihash(ipfsId);
                    this.log('[addPermittedAction] converted<ipfsIdBytes>:', ipfsIdBytes);
                    const tx = await this._callWithAdjustedOverrides(this.pkpPermissionsContract.write, 'addPermittedAction', [
                        tokenId,
                        ipfsIdBytes,
                        [
                            1
                        ]
                    ]);
                    this.log('[addPermittedAction] output<tx>:', tx);
                    return tx;
                },
                /**
                 * TODO: add transaction type
                 * Add permitted action to a given PKP id & ipfsId
                 *
                 * @param { string } pkpId 103309008291725705563022469659474510532358692659842796086905702509072063991354
                 * @param { string } ownerAddress  0x3B5dD2605.....22aDC499A1
                 *
                 * @return { object } transaction
                 */ addPermittedAddress: async (pkpId, ownerAddress)=>{
                    if (!this.connected) {
                        throw new constants_1.InitError({
                            info: {
                                connected: this.connected
                            }
                        }, 'Contracts are not connected. Please call connect() first');
                    }
                    if (!this.pkpPermissionsContract) {
                        throw new constants_1.InitError({
                            info: {
                                pkpPermissionsContract: this.pkpPermissionsContract
                            }
                        }, 'Contract is not available');
                    }
                    this.log('[addPermittedAddress] input<pkpId>:', pkpId);
                    this.log('[addPermittedAddress] input<ownerAddress>:', ownerAddress);
                    this.log('[addPermittedAddress] input<pkpId>:', pkpId);
                    const tx = await this._callWithAdjustedOverrides(this.pkpPermissionsContract.write, 'addPermittedAddress', [
                        pkpId,
                        ownerAddress,
                        [
                            1
                        ]
                    ]);
                    this.log('[addPermittedAddress] output<tx>:', tx);
                    return tx;
                },
                /**
                 * Revoke permitted action of a given PKP id & ipfsId
                 *
                 * @param { string } pkpId 103309008291725705563022469659474510532358692659842796086905702509072063991354
                 * @param { string } ipfsId  QmZKLGf3vgYsboM7WVUS9X56cJSdLzQVacNp841wmEDRkW
                 *
                 * @return { object } transaction
                 */ revokePermittedAction: async (pkpId, ipfsId)=>{
                    if (!this.connected) {
                        throw new constants_1.InitError({
                            info: {
                                connected: this.connected
                            }
                        }, 'Contracts are not connected. Please call connect() first');
                    }
                    if (!this.pkpPermissionsContract) {
                        throw new constants_1.InitError({
                            info: {
                                pkpPermissionsContract: this.pkpPermissionsContract
                            }
                        }, 'Contract is not available');
                    }
                    this.log('[revokePermittedAction] input<pkpId>:', pkpId);
                    this.log('[revokePermittedAction] input<ipfsId>:', ipfsId);
                    const ipfsHash = this.utils.getBytesFromMultihash(ipfsId);
                    this.log('[revokePermittedAction] converted<ipfsHash>:', ipfsHash);
                    const tx = await this._callWithAdjustedOverrides(this.pkpPermissionsContract.write, 'removePermittedAction', [
                        pkpId,
                        ipfsHash
                    ]);
                    this.log('[revokePermittedAction] output<tx>:', tx);
                    return tx;
                }
            }
        };
        this.rateLimitNftContractUtils = {
            read: {
                /**
                 * getCapacityByIndex: async (index: number): Promise<any> => {
                 *
                 *  This function takes a token index as a parameter and returns the capacity of the token
                 *  with the given index. The capacity is an object that contains the number of requests
                 *  per millisecond that the token allows, and an object with the expiration timestamp and
                 *  formatted expiration date of the token.
                 *
                 *  @param {number} index - The index of the token.
                 *  @returns {Promise<any>} - A promise that resolves to the capacity of the token.
                 *
                 *  Example:
                 *
                 *  const capacity = await getCapacityByIndex(1);
                 *  this.log(capacity);
                 *  // Output: {
                 *  //   requestsPerMillisecond: 100,
                 *  //   expiresAt: {
                 *  //     timestamp: 1623472800,
                 *  //     formatted: '2022-12-31',
                 *  //   },
                 *  // }
                 *
                 * }
                 */ getCapacityByIndex: async (index)=>{
                    if (!this.connected) {
                        throw new constants_1.InitError({
                            info: {
                                connected: this.connected
                            }
                        }, 'Contracts are not connected. Please call connect() first');
                    }
                    if (!this.rateLimitNftContract) {
                        throw new constants_1.InitError({
                            info: {
                                rateLimitNftContract: this.rateLimitNftContract
                            }
                        }, 'Contract is not available');
                    }
                    const capacity = await this.rateLimitNftContract.read.capacity(index);
                    return {
                        requestsPerMillisecond: parseInt(capacity[0].toString()),
                        expiresAt: {
                            timestamp: parseInt(capacity[1].toString()),
                            formatted: this.utils.timestamp2Date(capacity[1].toString())
                        }
                    };
                },
                /**
                 * getTokenURIByIndex: async (index: number): Promise<string> => {
                 *
                 *  This function takes a token index as a parameter and returns the URI of the token
                 *  with the given index.
                 *
                 *  @param {number} index - The index of the token.
                 *  @returns {Promise<string>} - A promise that resolves to the URI of the token.
                 *
                 *  Example:
                 *
                 *  const URI = await getTokenURIByIndex(1);
                 *  this.log(URI);
                 *  // Output: 'https://tokens.com/1'
                 *
                 * }
                 */ getTokenURIByIndex: async (index)=>{
                    if (!this.connected) {
                        throw new constants_1.InitError({
                            info: {
                                connected: this.connected
                            }
                        }, 'Contracts are not connected. Please call connect() first');
                    }
                    if (!this.rateLimitNftContract) {
                        throw new constants_1.InitError({
                            info: {
                                rateLimitNftContract: this.rateLimitNftContract
                            }
                        }, 'Contract is not available');
                    }
                    const base64 = await this.rateLimitNftContract.read.tokenURI(index);
                    const data = base64.split('data:application/json;base64,')[1];
                    const dataToString = Buffer.from(data, 'base64').toString('binary');
                    return JSON.parse(dataToString);
                },
                /**
                 * getTokensByOwnerAddress: async (ownerAddress: string): Promise<any> => {
                 *
                 *  This function takes an owner address as a parameter and returns an array of tokens
                 *  that are owned by the given address.
                 *
                 *  @param {string} ownerAddress - The address of the owner.
                 *  @returns {Promise<any>} - A promise that resolves to an array of token objects.
                 *
                 *  Example:
                 *
                 *  const tokens = await getTokensByOwnerAddress('0x1234...5678');
                 *  this.log(tokens);
                 *  // Output: [
                 *  //   {
                 *  //     tokenId: 1,
                 *  //     URI: 'https://tokens.com/1',
                 *  //     capacity: 100,
                 *  //     isExpired: false,
                 *  //   },
                 *  //   {
                 *  //     tokenId: 2,
                 *  //     URI: 'https://tokens.com/2',
                 *  //     capacity: 200,
                 *  //     isExpired: true,
                 *  //   },
                 *  //   ...
                 *  // ]
                 *
                 * }
                 */ getTokensByOwnerAddress: async (ownerAddress)=>{
                    if (!this.connected) {
                        throw new constants_1.InitError({
                            info: {
                                connected: this.connected
                            }
                        }, 'Contracts are not connected. Please call connect() first');
                    }
                    if (!this.rateLimitNftContract) {
                        throw new constants_1.InitError({
                            info: {
                                rateLimitNftContract: this.rateLimitNftContract
                            }
                        }, 'Contract is not available');
                    }
                    // -- validate
                    if (!ethers_1.ethers.utils.isAddress(ownerAddress)) {
                        throw Error(`Given string is not a valid address "${ownerAddress}"`);
                    }
                    let total = await this.rateLimitNftContract.read.balanceOf(ownerAddress);
                    total = parseInt(total.toString());
                    const tokens = await (0, exports.asyncForEachReturn)([
                        ...new Array(total)
                    ], async (_, i)=>{
                        if (!this.rateLimitNftContract) {
                            throw new constants_1.InitError({
                                info: {
                                    rateLimitNftContract: this.rateLimitNftContract
                                }
                            }, 'Contract is not available');
                        }
                        const token = await this.rateLimitNftContract.read.tokenOfOwnerByIndex(ownerAddress, i);
                        const tokenIndex = parseInt(token.toString());
                        const URI = await this.rateLimitNftContractUtils.read.getTokenURIByIndex(tokenIndex);
                        const capacity = await this.rateLimitNftContractUtils.read.getCapacityByIndex(tokenIndex);
                        const isExpired = await this.rateLimitNftContract.read.isExpired(tokenIndex);
                        return {
                            tokenId: parseInt(token.toString()),
                            URI,
                            capacity,
                            isExpired
                        };
                    });
                    return tokens;
                },
                /**
                 * getTokens: async (): Promise<any> => {
                 *
                 *  This function returns an array of all tokens that have been minted.
                 *
                 *  @returns {Promise<any>} - A promise that resolves to an array of token objects.
                 *
                 *  Example:
                 *
                 *  const tokens = await getTokens();
                 *  this.log(tokens);
                 *  // Output: [
                 *  //   {
                 *  //     tokenId: 1,
                 *  //     URI: 'https://tokens.com/1',
                 *  //     capacity: 100,
                 *  //     isExpired: false,
                 *  //   },
                 *  //   {
                 *  //     tokenId: 2,
                 *  //     URI: 'https://tokens.com/2',
                 *  //     capacity: 200,
                 *  //     isExpired: true,
                 *  //   },
                 *  //   ...
                 *  // ]
                 *
                 * }
                 */ getTokens: async ()=>{
                    if (!this.connected) {
                        throw new constants_1.InitError({
                            info: {
                                connected: this.connected
                            }
                        }, 'Contracts are not connected. Please call connect() first');
                    }
                    if (!this.rateLimitNftContract) {
                        throw new constants_1.InitError({
                            info: {
                                rateLimitNftContract: this.rateLimitNftContract
                            }
                        }, 'Contract is not available');
                    }
                    const bigTotal = await this.rateLimitNftContract.read.totalSupply();
                    const total = parseInt(bigTotal.toString());
                    const tokens = await (0, exports.asyncForEachReturn)([
                        ...new Array(total)
                    ], async (_, i)=>{
                        if (!this.rateLimitNftContract) {
                            throw new constants_1.InitError({
                                info: {
                                    rateLimitNftContract: this.rateLimitNftContract
                                }
                            }, 'Contract is not available');
                        }
                        const token = await this.rateLimitNftContract.read.tokenByIndex(i);
                        const tokenIndex = parseInt(token.toString());
                        const URI = await this.rateLimitNftContractUtils.read.getTokenURIByIndex(tokenIndex);
                        const capacity = await this.rateLimitNftContractUtils.read.getCapacityByIndex(tokenIndex);
                        const isExpired = await this.rateLimitNftContract.read.isExpired(tokenIndex);
                        return {
                            tokenId: parseInt(token.toString()),
                            URI,
                            capacity,
                            isExpired
                        };
                    });
                    return tokens;
                }
            },
            write: {
                mint: async ({ txOpts, timestamp })=>{
                    if (!this.connected) {
                        throw new constants_1.InitError({
                            info: {
                                connected: this.connected
                            }
                        }, 'Contracts are not connected. Please call connect() first');
                    }
                    if (!this.rateLimitNftContract) {
                        throw new constants_1.InitError({
                            info: {
                                rateLimitNftContract: this.rateLimitNftContract
                            }
                        }, 'Contract is not available');
                    }
                    const tx = await this._callWithAdjustedOverrides(this.rateLimitNftContract.write, 'mint', [
                        timestamp
                    ], txOpts);
                    const res = await tx.wait();
                    const tokenIdFromEvent = res.events?.[0].topics[1];
                    return {
                        tx,
                        tokenId: tokenIdFromEvent
                    };
                },
                /**
                 * Transfer RLI token from one address to another
                 *
                 * @property { string } fromAddress
                 * @property { string } toAddress
                 * @property { string } RLITokenAddress
                 *
                 * @return { <Promise<void>> } void
                 */ transfer: async ({ fromAddress, toAddress, RLITokenAddress })=>{
                    if (!this.connected) {
                        throw new constants_1.InitError({
                            info: {
                                connected: this.connected
                            }
                        }, 'Contracts are not connected. Please call connect() first');
                    }
                    if (!this.rateLimitNftContract) {
                        throw new constants_1.InitError({
                            info: {
                                rateLimitNftContract: this.rateLimitNftContract
                            }
                        }, 'Contract is not available');
                    }
                    const tx = await this._callWithAdjustedOverrides(this.rateLimitNftContract.write, 'transferFrom', [
                        fromAddress,
                        toAddress,
                        RLITokenAddress
                    ]);
                    this.log('tx:', tx);
                    // const res = await tx.wait();
                    // return {
                    //     tx,
                    //     events: res.events
                    // }
                    return tx;
                },
                /**
                 * Prune expired Capacity Credits NFT (RLI) tokens for a specified owner address.
                 * This function burns all expired RLI tokens owned by the target address, helping to clean up the blockchain.
                 * Anyone can call this function to prune expired tokens for any address.
                 *
                 * @param {string} ownerAddress - The address of the owner to prune expired tokens for.
                 * @returns {Promise<PruneExpiredCapacityCreditsRes>} - A promise that resolves to the pruning response with transaction details.
                 * @throws {Error} - If the input parameters are invalid or an error occurs during the pruning process.
                 */ pruneExpired: async (ownerAddress)=>{
                    this.log('Pruning expired Capacity Credits NFTs...');
                    // Validate input: ownerAddress must be a valid Ethereum address
                    if (!ownerAddress || !ethers_1.ethers.utils.isAddress(ownerAddress)) {
                        throw new constants_1.InvalidArgumentException({
                            info: {
                                ownerAddress
                            }
                        }, `A valid owner address is required to prune expired tokens`);
                    }
                    this.log(`Target owner address: ${ownerAddress}`);
                    try {
                        // Hardcoded ABI for pruneExpired function
                        const pruneExpiredABI = [
                            {
                                inputs: [
                                    {
                                        internalType: 'address',
                                        name: 'owner',
                                        type: 'address'
                                    }
                                ],
                                name: 'pruneExpired',
                                outputs: [],
                                stateMutability: 'nonpayable',
                                type: 'function'
                            }
                        ];
                        // Create contract instance with the hardcoded ABI
                        const contractAddress = this.rateLimitNftContract.read.address;
                        const contract = new ethers_1.ethers.Contract(contractAddress, pruneExpiredABI, this.signer);
                        // Call the pruneExpired function
                        const res = await contract['pruneExpired'](ownerAddress);
                        const txHash = res.hash;
                        this.log(`Prune transaction submitted: ${txHash}`);
                        const tx = await res.wait();
                        this.log('Prune transaction confirmed:', tx);
                        // Count the burned tokens from Transfer events (transfers to zero address)
                        const burnEvents = tx.logs.filter((log)=>{
                            try {
                                const parsedLog = this.rateLimitNftContract.read.interface.parseLog(log);
                                return parsedLog.name === 'Transfer' && parsedLog.args['to'] === ethers_1.ethers.constants.AddressZero;
                            } catch  {
                                return false;
                            }
                        });
                        const actualTokensBurned = burnEvents.length;
                        this.log(`Successfully burned ${actualTokensBurned} expired tokens`);
                        this.log(`Gas used: ${tx.gasUsed.toString()}`);
                        return {
                            txHash,
                            actualTokensBurned
                        };
                    } catch (e) {
                        throw new constants_1.TransactionError({
                            info: {
                                ownerAddress
                            },
                            cause: e
                        }, 'Pruning expired capacity credits NFTs failed');
                    }
                }
            }
        };
        this.routerContractUtils = {
            read: {
            },
            write: {}
        };
        this.pkpHelperContractUtil = {
            read: {},
            write: {
                /**
                 *
                 * @param param0
                 * @returns
                 */ mintNextAndAddAuthMethods: async ({ keyType, permittedAuthMethodTypes, permittedAuthMethodIds, permittedAuthMethodPubkeys, permittedAuthMethodScopes, addPkpEthAddressAsPermittedAddress, sendPkpToItself, gasLimit })=>{
                    // first get mint cost
                    const mintCost = await this.pkpNftContract.read.mintCost();
                    const tx = await this._callWithAdjustedOverrides(this.pkpHelperContract.write, 'mintNextAndAddAuthMethods', [
                        keyType,
                        permittedAuthMethodTypes,
                        permittedAuthMethodIds,
                        permittedAuthMethodPubkeys,
                        permittedAuthMethodScopes,
                        addPkpEthAddressAsPermittedAddress,
                        sendPkpToItself
                    ], {
                        value: mintCost,
                        gasLimit
                    });
                    return tx;
                }
            }
        };
        this._getAdjustedGasLimit = async (contract, method, args, overrides = {}, gasLimitAdjustment = GAS_LIMIT_ADJUSTMENT)=>{
            const gasLimit = await contract.estimateGas[method](...args, overrides);
            // BigNumber uses integer math, so for example, to get a 10% increase,
            // we multiply it by 110 to get 10% more gas and then divide
            // by 100 to get the final gas limit
            return gasLimit.mul(gasLimitAdjustment).div(100);
        };
        // this.provider = args?.provider;
        this.customContext = args?.customContext;
        this.rpc = args?.rpc;
        this.rpcs = args?.rpcs;
        this.signer = args?.signer;
        this.privateKey = args?.privateKey;
        this.provider = args?.provider;
        this.randomPrivateKey = args?.randomPrivatekey ?? false;
        this.options = args?.options;
        this.debug = args?.debug ?? false;
        this.network = args?.network || constants_1.LIT_NETWORK.DatilDev;
        // if rpc is not specified, use the default rpc
        if (!this.rpc) {
            this.rpc = constants_1.RPC_URL_BY_NETWORK[this.network];
        }
        if (!this.rpcs) {
            this.rpcs = [
                this.rpc
            ];
        }
        // ----- autogen:blank-init:start  -----
        // Generated at 2023-11-07T01:50:52.460Z
        this.allowlistContract = {};
        this.litTokenContract = {};
        this.multisenderContract = {};
        this.pkpHelperContract = {};
        this.pkpNftContract = {};
        this.pkpNftMetadataContract = {};
        this.pkpPermissionsContract = {};
        this.pubkeyRouterContract = {};
        this.rateLimitNftContract = {};
        this.stakingContract = {};
        this.stakingBalancesContract = {};
    // ----- autogen:blank-init:end  -----
    }
    /**
     * Retrieves the Staking contract instance based on the provided network, context, and RPC URL.
     * If a context is provided, it determines if a contract resolver is used for bootstrapping contracts.
     * If a resolver address is present in the context, it retrieves the Staking contract from the contract resolver instance.
     * Otherwise, it retrieves the Staking contract using the contract address and ABI from the contract context.
     * Throws an error if required contract data is missing or if the Staking contract cannot be obtained.
     *
     * @param network - The network key.
     * @param context - The contract context or contract resolver context.
     * @param rpcUrl - The RPC URL.
     * @returns The Staking contract instance.
     * @throws Error if required contract data is missing or if the Staking contract cannot be obtained.
     */ static async getStakingContract(network, context, rpcUrl) {
        let provider;
        const _rpcUrl = rpcUrl || constants_1.RPC_URL_BY_NETWORK[network];
        if (context && 'provider' in context) {
            provider = context.provider;
        } else {
            provider = new ethers_1.ethers.providers.StaticJsonRpcProvider({
                url: _rpcUrl,
                skipFetchSetup: true
            });
        }
        if (!context) {
            const contractData = await _a._resolveContractContext(network);
            const stakingContract = contractData.find((item)=>item.name === 'Staking');
            const { address, abi } = stakingContract;
            // Validate the required data
            if (!address || !abi) {
                throw new constants_1.InitError({
                    info: {
                        address,
                        abi,
                        network
                    }
                }, ' Required contract data is missing');
            }
            return new ethers_1.ethers.Contract(address, abi, provider);
        } else {
            // if we have contract context then we determine if there exists a `resolverAddress`
            // if there is a resolver address we assume we are using a contract resolver for bootstrapping of contracts
            if (!context.resolverAddress) {
                const stakingContract = context.Staking;
                if (!stakingContract.address) {
                    throw new constants_1.InitError({
                        info: {
                            stakingContract,
                            context
                        }
                    }, ' Could not get staking contract address from contract context');
                }
                return new ethers_1.ethers.Contract(stakingContract.address, stakingContract.abi ?? StakingData_1.StakingData.abi, provider);
            } else {
                const contractContext = await _a._getContractsFromResolver(context, provider, [
                    'Staking'
                ]);
                if (!contractContext.Staking.address) {
                    throw new constants_1.InitError({
                        info: {
                            contractContext,
                            context
                        }
                    }, ' Could not get Staking Contract from contract resolver instance');
                }
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                //@ts-ignore data is callable as an array type
                const stakingABI = constants_1.NETWORK_CONTEXT_BY_NETWORK[network].data.find((data)=>{
                    return data.name === 'Staking';
                });
                return new ethers_1.ethers.Contract(contractContext.Staking.address, contractContext.Staking.abi ?? stakingABI?.contracts[0].ABI, provider);
            }
        }
    }
    static async _getContractsFromResolver(context, provider, contractNames) {
        const resolverContract = new ethers_1.ethers.Contract(context.resolverAddress, context.abi, provider);
        const getContract = async function(contract, environment) {
            let address = '';
            switch(contract){
                case 'Allowlist':
                case 'AllowList':
                    address = await resolverContract['getContract'](await resolverContract['ALLOWLIST_CONTRACT'](), environment);
                    break;
                case 'LITToken':
                    address = await resolverContract['getContract'](await resolverContract['LIT_TOKEN_CONTRACT'](), environment);
                    break;
                case 'Multisender':
                    address = await resolverContract['getContract'](await resolverContract['MULTI_SENDER_CONTRACT'](), environment);
                    break;
                case 'PKPNFT':
                    address = await resolverContract['getContract'](await resolverContract['PKP_NFT_CONTRACT'](), environment);
                    break;
                case 'PKPNFTMetadata':
                    address = await resolverContract['getContract'](await resolverContract['PKP_NFT_METADATA_CONTRACT'](), environment);
                    break;
                case 'PKPPermissions':
                    address = await resolverContract['getContract'](await resolverContract['PKP_PERMISSIONS_CONTRACT'](), environment);
                    break;
                case 'PKPHelper':
                    address = await resolverContract['getContract'](await resolverContract['PKP_HELPER_CONTRACT'](), environment);
                    break;
                case 'PubkeyRouter':
                    address = await resolverContract['getContract'](await resolverContract['PUB_KEY_ROUTER_CONTRACT'](), environment);
                    break;
                case 'RateLimitNFT':
                    address = await resolverContract['getContract'](await resolverContract['RATE_LIMIT_NFT_CONTRACT'](), environment);
                    break;
                case 'Staking':
                    address = await resolverContract['getContract'](await resolverContract['STAKING_CONTRACT'](), environment);
                    break;
                case 'StakingBalances':
                    address = await resolverContract['getContract'](await resolverContract['STAKING_BALANCES_CONTRACT'](), environment);
                    break;
            }
            return address;
        };
        const names = contractNames ?? _a.contractNames;
        const contractContext = {};
        // Ah, Bluebird.props(), we miss you 
        await Promise.all(names.map(async (contractName)=>{
            const contracts = context?.contractContext;
            contractContext[contractName] = {
                address: await getContract(contractName, context.environment),
                abi: contracts?.[contractName]?.abi ?? undefined
            };
        }));
        return contractContext;
    }
    static async getContractAddresses(network, provider, context) {
        let contractData;
        if (context) {
            // if there is a resolver address we use the resolver contract to query the rest of the contracts
            // here we override context to be what is returned from the resolver which is of type LitContractContext
            if (context?.resolverAddress) {
                context = await _a._getContractsFromResolver(context, provider);
            }
            const flatten = [];
            const keys = Object.keys(context);
            for (const key of keys){
                context[key].name = key;
                flatten.push(context[key]);
            }
            contractData = flatten;
        } else {
            contractData = await _a._resolveContractContext(network);
        }
        // Destructure the data for easier access
        const addresses = {};
        for (const contract of contractData){
            switch(contract.name){
                case 'Allowlist':
                    addresses.Allowlist = {};
                    addresses.Allowlist.address = contract.address;
                    addresses.Allowlist.abi = contract.abi ?? AllowlistData_1.AllowlistData.abi;
                    break;
                case 'PKPHelper':
                    addresses.PKPHelper = {};
                    addresses.PKPHelper.address = contract.address;
                    addresses.PKPHelper.abi = contract?.abi ?? PKPHelperData_1.PKPHelperData.abi;
                    break;
                case 'PKPNFT':
                    addresses.PKPNFT = {};
                    addresses.PKPNFT.address = contract.address;
                    addresses.PKPNFT.abi = contract?.abi ?? PKPNFTData_1.PKPNFTData.abi;
                    break;
                case 'Staking':
                    addresses.Staking = {};
                    addresses.Staking.address = contract.address;
                    addresses.Staking.abi = contract.abi ?? StakingData_1.StakingData.abi;
                    break;
                case 'RateLimitNFT':
                    addresses.RateLimitNFT = {};
                    addresses.RateLimitNFT.address = contract.address;
                    addresses.RateLimitNFT.abi = contract.abi ?? RateLimitNFTData_1.RateLimitNFTData.abi;
                    break;
                case 'PKPPermissions':
                    addresses.PKPPermissions = {};
                    addresses.PKPPermissions.address = contract.address;
                    addresses.PKPPermissions.abi = contract.abi ?? PKPPermissionsData_1.PKPPermissionsData.abi;
                    break;
                case 'PKPNFTMetadata':
                    addresses.PKPNFTMetadata = {};
                    addresses.PKPNFTMetadata.address = contract.address;
                    addresses.PKPNFTMetadata.abi = contract.abi ?? PKPNFTMetadataData_1.PKPNFTMetadataData.abi;
                    break;
                case 'PubkeyRouter':
                    addresses.PubkeyRouter = {};
                    addresses.PubkeyRouter.address = contract.address;
                    addresses.PubkeyRouter.abi = contract?.abi ?? PubkeyRouterData_1.PubkeyRouterData.abi;
                    break;
                case 'LITToken':
                    addresses.LITToken = {};
                    addresses.LITToken.address = contract.address;
                    addresses.LITToken.abi = contract?.abi ?? LITTokenData_1.LITTokenData.abi;
                    break;
                case 'StakingBalances':
                    addresses.StakingBalances = {};
                    addresses.StakingBalances.address = contract.address;
                    addresses.StakingBalances.abi = contract.abi ?? StakingBalancesData_1.StakingBalancesData.abi;
                    break;
                case 'Multisender':
                    addresses.Multisender = {};
                    addresses.Multisender.address = contract.address;
                    addresses.Multisender.abi = contract?.abi ?? MultisenderData_1.MultisenderData.abi;
                    break;
            }
        }
        // Validate the required data
        if (Object.keys(addresses).length < 5) {
            throw new constants_1.InitError({
                info: {
                    network,
                    addresses,
                    context
                }
            }, ' Required contract data is missing');
        }
        return addresses;
    }
    static async _resolveContractContext(network) {
        // -- check if it's supported network
        if (!constants_1.NETWORK_CONTEXT_BY_NETWORK[network]) {
            throw new constants_1.WrongNetworkException({
                info: {
                    network
                }
            }, `[_resolveContractContext] Unsupported network: ${network}`);
        }
        const data = constants_1.NETWORK_CONTEXT_BY_NETWORK[network];
        if (!data) {
            throw new constants_1.WrongNetworkException({
                info: {
                    network
                }
            }, '[_resolveContractContext] No data found');
        }
        // Normalize the data to the LitContractContext type
        return data.data.map((c)=>({
                address: c.contracts[0].address_hash,
                abi: c.contracts[0].ABI,
                name: c.name
            }));
    }
    async _callWithAdjustedOverrides(contract, method, args, overrides = {}, gasLimitAdjustment = GAS_LIMIT_ADJUSTMENT) {
        // Check if the method exists on the contract
        if (!(method in contract.functions)) {
            throw new Error(`Method ${String(method)} does not exist on the contract`);
        }
        // Adjust the gas limit
        const gasLimit = overrides.gasLimit ?? await this._getAdjustedGasLimit(contract, method, args, overrides, gasLimitAdjustment);
        // Call the contract method with adjusted overrides
        return contract.functions[method](...args, {
            ...overrides,
            gasLimit
        });
    }
}
exports.LitContracts = LitContracts;
_a = LitContracts;
LitContracts.contractNames = [
    'Allowlist',
    'Staking',
    'RateLimitNFT',
    'PubkeyRouter',
    'PKPHelper',
    'PKPPermissions',
    'PKPNFTMetadata',
    'PKPNFT',
    'Multisender',
    'LITToken',
    'StakingBalances'
];
LitContracts.logger = logger_1.LogManager.Instance.get('contract-sdk');
/**
 * @deprecated - Use {@link getConnectionInfo } instead, which provides more information.
 */ LitContracts.getMinNodeCount = async (network, context, rpcUrl)=>{
    const contract = await _a.getStakingContract(network, context, rpcUrl);
    const minNodeCount = await contract['currentValidatorCountForConsensus']();
    if (!minNodeCount) {
        throw new constants_1.InitError({
            info: {
                minNodeCount
            }
        }, ' Minimum validator count is not set');
    }
    return minNodeCount;
};
/**
 * @deprecated - Use {@link getConnectionInfo } instead, which provides more information.
 */ LitContracts.getValidators = async (network, context, rpcUrl, nodeProtocol)=>{
    const contract = await _a.getStakingContract(network, context, rpcUrl);
    // Fetch contract data
    const [activeValidators, currentValidatorsCount, kickedValidators] = await Promise.all([
        contract['getValidatorsInCurrentEpoch'](),
        contract['currentValidatorCountForConsensus'](),
        contract['getKickedValidators']()
    ]);
    const validators = [];
    // Check if active validator set meets the threshold
    if (activeValidators.length - kickedValidators.length >= currentValidatorsCount) {
        // Process each validator
        for (const validator of activeValidators){
            validators.push(validator);
        }
    } else {
        _a.logger.error(' Active validator set does not meet the threshold');
    }
    // remove kicked validators in active validators
    const cleanedActiveValidators = activeValidators.filter((av)=>!kickedValidators.some((kv)=>kv === av));
    const activeValidatorStructs = (await contract['getValidatorsStructs'](cleanedActiveValidators)).map((item)=>{
        return {
            ip: item[0],
            ipv6: item[1],
            port: item[2],
            nodeAddress: item[3],
            reward: item[4],
            seconderPubkey: item[5],
            receiverPubkey: item[6]
        };
    });
    const networks = activeValidatorStructs.map((item)=>{
        const centralisation = constants_1.CENTRALISATION_BY_NETWORK[network];
        // Convert the integer IP to a string format
        const ip = (0, hex2dec_1.intToIP)(item.ip);
        const port = item.port;
        // Determine the protocol to use based on various conditions
        const protocol = // If nodeProtocol is defined, use it
        nodeProtocol || // If port is 443, use HTTPS, otherwise use network-specific HTTP
        (port === 443 ? constants_1.HTTPS : constants_1.HTTP_BY_NETWORK[network]) || // Fallback to HTTP if no other conditions are met
        constants_1.HTTP;
        const url = `${protocol}${ip}:${port}`;
        _a.logger.debug("Validator's URL:", url);
        return url;
    });
    return networks;
};
/**
 * Retrieves the connection information for a given network.
 *
 * @param params
 * @param params.litNetwork - The key representing the network.
 * @param [params.networkContext] - Optional network context for the contract.
 * @param [params.rpcUrl] - Optional RPC URL for the network.
 * @param [params.nodeProtocol] - Optional protocol for the network node.
 *
 * @returns An object containing the staking contract, epoch number, minimum node count and an array of bootstrap URLs.
 *
 * @throws Error if the minimum validator count is not set or if the active validator set does not meet the threshold.
 */ LitContracts.getConnectionInfo = async ({ litNetwork, networkContext, rpcUrl, nodeProtocol })=>{
    const stakingContract = await _a.getStakingContract(litNetwork, networkContext, rpcUrl);
    const [epochInfo, minNodeCount, activeUnkickedValidatorStructs] = await stakingContract['getActiveUnkickedValidatorStructsAndCounts']();
    const typedEpochInfo = {
        epochLength: ethers_1.ethers.BigNumber.from(epochInfo[0]).toNumber(),
        number: ethers_1.ethers.BigNumber.from(epochInfo[1]).toNumber(),
        endTime: ethers_1.ethers.BigNumber.from(epochInfo[2]).toNumber(),
        retries: ethers_1.ethers.BigNumber.from(epochInfo[3]).toNumber(),
        timeout: ethers_1.ethers.BigNumber.from(epochInfo[4]).toNumber()
    };
    const minNodeCountInt = ethers_1.ethers.BigNumber.from(minNodeCount).toNumber();
    if (!minNodeCountInt) {
        throw new Error(' Minimum validator count is not set');
    }
    if (activeUnkickedValidatorStructs.length < minNodeCountInt) {
        throw new Error(` Active validator set does not meet the threshold. Required: ${minNodeCountInt} but got: ${activeUnkickedValidatorStructs.length}`);
    }
    const activeValidatorStructs = activeUnkickedValidatorStructs.map((item)=>{
        return {
            ip: item[0],
            ipv6: item[1],
            port: item[2],
            nodeAddress: item[3],
            reward: item[4],
            seconderPubkey: item[5],
            receiverPubkey: item[6]
        };
    });
    const networks = activeValidatorStructs.map((item)=>{
        const centralisation = constants_1.CENTRALISATION_BY_NETWORK[litNetwork];
        // Convert the integer IP to a string format
        const ip = (0, hex2dec_1.intToIP)(item.ip);
        const port = item.port;
        // Determine the protocol to use based on various conditions
        const protocol = // If nodeProtocol is defined, use it
        nodeProtocol || // If port is 443, use HTTPS, otherwise use network-specific HTTP
        (port === 443 ? constants_1.HTTPS : constants_1.HTTP_BY_NETWORK[litNetwork]) || // Fallback to HTTP if no other conditions are met
        constants_1.HTTP;
        const url = `${protocol}${ip}:${port}`;
        _a.logger.debug("Validator's URL:", url);
        return url;
    });
    return {
        stakingContract,
        epochInfo: typedEpochInfo,
        minNodeCount: minNodeCountInt,
        bootstrapUrls: networks
    };
}; //# sourceMappingURL=contracts-sdk.js.map
}),
"[project]/node_modules/@lit-protocol/contracts-sdk/src/index.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
const tslib_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/contracts-sdk/node_modules/tslib/tslib.es6.js [app-ssr] (ecmascript)");
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/contracts-sdk/src/lib/contracts-sdk.js [app-ssr] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/contracts-sdk/src/lib/utils.js [app-ssr] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}),
];

//# sourceMappingURL=node_modules_%40lit-protocol_contracts-sdk_src_5be3fbcc._.js.map