{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/client/dist/service.js"],"sourcesContent":["import { isBrowser, isNode, isBun, isDeno, isElectron } from 'environment';\nimport * as client from '@ucanto/client';\nimport { CAR, HTTP } from '@ucanto/transport';\nimport * as DID from '@ipld/dag-ucan/did';\nimport { receiptsEndpoint } from '@storacha/upload-client';\nexport const accessServiceURL = new URL('https://up.storacha.network');\nexport const accessServicePrincipal = DID.parse('did:web:up.storacha.network');\n/* c8 ignore start */\nconst envName = isBrowser\n    ? 'Browser'\n    : isNode\n        ? 'Node'\n        : isBun\n            ? 'Bun'\n            : isDeno\n                ? 'Deno'\n                : isElectron\n                    ? 'Electron'\n                    : 'Unknown';\nexport const defaultHeaders = {\n    'X-Client': `Storacha/1 (js; ${envName})`,\n};\n/* c8 ignore end */\n/**\n * @param {object} [options]\n * @param {Record<string, string>} [options.headers]\n * @param {import('./types.js').Principal} [options.id]\n * @param {URL} [options.url]\n */\nexport const accessServiceConnection = (options = {}) => client.connect({\n    id: options.id ?? accessServicePrincipal,\n    codec: CAR.outbound,\n    channel: HTTP.open({\n        url: options.url ?? accessServiceURL,\n        method: 'POST',\n        headers: { ...defaultHeaders, ...options.headers },\n    }),\n});\nexport const uploadServiceURL = new URL('https://up.storacha.network');\nexport const uploadServicePrincipal = DID.parse('did:web:up.storacha.network');\n/**\n * @param {object} [options]\n * @param {Record<string, string>} [options.headers]\n * @param {import('./types.js').Principal} [options.id]\n * @param {URL} [options.url]\n */\nexport const uploadServiceConnection = (options = {}) => client.connect({\n    id: options.id ?? uploadServicePrincipal,\n    codec: CAR.outbound,\n    channel: HTTP.open({\n        url: options.url ?? uploadServiceURL,\n        method: 'POST',\n        headers: { ...defaultHeaders, ...options.headers },\n    }),\n});\nexport const filecoinServiceURL = new URL('https://up.storacha.network');\nexport const filecoinServicePrincipal = DID.parse('did:web:up.storacha.network');\n/**\n * @param {object} [options]\n * @param {Record<string, string>} [options.headers]\n * @param {import('./types.js').Principal} [options.id]\n * @param {URL} [options.url]\n */\nexport const filecoinServiceConnection = (options = {}) => client.connect({\n    id: options.id ?? filecoinServicePrincipal,\n    codec: CAR.outbound,\n    channel: HTTP.open({\n        url: options.url ?? filecoinServiceURL,\n        method: 'POST',\n        headers: { ...defaultHeaders, ...options.headers },\n    }),\n});\n// Note: we use a UCAN service domain that is different to the public access\n// domain so that if public access is blocked it does not effect authorization\n// invocations.\nexport const gatewayServiceURL = new URL('https://gateway.storacha.network');\nexport const gatewayServicePrincipal = DID.parse('did:web:w3s.link');\n/**\n * Create a connection to a gateway service.\n *\n * @param {object} [options]\n * @param {import('./types.js').Principal} [options.id]\n * @param {URL} [options.url]\n */\nexport const gatewayServiceConnection = ({ id, url } = {}) => client.connect({\n    id: id ?? gatewayServicePrincipal,\n    codec: CAR.outbound,\n    channel: HTTP.open({\n        url: url ?? gatewayServiceURL,\n        method: 'POST',\n    }),\n});\n/** @type {() => import('./types.js').ServiceConf} */\nexport const serviceConf = () => ({\n    access: accessServiceConnection(),\n    upload: uploadServiceConnection(),\n    filecoin: filecoinServiceConnection(),\n    gateway: gatewayServiceConnection(),\n});\nexport { receiptsEndpoint };\n//# sourceMappingURL=service.js.map"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;;;;;;AACO,MAAM,mBAAmB,IAAI,IAAI;AACjC,MAAM,yBAAyB,4JAAS,CAAC;AAChD,mBAAmB,GACnB,MAAM,UAAU,iJAAS,GACnB,YACA,8IAAM,GACF,SACA,6IAAK,GACD,QACA,8IAAM,GACF,SACA,kJAAU,GACN,aACA;AACf,MAAM,iBAAiB;IAC1B,YAAY,CAAC,gBAAgB,EAAE,QAAQ,CAAC,CAAC;AAC7C;AAQO,MAAM,0BAA0B,CAAC,UAAU,CAAC,CAAC,GAAK,kKAAc,CAAC;QACpE,IAAI,QAAQ,EAAE,IAAI;QAClB,OAAO,yLAAG,CAAC,QAAQ;QACnB,SAAS,4LAAI,CAAC,IAAI,CAAC;YACf,KAAK,QAAQ,GAAG,IAAI;YACpB,QAAQ;YACR,SAAS;gBAAE,GAAG,cAAc;gBAAE,GAAG,QAAQ,OAAO;YAAC;QACrD;IACJ;AACO,MAAM,mBAAmB,IAAI,IAAI;AACjC,MAAM,yBAAyB,4JAAS,CAAC;AAOzC,MAAM,0BAA0B,CAAC,UAAU,CAAC,CAAC,GAAK,kKAAc,CAAC;QACpE,IAAI,QAAQ,EAAE,IAAI;QAClB,OAAO,yLAAG,CAAC,QAAQ;QACnB,SAAS,4LAAI,CAAC,IAAI,CAAC;YACf,KAAK,QAAQ,GAAG,IAAI;YACpB,QAAQ;YACR,SAAS;gBAAE,GAAG,cAAc;gBAAE,GAAG,QAAQ,OAAO;YAAC;QACrD;IACJ;AACO,MAAM,qBAAqB,IAAI,IAAI;AACnC,MAAM,2BAA2B,4JAAS,CAAC;AAO3C,MAAM,4BAA4B,CAAC,UAAU,CAAC,CAAC,GAAK,kKAAc,CAAC;QACtE,IAAI,QAAQ,EAAE,IAAI;QAClB,OAAO,yLAAG,CAAC,QAAQ;QACnB,SAAS,4LAAI,CAAC,IAAI,CAAC;YACf,KAAK,QAAQ,GAAG,IAAI;YACpB,QAAQ;YACR,SAAS;gBAAE,GAAG,cAAc;gBAAE,GAAG,QAAQ,OAAO;YAAC;QACrD;IACJ;AAIO,MAAM,oBAAoB,IAAI,IAAI;AAClC,MAAM,0BAA0B,4JAAS,CAAC;AAQ1C,MAAM,2BAA2B,CAAC,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC,GAAK,kKAAc,CAAC;QACzE,IAAI,MAAM;QACV,OAAO,yLAAG,CAAC,QAAQ;QACnB,SAAS,4LAAI,CAAC,IAAI,CAAC;YACf,KAAK,OAAO;YACZ,QAAQ;QACZ;IACJ;AAEO,MAAM,cAAc,IAAM,CAAC;QAC9B,QAAQ;QACR,QAAQ;QACR,UAAU;QACV,SAAS;IACb,CAAC;;CAED,mCAAmC","ignoreList":[0]}},
    {"offset": {"line": 116, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/client/dist/base.js"],"sourcesContent":["import { Agent } from '@storacha/access/agent';\nimport { serviceConf, receiptsEndpoint } from './service.js';\nexport class Base {\n    /**\n     * @type {Agent}\n     * @protected\n     */\n    _agent;\n    /**\n     * @type {import('./types.js').ServiceConf}\n     * @protected\n     */\n    _serviceConf;\n    /**\n     * @param {import('@storacha/access').AgentData} agentData\n     * @param {object} [options]\n     * @param {import('./types.js').ServiceConf} [options.serviceConf]\n     * @param {URL} [options.receiptsEndpoint]\n     */\n    constructor(agentData, options = {}) {\n        this._serviceConf = options.serviceConf ?? serviceConf();\n        this._agent = new Agent(agentData, {\n            servicePrincipal: this._serviceConf.access.id,\n            // @ts-expect-error I know but it will be HTTP for the forseeable.\n            url: this._serviceConf.access.channel.url,\n            connection: this._serviceConf.access,\n        });\n        this._receiptsEndpoint = options.receiptsEndpoint ?? receiptsEndpoint;\n    }\n    /**\n     * The current user agent (this device).\n     *\n     * @type {Agent}\n     */\n    get agent() {\n        return this._agent;\n    }\n    /**\n     * @protected\n     * @param {import('./types.js').Ability[]} abilities\n     */\n    async _invocationConfig(abilities) {\n        const resource = this._agent.currentSpace();\n        if (!resource) {\n            throw new Error('missing current space: use createSpace() or setCurrentSpace()');\n        }\n        const issuer = this._agent.issuer;\n        const proofs = await this._agent.proofs(abilities.map((can) => ({ can, with: resource })));\n        const audience = this._serviceConf.upload.id;\n        return { issuer, with: resource, proofs, audience };\n    }\n}\n//# sourceMappingURL=base.js.map"],"names":[],"mappings":";;;;AAAA;AACA;AAAA;;;AACO,MAAM;IACT;;;KAGC,GACD,OAAO;IACP;;;KAGC,GACD,aAAa;IACb;;;;;KAKC,GACD,YAAY,SAAS,EAAE,UAAU,CAAC,CAAC,CAAE;QACjC,IAAI,CAAC,YAAY,GAAG,QAAQ,WAAW,IAAI,IAAA,sLAAW;QACtD,IAAI,CAAC,MAAM,GAAG,IAAI,8KAAK,CAAC,WAAW;YAC/B,kBAAkB,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,EAAE;YAC7C,kEAAkE;YAClE,KAAK,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,OAAO,CAAC,GAAG;YACzC,YAAY,IAAI,CAAC,YAAY,CAAC,MAAM;QACxC;QACA,IAAI,CAAC,iBAAiB,GAAG,QAAQ,gBAAgB,IAAI,qLAAgB;IACzE;IACA;;;;KAIC,GACD,IAAI,QAAQ;QACR,OAAO,IAAI,CAAC,MAAM;IACtB;IACA;;;KAGC,GACD,MAAM,kBAAkB,SAAS,EAAE;QAC/B,MAAM,WAAW,IAAI,CAAC,MAAM,CAAC,YAAY;QACzC,IAAI,CAAC,UAAU;YACX,MAAM,IAAI,MAAM;QACpB;QACA,MAAM,SAAS,IAAI,CAAC,MAAM,CAAC,MAAM;QACjC,MAAM,SAAS,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,UAAU,GAAG,CAAC,CAAC,MAAQ,CAAC;gBAAE;gBAAK,MAAM;YAAS,CAAC;QACvF,MAAM,WAAW,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,EAAE;QAC5C,OAAO;YAAE;YAAQ,MAAM;YAAU;YAAQ;QAAS;IACtD;AACJ,EACA,gCAAgC","ignoreList":[0]}},
    {"offset": {"line": 182, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/client/dist/types.js"],"sourcesContent":["export * from '@ucanto/interface';\nexport * from '@storacha/did-mailto';\nexport { AppName } from '@storacha/access/types';\nexport { Client } from './client.js';\n//# sourceMappingURL=types.js.map"],"names":[],"mappings":";AAAA;AACA;AACA;AACA,gSACA,iCAAiC","ignoreList":[0]}},
    {"offset": {"line": 195, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/client/dist/result.js"],"sourcesContent":["export * from '@ucanto/core/result';\nimport * as API from '@ucanto/interface';\n/**\n * Returns contained `ok` if result is and throws `error` if result is not ok.\n *\n * @template T\n * @param {API.Result<T, {}>} result\n * @returns {T}\n */\nexport const unwrap = ({ ok, error }) => {\n    if (error) {\n        throw error;\n    }\n    else {\n        return /** @type {T} */ (ok);\n    }\n};\n/**\n * Also expose as `Result.try` which is arguably more clear.\n */\nexport { unwrap as try };\n//# sourceMappingURL=result.js.map"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAQO,MAAM,SAAS,CAAC,EAAE,EAAE,EAAE,KAAK,EAAE;IAChC,IAAI,OAAO;QACP,MAAM;IACV,OACK;QACD,OAAyB;IAC7B;AACJ;;CAKA,kCAAkC","ignoreList":[0]}},
    {"offset": {"line": 218, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/client/dist/capability/access.js"],"sourcesContent":["import { Base } from '../base.js';\nimport * as Agent from '@storacha/access/agent';\nimport * as DIDMailto from '@storacha/did-mailto';\nimport * as Result from '../result.js';\nimport * as API from '../types.js';\nexport { DIDMailto };\n/**\n * Client for interacting with the `access/*` capabilities.\n */\nexport class AccessClient extends Base {\n    /* c8 ignore start - testing websocket code is hard */\n    /**\n     * Authorize the current agent to use capabilities granted to the passed\n     * email account.\n     *\n     * @deprecated Use `request` instead.\n     *\n     * @param {`${string}@${string}`} email\n     * @param {object} [options]\n     * @param {AbortSignal} [options.signal]\n     * @param {Iterable<{ can: API.Ability }>} [options.capabilities]\n     */\n    async authorize(email, options) {\n        const account = DIDMailto.fromEmail(email);\n        const authorization = Result.unwrap(await request(this, { account }));\n        const access = Result.unwrap(await authorization.claim(options));\n        await Result.unwrap(await access.save());\n        return access.proofs;\n    }\n    /* c8 ignore stop */\n    /**\n     * Claim delegations granted to the account associated with this agent.\n     *\n     * @param {object} [input]\n     * @param {API.DID} [input.audience]\n     */\n    async claim(input) {\n        const access = Result.unwrap(await claim(this, input));\n        await Result.unwrap(await access.save());\n        return access.proofs;\n    }\n    /**\n     * Requests specified `access` level from the account from the given account.\n     *\n     * @param {object} input\n     * @param {API.AccountDID} input.account\n     * @param {API.Access} [input.access]\n     * @param {AbortSignal} [input.signal]\n     */\n    async request(input) {\n        return await request(this, input);\n    }\n    /**\n     * Shares access with delegates.\n     *\n     * @param {object} input\n     * @param {API.Delegation[]} input.delegations\n     * @param {API.SpaceDID} [input.space]\n     * @param {API.Delegation[]} [input.proofs]\n     */\n    async delegate(input) {\n        return await delegate(this, input);\n    }\n}\n/**\n * @param {{agent: API.Agent}} client\n * @param {object} [input]\n * @param {API.DID} [input.audience]\n */\nexport const claim = async ({ agent }, input) => Agent.Access.claim(agent, input);\n/**\n * Requests specified `access` level from specified `account`. It will invoke\n * `access/authorize` capability and keep polling `access/claim` capability\n * until access is granted or request is aborted.\n *\n * @param {{agent: API.Agent}} agent\n * @param {object} input\n * @param {API.AccountDID} input.account\n * @param {API.Access} [input.access]\n * @param {API.DID} [input.audience]\n * @param {Agent.AppName} [input.appName]\n * @param {API.SSORequestParams} [input.sso] - SSO authentication request (all fields required if provided)\n */\nexport const request = async ({ agent }, input) => Agent.Access.request(agent, input);\n/**\n * Creates a new `PendingAccessRequest` object that can be used to poll for the\n * requested delegation through `access/claim` capability.\n *\n * @param {{agent: API.Agent}} agent\n * @param {object} input\n * @param {API.Link} input.request - Link to the `access/authorize` invocation.\n * @param {API.UTCUnixTimestamp} input.expiration - Seconds in UTC.\n * @param {API.DID} [input.audience] - Principal requesting an access.\n * @param {API.ProviderDID} [input.provider] - Provider handling request.\n */\n/* c8 ignore next 2 */\nexport const createPendingAccessRequest = ({ agent }, input) => Agent.Access.createPendingAccessRequest(agent, input);\n/**\n *\n * @param {{agent: API.Agent}} agent\n * @param {object} input\n * @param {API.Delegation[]} input.delegations\n * @param {API.SpaceDID} [input.space]\n * @param {API.Delegation[]} [input.proofs]\n */\nexport const delegate = async ({ agent }, input) => Agent.Access.delegate(agent, input);\nexport const { spaceAccess, accountAccess } = Agent.Access;\n//# sourceMappingURL=access.js.map"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;;;;;;;AAKO,MAAM,qBAAqB,4JAAI;IAClC,oDAAoD,GACpD;;;;;;;;;;KAUC,GACD,MAAM,UAAU,KAAK,EAAE,OAAO,EAAE;QAC5B,MAAM,UAAU,yLAAmB,CAAC;QACpC,MAAM,gBAAgB,gLAAa,CAAC,MAAM,QAAQ,IAAI,EAAE;YAAE;QAAQ;QAClE,MAAM,SAAS,gLAAa,CAAC,MAAM,cAAc,KAAK,CAAC;QACvD,MAAM,gLAAa,CAAC,MAAM,OAAO,IAAI;QACrC,OAAO,OAAO,MAAM;IACxB;IACA,kBAAkB,GAClB;;;;;KAKC,GACD,MAAM,MAAM,KAAK,EAAE;QACf,MAAM,SAAS,gLAAa,CAAC,MAAM,MAAM,IAAI,EAAE;QAC/C,MAAM,gLAAa,CAAC,MAAM,OAAO,IAAI;QACrC,OAAO,OAAO,MAAM;IACxB;IACA;;;;;;;KAOC,GACD,MAAM,QAAQ,KAAK,EAAE;QACjB,OAAO,MAAM,QAAQ,IAAI,EAAE;IAC/B;IACA;;;;;;;KAOC,GACD,MAAM,SAAS,KAAK,EAAE;QAClB,OAAO,MAAM,SAAS,IAAI,EAAE;IAChC;AACJ;AAMO,MAAM,QAAQ,OAAO,EAAE,KAAK,EAAE,EAAE,QAAU,kMAAY,CAAC,KAAK,CAAC,OAAO;AAcpE,MAAM,UAAU,OAAO,EAAE,KAAK,EAAE,EAAE,QAAU,kMAAY,CAAC,OAAO,CAAC,OAAO;AAaxE,MAAM,6BAA6B,CAAC,EAAE,KAAK,EAAE,EAAE,QAAU,kMAAY,CAAC,0BAA0B,CAAC,OAAO;AASxG,MAAM,WAAW,OAAO,EAAE,KAAK,EAAE,EAAE,QAAU,kMAAY,CAAC,QAAQ,CAAC,OAAO;AAC1E,MAAM,EAAE,WAAW,EAAE,aAAa,EAAE,GAAG,kMAAY,EAC1D,kCAAkC","ignoreList":[0]}},
    {"offset": {"line": 307, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/client/dist/capability/plan.js"],"sourcesContent":["import { Base } from '../base.js';\nimport * as API from '../types.js';\nimport * as Plan from '@storacha/capabilities/plan';\nexport class PlanClient extends Base {\n    /**\n     * Required delegated capabilities:\n     * - `plan/get`\n     *\n     * @param {import('@storacha/access').AccountDID} account\n     * @param {object} [options]\n     * @param {string} [options.nonce]\n     */\n    async get(account, options) {\n        const out = await get({ agent: this.agent }, { ...options, account });\n        if (!out.ok) {\n            throw new Error(`failed ${Plan.get.can} invocation`, {\n                cause: out.error,\n            });\n        }\n        return out.ok;\n    }\n    /**\n     * Required delegated capabilities:\n     * - `plan/set`\n     *\n     * @param {API.AccountDID} account\n     * @param {API.DID} product\n     * @param {object} [options]\n     * @param {string} [options.nonce]\n     */\n    async set(account, product, options) {\n        const out = await set({ agent: this.agent }, { ...options, account, product });\n        if (!out.ok) {\n            throw new Error(`failed ${Plan.set.can} invocation`, {\n                cause: out.error,\n            });\n        }\n        return out.ok;\n    }\n    /**\n     *\n     * @param {API.AccountDID} account\n     * @param {string} returnURL\n     * @param {object} [options]\n     * @param {string} [options.nonce]\n     */\n    async createAdminSession(account, returnURL, options) {\n        const out = await createAdminSession({ agent: this.agent }, { ...options, account, returnURL });\n        if (!out.ok) {\n            throw new Error(`failed ${Plan.createAdminSession.can} invocation`, {\n                cause: out.error,\n            });\n        }\n        return out.ok;\n    }\n    /**\n     *\n     * @param {API.AccountDID} account\n     * @param {object} options\n     * @param {API.DID} options.planID\n     * @param {string} [options.successURL]\n     * @param {string} [options.cancelURL]\n     * @param {boolean} [options.redirectAfterCompletion]\n     * @param {boolean} [options.freeTrial]\n     * @param {string} [options.nonce]\n     */\n    async createCheckoutSession(account, options) {\n        const out = await createCheckoutSession({ agent: this.agent }, { ...options, account });\n        if (!out.ok) {\n            throw new Error(`failed ${Plan.createCheckoutSession.can} invocation`, {\n                cause: out.error,\n            });\n        }\n        return out.ok;\n    }\n}\n/**\n * Gets the plan currently associated with the account.\n *\n * @param {{agent: API.Agent}} client\n * @param {object} options\n * @param {API.AccountDID} options.account\n * @param {string} [options.nonce]\n * @param {API.Delegation[]} [options.proofs]\n */\nexport const get = async ({ agent }, { account, nonce, proofs = [] }) => {\n    const receipt = await agent.invokeAndExecute(Plan.get, {\n        with: account,\n        proofs,\n        nonce,\n    });\n    return receipt.out;\n};\n/**\n * Sets the plan currently associated with the account.\n *\n * @param {{agent: API.Agent}} client\n * @param {object} options\n * @param {API.DID} options.product\n * @param {API.AccountDID} options.account\n * @param {string} [options.nonce]\n * @param {API.Delegation[]} [options.proofs]\n */\nexport const set = async ({ agent }, { account, product, nonce, proofs = [] }) => {\n    const receipt = await agent.invokeAndExecute(Plan.set, {\n        with: account,\n        nb: { product },\n        nonce,\n        proofs,\n    });\n    return receipt.out;\n};\n/**\n * Creates an admin session for the given account.\n *\n * Returns a URL that a user can resolve to enter the\n * admin billing portal for this account.\n *\n * @param {{agent: API.Agent}} client\n * @param {object} options\n * @param {API.AccountDID} options.account\n * @param {string} options.returnURL\n * @param {string} [options.nonce]\n * @param {API.Delegation[]} [options.proofs]\n */\nexport const createAdminSession = async ({ agent }, { account, returnURL, nonce, proofs = [] }) => {\n    const receipt = await agent.invokeAndExecute(Plan.createAdminSession, {\n        with: account,\n        proofs,\n        nonce,\n        nb: {\n            returnURL,\n        },\n    });\n    return receipt.out;\n};\n/**\n * Creates a checkout session for the given account.\n *\n * Returns a URL that a user can resolve to send the user\n * through Stripe checkout.\n *\n * @param {{agent: API.Agent}} client\n * @param {object} options\n * @param {API.AccountDID} options.account\n * @param {API.DID} options.planID\n * @param {string} [options.successURL]\n * @param {string} [options.cancelURL]\n * @param {boolean} [options.freeTrial]\n * @param {boolean} [options.redirectAfterCompletion]\n * @param {string} [options.nonce]\n * @param {API.Delegation[]} [options.proofs]\n */\nexport const createCheckoutSession = async ({ agent }, { account, planID, successURL, cancelURL, redirectAfterCompletion = true, freeTrial = false, nonce, proofs = [], }) => {\n    const receipt = await agent.invokeAndExecute(Plan.createCheckoutSession, {\n        with: account,\n        proofs,\n        nonce,\n        nb: {\n            planID,\n            successURL,\n            cancelURL,\n            redirectAfterCompletion,\n            freeTrial,\n        },\n    });\n    return receipt.out;\n};\n//# sourceMappingURL=plan.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 465, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/client/dist/capability/subscription.js"],"sourcesContent":["import { Subscription as SubscriptionCapabilities } from '@storacha/capabilities';\nimport * as API from '../types.js';\nimport { Base } from '../base.js';\n/**\n * Client for interacting with the `subscription/*` capabilities.\n */\nexport class SubscriptionClient extends Base {\n    /**\n     * List subscriptions for the passed account.\n     *\n     * Required delegated capabilities:\n     * - `subscription/list`\n     *\n     * @param {import('@storacha/access').AccountDID} account\n     * @param {object} [options]\n     * @param {string} [options.nonce]\n     */\n    /* c8 ignore next */\n    async list(account, options) {\n        const out = await list({ agent: this.agent }, { ...options, account });\n        /* c8 ignore next 8 */\n        if (!out.ok) {\n            throw new Error(`failed ${SubscriptionCapabilities.list.can} invocation`, {\n                cause: out.error,\n            });\n        }\n        return out.ok;\n    }\n}\n/**\n * Gets subscriptions associated with the account.\n *\n * @param {{agent: API.Agent}} client\n * @param {object} options\n * @param {API.AccountDID} options.account\n * @param {string} [options.nonce]\n * @param {API.Delegation[]} [options.proofs]\n */\nexport const list = async ({ agent }, { account, nonce, proofs = [] }) => {\n    const receipt = await agent.invokeAndExecute(SubscriptionCapabilities.list, {\n        with: account,\n        proofs,\n        nb: undefined,\n        nonce,\n    });\n    return receipt.out;\n};\n//# sourceMappingURL=subscription.js.map"],"names":[],"mappings":";;;;;;AAAA;AAAA;AACA;AACA;;;;AAIO,MAAM,2BAA2B,4JAAI;IACxC;;;;;;;;;KASC,GACD,kBAAkB,GAClB,MAAM,KAAK,OAAO,EAAE,OAAO,EAAE;QACzB,MAAM,MAAM,MAAM,KAAK;YAAE,OAAO,IAAI,CAAC,KAAK;QAAC,GAAG;YAAE,GAAG,OAAO;YAAE;QAAQ;QACpE,oBAAoB,GACpB,IAAI,CAAC,IAAI,EAAE,EAAE;YACT,MAAM,IAAI,MAAM,CAAC,OAAO,EAAE,0NAAwB,CAAC,IAAI,CAAC,GAAG,CAAC,WAAW,CAAC,EAAE;gBACtE,OAAO,IAAI,KAAK;YACpB;QACJ;QACA,OAAO,IAAI,EAAE;IACjB;AACJ;AAUO,MAAM,OAAO,OAAO,EAAE,KAAK,EAAE,EAAE,EAAE,OAAO,EAAE,KAAK,EAAE,SAAS,EAAE,EAAE;IACjE,MAAM,UAAU,MAAM,MAAM,gBAAgB,CAAC,0NAAwB,CAAC,IAAI,EAAE;QACxE,MAAM;QACN;QACA,IAAI;QACJ;IACJ;IACA,OAAO,QAAQ,GAAG;AACtB,GACA,wCAAwC","ignoreList":[0]}},
    {"offset": {"line": 516, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/client/dist/account.js"],"sourcesContent":["import * as API from './types.js';\nimport * as Access from './capability/access.js';\nimport * as Plan from './capability/plan.js';\nimport * as Subscription from './capability/subscription.js';\nimport { Delegation, importAuthorization } from '@storacha/access/agent';\nimport { add as provision, AccountDID } from '@storacha/access/provider';\nimport { fromEmail, toEmail } from '@storacha/did-mailto';\nimport * as UCAN from '@storacha/capabilities/ucan';\nexport { fromEmail };\n/**\n * @typedef {import('@storacha/did-mailto').EmailAddress} EmailAddress\n */\n/**\n * List all accounts that agent has stored access to. Returns a dictionary\n * of accounts keyed by their `did:mailto` identifier.\n *\n * @param {{agent: API.Agent}} client\n * @param {object} query\n * @param {API.DID<'mailto'>} [query.account]\n */\nexport const list = ({ agent }, { account } = {}) => {\n    const query = /** @type {API.CapabilityQuery} */ ({\n        with: account ?? /did:mailto:.*/,\n        can: '*',\n    });\n    const proofs = agent.proofs([query]);\n    /** @type {Record<API.DidMailto, Account>} */\n    const accounts = {};\n    /** @type {Record<string, API.Delegation>} */\n    const attestations = {};\n    for (const proof of proofs) {\n        const access = Delegation.allows(proof);\n        for (const [resource, abilities] of Object.entries(access)) {\n            if (AccountDID.is(resource) && abilities['*']) {\n                const id = /** @type {API.DidMailto} */ (resource);\n                const account = accounts[id] ||\n                    (accounts[id] = new Account({ id, agent, proofs: [] }));\n                account.addProof(proof);\n            }\n            for (const settings of /** @type {{proof?:API.Link}[]} */ (abilities['ucan/attest'] || [])) {\n                const id = settings.proof;\n                if (id) {\n                    attestations[`${id}`] = proof;\n                }\n            }\n        }\n    }\n    for (const account of Object.values(accounts)) {\n        for (const proof of account.proofs) {\n            const attestation = attestations[`${proof.cid}`];\n            if (attestation) {\n                account.addProof(attestation);\n            }\n        }\n    }\n    return accounts;\n};\n/**\n * Attempts to obtains an account access by performing an authentication with\n * the did:mailto account corresponding to given email. Process involves out\n * of bound email verification, so this function returns a promise that will\n * resolve to an account only after access has been granted by the email owner\n * by clicking on the link in the email. If the link is not clicked within the\n * authorization session time bounds (currently 15 minutes), the promise will\n * resolve to an error.\n *\n * @param {{agent: API.Agent}} client\n * @param {EmailAddress} email\n * @param {object} [options]\n * @param {AbortSignal} [options.signal]\n * @param {API.AppName} [options.appName]\n * @param {API.SSORequestParams} [options.sso] - SSO authentication (all fields required if provided)\n * @returns {Promise<API.Result<Account, Error>>}\n */\nexport const login = async ({ agent }, email, options = {}) => {\n    const account = fromEmail(email);\n    // If we already have a session for this account we\n    // skip the authentication process, otherwise we will\n    // end up adding more UCAN proofs and attestations to\n    // the store which we then will be sending when using\n    // this account.\n    // Note: This is not a robust solution as there may be\n    // reasons to re-authenticate e.g. previous session is\n    // no longer valid because it was revoked. But dropping\n    // revoked UCANs from store is something we should do\n    // anyway.\n    const session = list({ agent }, { account })[account];\n    if (session) {\n        return { ok: session };\n    }\n    const result = await Access.request({ agent }, {\n        account,\n        access: Access.accountAccess,\n        appName: options.appName,\n        sso: options.sso,\n    });\n    const { ok: access, error } = result;\n    /* c8 ignore next 2 - don't know how to test this */\n    if (error) {\n        return { error };\n    }\n    else {\n        const { ok, error } = await access.claim({ signal: options.signal });\n        /* c8 ignore next 2 - don't know how to test this */\n        if (error) {\n            return { error };\n        }\n        else {\n            return { ok: new Account({ id: account, proofs: ok.proofs, agent }) };\n        }\n    }\n};\n/* c8 ignore start */\n/**\n * Attempts to obtain account access for an out of band authentication process.\n * e.g. OAuth.\n *\n * Authentication is typically performed out of band by an OAuth provider. In\n * the OAuth callback, a delegation for the requested capabilities is issued\n * _from_ the email reported by the OAuth provider _to_ the agent. The service\n * also issues an attestation for this delegation.\n *\n * These capabilities are then claimed (using `access/claim`) and the account\n * email is derived from the delegation to the agent.\n *\n * @param {{agent: API.Agent}} client\n * @param {object} input\n * @param {API.Link} input.request Link to the `access/authorize` invocation.\n * @param {API.UTCUnixTimestamp} input.expiration Seconds in UTC.\n * @param {AbortSignal} [input.signal]\n * @param {string} [input.receiptsEndpoint]\n * @returns {Promise<API.Result<Account, Error>>}\n */\nexport const externalLogin = async ({ agent }, { request, expiration, ...options }) => {\n    const access = Access.createPendingAccessRequest({ agent }, { request, expiration });\n    const { ok, error } = await access.claim({ signal: options.signal });\n    /* c8 ignore next 2 - don't know how to test this */\n    if (error) {\n        return { error };\n    }\n    let attestedProof;\n    for (const p of ok.proofs) {\n        if (isUCANAttest(p)) {\n            attestedProof = p.capabilities[0].nb.proof;\n            break;\n        }\n    }\n    if (!attestedProof) {\n        return { error: new Error('missing attestation') };\n    }\n    let account;\n    for (const p of ok.proofs) {\n        if (p.cid.toString() === attestedProof.toString()) {\n            try {\n                account = Access.DIDMailto.fromString(p.issuer.did());\n            }\n            catch (err) {\n                return { error: new Error('invalid account DID', { cause: err }) };\n            }\n            break;\n        }\n    }\n    if (!account) {\n        return { error: new Error('missing attested delegation') };\n    }\n    return { ok: new Account({ id: account, proofs: ok.proofs, agent }) };\n};\n/* c8 ignore end */\n/**\n * @param {API.Delegation} d\n * @returns {d is API.Delegation<[API.UCANAttest]>}\n */\nconst isUCANAttest = (d) => d.capabilities[0].can === UCAN.attest.can;\n/**\n * @typedef {object} Model\n * @property {API.DidMailto} id\n * @property {API.Agent} agent\n * @property {API.Delegation[]} proofs\n */\nexport class Account {\n    /**\n     * @param {Model} model\n     */\n    constructor(model) {\n        this.model = model;\n        this.plan = new AccountPlan(model);\n    }\n    get agent() {\n        return this.model.agent;\n    }\n    get proofs() {\n        return this.model.proofs;\n    }\n    did() {\n        return this.model.id;\n    }\n    toEmail() {\n        return toEmail(this.did());\n    }\n    /**\n     * @param {API.Delegation} proof\n     */\n    addProof(proof) {\n        this.proofs.push(proof);\n    }\n    toJSON() {\n        return {\n            id: this.did(),\n            proofs: this.proofs\n                // we sort proofs to get a deterministic JSON representation.\n                .sort((a, b) => a.cid.toString().localeCompare(b.cid.toString()))\n                .map((proof) => proof.toJSON()),\n        };\n    }\n    /**\n     * Provisions given `space` with this account.\n     *\n     * @param {API.SpaceDID} space\n     * @param {object} input\n     * @param {API.ProviderDID} [input.provider]\n     * @param {API.Agent} [input.agent]\n     */\n    provision(space, input = {}) {\n        return provision(this.agent, {\n            ...input,\n            account: this.did(),\n            consumer: space,\n            proofs: this.proofs,\n        });\n    }\n    /**\n     * Saves account in the agent store so it can be accessed across sessions.\n     *\n     * @param {object} input\n     * @param {API.Agent} [input.agent]\n     */\n    async save({ agent = this.agent } = {}) {\n        return await importAuthorization(agent, this);\n    }\n}\nexport class AccountPlan {\n    /**\n     * @param {Model} model\n     */\n    constructor(model) {\n        this.model = model;\n    }\n    /**\n     * Gets information about the plan associated with this account.\n     *\n     * @param {object} [options]\n     * @param {string} [options.nonce]\n     */\n    async get(options) {\n        return await Plan.get(this.model, {\n            ...options,\n            account: this.model.id,\n            proofs: this.model.proofs,\n        });\n    }\n    /**\n     * Sets the plan associated with this account.\n     *\n     * @param {import('@ucanto/interface').DID} productDID\n     * @param {object} [options]\n     * @param {string} [options.nonce]\n     */\n    async set(productDID, options) {\n        return await Plan.set(this.model, {\n            ...options,\n            account: this.model.id,\n            product: productDID,\n            proofs: this.model.proofs,\n        });\n    }\n    /**\n     * Waits for a payment plan to be selected.\n     * This method continuously checks the account's payment plan status\n     * at a specified interval until a valid plan is selected, or when the timeout is reached,\n     * or when the abort signal is aborted.\n     *\n     * @param {object} [options]\n     * @param {number} [options.interval] - The polling interval in milliseconds (default is 1000ms).\n     * @param {number} [options.timeout] - The maximum time to wait in milliseconds before throwing a timeout error (default is 15 minutes).\n     * @param {AbortSignal} [options.signal] - An optional AbortSignal to cancel the waiting process.\n     * @returns {Promise<import('@storacha/access').PlanGetSuccess>} - Resolves once a payment plan is selected within the timeout.\n     * @throws {Error} - Throws an error if there is an issue retrieving the payment plan or if the timeout is exceeded.\n     */\n    async wait(options) {\n        const startTime = Date.now();\n        const interval = options?.interval || 1000; // 1 second\n        const timeout = options?.timeout || 60 * 15 * 1000; // 15 minutes\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const res = await this.get();\n            if (res.ok)\n                return res.ok;\n            if (res.error) {\n                if (res.error.name === 'PlanNotFound') {\n                    continue;\n                }\n                throw new Error(`Error retrieving payment plan: ${JSON.stringify(res.error)}`);\n            }\n            if (Date.now() - startTime > timeout) {\n                throw new Error('Timeout: Payment plan selection took too long.');\n            }\n            if (options?.signal?.aborted) {\n                throw new Error('Aborted: Payment plan selection was aborted.');\n            }\n            console.log('Waiting for payment plan to be selected...');\n            await new Promise((resolve) => setTimeout(resolve, interval));\n        }\n    }\n    /**\n     *\n     * @param {import('@storacha/access').AccountDID} accountDID\n     * @param {string} returnURL\n     * @param {object} [options]\n     * @param {string} [options.nonce]\n     */\n    async createAdminSession(accountDID, returnURL, options) {\n        return await Plan.createAdminSession(this.model, {\n            ...options,\n            account: accountDID,\n            returnURL,\n        });\n    }\n    /**\n     *\n     * @param {import('@storacha/access').AccountDID} accountDID\n     * @param {object} options\n     * @param {import('@storacha/did-mailto').DidMailto} options.planID\n     * @param {string} options.successURL\n     * @param {string} options.cancelURL\n     * @param {boolean} options.freeTrial\n     * @param {string} [options.nonce]\n     */\n    async createCheckoutSession(accountDID, options) {\n        return await Plan.createCheckoutSession(this.model, {\n            ...options,\n            account: accountDID,\n        });\n    }\n    /**\n     *\n     * @param {object} [options]\n     * @param {string} [options.nonce]\n     */\n    async subscriptions(options) {\n        return await Subscription.list(this.model, {\n            ...options,\n            account: this.model.id,\n            proofs: this.model.proofs,\n        });\n    }\n}\n//# sourceMappingURL=account.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 867, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/client/dist/capability/usage.js"],"sourcesContent":["import { Usage as UsageCapabilities } from '@storacha/capabilities';\nimport * as API from '../types.js';\nimport { Base } from '../base.js';\n/**\n * Client for interacting with the `usage/*` capabilities.\n */\nexport class UsageClient extends Base {\n    /**\n     * Get a usage report for the passed space in the given time period.\n     *\n     * Required delegated capabilities:\n     * - `usage/report`\n     *\n     * @param {import('../types.js').SpaceDID} space\n     * @param {{ from: Date, to: Date }} period\n     * @param {object} [options]\n     * @param {string} [options.nonce]\n     */\n    async report(space, period, options) {\n        const out = await report({ agent: this.agent }, { ...options, space, period });\n        /* c8 ignore next 7 */\n        if (!out.ok) {\n            throw new Error(`failed ${UsageCapabilities.report.can} invocation`, {\n                cause: out.error,\n            });\n        }\n        return out.ok;\n    }\n}\n/**\n * Get a usage report for the period.\n *\n * @param {{agent: API.Agent}} client\n * @param {object} options\n * @param {API.SpaceDID} options.space\n * @param {{ from: Date, to: Date }} options.period\n * @param {string} [options.nonce]\n * @param {API.Delegation[]} [options.proofs]\n * @returns {Promise<API.Result<API.UsageReportSuccess, API.UsageReportFailure>>}\n */\nexport const report = async ({ agent }, { space, period, nonce, proofs = [] }) => {\n    const receipt = await agent.invokeAndExecute(UsageCapabilities.report, {\n        with: space,\n        proofs,\n        nonce,\n        nb: {\n            period: {\n                from: Math.floor(period.from.getTime() / 1000),\n                to: Math.ceil(period.to.getTime() / 1000),\n            },\n        },\n    });\n    return receipt.out;\n};\n//# sourceMappingURL=usage.js.map"],"names":[],"mappings":";;;;;;AAAA;AAAA;AACA;AACA;;;;AAIO,MAAM,oBAAoB,4JAAI;IACjC;;;;;;;;;;KAUC,GACD,MAAM,OAAO,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE;QACjC,MAAM,MAAM,MAAM,OAAO;YAAE,OAAO,IAAI,CAAC,KAAK;QAAC,GAAG;YAAE,GAAG,OAAO;YAAE;YAAO;QAAO;QAC5E,oBAAoB,GACpB,IAAI,CAAC,IAAI,EAAE,EAAE;YACT,MAAM,IAAI,MAAM,CAAC,OAAO,EAAE,qMAAiB,CAAC,MAAM,CAAC,GAAG,CAAC,WAAW,CAAC,EAAE;gBACjE,OAAO,IAAI,KAAK;YACpB;QACJ;QACA,OAAO,IAAI,EAAE;IACjB;AACJ;AAYO,MAAM,SAAS,OAAO,EAAE,KAAK,EAAE,EAAE,EAAE,KAAK,EAAE,MAAM,EAAE,KAAK,EAAE,SAAS,EAAE,EAAE;IACzE,MAAM,UAAU,MAAM,MAAM,gBAAgB,CAAC,qMAAiB,CAAC,MAAM,EAAE;QACnE,MAAM;QACN;QACA;QACA,IAAI;YACA,QAAQ;gBACJ,MAAM,KAAK,KAAK,CAAC,OAAO,IAAI,CAAC,OAAO,KAAK;gBACzC,IAAI,KAAK,IAAI,CAAC,OAAO,EAAE,CAAC,OAAO,KAAK;YACxC;QACJ;IACJ;IACA,OAAO,QAAQ,GAAG;AACtB,GACA,iCAAiC","ignoreList":[0]}},
    {"offset": {"line": 925, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/client/dist/space.js"],"sourcesContent":["export * from '@storacha/access/space';\nimport * as Usage from './capability/usage.js';\nimport * as API from './types.js';\n/**\n * @typedef {object} Model\n * @property {API.SpaceDID} id\n * @property {{name?:string, access?:import('@storacha/access').SpaceAccessType}} [meta]\n * @property {API.Agent} agent\n */\nexport class Space {\n    #model;\n    /**\n     * @param {Model} model\n     */\n    constructor(model) {\n        this.#model = model;\n        this.usage = new StorageUsage(model);\n    }\n    /**\n     * The given space name.\n     */\n    get name() {\n        /* c8 ignore next */\n        return String(this.#model.meta?.name ?? '');\n    }\n    get access() {\n        return this.#model.meta?.access ?? { type: 'public' };\n    }\n    /**\n     * The DID of the space.\n     */\n    did() {\n        return this.#model.id;\n    }\n    /**\n     * User defined space metadata.\n     */\n    meta() {\n        return this.#model.meta;\n    }\n}\nexport class StorageUsage {\n    #model;\n    /**\n     * @param {Model} model\n     */\n    constructor(model) {\n        this.#model = model;\n    }\n    /**\n     * Get the current usage in bytes.\n     */\n    async get() {\n        const { agent } = this.#model;\n        const space = this.#model.id;\n        const now = new Date();\n        const period = {\n            // we may not have done a snapshot for this month _yet_, so get report\n            // from last month -> now\n            from: startOfLastMonth(now),\n            to: now,\n        };\n        const result = await Usage.report({ agent }, { space, period });\n        /* c8 ignore next */\n        if (result.error)\n            return result;\n        const provider = /** @type {API.ProviderDID} */ (agent.connection.id.did());\n        const report = result.ok[provider];\n        return {\n            /* c8 ignore next */\n            ok: report?.size.final == null ? undefined : BigInt(report.size.final),\n        };\n    }\n}\n/** @param {string|number|Date} now */\nconst startOfMonth = (now) => {\n    const d = new Date(now);\n    d.setUTCDate(1);\n    d.setUTCHours(0);\n    d.setUTCMinutes(0);\n    d.setUTCSeconds(0);\n    d.setUTCMilliseconds(0);\n    return d;\n};\n/** @param {string|number|Date} now */\nconst startOfLastMonth = (now) => {\n    const d = startOfMonth(now);\n    d.setUTCMonth(d.getUTCMonth() - 1);\n    return d;\n};\n//# sourceMappingURL=space.js.map"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;;;;AAOO,MAAM;IACT,CAAA,KAAM,CAAC;IACP;;KAEC,GACD,YAAY,KAAK,CAAE;QACf,IAAI,CAAC,CAAA,KAAM,GAAG;QACd,IAAI,CAAC,KAAK,GAAG,IAAI,aAAa;IAClC;IACA;;KAEC,GACD,IAAI,OAAO;QACP,kBAAkB,GAClB,OAAO,OAAO,IAAI,CAAC,CAAA,KAAM,CAAC,IAAI,EAAE,QAAQ;IAC5C;IACA,IAAI,SAAS;QACT,OAAO,IAAI,CAAC,CAAA,KAAM,CAAC,IAAI,EAAE,UAAU;YAAE,MAAM;QAAS;IACxD;IACA;;KAEC,GACD,MAAM;QACF,OAAO,IAAI,CAAC,CAAA,KAAM,CAAC,EAAE;IACzB;IACA;;KAEC,GACD,OAAO;QACH,OAAO,IAAI,CAAC,CAAA,KAAM,CAAC,IAAI;IAC3B;AACJ;AACO,MAAM;IACT,CAAA,KAAM,CAAC;IACP;;KAEC,GACD,YAAY,KAAK,CAAE;QACf,IAAI,CAAC,CAAA,KAAM,GAAG;IAClB;IACA;;KAEC,GACD,MAAM,MAAM;QACR,MAAM,EAAE,KAAK,EAAE,GAAG,IAAI,CAAC,CAAA,KAAM;QAC7B,MAAM,QAAQ,IAAI,CAAC,CAAA,KAAM,CAAC,EAAE;QAC5B,MAAM,MAAM,IAAI;QAChB,MAAM,SAAS;YACX,sEAAsE;YACtE,yBAAyB;YACzB,MAAM,iBAAiB;YACvB,IAAI;QACR;QACA,MAAM,SAAS,MAAM,6KAAY,CAAC;YAAE;QAAM,GAAG;YAAE;YAAO;QAAO;QAC7D,kBAAkB,GAClB,IAAI,OAAO,KAAK,EACZ,OAAO;QACX,MAAM,WAA2C,MAAM,UAAU,CAAC,EAAE,CAAC,GAAG;QACxE,MAAM,SAAS,OAAO,EAAE,CAAC,SAAS;QAClC,OAAO;YACH,kBAAkB,GAClB,IAAI,QAAQ,KAAK,SAAS,OAAO,YAAY,OAAO,OAAO,IAAI,CAAC,KAAK;QACzE;IACJ;AACJ;AACA,oCAAoC,GACpC,MAAM,eAAe,CAAC;IAClB,MAAM,IAAI,IAAI,KAAK;IACnB,EAAE,UAAU,CAAC;IACb,EAAE,WAAW,CAAC;IACd,EAAE,aAAa,CAAC;IAChB,EAAE,aAAa,CAAC;IAChB,EAAE,kBAAkB,CAAC;IACrB,OAAO;AACX;AACA,oCAAoC,GACpC,MAAM,mBAAmB,CAAC;IACtB,MAAM,IAAI,aAAa;IACvB,EAAE,WAAW,CAAC,EAAE,WAAW,KAAK;IAChC,OAAO;AACX,GACA,iCAAiC","ignoreList":[0]}},
    {"offset": {"line": 1017, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/client/dist/delegation.js"],"sourcesContent":["import { Delegation } from '@ucanto/core/delegation';\nexport * from '@ucanto/core/delegation';\n/* c8 ignore start */\n/**\n * @template {import('./types.js').Capabilities} C\n * @extends {Delegation<C>}\n */\nexport class AgentDelegation extends Delegation {\n    /* c8 ignore stop */\n    /** @type {Record<string, any>} */\n    #meta;\n    /**\n     * @param {import('./types.js').UCANBlock<C>} root\n     * @param {Map<string, import('./types.js').Block>} [blocks]\n     * @param {Record<string, any>} [meta]\n     */\n    constructor(root, blocks, meta = {}) {\n        super(root, blocks);\n        this.#meta = meta;\n    }\n    /**\n     * User defined delegation metadata.\n     */\n    meta() {\n        return this.#meta;\n    }\n}\n//# sourceMappingURL=delegation.js.map"],"names":[],"mappings":";;;;AAAA;;;AAOO,MAAM,wBAAwB,mKAAU;IAC3C,kBAAkB,GAClB,gCAAgC,GAChC,CAAA,IAAK,CAAC;IACN;;;;KAIC,GACD,YAAY,IAAI,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC,CAAE;QACjC,KAAK,CAAC,MAAM;QACZ,IAAI,CAAC,CAAA,IAAK,GAAG;IACjB;IACA;;KAEC,GACD,OAAO;QACH,OAAO,IAAI,CAAC,CAAA,IAAK;IACrB;AACJ,EACA,sCAAsC","ignoreList":[0]}},
    {"offset": {"line": 1044, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/client/dist/capability/blob.js"],"sourcesContent":["import { Blob } from '@storacha/upload-client';\nimport { SpaceBlob as BlobCapabilities } from '@storacha/capabilities';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { Base } from '../base.js';\n/** @import { AssertLocation } from '@web3-storage/content-claims/capability/api' */\n/**\n * Client for interacting with the `blob/*` capabilities.\n */\nexport class BlobClient extends Base {\n    /**\n     * Store a Blob to the resource.\n     *\n     * Required delegated capabilities:\n     * - `space/blob/add`\n     *\n     * @param {Blob} blob - blob data.\n     * @param {import('../types.js').RequestOptions} [options]\n     */\n    async add(blob, options = {}) {\n        options = {\n            receiptsEndpoint: this._receiptsEndpoint.toString(),\n            connection: this._serviceConf.upload,\n            ...options,\n        };\n        const conf = await this._invocationConfig([BlobCapabilities.add.can]);\n        const bytes = new Uint8Array(await blob.arrayBuffer());\n        const digest = await sha256.digest(bytes);\n        return { digest, ...(await Blob.add(conf, digest, bytes, options)) };\n    }\n    /**\n     * List blobs stored to the resource.\n     *\n     * Required delegated capabilities:\n     * - `space/blob/list`\n     *\n     * @param {import('../types.js').ListRequestOptions} [options]\n     */\n    async list(options = {}) {\n        const conf = await this._invocationConfig([BlobCapabilities.list.can]);\n        options.connection = this._serviceConf.upload;\n        return Blob.list(conf, options);\n    }\n    /**\n     * Remove a stored blob by multihash digest.\n     *\n     * Required delegated capabilities:\n     * - `space/blob/remove`\n     *\n     * @param {import('multiformats').MultihashDigest} digest - digest of blob to remove.\n     * @param {import('../types.js').RequestOptions} [options]\n     */\n    async remove(digest, options = {}) {\n        const conf = await this._invocationConfig([BlobCapabilities.remove.can]);\n        options.connection = this._serviceConf.upload;\n        return Blob.remove(conf, digest, options);\n    }\n    /**\n     * Gets a stored blob by multihash digest.\n     *\n     * @param {import('multiformats').MultihashDigest} digest - digest of blob to get.\n     * @param {import('../types.js').RequestOptions} [options]\n     */\n    async get(digest, options = {}) {\n        const conf = await this._invocationConfig([BlobCapabilities.get.can]);\n        options.connection = this._serviceConf.upload;\n        return Blob.get(conf, digest, options);\n    }\n    /**\n     * Replicate a blob to the specified number of nodes.\n     *\n     * @param {object} blob - details of the blob to replicate\n     * @param {import('multiformats').MultihashDigest} blob.digest - hash of the blob\n     * @param {number} blob.size - size of the blob in bytes\n     * @param {import('../types.js').Delegation<[AssertLocation]>} site - location commitment specifying where the blob can be obtained.\n     * @param {number} replicas - total number of replicas to provision.\n     * @param {import('../types.js').RequestOptions} [options]\n     */\n    async replicate(blob, site, replicas, options = {}) {\n        const conf = await this._invocationConfig([BlobCapabilities.replicate.can]);\n        options.connection = this._serviceConf.upload;\n        return Blob.replicate(conf, blob, site, replicas, options);\n    }\n}\n//# sourceMappingURL=blob.js.map"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;AAAA;AACA;AACA;;;;;AAKO,MAAM,mBAAmB,4JAAI;IAChC;;;;;;;;KAQC,GACD,MAAM,IAAI,IAAI,EAAE,UAAU,CAAC,CAAC,EAAE;QAC1B,UAAU;YACN,kBAAkB,IAAI,CAAC,iBAAiB,CAAC,QAAQ;YACjD,YAAY,IAAI,CAAC,YAAY,CAAC,MAAM;YACpC,GAAG,OAAO;QACd;QACA,MAAM,OAAO,MAAM,IAAI,CAAC,iBAAiB,CAAC;YAAC,qNAAgB,CAAC,GAAG,CAAC,GAAG;SAAC;QACpE,MAAM,QAAQ,IAAI,WAAW,MAAM,KAAK,WAAW;QACnD,MAAM,SAAS,MAAM,uKAAM,CAAC,MAAM,CAAC;QACnC,OAAO;YAAE;YAAQ,GAAI,MAAM,+MAAI,CAAC,GAAG,CAAC,MAAM,QAAQ,OAAO,QAAQ;QAAE;IACvE;IACA;;;;;;;KAOC,GACD,MAAM,KAAK,UAAU,CAAC,CAAC,EAAE;QACrB,MAAM,OAAO,MAAM,IAAI,CAAC,iBAAiB,CAAC;YAAC,qNAAgB,CAAC,IAAI,CAAC,GAAG;SAAC;QACrE,QAAQ,UAAU,GAAG,IAAI,CAAC,YAAY,CAAC,MAAM;QAC7C,OAAO,+MAAI,CAAC,IAAI,CAAC,MAAM;IAC3B;IACA;;;;;;;;KAQC,GACD,MAAM,OAAO,MAAM,EAAE,UAAU,CAAC,CAAC,EAAE;QAC/B,MAAM,OAAO,MAAM,IAAI,CAAC,iBAAiB,CAAC;YAAC,qNAAgB,CAAC,MAAM,CAAC,GAAG;SAAC;QACvE,QAAQ,UAAU,GAAG,IAAI,CAAC,YAAY,CAAC,MAAM;QAC7C,OAAO,+MAAI,CAAC,MAAM,CAAC,MAAM,QAAQ;IACrC;IACA;;;;;KAKC,GACD,MAAM,IAAI,MAAM,EAAE,UAAU,CAAC,CAAC,EAAE;QAC5B,MAAM,OAAO,MAAM,IAAI,CAAC,iBAAiB,CAAC;YAAC,qNAAgB,CAAC,GAAG,CAAC,GAAG;SAAC;QACpE,QAAQ,UAAU,GAAG,IAAI,CAAC,YAAY,CAAC,MAAM;QAC7C,OAAO,+MAAI,CAAC,GAAG,CAAC,MAAM,QAAQ;IAClC;IACA;;;;;;;;;KASC,GACD,MAAM,UAAU,IAAI,EAAE,IAAI,EAAE,QAAQ,EAAE,UAAU,CAAC,CAAC,EAAE;QAChD,MAAM,OAAO,MAAM,IAAI,CAAC,iBAAiB,CAAC;YAAC,qNAAgB,CAAC,SAAS,CAAC,GAAG;SAAC;QAC1E,QAAQ,UAAU,GAAG,IAAI,CAAC,YAAY,CAAC,MAAM;QAC7C,OAAO,+MAAI,CAAC,SAAS,CAAC,MAAM,MAAM,MAAM,UAAU;IACtD;AACJ,EACA,gCAAgC","ignoreList":[0]}},
    {"offset": {"line": 1145, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/client/dist/capability/index.js"],"sourcesContent":["import { Index } from '@storacha/upload-client';\nimport { SpaceIndex as IndexCapabilities } from '@storacha/capabilities';\nimport { Base } from '../base.js';\n/**\n * Client for interacting with the `index/*` capabilities.\n */\nexport class IndexClient extends Base {\n    /**\n     * Register an \"index\" to the resource.\n     *\n     * Required delegated capabilities:\n     * - `space/index/add`\n     *\n     * @param {import('../types.js').CARLink} index - CID of the CAR file that contains the index data.\n     * @param {import('../types.js').RequestOptions} [options]\n     */\n    async add(index, options = {}) {\n        const conf = await this._invocationConfig([IndexCapabilities.add.can]);\n        options.connection = this._serviceConf.upload;\n        return Index.add(conf, index, options);\n    }\n}\n//# sourceMappingURL=index.js.map"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;AAAA;AACA;;;;AAIO,MAAM,oBAAoB,4JAAI;IACjC;;;;;;;;KAQC,GACD,MAAM,IAAI,KAAK,EAAE,UAAU,CAAC,CAAC,EAAE;QAC3B,MAAM,OAAO,MAAM,IAAI,CAAC,iBAAiB,CAAC;YAAC,wNAAiB,CAAC,GAAG,CAAC,GAAG;SAAC;QACrE,QAAQ,UAAU,GAAG,IAAI,CAAC,YAAY,CAAC,MAAM;QAC7C,OAAO,kNAAK,CAAC,GAAG,CAAC,MAAM,OAAO;IAClC;AACJ,EACA,iCAAiC","ignoreList":[0]}},
    {"offset": {"line": 1178, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/client/dist/capability/upload.js"],"sourcesContent":["import { Upload } from '@storacha/upload-client';\nimport { Upload as UploadCapabilities } from '@storacha/capabilities';\nimport { Base } from '../base.js';\n/**\n * Client for interacting with the `upload/*` capabilities.\n */\nexport class UploadClient extends Base {\n    /**\n     * Register an \"upload\" to the resource.\n     *\n     * Required delegated capabilities:\n     * - `upload/add`\n     *\n     * @param {import('../types.js').UnknownLink} root - Root data CID for the DAG that was stored.\n     * @param {import('../types.js').CARLink[]} shards - CIDs of CAR files that contain the DAG.\n     * @param {import('../types.js').RequestOptions} [options]\n     */\n    async add(root, shards, options = {}) {\n        const conf = await this._invocationConfig([UploadCapabilities.add.can]);\n        options.connection = this._serviceConf.upload;\n        return Upload.add(conf, root, shards, options);\n    }\n    /**\n     * Get details of an \"upload\".\n     *\n     * Required delegated capabilities:\n     * - `upload/get`\n     *\n     * @param {import('../types.js').UnknownLink} root - Root data CID for the DAG that was stored.\n     * @param {import('../types.js').RequestOptions} [options]\n     */\n    async get(root, options = {}) {\n        const conf = await this._invocationConfig([UploadCapabilities.get.can]);\n        options.connection = this._serviceConf.upload;\n        return Upload.get(conf, root, options);\n    }\n    /**\n     * List uploads registered to the resource.\n     *\n     * Required delegated capabilities:\n     * - `upload/list`\n     *\n     * @param {import('../types.js').ListRequestOptions} [options]\n     */\n    async list(options = {}) {\n        const conf = await this._invocationConfig([UploadCapabilities.list.can]);\n        options.connection = this._serviceConf.upload;\n        return Upload.list(conf, options);\n    }\n    /**\n     * Remove an upload by root data CID.\n     *\n     * Required delegated capabilities:\n     * - `upload/remove`\n     *\n     * @param {import('../types.js').UnknownLink} root - Root data CID to remove.\n     * @param {import('../types.js').RequestOptions} [options]\n     */\n    async remove(root, options = {}) {\n        const conf = await this._invocationConfig([UploadCapabilities.remove.can]);\n        options.connection = this._serviceConf.upload;\n        return Upload.remove(conf, root, options);\n    }\n}\n//# sourceMappingURL=upload.js.map"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;AAAA;AACA;;;;AAIO,MAAM,qBAAqB,4JAAI;IAClC;;;;;;;;;KASC,GACD,MAAM,IAAI,IAAI,EAAE,MAAM,EAAE,UAAU,CAAC,CAAC,EAAE;QAClC,MAAM,OAAO,MAAM,IAAI,CAAC,iBAAiB,CAAC;YAAC,wMAAkB,CAAC,GAAG,CAAC,GAAG;SAAC;QACtE,QAAQ,UAAU,GAAG,IAAI,CAAC,YAAY,CAAC,MAAM;QAC7C,OAAO,qNAAM,CAAC,GAAG,CAAC,MAAM,MAAM,QAAQ;IAC1C;IACA;;;;;;;;KAQC,GACD,MAAM,IAAI,IAAI,EAAE,UAAU,CAAC,CAAC,EAAE;QAC1B,MAAM,OAAO,MAAM,IAAI,CAAC,iBAAiB,CAAC;YAAC,wMAAkB,CAAC,GAAG,CAAC,GAAG;SAAC;QACtE,QAAQ,UAAU,GAAG,IAAI,CAAC,YAAY,CAAC,MAAM;QAC7C,OAAO,qNAAM,CAAC,GAAG,CAAC,MAAM,MAAM;IAClC;IACA;;;;;;;KAOC,GACD,MAAM,KAAK,UAAU,CAAC,CAAC,EAAE;QACrB,MAAM,OAAO,MAAM,IAAI,CAAC,iBAAiB,CAAC;YAAC,wMAAkB,CAAC,IAAI,CAAC,GAAG;SAAC;QACvE,QAAQ,UAAU,GAAG,IAAI,CAAC,YAAY,CAAC,MAAM;QAC7C,OAAO,qNAAM,CAAC,IAAI,CAAC,MAAM;IAC7B;IACA;;;;;;;;KAQC,GACD,MAAM,OAAO,IAAI,EAAE,UAAU,CAAC,CAAC,EAAE;QAC7B,MAAM,OAAO,MAAM,IAAI,CAAC,iBAAiB,CAAC;YAAC,wMAAkB,CAAC,MAAM,CAAC,GAAG;SAAC;QACzE,QAAQ,UAAU,GAAG,IAAI,CAAC,YAAY,CAAC,MAAM;QAC7C,OAAO,qNAAM,CAAC,MAAM,CAAC,MAAM,MAAM;IACrC;AACJ,EACA,kCAAkC","ignoreList":[0]}},
    {"offset": {"line": 1256, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/client/dist/capability/space.js"],"sourcesContent":["import { Base } from '../base.js';\nimport { Space as SpaceCapabilities } from '@storacha/capabilities';\nimport * as API from '../types.js';\n/**\n * Client for interacting with the `space/*` capabilities.\n */\nexport class SpaceClient extends Base {\n    /**\n     * Get information about a space.\n     *\n     * Required delegated capabilities:\n     * - `space/info`\n     *\n     * @param {import('../types.js').DID} space - DID of the space to retrieve info about.\n     * @param {object} [options]\n     * @param {string} [options.nonce]\n     */\n    async info(space, options) {\n        return await this._agent.getSpaceInfo(space, options);\n    }\n    /**\n     * Record egress data for a served resource.\n     * It will execute the capability invocation to find the customer and then record the egress data for the resource.\n     *\n     * Required delegated capabilities:\n     * - `space/content/serve/egress/record`\n     *\n     * @param {object} egressData\n     * @param {import('../types.js').SpaceDID} egressData.space\n     * @param {API.UnknownLink} egressData.resource\n     * @param {number} egressData.bytes\n     * @param {string} egressData.servedAt\n     * @param {object} [options]\n     * @param {string} [options.nonce]\n     * @param {API.Delegation[]} [options.proofs]\n     * @returns {Promise<API.EgressRecordSuccess>}\n     */\n    async egressRecord(egressData, options) {\n        const out = await egressRecord({ agent: this.agent }, { ...egressData }, { ...options });\n        if (!out.ok) {\n            throw new Error(`failed ${SpaceCapabilities.egressRecord.can} invocation`, {\n                cause: out.error,\n            });\n        }\n        return /** @type {API.EgressRecordSuccess} */ (out.ok);\n    }\n}\n/**\n * Record egress data for a resource from a given space.\n *\n * @param {{agent: API.Agent}} client\n * @param {object} egressData\n * @param {API.SpaceDID} egressData.space\n * @param {API.UnknownLink} egressData.resource\n * @param {number} egressData.bytes\n * @param {string} egressData.servedAt\n * @param {object} options\n * @param {string} [options.nonce]\n * @param {API.Delegation[]} [options.proofs]\n */\nexport const egressRecord = async ({ agent }, { space, resource, bytes, servedAt }, { nonce, proofs = [] }) => {\n    const receipt = await agent.invokeAndExecute(SpaceCapabilities.egressRecord, {\n        with: space,\n        proofs,\n        nonce,\n        nb: {\n            resource,\n            bytes,\n            servedAt: Math.floor(new Date(servedAt).getTime() / 1000),\n        },\n    });\n    return receipt.out;\n};\n//# sourceMappingURL=space.js.map"],"names":[],"mappings":";;;;;;AAAA;AACA;AAAA;AACA;;;;AAIO,MAAM,oBAAoB,4JAAI;IACjC;;;;;;;;;KASC,GACD,MAAM,KAAK,KAAK,EAAE,OAAO,EAAE;QACvB,OAAO,MAAM,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,OAAO;IACjD;IACA;;;;;;;;;;;;;;;;KAgBC,GACD,MAAM,aAAa,UAAU,EAAE,OAAO,EAAE;QACpC,MAAM,MAAM,MAAM,aAAa;YAAE,OAAO,IAAI,CAAC,KAAK;QAAC,GAAG;YAAE,GAAG,UAAU;QAAC,GAAG;YAAE,GAAG,OAAO;QAAC;QACtF,IAAI,CAAC,IAAI,EAAE,EAAE;YACT,MAAM,IAAI,MAAM,CAAC,OAAO,EAAE,qMAAiB,CAAC,YAAY,CAAC,GAAG,CAAC,WAAW,CAAC,EAAE;gBACvE,OAAO,IAAI,KAAK;YACpB;QACJ;QACA,OAA+C,IAAI,EAAE;IACzD;AACJ;AAcO,MAAM,eAAe,OAAO,EAAE,KAAK,EAAE,EAAE,EAAE,KAAK,EAAE,QAAQ,EAAE,KAAK,EAAE,QAAQ,EAAE,EAAE,EAAE,KAAK,EAAE,SAAS,EAAE,EAAE;IACtG,MAAM,UAAU,MAAM,MAAM,gBAAgB,CAAC,qMAAiB,CAAC,YAAY,EAAE;QACzE,MAAM;QACN;QACA;QACA,IAAI;YACA;YACA;YACA,UAAU,KAAK,KAAK,CAAC,IAAI,KAAK,UAAU,OAAO,KAAK;QACxD;IACJ;IACA,OAAO,QAAQ,GAAG;AACtB,GACA,iCAAiC","ignoreList":[0]}},
    {"offset": {"line": 1331, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/client/dist/capability/account/usage.js"],"sourcesContent":["import { AccountUsage as AccountUsageCapabilites } from '@storacha/capabilities';\nimport * as API from '../../types.js';\nimport { Base } from '../../base.js';\n/**\n * Client for interacting with the `usage/*` capabilities.\n */\nexport class AccountUsageClient extends Base {\n    /**\n     * Get a usage report for the passed space in the given time period.\n     *\n     * Required delegated capabilities:\n     * - `usage/report`\n     *\n     * @param {API.AccountDID} account\n     * @param {object} [options]\n     * @param {{ from: Date, to: Date }} [options.period]\n     * @param {import('../../types.js').SpaceDID[]} [options.spaces]\n     * @param {string} [options.nonce]\n     */\n    async get(account, options) {\n        const out = await get({ agent: this.agent }, { ...options, account });\n        /* c8 ignore next 7 */\n        if (!out.ok) {\n            throw new Error(`failed ${AccountUsageCapabilites.get.can} invocation`, {\n                cause: out.error,\n            });\n        }\n        return out.ok;\n    }\n}\n/**\n * Get a usage report for the period.\n *\n * @param {{agent: API.Agent}} client\n * @param {object} options\n * @param {API.AccountDID} options.account\n * @param {API.SpaceDID[]} [options.spaces]\n * @param {{ from: Date, to: Date }} [options.period]\n * @param {string} [options.nonce]\n * @param {API.Delegation[]} [options.proofs]\n * @returns {Promise<API.Result<API.AccountUsageGetSuccess, API.AccountUsageGetFailure>>}\n */\nexport const get = async ({ agent }, { account, spaces, period, nonce, proofs = [] }) => {\n    const receipt = await agent.invokeAndExecute(AccountUsageCapabilites.get, {\n        with: account,\n        proofs,\n        nonce,\n        nb: {\n            spaces,\n            period: period\n                ? {\n                    from: Math.floor(period.from.getTime() / 1000),\n                    to: Math.ceil(period.to.getTime() / 1000),\n                }\n                : undefined,\n        },\n    });\n    return /** @type {API.Result<API.AccountUsageGetSuccess, API.AccountUsageGetFailure>} */ (receipt.out);\n};\n//# sourceMappingURL=usage.js.map"],"names":[],"mappings":";;;;;;AAAA;AAAA;AACA;AACA;;;;AAIO,MAAM,2BAA2B,4JAAI;IACxC;;;;;;;;;;;KAWC,GACD,MAAM,IAAI,OAAO,EAAE,OAAO,EAAE;QACxB,MAAM,MAAM,MAAM,IAAI;YAAE,OAAO,IAAI,CAAC,KAAK;QAAC,GAAG;YAAE,GAAG,OAAO;YAAE;QAAQ;QACnE,oBAAoB,GACpB,IAAI,CAAC,IAAI,EAAE,EAAE;YACT,MAAM,IAAI,MAAM,CAAC,OAAO,EAAE,8NAAuB,CAAC,GAAG,CAAC,GAAG,CAAC,WAAW,CAAC,EAAE;gBACpE,OAAO,IAAI,KAAK;YACpB;QACJ;QACA,OAAO,IAAI,EAAE;IACjB;AACJ;AAaO,MAAM,MAAM,OAAO,EAAE,KAAK,EAAE,EAAE,EAAE,OAAO,EAAE,MAAM,EAAE,MAAM,EAAE,KAAK,EAAE,SAAS,EAAE,EAAE;IAChF,MAAM,UAAU,MAAM,MAAM,gBAAgB,CAAC,8NAAuB,CAAC,GAAG,EAAE;QACtE,MAAM;QACN;QACA;QACA,IAAI;YACA;YACA,QAAQ,SACF;gBACE,MAAM,KAAK,KAAK,CAAC,OAAO,IAAI,CAAC,OAAO,KAAK;gBACzC,IAAI,KAAK,IAAI,CAAC,OAAO,EAAE,CAAC,OAAO,KAAK;YACxC,IACE;QACV;IACJ;IACA,OAA0F,QAAQ,GAAG;AACzG,GACA,iCAAiC","ignoreList":[0]}},
    {"offset": {"line": 1390, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/client/dist/capability/filecoin.js"],"sourcesContent":["import { Storefront } from '@storacha/filecoin-client';\nimport { Filecoin as FilecoinCapabilities } from '@storacha/capabilities';\nimport { Base } from '../base.js';\n/**\n * Client for interacting with the `filecoin/*` capabilities.\n */\nexport class FilecoinClient extends Base {\n    /**\n     * Offer a Filecoin \"piece\" to the resource.\n     *\n     * Required delegated capabilities:\n     * - `filecoin/offer`\n     *\n     * @param {import('multiformats').UnknownLink} content\n     * @param {import('@storacha/capabilities/types').PieceLink} piece\n     * @param {object} [options]\n     * @param {string} [options.nonce]\n     */\n    async offer(content, piece, options) {\n        const conf = await this._invocationConfig([FilecoinCapabilities.offer.can]);\n        return Storefront.filecoinOffer(conf, content, piece, {\n            ...options,\n            connection: this._serviceConf.filecoin,\n        });\n    }\n    /**\n     * Request info about a content piece in Filecoin deals\n     *\n     * Required delegated capabilities:\n     * - `filecoin/info`\n     *\n     * @param {import('@storacha/capabilities/types').PieceLink} piece\n     * @param {object} [options]\n     * @param {string} [options.nonce]\n     */\n    async info(piece, options) {\n        const conf = await this._invocationConfig([FilecoinCapabilities.info.can]);\n        return Storefront.filecoinInfo(conf, piece, {\n            ...options,\n            connection: this._serviceConf.filecoin,\n        });\n    }\n}\n//# sourceMappingURL=filecoin.js.map"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;AAAA;AACA;;;;AAIO,MAAM,uBAAuB,4JAAI;IACpC;;;;;;;;;;KAUC,GACD,MAAM,MAAM,OAAO,EAAE,KAAK,EAAE,OAAO,EAAE;QACjC,MAAM,OAAO,MAAM,IAAI,CAAC,iBAAiB,CAAC;YAAC,uNAAoB,CAAC,KAAK,CAAC,GAAG;SAAC;QAC1E,OAAO,0NAAU,CAAC,aAAa,CAAC,MAAM,SAAS,OAAO;YAClD,GAAG,OAAO;YACV,YAAY,IAAI,CAAC,YAAY,CAAC,QAAQ;QAC1C;IACJ;IACA;;;;;;;;;KASC,GACD,MAAM,KAAK,KAAK,EAAE,OAAO,EAAE;QACvB,MAAM,OAAO,MAAM,IAAI,CAAC,iBAAiB,CAAC;YAAC,uNAAoB,CAAC,IAAI,CAAC,GAAG;SAAC;QACzE,OAAO,0NAAU,CAAC,YAAY,CAAC,MAAM,OAAO;YACxC,GAAG,OAAO;YACV,YAAY,IAAI,CAAC,YAAY,CAAC,QAAQ;QAC1C;IACJ;AACJ,EACA,oCAAoC","ignoreList":[0]}},
    {"offset": {"line": 1445, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/client/dist/coupon.js"],"sourcesContent":["import * as API from '@storacha/access/types';\nimport { sha256, delegate, Delegation } from '@ucanto/core';\nimport { ed25519 } from '@ucanto/principal';\nimport * as Result from './result.js';\nimport { GrantedAccess } from '@storacha/access/access';\nimport { Base } from './base.js';\nexport class CouponAPI extends Base {\n    /**\n     * Redeems coupon from the the the archive. Throws an error if the coupon\n     * password is invalid or if provided archive is not a valid.\n     *\n     * @param {Uint8Array} archive\n     * @param {object} [options]\n     * @param {string} [options.password]\n     */\n    async redeem(archive, options = {}) {\n        const { agent } = this;\n        const coupon = Result.unwrap(await extract(archive));\n        return Result.unwrap(await redeem(coupon, { ...options, agent }));\n    }\n    /**\n     * Issues a coupon for the given delegation.\n     *\n     * @param {Omit<CouponOptions, 'issuer'>} options\n     */\n    async issue({ proofs = [], ...options }) {\n        const { agent } = this;\n        return await issue({\n            ...options,\n            issuer: agent.issuer,\n            proofs: [...proofs, ...agent.proofs(options.capabilities)],\n        });\n    }\n}\n/**\n * Extracts coupon from the archive.\n *\n * @param {Uint8Array} archive\n * @returns {Promise<API.Result<Coupon, Error>>}\n */\nexport const extract = async (archive) => {\n    const { ok, error } = await Delegation.extract(archive);\n    return ok ? Result.ok(new Coupon({ proofs: [ok] })) : Result.error(error);\n};\n/**\n * Encodes coupon into an archive.\n *\n * @param {Model} coupon\n */\nexport const archive = async (coupon) => {\n    const [delegation] = coupon.proofs;\n    return await Delegation.archive(delegation);\n};\n/**\n * Issues a coupon for the given delegation.\n *\n * @typedef {Omit<import('@ucanto/interface').DelegationOptions<API.Capabilities>, 'audience'> & { password?: string }} CouponOptions\n * @param {CouponOptions} options\n */\nexport const issue = async ({ password = '', ...options }) => {\n    const audience = await deriveSigner(password);\n    const delegation = await delegate({\n        ...options,\n        audience,\n    });\n    return new Coupon({ proofs: [delegation] });\n};\n/**\n * @typedef {object} Model\n * @property {[API.Delegation]} proofs\n */\n/**\n * Redeems granted access with the given agent from the given coupon.\n *\n * @param {Model} coupon\n * @param {object} options\n * @param {API.Agent} options.agent\n * @param {string} [options.password]\n * @returns {Promise<API.Result<GrantedAccess, Error>>}\n */\nexport const redeem = async (coupon, { agent, password = '' }) => {\n    const audience = await deriveSigner(password);\n    const [delegation] = coupon.proofs;\n    if (delegation.audience.did() !== audience.did()) {\n        return Result.error(new RangeError(password === ''\n            ? 'Extracting account requires a password'\n            : 'Provided password is invalid'));\n    }\n    else {\n        const authorization = await delegate({\n            issuer: audience,\n            audience: agent,\n            capabilities: delegation.capabilities,\n            expiration: delegation.expiration,\n            notBefore: delegation.notBefore,\n            proofs: [delegation],\n        });\n        return Result.ok(new GrantedAccess({ agent, proofs: [authorization] }));\n    }\n};\n/**\n * @param {string} password\n */\nconst deriveSigner = async (password) => {\n    const { digest } = await sha256.digest(new TextEncoder().encode(password));\n    return await ed25519.Signer.derive(digest);\n};\nexport class Coupon {\n    /**\n     * @param {Model} model\n     */\n    constructor(model) {\n        this.model = model;\n    }\n    get proofs() {\n        return this.model.proofs;\n    }\n    /**\n     *\n     * @param {API.Agent} agent\n     * @param {object} [options]\n     * @param {string} [options.password]\n     */\n    redeem(agent, options = {}) {\n        return redeem(this, { ...options, agent });\n    }\n    archive() {\n        return archive(this);\n    }\n}\n//# sourceMappingURL=coupon.js.map"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;;;;;;;AACO,MAAM,kBAAkB,4JAAI;IAC/B;;;;;;;KAOC,GACD,MAAM,OAAO,OAAO,EAAE,UAAU,CAAC,CAAC,EAAE;QAChC,MAAM,EAAE,KAAK,EAAE,GAAG,IAAI;QACtB,MAAM,SAAS,gLAAa,CAAC,MAAM,QAAQ;QAC3C,OAAO,gLAAa,CAAC,MAAM,OAAO,QAAQ;YAAE,GAAG,OAAO;YAAE;QAAM;IAClE;IACA;;;;KAIC,GACD,MAAM,MAAM,EAAE,SAAS,EAAE,EAAE,GAAG,SAAS,EAAE;QACrC,MAAM,EAAE,KAAK,EAAE,GAAG,IAAI;QACtB,OAAO,MAAM,MAAM;YACf,GAAG,OAAO;YACV,QAAQ,MAAM,MAAM;YACpB,QAAQ;mBAAI;mBAAW,MAAM,MAAM,CAAC,QAAQ,YAAY;aAAE;QAC9D;IACJ;AACJ;AAOO,MAAM,UAAU,OAAO;IAC1B,MAAM,EAAE,EAAE,EAAE,KAAK,EAAE,GAAG,MAAM,yMAAU,CAAC,OAAO,CAAC;IAC/C,OAAO,KAAK,uJAAS,CAAC,IAAI,OAAO;QAAE,QAAQ;YAAC;SAAG;IAAC,MAAM,0JAAY,CAAC;AACvE;AAMO,MAAM,UAAU,OAAO;IAC1B,MAAM,CAAC,WAAW,GAAG,OAAO,MAAM;IAClC,OAAO,MAAM,yMAAU,CAAC,OAAO,CAAC;AACpC;AAOO,MAAM,QAAQ,OAAO,EAAE,WAAW,EAAE,EAAE,GAAG,SAAS;IACrD,MAAM,WAAW,MAAM,aAAa;IACpC,MAAM,aAAa,MAAM,IAAA,iKAAQ,EAAC;QAC9B,GAAG,OAAO;QACV;IACJ;IACA,OAAO,IAAI,OAAO;QAAE,QAAQ;YAAC;SAAW;IAAC;AAC7C;AAcO,MAAM,SAAS,OAAO,QAAQ,EAAE,KAAK,EAAE,WAAW,EAAE,EAAE;IACzD,MAAM,WAAW,MAAM,aAAa;IACpC,MAAM,CAAC,WAAW,GAAG,OAAO,MAAM;IAClC,IAAI,WAAW,QAAQ,CAAC,GAAG,OAAO,SAAS,GAAG,IAAI;QAC9C,OAAO,0JAAY,CAAC,IAAI,WAAW,aAAa,KAC1C,2CACA;IACV,OACK;QACD,MAAM,gBAAgB,MAAM,IAAA,iKAAQ,EAAC;YACjC,QAAQ;YACR,UAAU;YACV,cAAc,WAAW,YAAY;YACrC,YAAY,WAAW,UAAU;YACjC,WAAW,WAAW,SAAS;YAC/B,QAAQ;gBAAC;aAAW;QACxB;QACA,OAAO,uJAAS,CAAC,IAAI,uKAAa,CAAC;YAAE;YAAO,QAAQ;gBAAC;aAAc;QAAC;IACxE;AACJ;AACA;;CAEC,GACD,MAAM,eAAe,OAAO;IACxB,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,uKAAM,CAAC,MAAM,CAAC,IAAI,cAAc,MAAM,CAAC;IAChE,OAAO,MAAM,qMAAO,CAAC,MAAM,CAAC,MAAM,CAAC;AACvC;AACO,MAAM;IACT;;KAEC,GACD,YAAY,KAAK,CAAE;QACf,IAAI,CAAC,KAAK,GAAG;IACjB;IACA,IAAI,SAAS;QACT,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM;IAC5B;IACA;;;;;KAKC,GACD,OAAO,KAAK,EAAE,UAAU,CAAC,CAAC,EAAE;QACxB,OAAO,OAAO,IAAI,EAAE;YAAE,GAAG,OAAO;YAAE;QAAM;IAC5C;IACA,UAAU;QACN,OAAO,QAAQ,IAAI;IACvB;AACJ,EACA,kCAAkC","ignoreList":[0]}},
    {"offset": {"line": 1590, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/client/dist/client.js"],"sourcesContent":["import { uploadFile, uploadDirectory, uploadCAR, Receipt, } from '@storacha/upload-client';\nimport { Access as AccessCapabilities, SpaceBlob as BlobCapabilities, SpaceIndex as IndexCapabilities, Upload as UploadCapabilities, Filecoin as FilecoinCapabilities, Space as SpaceCapabilities, } from '@storacha/capabilities';\nimport * as DIDMailto from '@storacha/did-mailto';\nimport { Base } from './base.js';\nimport * as Account from './account.js';\nimport { Space } from './space.js';\nimport { AgentDelegation } from './delegation.js';\nimport { BlobClient } from './capability/blob.js';\nimport { IndexClient } from './capability/index.js';\nimport { UploadClient } from './capability/upload.js';\nimport { SpaceClient } from './capability/space.js';\nimport { SubscriptionClient } from './capability/subscription.js';\nimport { UsageClient } from './capability/usage.js';\nimport { AccountUsageClient } from './capability/account/usage.js';\nimport { AccessClient } from './capability/access.js';\nimport { PlanClient } from './capability/plan.js';\nimport { FilecoinClient } from './capability/filecoin.js';\nimport { CouponAPI } from './coupon.js';\nexport * as Access from './capability/access.js';\nimport * as Result from './result.js';\nexport { AccessClient, BlobClient, FilecoinClient, IndexClient, PlanClient, SpaceClient, SubscriptionClient, UploadClient, UsageClient, AccountUsageClient, };\nexport class Client extends Base {\n    /**\n     * @param {import('@storacha/access').AgentData} agentData\n     * @param {object} [options]\n     * @param {import('./types.js').ServiceConf} [options.serviceConf]\n     * @param {URL} [options.receiptsEndpoint]\n     */\n    constructor(agentData, options) {\n        super(agentData, options);\n        this.capability = {\n            access: new AccessClient(agentData, options),\n            filecoin: new FilecoinClient(agentData, options),\n            index: new IndexClient(agentData, options),\n            plan: new PlanClient(agentData, options),\n            space: new SpaceClient(agentData, options),\n            blob: new BlobClient(agentData, options),\n            subscription: new SubscriptionClient(agentData, options),\n            upload: new UploadClient(agentData, options),\n            usage: new UsageClient(agentData, options),\n            account: {\n                usage: new AccountUsageClient(agentData, options),\n            },\n        };\n        this.coupon = new CouponAPI(agentData, options);\n    }\n    did() {\n        return this._agent.did();\n    }\n    /* c8 ignore start */\n    /**\n     * @deprecated - Use client.login instead.\n     *\n     * Authorize the current agent to use capabilities granted to the passed\n     * email account.\n     *\n     * @param {`${string}@${string}`} email\n     * @param {object} [options]\n     * @param {AbortSignal} [options.signal]\n     * @param {Iterable<{ can: import('./types.js').Ability }>} [options.capabilities]\n     */\n    async authorize(email, options) {\n        await this.capability.access.authorize(email, options);\n    }\n    /* c8 ignore stop */\n    /**\n     * @param {Account.EmailAddress} email\n     * @param {object} [options]\n     * @param {AbortSignal} [options.signal]\n     * @param {import('@storacha/client/types').AppName} [options.appName]\n     * @param {import('@storacha/client/types').SSORequestParams} [options.sso] - SSO authentication request (all fields required if provided)\n     */\n    async login(email, options = {}) {\n        const account = Result.unwrap(await Account.login(this, email, options));\n        Result.unwrap(await account.save());\n        return account;\n    }\n    /**\n     * List all accounts that agent has stored access to.\n     *\n     * @returns {Record<DIDMailto.DidMailto, Account.Account>} A dictionary with `did:mailto` as keys and `Account` instances as values.\n     */\n    accounts() {\n        return Account.list(this);\n    }\n    /**\n     * Uploads a file to the service and returns the root data CID for the\n     * generated DAG.\n     *\n     * Required delegated capabilities:\n     * - `filecoin/offer`\n     * - `space/blob/add`\n     * - `space/index/add`\n     * - `upload/add`\n     *\n     * @param {import('./types.js').BlobLike} file - File data.\n     * @param {import('./types.js').UploadFileOptions} [options]\n     */\n    async uploadFile(file, options = {}) {\n        const conf = await this._invocationConfig([\n            BlobCapabilities.add.can,\n            IndexCapabilities.add.can,\n            FilecoinCapabilities.offer.can,\n            UploadCapabilities.add.can,\n        ]);\n        options = {\n            receiptsEndpoint: this._receiptsEndpoint.toString(),\n            connection: this._serviceConf.upload,\n            ...options,\n        };\n        return uploadFile(conf, file, options);\n    }\n    /**\n     * Uploads a directory of files to the service and returns the root data CID\n     * for the generated DAG. All files are added to a container directory, with\n     * paths in the file names preserved.\n     *\n     * Required delegated capabilities:\n     * - `filecoin/offer`\n     * - `space/blob/add`\n     * - `space/index/add`\n     * - `upload/add`\n     *\n     * @param {import('./types.js').FileLike[]} files - File data.\n     * @param {import('./types.js').UploadDirectoryOptions} [options]\n     */\n    async uploadDirectory(files, options = {}) {\n        const conf = await this._invocationConfig([\n            BlobCapabilities.add.can,\n            IndexCapabilities.add.can,\n            FilecoinCapabilities.offer.can,\n            UploadCapabilities.add.can,\n        ]);\n        options = {\n            receiptsEndpoint: this._receiptsEndpoint.toString(),\n            connection: this._serviceConf.upload,\n            ...options,\n        };\n        return uploadDirectory(conf, files, options);\n    }\n    /**\n     * Uploads a CAR file to the service.\n     *\n     * The difference between this function and `capability.blob.add` is that\n     * the CAR file is automatically sharded, an index is generated, uploaded and\n     * registered (see `capability.index.add`) and finally an an \"upload\" is\n     * registered, linking the individual shards (see `capability.upload.add`).\n     *\n     * Use the `onShardStored` callback to obtain the CIDs of the CAR file shards.\n     *\n     * Required delegated capabilities:\n     * - `filecoin/offer`\n     * - `space/blob/add`\n     * - `space/index/add`\n     * - `upload/add`\n     *\n     * @param {import('./types.js').BlobLike} car - CAR file.\n     * @param {import('./types.js').UploadOptions} [options]\n     */\n    async uploadCAR(car, options = {}) {\n        const conf = await this._invocationConfig([\n            BlobCapabilities.add.can,\n            IndexCapabilities.add.can,\n            FilecoinCapabilities.offer.can,\n            UploadCapabilities.add.can,\n        ]);\n        options = {\n            receiptsEndpoint: this._receiptsEndpoint.toString(),\n            connection: this._serviceConf.upload,\n            ...options,\n        };\n        return uploadCAR(conf, car, options);\n    }\n    /**\n     * Get a receipt for an executed task by its CID.\n     *\n     * @template {import('./types.js').Capability} C\n     * @template {Record<string, any>} S\n     * @param {import('./types.js').UCANLink<[C]>} taskCid\n     * @param {import('./types.js').ReceiptGetOptions<S> & import('./types.js').Retryable} [options]\n     * @returns {Promise<import('./types.js').InferReceipt<C, S>>}\n     */\n    async getReceipt(taskCid, options) {\n        return Receipt.poll(taskCid, {\n            endpoint: new URL(this._receiptsEndpoint),\n            ...options,\n        });\n    }\n    /**\n     * Return the default provider.\n     */\n    defaultProvider() {\n        return this._agent.connection.id.did();\n    }\n    /**\n     * The current space.\n     */\n    currentSpace() {\n        const agent = this._agent;\n        const id = agent.currentSpace();\n        if (!id)\n            return;\n        const meta = agent.spaces.get(id);\n        return new Space({ id, meta, agent });\n    }\n    /**\n     * Use a specific space.\n     *\n     * @param {import('./types.js').DID} did\n     */\n    async setCurrentSpace(did) {\n        await this._agent.setCurrentSpace(/** @type {`did:key:${string}`} */ (did));\n    }\n    /**\n     * Spaces available to this agent.\n     */\n    spaces() {\n        return [...this._agent.spaces].map(([id, meta]) => {\n            // @ts-expect-error id is not did:key\n            return new Space({ id, meta, agent: this._agent });\n        });\n    }\n    /**\n     * Creates a new space with a given name.\n     * If an account is not provided, the space is created without any delegation and is not saved, hence it is a temporary space.\n     * When an account is provided in the options argument, then it creates a delegated recovery account\n     * by provisioning the space, saving it and then delegating access to the recovery account.\n     * In addition, it authorizes the listed Gateway Services to serve content from the created space.\n     * It is done by delegating the `space/content/serve/*` capability to the Gateway Service.\n     * User can skip the Gateway authorization by setting the `skipGatewayAuthorization` option to `true`.\n     * If no gateways are specified or the `skipGatewayAuthorization` flag is not set, the client will automatically grant access\n     * to the Storacha Gateway by default (https://w3s.link/).\n     *\n     * @typedef {import('./types.js').ConnectionView<import('./types.js').ContentServeService>} ConnectionView\n     *\n     * @typedef {object} SpaceCreateOptions\n     * @property {Account.Account} [account] - The account configured as the recovery account for the space.\n     * @property {Array<ConnectionView>} [authorizeGatewayServices] - The DID Key or DID Web of the Gateway to authorize to serve content from the created space.\n     * @property {boolean} [skipGatewayAuthorization] - Whether to skip the Gateway authorization. It means that the content of the space will not be served by any Gateway.\n     * @property {import('@storacha/access').SpaceAccessType} [access] - Access type for the space - determines client-side encryption behavior.\n     *\n     * @param {string} name - The name of the space to create.\n     * @param {SpaceCreateOptions} [options] - Options for the space creation.\n     * @returns {Promise<import(\"./space.js\").OwnedSpace>} The created space owned by the agent.\n     */\n    async createSpace(name, options = {}) {\n        // Save the space to authorize the client to use the space\n        const { access, account, skipGatewayAuthorization, authorizeGatewayServices, } = options;\n        const space = await this._agent.createSpace(name, { access });\n        if (account) {\n            // Provision the account with the space\n            const provisionResult = await account.provision(space.did());\n            if (provisionResult.error) {\n                throw new Error(`failed to provision account: ${provisionResult.error.message}`, { cause: provisionResult.error });\n            }\n            // Save the space to authorize the client to use the space\n            await space.save();\n            // Create a recovery for the account\n            const recovery = await space.createRecovery(account.did());\n            // Delegate space access to the recovery\n            const delegationResult = await this.capability.access.delegate({\n                space: space.did(),\n                delegations: [recovery],\n            });\n            if (delegationResult.error) {\n                // c8 ignore next 4\n                throw new Error(`failed to authorize recovery account: ${delegationResult.error.message}`, { cause: delegationResult.error });\n            }\n        }\n        // Authorize the listed Gateway Services to serve content from the created space\n        if (skipGatewayAuthorization !== true) {\n            let gatewayServices = authorizeGatewayServices;\n            if (!gatewayServices || gatewayServices.length === 0) {\n                // If no Gateway Services are provided, authorize the Storacha Gateway Service\n                gatewayServices = [this._serviceConf.gateway];\n            }\n            // Save the space to authorize the client to use the space\n            await space.save();\n            for (const serviceConnection of gatewayServices) {\n                await authorizeContentServe(this, space, serviceConnection);\n            }\n        }\n        return space;\n    }\n    /**\n     * Share an existing space with another Storacha account via email address delegation.\n     * Delegates access to the space to the specified email account with the following permissions:\n     * - space/* - for managing space metadata\n     * - blob/* - for managing blobs\n     * - store/* - for managing stores\n     * - upload/*- for registering uploads\n     * - access/* - for re-delegating access to other devices\n     * - filecoin/* - for submitting to the filecoin pipeline\n     * - usage/* - for querying usage\n     * The default expiration is set to infinity.\n     *\n     * @typedef {object} ShareOptions\n     * @property {import('./types.js').ServiceAbility[]} abilities - Abilities to delegate to the delegate account.\n     * @property {number} expiration - Expiration time in seconds.\n     \n     * @param {import(\"./types.js\").EmailAddress} delegateEmail - Email of the account to share the space with.\n     * @param {import('./types.js').SpaceDID} spaceDID - The DID of the space to share.\n     * @param {ShareOptions} [options] - Options for the delegation.\n     *\n     * @returns {Promise<import('./delegation.js').AgentDelegation<any>>} Resolves with the AgentDelegation instance once the space is successfully shared.\n     * @throws {Error} - Throws an error if there is an issue delegating access to the space.\n     */\n    async shareSpace(delegateEmail, spaceDID, options = {\n        abilities: [\n            'space/*',\n            'store/*',\n            'upload/*',\n            'access/*',\n            'usage/*',\n            'filecoin/*',\n        ],\n        expiration: Infinity,\n    }) {\n        const { abilities, ...restOptions } = options;\n        const currentSpace = this.agent.currentSpace();\n        try {\n            // Make sure the agent is using the shared space before delegating\n            await this.agent.setCurrentSpace(spaceDID);\n            // Delegate capabilities to the delegate account to access the **current space**\n            const { root, blocks } = await this.agent.delegate({\n                ...restOptions,\n                abilities,\n                audience: {\n                    did: () => DIDMailto.fromEmail(DIDMailto.email(delegateEmail)),\n                },\n                // @ts-expect-error audienceMeta is not defined in ShareOptions\n                audienceMeta: options.audienceMeta ?? {},\n            });\n            const delegation = new AgentDelegation(root, blocks, {\n                audience: delegateEmail,\n            });\n            const sharingResult = await this.capability.access.delegate({\n                space: spaceDID,\n                delegations: [delegation],\n            });\n            if (sharingResult.error) {\n                throw new Error(`failed to share space with ${delegateEmail}: ${sharingResult.error.message}`, {\n                    cause: sharingResult.error,\n                });\n            }\n            return delegation;\n        }\n        finally {\n            // Reset to the original space if it was different\n            if (currentSpace && currentSpace !== spaceDID) {\n                await this.agent.setCurrentSpace(currentSpace);\n            }\n        }\n    }\n    /* c8 ignore stop */\n    /**\n     * Add a space from a received proof.\n     *\n     * @param {import('./types.js').Delegation} proof\n     */\n    async addSpace(proof) {\n        return await this._agent.importSpaceFromDelegation(proof);\n    }\n    /**\n     * Get all the proofs matching the capabilities.\n     *\n     * Proofs are delegations with an _audience_ matching the agent DID.\n     *\n     * @param {import('./types.js').Capability[]} [caps] - Capabilities to\n     * filter by. Empty or undefined caps with return all the proofs.\n     */\n    proofs(caps) {\n        return this._agent.proofs(caps);\n    }\n    /**\n     * Add a proof to the agent. Proofs are delegations with an _audience_\n     * matching the agent DID.\n     *\n     * @param {import('./types.js').Delegation} proof\n     */\n    async addProof(proof) {\n        await this._agent.addProof(proof);\n    }\n    /**\n     * Get delegations created by the agent for others.\n     *\n     * @param {import('./types.js').Capability[]} [caps] - Capabilities to\n     * filter by. Empty or undefined caps with return all the delegations.\n     */\n    delegations(caps) {\n        const delegations = [];\n        for (const { delegation, meta } of this._agent.delegationsWithMeta(caps)) {\n            delegations.push(new AgentDelegation(delegation.root, delegation.blocks, meta));\n        }\n        return delegations;\n    }\n    /**\n     * Create a delegation to the passed audience for the given abilities with\n     * the _current_ space as the resource.\n     *\n     * @param {import('./types.js').Principal} audience\n     * @param {import('./types.js').ServiceAbility[]} abilities\n     * @param {Omit<import('./types.js').UCANOptions, 'audience'> & { audienceMeta?: import('./types.js').AgentMeta }} [options]\n     */\n    async createDelegation(audience, abilities, options = {}) {\n        const audienceMeta = options.audienceMeta ?? {\n            name: 'agent',\n            type: 'device',\n        };\n        const { root, blocks } = await this._agent.delegate({\n            ...options,\n            abilities,\n            audience,\n            audienceMeta,\n        });\n        return new AgentDelegation(root, blocks, { audience: audienceMeta });\n    }\n    /**\n     * Revoke a delegation by CID.\n     *\n     * If the delegation was issued by this agent (and therefore is stored in the\n     * delegation store) you can just pass the CID. If not, or if the current agent's\n     * delegation store no longer contains the delegation, you MUST pass a chain of\n     * proofs that proves your authority to revoke this delegation as `options.proofs`.\n     *\n     * @param {import('@ucanto/interface').UCANLink} delegationCID\n     * @param {object} [options]\n     * @param {import('@ucanto/interface').Delegation[]} [options.proofs]\n     */\n    async revokeDelegation(delegationCID, options = {}) {\n        return this._agent.revoke(delegationCID, {\n            proofs: options.proofs,\n        });\n    }\n    /**\n     * Removes association of a content CID with the space. Optionally, also removes\n     * association of CAR shards with space.\n     *\n     *  If `shards` option is `true` all shards will be deleted even if there is another upload(s) that\n     * reference same shards, which in turn could corrupt those uploads.\n     *\n     * Required delegated capabilities:\n     * - `space/blob/remove`\n     * - `store/remove`\n     * - `upload/get`\n     * - `upload/remove`\n     *\n     * @param {import('multiformats').UnknownLink} contentCID\n     * @param {object} [options]\n     * @param {boolean} [options.shards]\n     */\n    async remove(contentCID, options = {}) {\n        // Shortcut if there is no request to remove shards\n        if (!options.shards) {\n            // Remove association of content CID with selected space.\n            await this.capability.upload.remove(contentCID);\n            return;\n        }\n        // Get shards associated with upload.\n        const upload = await this.capability.upload.get(contentCID);\n        // Remove shards\n        if (upload.shards?.length) {\n            await Promise.allSettled(upload.shards.map((shard) => this.capability.blob.remove(shard.multihash)));\n        }\n        // Remove association of content CID with selected space.\n        await this.capability.upload.remove(contentCID);\n    }\n}\n/**\n * Authorizes an audience to serve content from the provided space and record egress events.\n * It also publishes the delegation to the content serve service.\n * Delegates the following capabilities to the audience:\n * - `space/content/serve/*`\n *\n * @param {Client} client - The w3up client instance.\n * @param {import('./types.js').OwnedSpace} space - The space to authorize the audience for.\n * @param {import('./types.js').ConnectionView<import('./types.js').ContentServeService>} connection - The connection to the Content Serve Service that will handle, validate, and store the access/delegate UCAN invocation.\n * @param {object} [options] - Options for the content serve authorization invocation.\n * @param {`did:${string}:${string}`} [options.audience] - The Web DID of the audience (gateway or peer) to authorize.\n * @param {number} [options.expiration] - The time at which the delegation expires in seconds from unix epoch.\n */\nexport const authorizeContentServe = async (client, space, connection, options = {}) => {\n    const currentSpace = client.currentSpace();\n    try {\n        // Set the current space to the space we are authorizing the gateway for, otherwise the delegation will fail\n        await client.setCurrentSpace(space.did());\n        /** @type {import('@ucanto/client').Principal<`did:${string}:${string}`>} */\n        const audience = {\n            did: () => options.audience ?? connection.id.did(),\n        };\n        // Grant the audience the ability to serve content from the space, it includes existing proofs automatically\n        const delegation = await client.createDelegation(audience, [SpaceCapabilities.contentServe.can], {\n            expiration: options.expiration ?? Infinity,\n        });\n        // Publish the delegation to the content serve service\n        const accessProofs = client.proofs([\n            { can: AccessCapabilities.access.can, with: space.did() },\n        ]);\n        const verificationResult = await AccessCapabilities.delegate\n            .invoke({\n            issuer: client.agent.issuer,\n            audience,\n            with: space.did(),\n            proofs: [...accessProofs, delegation],\n            nb: {\n                delegations: {\n                    [delegation.cid.toString()]: delegation.cid,\n                },\n            },\n        })\n            .execute(connection);\n        /* c8 ignore next 8 - can't mock this error */\n        if (verificationResult.out.error) {\n            throw new Error(`failed to publish delegation for audience ${audience.did()}: ${verificationResult.out.error.message}`, {\n                cause: verificationResult.out.error,\n            });\n        }\n        return { ok: { ...verificationResult.out.ok, delegation } };\n    }\n    finally {\n        if (currentSpace) {\n            await client.setCurrentSpace(currentSpace.did());\n        }\n    }\n};\n//# sourceMappingURL=client.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2144, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/client/dist/ability.js"],"sourcesContent":["import { abilitiesAsStrings } from '@storacha/capabilities';\nconst setOfAbilities = new Set(abilitiesAsStrings);\n/**\n * Verify and return Abilities.\n *\n * Given a list of strings representing capability names (Abilities),\n * verify that all the strings are valid Abilities and return Abilities[].\n *\n * Abilities[] is still just a list of strings, but this helps us play\n * nice with Typescript.\n *\n * @param {string[]} abilities\n * @returns {import('@storacha/capabilities/types').ServiceAbility[]}\n */\nexport function asAbilities(abilities) {\n    for (const ability of abilities) {\n        if (!setOfAbilities.has(\n        /** @type {import('@storacha/capabilities/types').ServiceAbility} */ (ability))) {\n            throw new Error(`${ability} is not a supported capability`);\n        }\n    }\n    return /** @type {import('@storacha/capabilities/types').ServiceAbility[]} */ (abilities);\n}\n//# sourceMappingURL=ability.js.map"],"names":[],"mappings":";;;;AAAA;;AACA,MAAM,iBAAiB,IAAI,IAAI,iMAAkB;AAa1C,SAAS,YAAY,SAAS;IACjC,KAAK,MAAM,WAAW,UAAW;QAC7B,IAAI,CAAC,eAAe,GAAG,CAC+C,UAAW;YAC7E,MAAM,IAAI,MAAM,GAAG,QAAQ,8BAA8B,CAAC;QAC9D;IACJ;IACA,OAA+E;AACnF,EACA,mCAAmC","ignoreList":[0]}},
    {"offset": {"line": 2163, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/client/dist/index.node.js"],"sourcesContent":["/**\n * @hidden\n * @module\n */\nimport { AgentData } from '@storacha/access/agent';\nimport { StoreConf } from '@storacha/access/stores/store-conf';\nimport { generate } from '@ucanto/principal/ed25519';\nimport { Client } from './client.js';\nexport * as Result from './result.js';\nexport * as Account from './account.js';\nexport * from './ability.js';\nexport { authorizeContentServe } from './client.js';\n/**\n * Create a new w3up client.\n *\n * If no backing store is passed one will be created that is appropriate for\n * the environment.\n *\n * If the backing store is empty, a new signing key will be generated and\n * persisted to the store. In the browser an unextractable RSA key will be\n * generated by default. In other environments an Ed25519 key is generated.\n *\n * If the backing store already has data stored, it will be loaded and used.\n *\n * @type {import('./types.js').ClientFactory}\n */\nexport async function create(options = {}) {\n    const store = options.store ?? new StoreConf({ profile: 'w3up-client' });\n    const raw = await store.load();\n    if (raw) {\n        const data = AgentData.fromExport(raw, { store });\n        if (options.principal && data.principal.did() !== options.principal.did()) {\n            throw new Error(`store cannot be used with ${options.principal.did()}, stored principal and passed principal must match`);\n        }\n        return new Client(data, options);\n    }\n    const principal = options.principal ?? (await generate());\n    const data = await AgentData.create({ principal }, { store });\n    return new Client(data, options);\n}\nexport { Client };\n//# sourceMappingURL=index.node.js.map"],"names":[],"mappings":"AAAA;;;CAGC;;;;AACD;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;AAgBO,eAAe,OAAO,UAAU,CAAC,CAAC;IACrC,MAAM,QAAQ,QAAQ,KAAK,IAAI,IAAI,oLAAS,CAAC;QAAE,SAAS;IAAc;IACtE,MAAM,MAAM,MAAM,MAAM,IAAI;IAC5B,IAAI,KAAK;QACL,MAAM,OAAO,0KAAS,CAAC,UAAU,CAAC,KAAK;YAAE;QAAM;QAC/C,IAAI,QAAQ,SAAS,IAAI,KAAK,SAAS,CAAC,GAAG,OAAO,QAAQ,SAAS,CAAC,GAAG,IAAI;YACvE,MAAM,IAAI,MAAM,CAAC,0BAA0B,EAAE,QAAQ,SAAS,CAAC,GAAG,GAAG,kDAAkD,CAAC;QAC5H;QACA,OAAO,IAAI,gLAAM,CAAC,MAAM;IAC5B;IACA,MAAM,YAAY,QAAQ,SAAS,IAAK,MAAM,IAAA,6KAAQ;IACtD,MAAM,OAAO,MAAM,0KAAS,CAAC,MAAM,CAAC;QAAE;IAAU,GAAG;QAAE;IAAM;IAC3D,OAAO,IAAI,gLAAM,CAAC,MAAM;AAC5B;;CAEA,sCAAsC","ignoreList":[0]}}]
}