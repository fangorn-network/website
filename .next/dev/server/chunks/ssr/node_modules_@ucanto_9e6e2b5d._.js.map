{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 9, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/client/src/connection.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport { Signature, Message, Receipt, sha256 } from '@ucanto/core'\n\n/**\n * Creates a connection to a service.\n *\n * @template {Record<string, any>} T\n * @param {API.ConnectionOptions<T>} options\n * @returns {API.ConnectionView<T>}\n */\nexport const connect = options => new Connection(options)\n\n/**\n * @template {Record<string, any>} T\n * @implements {API.ConnectionView<T>}\n */\nclass Connection {\n  /**\n   * @param {API.ConnectionOptions<T>} options\n   */\n  constructor(options) {\n    this.id = options.id\n    this.options = options\n    this.codec = options.codec\n    this.channel = options.channel\n    this.hasher = options.hasher || sha256\n  }\n  /**\n   * Execute invocations.\n   *\n   * @template {API.Capability} C\n   * @template {API.Tuple<API.ServiceInvocation<C, T>>} I\n   * @param {I} invocations\n   * @returns {Promise<API.InferReceipts<I, T>>}\n   */\n  async execute(...invocations) {\n    return execute(invocations, this)\n  }\n}\n\n/**\n * @template {API.Capability} C\n * @template {Record<string, any>} T\n * @template {API.Tuple<API.ServiceInvocation<C, T>>} I\n * @param {API.Connection<T>} connection\n * @param {I} invocations\n * @returns {Promise<API.InferReceipts<I, T>>}\n */\nexport const execute = async (invocations, connection) => {\n  const input = await Message.build({ invocations })\n  const request = await connection.codec.encode(input, connection)\n  const response = await connection.channel.request(request)\n  // We may fail to decode the response if content type is not supported\n  // or if data was corrupted. We do not want to throw in such case however,\n  // because client will get an Error object as opposed to a receipt, to retain\n  // consistent client API with two kinds of errors we encode caught error as\n  // a receipts per workflow invocation.\n  try {\n    const output = await connection.codec.decode(response)\n    const receipts = input.invocationLinks.map(link => output.get(link))\n    return /** @type {API.InferReceipts<I, T>} */ (receipts)\n  } catch (error) {\n    // No third party code is run during decode and we know\n    // we only throw an Error\n    const { message, name = 'Error', ...cause } = /** @type {Error} */ (error)\n    const receipts = []\n    for await (const ran of input.invocationLinks) {\n      const receipt = await Receipt.issue({\n        ran,\n        result: { error: { ...cause, name, message } },\n        // @ts-expect-error - we can not really sign a receipt without having\n        // an access to a signer which client does not have. In the future\n        // we will change client API requiring a signer to be passed in but\n        // for now we just use a dummy signer.\n        issuer: {\n          did() {\n            return connection.id.did()\n          },\n          sign() {\n            return Signature.createNonStandard('', new Uint8Array())\n          },\n        },\n      })\n\n      receipts.push(receipt)\n    }\n\n    return /** @type {API.InferReceipts<I, T>} */ (receipts)\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;AASO,MAAM,UAAU,CAAA,UAAW,IAAI,WAAW;AAEjD;;;CAGC,GACD,MAAM;IACJ;;GAEC,GACD,YAAY,OAAO,CAAE;QACnB,IAAI,CAAC,EAAE,GAAG,QAAQ,EAAE;QACpB,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,KAAK,GAAG,QAAQ,KAAK;QAC1B,IAAI,CAAC,OAAO,GAAG,QAAQ,OAAO;QAC9B,IAAI,CAAC,MAAM,GAAG,QAAQ,MAAM,IAAI,2MAAM;IACxC;IACA;;;;;;;GAOC,GACD,MAAM,QAAQ,GAAG,WAAW,EAAE;QAC5B,OAAO,QAAQ,aAAa,IAAI;IAClC;AACF;AAUO,MAAM,UAAU,OAAO,aAAa;IACzC,MAAM,QAAQ,MAAM,gMAAO,CAAC,KAAK,CAAC;QAAE;IAAY;IAChD,MAAM,UAAU,MAAM,WAAW,KAAK,CAAC,MAAM,CAAC,OAAO;IACrD,MAAM,WAAW,MAAM,WAAW,OAAO,CAAC,OAAO,CAAC;IAClD,sEAAsE;IACtE,0EAA0E;IAC1E,6EAA6E;IAC7E,2EAA2E;IAC3E,sCAAsC;IACtC,IAAI;QACF,MAAM,SAAS,MAAM,WAAW,KAAK,CAAC,MAAM,CAAC;QAC7C,MAAM,WAAW,MAAM,eAAe,CAAC,GAAG,CAAC,CAAA,OAAQ,OAAO,GAAG,CAAC;QAC9D,OAA+C;IACjD,EAAE,OAAO,OAAO;QACd,uDAAuD;QACvD,yBAAyB;QACzB,MAAM,EAAE,OAAO,EAAE,OAAO,OAAO,EAAE,GAAG,OAAO,GAAyB;QACpE,MAAM,WAAW,EAAE;QACnB,WAAW,MAAM,OAAO,MAAM,eAAe,CAAE;YAC7C,MAAM,UAAU,MAAM,gMAAO,CAAC,KAAK,CAAC;gBAClC;gBACA,QAAQ;oBAAE,OAAO;wBAAE,GAAG,KAAK;wBAAE;wBAAM;oBAAQ;gBAAE;gBAC7C,qEAAqE;gBACrE,kEAAkE;gBAClE,mEAAmE;gBACnE,sCAAsC;gBACtC,QAAQ;oBACN;wBACE,OAAO,WAAW,EAAE,CAAC,GAAG;oBAC1B;oBACA;wBACE,OAAO,2MAAS,CAAC,iBAAiB,CAAC,IAAI,IAAI;oBAC7C;gBACF;YACF;YAEA,SAAS,IAAI,CAAC;QAChB;QAEA,OAA+C;IACjD;AACF","ignoreList":[0]}},
    {"offset": {"line": 100, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/client/src/lib.js"],"sourcesContent":["export * from './connection.js'\n\nexport * from '@ucanto/interface'\nimport { Delegation, invoke, Schema, DAG, ok, error } from '@ucanto/core'\n\nexport const delegate = Delegation.delegate\nexport { invoke, ok, error, Schema, DAG }\n"],"names":[],"mappings":";;;;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEO,MAAM,WAAW,yMAAU,CAAC,QAAQ","ignoreList":[0]}},
    {"offset": {"line": 121, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/transport/src/car/request.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport { CAR, Message } from '@ucanto/core'\n\nexport { CAR as codec }\n\nexport const contentType = CAR.contentType\n\nconst HEADERS = Object.freeze({\n  'content-type': contentType,\n  // We will signal that we want to receive a CAR file in the response\n  accept: contentType,\n})\n\n/**\n * Encodes `AgentMessage` into an `HTTPRequest`.\n *\n * @template {API.AgentMessage} Message\n * @param {Message} message\n * @param {API.EncodeOptions & { headers?: Record<string, string> }} [options]\n * @returns {API.HTTPRequest<Message>}\n */\nexport const encode = (message, options) => {\n  const blocks = new Map()\n  for (const block of message.iterateIPLDBlocks()) {\n    blocks.set(`${block.cid}`, block)\n  }\n\n  /**\n   * Cast to Uint8Array to remove phantom type set by the\n   * CAR encoder which is too specific.\n   *\n   * @type {Uint8Array}\n   */\n  const body = CAR.encode({\n    roots: [message.root],\n    blocks,\n  })\n\n  return {\n    headers: options?.headers || { ...HEADERS },\n    body,\n  }\n}\n\n/**\n * Decodes `AgentMessage` from the received `HTTPRequest`.\n *\n * @template {API.AgentMessage} Message\n * @param {API.HTTPRequest<Message>} request\n * @returns {Promise<Message>}\n */\nexport const decode = async ({ headers, body }) => {\n  const { roots, blocks } = CAR.decode(/** @type {Uint8Array} */ (body))\n  const message = Message.view({ root: roots[0].cid, store: blocks })\n  return /** @type {Message} */ (message)\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AAAA;AAAA;;;;AAIO,MAAM,cAAc,oLAAG,CAAC,WAAW;AAE1C,MAAM,UAAU,OAAO,MAAM,CAAC;IAC5B,gBAAgB;IAChB,oEAAoE;IACpE,QAAQ;AACV;AAUO,MAAM,SAAS,CAAC,SAAS;IAC9B,MAAM,SAAS,IAAI;IACnB,KAAK,MAAM,SAAS,QAAQ,iBAAiB,GAAI;QAC/C,OAAO,GAAG,CAAC,GAAG,MAAM,GAAG,EAAE,EAAE;IAC7B;IAEA;;;;;GAKC,GACD,MAAM,OAAO,oLAAG,CAAC,MAAM,CAAC;QACtB,OAAO;YAAC,QAAQ,IAAI;SAAC;QACrB;IACF;IAEA,OAAO;QACL,SAAS,SAAS,WAAW;YAAE,GAAG,OAAO;QAAC;QAC1C;IACF;AACF;AASO,MAAM,SAAS,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE;IAC5C,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,GAAG,oLAAG,CAAC,MAAM,CAA4B;IAChE,MAAM,UAAU,gMAAO,CAAC,IAAI,CAAC;QAAE,MAAM,KAAK,CAAC,EAAE,CAAC,GAAG;QAAE,OAAO;IAAO;IACjE,OAA+B;AACjC","ignoreList":[0]}},
    {"offset": {"line": 193, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/transport/src/car/response.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport { CAR, Message } from '@ucanto/core'\nexport { CAR as codec }\n\nexport const contentType = CAR.contentType\n\nconst HEADERS = Object.freeze({\n  'content-type': contentType,\n})\n\n/**\n * Encodes `AgentMessage` into an `HTTPRequest`.\n *\n * @template {API.AgentMessage} Message\n * @param {Message} message\n * @param {API.EncodeOptions} [options]\n * @returns {API.HTTPResponse<Message>}\n */\nexport const encode = (message, options) => {\n  const blocks = new Map()\n  for (const block of message.iterateIPLDBlocks()) {\n    blocks.set(`${block.cid}`, block)\n  }\n\n  /**\n   * Cast to Uint8Array to remove phantom type set by the\n   * CAR encoder which is too specific.\n   *\n   * @type {Uint8Array}\n   */\n  const body = CAR.encode({\n    roots: [message.root],\n    blocks,\n  })\n\n  return {\n    headers: { ...HEADERS },\n    body,\n  }\n}\n\n/**\n * Decodes `AgentMessage` from the received `HTTPResponse`.\n *\n * @template {API.AgentMessage} Message\n * @param {API.HTTPResponse<Message>} response\n * @returns {Promise<Message>}\n */\nexport const decode = async ({ headers, body }) => {\n  const { roots, blocks } = CAR.decode(/** @type {Uint8Array} */ (body))\n  const message = Message.view({ root: roots[0].cid, store: blocks })\n  return /** @type {Message} */ (message)\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AAAA;AAAA;;;;AAGO,MAAM,cAAc,oLAAG,CAAC,WAAW;AAE1C,MAAM,UAAU,OAAO,MAAM,CAAC;IAC5B,gBAAgB;AAClB;AAUO,MAAM,SAAS,CAAC,SAAS;IAC9B,MAAM,SAAS,IAAI;IACnB,KAAK,MAAM,SAAS,QAAQ,iBAAiB,GAAI;QAC/C,OAAO,GAAG,CAAC,GAAG,MAAM,GAAG,EAAE,EAAE;IAC7B;IAEA;;;;;GAKC,GACD,MAAM,OAAO,oLAAG,CAAC,MAAM,CAAC;QACtB,OAAO;YAAC,QAAQ,IAAI;SAAC;QACrB;IACF;IAEA,OAAO;QACL,SAAS;YAAE,GAAG,OAAO;QAAC;QACtB;IACF;AACF;AASO,MAAM,SAAS,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE;IAC5C,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,GAAG,oLAAG,CAAC,MAAM,CAA4B;IAChE,MAAM,UAAU,gMAAO,CAAC,IAAI,CAAC;QAAE,MAAM,KAAK,CAAC,EAAE,CAAC,GAAG;QAAE,OAAO;IAAO;IACjE,OAA+B;AACjC","ignoreList":[0]}},
    {"offset": {"line": 263, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/transport/src/codec.js"],"sourcesContent":["import * as API from '@ucanto/interface'\n\n/**\n * @typedef {`${Lowercase<string>}/${Lowercase<string>}`|`${Lowercase<string>}/${Lowercase<string>}+${Lowercase<string>}`} ContentType\n * @typedef {`${Lowercase<string>}/${Lowercase<string>}`|`${Lowercase<string>}/${Lowercase<string>};q=${number}.${number}`} MediaType\n * @param {object} source\n * @param {Record<ContentType, API.Transport.RequestDecoder>} source.decoders\n * @param {Record<MediaType, API.Transport.ResponseEncoder>} source.encoders\n * @returns {API.InboundCodec}\n */\nexport const inbound = source => new Inbound(source)\n\n/**\n * @implements {API.InboundCodec}\n */\nclass Inbound {\n  /**\n   * @param {API.HTTPRequest} request\n   * @returns {API.Result<API.InboundAcceptCodec, API.HTTPError>} transport\n   */\n  accept({ headers }) {\n    const contentType = headers['content-type'] || headers['Content-Type']\n    const decoder = this.decoders[contentType]\n    if (!decoder) {\n      return {\n        error: {\n          status: 415,\n          message: `The server cannot process the request because the payload format is not supported. Please check the content-type header and try again with a supported media type.`,\n          headers: {\n            accept: Object.keys(this.decoders).join(', '),\n          },\n        },\n      }\n    }\n\n    const accept = parseAcceptHeader(headers.accept || headers.Accept || '*/*')\n    for (const { category, type } of accept) {\n      for (const encoder of this.encoders) {\n        const select =\n          (category === '*' || category === encoder.category) &&\n          (type === '*' || type === encoder.type)\n\n        if (select) {\n          return { ok: { ...encoder, decoder } }\n        }\n      }\n    }\n\n    return {\n      error: {\n        status: 406,\n        message: `The requested resource cannot be served in the requested content type. Please specify a supported content type using the Accept header.`,\n        headers: {\n          accept: formatAcceptHeader(Object.values(this.encoders)),\n        },\n      },\n    }\n  }\n\n  /**\n   * @param {object} source\n   * @param {Record<string, API.Transport.RequestDecoder>} source.decoders\n   * @param {Record<string, API.Transport.ResponseEncoder>} source.encoders\n   */\n  constructor({ decoders = {}, encoders = {} }) {\n    this.decoders = decoders\n\n    if (Object.keys(decoders).length === 0) {\n      throw new Error('At least one decoder MUST be provided')\n    }\n\n    // We sort the encoders by preference, so that we can pick the most\n    // preferred one when client accepts multiple content types.\n    this.encoders = Object.entries(encoders)\n      .map(([mediaType, encoder]) => {\n        return { ...parseMediaType(mediaType), encoder }\n      })\n      .sort((a, b) => b.preference - a.preference)\n\n    if (this.encoders.length === 0) {\n      throw new Error('At least one encoder MUST be provided')\n    }\n  }\n}\n\n/**\n * @param {object} source\n * @param {Record<MediaType, API.Transport.RequestEncoder>} source.encoders\n * @param {Record<ContentType, API.Transport.ResponseDecoder>} source.decoders\n * @returns {API.OutboundCodec}\n */\nexport const outbound = source => new Outbound(source)\n\n/**\n * @implements {API.OutboundCodec}\n */\nclass Outbound {\n  /**\n   * @param {object} source\n   * @param {Record<string, API.Transport.RequestEncoder>} source.encoders\n   * @param {Record<string, API.Transport.ResponseDecoder>} source.decoders\n   */\n  constructor({ decoders = {}, encoders = {} }) {\n    this.decoders = decoders\n\n    if (Object.keys(decoders).length === 0) {\n      throw new Error('At least one decoder MUST be provided')\n    }\n\n    // We sort the encoders by preference, so that we can pick the most\n    // preferred one when client accepts multiple content types.\n    this.encoders = Object.entries(encoders)\n      .map(([mediaType, encoder]) => {\n        return { ...parseMediaType(mediaType), encoder }\n      })\n      .sort((a, b) => b.preference - a.preference)\n\n    this.acceptType = formatAcceptHeader(this.encoders)\n\n    if (this.encoders.length === 0) {\n      throw new Error('At least one encoder MUST be provided')\n    }\n\n    this.encoder = this.encoders[0].encoder\n  }\n\n  /**\n   * @template {API.AgentMessage} Message\n   * @param {Message} message\n   */\n  encode(message) {\n    return this.encoder.encode(message, {\n      accept: this.acceptType,\n    })\n  }\n  /**\n   * @template {API.AgentMessage} Message\n   * @param {API.HTTPResponse<Message>} response\n   * @returns {API.Await<Message>}\n   */\n  decode(response) {\n    const { headers } = response\n    const contentType = headers['content-type'] || headers['Content-Type']\n    const decoder = this.decoders[contentType] || this.decoders['*/*']\n    switch (response.status) {\n      case 415:\n      case 406:\n        throw Object.assign(\n          new RangeError(new TextDecoder().decode(response.body)),\n          {\n            status: response.status,\n            headers: response.headers,\n          }\n        )\n    }\n    if (!decoder) {\n      throw Object.assign(\n        TypeError(\n          `Can not decode response with content-type '${contentType}' because no matching transport decoder is configured.`\n        ),\n        {\n          error: true,\n        }\n      )\n    }\n\n    return decoder.decode(response)\n  }\n}\n\n/**\n * @typedef {{ category: string, type: string, preference: number }} Media\n * @param {string} source\n * @returns {Media}\n */\nexport const parseMediaType = source => {\n  const [mediaType = '*/*', mediaRange = ''] = source.trim().split(';')\n  const [category = '*', type = '*'] = mediaType.split('/')\n  const params = new URLSearchParams(mediaRange)\n  const preference = parseFloat(params.get('q') || '0')\n  return {\n    category,\n    type,\n    /* c8 ignore next */\n    preference: isNaN(preference) ? 0 : preference,\n  }\n}\n\n/**\n * @param {Media} media\n */\nexport const formatMediaType = ({ category, type, preference }) =>\n  /** @type {MediaType}  */ (\n    `${category}/${type}${preference ? `;q=${preference}` : ''}`\n  )\n\n/**\n * @param {string} source\n */\nexport const parseAcceptHeader = source =>\n  source\n    .split(',')\n    .map(parseMediaType)\n    .sort((a, b) => b.preference - a.preference)\n\n/**\n * @param {Media[]} source\n */\nexport const formatAcceptHeader = source =>\n  source.map(formatMediaType).join(', ')\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 423, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/transport/src/car.js"],"sourcesContent":["import { CAR } from '@ucanto/core'\nimport * as request from './car/request.js'\nimport * as response from './car/response.js'\nimport * as Codec from './codec.js'\n\nexport { CAR as codec, request, response }\n\nexport const contentType = CAR.contentType\n\nexport const inbound = Codec.inbound({\n  decoders: {\n    [request.contentType]: request,\n  },\n  encoders: {\n    [response.contentType]: response,\n  },\n})\n\nexport const outbound = Codec.outbound({\n  encoders: {\n    [request.contentType]: request,\n  },\n  decoders: {\n    [response.contentType]: response,\n  },\n})\n"],"names":[],"mappings":";;;;;;;;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;AAIO,MAAM,cAAc,oLAAG,CAAC,WAAW;AAEnC,MAAM,UAAU,gKAAa,CAAC;IACnC,UAAU;QACR,CAAC,+JAAQ,WAAW,CAAC,EAAE;IACzB;IACA,UAAU;QACR,CAAC,gKAAS,WAAW,CAAC,EAAE;IAC1B;AACF;AAEO,MAAM,WAAW,iKAAc,CAAC;IACrC,UAAU;QACR,CAAC,+JAAQ,WAAW,CAAC,EAAE;IACzB;IACA,UAAU;QACR,CAAC,gKAAS,WAAW,CAAC,EAAE;IAC1B;AACF","ignoreList":[0]}},
    {"offset": {"line": 464, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/transport/src/http.js"],"sourcesContent":["import * as API from '@ucanto/interface'\n\n/**\n * @typedef {{\n * ok: boolean\n * arrayBuffer():API.Await<ArrayBuffer>\n * headers: {\n *  entries?: () => Iterable<[string, string]>\n * } | Headers\n * status?: number\n * statusText?: string\n * url?: string\n * }} FetchResponse\n * @typedef {(url:string, init:API.HTTPRequest) => API.Await<FetchResponse>} Fetcher\n */\n/**\n * @template S\n * @param {object} options\n * @param {URL} options.url\n * @param {(url:string, init:API.HTTPRequest) => API.Await<FetchResponse>} [options.fetch]\n * @param {string} [options.method]\n * @param {Record<string, string>} [options.headers]\n * @returns {API.Channel<S>}\n */\nexport const open = ({ url, method = 'POST', fetch, headers }) => {\n  /* c8 ignore next 9 */\n  if (!fetch) {\n    if (typeof globalThis.fetch !== 'undefined') {\n      fetch = globalThis.fetch.bind(globalThis)\n    } else {\n      throw new TypeError(\n        `ucanto HTTP transport got undefined \\`fetch\\`. Try passing in a \\`fetch\\` implementation explicitly.`\n      )\n    }\n  }\n  return new Channel({ url, method, fetch, headers })\n}\n\n/**\n * @template {Record<string, any>} S\n * @implements {API.Channel<S>}\n */\nclass Channel {\n  /**\n   * @param {object} options\n   * @param {URL} options.url\n   * @param {Fetcher} options.fetch\n   * @param {string} [options.method]\n   * @param {Record<string, string>} [options.headers]\n   */\n  constructor({ url, fetch, method, headers }) {\n    this.fetch = fetch\n    this.method = method\n    this.url = url\n    this.headers = headers\n  }\n  /**\n   * @template {API.Tuple<API.ServiceInvocation<API.Capability, S>>} I\n   * @param {API.HTTPRequest<API.AgentMessage<{ In: API.InferInvocations<I>, Out: API.Tuple<API.Receipt> }>>} request\n   * @returns {Promise<API.HTTPResponse<API.AgentMessage<{ Out: API.InferReceipts<I, S>, In: API.Tuple<API.Invocation> }>>>}\n   */\n  async request({ headers, body }) {\n    const response = await this.fetch(this.url.href, {\n      headers: { ...this.headers, ...headers },\n      body,\n      method: this.method,\n    })\n\n    const buffer = response.ok\n      ? await response.arrayBuffer()\n      : HTTPError.throw(`HTTP Request failed. ${this.method} ${this.url.href} â†’ ${response.status}`, response)\n\n    return {\n      headers: response.headers.entries\n        ? Object.fromEntries(response.headers.entries())\n        : /* c8 ignore next */\n          {},\n      body: new Uint8Array(buffer),\n    }\n  }\n}\n\n/**\n * @typedef {{\n * status?: number\n * statusText?: string\n * url?: string\n * }} Options\n */\nclass HTTPError extends Error {\n  /**\n   * @param {string} message\n   * @param {Options} options\n   * @returns {never}\n   */\n  static throw(message, options) {\n    throw new this(message, options)\n  }\n  /**\n   * @param {string} message\n   * @param {Options} options\n   */\n  constructor(message, { url, status = 500, statusText = 'Server error' }) {\n    super(message)\n    /** @type {'HTTPError'} */\n    this.name = 'HTTPError'\n    this.url = url\n    this.status = status\n    this.statusText = statusText\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;;AAwBO,MAAM,OAAO,CAAC,EAAE,GAAG,EAAE,SAAS,MAAM,EAAE,KAAK,EAAE,OAAO,EAAE;IAC3D,oBAAoB,GACpB,IAAI,CAAC,OAAO;QACV,IAAI,OAAO,WAAW,KAAK,KAAK,aAAa;YAC3C,QAAQ,WAAW,KAAK,CAAC,IAAI,CAAC;QAChC,OAAO;YACL,MAAM,IAAI,UACR,CAAC,oGAAoG,CAAC;QAE1G;IACF;IACA,OAAO,IAAI,QAAQ;QAAE;QAAK;QAAQ;QAAO;IAAQ;AACnD;AAEA;;;CAGC,GACD,MAAM;IACJ;;;;;;GAMC,GACD,YAAY,EAAE,GAAG,EAAE,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,CAAE;QAC3C,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,GAAG,GAAG;QACX,IAAI,CAAC,OAAO,GAAG;IACjB;IACA;;;;GAIC,GACD,MAAM,QAAQ,EAAE,OAAO,EAAE,IAAI,EAAE,EAAE;QAC/B,MAAM,WAAW,MAAM,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE;YAC/C,SAAS;gBAAE,GAAG,IAAI,CAAC,OAAO;gBAAE,GAAG,OAAO;YAAC;YACvC;YACA,QAAQ,IAAI,CAAC,MAAM;QACrB;QAEA,MAAM,SAAS,SAAS,EAAE,GACtB,MAAM,SAAS,WAAW,KAC1B,UAAU,KAAK,CAAC,CAAC,qBAAqB,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,EAAE,SAAS,MAAM,EAAE,EAAE;QAEjG,OAAO;YACL,SAAS,SAAS,OAAO,CAAC,OAAO,GAC7B,OAAO,WAAW,CAAC,SAAS,OAAO,CAAC,OAAO,MAC3C,kBAAkB,GAClB,CAAC;YACL,MAAM,IAAI,WAAW;QACvB;IACF;AACF;AAEA;;;;;;CAMC,GACD,MAAM,kBAAkB;IACtB;;;;GAIC,GACD,OAAO,MAAM,OAAO,EAAE,OAAO,EAAE;QAC7B,MAAM,IAAI,IAAI,CAAC,SAAS;IAC1B;IACA;;;GAGC,GACD,YAAY,OAAO,EAAE,EAAE,GAAG,EAAE,SAAS,GAAG,EAAE,aAAa,cAAc,EAAE,CAAE;QACvE,KAAK,CAAC;QACN,wBAAwB,GACxB,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,GAAG,GAAG;QACX,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,UAAU,GAAG;IACpB;AACF","ignoreList":[0]}},
    {"offset": {"line": 550, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/transport/src/utf8.js"],"sourcesContent":["export const encoder = new TextEncoder()\nexport const decoder = new TextDecoder()\n\n/**\n * @param {string} text\n * @returns {Uint8Array}\n */\nexport const encode = text => encoder.encode(text)\n\n/**\n *\n * @param {Uint8Array} bytes\n * @returns {string}\n */\nexport const decode = bytes => decoder.decode(bytes)\n"],"names":[],"mappings":";;;;;;;;;;AAAO,MAAM,UAAU,IAAI;AACpB,MAAM,UAAU,IAAI;AAMpB,MAAM,SAAS,CAAA,OAAQ,QAAQ,MAAM,CAAC;AAOtC,MAAM,SAAS,CAAA,QAAS,QAAQ,MAAM,CAAC","ignoreList":[0]}},
    {"offset": {"line": 586, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/transport/src/legacy/response.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport * as CBOR from '@ucanto/core/cbor'\nexport const contentType = 'application/cbor'\n\nconst HEADERS = Object.freeze({\n  'content-type': contentType,\n})\n\n/**\n * Encodes `AgentMessage` into a legacy CBOR representation.\n *\n * @template {API.AgentMessage} Message\n * @param {Message} message\n * @param {API.EncodeOptions} [options]\n * @returns {API.HTTPResponse<Message>}\n */\nexport const encode = (message, options) => {\n  const legacyResults = []\n  for (const receipt of message.receipts.values()) {\n    const result = receipt.out\n    if (result.ok) {\n      legacyResults.push(result.ok)\n    } else {\n      legacyResults.push({\n        ...result.error,\n        error: true,\n      })\n    }\n  }\n\n  /** @type {Uint8Array} */\n  const body = CBOR.encode(legacyResults)\n\n  return /** @type {API.HTTPResponse<Message>} */ ({\n    headers: HEADERS,\n    body,\n  })\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AACO,MAAM,cAAc;AAE3B,MAAM,UAAU,OAAO,MAAM,CAAC;IAC5B,gBAAgB;AAClB;AAUO,MAAM,SAAS,CAAC,SAAS;IAC9B,MAAM,gBAAgB,EAAE;IACxB,KAAK,MAAM,WAAW,QAAQ,QAAQ,CAAC,MAAM,GAAI;QAC/C,MAAM,SAAS,QAAQ,GAAG;QAC1B,IAAI,OAAO,EAAE,EAAE;YACb,cAAc,IAAI,CAAC,OAAO,EAAE;QAC9B,OAAO;YACL,cAAc,IAAI,CAAC;gBACjB,GAAG,OAAO,KAAK;gBACf,OAAO;YACT;QACF;IACF;IAEA,uBAAuB,GACvB,MAAM,OAAO,yKAAW,CAAC;IAEzB,OAAiD;QAC/C,SAAS;QACT;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 623, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/transport/src/legacy/request.js"],"sourcesContent":["import * as CAR from '@ucanto/core/car'\nimport * as API from '@ucanto/interface'\nimport { Invocation, Message } from '@ucanto/core'\n\nexport const contentType = 'application/car'\n\n/**\n * @template {API.AgentMessage} Message\n * @param {API.HTTPRequest<Message>} request\n */\nexport const decode = async ({ body }) => {\n  const { roots, blocks } = CAR.decode(/** @type {Uint8Array} */ (body))\n  /** @type {API.IssuedInvocation[]} */\n  const run = []\n  for (const { cid } of roots) {\n    // We don't have a way to know if the root matches a ucan link.\n    const invocation = Invocation.view({\n      root: /** @type {API.Link} */ (cid),\n      blocks,\n    })\n    run.push(invocation)\n  }\n\n  const message = await Message.build({\n    invocations: /** @type {API.Tuple<API.IssuedInvocation>} */ (run),\n  })\n\n  return /** @type {Message} */ (message)\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AAAA;AAAA;;;;AAEO,MAAM,cAAc;AAMpB,MAAM,SAAS,OAAO,EAAE,IAAI,EAAE;IACnC,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,GAAG,wJAAU,CAA4B;IAChE,mCAAmC,GACnC,MAAM,MAAM,EAAE;IACd,KAAK,MAAM,EAAE,GAAG,EAAE,IAAI,MAAO;QAC3B,+DAA+D;QAC/D,MAAM,aAAa,yMAAU,CAAC,IAAI,CAAC;YACjC,MAA+B;YAC/B;QACF;QACA,IAAI,IAAI,CAAC;IACX;IAEA,MAAM,UAAU,MAAM,gMAAO,CAAC,KAAK,CAAC;QAClC,aAA6D;IAC/D;IAEA,OAA+B;AACjC","ignoreList":[0]}},
    {"offset": {"line": 658, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/transport/src/legacy.js"],"sourcesContent":["import * as Codec from './codec.js'\nimport * as CAR from './car.js'\nimport * as response from './legacy/response.js'\nimport * as request from './legacy/request.js'\n\nexport const { contentType } = request\nexport { request, response }\n\n/**\n * This is an inbound codec designed to support legacy clients and encode\n * responses in a legacy (CBOR) format.\n */\nexport const inbound = Codec.inbound({\n  decoders: {\n    [contentType]: request,\n    [CAR.contentType]: CAR.request,\n  },\n  encoders: {\n    // Here we configure encoders such that if accept header is `*/*` (which is\n    // the default if omitted) we will encode the response in CBOR. If\n    // `application/vnd.ipld.car` is set we will encode the response in current\n    // format.\n    // Here we exploit the fact that legacy clients do not send an accept header\n    // and therefore will get response in legacy format. New clients on the other\n    // hand will send `application/vnd.ipld.car` and consequently get response\n    // in current format.\n    '*/*;q=0.1': response,\n    [CAR.contentType]: CAR.response,\n  },\n})\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AAAA;AAAA;AACA;AACA;;;;;AAEO,MAAM,EAAE,WAAW,EAAE,GAAG;;AAOxB,MAAM,UAAU,gKAAa,CAAC;IACnC,UAAU;QACR,CAAC,YAAY,EAAE;QACf,CAAC,kLAAe,CAAC,EAAE,4MAAW;IAChC;IACA,UAAU;QACR,2EAA2E;QAC3E,kEAAkE;QAClE,2EAA2E;QAC3E,UAAU;QACV,4EAA4E;QAC5E,6EAA6E;QAC7E,0EAA0E;QAC1E,qBAAqB;QACrB,aAAa;QACb,CAAC,kLAAe,CAAC,EAAE,+MAAY;IACjC;AACF","ignoreList":[0]}},
    {"offset": {"line": 698, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/transport/src/lib.js"],"sourcesContent":["// top level exports\nexport * as CAR from './car.js'\nexport * as HTTP from './http.js'\nexport * as UTF8 from './utf8.js'\nexport * as Legacy from './legacy.js'\nexport * as Codec from './codec.js'\nexport * from './codec.js'\n"],"names":[],"mappings":"AAAA,oBAAoB;;AACpB;AACA;AACA;AACA;AACA","ignoreList":[0]}},
    {"offset": {"line": 755, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 760, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/principal/src/verifier.js"],"sourcesContent":["import * as API from '@ucanto/interface'\n\n/**\n * @param {API.DID} did\n * @param {API.PrincipalParser[]} parsers\n * @return {API.Verifier}\n */\nconst parseWith = (did, parsers) => {\n  if (did.startsWith('did:')) {\n    for (const parser of parsers) {\n      try {\n        return parser.parse(did)\n      } catch (_) {}\n    }\n    throw new Error(`Unsupported did ${did}`)\n  } else {\n    throw new Error(`Expected did instead got ${did}`)\n  }\n}\n\n/**\n * @param {API.PrincipalParser} left\n * @param {API.PrincipalParser} right\n * @returns {API.ComposedDIDParser}\n */\nexport const or = (left, right) => new Parser([left, right])\n\n/**\n * @implements {API.ComposedDIDParser}\n */\nclass Parser {\n  /**\n   * @param {API.PrincipalParser[]} variants\n   */\n  constructor(variants) {\n    this.variants = variants\n  }\n\n  /**\n   * @param {API.DID} did\n   */\n  parse(did) {\n    return parseWith(did, this.variants)\n  }\n\n  /**\n   * @param {API.PrincipalParser} parser\n   */\n  or(parser) {\n    return new Parser([...this.variants, parser])\n  }\n}\n\n/**\n * @template {API.DID} ID\n * @template {API.MulticodecCode} SigAlg\n * @param {API.VerifierKey<SigAlg>} key\n * @param {ID} id\n * @returns {API.Verifier<ID, SigAlg>}\n */\nexport const withDID = (key, id) => new VerifierWithDID(id, key)\n\n/**\n * @template {API.DID} ID\n * @template {API.MulticodecCode} SigAlg\n * @implements {API.Verifier<ID, SigAlg>}\n */\nclass VerifierWithDID {\n  /**\n   * @param {ID} id\n   * @param {API.VerifierKey<SigAlg>} key\n   */\n  constructor(id, key) {\n    this.id = id\n    this.key = key\n  }\n  did() {\n    return this.id\n  }\n\n  toDIDKey() {\n    return this.key.toDIDKey()\n  }\n\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @param {API.Signature<T, SigAlg>} signature\n   * @returns {API.Await<boolean>}\n   */\n  verify(payload, signature) {\n    return this.key.verify(payload, signature)\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   */\n  withDID(id) {\n    return withDID(this.key, id)\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;;AAEA;;;;CAIC,GACD,MAAM,YAAY,CAAC,KAAK;IACtB,IAAI,IAAI,UAAU,CAAC,SAAS;QAC1B,KAAK,MAAM,UAAU,QAAS;YAC5B,IAAI;gBACF,OAAO,OAAO,KAAK,CAAC;YACtB,EAAE,OAAO,GAAG,CAAC;QACf;QACA,MAAM,IAAI,MAAM,CAAC,gBAAgB,EAAE,KAAK;IAC1C,OAAO;QACL,MAAM,IAAI,MAAM,CAAC,yBAAyB,EAAE,KAAK;IACnD;AACF;AAOO,MAAM,KAAK,CAAC,MAAM,QAAU,IAAI,OAAO;QAAC;QAAM;KAAM;AAE3D;;CAEC,GACD,MAAM;IACJ;;GAEC,GACD,YAAY,QAAQ,CAAE;QACpB,IAAI,CAAC,QAAQ,GAAG;IAClB;IAEA;;GAEC,GACD,MAAM,GAAG,EAAE;QACT,OAAO,UAAU,KAAK,IAAI,CAAC,QAAQ;IACrC;IAEA;;GAEC,GACD,GAAG,MAAM,EAAE;QACT,OAAO,IAAI,OAAO;eAAI,IAAI,CAAC,QAAQ;YAAE;SAAO;IAC9C;AACF;AASO,MAAM,UAAU,CAAC,KAAK,KAAO,IAAI,gBAAgB,IAAI;AAE5D;;;;CAIC,GACD,MAAM;IACJ;;;GAGC,GACD,YAAY,EAAE,EAAE,GAAG,CAAE;QACnB,IAAI,CAAC,EAAE,GAAG;QACV,IAAI,CAAC,GAAG,GAAG;IACb;IACA,MAAM;QACJ,OAAO,IAAI,CAAC,EAAE;IAChB;IAEA,WAAW;QACT,OAAO,IAAI,CAAC,GAAG,CAAC,QAAQ;IAC1B;IAEA;;;;;GAKC,GACD,OAAO,OAAO,EAAE,SAAS,EAAE;QACzB,OAAO,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,SAAS;IAClC;IAEA;;;GAGC,GACD,QAAQ,EAAE,EAAE;QACV,OAAO,QAAQ,IAAI,CAAC,GAAG,EAAE;IAC3B;AACF","ignoreList":[0]}},
    {"offset": {"line": 848, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/principal/src/ed25519/verifier.js"],"sourcesContent":["import * as DID from '@ipld/dag-ucan/did'\nimport * as ED25519 from '@noble/ed25519'\nimport { varint } from 'multiformats'\nimport * as API from './type.js'\nimport * as Signature from '@ipld/dag-ucan/signature'\nimport { base58btc } from 'multiformats/bases/base58'\nimport * as Verifier from '../verifier.js'\n\n/** @type {API.EdVerifier['code']} */\nexport const code = 0xed\nexport const name = 'Ed25519'\n\n/** @type {API.SigAlg} */\nexport const signatureCode = Signature.EdDSA\nexport const signatureAlgorithm = 'EdDSA'\nconst PUBLIC_TAG_SIZE = varint.encodingLength(code)\nconst SIZE = 32 + PUBLIC_TAG_SIZE\n\n/**\n * @typedef {API.EdVerifier} EdVerifier\n */\n\n/**\n * Parses `did:key:` string as a VerifyingPrincipal.\n *\n * @param {API.DID|string} did\n * @returns {API.Verifier<API.DID, typeof signatureCode>}\n */\nexport const parse = did => decode(DID.parse(did))\n\n/**\n * Takes ed25519 public key tagged with `0xed` multiformat code and creates a\n * corresponding `Principal` that can be used to verify signatures.\n *\n * @param {Uint8Array} bytes\n * @returns {API.EdVerifier}\n */\nexport const decode = bytes => {\n  const [algorithm] = varint.decode(bytes)\n  if (algorithm !== code) {\n    throw new RangeError(\n      `Unsupported key algorithm with multicode 0x${code.toString(16)}`\n    )\n  } else if (bytes.byteLength !== SIZE) {\n    throw new RangeError(\n      `Expected Uint8Array with byteLength ${SIZE}, instead got Uint8Array with byteLength ${bytes.byteLength}`\n    )\n  } else {\n    return new Ed25519Verifier(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n  }\n}\n\n/**\n * Formats given Principal into `did:key:` format.\n *\n * @param {API.Principal<API.DID>} principal\n */\nexport const format = principal => DID.format(principal)\n\n/**\n * Encodes given Principal by tagging it's ed25519 public key with `0xed`\n * multiformat code.\n *\n * @param {API.Principal<API.DID<\"key\">>} principal\n */\nexport const encode = principal => DID.encode(principal)\n\n/**\n * @implements {API.EdVerifier}\n */\nclass Ed25519Verifier extends Uint8Array {\n  /** @type {typeof code} */\n  get code() {\n    return code\n  }\n  /** @type {typeof signatureCode} */\n  get signatureCode() {\n    return signatureCode\n  }\n  /** @type {typeof signatureAlgorithm} */\n  get signatureAlgorithm() {\n    return signatureAlgorithm\n  }\n  /**\n   * Raw public key without a multiformat code.\n   *\n   * @readonly\n   */\n  get publicKey() {\n    const key = new Uint8Array(this.buffer, this.byteOffset + PUBLIC_TAG_SIZE)\n    Object.defineProperties(this, {\n      publicKey: {\n        value: key,\n      },\n    })\n    return key\n  }\n  /**\n   * DID of the Principal in `did:key` format.\n   * @returns {API.DID<\"key\">}\n   */\n  did() {\n    return `did:key:${base58btc.encode(this)}`\n  }\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @param {API.Signature<T, Signature.EdDSA>} signature\n   * @returns {API.Await<boolean>}\n   */\n  verify(payload, signature) {\n    return (\n      signature.code === signatureCode &&\n      ED25519.verify(signature.raw, payload, this.publicKey)\n    )\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   * @returns {API.Verifier<ID, typeof signatureCode>}\n   */\n  withDID(id) {\n    return Verifier.withDID(this, id)\n  }\n\n  toDIDKey() {\n    return this.did()\n  }\n}\n\n/**\n * @param {API.PrincipalParser} other\n */\nexport const or = other => Verifier.or({ parse }, other)\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;AAGO,MAAM,OAAO;AACb,MAAM,OAAO;AAGb,MAAM,gBAAgB,kKAAe;AACrC,MAAM,qBAAqB;AAClC,MAAM,kBAAkB,0OAAM,CAAC,cAAc,CAAC;AAC9C,MAAM,OAAO,KAAK;AAYX,MAAM,QAAQ,CAAA,MAAO,OAAO,4JAAS,CAAC;AAStC,MAAM,SAAS,CAAA;IACpB,MAAM,CAAC,UAAU,GAAG,0OAAM,CAAC,MAAM,CAAC;IAClC,IAAI,cAAc,MAAM;QACtB,MAAM,IAAI,WACR,CAAC,2CAA2C,EAAE,KAAK,QAAQ,CAAC,KAAK;IAErE,OAAO,IAAI,MAAM,UAAU,KAAK,MAAM;QACpC,MAAM,IAAI,WACR,CAAC,oCAAoC,EAAE,KAAK,yCAAyC,EAAE,MAAM,UAAU,EAAE;IAE7G,OAAO;QACL,OAAO,IAAI,gBAAgB,MAAM,MAAM,EAAE,MAAM,UAAU,EAAE,MAAM,UAAU;IAC7E;AACF;AAOO,MAAM,SAAS,CAAA,YAAa,6JAAU,CAAC;AAQvC,MAAM,SAAS,CAAA,YAAa,6JAAU,CAAC;AAE9C;;CAEC,GACD,MAAM,wBAAwB;IAC5B,wBAAwB,GACxB,IAAI,OAAO;QACT,OAAO;IACT;IACA,iCAAiC,GACjC,IAAI,gBAAgB;QAClB,OAAO;IACT;IACA,sCAAsC,GACtC,IAAI,qBAAqB;QACvB,OAAO;IACT;IACA;;;;GAIC,GACD,IAAI,YAAY;QACd,MAAM,MAAM,IAAI,WAAW,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,UAAU,GAAG;QAC1D,OAAO,gBAAgB,CAAC,IAAI,EAAE;YAC5B,WAAW;gBACT,OAAO;YACT;QACF;QACA,OAAO;IACT;IACA;;;GAGC,GACD,MAAM;QACJ,OAAO,CAAC,QAAQ,EAAE,oNAAS,CAAC,MAAM,CAAC,IAAI,GAAG;IAC5C;IACA;;;;;GAKC,GACD,OAAO,OAAO,EAAE,SAAS,EAAE;QACzB,OACE,UAAU,IAAI,KAAK,iBACnB,mKAAc,CAAC,UAAU,GAAG,EAAE,SAAS,IAAI,CAAC,SAAS;IAEzD;IAEA;;;;GAIC,GACD,QAAQ,EAAE,EAAE;QACV,OAAO,mKAAgB,CAAC,IAAI,EAAE;IAChC;IAEA,WAAW;QACT,OAAO,IAAI,CAAC,GAAG;IACjB;AACF;AAKO,MAAM,KAAK,CAAA,QAAS,8JAAW,CAAC;QAAE;IAAM,GAAG","ignoreList":[0]}},
    {"offset": {"line": 959, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/principal/src/signer.js"],"sourcesContent":["import * as API from '@ucanto/interface'\n\n/**\n * @template {API.SignerImporter} L\n * @template {API.SignerImporter} R\n * @param {L} left\n * @param {R} right\n * @returns {API.CompositeImporter<[L, R]>}\n */\nexport const or = (left, right) => new Importer([left, right])\n\n/**\n * @template {[API.SignerImporter, ...API.SignerImporter[]]} Importers\n * @implements {API.CompositeImporter<Importers>}\n */\nclass Importer {\n  /**\n   * @param {Importers} variants\n   */\n  constructor(variants) {\n    this.variants = variants\n    this.from = create(variants)\n  }\n\n  /**\n   * @template {API.SignerImporter} Other\n   * @param {Other} other\n   * @returns {API.CompositeImporter<[Other, ...Importers]>}\n   */\n  or(other) {\n    return new Importer([other, ...this.variants])\n  }\n}\n\n/**\n * @template {[API.SignerImporter, ...API.SignerImporter[]]} Importers\n * @param {Importers} importers\n */\nconst create = importers => {\n  /**\n   * @template {API.DID} ID - DID that can be imported, which may be a type union.\n   * @template {API.SigAlg} Alg - Multicodec code corresponding to signature algorithm.\n   * @param {API.SignerArchive<ID, Alg>} archive\n   * @returns {API.Signer<ID, Alg>}\n   */\n  const from = archive => {\n    if (archive.id.startsWith('did:key:')) {\n      return /** @type {API.Signer<ID, Alg>} */ (importWith(archive, importers))\n    } else {\n      for (const [name, key] of Object.entries(archive.keys)) {\n        const id = /** @type {API.DIDKey} */ (name)\n        const signer = /** @type {API.Signer<API.DIDKey, Alg>} */ (\n          importWith(\n            {\n              id,\n              keys: { [id]: key },\n            },\n            importers\n          )\n        )\n\n        return signer.withDID(archive.id)\n      }\n\n      throw new Error(`Archive ${archive.id} contains no keys`)\n    }\n  }\n\n  return /** @type {API.Intersection<Importers[number]['from']>} */ (from)\n}\n\n/**\n * @param {API.SignerArchive} archive\n * @param {API.SignerImporter[]} importers\n * @returns {API.Signer}\n */\nconst importWith = (archive, importers) => {\n  for (const importer of importers) {\n    try {\n      return importer.from(archive)\n    } catch (_) {}\n  }\n  throw new Error(`Unsupported signer`)\n}\n/**\n * @template {number} Code\n * @template {API.DID} ID\n * @param {API.Signer<API.DID<'key'>, Code>} signer\n * @param {ID} id\n * @returns {API.Signer<ID, Code>}\n */\nexport const withDID = ({ signer, verifier }, id) =>\n  new SignerWithDID(signer, verifier.withDID(id))\n\n/**\n * @template {API.DID} ID\n * @template {number} Code\n * @implements {API.Signer<ID, Code>}\n */\nclass SignerWithDID {\n  /**\n   * @param {API.Signer<API.DID<'key'>, Code>} key\n   * @param {API.Verifier<ID, Code>} verifier\n   */\n  constructor(key, verifier) {\n    this.key = key\n    this.verifier = verifier\n  }\n  /** @type {API.Signer<ID, Code>} */\n  get signer() {\n    return this\n  }\n\n  get signatureAlgorithm() {\n    return this.key.signatureAlgorithm\n  }\n  get signatureCode() {\n    return this.key.signatureCode\n  }\n\n  /**\n   * @returns {ID}\n   */\n  did() {\n    return this.verifier.did()\n  }\n\n  toDIDKey() {\n    return this.verifier.toDIDKey()\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   */\n  withDID(id) {\n    return withDID(this.key, id)\n  }\n\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   */\n  sign(payload) {\n    return this.key.sign(payload)\n  }\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @param {API.Signature<T, Code>} signature\n   */\n  verify(payload, signature) {\n    return this.verifier.verify(payload, signature)\n  }\n\n  toArchive() {\n    const { keys } = this.key.toArchive()\n    return {\n      id: this.did(),\n      keys,\n    }\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;;AASO,MAAM,KAAK,CAAC,MAAM,QAAU,IAAI,SAAS;QAAC;QAAM;KAAM;AAE7D;;;CAGC,GACD,MAAM;IACJ;;GAEC,GACD,YAAY,QAAQ,CAAE;QACpB,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,IAAI,GAAG,OAAO;IACrB;IAEA;;;;GAIC,GACD,GAAG,KAAK,EAAE;QACR,OAAO,IAAI,SAAS;YAAC;eAAU,IAAI,CAAC,QAAQ;SAAC;IAC/C;AACF;AAEA;;;CAGC,GACD,MAAM,SAAS,CAAA;IACb;;;;;GAKC,GACD,MAAM,OAAO,CAAA;QACX,IAAI,QAAQ,EAAE,CAAC,UAAU,CAAC,aAAa;YACrC,OAA2C,WAAW,SAAS;QACjE,OAAO;YACL,KAAK,MAAM,CAAC,MAAM,IAAI,IAAI,OAAO,OAAO,CAAC,QAAQ,IAAI,EAAG;gBACtD,MAAM,KAAgC;gBACtC,MAAM,SACJ,WACE;oBACE;oBACA,MAAM;wBAAE,CAAC,GAAG,EAAE;oBAAI;gBACpB,GACA;gBAIJ,OAAO,OAAO,OAAO,CAAC,QAAQ,EAAE;YAClC;YAEA,MAAM,IAAI,MAAM,CAAC,QAAQ,EAAE,QAAQ,EAAE,CAAC,iBAAiB,CAAC;QAC1D;IACF;IAEA,OAAmE;AACrE;AAEA;;;;CAIC,GACD,MAAM,aAAa,CAAC,SAAS;IAC3B,KAAK,MAAM,YAAY,UAAW;QAChC,IAAI;YACF,OAAO,SAAS,IAAI,CAAC;QACvB,EAAE,OAAO,GAAG,CAAC;IACf;IACA,MAAM,IAAI,MAAM,CAAC,kBAAkB,CAAC;AACtC;AAQO,MAAM,UAAU,CAAC,EAAE,MAAM,EAAE,QAAQ,EAAE,EAAE,KAC5C,IAAI,cAAc,QAAQ,SAAS,OAAO,CAAC;AAE7C;;;;CAIC,GACD,MAAM;IACJ;;;GAGC,GACD,YAAY,GAAG,EAAE,QAAQ,CAAE;QACzB,IAAI,CAAC,GAAG,GAAG;QACX,IAAI,CAAC,QAAQ,GAAG;IAClB;IACA,iCAAiC,GACjC,IAAI,SAAS;QACX,OAAO,IAAI;IACb;IAEA,IAAI,qBAAqB;QACvB,OAAO,IAAI,CAAC,GAAG,CAAC,kBAAkB;IACpC;IACA,IAAI,gBAAgB;QAClB,OAAO,IAAI,CAAC,GAAG,CAAC,aAAa;IAC/B;IAEA;;GAEC,GACD,MAAM;QACJ,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG;IAC1B;IAEA,WAAW;QACT,OAAO,IAAI,CAAC,QAAQ,CAAC,QAAQ;IAC/B;IAEA;;;GAGC,GACD,QAAQ,EAAE,EAAE;QACV,OAAO,QAAQ,IAAI,CAAC,GAAG,EAAE;IAC3B;IAEA;;;GAGC,GACD,KAAK,OAAO,EAAE;QACZ,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC;IACvB;IACA;;;;GAIC,GACD,OAAO,OAAO,EAAE,SAAS,EAAE;QACzB,OAAO,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,SAAS;IACvC;IAEA,YAAY;QACV,MAAM,EAAE,IAAI,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS;QACnC,OAAO;YACL,IAAI,IAAI,CAAC,GAAG;YACZ;QACF;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 1093, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/principal/src/ed25519/signer.js"],"sourcesContent":["import * as ED25519 from '@noble/ed25519'\nimport { varint } from 'multiformats'\nimport * as API from './type.js'\nimport * as Verifier from './verifier.js'\nimport { base64pad } from 'multiformats/bases/base64'\nimport * as Signature from '@ipld/dag-ucan/signature'\nimport * as Signer from '../signer.js'\nexport * from './type.js'\n\nexport const code = 0x1300\nexport const name = Verifier.name\n\n/** @type {'EdDSA'} */\nexport const signatureAlgorithm = Verifier.signatureAlgorithm\nexport const signatureCode = Verifier.signatureCode\n\nconst PRIVATE_TAG_SIZE = varint.encodingLength(code)\nconst PUBLIC_TAG_SIZE = varint.encodingLength(Verifier.code)\nconst KEY_SIZE = 32\nconst SIZE = PRIVATE_TAG_SIZE + KEY_SIZE + PUBLIC_TAG_SIZE + KEY_SIZE\n\nexport const PUB_KEY_OFFSET = PRIVATE_TAG_SIZE + KEY_SIZE\n\n/**\n * Generates new issuer by generating underlying ED25519 keypair.\n * @returns {Promise<API.EdSigner>}\n */\nexport const generate = () => derive(ED25519.utils.randomPrivateKey())\n\n/**\n * Derives issuer from 32 byte long secret key.\n * @param {Uint8Array} secret\n * @returns {Promise<API.EdSigner>}\n */\nexport const derive = async secret => {\n  if (secret.byteLength !== KEY_SIZE) {\n    throw new Error(\n      `Expected Uint8Array with byteLength of ${KEY_SIZE} instead not ${secret.byteLength}`\n    )\n  }\n\n  const publicKey = await ED25519.getPublicKey(secret)\n  const signer = new Ed25519Signer(SIZE)\n\n  varint.encodeTo(code, signer, 0)\n  signer.set(secret, PRIVATE_TAG_SIZE)\n\n  varint.encodeTo(Verifier.code, signer, PRIVATE_TAG_SIZE + KEY_SIZE)\n  signer.set(publicKey, PRIVATE_TAG_SIZE + KEY_SIZE + PUBLIC_TAG_SIZE)\n\n  return signer\n}\n\n/**\n * @param {API.SignerArchive<API.DID, typeof signatureCode>} archive\n * @returns {API.EdSigner}\n */\nexport const from = ({ id, keys }) => {\n  if (id.startsWith('did:key:')) {\n    const key = keys[/** @type {API.DIDKey} */ (id)]\n    if (key instanceof Uint8Array) {\n      return decode(key)\n    }\n  }\n  throw new TypeError(`Unsupported archive format`)\n}\n\n/**\n * @template {API.SignerImporter} O\n * @param {O} other\n */\nexport const or = other => Signer.or({ from }, other)\n\n/**\n * @param {Uint8Array} bytes\n * @returns {API.EdSigner}\n */\nexport const decode = bytes => {\n  if (bytes.byteLength !== SIZE) {\n    throw new Error(\n      `Expected Uint8Array with byteLength of ${SIZE} instead not ${bytes.byteLength}`\n    )\n  }\n\n  {\n    const [keyCode] = varint.decode(bytes)\n    if (keyCode !== code) {\n      throw new Error(`Given bytes must be a multiformat with ${code} tag`)\n    }\n  }\n\n  {\n    const [code] = varint.decode(bytes.subarray(PUB_KEY_OFFSET))\n    if (code !== Verifier.code) {\n      throw new Error(\n        `Given bytes must contain public key in multiformats with ${Verifier.code} tag`\n      )\n    }\n  }\n\n  return new Ed25519Signer(bytes)\n}\n\n/**\n * @param {API.EdSigner} signer\n * @return {API.ByteView<API.EdSigner & CryptoKeyPair>}\n */\nexport const encode = signer => signer.encode()\n\n/**\n * @template {string} Prefix\n * @param {API.EdSigner} signer\n * @param {API.MultibaseEncoder<Prefix>} [encoder]\n */\nexport const format = (signer, encoder) =>\n  (encoder || base64pad).encode(encode(signer))\n\n/**\n * @template {string} Prefix\n * @param {string} principal\n * @param {API.MultibaseDecoder<Prefix>} [decoder]\n * @returns {API.EdSigner}\n */\nexport const parse = (principal, decoder) =>\n  decode((decoder || base64pad).decode(principal))\n\n/**\n * @implements {API.EdSigner}\n */\nclass Ed25519Signer extends Uint8Array {\n  /** @type {typeof code} */\n  get code() {\n    return code\n  }\n  get signer() {\n    return this\n  }\n  /** @type {API.EdVerifier} */\n  get verifier() {\n    const bytes = new Uint8Array(this.buffer, PRIVATE_TAG_SIZE + KEY_SIZE)\n    const verifier = Verifier.decode(bytes)\n\n    Object.defineProperties(this, {\n      verifier: {\n        value: verifier,\n      },\n    })\n\n    return verifier\n  }\n\n  /**\n   * Raw public key without multiformat code.\n   */\n  get secret() {\n    const secret = new Uint8Array(this.buffer, PRIVATE_TAG_SIZE, KEY_SIZE)\n    Object.defineProperties(this, {\n      secret: {\n        value: secret,\n      },\n    })\n\n    return secret\n  }\n\n  /**\n   * DID of this principal in `did:key` format.\n   */\n  did() {\n    return this.verifier.did()\n  }\n\n  toDIDKey() {\n    return this.verifier.toDIDKey()\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   * @returns {API.Signer<ID, typeof Signature.EdDSA>}\n   */\n  withDID(id) {\n    return Signer.withDID(this, id)\n  }\n\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @returns {Promise<API.SignatureView<T, typeof Signature.EdDSA>>}\n   */\n  async sign(payload) {\n    const raw = await ED25519.sign(payload, this.secret)\n\n    return Signature.create(this.signatureCode, raw)\n  }\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @param {API.Signature<T, typeof this.signatureCode>} signature\n   */\n\n  verify(payload, signature) {\n    return this.verifier.verify(payload, signature)\n  }\n\n  get signatureAlgorithm() {\n    return signatureAlgorithm\n  }\n  get signatureCode() {\n    return Signature.EdDSA\n  }\n\n  encode() {\n    return this\n  }\n\n  toArchive() {\n    const id = this.did()\n    return {\n      id,\n      keys: { [id]: this.encode() },\n    }\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1275, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/principal/src/ed25519.js"],"sourcesContent":["export * from './ed25519/signer.js'\nexport * as Verifier from './ed25519/verifier.js'\nexport * as Signer from './ed25519/signer.js'\n"],"names":[],"mappings":";AAAA;AACA","ignoreList":[0]}},
    {"offset": {"line": 1367, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 1372, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/principal/src/multiformat.js"],"sourcesContent":["import { varint } from 'multiformats'\n\n/**\n *\n * @param {number} code\n * @param {Uint8Array} bytes\n */\nexport const tagWith = (code, bytes) => {\n  const offset = varint.encodingLength(code)\n  const multiformat = new Uint8Array(bytes.byteLength + offset)\n  varint.encodeTo(code, multiformat, 0)\n  multiformat.set(bytes, offset)\n\n  return multiformat\n}\n\n/**\n * @param {number} code\n * @param {Uint8Array} source\n * @param {number} byteOffset\n * @returns\n */\nexport const untagWith = (code, source, byteOffset = 0) => {\n  const bytes = byteOffset !== 0 ? source.subarray(byteOffset) : source\n  const [tag, size] = varint.decode(bytes)\n  if (tag !== code) {\n    throw new Error(\n      `Expected multiformat with 0x${code.toString(\n        16\n      )} tag instead got 0x${tag.toString(16)}`\n    )\n  } else {\n    return new Uint8Array(bytes.buffer, bytes.byteOffset + size)\n  }\n}\n\nexport const encodingLength = varint.encodingLength\nexport const encodeTo = varint.encodeTo\nexport const decode = varint.decode\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;AAAA;;AAOO,MAAM,UAAU,CAAC,MAAM;IAC5B,MAAM,SAAS,0OAAM,CAAC,cAAc,CAAC;IACrC,MAAM,cAAc,IAAI,WAAW,MAAM,UAAU,GAAG;IACtD,0OAAM,CAAC,QAAQ,CAAC,MAAM,aAAa;IACnC,YAAY,GAAG,CAAC,OAAO;IAEvB,OAAO;AACT;AAQO,MAAM,YAAY,CAAC,MAAM,QAAQ,aAAa,CAAC;IACpD,MAAM,QAAQ,eAAe,IAAI,OAAO,QAAQ,CAAC,cAAc;IAC/D,MAAM,CAAC,KAAK,KAAK,GAAG,0OAAM,CAAC,MAAM,CAAC;IAClC,IAAI,QAAQ,MAAM;QAChB,MAAM,IAAI,MACR,CAAC,4BAA4B,EAAE,KAAK,QAAQ,CAC1C,IACA,mBAAmB,EAAE,IAAI,QAAQ,CAAC,KAAK;IAE7C,OAAO;QACL,OAAO,IAAI,WAAW,MAAM,MAAM,EAAE,MAAM,UAAU,GAAG;IACzD;AACF;AAEO,MAAM,iBAAiB,0OAAM,CAAC,cAAc;AAC5C,MAAM,WAAW,0OAAM,CAAC,QAAQ;AAChC,MAAM,SAAS,0OAAM,CAAC,MAAM","ignoreList":[0]}},
    {"offset": {"line": 1410, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/principal/src/rsa/asn1.js"],"sourcesContent":["/**\n * ASN1 Tags as per https://luca.ntop.org/Teaching/Appunti/asn1.html\n */\nconst TAG_SIZE = 1\nexport const INT_TAG = 0x02\nexport const BITSTRING_TAG = 0x03\nexport const OCTET_STRING_TAG = 0x04\nexport const NULL_TAG = 0x05\nexport const OBJECT_TAG = 0x06\nexport const SEQUENCE_TAG = 0x30\n\nexport const UNUSED_BIT_PAD = 0x00\n\n/**\n * @param {number} length\n * @returns {Uint8Array}\n */\nexport const encodeDERLength = length => {\n  if (length <= 127) {\n    return new Uint8Array([length])\n  }\n\n  /** @type {number[]} */\n  const octets = []\n  while (length !== 0) {\n    octets.push(length & 0xff)\n    length = length >>> 8\n  }\n  octets.reverse()\n  return new Uint8Array([0x80 | (octets.length & 0xff), ...octets])\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {{number: number, consumed: number}}\n */\nexport const readDERLength = (bytes, offset = 0) => {\n  if ((bytes[offset] & 0x80) === 0) {\n    return { number: bytes[offset], consumed: 1 }\n  }\n\n  const numberBytes = bytes[offset] & 0x7f\n  /* c8 ignore next 5 */\n  if (bytes.length < numberBytes + 1) {\n    throw new Error(\n      `ASN parsing error: Too few bytes. Expected encoded length's length to be at least ${numberBytes}`\n    )\n  }\n\n  let length = 0\n  for (let i = 0; i < numberBytes; i++) {\n    length = length << 8\n    length = length | bytes[offset + i + 1]\n  }\n\n  return { number: length, consumed: numberBytes + 1 }\n}\n\n/**\n * @param {Uint8Array} input\n * @param {number} expectedTag\n * @param {number} position\n * @returns {number}\n */\nexport const skip = (input, expectedTag, position) => {\n  const parsed = into(input, expectedTag, position)\n  return parsed.position + parsed.length\n}\n\n/**\n * @param {Uint8Array} input\n * @param {number} expectedTag\n * @param {number} offset\n * @returns {{ position: number, length: number }}\n */\nexport const into = (input, expectedTag, offset) => {\n  const actualTag = input[offset]\n  /* c8 ignore next 7 */\n  if (actualTag !== expectedTag) {\n    throw new Error(\n      `ASN parsing error: Expected tag 0x${expectedTag.toString(\n        16\n      )} at position ${offset}, but got 0x${actualTag.toString(16)}.`\n    )\n  }\n\n  // length\n  const length = readDERLength(input, offset + TAG_SIZE)\n  const position = offset + TAG_SIZE + length.consumed\n\n  // content\n  return { position, length: length.number }\n}\n\n/**\n * @param {Uint8Array} input\n */\nexport const encodeBitString = input => {\n  // encode input length + 1 for unused bit pad\n  const length = encodeDERLength(input.byteLength + 1)\n  // allocate a buffer of desired size\n  const bytes = new Uint8Array(\n    TAG_SIZE + // ASN_BITSTRING_TAG\n      length.byteLength +\n      1 + // amount of unused bits at the end of our bitstring\n      input.byteLength\n  )\n\n  let byteOffset = 0\n  // write bytestring tag\n  bytes[byteOffset] = BITSTRING_TAG\n  byteOffset += TAG_SIZE\n\n  // write length of the bytestring\n  bytes.set(length, byteOffset)\n  byteOffset += length.byteLength\n\n  // write unused bits at the end of our bitstring\n  bytes[byteOffset] = UNUSED_BIT_PAD\n  byteOffset += 1\n\n  // write actual data into bitstring\n  bytes.set(input, byteOffset)\n\n  return bytes\n}\n\n/**\n * @param {Uint8Array} input\n */\nexport const encodeOctetString = input => {\n  // encode input length\n  const length = encodeDERLength(input.byteLength)\n  // allocate a buffer of desired size\n  const bytes = new Uint8Array(TAG_SIZE + length.byteLength + input.byteLength)\n\n  let byteOffset = 0\n  // write octet string tag\n  bytes[byteOffset] = OCTET_STRING_TAG\n  byteOffset += TAG_SIZE\n\n  // write octet string length\n  bytes.set(length, byteOffset)\n  byteOffset += length.byteLength\n\n  // write actual data into bitstring\n  bytes.set(input, byteOffset)\n\n  return bytes\n}\n\n/**\n * @param {Uint8Array[]} sequence\n */\nexport const encodeSequence = sequence => {\n  // calculate bytelength for all the parts\n  let byteLength = 0\n  for (const item of sequence) {\n    byteLength += item.byteLength\n  }\n\n  // encode sequence byte length\n  const length = encodeDERLength(byteLength)\n\n  // allocate the buffer to write sequence into\n  const bytes = new Uint8Array(TAG_SIZE + length.byteLength + byteLength)\n\n  let byteOffset = 0\n\n  // write the sequence tag\n  bytes[byteOffset] = SEQUENCE_TAG\n  byteOffset += TAG_SIZE\n\n  // write sequence length\n  bytes.set(length, byteOffset)\n  byteOffset += length.byteLength\n\n  // write each item in the sequence\n  for (const item of sequence) {\n    bytes.set(item, byteOffset)\n    byteOffset += item.byteLength\n  }\n\n  return bytes\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n */\nexport const readSequence = (bytes, offset = 0) => {\n  const { position, length } = into(bytes, SEQUENCE_TAG, offset)\n\n  return new Uint8Array(bytes.buffer, bytes.byteOffset + position, length)\n}\n\n/**\n * @param {Uint8Array} input\n */\nexport const encodeInt = input => {\n  const extra = input.byteLength === 0 || input[0] & 0x80 ? 1 : 0\n\n  // encode input length\n  const length = encodeDERLength(input.byteLength + extra)\n  // allocate a buffer of desired size\n  const bytes = new Uint8Array(\n    TAG_SIZE + // INT_TAG\n      length.byteLength +\n      input.byteLength +\n      extra\n  )\n\n  let byteOffset = 0\n  // write octet string tag\n  bytes[byteOffset] = INT_TAG\n  byteOffset += TAG_SIZE\n\n  // write int length\n  bytes.set(length, byteOffset)\n  byteOffset += length.byteLength\n\n  // add 0 if the most-significant bit is set\n  if (extra > 0) {\n    bytes[byteOffset] = UNUSED_BIT_PAD\n    byteOffset += extra\n  }\n\n  // write actual data into bitstring\n  bytes.set(input, byteOffset)\n\n  return bytes\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {number}\n */\n\nexport const enterSequence = (bytes, offset = 0) =>\n  into(bytes, SEQUENCE_TAG, offset).position\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {number}\n */\nexport const skipSequence = (bytes, offset = 0) =>\n  skip(bytes, SEQUENCE_TAG, offset)\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {number}\n */\nexport const skipInt = (bytes, offset = 0) => skip(bytes, INT_TAG, offset)\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {Uint8Array}\n */\nexport const readBitString = (bytes, offset = 0) => {\n  const { position, length } = into(bytes, BITSTRING_TAG, offset)\n  const tag = bytes[position]\n  /* c8 ignore next 5 */\n  if (tag !== UNUSED_BIT_PAD) {\n    throw new Error(\n      `Can not read bitstring, expected length to be multiple of 8, but got ${tag} unused bits in last byte.`\n    )\n  }\n\n  return new Uint8Array(\n    bytes.buffer,\n    bytes.byteOffset + position + 1,\n    length - 1\n  )\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} byteOffset\n * @returns {Uint8Array}\n */\nexport const readInt = (bytes, byteOffset = 0) => {\n  const { position, length } = into(bytes, INT_TAG, byteOffset)\n  let delta = 0\n\n  // drop leading 0s\n  while (bytes[position + delta] === 0) {\n    delta++\n  }\n\n  return new Uint8Array(\n    bytes.buffer,\n    bytes.byteOffset + position + delta,\n    length - delta\n  )\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {Uint8Array}\n */\nexport const readOctetString = (bytes, offset = 0) => {\n  const { position, length } = into(bytes, OCTET_STRING_TAG, offset)\n\n  return new Uint8Array(bytes.buffer, bytes.byteOffset + position, length)\n}\n\n/**\n * @typedef {(bytes:Uint8Array, offset:number) => Uint8Array} Reader\n * @param {[Reader, ...Reader[]]} readers\n * @param {Uint8Array} source\n * @param {number} byteOffset\n */\nexport const readSequenceWith = (readers, source, byteOffset = 0) => {\n  const results = []\n  const sequence = readSequence(source, byteOffset)\n  let offset = 0\n  for (const read of readers) {\n    const chunk = read(sequence, offset)\n    results.push(chunk)\n    offset = chunk.byteOffset + chunk.byteLength - sequence.byteOffset\n  }\n  return results\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1651, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/principal/src/rsa/spki.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport {\n  encodeSequence,\n  encodeBitString,\n  enterSequence,\n  skipSequence,\n  readBitString,\n} from './asn1.js'\n\n/**\n * @typedef {import('./public-key.js').RSAPublicKey} RSAPublicKey\n */\n/**\n * Described in RFC 5208 Section 4.1: https://tools.ietf.org/html/rfc5280#section-4.1\n * ```\n * SubjectPublicKeyInfo  ::=  SEQUENCE  {\n *    algorithm            AlgorithmIdentifier,\n *    subjectPublicKey     BIT STRING  }\n * ```\n *\n * @typedef {object} SubjectPublicKeyInfo\n * @property {API.ByteView<AlgorithmIdentifier>} algorithm\n * @property {API.ByteView<RSAPublicKey>} subjectPublicKey\n * @typedef {import('./pkcs8.js').AlgorithmIdentifier} AlgorithmIdentifier\n */\n\n/**\n * The ASN.1 DER encoded header that needs to be added to an\n * ASN.1 DER encoded RSAPublicKey to make it a SubjectPublicKeyInfo.\n *\n * This byte sequence is always the same.\n *\n * A human-readable version of this as part of a dumpasn1 dump:\n *\n *     SEQUENCE {\n *       OBJECT IDENTIFIER rsaEncryption (1 2 840 113549 1 1 1)\n *       NULL\n *     }\n *\n * See https://github.com/ucan-wg/ts-ucan/issues/30\n */\nexport const SPKI_PARAMS_ENCODED = new Uint8Array([\n  48, 13, 6, 9, 42, 134, 72, 134, 247, 13, 1, 1, 1, 5, 0,\n])\n\n/**\n * @param {API.ByteView<RSAPublicKey>} key\n * @returns {API.ByteView<SubjectPublicKeyInfo>}\n */\nexport const encode = key =>\n  encodeSequence([SPKI_PARAMS_ENCODED, encodeBitString(key)])\n\n/**\n *\n * @param {API.ByteView<SubjectPublicKeyInfo>} info\n * @returns {API.ByteView<RSAPublicKey>}\n */\nexport const decode = info => {\n  // go into the top-level SEQUENCE\n  const offset = enterSequence(info, 0)\n  // skip the header we expect (SKPI_PARAMS_ENCODED)\n  const keyOffset = skipSequence(info, offset)\n\n  // we expect the bitstring next\n  return readBitString(info, keyOffset)\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;;;AAwCO,MAAM,sBAAsB,IAAI,WAAW;IAChD;IAAI;IAAI;IAAG;IAAG;IAAI;IAAK;IAAI;IAAK;IAAK;IAAI;IAAG;IAAG;IAAG;IAAG;CACtD;AAMM,MAAM,SAAS,CAAA,MACpB,IAAA,6KAAc,EAAC;QAAC;QAAqB,IAAA,8KAAe,EAAC;KAAK;AAOrD,MAAM,SAAS,CAAA;IACpB,iCAAiC;IACjC,MAAM,SAAS,IAAA,4KAAa,EAAC,MAAM;IACnC,kDAAkD;IAClD,MAAM,YAAY,IAAA,2KAAY,EAAC,MAAM;IAErC,+BAA+B;IAC/B,OAAO,IAAA,4KAAa,EAAC,MAAM;AAC7B","ignoreList":[0]}},
    {"offset": {"line": 1696, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/principal/src/rsa/pkcs8.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport { base64url } from 'multiformats/bases/base64'\nimport {\n  encodeSequence,\n  encodeOctetString,\n  enterSequence,\n  skipSequence,\n  skipInt,\n  readOctetString,\n} from './asn1.js'\n\nconst PKSC8_HEADER = new Uint8Array([\n  // version\n  2, 1, 0,\n  // privateKeyAlgorithm\n  48, 13, 6, 9, 42, 134, 72, 134, 247, 13, 1, 1, 1, 5, 0,\n])\n/**\n * @typedef {import('./private-key').RSAPrivateKey} RSAPrivateKey\n * @typedef {object} AlgorithmIdentifier\n * @property {Uint8Array} version\n * @property {Uint8Array} parameters\n *\n * @see https://datatracker.ietf.org/doc/html/rfc5208#section-5\n * @typedef {object} PrivateKeyInfo\n * @property {API.ByteView<number>} version\n * @property {API.ByteView<AlgorithmIdentifier>} privateKeyAlgorithm\n * @property {API.ByteView<RSAPrivateKey>} privateKey\n * @property {API.ByteView<unknown>} [attributes]\n */\n\n/**\n * @param {API.ByteView<PrivateKeyInfo>} info\n * @returns {API.ByteView<RSAPrivateKey>}\n */\nexport const decode = info => {\n  let offset = 0\n  // go into the top-level SEQUENCE\n  offset = enterSequence(info, offset)\n  offset = skipInt(info, offset)\n  offset = skipSequence(info, offset)\n\n  // we expect the bitstring next\n  return readOctetString(info, offset)\n}\n\n/**\n * @param {API.ByteView<RSAPrivateKey>} key\n * @returns {API.ByteView<PrivateKeyInfo>}\n */\nexport const encode = key =>\n  encodeSequence([PKSC8_HEADER, encodeOctetString(key)])\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;;;;AASA,MAAM,eAAe,IAAI,WAAW;IAClC,UAAU;IACV;IAAG;IAAG;IACN,sBAAsB;IACtB;IAAI;IAAI;IAAG;IAAG;IAAI;IAAK;IAAI;IAAK;IAAK;IAAI;IAAG;IAAG;IAAG;IAAG;CACtD;AAmBM,MAAM,SAAS,CAAA;IACpB,IAAI,SAAS;IACb,iCAAiC;IACjC,SAAS,IAAA,4KAAa,EAAC,MAAM;IAC7B,SAAS,IAAA,sKAAO,EAAC,MAAM;IACvB,SAAS,IAAA,2KAAY,EAAC,MAAM;IAE5B,+BAA+B;IAC/B,OAAO,IAAA,8KAAe,EAAC,MAAM;AAC/B;AAMO,MAAM,SAAS,CAAA,MACpB,IAAA,6KAAc,EAAC;QAAC;QAAc,IAAA,gLAAiB,EAAC;KAAK","ignoreList":[0]}},
    {"offset": {"line": 1747, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/principal/src/rsa/public-key.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport { encodeSequence, readInt, encodeInt, readSequenceWith } from './asn1.js'\nimport * as SPKI from './spki.js'\nimport { base64url } from 'multiformats/bases/base64'\n/**\n * RSA public key represenatation\n * @see https://datatracker.ietf.org/doc/html/rfc3447#appendix-A.1\n *\n * @typedef {object} RSAPublicKey\n * @property {API.ByteView<number>} n\n * @property {API.ByteView<number>} e\n */\n\n/**\n * Takes private-key information in [Private-Key Information Syntax](https://datatracker.ietf.org/doc/html/rfc5208#section-5)\n * and extracts all the fields as per [RSA private key syntax](https://datatracker.ietf.org/doc/html/rfc3447#appendix-A.1.2)\n *\n *\n * @param {API.ByteView<RSAPublicKey>} key\n * @param {number} byteOffset\n * @returns {RSAPublicKey}\n */\nexport const decode = (key, byteOffset = 0) => {\n  const [n, e] = readSequenceWith([readInt, readInt], key, byteOffset)\n\n  return { n, e }\n}\n\n/**\n * @param {RSAPublicKey} key\n * @returns {API.ByteView<RSAPublicKey>}\n */\nexport const encode = ({ n, e }) => encodeSequence([encodeInt(n), encodeInt(e)])\n\n/**\n * @param {RSAPublicKey} key\n */\nexport const toSPKI = key => SPKI.encode(encode(key))\n\n/**\n * @param {API.ByteView<SPKI.SubjectPublicKeyInfo>} info\n */\nexport const fromSPKI = info => decode(SPKI.decode(info))\n\n/**\n * @param {RSAPublicKey} key\n * @returns {JsonWebKey}\n */\nexport const toJWK = ({ n, e }) => ({\n  kty: 'RSA',\n  alg: 'RS256',\n  key_ops: ['verify'],\n  ext: true,\n  n: base64url.baseEncode(n),\n  e: base64url.baseEncode(e),\n})\n\n/**\n * @param {JsonWebKey} jwk\n * @returns {RSAPublicKey}\n */\nexport const fromJWK = ({ n, e }) => ({\n  n: base64urlDecode(n),\n  e: base64urlDecode(e),\n})\n\n/**\n * @param {string|undefined} input\n */\nconst base64urlDecode = (input = '') => base64url.baseDecode(input)\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;;;;;AAmBO,MAAM,SAAS,CAAC,KAAK,aAAa,CAAC;IACxC,MAAM,CAAC,GAAG,EAAE,GAAG,IAAA,+KAAgB,EAAC;QAAC,sKAAO;QAAE,sKAAO;KAAC,EAAE,KAAK;IAEzD,OAAO;QAAE;QAAG;IAAE;AAChB;AAMO,MAAM,SAAS,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAK,IAAA,6KAAc,EAAC;QAAC,IAAA,wKAAS,EAAC;QAAI,IAAA,wKAAS,EAAC;KAAG;AAKxE,MAAM,SAAS,CAAA,MAAO,qKAAW,CAAC,OAAO;AAKzC,MAAM,WAAW,CAAA,OAAQ,OAAO,qKAAW,CAAC;AAM5C,MAAM,QAAQ,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAK,CAAC;QAClC,KAAK;QACL,KAAK;QACL,SAAS;YAAC;SAAS;QACnB,KAAK;QACL,GAAG,oNAAS,CAAC,UAAU,CAAC;QACxB,GAAG,oNAAS,CAAC,UAAU,CAAC;IAC1B,CAAC;AAMM,MAAM,UAAU,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAK,CAAC;QACpC,GAAG,gBAAgB;QACnB,GAAG,gBAAgB;IACrB,CAAC;AAED;;CAEC,GACD,MAAM,kBAAkB,CAAC,QAAQ,EAAE,GAAK,oNAAS,CAAC,UAAU,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1806, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/principal/src/rsa/private-key.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport { encodeSequence, readInt, readSequenceWith, encodeInt } from './asn1.js'\nimport { base64url } from 'multiformats/bases/base64'\nimport * as PKCS8 from './pkcs8.js'\nimport * as SPKI from './spki.js'\nimport * as PublicKey from './public-key.js'\n\nexport const code = 0x1305\nconst VERSION = new Uint8Array()\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc3447#appendix-A.1.2\n * @typedef {object} RSAPrivateKey\n * @property {Uint8Array} v\n * @property {Uint8Array} n\n * @property {Uint8Array} e\n * @property {Uint8Array} d\n * @property {Uint8Array} p\n * @property {Uint8Array} q\n * @property {Uint8Array} dp\n * @property {Uint8Array} dq\n * @property {Uint8Array} qi\n */\n\n/**\n * Takes private-key information in [Private-Key Information Syntax](https://datatracker.ietf.org/doc/html/rfc5208#section-5)\n * and extracts all the fields as per [RSA private key syntax](https://datatracker.ietf.org/doc/html/rfc3447#appendix-A.1.2)\n *\n *\n * @param {API.ByteView<RSAPrivateKey>} source\n * @param {number} byteOffset\n * @returns {RSAPrivateKey}\n */\nexport const decode = (source, byteOffset = 0) => {\n  const [v, n, e, d, p, q, dp, dq, qi] = readSequenceWith(\n    [\n      readInt,\n      readInt,\n      readInt,\n      readInt,\n      readInt,\n      readInt,\n      readInt,\n      readInt,\n      readInt,\n    ],\n    source,\n    byteOffset\n  )\n\n  return { v, n, e, d, p, q, dp, dq, qi }\n}\n\n/**\n * @param {RSAPrivateKey} key\n * @returns {API.ByteView<RSAPrivateKey>}\n */\nexport const encode = ({ v, n, e, d, p, q, dp, dq, qi }) => {\n  return encodeSequence([\n    encodeInt(v),\n    encodeInt(n),\n    encodeInt(e),\n    encodeInt(d),\n    encodeInt(p),\n    encodeInt(q),\n    encodeInt(dp),\n    encodeInt(dq),\n    encodeInt(qi),\n  ])\n}\n\n/**\n * @param {RSAPrivateKey} key\n * @returns {JsonWebKey}\n */\nexport const toJWK = ({ n, e, d, p, q, dp, dq, qi }) => ({\n  kty: 'RSA',\n  alg: 'RS256',\n  key_ops: ['sign'],\n  ext: true,\n  n: base64url.baseEncode(n),\n  e: base64url.baseEncode(e),\n  d: base64url.baseEncode(d),\n  p: base64url.baseEncode(p),\n  q: base64url.baseEncode(q),\n  dp: base64url.baseEncode(dp),\n  dq: base64url.baseEncode(dq),\n  qi: base64url.baseEncode(qi),\n})\n\n/**\n * @param {JsonWebKey} key\n * @returns {RSAPrivateKey}\n */\nexport const fromJWK = ({ n, e, d, p, q, dp, dq, qi }) => ({\n  v: VERSION,\n  n: base64urlDecode(n),\n  e: base64urlDecode(e),\n  d: base64urlDecode(d),\n  p: base64urlDecode(p),\n  q: base64urlDecode(q),\n  dp: base64urlDecode(dp),\n  dq: base64urlDecode(dq),\n  qi: base64urlDecode(qi),\n})\n\n/**\n * @param {RSAPrivateKey} key\n */\nexport const toPKCS8 = key => PKCS8.encode(encode(key))\n\n/**\n * @param {API.ByteView<PKCS8.PrivateKeyInfo>} info\n */\nexport const fromPKCS8 = info => decode(PKCS8.decode(info))\n\n/**\n * @param {RSAPrivateKey} key\n */\nexport const toSPKI = key => SPKI.encode(PublicKey.encode(key))\n\n/**\n *\n * @param {string|undefined} input\n * @returns\n */\nconst base64urlDecode = (input = '') => base64url.baseDecode(input)\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAEO,MAAM,OAAO;AACpB,MAAM,UAAU,IAAI;AAyBb,MAAM,SAAS,CAAC,QAAQ,aAAa,CAAC;IAC3C,MAAM,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,IAAA,+KAAgB,EACrD;QACE,sKAAO;QACP,sKAAO;QACP,sKAAO;QACP,sKAAO;QACP,sKAAO;QACP,sKAAO;QACP,sKAAO;QACP,sKAAO;QACP,sKAAO;KACR,EACD,QACA;IAGF,OAAO;QAAE;QAAG;QAAG;QAAG;QAAG;QAAG;QAAG;QAAI;QAAI;IAAG;AACxC;AAMO,MAAM,SAAS,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE;IACrD,OAAO,IAAA,6KAAc,EAAC;QACpB,IAAA,wKAAS,EAAC;QACV,IAAA,wKAAS,EAAC;QACV,IAAA,wKAAS,EAAC;QACV,IAAA,wKAAS,EAAC;QACV,IAAA,wKAAS,EAAC;QACV,IAAA,wKAAS,EAAC;QACV,IAAA,wKAAS,EAAC;QACV,IAAA,wKAAS,EAAC;QACV,IAAA,wKAAS,EAAC;KACX;AACH;AAMO,MAAM,QAAQ,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAK,CAAC;QACvD,KAAK;QACL,KAAK;QACL,SAAS;YAAC;SAAO;QACjB,KAAK;QACL,GAAG,oNAAS,CAAC,UAAU,CAAC;QACxB,GAAG,oNAAS,CAAC,UAAU,CAAC;QACxB,GAAG,oNAAS,CAAC,UAAU,CAAC;QACxB,GAAG,oNAAS,CAAC,UAAU,CAAC;QACxB,GAAG,oNAAS,CAAC,UAAU,CAAC;QACxB,IAAI,oNAAS,CAAC,UAAU,CAAC;QACzB,IAAI,oNAAS,CAAC,UAAU,CAAC;QACzB,IAAI,oNAAS,CAAC,UAAU,CAAC;IAC3B,CAAC;AAMM,MAAM,UAAU,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAK,CAAC;QACzD,GAAG;QACH,GAAG,gBAAgB;QACnB,GAAG,gBAAgB;QACnB,GAAG,gBAAgB;QACnB,GAAG,gBAAgB;QACnB,GAAG,gBAAgB;QACnB,IAAI,gBAAgB;QACpB,IAAI,gBAAgB;QACpB,IAAI,gBAAgB;IACtB,CAAC;AAKM,MAAM,UAAU,CAAA,MAAO,sKAAY,CAAC,OAAO;AAK3C,MAAM,YAAY,CAAA,OAAQ,OAAO,sKAAY,CAAC;AAK9C,MAAM,SAAS,CAAA,MAAO,qKAAW,CAAC,8KAAgB,CAAC;AAE1D;;;;CAIC,GACD,MAAM,kBAAkB,CAAC,QAAQ,EAAE,GAAK,oNAAS,CAAC,UAAU,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1914, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/principal/src/rsa.js"],"sourcesContent":["import { webcrypto } from 'one-webcrypto'\nimport { base58btc } from 'multiformats/bases/base58'\nimport * as API from './rsa/type.js'\nimport * as DID from '@ipld/dag-ucan/did'\nimport { tagWith, untagWith } from './multiformat.js'\nimport * as Signature from '@ipld/dag-ucan/signature'\nimport * as SPKI from './rsa/spki.js'\nimport * as PKCS8 from './rsa/pkcs8.js'\nimport * as PrivateKey from './rsa/private-key.js'\nimport * as PublicKey from './rsa/public-key.js'\nimport * as Verifier from './verifier.js'\nimport * as Signer from './signer.js'\nexport * from './rsa/type.js'\n\nexport const name = 'RSA'\n\n/** @type {API.RSASigner['code']} */\nexport const code = 0x1305\n\n/** @type {API.RSAVerifier['code']} */\nconst verifierCode = 0x1205\n\n/** @type {API.SigAlg} */\nexport const signatureCode = Signature.RS256\nexport const signatureAlgorithm = 'RS256'\n\nconst ALG = 'RSASSA-PKCS1-v1_5'\nconst HASH_ALG = 'SHA-256'\nconst KEY_SIZE = 2048\nconst SALT_LENGTH = 128\nconst IMPORT_PARAMS = {\n  name: ALG,\n  hash: { name: HASH_ALG },\n}\n\n/**\n * @param {object} options\n * @param {number} [options.size]\n * @param {boolean} [options.extractable]\n * @returns {Promise<API.RSASigner>}\n */\nexport const generate = async ({\n  size = KEY_SIZE,\n  extractable = false,\n} = {}) => {\n  // We start by generate an RSA keypair using web crypto API.\n  const { publicKey, privateKey } = await webcrypto.subtle.generateKey(\n    {\n      name: ALG,\n      modulusLength: size,\n      publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n      hash: { name: HASH_ALG },\n    },\n\n    extractable,\n    ['sign', 'verify']\n  )\n\n  // Next we need to encode public key, because `RSAVerifier` uses it to\n  // for implementing a `did()` method. To do this we first export\n  // Subject Public Key Info (SPKI) using web crypto API.\n  const spki = await webcrypto.subtle.exportKey('spki', publicKey)\n  // Then we extract public key from the SPKI and tag it with RSA public key\n  // multicode\n  const publicBytes = tagWith(verifierCode, SPKI.decode(new Uint8Array(spki)))\n  // Now that we have publicKey and it's multiformat representation we can\n  // create a verifier.\n  const verifier = new RSAVerifier({ bytes: publicBytes, publicKey })\n\n  // If we generated non extractable key we just wrap actual keys and verifier\n  // in the RSASigner view.\n  if (!extractable) {\n    return new UnextractableRSASigner({\n      privateKey,\n      verifier,\n    })\n  }\n  // Otherwise we export key in Private Key Cryptography Standards (PKCS)\n  // format and extract a bytes corresponding to the private key, which\n  // we tag with RSA private key multiformat code. With both binary and actual\n  // key representation we create a RSASigner view.\n  // Please note that do key export flow during generation so that we can:\n  // 1. Guarantee that it will be exportable.\n  // 2. Make `export` method sync.\n  else {\n    const pkcs8 = await webcrypto.subtle.exportKey('pkcs8', privateKey)\n    const bytes = tagWith(code, PKCS8.decode(new Uint8Array(pkcs8)))\n    return new ExtractableRSASigner({\n      privateKey,\n      bytes,\n      verifier,\n    })\n  }\n}\n\n/**\n * @param {API.SignerArchive<API.DID, typeof signatureCode>} archive\n * @returns {API.RSASigner}\n */\nexport const from = ({ id, keys }) => {\n  if (id.startsWith('did:key:')) {\n    const did = /** @type {API.DIDKey} */ (id)\n    const key = keys[did]\n    if (key instanceof Uint8Array) {\n      return decode(key)\n    } else {\n      return new UnextractableRSASigner({\n        privateKey: key,\n        verifier: RSAVerifier.parse(did),\n      })\n    }\n  } else {\n    throw new TypeError(\n      `RSA can not import from ${id} archive, try generic Signer instead`\n    )\n  }\n}\n\n/**\n * @template {API.SignerImporter} Other\n * @param {Other} other\n */\nexport const or = other => Signer.or({ from }, other)\n\n/**\n * @param {EncodedSigner} bytes\n * @returns {API.RSASigner}\n */\nexport const decode = bytes => {\n  // First we decode RSA key data from the private key with multicode tag.\n  const rsa = PrivateKey.decode(untagWith(code, bytes))\n  // Then we encode RSA key data as public key with multicode tag.\n  const publicBytes = tagWith(verifierCode, PublicKey.encode(rsa))\n\n  return new ExtractableRSASigner({\n    bytes,\n    privateKey: webcrypto.subtle.importKey(\n      'pkcs8',\n      PKCS8.encode(untagWith(code, bytes)),\n      IMPORT_PARAMS,\n      true,\n      ['sign']\n    ),\n\n    verifier: RSAVerifier.decode(publicBytes),\n  })\n}\n\n/**\n * @implements {API.RSAVerifier}\n */\nclass RSAVerifier {\n  /**\n   * @param {object} options\n   * @param {API.Await<CryptoKey>} options.publicKey\n   * @param {API.ByteView<API.RSAVerifier>} options.bytes\n   */\n  constructor({ publicKey, bytes }) {\n    /** @private */\n    this.publicKey = publicKey\n    /** @private */\n    this.bytes = bytes\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   * @returns {API.Verifier<ID, typeof signatureCode>}\n   */\n  withDID(id) {\n    return Verifier.withDID(this, id)\n  }\n\n  toDIDKey() {\n    return this.did()\n  }\n\n  /**\n   * @param {API.ByteView<API.RSAVerifier>} bytes\n   * @returns {API.RSAVerifier}\n   */\n  static decode(bytes) {\n    return new this({\n      bytes,\n      publicKey: webcrypto.subtle.importKey(\n        'spki',\n        SPKI.encode(untagWith(verifierCode, bytes)),\n        IMPORT_PARAMS,\n        true,\n        ['verify']\n      ),\n    })\n  }\n  /**\n   * @param {API.DIDKey} did\n   * @returns {API.RSAVerifier}\n   */\n  static parse(did) {\n    return RSAVerifier.decode(/** @type {Uint8Array} */ (DID.parse(did)))\n  }\n\n  /**\n   * @param {API.PrincipalParser} other\n   */\n  static or(other) {\n    return Verifier.or(this, other)\n  }\n\n  /** @type {typeof verifierCode} */\n  get code() {\n    return verifierCode\n  }\n  /**\n   * @type {typeof signatureCode}\n   */\n  get signatureCode() {\n    return signatureCode\n  }\n  /**\n   * @type {typeof signatureAlgorithm}\n   */\n  get signatureAlgorithm() {\n    return signatureAlgorithm\n  }\n  /**\n   * DID of the Principal in `did:key` format.\n   * @returns {API.DID<\"key\">}\n   */\n  did() {\n    return `did:key:${base58btc.encode(this.bytes)}`\n  }\n\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @param {API.Signature<T, typeof this.signatureCode>} signature\n   * @returns {Promise<boolean>}\n   */\n  async verify(payload, signature) {\n    // if signature code does not match RS256 it's not signed by corresponding\n    // signer.\n    if (signature.code !== signatureCode) {\n      return false\n    }\n\n    return webcrypto.subtle.verify(\n      { name: ALG, hash: { name: HASH_ALG } },\n      await this.publicKey,\n      signature.raw,\n      payload\n    )\n  }\n}\n\nconst RSAVerifier$ = /** @type {API.ComposedDIDParser} */ (RSAVerifier)\nexport { RSAVerifier as Verifier }\n\n/**\n * @typedef {API.ByteView<API.Signer<API.DID<'key'>, typeof signatureCode> & CryptoKey>} EncodedSigner\n */\n\nclass RSASigner {\n  /**\n   * @param {object} options\n   * @param {API.Await<CryptoKey>} options.privateKey\n   * @param {API.RSAVerifier} options.verifier\n   */\n  constructor({ privateKey, verifier }) {\n    /** @readonly */\n    this.verifier = verifier\n    /** @protected */\n    this.privateKey = privateKey\n  }\n  get signer() {\n    return this\n  }\n\n  /**\n   * @type {typeof code}\n   */\n  get code() {\n    return code\n  }\n  /**\n   * @type {typeof signatureCode}\n   */\n  get signatureCode() {\n    return signatureCode\n  }\n  /**\n   * @type {typeof signatureAlgorithm}\n   */\n  get signatureAlgorithm() {\n    return signatureAlgorithm\n  }\n\n  did() {\n    return this.verifier.did()\n  }\n\n  toDIDKey() {\n    return this.verifier.toDIDKey()\n  }\n\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @param {API.Signature<T, typeof this.signatureCode>} signature\n   */\n  verify(payload, signature) {\n    return this.verifier.verify(payload, signature)\n  }\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @returns {Promise<API.SignatureView<T, typeof signatureCode>>}\n   */\n  async sign(payload) {\n    const buffer = await webcrypto.subtle.sign(\n      { name: ALG, saltLength: SALT_LENGTH },\n      await this.privateKey,\n      payload\n    )\n\n    return Signature.create(signatureCode, new Uint8Array(buffer))\n  }\n}\n\n/**\n * @implements {API.RSASigner}\n */\nclass ExtractableRSASigner extends RSASigner {\n  /**\n   * @param {object} options\n   * @param {API.Await<CryptoKey>} options.privateKey\n   * @param {EncodedSigner} options.bytes\n   * @param {API.RSAVerifier} options.verifier\n   */\n  constructor(options) {\n    super(options)\n    this.bytes = options.bytes\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   * @returns {API.Signer<ID, typeof signatureCode>}\n   */\n  withDID(id) {\n    return Signer.withDID(this, id)\n  }\n\n  toArchive() {\n    const id = this.did()\n    return {\n      id,\n      keys: { [id]: this.bytes },\n    }\n  }\n}\n\n/**\n * @implements {API.RSASigner}\n */\nclass UnextractableRSASigner extends RSASigner {\n  /**\n   * @param {object} options\n   * @param {CryptoKey} options.privateKey\n   * @param {API.RSAVerifier} options.verifier\n   */\n  constructor(options) {\n    super(options)\n    this.privateKey = options.privateKey\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   * @returns {API.Signer<ID, typeof signatureCode>}\n   */\n  withDID(id) {\n    return Signer.withDID(this, id)\n  }\n\n  toArchive() {\n    const id = this.did()\n    return {\n      id,\n      keys: { [id]: this.privateKey },\n    }\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2277, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/principal/src/absentee.js"],"sourcesContent":["import * as Signature from '@ipld/dag-ucan/signature'\nimport * as UCAN from '@ipld/dag-ucan'\n\n/**\n * @template {UCAN.DID} ID\n * @param {{id: ID }} id\n * @returns {UCAN.Signer<ID, Signature.NON_STANDARD>}\n */\nexport const from = ({ id }) => new Absentee(id)\n\n/**\n * An absentee is a special type of signer that produces an absent signature,\n * which signals that verifier needs to verify authorization interactively.\n *\n * @template {UCAN.DID} ID\n * @implements {UCAN.Signer<ID, Signature.NON_STANDARD>}\n */\nclass Absentee {\n  /**\n   * @param {ID} id\n   */\n  constructor(id) {\n    this.id = id\n  }\n  did() {\n    return this.id\n  }\n  /* c8 ignore next 3 */\n  get signatureCode() {\n    return Signature.NON_STANDARD\n  }\n  get signatureAlgorithm() {\n    return ''\n  }\n  sign() {\n    return Signature.createNonStandard(\n      this.signatureAlgorithm,\n      new Uint8Array(0)\n    )\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAOO,MAAM,OAAO,CAAC,EAAE,EAAE,EAAE,GAAK,IAAI,SAAS;AAE7C;;;;;;CAMC,GACD,MAAM;IACJ;;GAEC,GACD,YAAY,EAAE,CAAE;QACd,IAAI,CAAC,EAAE,GAAG;IACZ;IACA,MAAM;QACJ,OAAO,IAAI,CAAC,EAAE;IAChB;IACA,oBAAoB,GACpB,IAAI,gBAAgB;QAClB,OAAO,yKAAsB;IAC/B;IACA,IAAI,qBAAqB;QACvB,OAAO;IACT;IACA,OAAO;QACL,OAAO,8KAA2B,CAChC,IAAI,CAAC,kBAAkB,EACvB,IAAI,WAAW;IAEnB;AACF","ignoreList":[0]}},
    {"offset": {"line": 2315, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/principal/src/lib.js"],"sourcesContent":["import * as ed25519 from './ed25519.js'\nimport * as RSA from './rsa.js'\nimport * as Absentee from './absentee.js'\nexport * from './multiformat.js'\nexport const Verifier = ed25519.Verifier.or(RSA.Verifier)\nexport const Signer = ed25519.or(RSA)\n\n// exports\nexport { ed25519, RSA, Absentee }\n"],"names":[],"mappings":";;;;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;;;;;AACO,MAAM,WAAW,mNAAgB,CAAC,EAAE,CAAC,oJAAI,QAAQ;AACjD,MAAM,SAAS,uKAAU,CAAC","ignoreList":[0]}}]
}