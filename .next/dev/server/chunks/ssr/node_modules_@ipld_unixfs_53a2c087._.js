module.exports = [
"[project]/node_modules/@ipld/unixfs/src/api.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// @ts-nocheck
/**
 * This is file is shadowed by api.ts and only exists so JS could import it to
 * refer to types without encountering runtime errors
 * @see https://github.com/microsoft/TypeScript/issues/41825
 */ __turbopack_context__.s([]);
}),
"[project]/node_modules/@ipld/unixfs/src/file/api.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// @ts-nocheck
/**
 * This is file is shadowed by api.ts and only exists so JS could import it to
 * refer to types without encountering runtime errors
 * @see https://github.com/microsoft/TypeScript/issues/41825
 */ __turbopack_context__.s([]);
}),
"[project]/node_modules/@ipld/unixfs/gen/unixfs.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*eslint-disable*/ __turbopack_context__.s([
    "Data",
    ()=>Data,
    "Metadata",
    ()=>Metadata,
    "UnixTime",
    ()=>UnixTime,
    "default",
    ()=>$root
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$node_modules$2f$protobufjs$2f$minimal$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/minimal.js [app-ssr] (ecmascript)");
;
// Common aliases
const $Reader = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$node_modules$2f$protobufjs$2f$minimal$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].Reader, $Writer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$node_modules$2f$protobufjs$2f$minimal$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].Writer, $util = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$node_modules$2f$protobufjs$2f$minimal$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].util;
// Exported root namespace
const $root = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$node_modules$2f$protobufjs$2f$minimal$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].roots.unixfs || (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$node_modules$2f$protobufjs$2f$minimal$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].roots.unixfs = {});
const Data = $root.Data = (()=>{
    /**
     * Properties of a Data.
     * @exports IData
     * @interface IData
     * @property {Data.DataType} Type Data Type
     * @property {Uint8Array|null} [Data] Data Data
     * @property {number|null} [filesize] Data filesize
     * @property {Array.<number>|null} [blocksizes] Data blocksizes
     * @property {number|null} [hashType] Data hashType
     * @property {number|null} [fanout] Data fanout
     * @property {number|null} [mode] Data mode
     * @property {IUnixTime|null} [mtime] Data mtime
     */ /**
     * Constructs a new Data.
     * @exports Data
     * @classdesc Represents a Data.
     * @implements IData
     * @constructor
     * @param {IData=} [p] Properties to set
     */ function Data(p) {
        this.blocksizes = [];
        if (p) {
            for(var ks = Object.keys(p), i = 0; i < ks.length; ++i)if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }
    }
    /**
     * Data Type.
     * @member {Data.DataType} Type
     * @memberof Data
     * @instance
     */ Data.prototype.Type = 0;
    /**
     * Data Data.
     * @member {Uint8Array} Data
     * @memberof Data
     * @instance
     */ Data.prototype.Data = $util.newBuffer([]);
    /**
     * Data filesize.
     * @member {number} filesize
     * @memberof Data
     * @instance
     */ Data.prototype.filesize = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * Data blocksizes.
     * @member {Array.<number>} blocksizes
     * @memberof Data
     * @instance
     */ Data.prototype.blocksizes = $util.emptyArray;
    /**
     * Data hashType.
     * @member {number} hashType
     * @memberof Data
     * @instance
     */ Data.prototype.hashType = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * Data fanout.
     * @member {number} fanout
     * @memberof Data
     * @instance
     */ Data.prototype.fanout = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * Data mode.
     * @member {number} mode
     * @memberof Data
     * @instance
     */ Data.prototype.mode = 0;
    /**
     * Data mtime.
     * @member {IUnixTime|null|undefined} mtime
     * @memberof Data
     * @instance
     */ Data.prototype.mtime = null;
    /**
     * Encodes the specified Data message. Does not implicitly {@link Data.verify|verify} messages.
     * @function encode
     * @memberof Data
     * @static
     * @param {IData} m Data message or plain object to encode
     * @param {$protobuf.Writer} [w] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */ Data.encode = function encode(m, w) {
        if (!w) w = $Writer.create();
        w.uint32(8).int32(m.Type);
        if (m.Data != null && Object.hasOwnProperty.call(m, "Data")) w.uint32(18).bytes(m.Data);
        if (m.filesize != null && Object.hasOwnProperty.call(m, "filesize")) w.uint32(24).uint64(m.filesize);
        if (m.blocksizes != null && m.blocksizes.length) {
            for(var i = 0; i < m.blocksizes.length; ++i)w.uint32(32).uint64(m.blocksizes[i]);
        }
        if (m.hashType != null && Object.hasOwnProperty.call(m, "hashType")) w.uint32(40).uint64(m.hashType);
        if (m.fanout != null && Object.hasOwnProperty.call(m, "fanout")) w.uint32(48).uint64(m.fanout);
        if (m.mode != null && Object.hasOwnProperty.call(m, "mode")) w.uint32(56).uint32(m.mode);
        if (m.mtime != null && Object.hasOwnProperty.call(m, "mtime")) $root.UnixTime.encode(m.mtime, w.uint32(66).fork()).ldelim();
        return w;
    };
    /**
     * Decodes a Data message from the specified reader or buffer.
     * @function decode
     * @memberof Data
     * @static
     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
     * @param {number} [l] Message length if known beforehand
     * @returns {Data} Data
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */ Data.decode = function decode(r, l) {
        if (!(r instanceof $Reader)) r = $Reader.create(r);
        var c = l === undefined ? r.len : r.pos + l, m = new $root.Data();
        while(r.pos < c){
            var t = r.uint32();
            switch(t >>> 3){
                case 1:
                    m.Type = r.int32();
                    break;
                case 2:
                    m.Data = r.bytes();
                    break;
                case 3:
                    m.filesize = r.uint64();
                    break;
                case 4:
                    if (!(m.blocksizes && m.blocksizes.length)) m.blocksizes = [];
                    if ((t & 7) === 2) {
                        var c2 = r.uint32() + r.pos;
                        while(r.pos < c2)m.blocksizes.push(r.uint64());
                    } else m.blocksizes.push(r.uint64());
                    break;
                case 5:
                    m.hashType = r.uint64();
                    break;
                case 6:
                    m.fanout = r.uint64();
                    break;
                case 7:
                    m.mode = r.uint32();
                    break;
                case 8:
                    m.mtime = $root.UnixTime.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
            }
        }
        if (!m.hasOwnProperty("Type")) throw $util.ProtocolError("missing required 'Type'", {
            instance: m
        });
        return m;
    };
    /**
     * Creates a Data message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Data
     * @static
     * @param {Object.<string,*>} d Plain object
     * @returns {Data} Data
     */ Data.fromObject = function fromObject(d) {
        if (d instanceof $root.Data) return d;
        var m = new $root.Data();
        switch(d.Type){
            case "Raw":
            case 0:
                m.Type = 0;
                break;
            case "Directory":
            case 1:
                m.Type = 1;
                break;
            case "File":
            case 2:
                m.Type = 2;
                break;
            case "Metadata":
            case 3:
                m.Type = 3;
                break;
            case "Symlink":
            case 4:
                m.Type = 4;
                break;
            case "HAMTShard":
            case 5:
                m.Type = 5;
                break;
        }
        if (d.Data != null) {
            if (typeof d.Data === "string") $util.base64.decode(d.Data, m.Data = $util.newBuffer($util.base64.length(d.Data)), 0);
            else if (d.Data.length) m.Data = d.Data;
        }
        if (d.filesize != null) {
            if ($util.Long) (m.filesize = $util.Long.fromValue(d.filesize)).unsigned = true;
            else if (typeof d.filesize === "string") m.filesize = parseInt(d.filesize, 10);
            else if (typeof d.filesize === "number") m.filesize = d.filesize;
            else if (typeof d.filesize === "object") m.filesize = new $util.LongBits(d.filesize.low >>> 0, d.filesize.high >>> 0).toNumber(true);
        }
        if (d.blocksizes) {
            if (!Array.isArray(d.blocksizes)) throw TypeError(".Data.blocksizes: array expected");
            m.blocksizes = [];
            for(var i = 0; i < d.blocksizes.length; ++i){
                if ($util.Long) (m.blocksizes[i] = $util.Long.fromValue(d.blocksizes[i])).unsigned = true;
                else if (typeof d.blocksizes[i] === "string") m.blocksizes[i] = parseInt(d.blocksizes[i], 10);
                else if (typeof d.blocksizes[i] === "number") m.blocksizes[i] = d.blocksizes[i];
                else if (typeof d.blocksizes[i] === "object") m.blocksizes[i] = new $util.LongBits(d.blocksizes[i].low >>> 0, d.blocksizes[i].high >>> 0).toNumber(true);
            }
        }
        if (d.hashType != null) {
            if ($util.Long) (m.hashType = $util.Long.fromValue(d.hashType)).unsigned = true;
            else if (typeof d.hashType === "string") m.hashType = parseInt(d.hashType, 10);
            else if (typeof d.hashType === "number") m.hashType = d.hashType;
            else if (typeof d.hashType === "object") m.hashType = new $util.LongBits(d.hashType.low >>> 0, d.hashType.high >>> 0).toNumber(true);
        }
        if (d.fanout != null) {
            if ($util.Long) (m.fanout = $util.Long.fromValue(d.fanout)).unsigned = true;
            else if (typeof d.fanout === "string") m.fanout = parseInt(d.fanout, 10);
            else if (typeof d.fanout === "number") m.fanout = d.fanout;
            else if (typeof d.fanout === "object") m.fanout = new $util.LongBits(d.fanout.low >>> 0, d.fanout.high >>> 0).toNumber(true);
        }
        if (d.mode != null) {
            m.mode = d.mode >>> 0;
        }
        if (d.mtime != null) {
            if (typeof d.mtime !== "object") throw TypeError(".Data.mtime: object expected");
            m.mtime = $root.UnixTime.fromObject(d.mtime);
        }
        return m;
    };
    /**
     * Creates a plain object from a Data message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Data
     * @static
     * @param {Data} m Data
     * @param {$protobuf.IConversionOptions} [o] Conversion options
     * @returns {Object.<string,*>} Plain object
     */ Data.toObject = function toObject(m, o) {
        if (!o) o = {};
        var d = {};
        if (o.arrays || o.defaults) {
            d.blocksizes = [];
        }
        if (o.defaults) {
            d.Type = o.enums === String ? "Raw" : 0;
            if (o.bytes === String) d.Data = "";
            else {
                d.Data = [];
                if (o.bytes !== Array) d.Data = $util.newBuffer(d.Data);
            }
            if ($util.Long) {
                var n = new $util.Long(0, 0, true);
                d.filesize = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
            } else d.filesize = o.longs === String ? "0" : 0;
            if ($util.Long) {
                var n = new $util.Long(0, 0, true);
                d.hashType = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
            } else d.hashType = o.longs === String ? "0" : 0;
            if ($util.Long) {
                var n = new $util.Long(0, 0, true);
                d.fanout = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
            } else d.fanout = o.longs === String ? "0" : 0;
            d.mode = 0;
            d.mtime = null;
        }
        if (m.Type != null && m.hasOwnProperty("Type")) {
            d.Type = o.enums === String ? $root.Data.DataType[m.Type] : m.Type;
        }
        if (m.Data != null && m.hasOwnProperty("Data")) {
            d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;
        }
        if (m.filesize != null && m.hasOwnProperty("filesize")) {
            if (typeof m.filesize === "number") d.filesize = o.longs === String ? String(m.filesize) : m.filesize;
            else d.filesize = o.longs === String ? $util.Long.prototype.toString.call(m.filesize) : o.longs === Number ? new $util.LongBits(m.filesize.low >>> 0, m.filesize.high >>> 0).toNumber(true) : m.filesize;
        }
        if (m.blocksizes && m.blocksizes.length) {
            d.blocksizes = [];
            for(var j = 0; j < m.blocksizes.length; ++j){
                if (typeof m.blocksizes[j] === "number") d.blocksizes[j] = o.longs === String ? String(m.blocksizes[j]) : m.blocksizes[j];
                else d.blocksizes[j] = o.longs === String ? $util.Long.prototype.toString.call(m.blocksizes[j]) : o.longs === Number ? new $util.LongBits(m.blocksizes[j].low >>> 0, m.blocksizes[j].high >>> 0).toNumber(true) : m.blocksizes[j];
            }
        }
        if (m.hashType != null && m.hasOwnProperty("hashType")) {
            if (typeof m.hashType === "number") d.hashType = o.longs === String ? String(m.hashType) : m.hashType;
            else d.hashType = o.longs === String ? $util.Long.prototype.toString.call(m.hashType) : o.longs === Number ? new $util.LongBits(m.hashType.low >>> 0, m.hashType.high >>> 0).toNumber(true) : m.hashType;
        }
        if (m.fanout != null && m.hasOwnProperty("fanout")) {
            if (typeof m.fanout === "number") d.fanout = o.longs === String ? String(m.fanout) : m.fanout;
            else d.fanout = o.longs === String ? $util.Long.prototype.toString.call(m.fanout) : o.longs === Number ? new $util.LongBits(m.fanout.low >>> 0, m.fanout.high >>> 0).toNumber(true) : m.fanout;
        }
        if (m.mode != null && m.hasOwnProperty("mode")) {
            d.mode = m.mode;
        }
        if (m.mtime != null && m.hasOwnProperty("mtime")) {
            d.mtime = $root.UnixTime.toObject(m.mtime, o);
        }
        return d;
    };
    /**
     * Converts this Data to JSON.
     * @function toJSON
     * @memberof Data
     * @instance
     * @returns {Object.<string,*>} JSON object
     */ Data.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$node_modules$2f$protobufjs$2f$minimal$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].util.toJSONOptions);
    };
    /**
     * DataType enum.
     * @name Data.DataType
     * @enum {number}
     * @property {number} Raw=0 Raw value
     * @property {number} Directory=1 Directory value
     * @property {number} File=2 File value
     * @property {number} Metadata=3 Metadata value
     * @property {number} Symlink=4 Symlink value
     * @property {number} HAMTShard=5 HAMTShard value
     */ Data.DataType = function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Raw"] = 0;
        values[valuesById[1] = "Directory"] = 1;
        values[valuesById[2] = "File"] = 2;
        values[valuesById[3] = "Metadata"] = 3;
        values[valuesById[4] = "Symlink"] = 4;
        values[valuesById[5] = "HAMTShard"] = 5;
        return values;
    }();
    return Data;
})();
const UnixTime = $root.UnixTime = (()=>{
    /**
     * Properties of an UnixTime.
     * @exports IUnixTime
     * @interface IUnixTime
     * @property {number} Seconds UnixTime Seconds
     * @property {number|null} [FractionalNanoseconds] UnixTime FractionalNanoseconds
     */ /**
     * Constructs a new UnixTime.
     * @exports UnixTime
     * @classdesc Represents an UnixTime.
     * @implements IUnixTime
     * @constructor
     * @param {IUnixTime=} [p] Properties to set
     */ function UnixTime(p) {
        if (p) {
            for(var ks = Object.keys(p), i = 0; i < ks.length; ++i)if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }
    }
    /**
     * UnixTime Seconds.
     * @member {number} Seconds
     * @memberof UnixTime
     * @instance
     */ UnixTime.prototype.Seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
    /**
     * UnixTime FractionalNanoseconds.
     * @member {number} FractionalNanoseconds
     * @memberof UnixTime
     * @instance
     */ UnixTime.prototype.FractionalNanoseconds = 0;
    /**
     * Encodes the specified UnixTime message. Does not implicitly {@link UnixTime.verify|verify} messages.
     * @function encode
     * @memberof UnixTime
     * @static
     * @param {IUnixTime} m UnixTime message or plain object to encode
     * @param {$protobuf.Writer} [w] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */ UnixTime.encode = function encode(m, w) {
        if (!w) w = $Writer.create();
        w.uint32(8).int64(m.Seconds);
        if (m.FractionalNanoseconds != null && Object.hasOwnProperty.call(m, "FractionalNanoseconds")) w.uint32(21).fixed32(m.FractionalNanoseconds);
        return w;
    };
    /**
     * Decodes an UnixTime message from the specified reader or buffer.
     * @function decode
     * @memberof UnixTime
     * @static
     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
     * @param {number} [l] Message length if known beforehand
     * @returns {UnixTime} UnixTime
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */ UnixTime.decode = function decode(r, l) {
        if (!(r instanceof $Reader)) r = $Reader.create(r);
        var c = l === undefined ? r.len : r.pos + l, m = new $root.UnixTime();
        while(r.pos < c){
            var t = r.uint32();
            switch(t >>> 3){
                case 1:
                    m.Seconds = r.int64();
                    break;
                case 2:
                    m.FractionalNanoseconds = r.fixed32();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
            }
        }
        if (!m.hasOwnProperty("Seconds")) throw $util.ProtocolError("missing required 'Seconds'", {
            instance: m
        });
        return m;
    };
    /**
     * Creates an UnixTime message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UnixTime
     * @static
     * @param {Object.<string,*>} d Plain object
     * @returns {UnixTime} UnixTime
     */ UnixTime.fromObject = function fromObject(d) {
        if (d instanceof $root.UnixTime) return d;
        var m = new $root.UnixTime();
        if (d.Seconds != null) {
            if ($util.Long) (m.Seconds = $util.Long.fromValue(d.Seconds)).unsigned = false;
            else if (typeof d.Seconds === "string") m.Seconds = parseInt(d.Seconds, 10);
            else if (typeof d.Seconds === "number") m.Seconds = d.Seconds;
            else if (typeof d.Seconds === "object") m.Seconds = new $util.LongBits(d.Seconds.low >>> 0, d.Seconds.high >>> 0).toNumber();
        }
        if (d.FractionalNanoseconds != null) {
            m.FractionalNanoseconds = d.FractionalNanoseconds >>> 0;
        }
        return m;
    };
    /**
     * Creates a plain object from an UnixTime message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UnixTime
     * @static
     * @param {UnixTime} m UnixTime
     * @param {$protobuf.IConversionOptions} [o] Conversion options
     * @returns {Object.<string,*>} Plain object
     */ UnixTime.toObject = function toObject(m, o) {
        if (!o) o = {};
        var d = {};
        if (o.defaults) {
            if ($util.Long) {
                var n = new $util.Long(0, 0, false);
                d.Seconds = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
            } else d.Seconds = o.longs === String ? "0" : 0;
            d.FractionalNanoseconds = 0;
        }
        if (m.Seconds != null && m.hasOwnProperty("Seconds")) {
            if (typeof m.Seconds === "number") d.Seconds = o.longs === String ? String(m.Seconds) : m.Seconds;
            else d.Seconds = o.longs === String ? $util.Long.prototype.toString.call(m.Seconds) : o.longs === Number ? new $util.LongBits(m.Seconds.low >>> 0, m.Seconds.high >>> 0).toNumber() : m.Seconds;
        }
        if (m.FractionalNanoseconds != null && m.hasOwnProperty("FractionalNanoseconds")) {
            d.FractionalNanoseconds = m.FractionalNanoseconds;
        }
        return d;
    };
    /**
     * Converts this UnixTime to JSON.
     * @function toJSON
     * @memberof UnixTime
     * @instance
     * @returns {Object.<string,*>} JSON object
     */ UnixTime.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$node_modules$2f$protobufjs$2f$minimal$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].util.toJSONOptions);
    };
    return UnixTime;
})();
const Metadata = $root.Metadata = (()=>{
    /**
     * Properties of a Metadata.
     * @exports IMetadata
     * @interface IMetadata
     * @property {string|null} [MimeType] Metadata MimeType
     */ /**
     * Constructs a new Metadata.
     * @exports Metadata
     * @classdesc Represents a Metadata.
     * @implements IMetadata
     * @constructor
     * @param {IMetadata=} [p] Properties to set
     */ function Metadata(p) {
        if (p) {
            for(var ks = Object.keys(p), i = 0; i < ks.length; ++i)if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }
    }
    /**
     * Metadata MimeType.
     * @member {string} MimeType
     * @memberof Metadata
     * @instance
     */ Metadata.prototype.MimeType = "";
    /**
     * Encodes the specified Metadata message. Does not implicitly {@link Metadata.verify|verify} messages.
     * @function encode
     * @memberof Metadata
     * @static
     * @param {IMetadata} m Metadata message or plain object to encode
     * @param {$protobuf.Writer} [w] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */ Metadata.encode = function encode(m, w) {
        if (!w) w = $Writer.create();
        if (m.MimeType != null && Object.hasOwnProperty.call(m, "MimeType")) w.uint32(10).string(m.MimeType);
        return w;
    };
    /**
     * Decodes a Metadata message from the specified reader or buffer.
     * @function decode
     * @memberof Metadata
     * @static
     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
     * @param {number} [l] Message length if known beforehand
     * @returns {Metadata} Metadata
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */ Metadata.decode = function decode(r, l) {
        if (!(r instanceof $Reader)) r = $Reader.create(r);
        var c = l === undefined ? r.len : r.pos + l, m = new $root.Metadata();
        while(r.pos < c){
            var t = r.uint32();
            switch(t >>> 3){
                case 1:
                    m.MimeType = r.string();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
            }
        }
        return m;
    };
    /**
     * Creates a Metadata message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Metadata
     * @static
     * @param {Object.<string,*>} d Plain object
     * @returns {Metadata} Metadata
     */ Metadata.fromObject = function fromObject(d) {
        if (d instanceof $root.Metadata) return d;
        var m = new $root.Metadata();
        if (d.MimeType != null) {
            m.MimeType = String(d.MimeType);
        }
        return m;
    };
    /**
     * Creates a plain object from a Metadata message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Metadata
     * @static
     * @param {Metadata} m Metadata
     * @param {$protobuf.IConversionOptions} [o] Conversion options
     * @returns {Object.<string,*>} Plain object
     */ Metadata.toObject = function toObject(m, o) {
        if (!o) o = {};
        var d = {};
        if (o.defaults) {
            d.MimeType = "";
        }
        if (m.MimeType != null && m.hasOwnProperty("MimeType")) {
            d.MimeType = m.MimeType;
        }
        return d;
    };
    /**
     * Converts this Metadata to JSON.
     * @function toJSON
     * @memberof Metadata
     * @instance
     * @returns {Object.<string,*>} JSON object
     */ Metadata.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$node_modules$2f$protobufjs$2f$minimal$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].util.toJSONOptions);
    };
    return Metadata;
})();
;
}),
"[project]/node_modules/@ipld/unixfs/src/unixfs.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// @ts-nocheck
/**
 * This is file is shadowed by api.ts and only exists so JS could import it to
 * refer to types without encountering runtime errors
 * @see https://github.com/microsoft/TypeScript/issues/41825
 */ __turbopack_context__.s([
    "NodeType",
    ()=>NodeType
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$gen$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/gen/unixfs.js [app-ssr] (ecmascript)");
;
const NodeType = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$gen$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Data"].DataType;
}),
"[project]/node_modules/@ipld/unixfs/src/codec.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DEFAULT_DIRECTORY_MODE",
    ()=>DEFAULT_DIRECTORY_MODE,
    "DEFAULT_FILE_MODE",
    ()=>DEFAULT_FILE_MODE,
    "code",
    ()=>code,
    "createAdvancedFile",
    ()=>createAdvancedFile,
    "createComplexFile",
    ()=>createComplexFile,
    "createDirectoryShard",
    ()=>createDirectoryShard,
    "createEmptyFile",
    ()=>createEmptyFile,
    "createFileChunk",
    ()=>createFileChunk,
    "createFileShard",
    ()=>createFileShard,
    "createFlatDirectory",
    ()=>createFlatDirectory,
    "createRaw",
    ()=>createRaw,
    "createShardedDirectory",
    ()=>createShardedDirectory,
    "createSimpleFile",
    ()=>createSimpleFile,
    "createSymlink",
    ()=>createSymlink,
    "cumulativeContentByteLength",
    ()=>cumulativeContentByteLength,
    "cumulativeDagByteLength",
    ()=>cumulativeDagByteLength,
    "decode",
    ()=>decode,
    "decodeMetadata",
    ()=>decodeMetadata,
    "encode",
    ()=>encode,
    "encodeAdvancedFile",
    ()=>encodeAdvancedFile,
    "encodeComplexFile",
    ()=>encodeComplexFile,
    "encodeDirectory",
    ()=>encodeDirectory,
    "encodeDirectoryMetadata",
    ()=>encodeDirectoryMetadata,
    "encodeFile",
    ()=>encodeFile,
    "encodeFileChunk",
    ()=>encodeFileChunk,
    "encodeFileShard",
    ()=>encodeFileShard,
    "encodeHAMTShard",
    ()=>encodeHAMTShard,
    "encodeLink",
    ()=>encodeLink,
    "encodeMetadata",
    ()=>encodeMetadata,
    "encodeMode",
    ()=>encodeMode,
    "encodeRaw",
    ()=>encodeRaw,
    "encodeSimpleFile",
    ()=>encodeSimpleFile,
    "encodeSymlink",
    ()=>encodeSymlink,
    "filesize",
    ()=>filesize,
    "matchFile",
    ()=>matchFile,
    "name",
    ()=>name
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-pb/src/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-pb/src/util.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/unixfs.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$gen$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/gen/unixfs.js [app-ssr] (ecmascript)");
;
;
;
;
;
/** @type {ReadonlyArray<any>} */ const EMPTY = Object.freeze([]);
const EMPTY_BUFFER = new Uint8Array(0);
const BLANK = Object.freeze({});
const DEFAULT_FILE_MODE = parseInt("0644", 8);
const DEFAULT_DIRECTORY_MODE = parseInt("0755", 8);
const code = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["code"];
const name = "UnixFS";
/**
 * @param {UnixFS.IData} data
 * @param {ReadonlyArray<UnixFS.PBLink>} links
 */ const encodePB = (data, links)=>{
    Object(globalThis).debug && console.log({
        data,
        links
    });
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encode"](// We run through prepare as links need to be sorted by name which it will
    // do.
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["prepare"]({
        Data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$gen$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Data"].encode(data).finish(),
        // We can cast to mutable array as we know no mutation occurs there
        Links: links
    }));
};
const createRaw = (content)=>({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].Raw,
        content
    });
const createEmptyFile = (metadata)=>createSimpleFile(EMPTY_BUFFER, metadata);
const createSimpleFile = (content, metadata)=>({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].File,
        layout: "simple",
        content,
        metadata: decodeMetadata(metadata)
    });
const createFileChunk = (content)=>({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].File,
        layout: "simple",
        content
    });
const createAdvancedFile = (parts, metadata)=>({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].File,
        layout: "advanced",
        parts,
        metadata: decodeMetadata(metadata)
    });
const createFileShard = (parts)=>({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].File,
        layout: "advanced",
        parts
    });
const createComplexFile = (content, parts, metadata)=>({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].File,
        layout: "complex",
        content,
        parts,
        metadata: decodeMetadata(metadata)
    });
const createFlatDirectory = (entries, metadata)=>({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].Directory,
        metadata: decodeMetadata(metadata),
        entries
    });
const createShardedDirectory = (entries, bitfield, fanout, hashType, metadata = BLANK)=>({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].HAMTShard,
        bitfield,
        fanout: readFanout(fanout),
        hashType: readInt(hashType),
        entries,
        metadata: decodeMetadata(metadata)
    });
const createDirectoryShard = (entries, bitfield, fanout, hashType)=>({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].HAMTShard,
        bitfield,
        fanout: readFanout(fanout),
        hashType: readInt(hashType),
        entries
    });
const encodeRaw = (content)=>encodePB({
        Type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].Raw,
        // TODO:
        Data: content.byteLength > 0 ? content : undefined,
        filesize: content.byteLength,
        // @ts-ignore
        blocksizes: EMPTY
    }, []);
const encodeFile = (node, ignoreMetadata = false)=>{
    const metadata = ignoreMetadata ? BLANK : Object(node).metadata;
    switch(node.layout){
        case "simple":
            return encodeSimpleFile(node.content, metadata);
        case "advanced":
            return encodeAdvancedFile(node.parts, metadata);
        case "complex":
            return encodeComplexFile(node.content, node.parts, metadata);
        default:
            throw new TypeError(`File with unknown layout "${Object(node).layout}" was passed`);
    }
};
const encodeFileChunk = (content)=>encodeSimpleFile(content, BLANK);
const encodeFileShard = (parts)=>encodePB({
        Type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].File,
        blocksizes: parts.map(contentByteLength),
        filesize: cumulativeContentByteLength(parts)
    }, parts.map(encodeLink));
const encodeAdvancedFile = (parts, metadata = BLANK)=>encodePB({
        Type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].File,
        blocksizes: parts.map(contentByteLength),
        filesize: cumulativeContentByteLength(parts),
        ...encodeMetadata(metadata)
    }, parts.map(encodeLink));
const encodeLink = (dag)=>({
        Name: "",
        Tsize: dag.dagByteLength,
        // @ts-ignore - @see https://github.com/multiformats/js-multiformats/pull/161
        Hash: dag.cid
    });
const encodeSimpleFile = (content, metadata = BLANK)=>encodePB({
        Type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].File,
        // adding empty file to both go-ipfs and js-ipfs produces block in
        // which `Data` is omitted but filesize and blocksizes are present.
        // For the sake of hash consistency we do the same.
        Data: content.byteLength > 0 ? content : undefined,
        filesize: content.byteLength,
        blocksizes: [],
        ...encodeMetadata(metadata)
    }, []);
const encodeComplexFile = (content, parts, metadata = BLANK)=>encodePB({
        Type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].File,
        Data: content,
        filesize: content.byteLength + cumulativeContentByteLength(parts),
        blocksizes: parts.map(contentByteLength)
    }, parts.map(encodeLink));
const encodeDirectory = (node)=>encodePB({
        Type: node.type,
        ...encodeDirectoryMetadata(node.metadata || BLANK)
    }, node.entries.map(encodeNamedLink));
const encodeHAMTShard = ({ bitfield, fanout, hashType, entries, metadata = BLANK })=>encodePB({
        Type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].HAMTShard,
        Data: bitfield.byteLength > 0 ? bitfield : undefined,
        fanout: readFanout(fanout),
        hashType: readInt(hashType),
        ...encodeDirectoryMetadata(metadata)
    }, entries.map(encodeNamedLink));
/**
 * @param {number} n
 * @returns {number}
 */ const readFanout = (n)=>{
    if (Math.log2(n) % 1 === 0) {
        return n;
    } else {
        throw new TypeError(`Expected hamt size to be a power of two instead got ${n}`);
    }
};
/**
 * @param {number} n
 * @returns {number}
 */ const readInt = (n)=>{
    if (Number.isInteger(n)) {
        return n;
    } else {
        throw new TypeError(`Expected an integer value instead got ${n}`);
    }
};
/**
 * @param {Uint8Array} bytes
 */ const readData = (bytes)=>bytes.byteLength > 0 ? bytes : undefined;
const createSymlink = (path, metadata = BLANK)=>({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].Symlink,
        content: path,
        metadata: decodeMetadata(metadata)
    });
const encodeSymlink = (node, ignoreMetadata = false)=>{
    const metadata = ignoreMetadata ? BLANK : Object(node).metadata;
    // We do not include filesize on symlinks because that is what go-ipfs does
    // when doing `ipfs add mysymlink`. js-ipfs on the other hand seems to store
    // it, here we choose to follow go-ipfs
    // @see https://explore.ipld.io/#/explore/QmPZ1CTc5fYErTH2XXDGrfsPsHicYXtkZeVojGycwAfm3v
    // @see https://github.com/ipfs/js-ipfs-unixfs/issues/195
    return encodePB({
        Type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].Symlink,
        Data: node.content,
        ...encodeMetadata(metadata || BLANK)
    }, []);
};
const encode = (node, root = true)=>{
    switch(node.type){
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].Raw:
            return encodeRaw(node.content);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].File:
            return encodeFile(node);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].Directory:
            return encodeDirectory(node);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].HAMTShard:
            return encodeHAMTShard(node);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].Symlink:
            return encodeSymlink(node);
        default:
            throw new Error(`Unknown node type ${Object(node).type}`);
    }
};
const decode = (bytes)=>{
    const pb = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["decode"](bytes);
    const message = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$gen$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Data"].decode(pb.Data);
    const { Type: type, Data: data, mtime, mode, blocksizes, ...rest } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$gen$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Data"].toObject(message, {
        defaults: false,
        arrays: true,
        longs: Number,
        objects: false
    });
    const metadata = {
        ...mode && {
            mode
        },
        ...decodeMtime(mtime)
    };
    /** @type {UnixFS.PBLink[]} */ const links = pb.Links;
    switch(message.Type){
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].Raw:
            return createRaw(data);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].File:
            if (links.length === 0) {
                return new SimpleFileView(data, metadata);
            } else if (data.byteLength === 0) {
                return new AdvancedFileView(decodeFileLinks(rest.blocksizes, links), metadata);
            } else {
                return new ComplexFileView(data, decodeFileLinks(rest.blocksizes, links), metadata);
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].Directory:
            return createFlatDirectory(decodeDirectoryLinks(links), metadata);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].HAMTShard:
            return createShardedDirectory(decodeDirectoryLinks(links), data || EMPTY_BUFFER, rest.fanout, rest.hashType, metadata);
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].Symlink:
            return createSymlink(data, metadata);
        default:
            throw new TypeError(`Unsupported node type ${message.Type}`);
    }
};
/**
 * @param {UnixFS.UnixTime|undefined} mtime
 */ const decodeMtime = (mtime)=>mtime == null ? undefined : {
        mtime: {
            secs: mtime.Seconds,
            nsecs: mtime.FractionalNanoseconds || 0
        }
    };
/**
 * @param {NodeType} type
 * @param {number[]|undefined} blocksizes
 */ const decodeBlocksizes = (type, blocksizes)=>{
    switch(type){
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].File:
            return blocksizes && blocksizes.length > 0 ? {
                blocksizes
            } : undefined;
        default:
            return undefined;
    }
};
/**
 *
 * @param {number[]} blocksizes
 * @param {UnixFS.PBLink[]} links
 * @returns {UnixFS.FileLink[]}
 */ const decodeFileLinks = (blocksizes, links)=>{
    const parts = [];
    const length = blocksizes.length;
    let n = 0;
    while(n < length){
        parts.push({
            cid: links[n].Hash,
            dagByteLength: links[n].Tsize || 0,
            contentByteLength: blocksizes[n]
        });
    }
    return parts;
};
/**
 * @param {UnixFS.PBLink[]} links
 * @returns {UnixFS.DirectoryEntryLink[]}
 */ const decodeDirectoryLinks = (links)=>links.map((link)=>/** @type {UnixFS.DirectoryEntryLink} */ ({
            cid: link.Hash,
            name: link.Name || "",
            dagByteLength: link.Tsize || 0
        }));
const cumulativeContentByteLength = (links)=>links.reduce((size, link)=>size + link.contentByteLength, 0);
const cumulativeDagByteLength = (root, links)=>links.reduce((size, link)=>size + link.dagByteLength, root.byteLength);
/**
 *
 * @param {UnixFS.FileLink} link
 */ const contentByteLength = (link)=>link.contentByteLength;
/**
 * @param {UnixFS.NamedDAGLink<unknown>} link
 * @returns {UnixFS.PBLink}
 */ const encodeNamedLink = ({ name, dagByteLength, cid })=>({
        Name: name,
        Tsize: dagByteLength,
        Hash: cid
    });
const encodeDirectoryMetadata = (metadata)=>encodeMetadata(metadata, DEFAULT_DIRECTORY_MODE);
const encodeMetadata = ({ mode, mtime }, defaultMode = DEFAULT_FILE_MODE)=>({
        mode: mode != null ? encodeMode(mode, defaultMode) : undefined,
        mtime: mtime != null ? encodeMTime(mtime) : undefined
    });
const decodeMetadata = (data)=>data == null ? BLANK : {
        ...data.mode == null ? undefined : {
            mode: decodeMode(data.mode)
        },
        ...data.mtime == null ? undefined : {
            mtime: data.mtime
        }
    };
/**
 * @param {UnixFS.MTime} mtime
 */ const encodeMTime = (mtime)=>{
    return mtime == null ? undefined : mtime.nsecs !== 0 ? {
        Seconds: mtime.secs,
        FractionalNanoseconds: mtime.nsecs
    } : {
        Seconds: mtime.secs
    };
};
const encodeMode = (specifiedMode, defaultMode)=>{
    const mode = specifiedMode == null ? undefined : decodeMode(specifiedMode);
    return mode === defaultMode || mode == null ? undefined : mode;
};
/**
 * @param {UnixFS.Mode} mode
 * @returns {UnixFS.Mode}
 */ const decodeMode = (mode)=>mode & 0xfff | mode & 0xfffff000;
const matchFile = ({ content = EMPTY_BUFFER, parts = EMPTY, metadata = BLANK, ...rest })=>{
    if (parts.length === 0) {
        return new SimpleFileView(content, metadata);
    } else if (content.byteLength === 0) {
        return new AdvancedFileView(parts, metadata);
    } else {
        return new ComplexFileView(content, parts, metadata);
    }
};
/**
 * @implements {UnixFS.SimpleFile}
 */ class SimpleFileView {
    /**
   * @param {Uint8Array} content
   * @param {UnixFS.Metadata} metadata
   */ constructor(content, metadata){
        this.content = content;
        this.metadata = metadata;
        /**
     * @readonly
     * @type {"simple"}
     */ this.layout = "simple";
        /**
     * @readonly
     * @type {NodeType.File}
     */ this.type = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].File;
    }
    get filesize() {
        return this.content.byteLength;
    }
    encode() {
        return encodeSimpleFile(this.content, this.metadata);
    }
}
/**
 * @implements {UnixFS.AdvancedFile}
 */ class AdvancedFileView {
    /**
   * @param {ReadonlyArray<UnixFS.FileLink>} parts
   * @param {UnixFS.Metadata} metadata
   */ constructor(parts, metadata){
        this.parts = parts;
        this.metadata = metadata;
    }
    /** @type {"advanced"} */ get layout() {
        return "advanced";
    }
    /**
   * @returns {NodeType.File}
   */ get type() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].File;
    }
    get fileSize() {
        return cumulativeContentByteLength(this.parts);
    }
    get blockSizes() {
        return this.parts.map(contentByteLength);
    }
    encode() {
        return encodeAdvancedFile(this.parts, this.metadata);
    }
}
/**
 * @implements {UnixFS.ComplexFile}
 */ class ComplexFileView {
    /**
   * @param {Uint8Array} content
   * @param {ReadonlyArray<UnixFS.FileLink>} parts
   * @param {UnixFS.Metadata} metadata
   */ constructor(content, parts, metadata){
        this.content = content;
        this.parts = parts;
        this.metadata = metadata;
    }
    /** @type {"complex"} */ get layout() {
        return "complex";
    }
    /**
   * @returns {NodeType.File}
   */ get type() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].File;
    }
    get fileSize() {
        return this.content.byteLength + cumulativeContentByteLength(this.parts);
    }
    get blockSizes() {
        return this.parts.map(contentByteLength);
    }
    encode() {
        return encodeComplexFile(this.content, this.parts, this.metadata);
    }
}
const filesize = (node)=>{
    switch(node.type){
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].Raw:
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].Symlink:
            return node.content.byteLength;
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].File:
            switch(node.layout){
                case "simple":
                    return node.content.byteLength;
                case "advanced":
                    return cumulativeContentByteLength(node.parts);
                case "complex":
                    return node.content.byteLength + cumulativeContentByteLength(node.parts);
            }
        default:
            return 0;
    }
};
}),
"[project]/node_modules/@ipld/unixfs/src/codec.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DEFAULT_DIRECTORY_MODE",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["DEFAULT_DIRECTORY_MODE"],
    "DEFAULT_FILE_MODE",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["DEFAULT_FILE_MODE"],
    "NodeType",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"],
    "code",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["code"],
    "createAdvancedFile",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createAdvancedFile"],
    "createComplexFile",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createComplexFile"],
    "createDirectoryShard",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createDirectoryShard"],
    "createEmptyFile",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createEmptyFile"],
    "createFileChunk",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createFileChunk"],
    "createFileShard",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createFileShard"],
    "createFlatDirectory",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createFlatDirectory"],
    "createRaw",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createRaw"],
    "createShardedDirectory",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createShardedDirectory"],
    "createSimpleFile",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createSimpleFile"],
    "createSymlink",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createSymlink"],
    "cumulativeContentByteLength",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["cumulativeContentByteLength"],
    "cumulativeDagByteLength",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["cumulativeDagByteLength"],
    "decode",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["decode"],
    "decodeMetadata",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["decodeMetadata"],
    "encode",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encode"],
    "encodeAdvancedFile",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encodeAdvancedFile"],
    "encodeComplexFile",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encodeComplexFile"],
    "encodeDirectory",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encodeDirectory"],
    "encodeDirectoryMetadata",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encodeDirectoryMetadata"],
    "encodeFile",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encodeFile"],
    "encodeFileChunk",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encodeFileChunk"],
    "encodeFileShard",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encodeFileShard"],
    "encodeHAMTShard",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encodeHAMTShard"],
    "encodeLink",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encodeLink"],
    "encodeMetadata",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encodeMetadata"],
    "encodeMode",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encodeMode"],
    "encodeRaw",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encodeRaw"],
    "encodeSimpleFile",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encodeSimpleFile"],
    "encodeSymlink",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encodeSymlink"],
    "filesize",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["filesize"],
    "matchFile",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["matchFile"],
    "name",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["name"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/codec.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/unixfs.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/@ipld/unixfs/src/file/layout/api.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// @ts-nocheck
/**
 * This is file is shadowed by api.ts and only exists so JS could import it to
 * refer to types without encountering runtime errors
 * @see https://github.com/microsoft/TypeScript/issues/41825
 */ __turbopack_context__.s([]);
}),
"[project]/node_modules/@ipld/unixfs/src/file/chunker/indexed.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Indexed",
    ()=>Indexed
]);
function Indexed() {}
Object.defineProperties(Indexed, {
    prototype: {
        value: new Proxy(Object.prototype, {
            /**
       * @param {object} target
       * @param {PropertyKey} property
       * @param {{get(key:PropertyKey): any}} receiver
       */ get (target, property, receiver) {
                return typeof property === "symbol" ? Reflect.get(target, property, receiver) : receiver.get(property);
            }
        })
    }
});
;
}),
"[project]/node_modules/@ipld/unixfs/src/file/chunker/buffer.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "copyTo",
    ()=>copyTo,
    "create",
    ()=>create,
    "empty",
    ()=>empty,
    "get",
    ()=>get,
    "iterate",
    ()=>iterate,
    "push",
    ()=>push,
    "slice",
    ()=>slice
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2f$chunker$2f$indexed$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/file/chunker/indexed.js [app-ssr] (ecmascript)");
;
const empty = ()=>new BufferView();
const create = (segments, byteOffset = 0, byteLength = totalByteLength(segments))=>new BufferView(segments, byteOffset, byteLength);
/**
 *
 * @param {Uint8Array[]} segments
 * @returns
 */ const totalByteLength = (segments)=>{
    let byteLength = 0;
    for (const segment of segments){
        byteLength += segment.byteLength;
    }
    return byteLength;
};
const slice = (buffer, startOffset = 0, endOffset = buffer.byteLength)=>{
    const segments = [];
    const start = startOffset < 0 ? buffer.byteLength - startOffset : startOffset;
    const end = endOffset < 0 ? buffer.byteLength - endOffset : endOffset;
    // If start at 0 offset and end is past buffer range it is effectively
    // as same buffer.
    if (start === 0 && end >= buffer.byteLength) {
        return buffer;
    }
    // If range is not within the current buffer just create an empty slice.
    if (start > end || start > buffer.byteLength || end <= 0) {
        return empty();
    }
    let byteLength = 0;
    let offset = 0;
    for (const segment of buffer.segments){
        const nextOffset = offset + segment.byteLength;
        // Have not found a start yet
        if (byteLength === 0) {
            // If end offset is within the current segment we know start is also,
            // because it preceeds the end & we had not found start yet.
            // In such case we create a view with only single segment of bytes
            // in the range.
            if (end <= nextOffset) {
                const range = segment.subarray(start - offset, end - offset);
                segments.push(range);
                byteLength = range.byteLength;
                break;
            } else if (start < nextOffset) {
                const range = start === offset ? segment : segment.subarray(start - offset);
                segments.push(range);
                byteLength = range.byteLength;
            }
        } else if (end <= nextOffset) {
            const range = end === nextOffset ? segment : segment.subarray(0, end - offset);
            segments.push(range);
            byteLength += range.byteLength;
            break;
        } else {
            segments.push(segment);
            byteLength += segment.byteLength;
        }
        offset = nextOffset;
    }
    return new BufferView(segments, buffer.byteOffset + start, byteLength);
};
const push = (buffer, part)=>{
    if (part.byteLength > 0) {
        // We MUTATE here but that is ok because it is out of bound for the passed
        // buffer view so there will be no visible side effects.
        buffer.segments.push(part);
        return new BufferView(buffer.segments, buffer.byteOffset, buffer.byteLength + part.byteLength);
    } else {
        return buffer;
    }
};
const get = (buffer, n)=>{
    if (n < buffer.byteLength) {
        let offset = 0;
        for (const segment of buffer.segments){
            if (n < offset + segment.byteLength) {
                return segment[n - offset];
            } else {
                offset += segment.byteLength;
            }
        }
    }
    return undefined;
};
const copyTo = (buffer, target, byteOffset)=>{
    let offset = byteOffset;
    for (const segment of buffer.segments){
        target.set(segment, offset);
        offset += segment.byteLength;
    }
    return target;
};
function* iterate(buffer) {
    for (const part of buffer.segments){
        yield* part;
    }
}
/**
 * @extends {Indexed<number>}
 */ class BufferView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2f$chunker$2f$indexed$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Indexed"] {
    /**
   * @param {Uint8Array[]} segments
   * @param {number} byteOffset
   * @param {number} byteLength
   */ constructor(segments = [], byteOffset = 0, byteLength = 0){
        super();
        /** @hide */ this.segments = segments;
        /** @readonly */ this.byteLength = byteLength;
        /** @readonly */ this.length = byteLength;
        /** @readonly */ this.byteOffset = byteOffset;
    }
    [Symbol.iterator]() {
        return iterate(this);
    }
    /**
   * @param {number} [start]
   * @param {number} [end]
   */ slice(start, end) {
        return slice(this, start, end);
    }
    /**
   * @param {number} [start]
   * @param {number} [end]
   */ subarray(start, end) {
        return slice(this, start, end);
    }
    /**
   *
   * @param {Uint8Array} bytes
   */ push(bytes) {
        return push(this, bytes);
    }
    /**
   * @param {number} n
   */ get(n) {
        return get(this, n);
    }
    /**
   *
   * @param {Uint8Array} target
   * @param {number} offset
   */ copyTo(target, offset) {
        return copyTo(this, target, offset);
    }
}
}),
"[project]/node_modules/@ipld/unixfs/src/file/chunker/api.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// @ts-nocheck
/**
 * This is file is shadowed by api.ts and only exists so JS could import it to
 * refer to types without encountering runtime errors
 * @see https://github.com/microsoft/TypeScript/issues/41825
 */ __turbopack_context__.s([]);
}),
"[project]/node_modules/@ipld/unixfs/src/writer/util.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @param {string} reason
 * @returns {never}
 */ __turbopack_context__.s([
    "EMPTY",
    ()=>EMPTY,
    "EMPTY_BUFFER",
    ()=>EMPTY_BUFFER,
    "panic",
    ()=>panic,
    "unreachable",
    ()=>unreachable
]);
const panic = (reason)=>{
    throw new Error(reason);
};
const unreachable = (template, subject, ...substitutions)=>panic(String.raw(template, JSON.stringify(subject), ...substitutions));
const EMPTY_BUFFER = new Uint8Array(0);
const EMPTY = [];
}),
"[project]/node_modules/@ipld/unixfs/src/file/chunker.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "close",
    ()=>close,
    "open",
    ()=>open,
    "split",
    ()=>split,
    "write",
    ()=>write
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2f$chunker$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/file/chunker/buffer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2f$chunker$2f$api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/file/chunker/api.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$writer$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/writer/util.js [app-ssr] (ecmascript)");
;
;
;
;
const open = (config)=>({
        config,
        buffer: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2f$chunker$2f$buffer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["empty"]()
    });
const write = (state, bytes)=>bytes.byteLength > 0 ? split(state.config, state.buffer.push(bytes), false) : {
        ...state,
        chunks: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$writer$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EMPTY"]
    };
const close = (state)=>split(state.config, state.buffer, true);
const split = (config, buffer, end)=>{
    const chunker = config.chunker;
    const chunks = [];
    let offset = 0;
    for (const size of chunker.cut(chunker.context, buffer, end)){
        // We may be splitting empty buffer in which case there will be no chunks
        // in it so we make sure that we do not emit empty buffer.
        if (size > 0) {
            const chunk = buffer.subarray(offset, offset + size);
            chunks.push(chunk);
            offset += size;
        }
    }
    return {
        config,
        chunks,
        buffer: buffer.subarray(offset)
    };
};
}),
"[project]/node_modules/@ipld/unixfs/src/file/layout/queue/api.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// @ts-nocheck
/**
 * This is file is shadowed by api.ts and only exists so JS could import it to
 * refer to types without encountering runtime errors
 * @see https://github.com/microsoft/TypeScript/issues/41825
 */ __turbopack_context__.s([]);
}),
"[project]/node_modules/@ipld/unixfs/src/file/layout/queue.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "addLink",
    ()=>addLink,
    "addLinks",
    ()=>addLinks,
    "addNode",
    ()=>addNode,
    "addNodes",
    ()=>addNodes,
    "empty",
    ()=>empty,
    "isEmpty",
    ()=>isEmpty,
    "mutable",
    ()=>mutable
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2f$layout$2f$api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/file/layout/api.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2f$layout$2f$queue$2f$api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/file/layout/queue/api.js [app-ssr] (ecmascript)");
;
;
;
const empty = ()=>({
        mutable: false,
        needs: {},
        nodes: {},
        links: {},
        linked: []
    });
const mutable = ()=>({
        mutable: true,
        needs: {},
        nodes: {},
        links: {},
        linked: EMPTY
    });
const addNode = (node, queue)=>addNodes([
        node
    ], queue);
const addNodes = (newNodes, input)=>{
    let queue = patch(input, {});
    for (const node of newNodes){
        const { ready, has, wants } = collect(node.children, queue.links);
        // If node isn't waiting on any of the children it's ready to be linked
        // so we add linked node diretly.
        if (wants.length === 0) {
            queue = patch(queue, {
                links: assign(undefined, has),
                linked: [
                    {
                        id: node.id,
                        links: ready
                    }
                ]
            });
        } else {
            queue = patch(queue, {
                needs: assign(node.id, wants),
                nodes: {
                    [node.id]: {
                        children: node.children,
                        count: wants.length
                    }
                }
            });
        }
    }
    return queue;
};
const addLink = (id, link, queue)=>{
    const nodeID = queue.needs[id];
    const node = queue.nodes[nodeID];
    // We have node than needs this link.
    if (node != null) {
        // This is the only link it needed so we materialize the node and remove
        // links and needs associated with it.
        if (node.count === 1) {
            const { ready, has } = collect(node.children, {
                ...queue.links,
                [id]: link
            });
            return patch(queue, {
                needs: {
                    [id]: undefined
                },
                links: assign(undefined, has),
                nodes: {
                    [nodeID]: undefined
                },
                linked: [
                    {
                        id: nodeID,
                        links: ready
                    }
                ]
            });
        } else {
            return patch(queue, {
                needs: {
                    [id]: undefined
                },
                links: {
                    [id]: link
                },
                nodes: {
                    [nodeID]: {
                        ...node,
                        count: node.count - 1
                    }
                }
            });
        }
    } else {
        return patch(queue, {
            links: {
                [id]: link
            }
        });
    }
};
/**
 *
 * @param {Queue.Queue} queue
 * @param {Queue.Delta} delta
 */ const patch = (queue, { needs, nodes, links, linked })=>{
    const result = queue.mutable ? queue : {
        ...queue
    };
    const original = queue.mutable ? BLANK : undefined;
    if (needs) {
        result.needs = patchDict(queue.needs, needs, original);
    }
    if (nodes) {
        result.nodes = patchDict(queue.nodes, nodes, original);
    }
    if (links) {
        result.links = patchDict(queue.links, links, original);
    }
    result.linked = linked ? append(queue.linked || EMPTY, linked, EMPTY) : queue.linked || [];
    return result;
};
/**
 * @template V
 * @template {PropertyKey} K
 * @param {V} value
 * @param {K[]} keys
 * @returns {Record<K, V>}
 */ const assign = (value, keys)=>{
    const delta = {};
    for (const key of keys){
        delta[key] = value;
    }
    return delta;
};
/**
 * @template {PropertyKey} K
 * @template V
 * @param {Record<K, V>} target
 *
 * @param {Record<K, V|void>} delta
 * @param {Record<K, V>} original
 * @returns {Record<K, V>}
 */ const patchDict = (target, delta, original = target)=>{
    const result = target === original ? {
        ...target
    } : target;
    for (const entry of Object.entries(delta)){
        const [id, value] = entry;
        if (value == null) {
            delete result[id];
        } else {
            result[id] = value;
        }
    }
    return result;
};
const addLinks = (entries, queue)=>{
    for (const [id, link] of entries){
        queue = addLink(id, link, queue);
    }
    return queue;
};
const isEmpty = (queue)=>Object.keys(queue.nodes).length === 0 && Object.keys(queue.links).length === 0;
/**
 * @template T
 * @param {T[]} target
 * @param {T[]} items
 * @param {T[]} original
 */ const append = (target, items, original = target)=>{
    if (target === original) {
        return [
            ...target,
            ...items
        ];
    } else {
        for (const item of items){
            target.push(item);
        }
        return target;
    }
};
/**
 * @param {Queue.NodeID[]} children
 * @param {Record<Queue.NodeID, Queue.Link>} source
 * @returns {{has:Queue.NodeID[], wants:Queue.NodeID[], ready:Queue.Link[]}}
 */ const collect = (children, source)=>{
    const has = [];
    const wants = [];
    const ready = [];
    for (const child of children){
        const link = source[child];
        if (link) {
            has.push(child);
            ready.push(link);
        } else {
            wants.push(child);
        }
    }
    return {
        has,
        wants,
        ready
    };
};
const EMPTY = Object.freeze([]);
const BLANK = Object.freeze({});
}),
"[project]/node_modules/@ipld/unixfs/src/file/writer.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "close",
    ()=>close,
    "encodeBranch",
    ()=>encodeBranch,
    "init",
    ()=>init,
    "link",
    ()=>link,
    "update",
    ()=>update,
    "write",
    ()=>write,
    "writeBlock",
    ()=>writeBlock
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$actor$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/actor/src/lib.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2f$api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/file/api.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2f$layout$2f$api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/file/layout/api.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/codec.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/unixfs.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2f$chunker$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/file/chunker.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$writer$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/writer/util.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2f$layout$2f$queue$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/file/layout/queue.js [app-ssr] (ecmascript) <locals>");
;
;
;
;
;
;
;
const update = (message, state)=>{
    switch(message.type){
        case "write":
            return write(state, message.bytes);
        case "link":
            return link(state, message.link);
        /* c8 ignore next 2 */ case "block":
            return {
                state,
                effect: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$actor$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["none"]()
            };
        case "close":
            return close(state);
        case "end":
            return {
                state,
                effect: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$actor$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["none"]()
            };
        default:
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$writer$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unreachable"]`File Writer got unknown message ${message}`;
    }
};
const init = (writer, metadata, config)=>{
    return {
        status: "open",
        metadata,
        config,
        writer,
        chunker: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2f$chunker$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["open"]({
            chunker: config.chunker
        }),
        layout: config.fileLayout.open(),
        // Note: Writing in large slices e.g. 1GiB at a time creates large queues
        // with around `16353` items. Immutable version ends up copying it every
        // time state of the queue changes, which introduces significant overhead.
        // To avoid this overhead we use mutable implementation which is API
        // compatible but makes in place updates.
        // TODO: We should consider using Persistent bit-partitioned vector tries
        // instead of arrays which would provide immutable interface with neglegable
        // overhead.
        // @see https://github.com/Gozala/vectrie
        nodeQueue: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2f$layout$2f$queue$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["mutable"]()
    };
};
const write = (state, bytes)=>{
    if (state.status === "open") {
        // Chunk up provided bytes
        const { chunks, ...chunker } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2f$chunker$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["write"](state.chunker, bytes);
        // Pass chunks to layout engine to produce nodes
        const { nodes, leaves, layout } = state.config.fileLayout.write(state.layout, chunks);
        const { linked, ...nodeQueue } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2f$layout$2f$queue$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["addNodes"](nodes, state.nodeQueue);
        // Create leaf encode tasks for all new leaves
        const tasks = [
            ...encodeLeaves(leaves, state.config),
            ...encodeBranches(linked, state.config)
        ];
        return {
            state: {
                ...state,
                chunker,
                layout,
                nodeQueue
            },
            effect: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$actor$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["listen"]({
                link: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$actor$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["effects"](tasks)
            })
        };
    } else {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$writer$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["panic"])("Unable to perform write on closed file");
    }
};
const link = (state, { id, link, block })=>{
    let { linked, ...nodeQueue } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2f$layout$2f$queue$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["addLink"](id, link, state.nodeQueue);
    const tasks = encodeBranches(linked, state.config);
    /** @type {State<Layout>} */ const newState = state.status === "closed" && id === state.rootID ? {
        ...state,
        status: "linked",
        link,
        nodeQueue
    } : {
        ...state,
        nodeQueue
    };
    // If we just linked a root and there is a **suspended** "end" task we create
    // a task to resume it.
    const end = state.status === "closed" && id === state.rootID && state.end ? state.end.resume() : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$actor$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["none"]();
    return {
        state: newState,
        effect: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$actor$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["listen"]({
            link: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$actor$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["effects"](tasks),
            block: writeBlock(state.writer, block),
            end
        })
    };
};
const close = (state)=>{
    if (state.status === "open") {
        const { chunks } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2f$chunker$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["close"](state.chunker);
        const { layout, ...write } = state.config.fileLayout.write(state.layout, chunks);
        const { root, ...close } = state.config.fileLayout.close(layout, state.metadata);
        const [nodes, leaves] = isLeafNode(root) ? [
            [
                ...write.nodes,
                ...close.nodes
            ],
            [
                ...write.leaves,
                ...close.leaves,
                root
            ]
        ] : [
            [
                ...write.nodes,
                ...close.nodes,
                root
            ],
            [
                ...write.leaves,
                ...close.leaves
            ]
        ];
        const { linked, ...nodeQueue } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2f$layout$2f$queue$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["addNodes"](nodes, state.nodeQueue);
        const tasks = [
            ...encodeLeaves(leaves, state.config),
            ...encodeBranches(linked, state.config)
        ];
        // We want to keep run loop around until root node is linked. To
        // accomplish this we fork a task that suspends itself, which we will
        // resume when root is linked (see link function).
        // Below we join this forked task in our effect, this way effect is not
        // complete until task forked task is, which will do once we link the
        // root.
        const fork = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$actor$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fork"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$actor$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["suspend"]());
        return {
            state: {
                ...state,
                chunker: null,
                layout: null,
                rootID: root.id,
                status: "closed",
                end: fork,
                nodeQueue
            },
            effect: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$actor$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["listen"]({
                link: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$actor$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["effects"](tasks),
                end: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$actor$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["join"](fork)
            })
        };
    } else {
        return {
            state,
            effect: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$actor$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["none"]()
        };
    }
};
/**
 * Creates concurrent leaf encode tasks. Each one will have an ID corresponding
 * to index in the queue.
 *
 * @param {Layout.Leaf[]} leaves
 * @param {API.EncoderSettings} config
 */ const encodeLeaves = (leaves, config)=>leaves.map((leaf)=>encodeLeaf(config, leaf, config.fileChunkEncoder));
/**
 * @param {API.EncoderSettings} config
 * @param {Layout.Leaf} leaf
 * @param {API.FileChunkEncoder} encoder
 * @returns {Task.Task<API.EncodedFile, never>}
 */ const encodeLeaf = function*({ hasher, linker }, { id, content }, encoder) {
    const bytes = encoder.encode(content ? asUint8Array(content) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$writer$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EMPTY_BUFFER"]);
    const hash = yield* __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$actor$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["wait"](hasher.digest(bytes));
    const cid = linker.createLink(encoder.code, hash);
    const block = {
        cid,
        bytes
    };
    const link = {
        cid,
        contentByteLength: content ? content.byteLength : 0,
        dagByteLength: bytes.byteLength
    };
    return {
        id,
        block,
        link
    };
};
/**
 * @param {Queue.LinkedNode[]} nodes
 * @param {API.EncoderSettings} config
 */ const encodeBranches = (nodes, config)=>nodes.map((node)=>encodeBranch(config, node));
const encodeBranch = function*(config, { id, links }, metadata) {
    const bytes = config.fileEncoder.encode({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NodeType"].File,
        layout: "advanced",
        parts: links,
        metadata
    });
    const hash = yield* __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$actor$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["wait"](Promise.resolve(config.hasher.digest(bytes)));
    const cid = config.linker.createLink(config.fileEncoder.code, hash);
    const block = {
        bytes,
        cid
    };
    const link = {
        cid,
        contentByteLength: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["cumulativeContentByteLength"](links),
        dagByteLength: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["cumulativeDagByteLength"](bytes, links)
    };
    return {
        id,
        block,
        link
    };
};
const writeBlock = function*(writer, block) {
    if ((writer.desiredSize || 0) <= 0) {
        yield* __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$actor$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["wait"](writer.ready);
    }
    writer.write(block);
};
/**
 *
 * @param {Uint8Array|Chunker.Chunk} buffer
 * @returns
 */ const asUint8Array = (buffer)=>buffer instanceof Uint8Array ? buffer : buffer.copyTo(new Uint8Array(buffer.byteLength), 0);
/**
 * @param {Layout.Node} node
 * @returns {node is Layout.Leaf}
 */ const isLeafNode = (node)=>node.children == null;
}),
"[project]/node_modules/@ipld/unixfs/src/file/chunker/fixed.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "context",
    ()=>context,
    "cut",
    ()=>cut,
    "name",
    ()=>name,
    "type",
    ()=>type,
    "withMaxChunkSize",
    ()=>withMaxChunkSize
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2f$chunker$2f$api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/file/chunker/api.js [app-ssr] (ecmascript)");
;
const name = "fixed";
const context = {
    maxChunkSize: 262144
};
const type = "Stateless";
const withMaxChunkSize = (maxChunkSize)=>({
        type: "Stateless",
        context: {
            maxChunkSize
        },
        name,
        cut
    });
const cut = ({ maxChunkSize }, { byteLength }, end)=>{
    // number of fixed size chunks that would fit
    const n = byteLength / maxChunkSize | 0;
    const chunks = new Array(n).fill(maxChunkSize);
    const lastChunkSize = end ? byteLength - n * maxChunkSize : 0;
    if (lastChunkSize > 0) {
        chunks.push(lastChunkSize);
    }
    return chunks;
};
}),
"[project]/node_modules/@ipld/unixfs/src/file/layout/balanced.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "close",
    ()=>close,
    "defaults",
    ()=>defaults,
    "flush",
    ()=>flush,
    "open",
    ()=>open,
    "withWidth",
    ()=>withWidth,
    "write",
    ()=>write
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2f$layout$2f$api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/file/layout/api.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2f$chunker$2f$api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/file/chunker/api.js [app-ssr] (ecmascript)");
;
;
/**
 * Type representing a state of the balanced tree. First row hold leaves coming
 * into a builder, once number of leaves in the stack reaches `maxChildren` they
 * are moved into `RootNode` instance which is pushed into the next row of nodes.
 * If next row now contains `maxChildren` nodes from there are again moved into
 * a new `RootNode` and pushed into next row etc...
 *
 * For illustration let's assume we have `maxChildren: 3`, after 3 leafs were
 * added tree will have following layout
 *
 * ```
 *           (root1)
 *              |
 *    ----------------------
 *    |         |          |
 * (leaf1)   (leaf2)    (leaf3)
 * ```
 *
 * Which in our model before flushing is represented as follows:
 *
 * ```js
 * {
 *    width: 3
 *    leafIndex: [leaf1, leaf2, leaf3]
 *    nodeIndex: []
 *    nodes: []
 * }
 * ```
 *
 * After flushing 3 leaves (which is width) are moved into a `RootNode` that
 * is added to `nodes` array (and returned so that caller can create a block).
 * Additionally position of the added node is captured in the `index` at an
 * appropriate depth `0` (that is because we don't count leaves into depth).
 *
 * ```js
 * {
 *    width: 3
 *    leafIndex: []
 *    nodeIndex: [[0]]
 *    nodes: [new RootNode([leaf1, leaf2, leaf3])]
 * }
 * ```
 *
 * Increasing number of leaves to 10 would produce following tree layout
 *
 *```
 *                                                         (root7)
 *                                                           |
 *                                    ------------------------------------------
 *                                    |                                        |
 *                                 (root4)                                  (root6)
 *                                    |                                        |
 *            -------------------------------------------------                |
 *            |                       |                       |                |
 *         (root1)                 (root2)                 (root3)          (root5)
 *            |                       |                       |                |
 *    --------|--------       --------|--------       --------|--------        |
 *    |       |       |       |       |       |       |       |       |        |
 * (leaf1) (leaf2) (leaf3) (leaf4) (leaf5) (leaf6) (leaf7) (leaf8) (leaf9) (leaf10)
 * ```
 *
 * Which in our model will look as follows (note we do not have root5 - root7
 * in model because they are build once width is reached or once builder is
 * closed)
 *
 * ```js
 * {
 *    width: 3
 *    leafIndex: [leaf10]
 *    nodeIndex: [
 *      [0, 1, 2], // [r1, r2, r3]
 *      [3]        // [r4]
 *     ]
 *    nodes: [
 *      new Node([leaf1, leaf2, leaf3]), // r1
 *      new Node([leaf4, leaf5, leaf6]), // r2
 *      new Node([leaf7, leaf8, leaf9]), // r3
 *      new Node([ // r4
 *         new Node([leaf1, leaf2, leaf3]), // r1
 *         new Node([leaf4, leaf5, leaf6]), // r2
 *         new Node([leaf7, leaf8, leaf9]), // r3
 *      ])
 *    ]
 * }
 * ```
 *
 * @typedef {{
 * width: number
 * head: Chunker.Chunk | null
 * leafIndex: number[]
 * nodeIndex: number[][]
 * lastID: number
 * }} Balanced
 */ class Node {
    /**
   *
   * @param {number} id
   * @param {number[]} children
   * @param {Layout.Metadata} [metadata]
   */ constructor(id, children, metadata){
        this.id = id;
        this.children = children;
        this.metadata = metadata;
    }
}
const withWidth = (width)=>({
        open: ()=>open({
                width
            }),
        write,
        close
    });
const defaults = {
    width: 174
};
const open = ({ width } = defaults)=>({
        width,
        head: null,
        leafIndex: [],
        nodeIndex: [],
        lastID: 0
    });
const write = (layout, chunks)=>{
    if (chunks.length === 0) {
        return {
            layout,
            nodes: EMPTY,
            leaves: EMPTY
        };
    } else {
        let { lastID } = layout;
        // We need to hold on to the first chunk until we either get a second chunk
        // (at which point we know our layout will have branches) or until we close
        // (at which point our layout will be single leaf or node depneding on
        // metadata)
        const [head, slices] = layout.head ? // chunks weren't empty) so we process head along with other chunks.
        [
            null,
            (chunks.unshift(layout.head), chunks)
        ] : // until we can decide what to do with it.
        chunks.length === 1 && layout.leafIndex.length === 0 ? [
            chunks[0],
            EMPTY
        ] : // node.
        [
            null,
            chunks
        ];
        if (slices.length === 0) {
            return {
                layout: {
                    ...layout,
                    head
                },
                nodes: EMPTY,
                leaves: EMPTY
            };
        } else {
            const leafIndex = [
                ...layout.leafIndex
            ];
            const leaves = [];
            for (const chunk of slices){
                const leaf = {
                    id: ++lastID,
                    content: chunk
                };
                leaves.push(leaf);
                leafIndex.push(leaf.id);
            }
            if (leafIndex.length > layout.width) {
                return flush({
                    ...layout,
                    leafIndex,
                    head,
                    lastID
                }, leaves);
            } else {
                return {
                    layout: {
                        ...layout,
                        head,
                        leafIndex,
                        lastID
                    },
                    leaves,
                    nodes: EMPTY
                };
            }
        }
    }
};
const flush = (state, leaves = EMPTY, nodes = [], close = false)=>{
    let { lastID } = state;
    const nodeIndex = state.nodeIndex.map((row)=>[
            ...row
        ]);
    const leafIndex = [
        ...state.leafIndex
    ];
    const { width } = state;
    // Move leaves into nodes
    while(leafIndex.length > width || leafIndex.length > 0 && close){
        grow(nodeIndex, 1);
        const node = new Node(++lastID, leafIndex.splice(0, width));
        nodeIndex[0].push(node.id);
        nodes.push(node);
    }
    let depth = 0;
    while(depth < nodeIndex.length){
        const row = nodeIndex[depth];
        depth++;
        while(row.length > width || row.length > 0 && close && depth < nodeIndex.length){
            const node = new Node(++lastID, row.splice(0, width));
            grow(nodeIndex, depth + 1);
            nodeIndex[depth].push(node.id);
            nodes.push(node);
        }
    }
    return {
        layout: {
            ...state,
            lastID,
            leafIndex,
            nodeIndex
        },
        leaves,
        nodes
    };
};
const close = (layout, metadata)=>{
    const state = layout;
    if (layout.head) {
        return {
            root: {
                id: 1,
                content: layout.head,
                metadata
            },
            leaves: EMPTY,
            nodes: EMPTY
        };
    } else if (layout.leafIndex.length === 0) {
        return {
            root: {
                id: 1,
                metadata
            },
            leaves: EMPTY,
            nodes: EMPTY
        };
    } else {
        // Flush with width 1 so all the items will be propagate up the tree
        // and height of `depth-1` so we propagate nodes all but from the top
        // most level
        const { nodes, layout } = flush(state, EMPTY, [], true);
        const { nodeIndex } = layout;
        const height = nodeIndex.length - 1;
        const top = nodeIndex[height];
        if (top.length === 1) {
            const root = nodes[nodes.length - 1];
            nodes.length = nodes.length - 1;
            return {
                root,
                nodes,
                leaves: EMPTY
            };
        } else {
            const root = new Node(layout.lastID + 1, top, metadata);
            return {
                root,
                nodes,
                leaves: EMPTY
            };
        }
    }
};
/**
 * @template T
 * @param {T[][]} index
 * @param {number} length
 */ const grow = (index, length)=>{
    while(index.length < length){
        index.push([]);
    }
    return index;
};
/** @type {never[]} */ const EMPTY = [];
}),
"[project]/node_modules/@ipld/unixfs/src/file.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "UnixFSLeaf",
    ()=>UnixFSLeaf,
    "UnixFSRawLeaf",
    ()=>UnixFSRawLeaf,
    "close",
    ()=>close,
    "configure",
    ()=>configure,
    "create",
    ()=>create,
    "defaults",
    ()=>defaults,
    "write",
    ()=>write
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2f$api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/file/api.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/codec.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/codec.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2f$writer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/file/writer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$actor$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/actor/src/lib.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$writer$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/writer/util.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2f$chunker$2f$fixed$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/file/chunker/fixed.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$sha2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/hashes/sha2.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/cid.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2f$layout$2f$balanced$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/file/layout/balanced.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
const defaults = ()=>({
        chunker: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2f$chunker$2f$fixed$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__,
        fileChunkEncoder: UnixFSLeaf,
        smallFileEncoder: UnixFSLeaf,
        fileEncoder: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__,
        fileLayout: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2f$layout$2f$balanced$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["withWidth"](174),
        hasher: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$sha2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sha256"],
        linker: {
            createLink: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].createV1
        }
    });
const configure = (config)=>({
        ...defaults(),
        ...config
    });
const UnixFSLeaf = {
    code: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.code,
    name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.name,
    encode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.encodeFileChunk
};
const UnixFSRawLeaf = {
    code: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.code,
    name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.name,
    encode: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__.encodeRaw
};
const create = ({ writer, metadata = {}, settings = defaults() })=>new FileWriterView(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2f$writer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["init"](writer, metadata, configure(settings)));
const write = async (view, bytes)=>{
    await perform(view, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$actor$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["send"]({
        type: "write",
        bytes
    }));
    return view;
};
const close = async (view, { releaseLock = false, closeWriter = false } = {})=>{
    await perform(view, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$actor$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["send"]({
        type: "close"
    }));
    const { state } = view;
    if (state.status === "linked") {
        if (closeWriter) {
            await view.state.writer.close();
        } else if (releaseLock) {
            view.state.writer.releaseLock();
        }
        return state.link;
    /* c8 ignore next 5 */ } else {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$writer$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["panic"])(`Expected writer to be in 'linked' state after close, but it is in "${state.status}" instead`);
    }
};
/**
 * @template T
 * @param {API.View<T>} view
 * @param {Task.Effect<Writer.Message>} effect
 */ const perform = (view, effect)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$actor$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fork"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$actor$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["loop"](effect, (message)=>{
        const { state, effect } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2f$writer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["update"](message, view.state);
        view.state = state;
        return effect;
    }));
/**
 * @template Layout
 * @implements {API.View<Layout>}
 */ class FileWriterView {
    /**
   * @param {Writer.State<Layout>} state
   */ constructor(state){
        this.state = state;
    }
    get writer() {
        return this.state.writer;
    }
    get settings() {
        return this.state.config;
    }
    /**
   * @param {Uint8Array} bytes
   * @returns {Promise<API.View<Layout>>}
   */ write(bytes) {
        return write(this, bytes);
    }
    /**
   * @param {API.CloseOptions} [options]
   * @returns {Promise<UnixFS.FileLink>}
   */ close(options) {
        return close(this, options);
    }
}
}),
"[project]/node_modules/@ipld/unixfs/src/directory/api.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// @ts-nocheck
/**
 * This is file is shadowed by api.ts and only exists so JS could import it to
 * refer to types without encountering runtime errors
 * @see https://github.com/microsoft/TypeScript/issues/41825
 */ __turbopack_context__.s([]);
}),
"[project]/node_modules/@ipld/unixfs/src/directory.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "close",
    ()=>close,
    "configure",
    ()=>configure,
    "create",
    ()=>create,
    "defaults",
    ()=>defaults,
    "fork",
    ()=>fork,
    "links",
    ()=>links,
    "remove",
    ()=>remove,
    "set",
    ()=>set
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$directory$2f$api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/directory/api.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/file.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/codec.js [app-ssr] (ecmascript) <locals>");
;
;
;
;
const configure = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["configure"];
const defaults = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["defaults"];
const create = ({ writer, settings = defaults(), metadata = {} })=>new DirectoryWriter({
        writer,
        metadata,
        settings,
        entries: new Map(),
        closed: false
    });
const set = (view, name, link, { overwrite = false } = {})=>{
    const writable = asWritable(view.state);
    if (name.includes("/")) {
        throw new Error(`Directory entry name "${name}" contains forbidden "/" character`);
    }
    if (!overwrite && writable.entries.has(name)) {
        throw new Error(`Directory already contains entry with name "${name}"`);
    } else {
        writable.entries.set(name, link);
        return view;
    }
};
const remove = (view, name)=>{
    const writer = asWritable(view.state);
    writer.entries.delete(name);
    return view;
};
/**
 * @template {API.State} Writer
 * @param {Writer} writer
 * @returns {Writer}
 */ const asWritable = (writer)=>{
    if (!writer.closed) {
        return writer;
    } else {
        throw new Error(`Can not change written directory, but you can .fork() and make changes to it`);
    }
};
const close = async (view, { closeWriter = false, releaseLock = false } = {})=>{
    const { writer, settings, metadata } = asWritable(view.state);
    view.state.closed = true;
    const entries = [
        ...links(view)
    ];
    const node = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createFlatDirectory"](entries, metadata);
    const bytes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encodeDirectory"](node);
    const digest = await settings.hasher.digest(bytes);
    /** @type {UnixFS.Link<UnixFS.Directory>} */ const cid = settings.linker.createLink(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["code"], digest);
    // we make sure that writer has some capacity for this write. If it
    // does not we await.
    if ((writer.desiredSize || 0) <= 0) {
        await writer.ready;
    }
    // once writer has some capacity we write a block, however we do not
    // await completion as we don't care when it's taken off the stream.
    writer.write({
        cid,
        bytes
    });
    if (closeWriter) {
        await writer.close();
    } else if (releaseLock) {
        writer.releaseLock();
    }
    return {
        cid,
        dagByteLength: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["cumulativeDagByteLength"](bytes, entries)
    };
};
const links = function*({ state }) {
    for (const [name, { dagByteLength, cid }] of state.entries){
        yield {
            name,
            dagByteLength,
            cid
        };
    }
};
const fork = ({ state }, { writer = state.writer, metadata = state.metadata, settings = state.settings } = {})=>new DirectoryWriter({
        writer,
        metadata,
        settings,
        entries: new Map(state.entries.entries()),
        closed: false
    });
/**
 * @template [Layout=unknown]
 * @implements {API.View<Layout>}
 */ class DirectoryWriter {
    /**
   * @param {API.State<Layout>} state
   */ constructor(state){
        this.state = state;
    }
    get writer() {
        return this.state.writer;
    }
    get settings() {
        return this.state.settings;
    }
    links() {
        return links(this);
    }
    /**
   * @param {string} name
   * @param {UnixFS.FileLink | UnixFS.DirectoryLink} link
   * @param {API.WriteOptions} [options]
   */ set(name, link, options) {
        return set(this, name, link, options);
    }
    /**
   * @param {string} name
   */ remove(name) {
        return remove(this, name);
    }
    /**
   * @template L
   * @param {Partial<API.Options<L>>} [options]
   * @returns {API.View<Layout|L>}
   */ fork(options) {
        return fork(this, options);
    }
    /**
   * @param {API.CloseOptions} [options]
   * @returns {Promise<UnixFS.DirectoryLink>}
   */ close(options) {
        return close(this, options);
    }
    entries() {
        return this.state.entries.entries();
    }
    /**
   * @param {string} name
   */ has(name) {
        return this.state.entries.has(name);
    }
    get size() {
        return this.state.entries.size;
    }
}
}),
"[project]/node_modules/@ipld/unixfs/src/sharded-directory.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "close",
    ()=>close,
    "configure",
    ()=>configure,
    "create",
    ()=>create,
    "defaults",
    ()=>defaults,
    "fork",
    ()=>fork
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/lib.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/unixfs.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-pb/src/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$murmur3$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/murmur3/src/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$block$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/block.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$directory$2f$api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/directory/api.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/file.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/codec.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$directory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/directory.js [app-ssr] (ecmascript) <locals>");
;
;
;
;
;
;
;
;
;
;
;
const configure = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["configure"];
const defaults = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["defaults"];
const create = ({ writer, settings = defaults(), metadata = {} })=>new HAMTDirectoryWriter({
        writer,
        metadata,
        settings,
        entries: new HashMap(),
        closed: false
    });
/**
 * @template {API.State} Writer
 * @param {Writer} writer
 * @returns {Writer}
 */ const asWritable = (writer)=>{
    if (!writer.closed) {
        return writer;
    } else {
        throw new Error("Can not change written HAMT directory, but you can .fork() and make changes to it");
    }
};
const close = async (view, { closeWriter = false, releaseLock = false } = {})=>{
    const { writer, settings, metadata } = asWritable(view.state);
    view.state.closed = true;
    const { entries } = view.state;
    /* c8 ignore next 3 */ if (!(entries instanceof HashMap)) {
        throw new Error(`not a HAMT: ${entries}`);
    }
    const hamt = entries.builder.build();
    const blocks = iterateBlocks(hamt, hamt.root, settings);
    /** @type {UnixFS.BlockView<UnixFS.DirectoryShard>?} */ let root = null;
    for await (const block of blocks){
        root = block;
        // we make sure that writer has some capacity for this write. If it
        // does not we await.
        if ((writer.desiredSize || 0) <= 0) {
            await writer.ready;
        }
        // once writer has some capacity we write a block, however we do not
        // await completion as we don't care when it's taken off the stream.
        writer.write(block);
    }
    /* c8 ignore next */ if (root == null) throw new Error("no root block yielded");
    if (closeWriter) {
        await writer.close();
    } else if (releaseLock) {
        writer.releaseLock();
    }
    return {
        cid: root.cid,
        dagByteLength: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["cumulativeDagByteLength"](root.bytes, root.value.entries)
    };
};
/**
 * @template {unknown} Layout
 * @param {UnixFSPermaMap.PersistentHashMap<API.EntryLink>} hamt
 * @param {UnixFSPermaMap.BitmapIndexedNode<API.EntryLink>} node
 * @param {API.EncoderSettings<Layout>} settings
 * @returns {AsyncIterableIterator<UnixFS.BlockView<UnixFS.DirectoryShard>>}
 */ const iterateBlocks = async function*(hamt, node, settings) {
    /** @type {UnixFS.DirectoryEntryLink[]} */ const entries = [];
    for (const ent of __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["iterate"](node)){
        if ('key' in ent) {
            entries.push({
                name: `${ent.prefix ?? ''}${ent.key ?? ''}`,
                dagByteLength: ent.value.dagByteLength,
                cid: ent.value.cid
            });
        } else {
            /** @type {UnixFS.BlockView<UnixFS.DirectoryShard>?} */ let root = null;
            for await (const block of iterateBlocks(hamt, ent.node, settings)){
                yield block;
                root = block;
            }
            /* c8 ignore next */ if (root == null) throw new Error("no root block yielded");
            entries.push({
                name: ent.prefix,
                dagByteLength: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["cumulativeDagByteLength"](root.bytes, root.value.entries),
                cid: root.cid
            });
        }
    }
    const shard = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createDirectoryShard"](entries, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bitField"](node), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["tableSize"](hamt), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$murmur3$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["murmur364"].code);
    yield await encodeHAMTShardBlock(shard, settings);
};
/**
 * @template {unknown} Layout
 * @param {UnixFS.DirectoryShard} shard
 * @param {API.EncoderSettings<Layout>} settings
 * @returns {Promise<UnixFS.BlockView<UnixFS.DirectoryShard>>}
 */ async function encodeHAMTShardBlock(shard, settings) {
    const bytes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encodeHAMTShard"](shard);
    const hash = await settings.hasher.digest(bytes);
    const cid = settings.linker.createLink(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["code"], hash);
    // @ts-ignore Link is not CID
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$block$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Block"]({
        cid,
        bytes,
        value: shard
    });
}
const fork = ({ state }, { writer = state.writer, metadata = state.metadata, settings = state.settings } = {})=>new HAMTDirectoryWriter({
        writer,
        metadata,
        settings,
        entries: new HashMap(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["from"](state.entries.entries()).createBuilder()),
        closed: false
    });
/**
 * @template [Layout=unknown]
 * @implements {API.View<Layout>}
 */ class HAMTDirectoryWriter {
    /**
   * @param {API.State<Layout>} state
   */ constructor(state){
        this.state = state;
    }
    get writer() {
        return this.state.writer;
    }
    get settings() {
        return this.state.settings;
    }
    /**
   * @param {string} name
   * @param {UnixFS.FileLink | UnixFS.DirectoryLink} link
   * @param {API.WriteOptions} [options]
   */ set(name, link, options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$directory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["set"])(this, name, link, options);
    }
    /**
   * @param {string} name
   */ remove(name) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$directory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["remove"])(this, name);
    }
    /**
   * @template L
   * @param {Partial<API.Options<L>>} [options]
   * @returns {API.View<Layout|L>}
   */ fork(options) {
        return fork(this, options);
    }
    /**
   * @param {API.CloseOptions} [options]
   * @returns {Promise<UnixFS.DirectoryLink>}
   */ close(options) {
        return close(this, options);
    }
    entries() {
        return this.state.entries.entries();
    }
    /**
   * @param {string} name
   */ has(name) {
        return this.state.entries.has(name);
    }
    get size() {
        return this.state.entries.size;
    }
}
/**
 * @implements {Map<string, API.EntryLink>}
 */ class HashMap extends Map {
    /**
   * @param {UnixFSPermaMap.HashMapBuilder} [builder]
   */ constructor(builder = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["builder"]()){
        super();
        /** @type {UnixFSPermaMap.HashMapBuilder} */ this.builder = builder;
    }
    clear() {
        this.builder = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$unixfs$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["builder"]();
    }
    /**
   * @param {string} key
   */ delete(key) {
        const { root } = this.builder;
        this.builder.delete(key);
        return this.builder.root !== root;
    }
    /**
   * @param {(value: API.EntryLink, key: string, map: Map<string, API.EntryLink>) => void} callbackfn
   * @param {any} [thisArg]
   */ forEach(callbackfn, thisArg = this) {
        for (const [k, v] of this.builder.root.entries()){
            callbackfn.call(thisArg, v, k, this);
        }
    }
    /**
   * @param {string} key
   */ get(key) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["get"](this.builder, key);
    }
    /**
   * @param {string} key
   */ has(key) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["has"](this.builder, key);
    }
    /**
   * @param {string} key 
   * @param {API.EntryLink} value 
   */ set(key, value) {
        this.builder.set(key, value);
        return this;
    }
    get size() {
        return this.builder.size;
    }
    [Symbol.iterator]() {
        return this.builder.root.entries();
    }
    entries() {
        return this.builder.root.entries();
    }
    keys() {
        return this.builder.root.keys();
    }
    values() {
        return this.builder.root.values();
    }
}
}),
"[project]/node_modules/@ipld/unixfs/src/lib.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BLOCK_SIZE_LIMIT",
    ()=>BLOCK_SIZE_LIMIT,
    "close",
    ()=>close,
    "createWriter",
    ()=>createWriter,
    "defaultCapacity",
    ()=>defaultCapacity,
    "withCapacity",
    ()=>withCapacity
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/api.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/file.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$directory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/directory.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$codec$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/codec.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$sharded$2d$directory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/sharded-directory.js [app-ssr] (ecmascript) <locals>");
;
;
;
;
;
;
;
;
const createWriter = ({ writable, settings = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["defaults"]() })=>new FileSystemWriter({
        writer: writable.getWriter(),
        settings
    });
const close = async (view, { releaseLock = true, closeWriter = true } = {})=>{
    if (closeWriter) {
        await view.writer.close();
    } else if (releaseLock) {
        view.writer.releaseLock();
    }
    return view;
};
/**
 * @template [Layout=unknown]
 * @implemets {API.View<Layout>}
 */ class FileSystemWriter {
    /**
   * @param {object} options
   * @param {API.BlockWriter} options.writer
   * @param {Partial<API.EncoderSettings<Layout>>} options.settings
   */ constructor({ writer, settings }){
        this.writer = writer;
        this.settings = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["configure"](settings);
    }
    /**
   * @template [L=unknown]
   * @param {API.WriterOptions<L|Layout>} config
   */ createFileWriter({ settings = this.settings, metadata } = {}) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["create"]({
            writer: this.writer,
            settings,
            metadata
        });
    }
    /**
   * @template [L=unknown]
   * @param {API.WriterOptions<L|Layout>} config
   */ createDirectoryWriter({ settings = this.settings, metadata } = {}) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$directory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["create"]({
            writer: this.writer,
            settings,
            metadata
        });
    }
    /**
   * @param {API.CloseOptions} [options]
   */ close(options) {
        return close(this, options);
    }
}
const BLOCK_SIZE_LIMIT = 1048576 // 1 MB
;
const defaultCapacity = BLOCK_SIZE_LIMIT * 100;
const withCapacity = (byteLength = defaultCapacity)=>({
        highWaterMark: byteLength,
        size: (block)=>block.bytes.length
    });
}),
"[project]/node_modules/@ipld/unixfs/src/file.js [app-ssr] (ecmascript) <locals> <export create as createFileWriter>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createFileWriter",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["create"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$file$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/file.js [app-ssr] (ecmascript) <locals>");
}),
"[project]/node_modules/@ipld/unixfs/src/directory.js [app-ssr] (ecmascript) <locals> <export create as createDirectoryWriter>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createDirectoryWriter",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$directory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["create"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$directory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/directory.js [app-ssr] (ecmascript) <locals>");
}),
"[project]/node_modules/@ipld/unixfs/src/sharded-directory.js [app-ssr] (ecmascript) <locals> <export create as createShardedDirectoryWriter>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createShardedDirectoryWriter",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$sharded$2d$directory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["create"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$unixfs$2f$src$2f$sharded$2d$directory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/unixfs/src/sharded-directory.js [app-ssr] (ecmascript) <locals>");
}),
];

//# sourceMappingURL=node_modules_%40ipld_unixfs_53a2c087._.js.map