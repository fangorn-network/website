{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/capabilities/dist/utils.js"],"sourcesContent":["import * as API from '@ucanto/interface';\nimport { DID, Schema, fail, ok } from '@ucanto/validator';\nimport { equals } from 'multiformats/bytes';\nimport { base58btc } from 'multiformats/bases/base58';\n// e.g. did:web:storacha.network or did:web:staging.storacha.network\nexport const ProviderDID = DID.match({ method: 'web' });\nexport const SpaceDID = DID.match({ method: 'key' });\nexport const AccountDID = DID.match({ method: 'mailto' });\nexport const Await = Schema.struct({\n    'ucan/await': Schema.tuple([Schema.string(), Schema.link()]),\n});\n/**\n *\n * Check URI can be delegated.\n *\n * @param {string} [child]\n * @param {string} [parent]\n */\nexport function canDelegateURI(child, parent) {\n    if (parent === undefined) {\n        return ok({});\n    }\n    if (child !== undefined && parent.endsWith('*')) {\n        return child.startsWith(parent.slice(0, -1))\n            ? ok({})\n            : fail(`${child} does not match ${parent}`);\n    }\n    return child === parent\n        ? ok({})\n        : fail(`${child} is different from ${parent}`);\n}\n/**\n * Checks that `with` on claimed capability is the same as `with`\n * in delegated capability. Note this will ignore `can` field.\n *\n * @param {API.ParsedCapability} child\n * @param {API.ParsedCapability} parent\n */\nexport function equalWith(child, parent) {\n    return child.with === parent.with\n        ? ok({})\n        : fail(`Can not derive ${child.can} with ${child.with} from ${parent.with}`);\n}\n/**\n * @param {unknown} child\n * @param {unknown} parent\n * @param {string} constraint\n */\nexport function equal(child, parent, constraint) {\n    if (parent === undefined || parent === '*') {\n        return ok({});\n    }\n    else if (String(child) === String(parent)) {\n        return ok({});\n    }\n    else {\n        return fail(`Constraint violation: ${child} violates imposed ${constraint} constraint ${parent}`);\n    }\n}\n/**\n * @template {any} T\n * @param {T[]} child\n * @param {T[]} parent\n * @param {string} constraint\n */\nexport function containedWithin(child, parent, constraint) {\n    if (child.every((item) => parent.includes(item))) {\n        return ok({});\n    }\n    else {\n        return fail(`Constraint violation: ${child} violates imposed ${constraint} constraint ${parent} because it contains items not in the constraint`);\n    }\n}\n/**\n * @template {API.ParsedCapability<\"store/add\"|\"store/get\"|\"store/remove\", API.URI<'did:'>, {link?: API.Link<unknown, number, number, 0|1>}>} T\n * @param {T} claimed\n * @param {T} delegated\n * @returns {API.Result<{}, API.Failure>}\n */\nexport const equalLink = (claimed, delegated) => {\n    if (claimed.with !== delegated.with) {\n        return fail(`Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`);\n    }\n    else if (delegated.nb.link &&\n        `${delegated.nb.link}` !== `${claimed.nb.link}`) {\n        return fail(`Link ${claimed.nb.link ? `${claimed.nb.link}` : ''} violates imposed ${delegated.nb.link} constraint.`);\n    }\n    else {\n        return ok({});\n    }\n};\n/** @param {API.UnknownLink | { digest: Uint8Array }} linkOrDigest */\nconst toDigestBytes = (linkOrDigest) => 'multihash' in linkOrDigest\n    ? linkOrDigest.multihash.bytes\n    : linkOrDigest.digest;\n/**\n * @template {API.ParsedCapability<API.Ability, API.URI, { content?: API.UnknownLink | { digest: Uint8Array } }>} T\n * @param {T} claimed\n * @param {T} delegated\n * @returns {API.Result<{}, API.Failure>}\n */\nexport const equalLinkOrDigestContent = (claimed, delegated) => {\n    if (delegated.nb.content) {\n        const delegatedBytes = toDigestBytes(delegated.nb.content);\n        if (!claimed.nb.content) {\n            return fail(`Constraint violation: undefined violates imposed content constraint ${base58btc.encode(delegatedBytes)}`);\n        }\n        const claimedBytes = toDigestBytes(claimed.nb.content);\n        if (!equals(claimedBytes, delegatedBytes)) {\n            return fail(`Constraint violation: ${base58btc.encode(claimedBytes)} violates imposed content constraint ${base58btc.encode(delegatedBytes)}`);\n        }\n    }\n    return ok({});\n};\n/**\n * @template {API.ParsedCapability<API.Ability, API.URI<'did:'>, {blob: { digest: Uint8Array, size: number }}>} T\n * @param {T} claimed\n * @param {T} delegated\n * @returns {API.Result<{}, API.Failure>}\n */\nexport const equalBlob = (claimed, delegated) => {\n    if (claimed.with !== delegated.with) {\n        return fail(`Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`);\n    }\n    else if (delegated.nb.blob.digest &&\n        !equals(delegated.nb.blob.digest, claimed.nb.blob.digest)) {\n        return fail(`Link ${claimed.nb.blob.digest ? `${claimed.nb.blob.digest}` : ''} violates imposed ${delegated.nb.blob.digest} constraint.`);\n    }\n    else if (claimed.nb.blob.size !== undefined &&\n        delegated.nb.blob.size !== undefined) {\n        return claimed.nb.blob.size > delegated.nb.blob.size\n            ? fail(`Size constraint violation: ${claimed.nb.blob.size} > ${delegated.nb.blob.size}`)\n            : ok({});\n    }\n    else {\n        return ok({});\n    }\n};\n/**\n * @template {API.ParsedCapability<\"http/put\", API.URI<'did:'>, {body: { digest: Uint8Array, size: number }}>} T\n * @param {T} claimed\n * @param {T} delegated\n * @returns {API.Result<{}, API.Failure>}\n */\nexport const equalBody = (claimed, delegated) => {\n    if (claimed.with !== delegated.with) {\n        return fail(`Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`);\n    }\n    else if (delegated.nb.body.digest &&\n        !equals(delegated.nb.body.digest, claimed.nb.body.digest)) {\n        return fail(`Link ${claimed.nb.body.digest ? `${claimed.nb.body.digest}` : ''} violates imposed ${delegated.nb.body.digest} constraint.`);\n    }\n    else if (claimed.nb.body.size !== undefined &&\n        delegated.nb.body.size !== undefined) {\n        return claimed.nb.body.size !== delegated.nb.body.size\n            ? fail(`Size constraint violation: ${claimed.nb.body.size} !== ${delegated.nb.body.size}`)\n            : ok({});\n    }\n    else {\n        return ok({});\n    }\n};\n/**\n * @template {API.ParsedCapability<\"blob/add\"|\"blob/remove\"|\"blob/allocate\"|\"blob/accept\"|\"http/put\", API.URI<'did:'>, {content: Uint8Array}>} T\n * @param {T} claimed\n * @param {T} delegated\n * @returns {API.Result<{}, API.Failure>}\n */\nexport const equalContent = (claimed, delegated) => {\n    if (claimed.with !== delegated.with) {\n        return fail(`Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`);\n    }\n    else if (delegated.nb.content &&\n        !equals(delegated.nb.content, claimed.nb.content)) {\n        return fail(`Link ${claimed.nb.content ? `${claimed.nb.content}` : ''} violates imposed ${delegated.nb.content} constraint.`);\n    }\n    else {\n        return ok({});\n    }\n};\n/**\n * Checks that `claimed` {@link API.Link} meets an `imposed` constraint.\n *\n * @param {API.UnknownLink} claimed\n * @param {API.UnknownLink|undefined} imposed\n * @param {string} at\n * @returns {API.Result<{}, API.Failure>}\n */\nexport const checkLink = (claimed, imposed, at) => {\n    return equal(String(claimed), imposed === undefined ? undefined : String(imposed), at);\n};\n/**\n * @template T\n * @param {API.Result<T , API.Failure>} result\n * @returns {{error: API.Failure, ok?:undefined}|undefined}\n */\nexport const and = (result) => (result.error ? result : undefined);\n/**\n *\n * @param {import('@ucanto/interface').Ability} ability\n */\nfunction parseAbility(ability) {\n    const [namespace, ...segments] = ability.split('/');\n    return { namespace, segments };\n}\n/**\n *\n * TODO: needs to account for caps derived from different namespaces like 'account/info' can be derived from 'store/add'\n *\n * @param {import('@ucanto/interface').Ability} parent\n * @param {import('@ucanto/interface').Ability} child\n */\nexport function canDelegateAbility(parent, child) {\n    const parsedParent = parseAbility(parent);\n    const parsedChild = parseAbility(child);\n    // Parent is wildcard\n    if (parsedParent.namespace === '*' && parsedParent.segments.length === 0) {\n        return true;\n    }\n    // Child is wild card so it can not be delegated from anything\n    if (parsedChild.namespace === '*' && parsedChild.segments.length === 0) {\n        return false;\n    }\n    // namespaces don't match\n    if (parsedParent.namespace !== parsedChild.namespace) {\n        return false;\n    }\n    // given that namespaces match and parent first segment is wildcard\n    if (parsedParent.segments[0] === '*') {\n        return true;\n    }\n    // Array equality\n    if (parsedParent.segments.length !== parsedChild.segments.length) {\n        return false;\n    }\n    // all segments must match\n    return parsedParent.segments.reduce((acc, v, i) => acc && parsedChild.segments[i] === v, true);\n}\n//# sourceMappingURL=utils.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 190, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/capabilities/dist/store.js"],"sourcesContent":["/**\n * Store Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as Store from '@storacha/capabilities/store'\n * ```\n *\n * @module\n */\nimport { capability, Link, Schema, ok, fail } from '@ucanto/validator';\nimport { equalLink, equalWith, SpaceDID } from './utils.js';\n// @see https://github.com/multiformats/multicodec/blob/master/table.csv#L140\nexport const code = 0x0202;\nexport const CARLink = Schema.link({ code, version: 1 });\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derived any `store/` prefixed capability for the (memory) space identified\n * by DID in the `with` field.\n *\n * @deprecated\n */\nexport const store = capability({\n    can: 'store/*',\n    /**\n     * DID of the (memory) space where CAR is intended to\n     * be stored.\n     */\n    with: SpaceDID,\n    derives: equalWith,\n});\n/**\n * `store/add` capability allows agent to store a CAR file into a (memory) space\n * identified by did:key in the `with` field. Agent must precompute CAR locally\n * and provide it's CID and size using `nb.link` and `nb.size` fields, allowing\n * a service to provision a write location for the agent to PUT or POST desired\n * CAR into.\n *\n * @deprecated\n */\nexport const add = capability({\n    can: 'store/add',\n    /**\n     * DID of the (memory) space where CAR is intended to\n     * be stored.\n     */\n    with: SpaceDID,\n    nb: Schema.struct({\n        /**\n         * CID of the CAR file to be stored. Service will provision write target\n         * for this exact CAR file for agent to PUT or POST it. Attempt to write\n         * any other content will fail.\n         */\n        link: CARLink,\n        /**\n         * Size of the CAR file to be stored. Service will provision write target\n         * for this exact size. Attempt to write a larger CAR file will fail.\n         */\n        size: Schema.integer(),\n        /**\n         * Agent may optionally provide a link to a related CAR file using `origin`\n         * field. This is useful when storing large DAGs, agent could shard it\n         * across multiple CAR files and then link each shard with a previous one.\n         *\n         * Providing this relation tells service that given CAR is shard of the\n         * larger DAG as opposed to it being intentionally partial DAG. When DAG is\n         * not sharded, there will be only one `store/add` with `origin` left out.\n         */\n        origin: Link.optional(),\n    }),\n    derives: (claim, from) => {\n        const result = equalLink(claim, from);\n        if (result.error) {\n            return result;\n        }\n        else if (claim.nb.size !== undefined && from.nb.size !== undefined) {\n            return claim.nb.size > from.nb.size\n                ? fail(`Size constraint violation: ${claim.nb.size} > ${from.nb.size}`)\n                : ok({});\n        }\n        else {\n            return ok({});\n        }\n    },\n});\n/**\n * Capability to get store metadata by shard CID.\n * Use to check for inclusion, or get shard size and origin\n *\n * `nb.link` is optional to allow delegation of `store/get`\n * capability for any shard CID. If link is specified, then the\n * capability only allows a get for that specific CID.\n *\n * When used as as an invocation, `nb.link` must be specified.\n *\n * @deprecated\n */\nexport const get = capability({\n    can: 'store/get',\n    with: SpaceDID,\n    nb: Schema.struct({\n        /**\n         * shard CID to fetch info about.\n         */\n        link: CARLink.optional(),\n    }),\n    derives: equalLink,\n});\n/**\n * Capability can be used to remove the stored CAR file from the (memory)\n * space identified by `with` field.\n *\n * @deprecated\n */\nexport const remove = capability({\n    can: 'store/remove',\n    /**\n     * DID of the (memory) space where CAR is intended to\n     * be stored.\n     */\n    with: SpaceDID,\n    nb: Schema.struct({\n        /**\n         * CID of the CAR file to be removed from the store.\n         */\n        link: CARLink,\n    }),\n    derives: equalLink,\n});\n/**\n * Capability can be invoked to request a list of stored CAR files in the\n * (memory) space identified by `with` field.\n *\n * @deprecated\n */\nexport const list = capability({\n    can: 'store/list',\n    /**\n     * DID of the (memory) space where CAR is intended to\n     * be stored.\n     */\n    with: SpaceDID,\n    nb: Schema.struct({\n        /**\n         * A pointer that can be moved back and forth on the list.\n         * It can be used to paginate a list for instance.\n         */\n        cursor: Schema.string().optional(),\n        /**\n         * Maximum number of items per page.\n         */\n        size: Schema.integer().optional(),\n        /**\n         * If true, return page of results preceding cursor. Defaults to false.\n         */\n        pre: Schema.boolean().optional(),\n    }),\n    derives: (claimed, delegated) => {\n        if (claimed.with !== delegated.with) {\n            return fail(`Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`);\n        }\n        return ok({});\n    },\n});\n/** @deprecated */\nexport const all = add.or(remove).or(list);\n// ⚠️ We export imports here so they are not omitted in generated typedes\n// @see https://github.com/microsoft/TypeScript/issues/51548\nexport { Schema, Link };\n//# sourceMappingURL=store.js.map"],"names":[],"mappings":"AAAA;;;;;;;;;CASC;;;;;;;;;;;;;;;;;;AACD;AAAA;AAAA;AAAA;AAAA;AACA;;;AAEO,MAAM,OAAO;AACb,MAAM,UAAU,6LAAM,CAAC,IAAI,CAAC;IAAE;IAAM,SAAS;AAAE;AAQ/C,MAAM,QAAQ,IAAA,wKAAU,EAAC;IAC5B,KAAK;IACL;;;KAGC,GACD,MAAM,uKAAQ;IACd,SAAS,wKAAS;AACtB;AAUO,MAAM,MAAM,IAAA,wKAAU,EAAC;IAC1B,KAAK;IACL;;;KAGC,GACD,MAAM,uKAAQ;IACd,IAAI,6LAAM,CAAC,MAAM,CAAC;QACd;;;;SAIC,GACD,MAAM;QACN;;;SAGC,GACD,MAAM,6LAAM,CAAC,OAAO;QACpB;;;;;;;;SAQC,GACD,QAAQ,yJAAI,CAAC,QAAQ;IACzB;IACA,SAAS,CAAC,OAAO;QACb,MAAM,SAAS,IAAA,wKAAS,EAAC,OAAO;QAChC,IAAI,OAAO,KAAK,EAAE;YACd,OAAO;QACX,OACK,IAAI,MAAM,EAAE,CAAC,IAAI,KAAK,aAAa,KAAK,EAAE,CAAC,IAAI,KAAK,WAAW;YAChE,OAAO,MAAM,EAAE,CAAC,IAAI,GAAG,KAAK,EAAE,CAAC,IAAI,GAC7B,IAAA,yJAAI,EAAC,CAAC,2BAA2B,EAAE,MAAM,EAAE,CAAC,IAAI,CAAC,GAAG,EAAE,KAAK,EAAE,CAAC,IAAI,EAAE,IACpE,IAAA,uJAAE,EAAC,CAAC;QACd,OACK;YACD,OAAO,IAAA,uJAAE,EAAC,CAAC;QACf;IACJ;AACJ;AAaO,MAAM,MAAM,IAAA,wKAAU,EAAC;IAC1B,KAAK;IACL,MAAM,uKAAQ;IACd,IAAI,6LAAM,CAAC,MAAM,CAAC;QACd;;SAEC,GACD,MAAM,QAAQ,QAAQ;IAC1B;IACA,SAAS,wKAAS;AACtB;AAOO,MAAM,SAAS,IAAA,wKAAU,EAAC;IAC7B,KAAK;IACL;;;KAGC,GACD,MAAM,uKAAQ;IACd,IAAI,6LAAM,CAAC,MAAM,CAAC;QACd;;SAEC,GACD,MAAM;IACV;IACA,SAAS,wKAAS;AACtB;AAOO,MAAM,OAAO,IAAA,wKAAU,EAAC;IAC3B,KAAK;IACL;;;KAGC,GACD,MAAM,uKAAQ;IACd,IAAI,6LAAM,CAAC,MAAM,CAAC;QACd;;;SAGC,GACD,QAAQ,6LAAM,CAAC,MAAM,GAAG,QAAQ;QAChC;;SAEC,GACD,MAAM,6LAAM,CAAC,OAAO,GAAG,QAAQ;QAC/B;;SAEC,GACD,KAAK,6LAAM,CAAC,OAAO,GAAG,QAAQ;IAClC;IACA,SAAS,CAAC,SAAS;QACf,IAAI,QAAQ,IAAI,KAAK,UAAU,IAAI,EAAE;YACjC,OAAO,IAAA,yJAAI,EAAC,CAAC,iBAAiB,EAAE,UAAU,IAAI,CAAC,gBAAgB,EAAE,QAAQ,IAAI,CAAC,CAAC,CAAC;QACpF;QACA,OAAO,IAAA,uJAAE,EAAC,CAAC;IACf;AACJ;AAEO,MAAM,MAAM,IAAI,EAAE,CAAC,QAAQ,EAAE,CAAC;;CAIrC,iCAAiC","ignoreList":[0]}},
    {"offset": {"line": 359, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/capabilities/dist/upload.js"],"sourcesContent":["/**\n * Upload Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as Account from '@storacha/capabilities/upload'\n * ```\n *\n * @module\n */\nimport { capability, Link, Schema, ok } from '@ucanto/validator';\nimport { codec as CAR } from '@ucanto/transport/car';\nimport { equalWith, and, equal, SpaceDID } from './utils.js';\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derived any `upload/` prefixed capability for the (memory) space identified\n * by DID in the `with` field.\n */\nexport const upload = capability({\n    can: 'upload/*',\n    /**\n     * DID of the (memory) space where upload is add to the\n     * upload list.\n     */\n    with: SpaceDID,\n    derives: equalWith,\n});\n/**\n * Schema representing a link (a.k.a CID) to a CAR file. Enforces CAR codec code and CID v1.\n */\nconst CARLink = Link.match({ code: CAR.code, version: 1 });\n/**\n * Capability allows an agent to add an arbitrary DAG (root) to the upload list\n * of the specified (memory) space (identified by did:key in the `with` field).\n * It is recommended to provide an optional list of shard links that contain\n * fragments of this DAG, as it allows system to optimize block discovery, it is\n * also a way to communicate DAG partiality - this upload contains partial DAG\n * identified by the given `root`.\n *\n * Usually when agent wants to upload a DAG it will encode it as a one or more\n * CAR files (shards) and invoke `store/add` capability for each one. Once all\n * shards are stored it will invoke `upload/add` capability (providing link to\n * a DAG root and all the shards) to add it the upload list.\n *\n * That said `upload/add` could be invoked without invoking `store/add`s e.g.\n * because another (memory) space may already have those CARs.\n *\n * Note: If DAG with the given root is already in the upload list, invocation\n * will simply update `shards` to be a union of existing and new shards.\n */\nexport const add = capability({\n    can: 'upload/add',\n    /**\n     * DID of the (memory) space where uploaded is added.\n     */\n    with: SpaceDID,\n    nb: Schema.struct({\n        /**\n         * Root CID of the DAG to be added to the upload list.\n         */\n        root: Link,\n        /**\n         * CIDs to the CAR files that contain blocks of the DAG.\n         */\n        shards: CARLink.array().optional(),\n    }),\n    derives: (self, from) => {\n        return (and(equalWith(self, from)) ||\n            and(equal(self.nb.root, from.nb.root, 'root')) ||\n            and(equal(self.nb.shards, from.nb.shards, 'shards')) ||\n            ok({}));\n    },\n});\n/**\n * Capability to get upload metadata by root CID.\n * Use to check for inclusion, or find the shards for a root.\n *\n * `nb.root` is optional to allow delegation of `upload/get`\n * capability for any root. If root is specified, then the\n * capability only allows a get for that single cid.\n *\n * When used as as an invocation, `nb.root` must be specified.\n */\nexport const get = capability({\n    can: 'upload/get',\n    with: SpaceDID,\n    nb: Schema.struct({\n        /**\n         * Root CID of the DAG to fetch upload info about.\n         */\n        root: Link.optional(),\n    }),\n    derives: (self, from) => {\n        const res = equalWith(self, from);\n        if (res.error) {\n            return res;\n        }\n        if (!from.nb.root) {\n            return res;\n        }\n        // root must match if specified in the proof\n        return equal(self.nb.root, from.nb.root, 'root');\n    },\n});\n/**\n * Capability removes an upload (identified by it's root CID) from the upload\n * list. Please note that removing an upload does not delete corresponding shards\n * from the store, however that could be done via `store/remove` invocations.\n */\nexport const remove = capability({\n    can: 'upload/remove',\n    /**\n     * DID of the (memory) space where uploaded is removed from.\n     */\n    with: SpaceDID,\n    nb: Schema.struct({\n        /**\n         * Root CID of the DAG to be removed from the upload list.\n         */\n        root: Link,\n    }),\n    derives: (self, from) => {\n        return (and(equalWith(self, from)) ||\n            and(equal(self.nb.root, from.nb.root, 'root')) ||\n            ok({}));\n    },\n});\n/**\n * Capability can be invoked to request a list of uploads in the (memory) space\n * identified by the `with` field.\n */\nexport const list = capability({\n    can: 'upload/list',\n    with: SpaceDID,\n    nb: Schema.struct({\n        /**\n         * A pointer that can be moved back and forth on the list.\n         * It can be used to paginate a list for instance.\n         */\n        cursor: Schema.string().optional(),\n        /**\n         * Maximum number of items per page.\n         */\n        size: Schema.integer().optional(),\n        /**\n         * If true, return page of results preceding cursor. Defaults to false.\n         */\n        pre: Schema.boolean().optional(),\n    }),\n});\nexport const all = add.or(remove).or(list);\n// ⚠️ We export imports here so they are not omitted in generated typedefs\n// @see https://github.com/microsoft/TypeScript/issues/51548\nexport { Link, Schema };\n//# sourceMappingURL=upload.js.map"],"names":[],"mappings":"AAAA;;;;;;;;;CASC;;;;;;;;;;;;;;AACD;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;;;AAMO,MAAM,SAAS,IAAA,wKAAU,EAAC;IAC7B,KAAK;IACL;;;KAGC,GACD,MAAM,uKAAQ;IACd,SAAS,wKAAS;AACtB;AACA;;CAEC,GACD,MAAM,UAAU,yJAAI,CAAC,KAAK,CAAC;IAAE,MAAM,wLAAG,CAAC,IAAI;IAAE,SAAS;AAAE;AAoBjD,MAAM,MAAM,IAAA,wKAAU,EAAC;IAC1B,KAAK;IACL;;KAEC,GACD,MAAM,uKAAQ;IACd,IAAI,6LAAM,CAAC,MAAM,CAAC;QACd;;SAEC,GACD,MAAM,yJAAI;QACV;;SAEC,GACD,QAAQ,QAAQ,KAAK,GAAG,QAAQ;IACpC;IACA,SAAS,CAAC,MAAM;QACZ,OAAQ,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,MAAM,UACxB,IAAA,kKAAG,EAAC,IAAA,oKAAK,EAAC,KAAK,EAAE,CAAC,IAAI,EAAE,KAAK,EAAE,CAAC,IAAI,EAAE,YACtC,IAAA,kKAAG,EAAC,IAAA,oKAAK,EAAC,KAAK,EAAE,CAAC,MAAM,EAAE,KAAK,EAAE,CAAC,MAAM,EAAE,cAC1C,IAAA,uJAAE,EAAC,CAAC;IACZ;AACJ;AAWO,MAAM,MAAM,IAAA,wKAAU,EAAC;IAC1B,KAAK;IACL,MAAM,uKAAQ;IACd,IAAI,6LAAM,CAAC,MAAM,CAAC;QACd;;SAEC,GACD,MAAM,yJAAI,CAAC,QAAQ;IACvB;IACA,SAAS,CAAC,MAAM;QACZ,MAAM,MAAM,IAAA,wKAAS,EAAC,MAAM;QAC5B,IAAI,IAAI,KAAK,EAAE;YACX,OAAO;QACX;QACA,IAAI,CAAC,KAAK,EAAE,CAAC,IAAI,EAAE;YACf,OAAO;QACX;QACA,4CAA4C;QAC5C,OAAO,IAAA,oKAAK,EAAC,KAAK,EAAE,CAAC,IAAI,EAAE,KAAK,EAAE,CAAC,IAAI,EAAE;IAC7C;AACJ;AAMO,MAAM,SAAS,IAAA,wKAAU,EAAC;IAC7B,KAAK;IACL;;KAEC,GACD,MAAM,uKAAQ;IACd,IAAI,6LAAM,CAAC,MAAM,CAAC;QACd;;SAEC,GACD,MAAM,yJAAI;IACd;IACA,SAAS,CAAC,MAAM;QACZ,OAAQ,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,MAAM,UACxB,IAAA,kKAAG,EAAC,IAAA,oKAAK,EAAC,KAAK,EAAE,CAAC,IAAI,EAAE,KAAK,EAAE,CAAC,IAAI,EAAE,YACtC,IAAA,uJAAE,EAAC,CAAC;IACZ;AACJ;AAKO,MAAM,OAAO,IAAA,wKAAU,EAAC;IAC3B,KAAK;IACL,MAAM,uKAAQ;IACd,IAAI,6LAAM,CAAC,MAAM,CAAC;QACd;;;SAGC,GACD,QAAQ,6LAAM,CAAC,MAAM,GAAG,QAAQ;QAChC;;SAEC,GACD,MAAM,6LAAM,CAAC,OAAO,GAAG,QAAQ;QAC/B;;SAEC,GACD,KAAK,6LAAM,CAAC,OAAO,GAAG,QAAQ;IAClC;AACJ;AACO,MAAM,MAAM,IAAI,EAAE,CAAC,QAAQ,EAAE,CAAC;;CAIrC,kCAAkC","ignoreList":[0]}},
    {"offset": {"line": 481, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/capabilities/dist/top.js"],"sourcesContent":["/**\n * Top Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as Account from '@storacha/capabilities/top'\n * ```\n *\n * @module\n */\nimport { capability, Schema } from '@ucanto/validator';\nimport { equalWith } from './utils.js';\n/**\n * Represents the top `{ can: '*', with: 'did:key:zAlice' }` capability, which we often\n * also call account linking.\n *\n * @see {@link https://github.com/ucan-wg/spec#52-top}\n */\nexport const top = capability({\n    can: '*',\n    with: Schema.or(Schema.did(), Schema.literal('ucan:*')),\n    derives: equalWith,\n});\n//# sourceMappingURL=top.js.map"],"names":[],"mappings":"AAAA;;;;;;;;;CASC;;;;AACD;AAAA;AAAA;AACA;;;AAOO,MAAM,MAAM,IAAA,wKAAU,EAAC;IAC1B,KAAK;IACL,MAAM,6LAAM,CAAC,EAAE,CAAC,6LAAM,CAAC,GAAG,IAAI,6LAAM,CAAC,OAAO,CAAC;IAC7C,SAAS,wKAAS;AACtB,IACA,+BAA+B","ignoreList":[0]}},
    {"offset": {"line": 509, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/capabilities/dist/space.js"],"sourcesContent":["/**\n * Space Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as Space from '@storacha/capabilities/space'\n * ```\n *\n * @module\n */\nimport * as Store from './store.js';\nimport { capability, Schema, ok, fail } from '@ucanto/validator';\nimport { SpaceDID, equalWith } from './utils.js';\nimport * as Upload from './upload.js';\nexport { top } from './top.js';\n// Need this to workaround TS bug\n// @see https://github.com/microsoft/TypeScript/issues/51548\nexport { Store };\nexport const space = capability({\n    can: 'space/*',\n    with: SpaceDID,\n    derives: equalWith,\n});\n/**\n * `space/info` can be derived from any of the `store/*`\n * capability that has matching `with`. This allows store service\n * to identify account based on any user request.\n */\nexport const info = Store.add\n    .or(Store.list)\n    .or(Store.remove)\n    .or(Upload.add)\n    .or(Upload.list)\n    .or(Upload.remove)\n    .derive({\n    to: capability({\n        can: 'space/info',\n        with: SpaceDID,\n    }),\n    derives: equalWith,\n});\nexport const allocate = capability({\n    can: 'space/allocate',\n    with: SpaceDID,\n    nb: Schema.struct({\n        size: Schema.integer(),\n    }),\n    derives: (child, parent) => {\n        const result = equalWith(child, parent);\n        if (result.ok) {\n            return child.nb.size <= parent.nb.size\n                ? ok({})\n                : fail(`Claimed size ${child.nb.size} escalates delegated size ${parent.nb.size}`);\n        }\n        else {\n            return result;\n        }\n    },\n});\n/**\n * The capability grants permission for all content serve operations that fall under the \"space/content/serve\" namespace.\n * It can be derived from any of the `space/*` capability that has matching `with`.\n */\nexport const contentServe = capability({\n    can: 'space/content/serve/*',\n    with: SpaceDID,\n    derives: equalWith,\n});\n/**\n * Capability can be invoked by an agent to record egress data for a given resource.\n * It can be derived from any of the `space/content/serve/*` capability that has matching `with`.\n */\nexport const egressRecord = capability({\n    can: 'space/content/serve/egress/record',\n    with: SpaceDID,\n    nb: Schema.struct({\n        /** CID of the resource that was served. */\n        resource: Schema.link(),\n        /** Amount of bytes served. */\n        bytes: Schema.integer().greaterThan(0),\n        /** Timestamp of the event in milliseconds after Unix epoch. */\n        servedAt: Schema.integer().greaterThan(-1),\n    }),\n    derives: equalWith,\n});\n/**\n * The capability grants permission to decrypt a given resource.\n * It can be derived from `space/content/decrypt` capability that has matching `with` and `nb.resource`.\n */\nexport const decrypt = capability({\n    can: 'space/content/decrypt',\n    with: SpaceDID,\n    nb: Schema.struct({\n        resource: Schema.link(),\n    }),\n    derives: (child, parent) => {\n        if (child.with !== parent.with) {\n            return fail(`Can not derive ${child.can} with ${child.with} from ${parent.with}`);\n        }\n        if (child.nb.resource.toString() !== parent.nb.resource.toString()) {\n            return fail(`Can not derive ${child.can} resource ${child.nb.resource} from ${parent.nb.resource}`);\n        }\n        return ok({});\n    },\n});\n/**\n * \"Setup encryption for a Space using asymmetric keys in KMS.\"\n *\n * A Principal who may `space/encryption/setup` is permitted to initialize\n * encryption for a Space. This generates an RSA key pair in Google KMS\n * for the Space and returns the public key that clients can use to encrypt\n * per-file symmetric keys.\n *\n * This operation is idempotent - invoking it the first time generates the\n * asymmetric key for the space, but future invocations just return the\n * existing public key.\n *\n * The Space must be provisioned for a paid plan to use encryption.\n */\nexport const EncryptionSetup = capability({\n    can: 'space/encryption/setup',\n    with: SpaceDID,\n    nb: Schema.struct({\n        /**\n         * The location of the KMS key to use for encryption. If not provided, the Storacha Key Manager will use the default location.\n         */\n        location: Schema.string().optional(),\n        /**\n         * The keyring of the KMS key to use for encryption. If not provided, the Storacha Key Manager will use the default keyring.\n         */\n        keyring: Schema.string().optional(),\n    }),\n    derives: (child, parent) => {\n        if (child.with !== parent.with) {\n            return fail(`Can not derive ${child.can} with ${child.with} from ${parent.with}`);\n        }\n        if (child.nb.location !== parent.nb.location) {\n            return fail(`Can not derive ${child.can} location ${child.nb.location} from ${parent.nb.location}`);\n        }\n        if (child.nb.keyring !== parent.nb.keyring) {\n            return fail(`Can not derive ${child.can} keyring ${child.nb.keyring} from ${parent.nb.keyring}`);\n        }\n        return ok({});\n    },\n});\n/**\n * \"Decrypt symmetric keys for encrypted content owned by the subject Space.\"\n *\n * A Principal who may `space/encryption/key/decrypt` is permitted to decrypt\n * the symmetric keys for any encrypted content owned by the Space. This capability\n * is used by the gateway to validate that a client has permission to access encrypted\n * content and receive the decrypted Data Encryption Keys (DEKs).\n *\n * The gateway will validate this capability against UCAN delegations before\n * providing decrypted Data Encryption Keys (DEKs) to authorized clients.\n */\nexport const EncryptionKeyDecrypt = capability({\n    can: 'space/encryption/key/decrypt',\n    with: SpaceDID,\n    nb: Schema.struct({\n        /**\n         * The encrypted symmetric key to be decrypted\n         */\n        key: Schema.bytes(),\n    }),\n    derives: (child, parent) => {\n        if (child.with !== parent.with) {\n            return fail(`Can not derive ${child.can} with ${child.with} from ${parent.with}`);\n        }\n        if (child.nb.key !== parent.nb.key) {\n            return fail(`Can not derive ${child.can} key ${child.nb.key} from ${parent.nb.key}`);\n        }\n        return ok({});\n    },\n});\n//# sourceMappingURL=space.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 655, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/capabilities/dist/ucan.js"],"sourcesContent":["/**\n * UCAN core capabilities.\n */\nimport { capability, Schema, ok } from '@ucanto/validator';\nimport * as API from '@ucanto/interface';\nimport { equalWith, equal, and, checkLink } from './utils.js';\nexport const UCANLink = \n/** @type {Schema.Schema<API.UCANLink, unknown>} */\n(Schema.link({ version: 1 }));\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derived any `store/` prefixed capability for the (memory) space identified\n * by DID in the `with` field.\n */\nexport const ucan = capability({\n    can: 'ucan/*',\n    with: Schema.did(),\n    derives: equalWith,\n});\n/**\n * `ucan/revoke` capability is a replacement for the\n * [UCAN Revocation](https://github.com/ucan-wg/spec#66-revocation) that had\n * been proposed to a UCAN working group and had a tentative support from\n * members.\n *\n * Capability can be used to revoke `nb.ucan` authorization from all proofs\n * chains that lead to the UCAN issued or being delegated to the principal\n * identified by the `with` field. Note that revoked UCAN MUST continue to\n * be valid in the invocation where proof chain does not lead to the principal\n * identified by the `with` field.\n */\nexport const revoke = capability({\n    can: 'ucan/revoke',\n    /**\n     * DID of the principal authorizing revocation.\n     */\n    with: Schema.did(),\n    nb: Schema.struct({\n        /**\n         * UCAN being revoked from all proof chains that lead to the UCAN that is\n         * either issued (iss) by or delegated to (aud) the principal identified\n         * by the `with` field.\n         */\n        ucan: UCANLink,\n        /**\n         * Proof chain illustrating the path from revoked UCAN to the one that is\n         * either issued (iss) by or delegated to (aud) the principal identified\n         * by the `with` field.\n         *\n         * If the UCAN being revoked is either issued (iss) by or delegated to (aud)\n         * the principal identified by the `with` field no `proof` is required and\n         * it can be omitted or set to an empty array.\n         *\n         * It is RECOMMENDED that `proof` is provided in all other cases otherwise\n         * it MAY not be possible to verify that revoking principal is a participant\n         * in the proof chain.\n         */\n        proof: UCANLink.array().optional(),\n    }),\n    derives: (claim, from) => \n    // With field MUST be the same\n    and(equalWith(claim, from)) ??\n        // UCAN being revoked MUST be the same\n        and(checkLink(claim.nb.ucan, from.nb.ucan, 'nb.ucan')) ??\n        // And proof chain MUST be the same\n        equal((claim.nb.proof ?? []).join('/'), (from.nb.proof ?? []).join('/'), 'nb.proof'),\n});\n/**\n * `ucan/conclude` capability represents a receipt using a special UCAN capability.\n *\n * The UCAN invocation specification defines receipt record, that is cryptographically\n * signed description of the invocation output and requested effects. Receipt\n * structure is very similar to UCAN except it has no notion of expiry nor it is\n * possible to delegate ability to issue receipt to another principal.\n */\nexport const conclude = capability({\n    can: 'ucan/conclude',\n    /**\n     * DID of the principal representing the Conclusion Authority.\n     * MUST be the DID of the audience of the ran invocation.\n     */\n    with: Schema.did(),\n    nb: Schema.struct({\n        /**\n         * CID of the content with the Receipt.\n         */\n        receipt: Schema.link(),\n    }),\n    derives: (claim, from) => \n    // With field MUST be the same\n    and(equalWith(claim, from)) ||\n        and(checkLink(claim.nb.receipt, from.nb.receipt, 'nb.receipt')) ||\n        ok({}),\n});\n/**\n * Issued by trusted authority (usually the one handling invocation) that attest\n * that specific UCAN delegation has been considered authentic.\n *\n * @see https://github.com/storacha/specs/blob/main/w3-session.md#authorization-session\n *\n * @example\n * ```js\n * {\n    iss: \"did:web:storacha.network\",\n    aud: \"did:key:z6Mkk89bC3JrVqKie71YEcc5M1SMVxuCgNx6zLZ8SYJsxALi\",\n    att: [{\n      \"with\": \"did:web:storacha.network\",\n      \"can\": \"ucan/attest\",\n      \"nb\": {\n        \"proof\": {\n          \"/\": \"bafyreifer23oxeyamllbmrfkkyvcqpujevuediffrpvrxmgn736f4fffui\"\n        }\n      }\n    }],\n    exp: null\n    sig: \"...\"\n  }\n * ```\n */\nexport const attest = capability({\n    can: 'ucan/attest',\n    // Should be storacha.network DID\n    with: Schema.did(),\n    nb: Schema.struct({\n        // UCAN delegation that is being attested.\n        proof: Schema.link({ version: 1 }),\n    }),\n    derives: (claim, from) => \n    // With field MUST be the same\n    and(equalWith(claim, from)) ??\n        // UCAN link MUST be the same\n        checkLink(claim.nb.proof, from.nb.proof, 'nb.proof'),\n});\n//# sourceMappingURL=ucan.js.map"],"names":[],"mappings":"AAAA;;CAEC;;;;;;;;;;;;AACD;AAAA;AAAA;AAAA;AACA;AACA;;;;AACO,MAAM,WAEZ,6LAAM,CAAC,IAAI,CAAC;IAAE,SAAS;AAAE;AAMnB,MAAM,OAAO,IAAA,wKAAU,EAAC;IAC3B,KAAK;IACL,MAAM,6LAAM,CAAC,GAAG;IAChB,SAAS,wKAAS;AACtB;AAaO,MAAM,SAAS,IAAA,wKAAU,EAAC;IAC7B,KAAK;IACL;;KAEC,GACD,MAAM,6LAAM,CAAC,GAAG;IAChB,IAAI,6LAAM,CAAC,MAAM,CAAC;QACd;;;;SAIC,GACD,MAAM;QACN;;;;;;;;;;;;SAYC,GACD,OAAO,SAAS,KAAK,GAAG,QAAQ;IACpC;IACA,SAAS,CAAC,OAAO,OACjB,8BAA8B;QAC9B,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,OAAO,UACjB,sCAAsC;QACtC,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,MAAM,EAAE,CAAC,IAAI,EAAE,KAAK,EAAE,CAAC,IAAI,EAAE,eAC3C,mCAAmC;QACnC,IAAA,oKAAK,EAAC,CAAC,MAAM,EAAE,CAAC,KAAK,IAAI,EAAE,EAAE,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,KAAK,IAAI,EAAE,EAAE,IAAI,CAAC,MAAM;AACjF;AASO,MAAM,WAAW,IAAA,wKAAU,EAAC;IAC/B,KAAK;IACL;;;KAGC,GACD,MAAM,6LAAM,CAAC,GAAG;IAChB,IAAI,6LAAM,CAAC,MAAM,CAAC;QACd;;SAEC,GACD,SAAS,6LAAM,CAAC,IAAI;IACxB;IACA,SAAS,CAAC,OAAO,OACjB,8BAA8B;QAC9B,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,OAAO,UACjB,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,MAAM,EAAE,CAAC,OAAO,EAAE,KAAK,EAAE,CAAC,OAAO,EAAE,kBACjD,IAAA,uJAAE,EAAC,CAAC;AACZ;AA0BO,MAAM,SAAS,IAAA,wKAAU,EAAC;IAC7B,KAAK;IACL,iCAAiC;IACjC,MAAM,6LAAM,CAAC,GAAG;IAChB,IAAI,6LAAM,CAAC,MAAM,CAAC;QACd,0CAA0C;QAC1C,OAAO,6LAAM,CAAC,IAAI,CAAC;YAAE,SAAS;QAAE;IACpC;IACA,SAAS,CAAC,OAAO,OACjB,8BAA8B;QAC9B,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,OAAO,UACjB,6BAA6B;QAC7B,IAAA,wKAAS,EAAC,MAAM,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,KAAK,EAAE;AACjD,IACA,gCAAgC","ignoreList":[0]}},
    {"offset": {"line": 748, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/capabilities/dist/access.js"],"sourcesContent":["/**\n * Access Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as Access from '@storacha/capabilities/access'\n * ```\n *\n * @module\n */\nimport { capability, URI, DID, Schema, fail, ok } from '@ucanto/validator';\nimport * as Types from '@ucanto/interface';\nimport { attest } from './ucan.js';\nimport { equalWith, equal, and, SpaceDID, checkLink } from './utils.js';\nexport { top } from './top.js';\n/**\n * @deprecated - Use `ucan.attest` instead.\n */\nexport const session = attest;\n/**\n * Account identifier.\n */\nexport const Account = DID.match({ method: 'mailto' });\n/**\n * Describes the capability requested.\n */\nexport const CapabilityRequest = Schema.struct({\n    /**\n     * If set to `\"*\"` it corresponds to \"sudo\" access.\n     */\n    can: Schema.string(),\n});\n/**\n * Authorization request describing set of desired capabilities.\n */\nexport const AuthorizationRequest = Schema.struct({\n    /**\n     * DID of the Account authorization is requested from.\n     */\n    iss: Account.optional(),\n    /**\n     * Capabilities agent wishes to be granted.\n     */\n    att: CapabilityRequest.array(),\n});\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derived any `access/` prefixed capability for the agent identified\n * by did:key in the `with` field.\n */\nexport const access = capability({\n    can: 'access/*',\n    with: URI.match({ protocol: 'did:' }),\n});\n/**\n * Capability can be invoked by an agent to request set of capabilities from\n * the account.\n */\nexport const authorize = capability({\n    can: 'access/authorize',\n    with: DID.match({ method: 'key' }),\n    /**\n     * Authorization request describing set of desired capabilities\n     */\n    nb: AuthorizationRequest,\n    derives: (child, parent) => {\n        return (and(equalWith(child, parent)) ||\n            and(equal(child.nb.iss, parent.nb.iss, 'iss')) ||\n            and(subsetCapabilities(child.nb.att, parent.nb.att)) ||\n            ok({}));\n    },\n});\n/**\n * Capability is delegated by us to the user allowing them to complete the\n * authorization flow. It allows us to ensure that user clicks the link and\n * we don't have some rogue agent trying to impersonate user clicking the link\n * in order to get access to their account.\n */\nexport const confirm = capability({\n    can: 'access/confirm',\n    with: DID,\n    nb: Schema.struct({\n        /**\n         * Link to the `access/authorize` request that this delegation was created\n         * for.\n         */\n        cause: Schema.link({ version: 1 }),\n        iss: Account,\n        aud: Schema.did(),\n        att: CapabilityRequest.array(),\n    }),\n    derives: (claim, proof) => {\n        return (and(equalWith(claim, proof)) ||\n            and(equal(claim.nb.iss, proof.nb.iss, 'iss')) ||\n            and(equal(claim.nb.aud, proof.nb.aud, 'aud')) ||\n            and(subsetCapabilities(claim.nb.att, proof.nb.att)) ||\n            and(checkLink(claim.nb.cause, proof.nb.cause, 'nb.cause')) ||\n            ok({}));\n    },\n});\nexport const claim = capability({\n    can: 'access/claim',\n    with: DID.match({ method: 'key' }).or(DID.match({ method: 'mailto' })),\n});\n// https://github.com/storacha/specs/blob/main/w3-access.md#accessdelegate\nexport const delegate = capability({\n    can: 'access/delegate',\n    /**\n     * Field MUST be a space DID with a storage provider. Delegation will be stored just like any other DAG stored using store/add capability.\n     *\n     * @see https://github.com/storacha/specs/blob/main/w3-access.md#delegate-with\n     */\n    with: SpaceDID,\n    nb: Schema.struct({\n        // keys SHOULD be CIDs, but we won't require it in the schema\n        /**\n         * @type {Schema.Schema<AccessDelegateDelegations>}\n         */\n        delegations: Schema.dictionary({\n            value: Schema.Link.match(),\n        }),\n    }),\n    derives: (claim, proof) => {\n        return (and(equalWith(claim, proof)) ||\n            and(subsetsNbDelegations(claim, proof)) ||\n            ok({}));\n    },\n});\n/**\n * @typedef {Schema.Dictionary<string, Types.Link<unknown, number, number, 0 | 1>>} AccessDelegateDelegations\n */\n/**\n * Parsed Capability for access/delegate\n *\n * @typedef {object} ParsedAccessDelegate\n * @property {string} can\n * @property {object} nb\n * @property {AccessDelegateDelegations} [nb.delegations]\n */\n/**\n * returns whether the claimed ucan is proves by the proof ucan.\n * both are access/delegate, or at least have same semantics for `nb.delegations`, which is a set of delegations.\n * checks that the claimed delegation set is equal to or less than the proven delegation set.\n * usable with {import('@ucanto/interface').Derives}.\n *\n * @param {ParsedAccessDelegate} claim\n * @param {ParsedAccessDelegate} proof\n */\nfunction subsetsNbDelegations(claim, proof) {\n    const missingProofs = setDifference(delegatedCids(claim), new Set(delegatedCids(proof)));\n    if (missingProofs.size > 0) {\n        return fail(`unauthorized nb.delegations ${[...missingProofs].join(', ')}`);\n    }\n    return ok({});\n}\n/**\n * Checks that set of requested capabilities is a subset of the capabilities\n * that had been allowed by the owner or the delegate.\n *\n * ⚠️ This function does not currently check that say `store/add` is allowed\n * when say `store/*` was delegated, because it seems very unlikely that we\n * will ever encounter delegations for `access/authorize` at all.\n *\n * @param {Schema.Infer<CapabilityRequest>[]} claim\n * @param {Schema.Infer<CapabilityRequest>[]} proof\n */\nconst subsetCapabilities = (claim, proof) => {\n    const allowed = new Set(proof.map((p) => p.can));\n    // If everything is allowed, no need to check further because it contains\n    // all the capabilities.\n    if (allowed.has('*')) {\n        return ok({});\n    }\n    // Otherwise we compute delta between what is allowed and what is requested.\n    const escalated = setDifference(claim.map((c) => c.can), allowed);\n    if (escalated.size > 0) {\n        return fail(`unauthorized nb.att.can ${[...escalated].join(', ')}`);\n    }\n    return ok({});\n};\n/**\n * iterate delegated UCAN CIDs from an access/delegate capability.nb.delegations value.\n *\n * @param {ParsedAccessDelegate} delegate\n * @returns {Iterable<string>}\n */\nfunction* delegatedCids(delegate) {\n    for (const d of Object.values(delegate.nb.delegations || {})) {\n        yield d.toString();\n    }\n}\n/**\n * @template S\n * @param {Iterable<S>} minuend - set to subtract from\n * @param {Set<S>} subtrahend - subtracted from minuend\n */\nfunction setDifference(minuend, subtrahend) {\n    /** @type {Set<S>} */\n    const difference = new Set();\n    for (const e of minuend) {\n        if (!subtrahend.has(e)) {\n            difference.add(e);\n        }\n    }\n    return difference;\n}\n//# sourceMappingURL=access.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 950, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/capabilities/dist/types.js"],"sourcesContent":["export {};\n//# sourceMappingURL=types.js.map"],"names":[],"mappings":";;CACA,iCAAiC","ignoreList":[0]}},
    {"offset": {"line": 957, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/capabilities/dist/provider.js"],"sourcesContent":["/**\n * Provider Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as Provider from '@storacha/capabilities/provider'\n * ```\n *\n * @module\n */\nimport { capability, DID, struct, ok } from '@ucanto/validator';\nimport { AccountDID, equalWith, and, equal, SpaceDID } from './utils.js';\n// e.g. did:web:storacha.network or did:web:staging.storacha.network\nexport const Provider = DID.match({ method: 'web' });\nexport { AccountDID };\n/**\n * Capability can be invoked by an agent to add a provider to a space.\n */\nexport const add = capability({\n    can: 'provider/add',\n    with: AccountDID,\n    nb: struct({\n        provider: Provider,\n        consumer: SpaceDID,\n    }),\n    derives: (child, parent) => {\n        return (and(equalWith(child, parent)) ||\n            and(equal(child.nb.provider, parent.nb.provider, 'provider')) ||\n            and(equal(child.nb.consumer, parent.nb.consumer, 'consumer')) ||\n            ok({}));\n    },\n});\n//# sourceMappingURL=provider.js.map"],"names":[],"mappings":"AAAA;;;;;;;;;CASC;;;;;;AACD;AAAA;AAAA;AAAA;AAAA;AACA;;;AAEO,MAAM,WAAW,wJAAG,CAAC,KAAK,CAAC;IAAE,QAAQ;AAAM;;AAK3C,MAAM,MAAM,IAAA,wKAAU,EAAC;IAC1B,KAAK;IACL,MAAM,yKAAU;IAChB,IAAI,IAAA,qKAAM,EAAC;QACP,UAAU;QACV,UAAU,uKAAQ;IACtB;IACA,SAAS,CAAC,OAAO;QACb,OAAQ,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,OAAO,YACzB,IAAA,kKAAG,EAAC,IAAA,oKAAK,EAAC,MAAM,EAAE,CAAC,QAAQ,EAAE,OAAO,EAAE,CAAC,QAAQ,EAAE,gBACjD,IAAA,kKAAG,EAAC,IAAA,oKAAK,EAAC,MAAM,EAAE,CAAC,QAAQ,EAAE,OAAO,EAAE,CAAC,QAAQ,EAAE,gBACjD,IAAA,uJAAE,EAAC,CAAC;IACZ;AACJ,IACA,oCAAoC","ignoreList":[0]}},
    {"offset": {"line": 1013, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/capabilities/dist/assert.js"],"sourcesContent":["import { capability, URI, Schema, ok } from '@ucanto/validator';\nimport { and, equal, equalLinkOrDigestContent, equalWith } from './utils.js';\nconst linkOrDigest = () => Schema.link().or(Schema.struct({ digest: Schema.bytes() }));\nexport const assert = capability({\n    can: 'assert/*',\n    with: URI.match({ protocol: 'did:' }),\n});\n/**\n * Claims that a CID is available at a URL.\n */\nexport const location = capability({\n    can: 'assert/location',\n    with: URI.match({ protocol: 'did:' }),\n    nb: Schema.struct({\n        /** Blob CID or multihash */\n        content: linkOrDigest(),\n        location: Schema.array(URI),\n        range: Schema.struct({\n            offset: Schema.integer(),\n            length: Schema.integer().optional(),\n        }).optional(),\n        space: Schema.principal().optional(),\n    }),\n    derives: (claimed, delegated) => and(equalWith(claimed, delegated)) ||\n        and(equalLinkOrDigestContent(claimed, delegated)) ||\n        and(equal(claimed.nb.location, delegated.nb.location, 'location')) ||\n        and(equal(claimed.nb.range?.offset, delegated.nb.range?.offset, 'offset')) ||\n        and(equal(claimed.nb.range?.length, delegated.nb.range?.length, 'length')) ||\n        and(equal(claimed.nb.space, delegated.nb.space, 'space')) ||\n        ok({}),\n});\n/**\n * Claims that a CID includes the contents claimed in another CID.\n */\nexport const inclusion = capability({\n    can: 'assert/inclusion',\n    with: URI.match({ protocol: 'did:' }),\n    nb: Schema.struct({\n        /** CAR CID */\n        content: linkOrDigest(),\n        /** CARv2 index CID */\n        includes: Schema.link({ version: 1 }),\n        proof: Schema.link({ version: 1 }).optional(),\n    }),\n});\n/**\n * Claims that a content graph can be found in blob(s) that are identified and\n * indexed in the given index CID.\n */\nexport const index = capability({\n    can: 'assert/index',\n    with: URI.match({ protocol: 'did:' }),\n    nb: Schema.struct({\n        /** DAG root CID */\n        content: linkOrDigest(),\n        /**\n         * Link to a Content Archive that contains the index.\n         * e.g. `index/sharded/dag@0.1`\n         *\n         * @see https://github.com/storacha/specs/blob/main/w3-index.md\n         */\n        index: Schema.link({ version: 1 }),\n    }),\n    derives: (claimed, delegated) => and(equalWith(claimed, delegated)) ||\n        and(equal(claimed.nb.content, delegated.nb.content, 'content')) ||\n        and(equal(claimed.nb.index, delegated.nb.index, 'index')) ||\n        ok({}),\n});\n/**\n * Claims that a CID's graph can be read from the blocks found in parts.\n */\nexport const partition = capability({\n    can: 'assert/partition',\n    with: URI.match({ protocol: 'did:' }),\n    nb: Schema.struct({\n        /** Content root CID */\n        content: linkOrDigest(),\n        /** CIDs CID */\n        blocks: Schema.link({ version: 1 }).optional(),\n        parts: Schema.array(Schema.link({ version: 1 })),\n    }),\n});\n/**\n * Claims that a CID links to other CIDs.\n */\nexport const relation = capability({\n    can: 'assert/relation',\n    with: URI.match({ protocol: 'did:' }),\n    nb: Schema.struct({\n        content: linkOrDigest(),\n        /** CIDs this content links to directly. */\n        children: Schema.array(Schema.link()),\n        /** Parts this content and it's children can be read from. */\n        parts: Schema.array(Schema.struct({\n            content: Schema.link({ version: 1 }),\n            /** CID of contents (CARv2 index) included in this part. */\n            includes: Schema.struct({\n                content: Schema.link({ version: 1 }),\n                /** CIDs of parts this index may be found in. */\n                parts: Schema.array(Schema.link({ version: 1 })).optional(),\n            }).optional(),\n        })),\n    }),\n});\n/**\n * Claim data is referred to by another CID and/or multihash.\n * e.g CAR CID & CommP CID\n */\nexport const equals = capability({\n    can: 'assert/equals',\n    with: URI.match({ protocol: 'did:' }),\n    nb: Schema.struct({\n        content: linkOrDigest(),\n        equals: Schema.link(),\n    }),\n    derives: (claimed, delegated) => and(equalWith(claimed, delegated)) ||\n        and(equalLinkOrDigestContent(claimed, delegated)) ||\n        and(equal(claimed.nb.equals, delegated.nb.equals, 'equals')) ||\n        ok({}),\n});\n//# sourceMappingURL=assert.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1148, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/capabilities/dist/claim.js"],"sourcesContent":["import { capability, URI, Schema, ok, fail } from '@ucanto/validator';\nimport * as Bytes from 'multiformats/bytes';\nimport { and, equal, equalWith } from './utils.js';\n/** @import * as API from '@ucanto/interface' */\nconst multiaddr = Schema.bytes();\nexport const claim = capability({\n    can: 'claim/*',\n    with: URI.match({ protocol: 'did:' }),\n});\n/**\n * Cache the provided content claim.\n */\nexport const cache = capability({\n    can: 'claim/cache',\n    with: URI.match({ protocol: 'did:' }),\n    nb: Schema.struct({\n        claim: Schema.link({ version: 1 }),\n        provider: Schema.struct({\n            addresses: Schema.array(multiaddr),\n        }),\n    }),\n    derives: (claimed, delegated) => and(equalWith(claimed, delegated)) ||\n        and(equal(claimed.nb.claim, delegated.nb.claim, 'claim')) ||\n        and(equalProviderAddresses(claimed, delegated)) ||\n        ok({}),\n});\n/**\n * @template {API.ParsedCapability<API.Ability, API.URI, { provider: { addresses: Uint8Array[] } }>} T\n * @param {T} claimed\n * @param {T} delegated\n * @returns {API.Result<{}, API.Failure>}\n */\nconst equalProviderAddresses = (claimed, delegated) => {\n    if (delegated.nb?.provider?.addresses) {\n        const delegatedAddrs = delegated.nb.provider.addresses;\n        const claimedAddrs = claimed.nb?.provider?.addresses ?? [];\n        if (claimedAddrs.length !== delegatedAddrs.length) {\n            return fail(`Constraint violation: ${claimedAddrs.length} provider addresses violates imposed constraint ${delegatedAddrs.length} provider addresses`);\n        }\n        for (let i = 0; i < delegatedAddrs.length; i++) {\n            const addr = delegatedAddrs[i];\n            const found = claimedAddrs.some((a) => Bytes.equals(addr, a));\n            if (!found) {\n                return fail(`Constraint violation: provider address ${i} is not an allowed provider address`);\n            }\n        }\n    }\n    return ok({});\n};\n//# sourceMappingURL=claim.js.map"],"names":[],"mappings":";;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;AACA,8CAA8C,GAC9C,MAAM,YAAY,6LAAM,CAAC,KAAK;AACvB,MAAM,QAAQ,IAAA,wKAAU,EAAC;IAC5B,KAAK;IACL,MAAM,wJAAG,CAAC,KAAK,CAAC;QAAE,UAAU;IAAO;AACvC;AAIO,MAAM,QAAQ,IAAA,wKAAU,EAAC;IAC5B,KAAK;IACL,MAAM,wJAAG,CAAC,KAAK,CAAC;QAAE,UAAU;IAAO;IACnC,IAAI,6LAAM,CAAC,MAAM,CAAC;QACd,OAAO,6LAAM,CAAC,IAAI,CAAC;YAAE,SAAS;QAAE;QAChC,UAAU,6LAAM,CAAC,MAAM,CAAC;YACpB,WAAW,6LAAM,CAAC,KAAK,CAAC;QAC5B;IACJ;IACA,SAAS,CAAC,SAAS,YAAc,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,SAAS,eACpD,IAAA,kKAAG,EAAC,IAAA,oKAAK,EAAC,QAAQ,EAAE,CAAC,KAAK,EAAE,UAAU,EAAE,CAAC,KAAK,EAAE,aAChD,IAAA,kKAAG,EAAC,uBAAuB,SAAS,eACpC,IAAA,uJAAE,EAAC,CAAC;AACZ;AACA;;;;;CAKC,GACD,MAAM,yBAAyB,CAAC,SAAS;IACrC,IAAI,UAAU,EAAE,EAAE,UAAU,WAAW;QACnC,MAAM,iBAAiB,UAAU,EAAE,CAAC,QAAQ,CAAC,SAAS;QACtD,MAAM,eAAe,QAAQ,EAAE,EAAE,UAAU,aAAa,EAAE;QAC1D,IAAI,aAAa,MAAM,KAAK,eAAe,MAAM,EAAE;YAC/C,OAAO,IAAA,yJAAI,EAAC,CAAC,sBAAsB,EAAE,aAAa,MAAM,CAAC,gDAAgD,EAAE,eAAe,MAAM,CAAC,mBAAmB,CAAC;QACzJ;QACA,IAAK,IAAI,IAAI,GAAG,IAAI,eAAe,MAAM,EAAE,IAAK;YAC5C,MAAM,OAAO,cAAc,CAAC,EAAE;YAC9B,MAAM,QAAQ,aAAa,IAAI,CAAC,CAAC,IAAM,8JAAY,CAAC,MAAM;YAC1D,IAAI,CAAC,OAAO;gBACR,OAAO,IAAA,yJAAI,EAAC,CAAC,uCAAuC,EAAE,EAAE,mCAAmC,CAAC;YAChG;QACJ;IACJ;IACA,OAAO,IAAA,uJAAE,EAAC,CAAC;AACf,GACA,iCAAiC","ignoreList":[0]}},
    {"offset": {"line": 1294, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/capabilities/dist/consumer.js"],"sourcesContent":["import { capability, DID, struct, ok } from '@ucanto/validator';\nimport { equalWith, and, equal, SpaceDID } from './utils.js';\n// e.g. did:web:storacha.network or did:web:staging.storacha.network\nexport const ProviderDID = DID.match({ method: 'web' });\n/**\n * Capability can be invoked by a provider to check if it has given space as\n * a consumer.\n */\nexport const has = capability({\n    can: 'consumer/has',\n    with: ProviderDID,\n    nb: struct({\n        consumer: SpaceDID,\n    }),\n    derives: (child, parent) => {\n        return (and(equalWith(child, parent)) ||\n            and(equal(child.nb.consumer, parent.nb.consumer, 'consumer')) ||\n            ok({}));\n    },\n});\n/**\n * Capability can be invoked by a provider to get information about a consumer.\n */\nexport const get = capability({\n    can: 'consumer/get',\n    with: ProviderDID,\n    nb: struct({\n        consumer: SpaceDID,\n    }),\n    derives: (child, parent) => {\n        return (and(equalWith(child, parent)) ||\n            and(equal(child.nb.consumer, parent.nb.consumer, 'consumer')) ||\n            ok({}));\n    },\n});\n//# sourceMappingURL=consumer.js.map"],"names":[],"mappings":";;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAEO,MAAM,cAAc,wJAAG,CAAC,KAAK,CAAC;IAAE,QAAQ;AAAM;AAK9C,MAAM,MAAM,IAAA,wKAAU,EAAC;IAC1B,KAAK;IACL,MAAM;IACN,IAAI,IAAA,qKAAM,EAAC;QACP,UAAU,uKAAQ;IACtB;IACA,SAAS,CAAC,OAAO;QACb,OAAQ,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,OAAO,YACzB,IAAA,kKAAG,EAAC,IAAA,oKAAK,EAAC,MAAM,EAAE,CAAC,QAAQ,EAAE,OAAO,EAAE,CAAC,QAAQ,EAAE,gBACjD,IAAA,uJAAE,EAAC,CAAC;IACZ;AACJ;AAIO,MAAM,MAAM,IAAA,wKAAU,EAAC;IAC1B,KAAK;IACL,MAAM;IACN,IAAI,IAAA,qKAAM,EAAC;QACP,UAAU,uKAAQ;IACtB;IACA,SAAS,CAAC,OAAO;QACb,OAAQ,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,OAAO,YACzB,IAAA,kKAAG,EAAC,IAAA,oKAAK,EAAC,MAAM,EAAE,CAAC,QAAQ,EAAE,OAAO,EAAE,CAAC,QAAQ,EAAE,gBACjD,IAAA,uJAAE,EAAC,CAAC;IACZ;AACJ,IACA,oCAAoC","ignoreList":[0]}},
    {"offset": {"line": 1337, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/capabilities/dist/customer.js"],"sourcesContent":["import { capability, DID, struct, ok } from '@ucanto/validator';\nimport { AccountDID, equalWith, and, equal } from './utils.js';\n// e.g. did:web:storacha.network or did:web:staging.storacha.network\nexport const ProviderDID = DID.match({ method: 'web' });\n/**\n * Capability can be invoked by a provider to get information about the\n * customer.\n */\nexport const get = capability({\n    can: 'customer/get',\n    with: ProviderDID,\n    nb: struct({\n        customer: AccountDID,\n    }),\n    derives: (child, parent) => {\n        return (and(equalWith(child, parent)) ||\n            and(equal(child.nb.customer, parent.nb.customer, 'customer')) ||\n            ok({}));\n    },\n});\n//# sourceMappingURL=customer.js.map"],"names":[],"mappings":";;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAEO,MAAM,cAAc,wJAAG,CAAC,KAAK,CAAC;IAAE,QAAQ;AAAM;AAK9C,MAAM,MAAM,IAAA,wKAAU,EAAC;IAC1B,KAAK;IACL,MAAM;IACN,IAAI,IAAA,qKAAM,EAAC;QACP,UAAU,yKAAU;IACxB;IACA,SAAS,CAAC,OAAO;QACb,OAAQ,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,OAAO,YACzB,IAAA,kKAAG,EAAC,IAAA,oKAAK,EAAC,MAAM,EAAE,CAAC,QAAQ,EAAE,OAAO,EAAE,CAAC,QAAQ,EAAE,gBACjD,IAAA,uJAAE,EAAC,CAAC;IACZ;AACJ,IACA,oCAAoC","ignoreList":[0]}},
    {"offset": {"line": 1368, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/capabilities/dist/console.js"],"sourcesContent":["import { capability, Schema } from '@ucanto/validator';\nimport { equalWith } from './utils.js';\nexport const console = capability({\n    can: 'console/*',\n    with: Schema.did(),\n    derives: equalWith,\n});\n/**\n * Capability that succeeds with the `nb.value` value.\n */\nexport const log = capability({\n    can: 'console/log',\n    with: Schema.did(),\n    nb: Schema.struct({\n        value: Schema.unknown(),\n    }),\n    derives: equalWith,\n});\n/**\n * Capability that fails with an error provided to `nb.error` field.\n */\nexport const error = capability({\n    can: 'console/error',\n    with: Schema.did(),\n    nb: Schema.struct({\n        error: Schema.unknown(),\n    }),\n    derives: equalWith,\n});\n//# sourceMappingURL=console.js.map"],"names":[],"mappings":";;;;;;;;AAAA;AAAA;AAAA;AACA;;;AACO,MAAM,UAAU,IAAA,wKAAU,EAAC;IAC9B,KAAK;IACL,MAAM,6LAAM,CAAC,GAAG;IAChB,SAAS,wKAAS;AACtB;AAIO,MAAM,MAAM,IAAA,wKAAU,EAAC;IAC1B,KAAK;IACL,MAAM,6LAAM,CAAC,GAAG;IAChB,IAAI,6LAAM,CAAC,MAAM,CAAC;QACd,OAAO,6LAAM,CAAC,OAAO;IACzB;IACA,SAAS,wKAAS;AACtB;AAIO,MAAM,QAAQ,IAAA,wKAAU,EAAC;IAC5B,KAAK;IACL,MAAM,6LAAM,CAAC,GAAG;IAChB,IAAI,6LAAM,CAAC,MAAM,CAAC;QACd,OAAO,6LAAM,CAAC,OAAO;IACzB;IACA,SAAS,wKAAS;AACtB,IACA,mCAAmC","ignoreList":[0]}},
    {"offset": {"line": 1407, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/capabilities/dist/rate-limit.js"],"sourcesContent":["/**\n * Rate Limit Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as RateLimit from '@storacha/capabilities/rate-limit'\n * ```\n *\n * @module\n */\nimport { capability, DID, struct, Schema, ok } from '@ucanto/validator';\nimport { equalWith, and, equal } from './utils.js';\n// e.g. did:web:storacha.network or did:web:staging.storacha.network\nexport const Provider = DID;\n/**\n * Capability can be invoked by the provider or an authorized delegate to add a rate limit to a subject.\n */\nexport const add = capability({\n    can: 'rate-limit/add',\n    with: Provider,\n    nb: struct({\n        subject: Schema.string(),\n        rate: Schema.number(),\n    }),\n    derives: (child, parent) => {\n        return (and(equalWith(child, parent)) ||\n            and(equal(child.nb.subject, parent.nb.subject, 'subject')) ||\n            and(equal(child.nb.rate, parent.nb.rate, 'rate')) ||\n            ok({}));\n    },\n});\n/**\n * Capability can be invoked by the provider are an authorized delegate to remove rate limits from a subject.\n */\nexport const remove = capability({\n    can: 'rate-limit/remove',\n    with: Provider,\n    nb: struct({\n        id: Schema.string(),\n    }),\n    derives: (child, parent) => {\n        return (and(equalWith(child, parent)) ||\n            and(equal(child.nb.id, parent.nb.id, 'id')) ||\n            ok({}));\n    },\n});\n/**\n * Capability can be invoked by the provider or an authorized delegate to list rate limits on the given subject\n */\nexport const list = capability({\n    can: 'rate-limit/list',\n    with: Provider,\n    nb: struct({\n        subject: Schema.string(),\n    }),\n    derives: (child, parent) => {\n        return (and(equalWith(child, parent)) ||\n            and(equal(child.nb.subject, parent.nb.subject, 'subject')) ||\n            ok({}));\n    },\n});\n//# sourceMappingURL=rate-limit.js.map"],"names":[],"mappings":"AAAA;;;;;;;;;CASC;;;;;;;;;;AACD;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAEO,MAAM,WAAW,wJAAG;AAIpB,MAAM,MAAM,IAAA,wKAAU,EAAC;IAC1B,KAAK;IACL,MAAM;IACN,IAAI,IAAA,qKAAM,EAAC;QACP,SAAS,6LAAM,CAAC,MAAM;QACtB,MAAM,6LAAM,CAAC,MAAM;IACvB;IACA,SAAS,CAAC,OAAO;QACb,OAAQ,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,OAAO,YACzB,IAAA,kKAAG,EAAC,IAAA,oKAAK,EAAC,MAAM,EAAE,CAAC,OAAO,EAAE,OAAO,EAAE,CAAC,OAAO,EAAE,eAC/C,IAAA,kKAAG,EAAC,IAAA,oKAAK,EAAC,MAAM,EAAE,CAAC,IAAI,EAAE,OAAO,EAAE,CAAC,IAAI,EAAE,YACzC,IAAA,uJAAE,EAAC,CAAC;IACZ;AACJ;AAIO,MAAM,SAAS,IAAA,wKAAU,EAAC;IAC7B,KAAK;IACL,MAAM;IACN,IAAI,IAAA,qKAAM,EAAC;QACP,IAAI,6LAAM,CAAC,MAAM;IACrB;IACA,SAAS,CAAC,OAAO;QACb,OAAQ,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,OAAO,YACzB,IAAA,kKAAG,EAAC,IAAA,oKAAK,EAAC,MAAM,EAAE,CAAC,EAAE,EAAE,OAAO,EAAE,CAAC,EAAE,EAAE,UACrC,IAAA,uJAAE,EAAC,CAAC;IACZ;AACJ;AAIO,MAAM,OAAO,IAAA,wKAAU,EAAC;IAC3B,KAAK;IACL,MAAM;IACN,IAAI,IAAA,qKAAM,EAAC;QACP,SAAS,6LAAM,CAAC,MAAM;IAC1B;IACA,SAAS,CAAC,OAAO;QACb,OAAQ,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,OAAO,YACzB,IAAA,kKAAG,EAAC,IAAA,oKAAK,EAAC,MAAM,EAAE,CAAC,OAAO,EAAE,OAAO,EAAE,CAAC,OAAO,EAAE,eAC/C,IAAA,uJAAE,EAAC,CAAC;IACZ;AACJ,IACA,sCAAsC","ignoreList":[0]}},
    {"offset": {"line": 1471, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/capabilities/dist/admin.js"],"sourcesContent":["import { capability, struct, ok, Link } from '@ucanto/validator';\nimport { equalWith, and, equal, ProviderDID } from './utils.js';\nexport const admin = capability({\n    can: 'admin/*',\n    with: ProviderDID,\n    derives: equalWith,\n});\nexport const upload = {\n    /**\n     * Capability can be invoked by a provider to get information about a content CID.\n     */\n    inspect: capability({\n        can: 'admin/upload/inspect',\n        with: ProviderDID,\n        nb: struct({\n            root: Link,\n        }),\n        derives: (child, parent) => {\n            return (and(equalWith(child, parent)) ||\n                and(equal(child.nb.root, parent.nb.root, 'root')) ||\n                ok({}));\n        },\n    }),\n};\nexport const store = {\n    /**\n     * Capability can be invoked by a provider to get information an upload shard CID.\n     */\n    inspect: capability({\n        can: 'admin/store/inspect',\n        with: ProviderDID,\n        nb: struct({\n            link: Link,\n        }),\n        derives: (child, parent) => {\n            return (and(equalWith(child, parent)) ||\n                and(equal(child.nb.link, parent.nb.link, 'link')) ||\n                ok({}));\n        },\n    }),\n};\n//# sourceMappingURL=admin.js.map"],"names":[],"mappings":";;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AACO,MAAM,QAAQ,IAAA,wKAAU,EAAC;IAC5B,KAAK;IACL,MAAM,0KAAW;IACjB,SAAS,wKAAS;AACtB;AACO,MAAM,SAAS;IAClB;;KAEC,GACD,SAAS,IAAA,wKAAU,EAAC;QAChB,KAAK;QACL,MAAM,0KAAW;QACjB,IAAI,IAAA,qKAAM,EAAC;YACP,MAAM,yJAAI;QACd;QACA,SAAS,CAAC,OAAO;YACb,OAAQ,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,OAAO,YACzB,IAAA,kKAAG,EAAC,IAAA,oKAAK,EAAC,MAAM,EAAE,CAAC,IAAI,EAAE,OAAO,EAAE,CAAC,IAAI,EAAE,YACzC,IAAA,uJAAE,EAAC,CAAC;QACZ;IACJ;AACJ;AACO,MAAM,QAAQ;IACjB;;KAEC,GACD,SAAS,IAAA,wKAAU,EAAC;QAChB,KAAK;QACL,MAAM,0KAAW;QACjB,IAAI,IAAA,qKAAM,EAAC;YACP,MAAM,yJAAI;QACd;QACA,SAAS,CAAC,OAAO;YACb,OAAQ,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,OAAO,YACzB,IAAA,kKAAG,EAAC,IAAA,oKAAK,EAAC,MAAM,EAAE,CAAC,IAAI,EAAE,OAAO,EAAE,CAAC,IAAI,EAAE,YACzC,IAAA,uJAAE,EAAC,CAAC;QACZ;IACJ;AACJ,GACA,iCAAiC","ignoreList":[0]}},
    {"offset": {"line": 1524, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/capabilities/dist/subscription.js"],"sourcesContent":["import { capability, DID, struct, ok, Schema } from '@ucanto/validator';\nimport { AccountDID, equalWith, and, equal } from './utils.js';\n// e.g. did:web:storacha.network or did:web:staging.storacha.network\nexport const ProviderDID = DID.match({ method: 'web' });\n/**\n * Capability can be invoked by a provider to get information about a subscription.\n */\nexport const get = capability({\n    can: 'subscription/get',\n    with: ProviderDID,\n    nb: struct({\n        subscription: Schema.string(),\n    }),\n    derives: (child, parent) => {\n        return (and(equalWith(child, parent)) ||\n            and(equal(child.nb.subscription, parent.nb.subscription, 'consumer')) ||\n            ok({}));\n    },\n});\n/**\n * Capability can be invoked to retrieve the list of subscriptions for an\n * account.\n */\nexport const list = capability({\n    can: 'subscription/list',\n    with: AccountDID,\n    derives: equalWith,\n});\n//# sourceMappingURL=subscription.js.map"],"names":[],"mappings":";;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAEO,MAAM,cAAc,wJAAG,CAAC,KAAK,CAAC;IAAE,QAAQ;AAAM;AAI9C,MAAM,MAAM,IAAA,wKAAU,EAAC;IAC1B,KAAK;IACL,MAAM;IACN,IAAI,IAAA,qKAAM,EAAC;QACP,cAAc,6LAAM,CAAC,MAAM;IAC/B;IACA,SAAS,CAAC,OAAO;QACb,OAAQ,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,OAAO,YACzB,IAAA,kKAAG,EAAC,IAAA,oKAAK,EAAC,MAAM,EAAE,CAAC,YAAY,EAAE,OAAO,EAAE,CAAC,YAAY,EAAE,gBACzD,IAAA,uJAAE,EAAC,CAAC;IACZ;AACJ;AAKO,MAAM,OAAO,IAAA,wKAAU,EAAC;IAC3B,KAAK;IACL,MAAM,yKAAU;IAChB,SAAS,wKAAS;AACtB,IACA,wCAAwC","ignoreList":[0]}},
    {"offset": {"line": 1563, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/capabilities/dist/filecoin/lib.js"],"sourcesContent":["import { Schema } from '@ucanto/validator';\n/**\n * @see https://github.com/filecoin-project/FIPs/pull/758/files\n */\nconst FR32_SHA2_256_TRUNC254_PADDED_BINARY_TREE = /** @type {const} */ (0x1011);\n/**\n * @see https://github.com/filecoin-project/FIPs/pull/758/files\n */\nconst RAW_CODE = /** @type {const} */ (0x55);\nexport const PieceLink = /** @type {import('../types.js').PieceLinkSchema} */ (Schema.link({\n    code: RAW_CODE,\n    version: 1,\n    multihash: {\n        code: FR32_SHA2_256_TRUNC254_PADDED_BINARY_TREE,\n    },\n}));\n//# sourceMappingURL=lib.js.map"],"names":[],"mappings":";;;;AAAA;AAAA;;AACA;;CAEC,GACD,MAAM,4CAAkE;AACxE;;CAEC,GACD,MAAM,WAAiC;AAChC,MAAM,YAAkE,6LAAM,CAAC,IAAI,CAAC;IACvF,MAAM;IACN,SAAS;IACT,WAAW;QACP,MAAM;IACV;AACJ,IACA,+BAA+B","ignoreList":[0]}},
    {"offset": {"line": 1587, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/capabilities/dist/filecoin/storefront.js"],"sourcesContent":["/**\n * Filecoin Storefront Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as Storefront from '@storacha/capabilities/filecoin/storefront'\n * ```\n *\n * @module\n */\nimport { capability, Schema, ok } from '@ucanto/validator';\nimport { PieceLink } from './lib.js';\nimport { equalWith, checkLink, and } from '../utils.js';\n/**\n * Top-level capability for Filecoin operations.\n */\nexport const filecoin = capability({\n    can: 'filecoin/*',\n    /**\n     * DID of the space the content is stored in.\n     */\n    with: Schema.did(),\n    derives: equalWith,\n});\n/**\n * Capability allowing an agent to _request_ storing a content piece in\n * Filecoin.\n */\nexport const filecoinOffer = capability({\n    can: 'filecoin/offer',\n    /**\n     * DID of the space the content is stored in.\n     */\n    with: Schema.did(),\n    nb: Schema.struct({\n        /**\n         * CID of the content that resulted in Filecoin piece.\n         */\n        content: Schema.link(),\n        /**\n         * CID of the piece.\n         */\n        piece: PieceLink,\n        /**\n         * Link to a pdp/accept invocation included returned when blob was accepted\n         */\n        PDP: Schema.link({ version: 1 }).optional(),\n    }),\n    derives: (claim, from) => {\n        return (and(equalWith(claim, from)) ||\n            and(checkLink(claim.nb.content, from.nb.content, 'nb.content')) ||\n            and(checkLink(claim.nb.piece, from.nb.piece, 'nb.piece')) ||\n            ok({}));\n    },\n});\n/**\n * Capability allowing a Storefront to signal that an offered piece has been\n * submitted to the filecoin storage pipeline.\n */\nexport const filecoinSubmit = capability({\n    can: 'filecoin/submit',\n    /**\n     * DID of the Storefront.\n     */\n    with: Schema.did(),\n    nb: Schema.struct({\n        /**\n         * CID of the content that resulted in Filecoin piece.\n         */\n        content: Schema.link(),\n        /**\n         * CID of the piece.\n         *\n         * @see https://github.com/filecoin-project/FIPs/pull/758/files\n         */\n        piece: PieceLink,\n    }),\n    derives: (claim, from) => {\n        return (and(equalWith(claim, from)) ||\n            and(checkLink(claim.nb.content, from.nb.content, 'nb.content')) ||\n            and(checkLink(claim.nb.piece, from.nb.piece, 'nb.piece')) ||\n            ok({}));\n    },\n});\n/**\n * Capability allowing a Storefront to signal that a submitted piece has been\n * accepted in a Filecoin deal. The receipt contains the proof.\n */\nexport const filecoinAccept = capability({\n    can: 'filecoin/accept',\n    /**\n     * DID of the Storefront.\n     */\n    with: Schema.did(),\n    nb: Schema.struct({\n        /**\n         * CID of the content that resulted in Filecoin piece.\n         */\n        content: Schema.link(),\n        /**\n         * CID of the piece.\n         *\n         * @see https://github.com/filecoin-project/FIPs/pull/758/files\n         */\n        piece: PieceLink,\n    }),\n    derives: (claim, from) => {\n        return (and(equalWith(claim, from)) ||\n            and(checkLink(claim.nb.content, from.nb.content, 'nb.content')) ||\n            and(checkLink(claim.nb.piece, from.nb.piece, 'nb.piece')) ||\n            ok({}));\n    },\n});\n/**\n * Capability allowing an agent to _request_ info about a content piece in\n * Filecoin deals.\n */\nexport const filecoinInfo = capability({\n    can: 'filecoin/info',\n    /**\n     * DID of the space the content is stored in.\n     */\n    with: Schema.did(),\n    nb: Schema.struct({\n        /**\n         * CID of the piece.\n         *\n         * @see https://github.com/filecoin-project/FIPs/pull/758/files\n         */\n        piece: PieceLink,\n    }),\n    derives: (claim, from) => {\n        return (and(equalWith(claim, from)) ||\n            and(checkLink(claim.nb.piece, from.nb.piece, 'nb.piece')) ||\n            ok({}));\n    },\n});\n//# sourceMappingURL=storefront.js.map"],"names":[],"mappings":"AAAA;;;;;;;;;CASC;;;;;;;;;;;;AACD;AAAA;AAAA;AAAA;AACA;AACA;;;;AAIO,MAAM,WAAW,IAAA,wKAAU,EAAC;IAC/B,KAAK;IACL;;KAEC,GACD,MAAM,6LAAM,CAAC,GAAG;IAChB,SAAS,wKAAS;AACtB;AAKO,MAAM,gBAAgB,IAAA,wKAAU,EAAC;IACpC,KAAK;IACL;;KAEC,GACD,MAAM,6LAAM,CAAC,GAAG;IAChB,IAAI,6LAAM,CAAC,MAAM,CAAC;QACd;;SAEC,GACD,SAAS,6LAAM,CAAC,IAAI;QACpB;;SAEC,GACD,OAAO,kLAAS;QAChB;;SAEC,GACD,KAAK,6LAAM,CAAC,IAAI,CAAC;YAAE,SAAS;QAAE,GAAG,QAAQ;IAC7C;IACA,SAAS,CAAC,OAAO;QACb,OAAQ,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,OAAO,UACzB,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,MAAM,EAAE,CAAC,OAAO,EAAE,KAAK,EAAE,CAAC,OAAO,EAAE,kBACjD,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,MAAM,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,KAAK,EAAE,gBAC7C,IAAA,uJAAE,EAAC,CAAC;IACZ;AACJ;AAKO,MAAM,iBAAiB,IAAA,wKAAU,EAAC;IACrC,KAAK;IACL;;KAEC,GACD,MAAM,6LAAM,CAAC,GAAG;IAChB,IAAI,6LAAM,CAAC,MAAM,CAAC;QACd;;SAEC,GACD,SAAS,6LAAM,CAAC,IAAI;QACpB;;;;SAIC,GACD,OAAO,kLAAS;IACpB;IACA,SAAS,CAAC,OAAO;QACb,OAAQ,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,OAAO,UACzB,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,MAAM,EAAE,CAAC,OAAO,EAAE,KAAK,EAAE,CAAC,OAAO,EAAE,kBACjD,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,MAAM,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,KAAK,EAAE,gBAC7C,IAAA,uJAAE,EAAC,CAAC;IACZ;AACJ;AAKO,MAAM,iBAAiB,IAAA,wKAAU,EAAC;IACrC,KAAK;IACL;;KAEC,GACD,MAAM,6LAAM,CAAC,GAAG;IAChB,IAAI,6LAAM,CAAC,MAAM,CAAC;QACd;;SAEC,GACD,SAAS,6LAAM,CAAC,IAAI;QACpB;;;;SAIC,GACD,OAAO,kLAAS;IACpB;IACA,SAAS,CAAC,OAAO;QACb,OAAQ,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,OAAO,UACzB,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,MAAM,EAAE,CAAC,OAAO,EAAE,KAAK,EAAE,CAAC,OAAO,EAAE,kBACjD,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,MAAM,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,KAAK,EAAE,gBAC7C,IAAA,uJAAE,EAAC,CAAC;IACZ;AACJ;AAKO,MAAM,eAAe,IAAA,wKAAU,EAAC;IACnC,KAAK;IACL;;KAEC,GACD,MAAM,6LAAM,CAAC,GAAG;IAChB,IAAI,6LAAM,CAAC,MAAM,CAAC;QACd;;;;SAIC,GACD,OAAO,kLAAS;IACpB;IACA,SAAS,CAAC,OAAO;QACb,OAAQ,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,OAAO,UACzB,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,MAAM,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,KAAK,EAAE,gBAC7C,IAAA,uJAAE,EAAC,CAAC;IACZ;AACJ,IACA,sCAAsC","ignoreList":[0]}},
    {"offset": {"line": 1704, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/capabilities/dist/filecoin/index.js"],"sourcesContent":["/**\n * Filecoin Capabilities\n *\n * These capabilities are the entrypoint to the filecoin pipeline and are\n * aliases for the filecoin storefront capabilities.\n *\n * These can be imported directly with:\n * ```js\n * import * as Filecoin from '@storacha/capabilities/filecoin'\n * ```\n *\n * @module\n */\nexport { filecoinOffer as offer, filecoinSubmit as submit, filecoinAccept as accept, filecoinInfo as info, filecoin as filecoin, } from './storefront.js';\n//# sourceMappingURL=index.js.map"],"names":[],"mappings":"AAAA;;;;;;;;;;;;CAYC;AACD,gTACA,iCAAiC","ignoreList":[0]}},
    {"offset": {"line": 1741, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/capabilities/dist/filecoin/aggregator.js"],"sourcesContent":["/**\n * Filecoin Aggregator Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as Aggregator from '@storacha/capabilities/filecoin/aggregator'\n * ```\n *\n * @module\n */\nimport { capability, Schema, ok } from '@ucanto/validator';\nimport { PieceLink } from './lib.js';\nimport { equal, equalWith, checkLink, and } from '../utils.js';\n/**\n * Capability that allows a Storefront to request that a piece be aggregated\n * for inclusion in an upcoming an Filecoin deal.\n */\nexport const pieceOffer = capability({\n    can: 'piece/offer',\n    /**\n     * DID of an authorized Storefront.\n     */\n    with: Schema.did(),\n    nb: Schema.struct({\n        /**\n         * CID of the piece.\n         */\n        piece: PieceLink,\n        /**\n         * Grouping of joining segments into an aggregate.\n         */\n        group: Schema.text(),\n    }),\n    derives: (claim, from) => {\n        return (and(equalWith(claim, from)) ||\n            and(checkLink(claim.nb.piece, from.nb.piece, 'nb.piece')) ||\n            and(equal(claim.nb.group, from.nb.group, 'nb.group')) ||\n            ok({}));\n    },\n});\n/**\n * Capability that allows an Aggregator to signal a piece has been accepted\n * or rejected for inclusion in an aggregate.\n */\nexport const pieceAccept = capability({\n    can: 'piece/accept',\n    /**\n     * DID of the Aggregator.\n     */\n    with: Schema.did(),\n    nb: Schema.struct({\n        /**\n         * CID of the piece.\n         *\n         * @see https://github.com/filecoin-project/FIPs/pull/758/files\n         */\n        piece: PieceLink,\n        /**\n         * Grouping of joining segments into an aggregate.\n         */\n        group: Schema.text(),\n    }),\n    derives: (claim, from) => {\n        return (and(equalWith(claim, from)) ||\n            and(checkLink(claim.nb.piece, from.nb.piece, 'nb.piece')) ||\n            and(equal(claim.nb.group, from.nb.group, 'nb.group')) ||\n            ok({}));\n    },\n});\n//# sourceMappingURL=aggregator.js.map"],"names":[],"mappings":"AAAA;;;;;;;;;CASC;;;;;;AACD;AAAA;AAAA;AAAA;AACA;AACA;;;;AAKO,MAAM,aAAa,IAAA,wKAAU,EAAC;IACjC,KAAK;IACL;;KAEC,GACD,MAAM,6LAAM,CAAC,GAAG;IAChB,IAAI,6LAAM,CAAC,MAAM,CAAC;QACd;;SAEC,GACD,OAAO,kLAAS;QAChB;;SAEC,GACD,OAAO,6LAAM,CAAC,IAAI;IACtB;IACA,SAAS,CAAC,OAAO;QACb,OAAQ,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,OAAO,UACzB,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,MAAM,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,KAAK,EAAE,gBAC7C,IAAA,kKAAG,EAAC,IAAA,oKAAK,EAAC,MAAM,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,KAAK,EAAE,gBACzC,IAAA,uJAAE,EAAC,CAAC;IACZ;AACJ;AAKO,MAAM,cAAc,IAAA,wKAAU,EAAC;IAClC,KAAK;IACL;;KAEC,GACD,MAAM,6LAAM,CAAC,GAAG;IAChB,IAAI,6LAAM,CAAC,MAAM,CAAC;QACd;;;;SAIC,GACD,OAAO,kLAAS;QAChB;;SAEC,GACD,OAAO,6LAAM,CAAC,IAAI;IACtB;IACA,SAAS,CAAC,OAAO;QACb,OAAQ,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,OAAO,UACzB,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,MAAM,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,KAAK,EAAE,gBAC7C,IAAA,kKAAG,EAAC,IAAA,oKAAK,EAAC,MAAM,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,KAAK,EAAE,gBACzC,IAAA,uJAAE,EAAC,CAAC;IACZ;AACJ,IACA,sCAAsC","ignoreList":[0]}},
    {"offset": {"line": 1805, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/capabilities/dist/filecoin/dealer.js"],"sourcesContent":["/**\n * Filecoin Dealer Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as Dealer from '@storacha/capabilities/filecoin/dealer'\n * ```\n *\n * @module\n */\nimport { capability, Schema, ok } from '@ucanto/validator';\nimport { PieceLink } from './lib.js';\nimport { equalWith, checkLink, and } from '../utils.js';\n/**\n * Capability allowing an Aggregator to request an aggregate to be added to a\n * deal with a Storage Provider.\n */\nexport const aggregateOffer = capability({\n    can: 'aggregate/offer',\n    /**\n     * DID of an authorized Storefront.\n     */\n    with: Schema.did(),\n    nb: Schema.struct({\n        /**\n         * Commitment proof for the aggregate being offered.\n         */\n        aggregate: PieceLink,\n        /**\n         * CID of the DAG-CBOR encoded block with offer details.\n         * Service will queue given offer to be validated and handled.\n         */\n        pieces: Schema.link({ version: 1 }),\n    }),\n    derives: (claim, from) => {\n        return (and(equalWith(claim, from)) ||\n            and(checkLink(claim.nb.aggregate, from.nb.aggregate, 'nb.aggregate')) ||\n            and(checkLink(claim.nb.pieces, from.nb.pieces, 'nb.pieces')) ||\n            ok({}));\n    },\n});\n/**\n * Capability that allows a Dealer to signal an aggregate has been accepted\n * for inclusion in a Filecoin deal.\n */\nexport const aggregateAccept = capability({\n    can: 'aggregate/accept',\n    /**\n     * did:key identifier of the broker authority where offer is made available.\n     */\n    with: Schema.did(),\n    nb: Schema.struct({\n        /**\n         * Commitment proof for the aggregate being offered.\n         */\n        aggregate: PieceLink,\n        /**\n         * CID of the DAG-CBOR encoded block with offer details.\n         * Service will queue given offer to be validated and handled.\n         */\n        pieces: Schema.link(),\n    }),\n    derives: (claim, from) => {\n        return (and(equalWith(claim, from)) ||\n            and(checkLink(claim.nb.aggregate, from.nb.aggregate, 'nb.aggregate')) ||\n            and(checkLink(claim.nb.pieces, from.nb.pieces, 'nb.pieces')) ||\n            ok({}));\n    },\n});\n//# sourceMappingURL=dealer.js.map"],"names":[],"mappings":"AAAA;;;;;;;;;CASC;;;;;;AACD;AAAA;AAAA;AAAA;AACA;AACA;;;;AAKO,MAAM,iBAAiB,IAAA,wKAAU,EAAC;IACrC,KAAK;IACL;;KAEC,GACD,MAAM,6LAAM,CAAC,GAAG;IAChB,IAAI,6LAAM,CAAC,MAAM,CAAC;QACd;;SAEC,GACD,WAAW,kLAAS;QACpB;;;SAGC,GACD,QAAQ,6LAAM,CAAC,IAAI,CAAC;YAAE,SAAS;QAAE;IACrC;IACA,SAAS,CAAC,OAAO;QACb,OAAQ,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,OAAO,UACzB,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,MAAM,EAAE,CAAC,SAAS,EAAE,KAAK,EAAE,CAAC,SAAS,EAAE,oBACrD,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,MAAM,EAAE,CAAC,MAAM,EAAE,KAAK,EAAE,CAAC,MAAM,EAAE,iBAC/C,IAAA,uJAAE,EAAC,CAAC;IACZ;AACJ;AAKO,MAAM,kBAAkB,IAAA,wKAAU,EAAC;IACtC,KAAK;IACL;;KAEC,GACD,MAAM,6LAAM,CAAC,GAAG;IAChB,IAAI,6LAAM,CAAC,MAAM,CAAC;QACd;;SAEC,GACD,WAAW,kLAAS;QACpB;;;SAGC,GACD,QAAQ,6LAAM,CAAC,IAAI;IACvB;IACA,SAAS,CAAC,OAAO;QACb,OAAQ,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,OAAO,UACzB,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,MAAM,EAAE,CAAC,SAAS,EAAE,KAAK,EAAE,CAAC,SAAS,EAAE,oBACrD,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,MAAM,EAAE,CAAC,MAAM,EAAE,KAAK,EAAE,CAAC,MAAM,EAAE,iBAC/C,IAAA,uJAAE,EAAC,CAAC;IACZ;AACJ,IACA,kCAAkC","ignoreList":[0]}},
    {"offset": {"line": 1871, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/capabilities/dist/filecoin/deal-tracker.js"],"sourcesContent":["/**\n * Filecoin Deal Tracker Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as DealTracker from '@storacha/capabilities/filecoin/deal-tracker'\n * ```\n *\n * @module\n */\nimport { capability, Schema, ok } from '@ucanto/validator';\nimport { PieceLink } from './lib.js';\nimport { equalWith, checkLink, and } from '../utils.js';\n/**\n * Capability allowing a Storefront or Aggregator to obtain deal information\n * for a given aggregate piece.\n */\nexport const dealInfo = capability({\n    can: 'deal/info',\n    /**\n     * DID of the Storefront.\n     */\n    with: Schema.did(),\n    nb: Schema.struct({\n        /**\n         * CID of the piece.\n         *\n         * @see https://github.com/filecoin-project/FIPs/pull/758/files\n         */\n        piece: PieceLink,\n    }),\n    derives: (claim, from) => {\n        return (and(equalWith(claim, from)) ||\n            and(checkLink(claim.nb.piece, from.nb.piece, 'nb.piece')) ||\n            ok({}));\n    },\n});\n//# sourceMappingURL=deal-tracker.js.map"],"names":[],"mappings":"AAAA;;;;;;;;;CASC;;;;AACD;AAAA;AAAA;AAAA;AACA;AACA;;;;AAKO,MAAM,WAAW,IAAA,wKAAU,EAAC;IAC/B,KAAK;IACL;;KAEC,GACD,MAAM,6LAAM,CAAC,GAAG;IAChB,IAAI,6LAAM,CAAC,MAAM,CAAC;QACd;;;;SAIC,GACD,OAAO,kLAAS;IACpB;IACA,SAAS,CAAC,OAAO;QACb,OAAQ,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,OAAO,UACzB,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,MAAM,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,KAAK,EAAE,gBAC7C,IAAA,uJAAE,EAAC,CAAC;IACZ;AACJ,IACA,wCAAwC","ignoreList":[0]}},
    {"offset": {"line": 1913, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/capabilities/dist/space/index.js"],"sourcesContent":["/**\n * Index Capabilities.\n *\n * W3 Indexing protocol allows authorized agents to submit verifiable claims\n * about content-addressed data to be published on the InterPlanetary Network\n * Indexer (IPNI), making it publicly queryable.\n *\n * These can be imported directly with:\n * ```js\n * import * as Index from '@storacha/capabilities/space/index'\n * ```\n *\n * @module\n */\nimport { CAR as SpaceIndex } from '@ucanto/core';\nimport { capability, Schema, ok } from '@ucanto/validator';\nimport { equalWith, SpaceDID, and, equal } from '../utils.js';\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derive any `space/index/` prefixed capability for the space identified by the DID\n * in the `with` field.\n */\nexport const index = capability({\n    can: 'space/index/*',\n    /** DID of the space where indexed data is stored. */\n    with: SpaceDID,\n    derives: equalWith,\n});\n/**\n * `space/index/add` capability allows an agent to submit verifiable claims\n * about content-addressed data to be published on the InterPlanetary Network\n * Indexer (IPNI), making it publicly queryable.\n */\nexport const add = capability({\n    can: 'space/index/add',\n    /** DID of the space where indexed data is stored. */\n    with: SpaceDID,\n    nb: Schema.struct({\n        /** Content Archive (CAR) containing the `Index`. */\n        index: Schema.link({ code: SpaceIndex.code, version: 1 }),\n        /** The content root CID - the root of the DAG that is indexed. */\n        content: Schema.link().optional(),\n    }),\n    derives: (claimed, delegated) => and(equalWith(claimed, delegated)) ||\n        and(equal(claimed.nb.index, delegated.nb.index, 'index')) ||\n        ok({}),\n});\n// ⚠️ We export imports here so they are not omitted in generated typedefs\n// @see https://github.com/microsoft/TypeScript/issues/51548\nexport { Schema };\n//# sourceMappingURL=index.js.map"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;CAaC;;;;;;AACD;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;AAMO,MAAM,QAAQ,IAAA,wKAAU,EAAC;IAC5B,KAAK;IACL,mDAAmD,GACnD,MAAM,uKAAQ;IACd,SAAS,wKAAS;AACtB;AAMO,MAAM,MAAM,IAAA,wKAAU,EAAC;IAC1B,KAAK;IACL,mDAAmD,GACnD,MAAM,uKAAQ;IACd,IAAI,6LAAM,CAAC,MAAM,CAAC;QACd,kDAAkD,GAClD,OAAO,6LAAM,CAAC,IAAI,CAAC;YAAE,MAAM,oLAAU,CAAC,IAAI;YAAE,SAAS;QAAE;QACvD,gEAAgE,GAChE,SAAS,6LAAM,CAAC,IAAI,GAAG,QAAQ;IACnC;IACA,SAAS,CAAC,SAAS,YAAc,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,SAAS,eACpD,IAAA,kKAAG,EAAC,IAAA,oKAAK,EAAC,QAAQ,EAAE,CAAC,KAAK,EAAE,UAAU,EAAE,CAAC,KAAK,EAAE,aAChD,IAAA,uJAAE,EAAC,CAAC;AACZ;;CAIA,iCAAiC","ignoreList":[0]}},
    {"offset": {"line": 1979, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/capabilities/dist/plan.js"],"sourcesContent":["import { DID, Schema, capability, ok, struct } from '@ucanto/validator';\nimport { AccountDID, equal, equalWith, and } from './utils.js';\n/**\n * Capability can be invoked by an account to get information about\n * the plan it is currently signed up for.\n */\nexport const get = capability({\n    can: 'plan/get',\n    with: AccountDID,\n    derives: (child, parent) => {\n        return and(equalWith(child, parent)) || ok({});\n    },\n});\n/**\n * Capability can be invoked by an account to change its billing plan.\n */\nexport const set = capability({\n    can: 'plan/set',\n    with: AccountDID,\n    nb: struct({\n        product: DID,\n    }),\n    derives: (child, parent) => {\n        return (and(equalWith(child, parent)) ||\n            and(equal(child.nb.product, parent.nb.product, 'product')) ||\n            ok({}));\n    },\n});\n/**\n * Capability can be invoked by an account to generate a billing admin session.\n *\n * May not be possible with all billing providers - this is designed with\n * https://docs.stripe.com/api/customer_portal/sessions/create in mind.\n */\nexport const createAdminSession = capability({\n    can: 'plan/create-admin-session',\n    with: AccountDID,\n    nb: struct({\n        returnURL: Schema.string(),\n    }),\n    derives: (child, parent) => {\n        return (and(equalWith(child, parent)) ||\n            and(equal(child.nb.returnURL, parent.nb.returnURL, 'returnURL')) ||\n            ok({}));\n    },\n});\n/**\n * Capability can be invoked by an account to generate a billing checkout session.\n *\n * May not be possible with all billing providers - this is designed with\n * https://docs.stripe.com/api/customer_portal/sessions/create in mind.\n */\nexport const createCheckoutSession = capability({\n    can: 'plan/create-checkout-session',\n    with: AccountDID,\n    nb: struct({\n        planID: Schema.DID,\n        redirectAfterCompletion: Schema.boolean().optional(),\n        successURL: Schema.string().optional(),\n        cancelURL: Schema.string().optional(),\n        freeTrial: Schema.boolean().optional(),\n    }),\n    derives: (child, parent) => {\n        return (and(equalWith(child, parent)) ||\n            and(equal(child.nb.planID, parent.nb.planID, 'planID')) ||\n            and(equal(child.nb.successURL, parent.nb.successURL, 'successURL')) ||\n            and(equal(child.nb.cancelURL, parent.nb.cancelURL, 'cancelURL')) ||\n            and(equal(child.nb.freeTrial, parent.nb.freeTrial, 'freeTrial')) ||\n            ok({}));\n    },\n});\n//# sourceMappingURL=plan.js.map"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAKO,MAAM,MAAM,IAAA,wKAAU,EAAC;IAC1B,KAAK;IACL,MAAM,yKAAU;IAChB,SAAS,CAAC,OAAO;QACb,OAAO,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,OAAO,YAAY,IAAA,uJAAE,EAAC,CAAC;IAChD;AACJ;AAIO,MAAM,MAAM,IAAA,wKAAU,EAAC;IAC1B,KAAK;IACL,MAAM,yKAAU;IAChB,IAAI,IAAA,qKAAM,EAAC;QACP,SAAS,wJAAG;IAChB;IACA,SAAS,CAAC,OAAO;QACb,OAAQ,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,OAAO,YACzB,IAAA,kKAAG,EAAC,IAAA,oKAAK,EAAC,MAAM,EAAE,CAAC,OAAO,EAAE,OAAO,EAAE,CAAC,OAAO,EAAE,eAC/C,IAAA,uJAAE,EAAC,CAAC;IACZ;AACJ;AAOO,MAAM,qBAAqB,IAAA,wKAAU,EAAC;IACzC,KAAK;IACL,MAAM,yKAAU;IAChB,IAAI,IAAA,qKAAM,EAAC;QACP,WAAW,6LAAM,CAAC,MAAM;IAC5B;IACA,SAAS,CAAC,OAAO;QACb,OAAQ,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,OAAO,YACzB,IAAA,kKAAG,EAAC,IAAA,oKAAK,EAAC,MAAM,EAAE,CAAC,SAAS,EAAE,OAAO,EAAE,CAAC,SAAS,EAAE,iBACnD,IAAA,uJAAE,EAAC,CAAC;IACZ;AACJ;AAOO,MAAM,wBAAwB,IAAA,wKAAU,EAAC;IAC5C,KAAK;IACL,MAAM,yKAAU;IAChB,IAAI,IAAA,qKAAM,EAAC;QACP,QAAQ,6LAAM,CAAC,GAAG;QAClB,yBAAyB,6LAAM,CAAC,OAAO,GAAG,QAAQ;QAClD,YAAY,6LAAM,CAAC,MAAM,GAAG,QAAQ;QACpC,WAAW,6LAAM,CAAC,MAAM,GAAG,QAAQ;QACnC,WAAW,6LAAM,CAAC,OAAO,GAAG,QAAQ;IACxC;IACA,SAAS,CAAC,OAAO;QACb,OAAQ,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,OAAO,YACzB,IAAA,kKAAG,EAAC,IAAA,oKAAK,EAAC,MAAM,EAAE,CAAC,MAAM,EAAE,OAAO,EAAE,CAAC,MAAM,EAAE,cAC7C,IAAA,kKAAG,EAAC,IAAA,oKAAK,EAAC,MAAM,EAAE,CAAC,UAAU,EAAE,OAAO,EAAE,CAAC,UAAU,EAAE,kBACrD,IAAA,kKAAG,EAAC,IAAA,oKAAK,EAAC,MAAM,EAAE,CAAC,SAAS,EAAE,OAAO,EAAE,CAAC,SAAS,EAAE,iBACnD,IAAA,kKAAG,EAAC,IAAA,oKAAK,EAAC,MAAM,EAAE,CAAC,SAAS,EAAE,OAAO,EAAE,CAAC,SAAS,EAAE,iBACnD,IAAA,uJAAE,EAAC,CAAC;IACZ;AACJ,IACA,gCAAgC","ignoreList":[0]}},
    {"offset": {"line": 2043, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/capabilities/dist/usage.js"],"sourcesContent":["import { capability, ok, Schema } from '@ucanto/validator';\nimport { and, equal, equalWith, SpaceDID } from './utils.js';\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * be derived any `usage/` prefixed capability for the (memory) space identified\n * by DID in the `with` field.\n */\nexport const usage = capability({\n    can: 'usage/*',\n    /** DID of the (memory) space where usage is derived. */\n    with: SpaceDID,\n    derives: equalWith,\n});\n/**\n * Capability can be invoked by an agent to retrieve usage data for a space in\n * a given period.\n */\nexport const report = capability({\n    can: 'usage/report',\n    with: SpaceDID,\n    nb: Schema.struct({\n        /** Period to retrieve events between. */\n        period: Schema.struct({\n            /** Time in seconds after Unix epoch (inclusive). */\n            from: Schema.integer().greaterThan(-1),\n            /** Time in seconds after Unix epoch (exclusive). */\n            to: Schema.integer().greaterThan(-1),\n        }),\n    }),\n    derives: (child, parent) => {\n        return (and(equalWith(child, parent)) ||\n            and(equal(child.nb.period?.from, parent.nb.period?.from, 'period.from')) ||\n            and(equal(child.nb.period?.to, parent.nb.period?.to, 'period.to')) ||\n            ok({}));\n    },\n});\n//# sourceMappingURL=usage.js.map"],"names":[],"mappings":";;;;;;AAAA;AAAA;AAAA;AAAA;AACA;;;AAMO,MAAM,QAAQ,IAAA,wKAAU,EAAC;IAC5B,KAAK;IACL,sDAAsD,GACtD,MAAM,uKAAQ;IACd,SAAS,wKAAS;AACtB;AAKO,MAAM,SAAS,IAAA,wKAAU,EAAC;IAC7B,KAAK;IACL,MAAM,uKAAQ;IACd,IAAI,6LAAM,CAAC,MAAM,CAAC;QACd,uCAAuC,GACvC,QAAQ,6LAAM,CAAC,MAAM,CAAC;YAClB,kDAAkD,GAClD,MAAM,6LAAM,CAAC,OAAO,GAAG,WAAW,CAAC,CAAC;YACpC,kDAAkD,GAClD,IAAI,6LAAM,CAAC,OAAO,GAAG,WAAW,CAAC,CAAC;QACtC;IACJ;IACA,SAAS,CAAC,OAAO;QACb,OAAQ,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,OAAO,YACzB,IAAA,kKAAG,EAAC,IAAA,oKAAK,EAAC,MAAM,EAAE,CAAC,MAAM,EAAE,MAAM,OAAO,EAAE,CAAC,MAAM,EAAE,MAAM,mBACzD,IAAA,kKAAG,EAAC,IAAA,oKAAK,EAAC,MAAM,EAAE,CAAC,MAAM,EAAE,IAAI,OAAO,EAAE,CAAC,MAAM,EAAE,IAAI,iBACrD,IAAA,uJAAE,EAAC,CAAC;IACZ;AACJ,IACA,iCAAiC","ignoreList":[0]}},
    {"offset": {"line": 2078, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/capabilities/dist/space/blob.js"],"sourcesContent":["/**\n * Blob Capabilities.\n *\n * Blob is a fixed size byte array addressed by the multihash.\n * Usually blobs are used to represent set of IPLD blocks at different byte ranges.\n *\n * These can be imported directly with:\n * ```js\n * import * as Blob from '@storacha/capabilities/space/blob'\n * ```\n *\n * @module\n */\nimport { equals } from 'multiformats/bytes';\nimport { capability, Schema, fail, ok } from '@ucanto/validator';\nimport { equalBlob, equalWith, SpaceDID, and, equal, checkLink, } from '../utils.js';\n/**\n * Agent capabilities for Blob protocol\n */\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derived any `space/blob/` prefixed capability for the (memory) space identified\n * by DID in the `with` field.\n */\nexport const blob = capability({\n    can: 'space/blob/*',\n    /**\n     * DID of the (memory) space where Blob is intended to\n     * be stored.\n     */\n    with: SpaceDID,\n    derives: equalWith,\n});\n/**\n * Blob description for being ingested by the service.\n */\nexport const content = Schema.struct({\n    /**\n     * A multihash digest of the blob payload bytes, uniquely identifying blob.\n     */\n    digest: Schema.bytes(),\n    /**\n     * Number of bytes contained by this blob. Service will provision write target\n     * for this exact size. Attempt to write a larger Blob file will fail.\n     */\n    size: Schema.integer(),\n});\n/**\n * `space/blob/add` capability allows agent to store a Blob into a (memory) space\n * identified by did:key in the `with` field. Agent should compute blob multihash\n * and size and provide it under `nb.blob` field, allowing a service to provision\n * a write location for the agent to PUT desired Blob into.\n */\nexport const add = capability({\n    can: 'space/blob/add',\n    /**\n     * DID of the (memory) space where Blob is intended to\n     * be stored.\n     */\n    with: SpaceDID,\n    nb: Schema.struct({\n        /**\n         * Blob to be added on the space.\n         */\n        blob: content,\n    }),\n    derives: equalBlob,\n});\n/**\n * Capability can be used to remove the stored Blob from the (memory)\n * space identified by `with` field.\n */\nexport const remove = capability({\n    can: 'space/blob/remove',\n    /**\n     * DID of the (memory) space where Blob is stored.\n     */\n    with: SpaceDID,\n    nb: Schema.struct({\n        /**\n         * A multihash digest of the blob payload bytes, uniquely identifying blob.\n         */\n        digest: Schema.bytes(),\n    }),\n    derives: (claimed, delegated) => {\n        if (claimed.with !== delegated.with) {\n            return fail(`Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`);\n        }\n        else if (delegated.nb.digest &&\n            !equals(delegated.nb.digest, claimed.nb.digest)) {\n            return fail(`Link ${claimed.nb.digest ? `${claimed.nb.digest}` : ''} violates imposed ${delegated.nb.digest} constraint.`);\n        }\n        return ok({});\n    },\n});\n/**\n * Capability can be invoked to request a list of stored Blobs in the\n * (memory) space identified by `with` field.\n */\nexport const list = capability({\n    can: 'space/blob/list',\n    /**\n     * DID of the (memory) space where Blobs to be listed are stored.\n     */\n    with: SpaceDID,\n    nb: Schema.struct({\n        /**\n         * A pointer that can be moved back and forth on the list.\n         * It can be used to paginate a list for instance.\n         */\n        cursor: Schema.string().optional(),\n        /**\n         * Maximum number of items per page.\n         */\n        size: Schema.integer().optional(),\n    }),\n    derives: (claimed, delegated) => {\n        if (claimed.with !== delegated.with) {\n            return fail(`Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`);\n        }\n        return ok({});\n    },\n});\n/**\n * Capability can be used to get the stored Blob from the (memory)\n * space identified by `with` field.\n */\nexport const get = capability({\n    can: 'space/blob/get/0/1',\n    /**\n     * DID of the (memory) space where Blob is stored.\n     */\n    with: SpaceDID,\n    nb: Schema.struct({\n        /**\n         * A multihash digest of the blob payload bytes, uniquely identifying blob.\n         */\n        digest: Schema.bytes(),\n    }),\n    derives: (claimed, delegated) => {\n        if (claimed.with !== delegated.with) {\n            return fail(`Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`);\n        }\n        else if (delegated.nb.digest &&\n            !equals(delegated.nb.digest, claimed.nb.digest)) {\n            return fail(`Link ${claimed.nb.digest ? `${claimed.nb.digest}` : ''} violates imposed ${delegated.nb.digest} constraint.`);\n        }\n        return ok({});\n    },\n});\n/**\n * The `space/blob/replicate` capability allows an agent to replicate a Blob\n * into a space identified by did:key in the `with` field.\n *\n * A replicate capability may only be invoked after a `blob/accept` receipt has\n * been receieved, indicating the source node has successfully received the\n * blob.\n *\n * Each Replicate task MUST target a different node, and they MUST NOT target\n * the original upload target.\n *\n * The Replicate task receipt includes async tasks for `blob/replica/allocate`\n * and `blob/replica/transfer`. Successful completion of the\n * `blob/replica/transfer` task indicates the replication target has transferred\n * and stored the blob. The number of `blob/replica/allocate` and\n * `blob/replica/transfer` tasks corresponds directly to number of replicas\n * requested.\n */\nexport const replicate = capability({\n    can: 'space/blob/replicate',\n    with: SpaceDID,\n    nb: Schema.struct({\n        /** Blob to replicate. */\n        blob: content,\n        /**\n         * The number of replicas to ensure. e.g. `replicas: 2` will ensure 2 copies\n         * of the data exist in the network.\n         */\n        replicas: Schema.integer().greaterThan(0),\n        /** Link to a location commitment indicating where the Blob must be fetched from. */\n        site: Schema.link({ version: 1 }),\n    }),\n    derives: (claimed, delegated) => and(equalWith(claimed, delegated)) ||\n        and(equalBlob(claimed, delegated)) ||\n        and(equal(claimed.nb.replicas, delegated.nb.replicas, 'replicas')) ||\n        and(checkLink(claimed.nb.site, delegated.nb.site, 'site')) ||\n        ok({}),\n});\n// ⚠️ We export imports here so they are not omitted in generated typedefs\n// @see https://github.com/microsoft/TypeScript/issues/51548\nexport { Schema };\n//# sourceMappingURL=blob.js.map"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2225, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/capabilities/dist/blob/index.js"],"sourcesContent":["/**\n * Blob Capabilities.\n *\n * The blob protocol allows authorized agents allocate memory space on a storage\n * node and subsequently verify the content has been accepted by / delivered to\n * said node.\n *\n * These can be imported directly with:\n * ```js\n * import * as Index from '@storacha/capabilities/blob'\n * ```\n *\n * @module\n * @see https://github.com/storacha/specs/blob/main/w3-blob.md\n */\nimport { capability, Schema, Link, ok } from '@ucanto/validator';\nimport { content } from '../space/blob.js';\nimport { equalBlob, equalWith, and, equal, checkLink, Await } from '../utils.js';\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derive any `blob/` prefixed capability.\n */\nexport const blob = capability({\n    can: 'blob/*',\n    /** Storage provider DID. */\n    with: Schema.did(),\n    derives: equalWith,\n});\n/**\n * The `blob/allocate` capability can be invoked to create a memory address on a\n * storage node where blob content can be written via a HTTP PUT request.\n */\nexport const allocate = capability({\n    can: 'blob/allocate',\n    /** Storage provider DID. */\n    with: Schema.did(),\n    nb: Schema.struct({\n        /** Blob to allocate. */\n        blob: content,\n        /** Link to the add blob task that initiated the allocation. */\n        cause: Schema.link({ version: 1 }),\n        /** DID of the user space where the allocation takes place. */\n        space: Schema.principal({ method: 'key' }),\n    }),\n    derives: (claimed, delegated) => and(equalWith(claimed, delegated)) ||\n        and(equalBlob(claimed, delegated)) ||\n        and(checkLink(claimed.nb.cause, delegated.nb.cause, 'cause')) ||\n        and(equal(claimed.nb.space?.did(), delegated.nb.space?.did(), 'space')) ||\n        ok({}),\n});\n/**\n * The `blob/accept` capability invocation should either succeed when content is\n * delivered on allocated address or fail if no content is allocation expires\n * without content being delivered.\n */\nexport const accept = capability({\n    can: 'blob/accept',\n    /** Storage provider DID. */\n    with: Schema.did(),\n    nb: Schema.struct({\n        /** Blob to accept. */\n        blob: content,\n        /** DID of the user space where allocation took place. */\n        space: Schema.principal({ method: 'key' }),\n        /** This task is blocked on `http/put` receipt available */\n        _put: Await,\n    }),\n    derives: (claimed, delegated) => and(equalWith(claimed, delegated)) ||\n        and(equalBlob(claimed, delegated)) ||\n        and(equal(claimed.nb.space?.did(), delegated.nb.space?.did(), 'space')) ||\n        ok({}),\n});\n// ⚠️ We export imports here so they are not omitted in generated typedefs\n// @see https://github.com/microsoft/TypeScript/issues/51548\nexport { Schema, Link };\n//# sourceMappingURL=index.js.map"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;CAcC;;;;;;;;AACD;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;AAKO,MAAM,OAAO,IAAA,wKAAU,EAAC;IAC3B,KAAK;IACL,0BAA0B,GAC1B,MAAM,6LAAM,CAAC,GAAG;IAChB,SAAS,wKAAS;AACtB;AAKO,MAAM,WAAW,IAAA,wKAAU,EAAC;IAC/B,KAAK;IACL,0BAA0B,GAC1B,MAAM,6LAAM,CAAC,GAAG;IAChB,IAAI,6LAAM,CAAC,MAAM,CAAC;QACd,sBAAsB,GACtB,MAAM,8LAAO;QACb,6DAA6D,GAC7D,OAAO,6LAAM,CAAC,IAAI,CAAC;YAAE,SAAS;QAAE;QAChC,4DAA4D,GAC5D,OAAO,6LAAM,CAAC,SAAS,CAAC;YAAE,QAAQ;QAAM;IAC5C;IACA,SAAS,CAAC,SAAS,YAAc,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,SAAS,eACpD,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,SAAS,eACvB,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,QAAQ,EAAE,CAAC,KAAK,EAAE,UAAU,EAAE,CAAC,KAAK,EAAE,aACpD,IAAA,kKAAG,EAAC,IAAA,oKAAK,EAAC,QAAQ,EAAE,CAAC,KAAK,EAAE,OAAO,UAAU,EAAE,CAAC,KAAK,EAAE,OAAO,aAC9D,IAAA,uJAAE,EAAC,CAAC;AACZ;AAMO,MAAM,SAAS,IAAA,wKAAU,EAAC;IAC7B,KAAK;IACL,0BAA0B,GAC1B,MAAM,6LAAM,CAAC,GAAG;IAChB,IAAI,6LAAM,CAAC,MAAM,CAAC;QACd,oBAAoB,GACpB,MAAM,8LAAO;QACb,uDAAuD,GACvD,OAAO,6LAAM,CAAC,SAAS,CAAC;YAAE,QAAQ;QAAM;QACxC,yDAAyD,GACzD,MAAM,oKAAK;IACf;IACA,SAAS,CAAC,SAAS,YAAc,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,SAAS,eACpD,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,SAAS,eACvB,IAAA,kKAAG,EAAC,IAAA,oKAAK,EAAC,QAAQ,EAAE,CAAC,KAAK,EAAE,OAAO,UAAU,EAAE,CAAC,KAAK,EAAE,OAAO,aAC9D,IAAA,uJAAE,EAAC,CAAC;AACZ;;CAIA,iCAAiC","ignoreList":[0]}},
    {"offset": {"line": 2337, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/capabilities/dist/web3.storage/blob.js"],"sourcesContent":["import { capability, Schema, Link, ok } from '@ucanto/validator';\nimport { content } from '../space/blob.js';\nimport { equalBlob, equalWith, SpaceDID, and, equal, checkLink, Await, } from '../utils.js';\n/**\n * Service capabilities for Blob protocol\n */\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derived any `web3.storage/blob/` prefixed capability for the (memory) space identified\n * by DID in the `with` field.\n *\n * @deprecated These capabilities were used by w3up to invoke on itself.\n */\nexport const blob = capability({\n    can: 'web3.storage/blob/*',\n    /**\n     * DID of the (memory) space where Blob is intended to\n     * be stored.\n     */\n    with: SpaceDID,\n    derives: equalWith,\n});\n/**\n * `web3.storage/blob//allocate` capability can be invoked to create a memory\n * address where blob content can be written via HTTP PUT request.\n *\n * @deprecated These capabilities were used by w3up to invoke on itself.\n */\nexport const allocate = capability({\n    can: 'web3.storage/blob/allocate',\n    /**\n     * Provider DID.\n     */\n    with: Schema.did(),\n    nb: Schema.struct({\n        /**\n         * Blob to allocate on the space.\n         */\n        blob: content,\n        /**\n         * The Link for an Add Blob task, that caused an allocation\n         */\n        cause: Link,\n        /**\n         * DID of the user space where allocation takes place\n         */\n        space: SpaceDID,\n    }),\n    derives: (claim, from) => {\n        return (and(equalWith(claim, from)) ||\n            and(equalBlob(claim, from)) ||\n            and(checkLink(claim.nb.cause, from.nb.cause, 'cause')) ||\n            and(equal(claim.nb.space, from.nb.space, 'space')) ||\n            ok({}));\n    },\n});\n/**\n * `blob/accept` capability invocation should either succeed when content is\n * delivered on allocated address or fail if no content is allocation expires\n * without content being delivered.\n *\n * @deprecated These capabilities were used by w3up to invoke on itself.\n */\nexport const accept = capability({\n    can: 'web3.storage/blob/accept',\n    /**\n     * Provider DID.\n     */\n    with: Schema.did(),\n    nb: Schema.struct({\n        /**\n         * Blob to accept.\n         */\n        blob: content,\n        /**\n         * Content location commitment time to live, which will be encoded as expiry of the issued location claim.\n         */\n        ttl: Schema.integer().optional(),\n        /**\n         * DID of the user space where allocation took place\n         */\n        space: SpaceDID,\n        /**\n         * This task is blocked on `http/put` receipt available\n         */\n        _put: Await,\n    }),\n    derives: (claim, from) => {\n        return (and(equalWith(claim, from)) ||\n            and(equalBlob(claim, from)) ||\n            and(equal(claim.nb.ttl, from.nb.ttl, 'ttl')) ||\n            and(equal(claim.nb.space, from.nb.space, 'space')) ||\n            ok({}));\n    },\n});\n// ⚠️ We export imports here so they are not omitted in generated typedefs\n// @see https://github.com/microsoft/TypeScript/issues/51548\nexport { Schema, Link };\n//# sourceMappingURL=blob.js.map"],"names":[],"mappings":";;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;AAWO,MAAM,OAAO,IAAA,wKAAU,EAAC;IAC3B,KAAK;IACL;;;KAGC,GACD,MAAM,uKAAQ;IACd,SAAS,wKAAS;AACtB;AAOO,MAAM,WAAW,IAAA,wKAAU,EAAC;IAC/B,KAAK;IACL;;KAEC,GACD,MAAM,6LAAM,CAAC,GAAG;IAChB,IAAI,6LAAM,CAAC,MAAM,CAAC;QACd;;SAEC,GACD,MAAM,8LAAO;QACb;;SAEC,GACD,OAAO,yJAAI;QACX;;SAEC,GACD,OAAO,uKAAQ;IACnB;IACA,SAAS,CAAC,OAAO;QACb,OAAQ,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,OAAO,UACzB,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,OAAO,UACrB,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,MAAM,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,KAAK,EAAE,aAC7C,IAAA,kKAAG,EAAC,IAAA,oKAAK,EAAC,MAAM,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,KAAK,EAAE,aACzC,IAAA,uJAAE,EAAC,CAAC;IACZ;AACJ;AAQO,MAAM,SAAS,IAAA,wKAAU,EAAC;IAC7B,KAAK;IACL;;KAEC,GACD,MAAM,6LAAM,CAAC,GAAG;IAChB,IAAI,6LAAM,CAAC,MAAM,CAAC;QACd;;SAEC,GACD,MAAM,8LAAO;QACb;;SAEC,GACD,KAAK,6LAAM,CAAC,OAAO,GAAG,QAAQ;QAC9B;;SAEC,GACD,OAAO,uKAAQ;QACf;;SAEC,GACD,MAAM,oKAAK;IACf;IACA,SAAS,CAAC,OAAO;QACb,OAAQ,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,OAAO,UACzB,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,OAAO,UACrB,IAAA,kKAAG,EAAC,IAAA,oKAAK,EAAC,MAAM,EAAE,CAAC,GAAG,EAAE,KAAK,EAAE,CAAC,GAAG,EAAE,WACrC,IAAA,kKAAG,EAAC,IAAA,oKAAK,EAAC,MAAM,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,KAAK,EAAE,aACzC,IAAA,uJAAE,EAAC,CAAC;IACZ;AACJ;;CAIA,gCAAgC","ignoreList":[0]}},
    {"offset": {"line": 2431, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/capabilities/dist/http.js"],"sourcesContent":["/**\n * HTTP Capabilities.\n *\n * These can be imported directly with:\n * ```js\n * import * as HTTP from '@storacha/capabilities/http'\n * ```\n *\n * @module\n */\nimport { capability, Schema, ok } from '@ucanto/validator';\nimport { content } from './space/blob.js';\nimport { equal, equalBody, equalWith, SpaceDID, Await, and } from './utils.js';\n/**\n * `http/put` capability invocation MAY be performed by any authorized agent on behalf of the subject\n * as long as they have referenced `body` content to do so.\n */\nexport const put = capability({\n    can: 'http/put',\n    /**\n     * DID of the (memory) space where Blob is intended to\n     * be stored.\n     */\n    with: SpaceDID,\n    nb: Schema.struct({\n        /**\n         * Description of body to send (digest/size).\n         */\n        body: content,\n        /**\n         * HTTP(S) location that can receive blob content via HTTP PUT request.\n         */\n        url: Schema.string().or(Await),\n        /**\n         * HTTP headers.\n         */\n        headers: Schema.dictionary({ value: Schema.string() }).or(Await),\n    }),\n    derives: (claim, from) => {\n        return (and(equalWith(claim, from)) ||\n            and(equalBody(claim, from)) ||\n            and(equal(claim.nb.url, from.nb, 'url')) ||\n            and(equal(claim.nb.headers, from.nb, 'headers')) ||\n            ok({}));\n    },\n});\n//# sourceMappingURL=http.js.map"],"names":[],"mappings":"AAAA;;;;;;;;;CASC;;;;AACD;AAAA;AAAA;AAAA;AACA;AACA;;;;AAKO,MAAM,MAAM,IAAA,wKAAU,EAAC;IAC1B,KAAK;IACL;;;KAGC,GACD,MAAM,uKAAQ;IACd,IAAI,6LAAM,CAAC,MAAM,CAAC;QACd;;SAEC,GACD,MAAM,8LAAO;QACb;;SAEC,GACD,KAAK,6LAAM,CAAC,MAAM,GAAG,EAAE,CAAC,oKAAK;QAC7B;;SAEC,GACD,SAAS,6LAAM,CAAC,UAAU,CAAC;YAAE,OAAO,6LAAM,CAAC,MAAM;QAAG,GAAG,EAAE,CAAC,oKAAK;IACnE;IACA,SAAS,CAAC,OAAO;QACb,OAAQ,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,OAAO,UACzB,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,OAAO,UACrB,IAAA,kKAAG,EAAC,IAAA,oKAAK,EAAC,MAAM,EAAE,CAAC,GAAG,EAAE,KAAK,EAAE,EAAE,WACjC,IAAA,kKAAG,EAAC,IAAA,oKAAK,EAAC,MAAM,EAAE,CAAC,OAAO,EAAE,KAAK,EAAE,EAAE,eACrC,IAAA,uJAAE,EAAC,CAAC;IACZ;AACJ,IACA,gCAAgC","ignoreList":[0]}},
    {"offset": {"line": 2480, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/capabilities/dist/account/usage.js"],"sourcesContent":["import { capability, fail, ok, Schema } from '@ucanto/validator';\nimport { AccountDID, SpaceDID, equalWith, and, equal, containedWithin, } from '../utils.js';\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * be derived any `account/usage/` prefixed capability for the account identified\n * by DID in the `with` field.\n */\nexport const accountUsage = capability({\n    can: 'account/usage/*',\n    with: AccountDID,\n    derives: equalWith,\n});\n/**\n * Capability can be invoked by an agent to retrieve usage data for all or a\n * specified set of spaces within an account in a given period.\n */\nexport const get = capability({\n    can: 'account/usage/get',\n    with: AccountDID,\n    nb: Schema.struct({\n        spaces: SpaceDID.array().optional(),\n        /** Period to retrieve events between. */\n        period: Schema.struct({\n            /** Time in seconds after Unix epoch (inclusive). */\n            from: Schema.integer().greaterThan(-1),\n            /** Time in seconds after Unix epoch (exclusive). */\n            to: Schema.integer().greaterThan(-1),\n        }).optional(),\n    }),\n    derives: (child, parent) => {\n        return (and(equalWith(child, parent)) ||\n            and((() => {\n                if (parent.nb.spaces === undefined) {\n                    return ok({});\n                }\n                if (child.nb.spaces === undefined) {\n                    return fail(`Constraint violation: violates imposed spaces constraint ${parent.nb.spaces} because it asks for all spaces`);\n                }\n                return containedWithin(child.nb.spaces, parent.nb.spaces, 'spaces');\n            })()) ||\n            and(equal(child.nb.period?.from, parent.nb.period?.from, 'period.from')) ||\n            and(equal(child.nb.period?.to, parent.nb.period?.to, 'period.to')) ||\n            ok({}));\n    },\n});\n//# sourceMappingURL=usage.js.map"],"names":[],"mappings":";;;;;;AAAA;AAAA;AAAA;AAAA;AACA;;;AAMO,MAAM,eAAe,IAAA,wKAAU,EAAC;IACnC,KAAK;IACL,MAAM,yKAAU;IAChB,SAAS,wKAAS;AACtB;AAKO,MAAM,MAAM,IAAA,wKAAU,EAAC;IAC1B,KAAK;IACL,MAAM,yKAAU;IAChB,IAAI,6LAAM,CAAC,MAAM,CAAC;QACd,QAAQ,uKAAQ,CAAC,KAAK,GAAG,QAAQ;QACjC,uCAAuC,GACvC,QAAQ,6LAAM,CAAC,MAAM,CAAC;YAClB,kDAAkD,GAClD,MAAM,6LAAM,CAAC,OAAO,GAAG,WAAW,CAAC,CAAC;YACpC,kDAAkD,GAClD,IAAI,6LAAM,CAAC,OAAO,GAAG,WAAW,CAAC,CAAC;QACtC,GAAG,QAAQ;IACf;IACA,SAAS,CAAC,OAAO;QACb,OAAQ,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,OAAO,YACzB,IAAA,kKAAG,EAAC,CAAC;YACD,IAAI,OAAO,EAAE,CAAC,MAAM,KAAK,WAAW;gBAChC,OAAO,IAAA,uJAAE,EAAC,CAAC;YACf;YACA,IAAI,MAAM,EAAE,CAAC,MAAM,KAAK,WAAW;gBAC/B,OAAO,IAAA,yJAAI,EAAC,CAAC,yDAAyD,EAAE,OAAO,EAAE,CAAC,MAAM,CAAC,+BAA+B,CAAC;YAC7H;YACA,OAAO,IAAA,8KAAe,EAAC,MAAM,EAAE,CAAC,MAAM,EAAE,OAAO,EAAE,CAAC,MAAM,EAAE;QAC9D,CAAC,QACD,IAAA,kKAAG,EAAC,IAAA,oKAAK,EAAC,MAAM,EAAE,CAAC,MAAM,EAAE,MAAM,OAAO,EAAE,CAAC,MAAM,EAAE,MAAM,mBACzD,IAAA,kKAAG,EAAC,IAAA,oKAAK,EAAC,MAAM,EAAE,CAAC,MAAM,EAAE,IAAI,OAAO,EAAE,CAAC,MAAM,EAAE,IAAI,iBACrD,IAAA,uJAAE,EAAC,CAAC;IACZ;AACJ,IACA,iCAAiC","ignoreList":[0]}},
    {"offset": {"line": 2524, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/capabilities/dist/pdp.js"],"sourcesContent":["/**\n * PDP (Proof of Data Possession) Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as PDP from '@storacha/capabilities/pdp'\n * ```\n *\n * @module\n */\nimport { capability, Schema, ok } from '@ucanto/validator';\nimport { equalWith, and, equal } from './utils.js';\n/**\n * `pdp/accept` capability allows an agent to signal acceptance of a blob\n * into a PDP aggregate. The capability confirms that the blob has been\n * included in an aggregate piece with the provided inclusion proof.\n */\nexport const accept = capability({\n    can: 'pdp/accept',\n    /**\n     * DID of the service accepting the blob.\n     */\n    with: Schema.did(),\n    nb: Schema.struct({\n        /**\n         * Multihash digest of the blob being accepted.\n         */\n        blob: Schema.bytes(),\n    }),\n    derives: (claim, from) => {\n        return (and(equalWith(claim, from)) ||\n            and(equal(claim.nb.blob, from.nb.blob, 'blob')) ||\n            ok({}));\n    },\n});\n/**\n * `pdp/info` capability allows an agent to request information about\n * a blob's inclusion in PDP aggregates. The response includes the piece\n * CID and a list of aggregates containing the blob with their inclusion proofs.\n */\nexport const info = capability({\n    can: 'pdp/info',\n    /**\n     * DID of the service providing blob information.\n     */\n    with: Schema.did(),\n    nb: Schema.struct({\n        /**\n         * Multihash digest of the blob to query.\n         */\n        blob: Schema.bytes(),\n    }),\n    derives: (claim, from) => {\n        return (and(equalWith(claim, from)) ||\n            and(equal(claim.nb.blob, from.nb.blob, 'blob')) ||\n            ok({}));\n    },\n});\n// �\u000f We export imports here so they are not omitted in generated typedefs\n// @see https://github.com/microsoft/TypeScript/issues/51548\nexport { Schema };\n//# sourceMappingURL=pdp.js.map"],"names":[],"mappings":"AAAA;;;;;;;;;CASC;;;;;;AACD;AAAA;AAAA;AAAA;AACA;;;AAMO,MAAM,SAAS,IAAA,wKAAU,EAAC;IAC7B,KAAK;IACL;;KAEC,GACD,MAAM,6LAAM,CAAC,GAAG;IAChB,IAAI,6LAAM,CAAC,MAAM,CAAC;QACd;;SAEC,GACD,MAAM,6LAAM,CAAC,KAAK;IACtB;IACA,SAAS,CAAC,OAAO;QACb,OAAQ,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,OAAO,UACzB,IAAA,kKAAG,EAAC,IAAA,oKAAK,EAAC,MAAM,EAAE,CAAC,IAAI,EAAE,KAAK,EAAE,CAAC,IAAI,EAAE,YACvC,IAAA,uJAAE,EAAC,CAAC;IACZ;AACJ;AAMO,MAAM,OAAO,IAAA,wKAAU,EAAC;IAC3B,KAAK;IACL;;KAEC,GACD,MAAM,6LAAM,CAAC,GAAG;IAChB,IAAI,6LAAM,CAAC,MAAM,CAAC;QACd;;SAEC,GACD,MAAM,6LAAM,CAAC,KAAK;IACtB;IACA,SAAS,CAAC,OAAO;QACb,OAAQ,IAAA,kKAAG,EAAC,IAAA,wKAAS,EAAC,OAAO,UACzB,IAAA,kKAAG,EAAC,IAAA,oKAAK,EAAC,MAAM,EAAE,CAAC,IAAI,EAAE,KAAK,EAAE,CAAC,IAAI,EAAE,YACvC,IAAA,uJAAE,EAAC,CAAC;IACZ;AACJ;;CAIA,+BAA+B","ignoreList":[0]}},
    {"offset": {"line": 2594, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40storacha/capabilities/dist/index.js"],"sourcesContent":["import * as Assert from './assert.js';\nimport * as Claim from './claim.js';\nimport * as Provider from './provider.js';\nimport * as Space from './space.js';\nimport * as Top from './top.js';\nimport * as Store from './store.js';\nimport * as Upload from './upload.js';\nimport * as Access from './access.js';\nimport * as Utils from './utils.js';\nimport * as Consumer from './consumer.js';\nimport * as Customer from './customer.js';\nimport * as Console from './console.js';\nimport * as RateLimit from './rate-limit.js';\nimport * as Admin from './admin.js';\nimport * as Subscription from './subscription.js';\nimport * as Filecoin from './filecoin/index.js';\nimport * as Storefront from './filecoin/storefront.js';\nimport * as Aggregator from './filecoin/aggregator.js';\nimport * as Dealer from './filecoin/dealer.js';\nimport * as DealTracker from './filecoin/deal-tracker.js';\nimport * as SpaceIndex from './space/index.js';\nimport * as UCAN from './ucan.js';\nimport * as Plan from './plan.js';\nimport * as Usage from './usage.js';\nimport * as Blob from './blob/index.js';\nimport * as SpaceBlob from './space/blob.js';\nimport * as W3sBlob from './web3.storage/blob.js';\nimport * as HTTP from './http.js';\nimport * as AccountUsage from './account/usage.js';\nimport * as PDP from './pdp.js';\nexport { Access, Assert, Claim, Provider, Space, Top, Store, Upload, Consumer, Customer, Console, Utils, RateLimit, Subscription, Filecoin, SpaceIndex, Storefront, Aggregator, Dealer, DealTracker, Admin, UCAN, Plan, Usage, Blob, SpaceBlob, W3sBlob, HTTP, AccountUsage, PDP, };\n/** @type {import('./types.js').ServiceAbility[]} */\nexport const abilitiesAsStrings = [\n    Top.top.can,\n    Assert.assert.can,\n    Assert.equals.can,\n    Assert.inclusion.can,\n    Assert.index.can,\n    Assert.location.can,\n    Assert.partition.can,\n    Assert.relation.can,\n    Claim.claim.can,\n    Claim.cache.can,\n    Provider.add.can,\n    Space.space.can,\n    Space.info.can,\n    Space.EncryptionSetup.can,\n    Space.EncryptionKeyDecrypt.can,\n    Upload.upload.can,\n    Upload.add.can,\n    Upload.get.can,\n    Upload.remove.can,\n    Upload.list.can,\n    Store.store.can,\n    Store.add.can,\n    Store.get.can,\n    Store.remove.can,\n    Store.list.can,\n    Access.access.can,\n    Access.authorize.can,\n    UCAN.attest.can,\n    UCAN.conclude.can,\n    Customer.get.can,\n    Consumer.has.can,\n    Consumer.get.can,\n    Subscription.get.can,\n    Subscription.list.can,\n    RateLimit.add.can,\n    RateLimit.remove.can,\n    RateLimit.list.can,\n    Storefront.filecoinOffer.can,\n    Storefront.filecoinSubmit.can,\n    Storefront.filecoinAccept.can,\n    Storefront.filecoinInfo.can,\n    Aggregator.pieceOffer.can,\n    Aggregator.pieceAccept.can,\n    Dealer.aggregateOffer.can,\n    Dealer.aggregateAccept.can,\n    DealTracker.dealInfo.can,\n    Admin.admin.can,\n    Admin.upload.inspect.can,\n    Admin.store.inspect.can,\n    Plan.get.can,\n    Plan.set.can,\n    Plan.createAdminSession.can,\n    Usage.usage.can,\n    Usage.report.can,\n    Blob.blob.can,\n    Blob.allocate.can,\n    Blob.accept.can,\n    SpaceBlob.blob.can,\n    SpaceBlob.add.can,\n    SpaceBlob.remove.can,\n    SpaceBlob.list.can,\n    W3sBlob.blob.can,\n    W3sBlob.allocate.can,\n    W3sBlob.accept.can,\n    HTTP.put.can,\n    SpaceIndex.index.can,\n    SpaceIndex.add.can,\n    AccountUsage.get.can,\n    PDP.accept.can,\n    PDP.info.can,\n];\n//# sourceMappingURL=index.js.map"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAGO,MAAM,qBAAqB;IAC9B,gKAAO,CAAC,GAAG;IACX,sKAAa,CAAC,GAAG;IACjB,sKAAa,CAAC,GAAG;IACjB,yKAAgB,CAAC,GAAG;IACpB,qKAAY,CAAC,GAAG;IAChB,wKAAe,CAAC,GAAG;IACnB,yKAAgB,CAAC,GAAG;IACpB,wKAAe,CAAC,GAAG;IACnB,oKAAW,CAAC,GAAG;IACf,oKAAW,CAAC,GAAG;IACf,qLAAY,CAAC,GAAG;IAChB,oLAAW,CAAC,GAAG;IACf,mLAAU,CAAC,GAAG;IACd,8LAAqB,CAAC,GAAG;IACzB,mMAA0B,CAAC,GAAG;IAC9B,sLAAa,CAAC,GAAG;IACjB,mLAAU,CAAC,GAAG;IACd,mLAAU,CAAC,GAAG;IACd,sLAAa,CAAC,GAAG;IACjB,oLAAW,CAAC,GAAG;IACf,oLAAW,CAAC,GAAG;IACf,kLAAS,CAAC,GAAG;IACb,kLAAS,CAAC,GAAG;IACb,qLAAY,CAAC,GAAG;IAChB,mLAAU,CAAC,GAAG;IACd,sLAAa,CAAC,GAAG;IACjB,yLAAgB,CAAC,GAAG;IACpB,oKAAW,CAAC,GAAG;IACf,sKAAa,CAAC,GAAG;IACjB,qKAAY,CAAC,GAAG;IAChB,qKAAY,CAAC,GAAG;IAChB,qKAAY,CAAC,GAAG;IAChB,yKAAgB,CAAC,GAAG;IACpB,0KAAiB,CAAC,GAAG;IACrB,0KAAa,CAAC,GAAG;IACjB,6KAAgB,CAAC,GAAG;IACpB,2KAAc,CAAC,GAAG;IAClB,6LAAwB,CAAC,GAAG;IAC5B,8LAAyB,CAAC,GAAG;IAC7B,8LAAyB,CAAC,GAAG;IAC7B,4LAAuB,CAAC,GAAG;IAC3B,0LAAqB,CAAC,GAAG;IACzB,2LAAsB,CAAC,GAAG;IAC1B,0LAAqB,CAAC,GAAG;IACzB,2LAAsB,CAAC,GAAG;IAC1B,6LAAoB,CAAC,GAAG;IACxB,oKAAW,CAAC,GAAG;IACf,qKAAY,CAAC,OAAO,CAAC,GAAG;IACxB,oKAAW,CAAC,OAAO,CAAC,GAAG;IACvB,iKAAQ,CAAC,GAAG;IACZ,iKAAQ,CAAC,GAAG;IACZ,gLAAuB,CAAC,GAAG;IAC3B,oKAAW,CAAC,GAAG;IACf,qKAAY,CAAC,GAAG;IAChB,2LAAS,CAAC,GAAG;IACb,+LAAa,CAAC,GAAG;IACjB,6LAAW,CAAC,GAAG;IACf,2LAAc,CAAC,GAAG;IAClB,0LAAa,CAAC,GAAG;IACjB,6LAAgB,CAAC,GAAG;IACpB,2LAAc,CAAC,GAAG;IAClB,qMAAY,CAAC,GAAG;IAChB,yMAAgB,CAAC,GAAG;IACpB,uMAAc,CAAC,GAAG;IAClB,iKAAQ,CAAC,GAAG;IACZ,6LAAgB,CAAC,GAAG;IACpB,2LAAc,CAAC,GAAG;IAClB,6KAAgB,CAAC,GAAG;IACpB,mLAAU,CAAC,GAAG;IACd,iLAAQ,CAAC,GAAG;CACf,EACD,iCAAiC","ignoreList":[0]}}]
}