module.exports = [
"[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/util/longbits.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = LongBits;
var util = __turbopack_context__.r("[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/util/minimal.js [app-ssr] (ecmascript)");
/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */ function LongBits(lo, hi) {
    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.
    /**
     * Low bits.
     * @type {number}
     */ this.lo = lo >>> 0;
    /**
     * High bits.
     * @type {number}
     */ this.hi = hi >>> 0;
}
/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */ var zero = LongBits.zero = new LongBits(0, 0);
zero.toNumber = function() {
    return 0;
};
zero.zzEncode = zero.zzDecode = function() {
    return this;
};
zero.length = function() {
    return 1;
};
/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */ var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */ LongBits.fromNumber = function fromNumber(value) {
    if (value === 0) return zero;
    var sign = value < 0;
    if (sign) value = -value;
    var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295) hi = 0;
        }
    }
    return new LongBits(lo, hi);
};
/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */ LongBits.from = function from(value) {
    if (typeof value === "number") return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */ if (util.Long) value = util.Long.fromString(value);
        else return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};
/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */ LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo) hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};
/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */ LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : {
        low: this.lo | 0,
        high: this.hi | 0,
        unsigned: Boolean(unsigned)
    };
};
var charCodeAt = String.prototype.charCodeAt;
/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */ LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash) return zero;
    return new LongBits((charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0, (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0);
};
/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */ LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
};
/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */ LongBits.prototype.zzEncode = function zzEncode() {
    var mask = this.hi >> 31;
    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo = (this.lo << 1 ^ mask) >>> 0;
    return this;
};
/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */ LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi = (this.hi >>> 1 ^ mask) >>> 0;
    return this;
};
/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */ LongBits.prototype.length = function length() {
    var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
    return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
};
}),
"[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/util/minimal.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var util = exports;
// used to return a Promise where callback is omitted
util.asPromise = __turbopack_context__.r("[project]/node_modules/@protobufjs/aspromise/index.js [app-ssr] (ecmascript)");
// converts to / from base64 encoded strings
util.base64 = __turbopack_context__.r("[project]/node_modules/@protobufjs/base64/index.js [app-ssr] (ecmascript)");
// base class of rpc.Service
util.EventEmitter = __turbopack_context__.r("[project]/node_modules/@protobufjs/eventemitter/index.js [app-ssr] (ecmascript)");
// float handling accross browsers
util.float = __turbopack_context__.r("[project]/node_modules/@protobufjs/float/index.js [app-ssr] (ecmascript)");
// requires modules optionally and hides the call from bundlers
util.inquire = __turbopack_context__.r("[project]/node_modules/@protobufjs/inquire/index.js [app-ssr] (ecmascript)");
// converts to / from utf8 encoded strings
util.utf8 = __turbopack_context__.r("[project]/node_modules/@protobufjs/utf8/index.js [app-ssr] (ecmascript)");
// provides a node-like buffer pool in the browser
util.pool = __turbopack_context__.r("[project]/node_modules/@protobufjs/pool/index.js [app-ssr] (ecmascript)");
// utility to work with the low and high bits of a 64 bit value
util.LongBits = __turbopack_context__.r("[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/util/longbits.js [app-ssr] (ecmascript)");
/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 */ util.isNode = Boolean(("TURBOPACK compile-time value", "object") !== "undefined" && /*TURBOPACK member replacement*/ __turbopack_context__.g && /*TURBOPACK member replacement*/ __turbopack_context__.g.process && /*TURBOPACK member replacement*/ __turbopack_context__.g.process.versions && /*TURBOPACK member replacement*/ __turbopack_context__.g.process.versions.node);
/**
 * Global object reference.
 * @memberof util
 * @type {Object}
 */ util.global = util.isNode && /*TURBOPACK member replacement*/ __turbopack_context__.g || ("TURBOPACK compile-time value", "undefined") !== "undefined" && window || typeof self !== "undefined" && self || /*TURBOPACK member replacement*/ __turbopack_context__.e; // eslint-disable-line no-invalid-this
/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */ util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes
/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */ util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes
/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */ util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};
/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */ util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};
/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */ util.isObject = function isObject(value) {
    return value && typeof value === "object";
};
/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */ util.isset = /**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */ util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};
/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */ /**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */ util.Buffer = function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */ return null;
    }
}();
// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;
// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;
/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */ util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */ return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
};
/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */ util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */  : Array;
/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */ /**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */ util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long || /* istanbul ignore next */ util.global.Long || util.inquire("long");
/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */ util.key2Re = /^true|false|0|1$/;
/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */ util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */ util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */ util.longToHash = function longToHash(value) {
    return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
};
/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */ util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long) return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};
/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */ function merge(dst, src, ifNotSet) {
    for(var keys = Object.keys(src), i = 0; i < keys.length; ++i)if (dst[keys[i]] === undefined || !ifNotSet) dst[keys[i]] = src[keys[i]];
    return dst;
}
util.merge = merge;
/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */ util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};
/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */ function newError(name) {
    function CustomError(message, properties) {
        if (!(this instanceof CustomError)) return new CustomError(message, properties);
        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function
        Object.defineProperty(this, "message", {
            get: function() {
                return message;
            }
        });
        /* istanbul ignore next */ if (Error.captureStackTrace) Error.captureStackTrace(this, CustomError);
        else Object.defineProperty(this, "stack", {
            value: new Error().stack || ""
        });
        if (properties) merge(this, properties);
    }
    CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
            value: CustomError,
            writable: true,
            enumerable: false,
            configurable: true
        },
        name: {
            get: function get() {
                return name;
            },
            set: undefined,
            enumerable: false,
            // configurable: false would accurately preserve the behavior of
            // the original, but I'm guessing that was not intentional.
            // For an actual error subclass, this property would
            // be configurable.
            configurable: true
        },
        toString: {
            value: function value() {
                return this.name + ": " + this.message;
            },
            writable: true,
            enumerable: false,
            configurable: true
        }
    });
    return CustomError;
}
util.newError = newError;
/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */ util.ProtocolError = newError("ProtocolError");
/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */ /**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */ /**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */ util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for(var i = 0; i < fieldNames.length; ++i)fieldMap[fieldNames[i]] = 1;
    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */ return function() {
        for(var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null) return keys[i];
    };
};
/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */ /**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */ util.oneOfSetter = function setOneOf(fieldNames) {
    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */ return function(name) {
        for(var i = 0; i < fieldNames.length; ++i)if (fieldNames[i] !== name) delete this[fieldNames[i]];
    };
};
/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */ util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};
// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */ if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from || /* istanbul ignore next */ function Buffer_from(value, encoding) {
        return new Buffer(value, encoding);
    };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe || /* istanbul ignore next */ function Buffer_allocUnsafe(size) {
        return new Buffer(size);
    };
};
}),
"[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/writer.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = Writer;
var util = __turbopack_context__.r("[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/util/minimal.js [app-ssr] (ecmascript)");
var BufferWriter; // cyclic
var LongBits = util.LongBits, base64 = util.base64, utf8 = util.utf8;
/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */ function Op(fn, len, val) {
    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */ this.fn = fn;
    /**
     * Value byte length.
     * @type {number}
     */ this.len = len;
    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */ this.next = undefined;
    /**
     * Value to write.
     * @type {*}
     */ this.val = val; // type varies
}
/* istanbul ignore next */ function noop() {} // eslint-disable-line no-empty-function
/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */ function State(writer) {
    /**
     * Current head.
     * @type {Writer.Op}
     */ this.head = writer.head;
    /**
     * Current tail.
     * @type {Writer.Op}
     */ this.tail = writer.tail;
    /**
     * Current buffer length.
     * @type {number}
     */ this.len = writer.len;
    /**
     * Next state.
     * @type {State|null}
     */ this.next = writer.states;
}
/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */ function Writer() {
    /**
     * Current length.
     * @type {number}
     */ this.len = 0;
    /**
     * Operations head.
     * @type {Object}
     */ this.head = new Op(noop, 0, 0);
    /**
     * Operations tail
     * @type {Object}
     */ this.tail = this.head;
    /**
     * Linked forked states.
     * @type {Object|null}
     */ this.states = null;
// When a value is written, the writer calculates its byte length and puts it into a linked
// list of operations to perform when finish() is called. This both allows us to allocate
// buffers of the exact required size and reduces the amount of work we have to do compared
// to first calculating over objects and then encoding over objects. In our case, the encoding
// part is just a linked list walk calling operations with already prepared values.
}
var create = function create() {
    return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
            return new BufferWriter();
        })();
    } : function create_array() {
        return new Writer();
    };
};
/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */ Writer.create = create();
/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */ Writer.alloc = function alloc(size) {
    return new util.Array(size);
};
// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */ if (util.Array !== Array) Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */ Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};
function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}
function writeVarint32(val, buf, pos) {
    while(val > 127){
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}
/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */ function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}
VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;
/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
    return this;
};
/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.int32 = function write_int32(value) {
    return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
     : this.uint32(value);
};
/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};
function writeVarint64(val, buf, pos) {
    while(val.hi){
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while(val.lo > 127){
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}
/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */ Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};
/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */ Writer.prototype.int64 = Writer.prototype.uint64;
/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */ Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};
/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};
function writeFixed32(val, buf, pos) {
    buf[pos] = val & 255;
    buf[pos + 1] = val >>> 8 & 255;
    buf[pos + 2] = val >>> 16 & 255;
    buf[pos + 3] = val >>> 24;
}
/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};
/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.sfixed32 = Writer.prototype.fixed32;
/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */ Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};
/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */ Writer.prototype.sfixed64 = Writer.prototype.fixed64;
/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};
/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};
var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
    buf.set(val, pos); // also works for plain array values
} : function writeBytes_for(val, buf, pos) {
    for(var i = 0; i < val.length; ++i)buf[pos + i] = val[i];
};
/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */ Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len) return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};
/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
};
/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */ Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};
/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */ Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
    }
    return this;
};
/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */ Writer.prototype.ldelim = function ldelim() {
    var head = this.head, tail = this.tail, len = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};
/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */ Writer.prototype.finish = function finish() {
    var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
    while(head){
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};
Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
};
}),
"[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/writer_buffer.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = BufferWriter;
// extends Writer
var Writer = __turbopack_context__.r("[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/writer.js [app-ssr] (ecmascript)");
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
var util = __turbopack_context__.r("[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/util/minimal.js [app-ssr] (ecmascript)");
/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */ function BufferWriter() {
    Writer.call(this);
}
BufferWriter._configure = function() {
    /**
     * Allocates a buffer of the specified size.
     * @function
     * @param {number} size Buffer size
     * @returns {Buffer} Buffer
     */ BufferWriter.alloc = util._Buffer_allocUnsafe;
    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
    // also works for plain array values
    } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy) val.copy(buf, pos, 0, val.length);
        else for(var i = 0; i < val.length;)buf[pos++] = val[i++];
    };
};
/**
 * @override
 */ BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value)) value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len) this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
};
function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) util.utf8.write(val, buf, pos);
    else if (buf.utf8Write) buf.utf8Write(val, pos);
    else buf.write(val, pos);
}
/**
 * @override
 */ BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util.Buffer.byteLength(value);
    this.uint32(len);
    if (len) this._push(writeStringBuffer, len, value);
    return this;
};
/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */ BufferWriter._configure();
}),
"[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/reader.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = Reader;
var util = __turbopack_context__.r("[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/util/minimal.js [app-ssr] (ecmascript)");
var BufferReader; // cyclic
var LongBits = util.LongBits, utf8 = util.utf8;
/* istanbul ignore next */ function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}
/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */ function Reader(buffer) {
    /**
     * Read buffer.
     * @type {Uint8Array}
     */ this.buf = buffer;
    /**
     * Read buffer position.
     * @type {number}
     */ this.pos = 0;
    /**
     * Read buffer length.
     * @type {number}
     */ this.len = buffer.length;
}
var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
    if (buffer instanceof Uint8Array || Array.isArray(buffer)) return new Reader(buffer);
    throw Error("illegal buffer");
} : function create_array(buffer) {
    if (Array.isArray(buffer)) return new Reader(buffer);
    throw Error("illegal buffer");
};
var create = function create() {
    return util.Buffer ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer) {
            return util.Buffer.isBuffer(buffer) ? new BufferReader(buffer) : create_array(buffer);
        })(buffer);
    } : create_array;
};
/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */ Reader.create = create();
Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;
/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */ Reader.prototype.uint32 = function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        /* istanbul ignore if */ if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
}();
/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */ Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};
/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */ Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};
/* eslint-disable no-invalid-this */ function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) {
        for(; i < 4; ++i){
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128) return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128) return bits;
        i = 0;
    } else {
        for(; i < 3; ++i){
            /* istanbul ignore if */ if (this.pos >= this.len) throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128) return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) {
        for(; i < 5; ++i){
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128) return bits;
        }
    } else {
        for(; i < 5; ++i){
            /* istanbul ignore if */ if (this.pos >= this.len) throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128) return bits;
        }
    }
    /* istanbul ignore next */ throw Error("invalid varint encoding");
}
/* eslint-enable no-invalid-this */ /**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */ /**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */ /**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */ /**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */ Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};
function readFixed32_end(buf, end) {
    return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
}
/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */ Reader.prototype.fixed32 = function read_fixed32() {
    /* istanbul ignore if */ if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
    return readFixed32_end(this.buf, this.pos += 4);
};
/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */ Reader.prototype.sfixed32 = function read_sfixed32() {
    /* istanbul ignore if */ if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
    return readFixed32_end(this.buf, this.pos += 4) | 0;
};
/* eslint-disable no-invalid-this */ function readFixed64() {
    /* istanbul ignore if */ if (this.pos + 8 > this.len) throw indexOutOfRange(this, 8);
    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}
/* eslint-enable no-invalid-this */ /**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */ /**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */ /**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */ Reader.prototype.float = function read_float() {
    /* istanbul ignore if */ if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};
/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */ Reader.prototype.double = function read_double() {
    /* istanbul ignore if */ if (this.pos + 8 > this.len) throw indexOutOfRange(this, 4);
    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};
/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */ Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(), start = this.pos, end = this.pos + length;
    /* istanbul ignore if */ if (end > this.len) throw indexOutOfRange(this, length);
    this.pos += length;
    if (Array.isArray(this.buf)) return this.buf.slice(start, end);
    if (start === end) {
        var nativeBuffer = util.Buffer;
        return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);
    }
    return this._slice.call(this.buf, start, end);
};
/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */ Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};
/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */ Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */ if (this.pos + length > this.len) throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */ if (this.pos >= this.len) throw indexOutOfRange(this);
        }while (this.buf[this.pos++] & 128)
    }
    return this;
};
/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */ Reader.prototype.skipType = function(wireType) {
    switch(wireType){
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while((wireType = this.uint32() & 7) !== 4){
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;
        /* istanbul ignore next */ default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};
Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();
    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {
        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }
    });
};
}),
"[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/reader_buffer.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = BufferReader;
// extends Reader
var Reader = __turbopack_context__.r("[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/reader.js [app-ssr] (ecmascript)");
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
var util = __turbopack_context__.r("[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/util/minimal.js [app-ssr] (ecmascript)");
/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */ function BufferReader(buffer) {
    Reader.call(this, buffer);
/**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */ }
BufferReader._configure = function() {
    /* istanbul ignore else */ if (util.Buffer) BufferReader.prototype._slice = util.Buffer.prototype.slice;
};
/**
 * @override
 */ BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};
/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */ BufferReader._configure();
}),
"[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/rpc/service.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = Service;
var util = __turbopack_context__.r("[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/util/minimal.js [app-ssr] (ecmascript)");
// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */ /**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */ /**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */ function Service(rpcImpl, requestDelimited, responseDelimited) {
    if (typeof rpcImpl !== "function") throw TypeError("rpcImpl must be a function");
    util.EventEmitter.call(this);
    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */ this.rpcImpl = rpcImpl;
    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */ this.requestDelimited = Boolean(requestDelimited);
    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */ this.responseDelimited = Boolean(responseDelimited);
}
/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */ Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
    if (!request) throw TypeError("request must be specified");
    var self = this;
    if (!callback) return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);
    if (!self.rpcImpl) {
        setTimeout(function() {
            callback(Error("already ended"));
        }, 0);
        return undefined;
    }
    try {
        return self.rpcImpl(method, requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(), function rpcCallback(err, response) {
            if (err) {
                self.emit("error", err, method);
                return callback(err);
            }
            if (response === null) {
                self.end(/* endedByRPC */ true);
                return undefined;
            }
            if (!(response instanceof responseCtor)) {
                try {
                    response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                } catch (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }
            }
            self.emit("data", response, method);
            return callback(null, response);
        });
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() {
            callback(err);
        }, 0);
        return undefined;
    }
};
/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */ Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};
}),
"[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/rpc.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Streaming RPC helpers.
 * @namespace
 */ var rpc = exports;
/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */ /**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */ rpc.Service = __turbopack_context__.r("[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/rpc/service.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/roots.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = {}; /**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available across modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */ 
}),
"[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/index-minimal.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var protobuf = exports;
/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */ protobuf.build = "minimal";
// Serialization
protobuf.Writer = __turbopack_context__.r("[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/writer.js [app-ssr] (ecmascript)");
protobuf.BufferWriter = __turbopack_context__.r("[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/writer_buffer.js [app-ssr] (ecmascript)");
protobuf.Reader = __turbopack_context__.r("[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/reader.js [app-ssr] (ecmascript)");
protobuf.BufferReader = __turbopack_context__.r("[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/reader_buffer.js [app-ssr] (ecmascript)");
// Utility
protobuf.util = __turbopack_context__.r("[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/util/minimal.js [app-ssr] (ecmascript)");
protobuf.rpc = __turbopack_context__.r("[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/rpc.js [app-ssr] (ecmascript)");
protobuf.roots = __turbopack_context__.r("[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/roots.js [app-ssr] (ecmascript)");
protobuf.configure = configure;
/* istanbul ignore next */ /**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */ function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
}
// Set up buffer utility according to the environment
configure();
}),
"[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/minimal.js [app-ssr] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// minimal library entry point.
module.exports = __turbopack_context__.r("[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/index-minimal.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/@ipld/dag-ucan/src/ucan.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
}),
"[project]/node_modules/@ipld/dag-ucan/src/utf8.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "decode",
    ()=>decode,
    "decoder",
    ()=>decoder,
    "encode",
    ()=>encode,
    "encoder",
    ()=>encoder
]);
const encoder = new TextEncoder();
const decoder = new TextDecoder();
const encode = (text)=>encoder.encode(text);
const decode = (bytes)=>decoder.decode(bytes);
}),
"[project]/node_modules/@ipld/dag-ucan/src/did.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BLS12381G1",
    ()=>BLS12381G1,
    "BLS12381G2",
    ()=>BLS12381G2,
    "DID_CORE",
    ()=>DID_CORE,
    "ED25519",
    ()=>ED25519,
    "P256",
    ()=>P256,
    "P384",
    ()=>P384,
    "P521",
    ()=>P521,
    "RSA",
    ()=>RSA,
    "SECP256K1",
    ()=>SECP256K1,
    "decode",
    ()=>decode,
    "encode",
    ()=>encode,
    "format",
    ()=>format,
    "from",
    ()=>from,
    "parse",
    ()=>parse
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$ucan$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/ucan.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base58.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/varint.js [app-ssr] (ecmascript) <export * as varint>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/utf8.js [app-ssr] (ecmascript)");
;
;
;
;
const DID_PREFIX = "did:";
const DID_PREFIX_SIZE = DID_PREFIX.length;
const DID_KEY_PREFIX = `did:key:`;
const DID_KEY_PREFIX_SIZE = DID_KEY_PREFIX.length;
const ED25519 = 0xed;
const RSA = 0x1205;
const P256 = 0x1200;
const P384 = 0x1201;
const P521 = 0x1202;
const SECP256K1 = 0xe7;
const BLS12381G1 = 0xea;
const BLS12381G2 = 0xeb;
const DID_CORE = 0x0d1d;
const METHOD_OFFSET = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(DID_CORE);
const parse = (did)=>{
    if (!did.startsWith(DID_PREFIX)) {
        throw new RangeError(`Invalid DID "${did}", must start with 'did:'`);
    } else if (did.startsWith(DID_KEY_PREFIX)) {
        const key = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["base58btc"].decode(did.slice(DID_KEY_PREFIX_SIZE));
        return decode(key);
    } else {
        const suffix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encode"](did.slice(DID_PREFIX_SIZE));
        const bytes = new Uint8Array(suffix.byteLength + METHOD_OFFSET);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodeTo(DID_CORE, bytes);
        bytes.set(suffix, METHOD_OFFSET);
        return new DID(bytes);
    }
};
const format = (id)=>id.did();
const from = (principal)=>{
    if (principal instanceof DID) {
        return principal;
    } else if (principal instanceof Uint8Array) {
        return decode(principal);
    } else if (typeof principal === "string") {
        return parse(principal);
    } else {
        return parse(principal.did());
    }
};
const decode = (bytes)=>{
    const [code] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].decode(bytes);
    const { buffer, byteOffset, byteLength } = bytes;
    switch(code){
        case P256:
            if (bytes.length > 35) {
                throw new RangeError(`Only p256-pub compressed is supported.`);
            }
        case ED25519:
        case RSA:
        case P384:
        case P521:
        case BLS12381G1:
        case BLS12381G2:
        case SECP256K1:
            return new DIDKey(buffer, byteOffset, byteLength);
        case DID_CORE:
            return new DID(buffer, byteOffset, byteLength);
        default:
            throw new RangeError(`Unsupported DID encoding, unknown multicode 0x${code.toString(16)}.`);
    }
};
const encode = (principal)=>parse(principal.did());
/**
 * @template {UCAN.DID} ID
 * @implements {UCAN.PrincipalView<ID>}
 * @extends {Uint8Array}
 */ class DID extends Uint8Array {
    /**
   * @returns {ID}
   */ did() {
        const bytes = new Uint8Array(this.buffer, this.byteOffset + METHOD_OFFSET);
        return `did:${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decode"](bytes)}`;
    }
    toJSON() {
        return this.did();
    }
}
/**
 * @implements {UCAN.PrincipalView<UCAN.DID<"key">>}
 * @extends {DID<UCAN.DID<"key">>}
 */ class DIDKey extends DID {
    /**
   * @return {`did:key:${string}`}
   */ did() {
        return `did:key:${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["base58btc"].encode(this)}`;
    }
}
}),
"[project]/node_modules/@ipld/dag-ucan/src/signature.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BLS12381G1",
    ()=>BLS12381G1,
    "BLS12381G2",
    ()=>BLS12381G2,
    "EIP191",
    ()=>EIP191,
    "ES256",
    ()=>ES256,
    "ES256K",
    ()=>ES256K,
    "ES384",
    ()=>ES384,
    "ES512",
    ()=>ES512,
    "EdDSA",
    ()=>EdDSA,
    "NON_STANDARD",
    ()=>NON_STANDARD,
    "RS256",
    ()=>RS256,
    "Signature",
    ()=>Signature,
    "create",
    ()=>create,
    "createNamed",
    ()=>createNamed,
    "createNonStandard",
    ()=>createNonStandard,
    "decode",
    ()=>decode,
    "encode",
    ()=>encode,
    "format",
    ()=>format,
    "fromJSON",
    ()=>fromJSON,
    "nameCode",
    ()=>nameCode,
    "parse",
    ()=>parse,
    "toJSON",
    ()=>toJSON,
    "view",
    ()=>view
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$ucan$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/ucan.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/varint.js [app-ssr] (ecmascript) <export * as varint>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base64.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/utf8.js [app-ssr] (ecmascript)");
;
;
;
;
const NON_STANDARD = 0xd000;
const ES256K = 0xd0e7;
const BLS12381G1 = 0xd0ea;
const BLS12381G2 = 0xd0eb;
const EdDSA = 0xd0ed;
const ES256 = 0xd01200;
const ES384 = 0xd01201;
const ES512 = 0xd01202;
const RS256 = 0xd01205;
const EIP191 = 0xd191;
/**
 * @param {number} code
 * @returns {string}
 */ const codeName = (code)=>{
    switch(code){
        case ES256K:
            return "ES256K";
        case BLS12381G1:
            return "BLS12381G1";
        case BLS12381G2:
            return "BLS12381G2";
        case EdDSA:
            return "EdDSA";
        case ES256:
            return "ES256";
        case ES384:
            return "ES384";
        case ES512:
            return "ES512";
        case RS256:
            return "RS256";
        case EIP191:
            return "EIP191";
        default:
            throw new RangeError(`Unknown signature algorithm code 0x${code.toString(16)}`);
    }
};
const nameCode = (name)=>{
    switch(name){
        case "ES256K":
            return ES256K;
        case "BLS12381G1":
            return BLS12381G1;
        case "BLS12381G2":
            return BLS12381G2;
        case "EdDSA":
            return EdDSA;
        case "ES256":
            return ES256;
        case "ES384":
            return ES384;
        case "ES512":
            return ES512;
        case "RS256":
            return RS256;
        case "EIP191":
            return EIP191;
        default:
            return NON_STANDARD;
    }
};
class Signature extends Uint8Array {
    get code() {
        const [code] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].decode(this);
        Object.defineProperties(this, {
            code: {
                value: code
            }
        });
        return code;
    }
    get size() {
        const value = size(this);
        Object.defineProperties(this, {
            size: {
                value
            }
        });
        return value;
    }
    get algorithm() {
        const value = algorithm(this);
        Object.defineProperties(this, {
            algorithm: {
                value
            }
        });
        return value;
    }
    get raw() {
        const { buffer, byteOffset, size, code } = this;
        const codeSize = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(code);
        const rawSize = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(size);
        const value = new Uint8Array(buffer, byteOffset + codeSize + rawSize, size);
        Object.defineProperties(this, {
            raw: {
                value
            }
        });
        return value;
    }
    /**
   * Verify that this signature was created by the given key.
   *
   * @param {UCAN.Crypto.Verifier<A>} signer
   * @param {UCAN.ByteView<T>} payload
   */ async verify(signer, payload) {
        try {
            if (await signer.verify(payload, this) === true) {
                return {
                    ok: {}
                };
            } else {
                throw new Error("Invalid signature");
            }
        } catch (cause) {
            return {
                error: cause
            };
        }
    }
    toJSON() {
        return toJSON(this);
    }
}
/**
 * @param {UCAN.Signature} signature
 */ const algorithm = (signature)=>{
    const { code, raw, buffer, byteOffset } = signature;
    if (code === NON_STANDARD) {
        const offset = raw.byteLength + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(code) + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(raw.byteLength);
        const bytes = new Uint8Array(buffer, byteOffset + offset);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decode"](bytes);
    } else {
        return codeName(code);
    }
};
/**
 * @param {UCAN.Signature} signature
 */ const size = (signature)=>{
    const offset = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(signature.code);
    const [size] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].decode(new Uint8Array(signature.buffer, signature.byteOffset + offset));
    return size;
};
const create = (code, raw)=>{
    const _ = codeName(code);
    const codeSize = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(code);
    const rawSize = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(raw.byteLength);
    /** @type {Signature<T, A>} */ const signature = new Signature(codeSize + rawSize + raw.byteLength);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodeTo(code, signature);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodeTo(raw.byteLength, signature, codeSize);
    signature.set(raw, codeSize + rawSize);
    Object.defineProperties(signature, {
        code: {
            value: code
        },
        size: {
            value: raw.byteLength
        }
    });
    return signature;
};
const createNamed = (name, raw)=>{
    const code = nameCode(name);
    return code === NON_STANDARD ? createNonStandard(name, raw) : create(code, raw);
};
const createNonStandard = (name, raw)=>{
    const code = NON_STANDARD;
    const codeSize = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(code);
    const rawSize = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(raw.byteLength);
    const nameBytes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encode"](name);
    /** @type {Signature<T, typeof NON_STANDARD>} */ const signature = new Signature(codeSize + rawSize + raw.byteLength + nameBytes.byteLength);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodeTo(code, signature);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodeTo(raw.byteLength, signature, codeSize);
    signature.set(raw, codeSize + rawSize);
    signature.set(nameBytes, codeSize + rawSize + raw.byteLength);
    return signature;
};
const view = (bytes)=>new Signature(bytes.buffer, bytes.byteOffset, bytes.byteLength);
const decode = (bytes)=>{
    if (!(bytes instanceof Uint8Array)) {
        throw new TypeError(`Can only decode Uint8Array into a Signature, instead got ${JSON.stringify(bytes)}`);
    }
    /** @type {UCAN.SignatureView<T, A>} */ const signature = view(bytes);
    const { code, algorithm, raw } = signature;
    return signature;
};
const encode = (signature)=>decode(signature);
const format = (signature, base)=>(base || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["base64url"]).encode(signature);
const parse = (signature, base)=>decode((base || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["base64url"]).decode(signature));
const toJSON = (signature)=>({
        "/": {
            bytes: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["base64"].baseEncode(signature)
        }
    });
const fromJSON = (json)=>decode(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["base64"].baseDecode(json["/"].bytes));
}),
"[project]/node_modules/@ipld/dag-ucan/src/schema.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ParseError",
    ()=>ParseError,
    "asCapability",
    ()=>asCapability,
    "fail",
    ()=>fail,
    "readArray",
    ()=>readArray,
    "readBytes",
    ()=>readBytes,
    "readCapabilities",
    ()=>readCapabilities,
    "readCapability",
    ()=>readCapability,
    "readFact",
    ()=>readFact,
    "readInt",
    ()=>readInt,
    "readJWTPayload",
    ()=>readJWTPayload,
    "readLiteral",
    ()=>readLiteral,
    "readNullable",
    ()=>readNullable,
    "readOptional",
    ()=>readOptional,
    "readOptionalArray",
    ()=>readOptionalArray,
    "readPayload",
    ()=>readPayload,
    "readPrincipal",
    ()=>readPrincipal,
    "readProof",
    ()=>readProof,
    "readSignature",
    ()=>readSignature,
    "readString",
    ()=>readString,
    "readStringPrincipal",
    ()=>readStringPrincipal,
    "readStringProof",
    ()=>readStringProof,
    "readStruct",
    ()=>readStruct,
    "readVersion",
    ()=>readVersion,
    "throw",
    ()=>fail
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$ucan$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/ucan.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/utf8.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/link.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$identity$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/hashes/identity.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/did.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$codecs$2f$raw$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/codecs/raw.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$signature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/signature.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
const readPayload = (data)=>readPayloadWith(data, {
        readPrincipal,
        readProof
    });
const readJWTPayload = (data)=>readPayloadWith(data, {
        readPrincipal: readStringPrincipal,
        readProof: readStringProof
    });
/**
 *
 * @template {UCAN.Capabilities} C
 * @param {Record<string, unknown>|UCAN.Payload<C>} data
 * @param {object} readers
 * @param {(source:unknown, context:string) => UCAN.Principal} readers.readPrincipal
 * @param {(source:unknown, context:string) => UCAN.Link} readers.readProof
 * @returns {UCAN.Payload<C>}
 */ const readPayloadWith = (data, { readPrincipal, readProof })=>({
        iss: readPrincipal(data.iss, "iss"),
        aud: readPrincipal(data.aud, "aud"),
        att: readCapabilities(data.att, "att"),
        prf: readOptionalArray(data.prf, readProof, "prf") || [],
        exp: readNullable(data.exp === Infinity ? null : data.exp, readInt, "exp"),
        nbf: readOptional(data.nbf, readInt, "nbf"),
        fct: readOptionalArray(data.fct, readFact, "fct") || [],
        nnc: readOptional(data.nnc, readString, "nnc")
    });
const readSignature = (source)=>{
    if (source instanceof Uint8Array) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$signature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decode"](source);
    } else {
        throw new TypeError(`Can only decode Uint8Array into a Signature, instead got ${JSON.stringify(source)}`);
    }
};
const readInt = (input, name)=>Number.isInteger(input) ? input : ParseError.throw(`Expected ${name} to be integer, instead got ${JSON.stringify(input)}`);
const readCapability = (input, context)=>readStruct(input, asCapability, context);
const readCapabilities = (input, context)=>readArray(input, readCapability, context);
const asCapability = (input)=>/** @type {C} */ ({
        ...input,
        can: readAbility(input.can),
        with: readResource(input.with)
    });
/**
 * @param {unknown} input
 */ const readAbility = (input)=>typeof input !== "string" ? ParseError.throw(`Capability has invalid 'can: ${JSON.stringify(input)}', value must be a string`) : input.slice(1, -1).includes("/") ? input.toLocaleLowerCase() : input === "*" ? input : ParseError.throw(`Capability has invalid 'can: "${input}"', value must have at least one path segment`);
/**
 * @param {unknown} input
 */ const readResource = (input)=>typeof input !== "string" ? ParseError.throw(`Capability has invalid 'with: ${JSON.stringify(input)}', value must be a string`) : parseURL(input) || ParseError.throw(`Capability has invalid 'with: "${input}"', value must be a valid URI string`);
/**
 * @param {string} input
 */ const parseURL = (input)=>{
    try {
        new URL(input);
        return input;
    } catch (_) {
        return null;
    }
};
const readArray = (input, read, context)=>Array.isArray(input) ? input.map((element, n)=>read(element, `${context}[${n}]`)) : ParseError.throw(`${context} must be an array`);
const readOptionalArray = (input, reader, context)=>input === undefined ? input : readArray(input, reader, context);
const readStruct = (input, reader, context)=>input != null && typeof input === "object" ? reader(input) : ParseError.throw(`${context} must be of type object, instead got ${input}`);
const readFact = (input, context)=>readStruct(input, Object, context);
const readProof = (source, context)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isLink"](source) ? source : fail(`Expected ${context} to be IPLD link, instead got ${JSON.stringify(source)}`);
const readStringProof = (source, context)=>parseProof(readString(source, context));
/**
 * @param {string} source
 * @returns {UCAN.Link}
 */ const parseProof = (source)=>{
    // First we attempt to read proof as CID, if we fail fallback to reading it as
    // an inline proof.
    try {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["parse"](source);
    } catch (error) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["create"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$codecs$2f$raw$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["code"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$identity$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["identity"].digest(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encode"](source)));
    }
};
const readPrincipal = (input, context)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decode"](readBytes(input, context));
const readStringPrincipal = (source, context)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"](readString(source, context));
const readOptional = (source, read, context = "Field")=>source !== undefined ? read(source, context) : undefined;
const readNullable = (source, read, context)=>source === null ? null : read(source, context);
const readString = (source, context = "Field")=>typeof source === "string" ? source : fail(`${context} has invalid value ${source}`);
const readBytes = (source, context)=>source instanceof Uint8Array ? source : fail(`Expected ${context} to be Uint8Array, instead got ${JSON.stringify(source)}`);
const readVersion = (input, context)=>/\d+\.\d+\.\d+/.test(input) ? input : ParseError.throw(`Invalid version '${context}: ${JSON.stringify(input)}'`);
const readLiteral = (input, literal, context)=>input === literal ? literal : ParseError.throw(`Expected ${context} to be a ${JSON.stringify(literal)} instead got ${JSON.stringify(input)}`);
class ParseError extends TypeError {
    get name() {
        return "ParseError";
    }
    /**
   * @param {string} message
   * @returns {never}
   */ static throw(message) {
        throw new this(message);
    }
}
const fail = (reason)=>ParseError.throw(reason);
;
}),
"[project]/node_modules/@ipld/dag-ucan/src/formatter.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "format",
    ()=>format,
    "formatHeader",
    ()=>formatHeader,
    "formatPayload",
    ()=>formatPayload,
    "formatSignPayload",
    ()=>formatSignPayload,
    "formatSignature",
    ()=>formatSignature
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$ucan$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/ucan.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/did.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$json$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-json/src/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base64.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$signature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/signature.js [app-ssr] (ecmascript)");
;
;
;
;
;
const format = (model)=>{
    const header = formatHeader(model.v, model.s.algorithm);
    const payload = formatPayload(model);
    const signature = formatSignature(model.s);
    return `${header}.${payload}.${signature}`;
};
const formatSignPayload = (payload, version, alg)=>`${formatHeader(version, alg)}.${formatPayload(payload)}`;
const formatHeader = (version, alg)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["base64url"].baseEncode(encodeHeader(version, alg));
const formatPayload = (data)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["base64url"].baseEncode(encodePayload(data));
const formatSignature = (signature)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["base64url"].baseEncode(signature.raw);
/**
 * @param {UCAN.Version} v
 * @param {string} alg
 * @returns {UCAN.ByteView<UCAN.JWTHeader>}
 */ const encodeHeader = (v, alg)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$json$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encode"]({
        alg,
        ucv: v,
        typ: "JWT"
    });
/**
 * @template {UCAN.Capabilities} C
 * @param {UCAN.Payload<C>} data
 * @returns {UCAN.ByteView<UCAN.JWTPayload<C>>}
 */ const encodePayload = (data)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$json$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encode"]({
        iss: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"](data.iss),
        aud: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"](data.aud),
        att: data.att,
        exp: data.exp,
        prf: data.prf.map(encodeProof),
        // leave out optionals and empty fields
        ...data.fct.length > 0 && {
            fct: data.fct
        },
        ...data.nnc && {
            nnc: data.nnc
        },
        ...data.nbf && {
            nbf: data.nbf
        }
    });
/**
 * @param {UCAN.Link} proof
 * @returns {UCAN.ToString<UCAN.Link>}
 */ const encodeProof = (proof)=>proof.toString();
}),
"[project]/node_modules/@ipld/dag-ucan/src/view.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "View",
    ()=>View
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$ucan$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/ucan.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/did.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$json$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-json/src/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/utf8.js [app-ssr] (ecmascript)");
;
;
;
;
/**
 * @param {unknown} data
 */ const toJSON = (data)=>JSON.parse((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decode"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$json$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encode"])(data)));
class View {
    /**
   * @param {UCAN.UCAN<C>} model
   */ constructor(model){
        /** @readonly */ this.model = model;
    }
    get version() {
        return this.model.v;
    }
    get issuer() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["from"](this.model.iss);
    }
    get audience() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["from"](this.model.aud);
    }
    /**
   * @returns {C}
   */ get capabilities() {
        return this.model.att;
    }
    /**
   * @returns {number}
   */ get expiration() {
        const { exp } = this.model;
        return exp === null ? Infinity : exp;
    }
    /**
   * @returns {undefined|number}
   */ get notBefore() {
        return this.model.nbf;
    }
    /**
   * @returns {undefined|string}
   */ get nonce() {
        return this.model.nnc;
    }
    /**
   * @returns {UCAN.Fact[]}
   */ get facts() {
        return this.model.fct;
    }
    /**
   * @returns {UCAN.Link[]}
   */ get proofs() {
        return this.model.prf;
    }
    get signature() {
        return this.model.s;
    }
    // compatibility with UCAN.UCAN
    get jwt() {
        return this.model.jwt;
    }
    get s() {
        return this.model.s;
    }
    get v() {
        return this.model.v;
    }
    get iss() {
        return this.model.iss;
    }
    get aud() {
        return this.model.aud;
    }
    get att() {
        return this.model.att;
    }
    get exp() {
        return this.model.exp;
    }
    get nbf() {
        return this.model.nbf;
    }
    get nnc() {
        return this.model.nnc;
    }
    get fct() {
        return this.model.fct;
    }
    get prf() {
        return this.model.prf;
    }
    /**
   * @returns {UCAN.ToJSON<UCAN.UCAN<C>, UCAN.UCANJSON<this>>}
   */ toJSON() {
        const { v, iss, aud, s, att, prf, exp, fct, nnc, nbf } = this.model;
        return {
            iss,
            aud,
            v,
            s,
            exp,
            ...toJSON({
                att,
                prf,
                ...fct.length > 0 && {
                    fct
                }
            }),
            ...nnc != null && {
                nnc
            },
            ...nbf && {
                nbf
            }
        };
    }
}
}),
"[project]/node_modules/@ipld/dag-ucan/src/codec/cbor.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "code",
    ()=>code,
    "decode",
    ()=>decode,
    "encode",
    ()=>encode,
    "from",
    ()=>from,
    "name",
    ()=>name
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$ucan$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/ucan.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-cbor/src/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/schema.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$formatter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/formatter.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$signature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/signature.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$view$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/view.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
const name = "dag-ucan";
const code = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["code"];
const from = (model)=>new CBORView(model);
const encode = (model)=>{
    const { fct, nnc, nbf, ...payload } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["readPayload"])(model);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encode"]({
        // leave out optionals unless they are set
        ...fct.length > 0 && {
            fct
        },
        ...nnc != null && {
            nnc
        },
        ...nbf && {
            nbf
        },
        ...payload,
        // add version and signature
        v: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["readVersion"])(model.v, "v"),
        s: encodeSignature(model.s, "s")
    });
};
/**
 * @param {UCAN.Signature} signature
 * @param {string} context
 */ const encodeSignature = (signature, context)=>{
    try {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$signature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encode"](signature);
    } catch (cause) {
        throw new Error(`Expected signature ${context}, instead got ${JSON.stringify(signature)}`, // @ts-expect-error - types don't know about second arg
        {
            cause
        });
    }
};
const decode = (bytes)=>{
    const model = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decode"](bytes);
    return new CBORView({
        ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["readPayload"])(model),
        v: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["readVersion"])(model.v, "v"),
        s: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["readSignature"])(model.s)
    });
};
;
/**
 * @template {UCAN.Capabilities} C
 * @extends {View<C>}
 */ class CBORView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$view$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["View"] {
    /** @type {UCAN.MulticodecCode<typeof code, "CBOR">} */ get code() {
        return code;
    }
    format() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$formatter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"])(this.model);
    }
    encode() {
        return encode(this.model);
    }
}
}),
"[project]/node_modules/@ipld/dag-ucan/src/parser.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "parse",
    ()=>parse,
    "parseHeader",
    ()=>parseHeader,
    "parsePayload",
    ()=>parsePayload
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$ucan$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/ucan.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$json$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-json/src/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/schema.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base64.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$signature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/signature.js [app-ssr] (ecmascript)");
;
;
;
;
;
const parse = (jwt)=>{
    const segments = jwt.split(".");
    const [header, payload, signature] = segments.length === 3 ? segments : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["throw"](`Can't parse UCAN: ${jwt}: Expected JWT format: 3 dot-separated base64url-encoded values.`);
    const { ucv, alg } = parseHeader(header);
    return {
        ...parsePayload(payload),
        v: ucv,
        s: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$signature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createNamed"])(alg, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["base64url"].baseDecode(signature))
    };
};
const parseHeader = (header)=>{
    const { ucv, alg, typ } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$json$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decode"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["base64url"].baseDecode(header));
    return {
        typ: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["readLiteral"](typ, "JWT", "typ"),
        ucv: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["readVersion"](ucv, "ucv"),
        alg: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["readString"](alg, "alg")
    };
};
const parsePayload = (source)=>{
    /** @type {Record<string, unknown>} */ const payload = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$json$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decode"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["base64url"].baseDecode(source));
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["readJWTPayload"](payload);
};
}),
"[project]/node_modules/@ipld/dag-ucan/src/codec/jwt.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "decode",
    ()=>decode,
    "encode",
    ()=>encode,
    "format",
    ()=>format,
    "from",
    ()=>from,
    "name",
    ()=>name
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$ucan$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/ucan.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/utf8.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$parser$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/parser.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$codecs$2f$raw$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/codecs/raw.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$view$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/view.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
const name = "dag-ucan";
const from = (model)=>new JWTView(model);
const decode = (bytes)=>{
    const jwt = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decode"](bytes);
    return new JWTView({
        ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$parser$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"])(jwt),
        jwt
    });
};
const encode = ({ jwt })=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encode"](jwt);
const format = ({ jwt })=>jwt;
/**
 * @template {UCAN.Capabilities} C
 * @extends {View<C>}
 */ class JWTView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$view$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["View"] {
    /**
   * @param {UCAN.FromJWT<C>} model
   */ constructor(model){
        super(model);
        this.model = model;
    }
    /** @type {UCAN.MulticodecCode<typeof code, "Raw">} */ get code() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$codecs$2f$raw$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["code"];
    }
    format() {
        return format(this.model);
    }
    encode() {
        return encode(this.model);
    }
}
}),
"[project]/node_modules/@ipld/dag-ucan/src/lib.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "VERSION",
    ()=>VERSION,
    "code",
    ()=>code,
    "decode",
    ()=>decode,
    "encode",
    ()=>encode,
    "format",
    ()=>format,
    "isExpired",
    ()=>isExpired,
    "isTooEarly",
    ()=>isTooEarly,
    "issue",
    ()=>issue,
    "link",
    ()=>link,
    "name",
    ()=>name,
    "now",
    ()=>now,
    "parse",
    ()=>parse,
    "verifySignature",
    ()=>verifySignature,
    "write",
    ()=>write
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$ucan$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/ucan.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$cbor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/codec/cbor.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$formatter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/formatter.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$jwt$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/codec/jwt.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$codecs$2f$raw$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/codecs/raw.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/utf8.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/schema.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/did.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$parser$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/parser.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$sha2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/hashes/sha2.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/link.js [app-ssr] (ecmascript) <locals>");
;
;
;
;
;
;
;
;
;
;
;
;
const VERSION = "0.9.1";
const name = "dag-ucan";
const code = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$cbor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["code"];
/**
 * We cast sha256 to workaround typescripts limited inference problem when using
 * sha256 as default. If hasher is omitted type `A` should match sha256.code
 * but TS fails to deduce that.
 * @type {UCAN.MultihashHasher<any>}
 */ const defaultHasher = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$sha2$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["sha256"];
const encode = (ucan)=>ucan.jwt ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$jwt$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encode"](ucan) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$cbor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encode"](ucan);
const decode = (bytes)=>{
    try {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$cbor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["decode"](bytes);
    } catch (_) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$jwt$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["decode"](bytes);
    }
};
const link = async (ucan, options)=>{
    const { cid } = await write(ucan, options);
    return cid;
};
const write = async (ucan, { hasher = defaultHasher } = {})=>{
    const [code, bytes] = ucan.jwt ? [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$codecs$2f$raw$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["code"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$jwt$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encode"](ucan)
    ] : [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$cbor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["code"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$cbor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encode"](ucan)
    ];
    const digest = await hasher.digest(bytes);
    return {
        bytes,
        cid: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["create"])(code, digest),
        data: ucan
    };
};
const parse = (jwt)=>{
    const model = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$parser$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"])(jwt);
    // If formatting UCAN produces same jwt string we can use IPLD representation
    // otherwise we need to fallback to raw representation. This decision will
    // affect how we `encode` the UCAN.
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$formatter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"](model) === jwt ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$cbor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["from"](model) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$jwt$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["from"]({
        ...model,
        jwt: jwt
    });
};
const format = (ucan)=>ucan.jwt ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$jwt$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["format"](ucan) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$formatter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"](ucan);
const issue = async ({ issuer, audience, capabilities, lifetimeInSeconds = 30, expiration = now() + lifetimeInSeconds, notBefore, facts = [], proofs = [], nonce })=>{
    const v = VERSION;
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["readPayload"])({
        iss: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"])(issuer.did()),
        aud: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["parse"])(audience.did()),
        att: capabilities,
        fct: facts,
        exp: expiration,
        nbf: notBefore,
        prf: proofs,
        nnc: nonce
    });
    const payload = encodeSignaturePayload(data, v, issuer.signatureAlgorithm);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$cbor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["from"]({
        ...data,
        v,
        s: await issuer.sign(payload)
    });
};
/**
 *
 * @param {UCAN.Payload} payload
 * @param {UCAN.Version} version
 * @param {string} algorithm
 * @returns
 */ const encodeSignaturePayload = (payload, version, algorithm)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encode"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$formatter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["formatSignPayload"])(payload, version, algorithm));
const verifySignature = (ucan, verifier)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["format"])(ucan.issuer) === verifier.did() && verifier.verify(encodeSignaturePayload(ucan.model, ucan.model.v, ucan.signature.algorithm), ucan.signature);
const isExpired = (ucan)=>ucan.expiration <= now();
const isTooEarly = (ucan)=>ucan.notBefore != null && now() <= ucan.notBefore;
const now = ()=>Math.floor(Date.now() / 1000);
}),
"[project]/node_modules/@ipld/dag-ucan/src/signature.js [app-ssr] (ecmascript) <export * as Signature>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Signature",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$signature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$signature$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/signature.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/@ipld/dag-ucan/src/lib.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "VERSION",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["VERSION"],
    "code",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["code"],
    "decode",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["decode"],
    "encode",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encode"],
    "format",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["format"],
    "isExpired",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isExpired"],
    "isTooEarly",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isTooEarly"],
    "issue",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["issue"],
    "link",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["link"],
    "name",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["name"],
    "now",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["now"],
    "parse",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["parse"],
    "verifySignature",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["verifySignature"],
    "write",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["write"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/lib.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$ucan$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/ucan.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/@ipld/dag-ucan/src/lib.js [app-ssr] (ecmascript) <export * as UCAN>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "UCAN",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/lib.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/@ipld/dag-ucan/src/did.js [app-ssr] (ecmascript) <export * as DID>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DID",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/did.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/@ipld/dag-cbor/src/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "code",
    ()=>code,
    "decode",
    ()=>decode,
    "decodeOptions",
    ()=>decodeOptions,
    "encode",
    ()=>encode,
    "encodeOptions",
    ()=>encodeOptions,
    "name",
    ()=>name,
    "toByteView",
    ()=>toByteView
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$cborg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/cborg/cborg.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$encode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cborg/lib/encode.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$decode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cborg/lib/decode.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cborg/lib/token.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/cid.js [app-ssr] (ecmascript) <locals>");
;
;
// https://github.com/ipfs/go-ipfs/issues/3570#issuecomment-273931692
const CID_CBOR_TAG = 42;
function toByteView(buf) {
    if (buf instanceof ArrayBuffer) {
        return new Uint8Array(buf, 0, buf.byteLength);
    }
    return buf;
}
/**
 * cidEncoder will receive all Objects during encode, it needs to filter out
 * anything that's not a CID and return `null` for that so it's encoded as
 * normal.
 *
 * @param {any} obj
 * @returns {cborg.Token[]|null}
 */ function cidEncoder(obj) {
    if (obj.asCID !== obj && obj['/'] !== obj.bytes) {
        return null // any other kind of object
        ;
    }
    const cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].asCID(obj);
    /* c8 ignore next 4 */ // very unlikely case, and it'll probably throw a recursion error in cborg
    if (!cid) {
        return null;
    }
    const bytes = new Uint8Array(cid.bytes.byteLength + 1);
    bytes.set(cid.bytes, 1); // prefix is 0x00, for historical reasons
    return [
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Type"].tag, CID_CBOR_TAG),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Type"].bytes, bytes)
    ];
}
// eslint-disable-next-line jsdoc/require-returns-check
/**
 * Intercept all `undefined` values from an object walk and reject the entire
 * object if we find one.
 *
 * @returns {null}
 */ function undefinedEncoder() {
    throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded');
}
/**
 * Intercept all `number` values from an object walk and reject the entire
 * object if we find something that doesn't fit the IPLD data model (NaN &
 * Infinity).
 *
 * @param {number} num
 * @returns {null}
 */ function numberEncoder(num) {
    if (Number.isNaN(num)) {
        throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded');
    }
    if (num === Infinity || num === -Infinity) {
        throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded');
    }
    return null;
}
/**
 * @param {Map<any, any>} map
 * @returns {null}
 */ function mapEncoder(map) {
    for (const key of map.keys()){
        if (typeof key !== 'string' || key.length === 0) {
            throw new Error('Non-string Map keys are not supported by the IPLD Data Model and cannot be encoded');
        }
    }
    return null;
}
const _encodeOptions = {
    float64: true,
    typeEncoders: {
        Map: mapEncoder,
        Object: cidEncoder,
        undefined: undefinedEncoder,
        number: numberEncoder
    }
};
const encodeOptions = {
    ..._encodeOptions,
    typeEncoders: {
        ..._encodeOptions.typeEncoders
    }
};
/**
 * @param {Uint8Array} bytes
 * @returns {CID}
 */ function cidDecoder(bytes) {
    if (bytes[0] !== 0) {
        throw new Error('Invalid CID for CBOR tag 42; expected leading 0x00');
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].decode(bytes.subarray(1)) // ignore leading 0x00
    ;
}
const _decodeOptions = {
    allowIndefinite: false,
    coerceUndefinedToNull: true,
    allowNaN: false,
    allowInfinity: false,
    allowBigInt: true,
    // safe-integer range, which may surprise users
    strict: true,
    useMaps: false,
    rejectDuplicateMapKeys: true,
    /** @type {import('cborg').TagDecoder[]} */ tags: []
};
_decodeOptions.tags[CID_CBOR_TAG] = cidDecoder;
const decodeOptions = {
    ..._decodeOptions,
    tags: _decodeOptions.tags.slice()
};
const name = 'dag-cbor';
const code = 0x71;
const encode = (node)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$encode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encode"](node, _encodeOptions);
const decode = (data)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$decode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decode"](toByteView(data), _decodeOptions);
}),
"[project]/node_modules/@ipld/dag-json/src/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* eslint max-depth: ["error", 7] */ __turbopack_context__.s([
    "code",
    ()=>code,
    "decode",
    ()=>decode,
    "encode",
    ()=>encode,
    "format",
    ()=>format,
    "name",
    ()=>name,
    "parse",
    ()=>parse,
    "stringify",
    ()=>format
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$cborg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/cborg/cborg.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cborg/lib/token.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$json$2f$json$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/cborg/lib/json/json.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$json$2f$decode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cborg/lib/json/decode.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$json$2f$encode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cborg/lib/json/encode.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/cid.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base64.js [app-ssr] (ecmascript)");
;
;
;
;
/**
 * @template T
 * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView
 */ /**
 * @template T
 * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView
 */ /**
 * @template T
 * @typedef {import('multiformats').ToString<T>} ToString
 */ /**
 * @typedef {import('cborg/interface').DecodeTokenizer} DecodeTokenizer
 */ /**
 * @template T
 * @param {ByteView<T> | ArrayBufferView<T>} buf
 * @returns {ByteView<T>}
 */ function toByteView(buf) {
    if (buf instanceof ArrayBuffer) {
        return new Uint8Array(buf, 0, buf.byteLength);
    }
    return buf;
}
/**
 * cidEncoder will receive all Objects during encode, it needs to filter out
 * anything that's not a CID and return `null` for that so it's encoded as
 * normal. Encoding a CID means replacing it with a `{"/":"<CidString>}`
 * object as per the DAG-JSON spec.
 *
 * @param {any} obj
 * @returns {Token[]|null}
 */ function cidEncoder(obj) {
    if (obj.asCID !== obj && obj['/'] !== obj.bytes) {
        return null // any other kind of object
        ;
    }
    const cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].asCID(obj);
    /* c8 ignore next 4 */ // very unlikely case, and it'll probably throw a recursion error in cborg
    if (!cid) {
        return null;
    }
    const cidString = cid.toString();
    return [
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Type"].map, Infinity, 1),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Type"].string, '/', 1),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Type"].string, cidString, cidString.length),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Type"].break, undefined, 1)
    ];
}
/**
 * bytesEncoder will receive all Uint8Arrays (and friends) during encode, it
 * needs to replace it with a `{"/":{"bytes":"Base64ByteString"}}` object as
 * per the DAG-JSON spec.
 *
 * @param {Uint8Array} bytes
 * @returns {Token[]|null}
 */ function bytesEncoder(bytes) {
    const bytesString = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["base64"].encode(bytes).slice(1) // no mbase prefix
    ;
    return [
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Type"].map, Infinity, 1),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Type"].string, '/', 1),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Type"].map, Infinity, 1),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Type"].string, 'bytes', 5),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Type"].string, bytesString, bytesString.length),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Type"].break, undefined, 1),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Type"].break, undefined, 1)
    ];
}
/**
 * taBytesEncoder wraps bytesEncoder() but for the more exotic typed arrays so
 * that we access the underlying ArrayBuffer data
 *
 * @param {Int8Array|Uint16Array|Int16Array|Uint32Array|Int32Array|Float32Array|Float64Array|Uint8ClampedArray|BigInt64Array|BigUint64Array} obj
 * @returns {Token[]|null}
 */ function taBytesEncoder(obj) {
    return bytesEncoder(new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
}
/**
 * abBytesEncoder wraps bytesEncoder() but for plain ArrayBuffers
 *
 * @param {ArrayBuffer} ab
 * @returns {Token[]|null}
 */ function abBytesEncoder(ab) {
    return bytesEncoder(new Uint8Array(ab));
}
// eslint-disable-next-line jsdoc/require-returns-check
/**
 * Intercept all `undefined` values from an object walk and reject the entire
 * object if we find one.
 *
 * @returns {null}
 */ function undefinedEncoder() {
    throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded');
}
/**
 * Intercept all `number` values from an object walk and reject the entire
 * object if we find something that doesn't fit the IPLD data model (NaN &
 * Infinity).
 *
 * @param {number} num
 * @returns {null}
 */ function numberEncoder(num) {
    if (Number.isNaN(num)) {
        throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded');
    }
    if (num === Infinity || num === -Infinity) {
        throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded');
    }
    return null // process with standard number encoder
    ;
}
const encodeOptions = {
    typeEncoders: {
        Object: cidEncoder,
        Buffer: bytesEncoder,
        Uint8Array: bytesEncoder,
        Int8Array: taBytesEncoder,
        Uint16Array: taBytesEncoder,
        Int16Array: taBytesEncoder,
        Uint32Array: taBytesEncoder,
        Int32Array: taBytesEncoder,
        Float32Array: taBytesEncoder,
        Float64Array: taBytesEncoder,
        Uint8ClampedArray: taBytesEncoder,
        BigInt64Array: taBytesEncoder,
        BigUint64Array: taBytesEncoder,
        DataView: taBytesEncoder,
        ArrayBuffer: abBytesEncoder,
        undefined: undefinedEncoder,
        number: numberEncoder
    }
};
/**
 * @implements {DecodeTokenizer}
 */ class DagJsonTokenizer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$json$2f$decode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tokenizer"] {
    /**
   * @param {Uint8Array} data
   * @param {object} [options]
   */ constructor(data, options){
        super(data, options);
        /** @type {Token[]} */ this.tokenBuffer = [];
    }
    /**
   * @returns {boolean}
   */ done() {
        return this.tokenBuffer.length === 0 && super.done();
    }
    /**
   * @returns {Token}
   */ _next() {
        if (this.tokenBuffer.length > 0) {
            // @ts-ignore https://github.com/Microsoft/TypeScript/issues/30406
            return this.tokenBuffer.pop();
        }
        return super.next();
    }
    /**
   * Implements rules outlined in https://github.com/ipld/specs/pull/356
   *
   * @returns {Token}
   */ next() {
        const token = this._next();
        if (token.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Type"].map) {
            const keyToken = this._next();
            if (keyToken.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Type"].string && keyToken.value === '/') {
                const valueToken = this._next();
                if (valueToken.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Type"].string) {
                    const breakToken = this._next() // swallow the end-of-map token
                    ;
                    if (breakToken.type !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Type"].break) {
                        throw new Error('Invalid encoded CID form');
                    }
                    this.tokenBuffer.push(valueToken); // CID.parse will pick this up after our tag token
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Type"].tag, 42, 0);
                }
                if (valueToken.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Type"].map) {
                    const innerKeyToken = this._next();
                    if (innerKeyToken.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Type"].string && innerKeyToken.value === 'bytes') {
                        const innerValueToken = this._next();
                        if (innerValueToken.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Type"].string) {
                            for(let i = 0; i < 2; i++){
                                const breakToken = this._next() // swallow two end-of-map tokens
                                ;
                                if (breakToken.type !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Type"].break) {
                                    throw new Error('Invalid encoded Bytes form');
                                }
                            }
                            const bytes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["base64"].decode(`m${innerValueToken.value}`);
                            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Type"].bytes, bytes, innerValueToken.value.length);
                        }
                        this.tokenBuffer.push(innerValueToken); // bail
                    }
                    this.tokenBuffer.push(innerKeyToken); // bail
                }
                this.tokenBuffer.push(valueToken); // bail
            }
            this.tokenBuffer.push(keyToken); // bail
        }
        return token;
    }
}
const decodeOptions = {
    allowIndefinite: false,
    allowUndefined: false,
    allowNaN: false,
    allowInfinity: false,
    allowBigInt: true,
    // safe-integer range, which may surprise users
    strict: true,
    useMaps: false,
    rejectDuplicateMapKeys: true,
    /** @type {import('cborg').TagDecoder[]} */ tags: []
};
// we're going to get TAG(42)STRING("bafy...") from the tokenizer so we only need
// to deal with the STRING("bafy...") at this point
decodeOptions.tags[42] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].parse;
const name = 'dag-json';
const code = 0x0129;
const encode = (node)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$json$2f$encode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encode"](node, encodeOptions);
const decode = (data)=>{
    const buf = toByteView(data);
    // the tokenizer is stateful so we need a single instance of it
    const options = Object.assign(decodeOptions, {
        tokenizer: new DagJsonTokenizer(buf, decodeOptions)
    });
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$json$2f$decode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decode"](buf, options);
};
const format = (node)=>utf8Decoder.decode(encode(node));
;
const utf8Decoder = new TextDecoder();
const parse = (data)=>decode(utf8Encoder.encode(data));
const utf8Encoder = new TextEncoder();
}),
"[project]/node_modules/@ipld/car/src/decoder-common.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CIDV0_BYTES",
    ()=>CIDV0_BYTES,
    "V2_HEADER_LENGTH",
    ()=>V2_HEADER_LENGTH,
    "decodeV2Header",
    ()=>decodeV2Header,
    "decodeVarint",
    ()=>decodeVarint,
    "getMultihashLength",
    ()=>getMultihashLength
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/varint/index.js [app-ssr] (ecmascript)");
;
const CIDV0_BYTES = {
    SHA2_256: 0x12,
    LENGTH: 0x20,
    DAG_PB: 0x70
};
const V2_HEADER_LENGTH = /* characteristics */ 16 /* v1 offset */  + 8 /* v1 size */  + 8 /* index offset */  + 8;
function decodeVarint(bytes, seeker) {
    if (!bytes.length) {
        throw new Error('Unexpected end of data');
    }
    const i = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].decode(bytes);
    seeker.seek(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].decode.bytes);
    return i;
}
function decodeV2Header(bytes) {
    const dv = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    let offset = 0;
    const header = {
        version: 2,
        /** @type {[bigint, bigint]} */ characteristics: [
            dv.getBigUint64(offset, true),
            dv.getBigUint64(offset += 8, true)
        ],
        dataOffset: Number(dv.getBigUint64(offset += 8, true)),
        dataSize: Number(dv.getBigUint64(offset += 8, true)),
        indexOffset: Number(dv.getBigUint64(offset += 8, true))
    };
    return header;
}
function getMultihashLength(bytes) {
    // | code | length | .... |
    // where both code and length are varints, so we have to decode
    // them first before we can know total length
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].decode(bytes); // code
    const codeLength = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].decode.bytes;
    const length = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].decode(bytes.subarray(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].decode.bytes));
    const lengthLength = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].decode.bytes;
    const mhLength = codeLength + lengthLength + length;
    return mhLength;
}
}),
"[project]/node_modules/@ipld/car/src/header-validator.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* eslint-disable jsdoc/check-indentation, max-depth */ /**
 * Auto-generated with @ipld/schema@v4.2.0 at Thu Sep 14 2023 from IPLD Schema:
 *
 * # CarV1HeaderOrV2Pragma is a more relaxed form, and can parse {version:x} where
 * # roots are optional. This is typically useful for the {verison:2} CARv2
 * # pragma.
 *
 * type CarV1HeaderOrV2Pragma struct {
 *   roots optional [&Any]
 *   # roots is _not_ optional for CarV1 but we defer that check within code to
 *   # gracefully handle the V2 case where it's just {version:X}
 *   version Int
 * }
 *
 * # CarV1Header is the strict form of the header, and requires roots to be
 * # present. This is compatible with the CARv1 specification.
 *
 * # type CarV1Header struct {
 * #   roots [&Any]
 * #   version Int
 * # }
 *
 */ __turbopack_context__.s([
    "CarV1HeaderOrV2Pragma",
    ()=>CarV1HeaderOrV2Pragma
]);
const Kinds = {
    Null: /**
         * @param obj
         * @returns {undefined|null}
         */ (/** @type {any} */ obj)=>obj === null ? obj : undefined,
    Int: /**
        * @param obj
        * @returns {undefined|number}
        */ (/** @type {any} */ obj)=>Number.isInteger(obj) ? obj : undefined,
    Float: /**
          * @param obj
          * @returns {undefined|number}
          */ (/** @type {any} */ obj)=>typeof obj === 'number' && Number.isFinite(obj) ? obj : undefined,
    String: /**
           * @param obj
           * @returns {undefined|string}
           */ (/** @type {any} */ obj)=>typeof obj === 'string' ? obj : undefined,
    Bool: /**
         * @param obj
         * @returns {undefined|boolean}
         */ (/** @type {any} */ obj)=>typeof obj === 'boolean' ? obj : undefined,
    Bytes: /**
          * @param obj
          * @returns {undefined|Uint8Array}
          */ (/** @type {any} */ obj)=>obj instanceof Uint8Array ? obj : undefined,
    Link: /**
         * @param obj
         * @returns {undefined|object}
         */ (/** @type {any} */ obj)=>obj !== null && typeof obj === 'object' && obj.asCID === obj ? obj : undefined,
    List: /**
         * @param obj
         * @returns {undefined|Array<any>}
         */ (/** @type {any} */ obj)=>Array.isArray(obj) ? obj : undefined,
    Map: /**
        * @param obj
        * @returns {undefined|object}
        */ (/** @type {any} */ obj)=>obj !== null && typeof obj === 'object' && obj.asCID !== obj && !Array.isArray(obj) && !(obj instanceof Uint8Array) ? obj : undefined
};
/** @type {{ [k in string]: (obj:any)=>undefined|any}} */ const Types = {
    'CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)': Kinds.Link,
    'CarV1HeaderOrV2Pragma > roots (anon)': /**
                                           * @param obj
                                           * @returns {undefined|any}
                                           */ (/** @type {any} */ obj)=>{
        if (Kinds.List(obj) === undefined) {
            return undefined;
        }
        for(let i = 0; i < obj.length; i++){
            let v = obj[i];
            v = Types['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v);
            if (v === undefined) {
                return undefined;
            }
            if (v !== obj[i]) {
                const ret = obj.slice(0, i);
                for(let j = i; j < obj.length; j++){
                    let v = obj[j];
                    v = Types['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v);
                    if (v === undefined) {
                        return undefined;
                    }
                    ret.push(v);
                }
                return ret;
            }
        }
        return obj;
    },
    Int: Kinds.Int,
    CarV1HeaderOrV2Pragma: /**
                          * @param obj
                          * @returns {undefined|any}
                          */ (/** @type {any} */ obj)=>{
        if (Kinds.Map(obj) === undefined) {
            return undefined;
        }
        const entries = Object.entries(obj);
        /** @type {{[k in string]: any}} */ let ret = obj;
        let requiredCount = 1;
        for(let i = 0; i < entries.length; i++){
            const [key, value] = entries[i];
            switch(key){
                case 'roots':
                    {
                        const v = Types['CarV1HeaderOrV2Pragma > roots (anon)'](obj[key]);
                        if (v === undefined) {
                            return undefined;
                        }
                        if (v !== value || ret !== obj) {
                            if (ret === obj) {
                                /** @type {{[k in string]: any}} */ ret = {};
                                for(let j = 0; j < i; j++){
                                    ret[entries[j][0]] = entries[j][1];
                                }
                            }
                            ret.roots = v;
                        }
                    }
                    break;
                case 'version':
                    {
                        requiredCount--;
                        const v = Types.Int(obj[key]);
                        if (v === undefined) {
                            return undefined;
                        }
                        if (v !== value || ret !== obj) {
                            if (ret === obj) {
                                /** @type {{[k in string]: any}} */ ret = {};
                                for(let j = 0; j < i; j++){
                                    ret[entries[j][0]] = entries[j][1];
                                }
                            }
                            ret.version = v;
                        }
                    }
                    break;
                default:
                    return undefined;
            }
        }
        if (requiredCount > 0) {
            return undefined;
        }
        return ret;
    }
};
/** @type {{ [k in string]: (obj:any)=>undefined|any}} */ const Reprs = {
    'CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)': Kinds.Link,
    'CarV1HeaderOrV2Pragma > roots (anon)': /**
                                           * @param obj
                                           * @returns {undefined|any}
                                           */ (/** @type {any} */ obj)=>{
        if (Kinds.List(obj) === undefined) {
            return undefined;
        }
        for(let i = 0; i < obj.length; i++){
            let v = obj[i];
            v = Reprs['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v);
            if (v === undefined) {
                return undefined;
            }
            if (v !== obj[i]) {
                const ret = obj.slice(0, i);
                for(let j = i; j < obj.length; j++){
                    let v = obj[j];
                    v = Reprs['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v);
                    if (v === undefined) {
                        return undefined;
                    }
                    ret.push(v);
                }
                return ret;
            }
        }
        return obj;
    },
    Int: Kinds.Int,
    CarV1HeaderOrV2Pragma: /**
                          * @param obj
                          * @returns {undefined|any}
                          */ (/** @type {any} */ obj)=>{
        if (Kinds.Map(obj) === undefined) {
            return undefined;
        }
        const entries = Object.entries(obj);
        /** @type {{[k in string]: any}} */ let ret = obj;
        let requiredCount = 1;
        for(let i = 0; i < entries.length; i++){
            const [key, value] = entries[i];
            switch(key){
                case 'roots':
                    {
                        const v = Reprs['CarV1HeaderOrV2Pragma > roots (anon)'](value);
                        if (v === undefined) {
                            return undefined;
                        }
                        if (v !== value || ret !== obj) {
                            if (ret === obj) {
                                /** @type {{[k in string]: any}} */ ret = {};
                                for(let j = 0; j < i; j++){
                                    ret[entries[j][0]] = entries[j][1];
                                }
                            }
                            ret.roots = v;
                        }
                    }
                    break;
                case 'version':
                    {
                        requiredCount--;
                        const v = Reprs.Int(value);
                        if (v === undefined) {
                            return undefined;
                        }
                        if (v !== value || ret !== obj) {
                            if (ret === obj) {
                                /** @type {{[k in string]: any}} */ ret = {};
                                for(let j = 0; j < i; j++){
                                    ret[entries[j][0]] = entries[j][1];
                                }
                            }
                            ret.version = v;
                        }
                    }
                    break;
                default:
                    return undefined;
            }
        }
        if (requiredCount > 0) {
            return undefined;
        }
        return ret;
    }
};
const CarV1HeaderOrV2Pragma = {
    toTyped: Types.CarV1HeaderOrV2Pragma,
    toRepresentation: Reprs.CarV1HeaderOrV2Pragma
};
}),
"[project]/node_modules/@ipld/car/src/buffer-decoder.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "bytesReader",
    ()=>bytesReader,
    "fromBytes",
    ()=>fromBytes,
    "limitReader",
    ()=>limitReader,
    "readBlockHead",
    ()=>readBlockHead,
    "readHeader",
    ()=>readHeader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-cbor/src/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/cid.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/hashes/digest.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/decoder-common.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$header$2d$validator$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/header-validator.js [app-ssr] (ecmascript)");
;
;
;
;
;
function readHeader(reader, strictVersion) {
    const length = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decodeVarint"])(reader.upTo(8), reader);
    if (length === 0) {
        throw new Error('Invalid CAR header (zero length)');
    }
    const header = reader.exactly(length, true);
    const block = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decode"])(header);
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$header$2d$validator$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CarV1HeaderOrV2Pragma"].toTyped(block) === undefined) {
        throw new Error('Invalid CAR header format');
    }
    if (block.version !== 1 && block.version !== 2 || strictVersion !== undefined && block.version !== strictVersion) {
        throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== undefined ? ` (expected ${strictVersion})` : ''}`);
    }
    if (block.version === 1) {
        // CarV1HeaderOrV2Pragma makes roots optional, let's make it mandatory
        if (!Array.isArray(block.roots)) {
            throw new Error('Invalid CAR header format');
        }
        return block;
    }
    // version 2
    if (block.roots !== undefined) {
        throw new Error('Invalid CAR header format');
    }
    const v2Header = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decodeV2Header"])(reader.exactly(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["V2_HEADER_LENGTH"], true));
    reader.seek(v2Header.dataOffset - reader.pos);
    const v1Header = readHeader(reader, 1);
    return Object.assign(v1Header, v2Header);
}
/**
 * Reads CID sync
 *
 * @param {BytesBufferReader} reader
 * @returns {CID}
 */ function readCid(reader) {
    const first = reader.exactly(2, false);
    if (first[0] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CIDV0_BYTES"].SHA2_256 && first[1] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CIDV0_BYTES"].LENGTH) {
        // cidv0 32-byte sha2-256
        const bytes = reader.exactly(34, true);
        const multihash = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decode"](bytes);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].create(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CIDV0_BYTES"].DAG_PB, multihash);
    }
    const version = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decodeVarint"])(reader.upTo(8), reader);
    if (version !== 1) {
        throw new Error(`Unexpected CID version (${version})`);
    }
    const codec = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decodeVarint"])(reader.upTo(8), reader);
    const bytes = reader.exactly((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getMultihashLength"])(reader.upTo(8)), true);
    const multihash = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decode"](bytes);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].create(version, codec, multihash);
}
function readBlockHead(reader) {
    // length includes a CID + Binary, where CID has a variable length
    // we have to deal with
    const start = reader.pos;
    let length = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decodeVarint"])(reader.upTo(8), reader);
    if (length === 0) {
        throw new Error('Invalid CAR section (zero length)');
    }
    length += reader.pos - start;
    const cid = readCid(reader);
    const blockLength = length - Number(reader.pos - start) // subtract CID length
    ;
    return {
        cid,
        length,
        blockLength
    };
}
function fromBytes(bytes) {
    let reader = bytesReader(bytes);
    const header = readHeader(reader);
    if (header.version === 2) {
        const v1length = reader.pos - header.dataOffset;
        reader = limitReader(reader, header.dataSize - v1length);
    }
    const blocks = [];
    while(reader.upTo(8).length > 0){
        const { cid, blockLength } = readBlockHead(reader);
        blocks.push({
            cid,
            bytes: reader.exactly(blockLength, true)
        });
    }
    return {
        header,
        blocks
    };
}
function bytesReader(bytes) {
    let pos = 0;
    /** @type {BytesBufferReader} */ return {
        upTo (length) {
            return bytes.subarray(pos, pos + Math.min(length, bytes.length - pos));
        },
        exactly (length, seek = false) {
            if (length > bytes.length - pos) {
                throw new Error('Unexpected end of data');
            }
            const out = bytes.subarray(pos, pos + length);
            if (seek) {
                pos += length;
            }
            return out;
        },
        seek (length) {
            pos += length;
        },
        get pos () {
            return pos;
        }
    };
}
function limitReader(reader, byteLimit) {
    let bytesRead = 0;
    /** @type {BytesBufferReader} */ return {
        upTo (length) {
            let bytes = reader.upTo(length);
            if (bytes.length + bytesRead > byteLimit) {
                bytes = bytes.subarray(0, byteLimit - bytesRead);
            }
            return bytes;
        },
        exactly (length, seek = false) {
            const bytes = reader.exactly(length, seek);
            if (bytes.length + bytesRead > byteLimit) {
                throw new Error('Unexpected end of data');
            }
            if (seek) {
                bytesRead += length;
            }
            return bytes;
        },
        seek (length) {
            bytesRead += length;
            reader.seek(length);
        },
        get pos () {
            return reader.pos;
        }
    };
}
}),
"[project]/node_modules/@ipld/car/src/buffer-reader-browser.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CarBufferReader",
    ()=>CarBufferReader,
    "__browser",
    ()=>__browser
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$buffer$2d$decoder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/buffer-decoder.js [app-ssr] (ecmascript)");
;
class CarBufferReader {
    /**
   * @constructs CarBufferReader
   * @param {CarHeader|CarV2Header} header
   * @param {Block[]} blocks
   */ constructor(header, blocks){
        this._header = header;
        this._blocks = blocks;
        this._cids = undefined;
    }
    /**
   * @property {number} version of the CAR
   * @memberof CarBufferReader
   * @instance
   */ get version() {
        return this._header.version;
    }
    /**
   * Get the list of roots defined by the CAR referenced by this reader. May be
   * zero or more `CID`s.
   *
   * @function
   * @memberof CarBufferReader
   * @instance
   * @returns {CID[]}
   */ getRoots() {
        return this._header.roots;
    }
    /**
   * Check whether a given `CID` exists within the CAR referenced by this
   * reader.
   *
   * @function
   * @memberof CarBufferReader
   * @instance
   * @param {CID} key
   * @returns {boolean}
   */ has(key) {
        return this._blocks.some((b)=>b.cid.equals(key));
    }
    /**
   * Fetch a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) from the CAR
   * referenced by this reader matching the provided `CID`. In the case where
   * the provided `CID` doesn't exist within the CAR, `undefined` will be
   * returned.
   *
   * @function
   * @memberof CarBufferReader
   * @instance
   * @param {CID} key
   * @returns {Block | undefined}
   */ get(key) {
        return this._blocks.find((b)=>b.cid.equals(key));
    }
    /**
   * Returns a `Block[]` of the `Block`s (`{ cid:CID, bytes:Uint8Array }` pairs) contained within
   * the CAR referenced by this reader.
   *
   * @function
   * @memberof CarBufferReader
   * @instance
   * @returns {Block[]}
   */ blocks() {
        return this._blocks;
    }
    /**
   * Returns a `CID[]` of the `CID`s contained within the CAR referenced by this reader.
   *
   * @function
   * @memberof CarBufferReader
   * @instance
   * @returns {CID[]}
   */ cids() {
        if (!this._cids) {
            this._cids = this._blocks.map((b)=>b.cid);
        }
        return this._cids;
    }
    /**
   * Instantiate a {@link CarBufferReader} from a `Uint8Array` blob. This performs a
   * decode fully in memory and maintains the decoded state in memory for full
   * access to the data via the `CarReader` API.
   *
   * @static
   * @memberof CarBufferReader
   * @param {Uint8Array} bytes
   * @returns {CarBufferReader}
   */ static fromBytes(bytes) {
        if (!(bytes instanceof Uint8Array)) {
            throw new TypeError('fromBytes() requires a Uint8Array');
        }
        const { header, blocks } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$buffer$2d$decoder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fromBytes"](bytes);
        return new CarBufferReader(header, blocks);
    }
}
const __browser = true;
}),
"[project]/node_modules/@ipld/car/src/buffer-reader.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CarBufferReader",
    ()=>CarBufferReader,
    "__browser",
    ()=>__browser
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs [external] (fs, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$buffer$2d$reader$2d$browser$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/buffer-reader-browser.js [app-ssr] (ecmascript)");
;
;
/**
 * @typedef {import('./api.js').Block} Block
 * @typedef {import('./api.js').BlockIndex} BlockIndex
 * @typedef {import('./api.js').CarBufferReader} ICarBufferReader
 */ const fsread = __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].readSync;
class CarBufferReader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$buffer$2d$reader$2d$browser$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CarBufferReader"] {
    /**
   * Reads a block directly from a file descriptor for an open CAR file. This
   * function is **only available in Node.js** and not a browser environment.
   *
   * This function can be used in connection with {@link CarIndexer} which emits
   * the `BlockIndex` objects that are required by this function.
   *
   * The user is responsible for opening and closing the file used in this call.
   *
   * @static
   * @memberof CarBufferReader
   * @param {number} fd - A file descriptor from the
   * Node.js `fs` module. An integer, from `fs.open()`.
   * @param {BlockIndex} blockIndex - An index pointing to the location of the
   * Block required. This `BlockIndex` should take the form:
   * `{cid:CID, blockLength:number, blockOffset:number}`.
   * @returns {Block} A `{ cid:CID, bytes:Uint8Array }` pair.
   */ static readRaw(fd, blockIndex) {
        const { cid, blockLength, blockOffset } = blockIndex;
        const bytes = new Uint8Array(blockLength);
        let read;
        if (typeof fd === 'number') {
            read = fsread(fd, bytes, 0, blockLength, blockOffset);
        } else {
            throw new TypeError('Bad fd');
        }
        if (read !== blockLength) {
            throw new Error(`Failed to read entire block (${read} instead of ${blockLength})`);
        }
        return {
            cid,
            bytes
        };
    }
}
const __browser = false;
}),
"[project]/node_modules/@ipld/car/src/buffer-writer.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "addBlock",
    ()=>addBlock,
    "addRoot",
    ()=>addRoot,
    "blockLength",
    ()=>blockLength,
    "calculateHeaderLength",
    ()=>calculateHeaderLength,
    "close",
    ()=>close,
    "createWriter",
    ()=>createWriter,
    "estimateHeaderLength",
    ()=>estimateHeaderLength,
    "headerLength",
    ()=>headerLength,
    "resizeHeader",
    ()=>resizeHeader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-cbor/src/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$cborg$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/cborg/cborg.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cborg/lib/token.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$length$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cborg/lib/length.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/varint/index.js [app-ssr] (ecmascript)");
;
;
;
;
/**
 * @typedef {import('./api.js').CID} CID
 * @typedef {import('./api.js').Block} Block
 * @typedef {import('./api.js').CarBufferWriter} Writer
 * @typedef {import('./api.js').CarBufferWriterOptions} Options
 * @typedef {import('./coding.js').CarEncoder} CarEncoder
 */ /**
 * A simple CAR writer that writes to a pre-allocated buffer.
 *
 * @class
 * @name CarBufferWriter
 * @implements {Writer}
 */ class CarBufferWriter {
    /**
   * @param {Uint8Array} bytes
   * @param {number} headerSize
   */ constructor(bytes, headerSize){
        /** @readonly */ this.bytes = bytes;
        this.byteOffset = headerSize;
        /**
     * @readonly
     * @type {CID[]}
     */ this.roots = [];
        this.headerSize = headerSize;
    }
    /**
   * Add a root to this writer, to be used to create a header when the CAR is
   * finalized with {@link CarBufferWriter.close `close()`}
   *
   * @param {CID} root
   * @param {{resize?:boolean}} [options]
   * @returns {CarBufferWriter}
   */ addRoot(root, options) {
        addRoot(this, root, options);
        return this;
    }
    /**
   * Write a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) to the archive.
   * Throws if there is not enough capacity.
   *
   * @param {Block} block - A `{ cid:CID, bytes:Uint8Array }` pair.
   * @returns {CarBufferWriter}
   */ write(block) {
        addBlock(this, block);
        return this;
    }
    /**
   * Finalize the CAR and return it as a `Uint8Array`.
   *
   * @param {object} [options]
   * @param {boolean} [options.resize]
   * @returns {Uint8Array}
   */ close(options) {
        return close(this, options);
    }
}
const addRoot = (writer, root, options = {})=>{
    const { resize = false } = options;
    const { bytes, headerSize, byteOffset, roots } = writer;
    writer.roots.push(root);
    const size = headerLength(writer);
    // If there is not enough space for the new root
    if (size > headerSize) {
        // Check if we root would fit if we were to resize the head.
        if (size - headerSize + byteOffset < bytes.byteLength) {
            // If resize is enabled resize head
            if (resize) {
                resizeHeader(writer, size);
            // otherwise remove head and throw an error suggesting to resize
            } else {
                roots.pop();
                throw new RangeError(`Header of size ${headerSize} has no capacity for new root ${root}.
  However there is a space in the buffer and you could call addRoot(root, { resize: root }) to resize header to make a space for this root.`);
            }
        // If head would not fit even with resize pop new root and throw error
        } else {
            roots.pop();
            throw new RangeError(`Buffer has no capacity for a new root ${root}`);
        }
    }
};
const blockLength = ({ cid, bytes })=>{
    const size = cid.bytes.byteLength + bytes.byteLength;
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].encodingLength(size) + size;
};
const addBlock = (writer, { cid, bytes })=>{
    const byteLength = cid.bytes.byteLength + bytes.byteLength;
    const size = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].encode(byteLength);
    if (writer.byteOffset + size.length + byteLength > writer.bytes.byteLength) {
        throw new RangeError('Buffer has no capacity for this block');
    } else {
        writeBytes(writer, size);
        writeBytes(writer, cid.bytes);
        writeBytes(writer, bytes);
    }
};
const close = (writer, options = {})=>{
    const { resize = false } = options;
    const { roots, bytes, byteOffset, headerSize } = writer;
    const headerBytes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encode"]({
        version: 1,
        roots
    });
    const varintBytes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].encode(headerBytes.length);
    const size = varintBytes.length + headerBytes.byteLength;
    const offset = headerSize - size;
    // If header size estimate was accurate we just write header and return
    // view into buffer.
    if (offset === 0) {
        writeHeader(writer, varintBytes, headerBytes);
        return bytes.subarray(0, byteOffset);
    // If header was overestimated and `{resize: true}` is passed resize header
    } else if (resize) {
        resizeHeader(writer, size);
        writeHeader(writer, varintBytes, headerBytes);
        return bytes.subarray(0, writer.byteOffset);
    } else {
        throw new RangeError(`Header size was overestimated.
You can use close({ resize: true }) to resize header`);
    }
};
const resizeHeader = (writer, byteLength)=>{
    const { bytes, headerSize } = writer;
    // Move data section to a new offset
    bytes.set(bytes.subarray(headerSize, writer.byteOffset), byteLength);
    // Update header size & byteOffset
    writer.byteOffset += byteLength - headerSize;
    writer.headerSize = byteLength;
};
/**
 * @param {CarBufferWriter} writer
 * @param {number[]|Uint8Array} bytes
 */ const writeBytes = (writer, bytes)=>{
    writer.bytes.set(bytes, writer.byteOffset);
    writer.byteOffset += bytes.length;
};
/**
 * @param {{bytes:Uint8Array}} writer
 * @param {number[]} varint
 * @param {Uint8Array} header
 */ const writeHeader = ({ bytes }, varint, header)=>{
    bytes.set(varint);
    bytes.set(header, varint.length);
};
const headerPreludeTokens = [
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Type"].map, 2),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Type"].string, 'version'),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Type"].uint, 1),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Type"].string, 'roots')
];
const CID_TAG = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Type"].tag, 42);
const calculateHeaderLength = (rootLengths)=>{
    const tokens = [
        ...headerPreludeTokens
    ];
    tokens.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Type"].array, rootLengths.length));
    for (const rootLength of rootLengths){
        tokens.push(CID_TAG);
        tokens.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Type"].bytes, {
            length: rootLength + 1
        }));
    }
    const length = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$length$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["tokensToLength"])(tokens) // no options needed here because we have simple tokens
    ;
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].encodingLength(length) + length;
};
const headerLength = ({ roots })=>calculateHeaderLength(roots.map((cid)=>cid.bytes.byteLength));
const estimateHeaderLength = (rootCount, rootByteLength = 36)=>calculateHeaderLength(new Array(rootCount).fill(rootByteLength));
const createWriter = (buffer, options = {})=>{
    const { roots = [], byteOffset = 0, byteLength = buffer.byteLength, headerSize = headerLength({
        roots
    }) } = options;
    const bytes = new Uint8Array(buffer, byteOffset, byteLength);
    const writer = new CarBufferWriter(bytes, headerSize);
    for (const root of roots){
        writer.addRoot(root);
    }
    return writer;
};
}),
"[project]/node_modules/@ipld/car/src/decoder.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "asyncIterableReader",
    ()=>asyncIterableReader,
    "bytesReader",
    ()=>bytesReader,
    "chunkReader",
    ()=>chunkReader,
    "createDecoder",
    ()=>createDecoder,
    "limitReader",
    ()=>limitReader,
    "readBlockHead",
    ()=>readBlockHead,
    "readHeader",
    ()=>readHeader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-cbor/src/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/cid.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/hashes/digest.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/decoder-common.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$header$2d$validator$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/header-validator.js [app-ssr] (ecmascript)");
;
;
;
;
;
async function readHeader(reader, strictVersion) {
    const length = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decodeVarint"])(await reader.upTo(8), reader);
    if (length === 0) {
        throw new Error('Invalid CAR header (zero length)');
    }
    const header = await reader.exactly(length, true);
    const block = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decode"])(header);
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$header$2d$validator$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CarV1HeaderOrV2Pragma"].toTyped(block) === undefined) {
        throw new Error('Invalid CAR header format');
    }
    if (block.version !== 1 && block.version !== 2 || strictVersion !== undefined && block.version !== strictVersion) {
        throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== undefined ? ` (expected ${strictVersion})` : ''}`);
    }
    if (block.version === 1) {
        // CarV1HeaderOrV2Pragma makes roots optional, let's make it mandatory
        if (!Array.isArray(block.roots)) {
            throw new Error('Invalid CAR header format');
        }
        return block;
    }
    // version 2
    if (block.roots !== undefined) {
        throw new Error('Invalid CAR header format');
    }
    const v2Header = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decodeV2Header"])(await reader.exactly(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["V2_HEADER_LENGTH"], true));
    reader.seek(v2Header.dataOffset - reader.pos);
    const v1Header = await readHeader(reader, 1);
    return Object.assign(v1Header, v2Header);
}
/**
 * @param {BytesReader} reader
 * @returns {Promise<CID>}
 */ async function readCid(reader) {
    const first = await reader.exactly(2, false);
    if (first[0] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CIDV0_BYTES"].SHA2_256 && first[1] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CIDV0_BYTES"].LENGTH) {
        // cidv0 32-byte sha2-256
        const bytes = await reader.exactly(34, true);
        const multihash = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decode"](bytes);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].create(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CIDV0_BYTES"].DAG_PB, multihash);
    }
    const version = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decodeVarint"])(await reader.upTo(8), reader);
    if (version !== 1) {
        throw new Error(`Unexpected CID version (${version})`);
    }
    const codec = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decodeVarint"])(await reader.upTo(8), reader);
    const bytes = await reader.exactly((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getMultihashLength"])(await reader.upTo(8)), true);
    const multihash = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decode"](bytes);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].create(version, codec, multihash);
}
async function readBlockHead(reader) {
    // length includes a CID + Binary, where CID has a variable length
    // we have to deal with
    const start = reader.pos;
    let length = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decodeVarint"])(await reader.upTo(8), reader);
    if (length === 0) {
        throw new Error('Invalid CAR section (zero length)');
    }
    length += reader.pos - start;
    const cid = await readCid(reader);
    const blockLength = length - Number(reader.pos - start) // subtract CID length
    ;
    return {
        cid,
        length,
        blockLength
    };
}
/**
 * @param {BytesReader} reader
 * @returns {Promise<Block>}
 */ async function readBlock(reader) {
    const { cid, blockLength } = await readBlockHead(reader);
    const bytes = await reader.exactly(blockLength, true);
    return {
        bytes,
        cid
    };
}
/**
 * @param {BytesReader} reader
 * @returns {Promise<BlockIndex>}
 */ async function readBlockIndex(reader) {
    const offset = reader.pos;
    const { cid, length, blockLength } = await readBlockHead(reader);
    const index = {
        cid,
        length,
        blockLength,
        offset,
        blockOffset: reader.pos
    };
    reader.seek(index.blockLength);
    return index;
}
function createDecoder(reader) {
    const headerPromise = (async ()=>{
        const header = await readHeader(reader);
        if (header.version === 2) {
            const v1length = reader.pos - header.dataOffset;
            reader = limitReader(reader, header.dataSize - v1length);
        }
        return header;
    })();
    return {
        header: ()=>headerPromise,
        async *blocks () {
            await headerPromise;
            while((await reader.upTo(8)).length > 0){
                yield await readBlock(reader);
            }
        },
        async *blocksIndex () {
            await headerPromise;
            while((await reader.upTo(8)).length > 0){
                yield await readBlockIndex(reader);
            }
        }
    };
}
function bytesReader(bytes) {
    let pos = 0;
    /** @type {BytesReader} */ return {
        async upTo (length) {
            const out = bytes.subarray(pos, pos + Math.min(length, bytes.length - pos));
            return out;
        },
        async exactly (length, seek = false) {
            if (length > bytes.length - pos) {
                throw new Error('Unexpected end of data');
            }
            const out = bytes.subarray(pos, pos + length);
            if (seek) {
                pos += length;
            }
            return out;
        },
        seek (length) {
            pos += length;
        },
        get pos () {
            return pos;
        }
    };
}
function chunkReader(readChunk /*, closer */ ) {
    let pos = 0;
    let have = 0;
    let offset = 0;
    let currentChunk = new Uint8Array(0);
    const read = async (/** @type {number} */ length)=>{
        have = currentChunk.length - offset;
        const bufa = [
            currentChunk.subarray(offset)
        ];
        while(have < length){
            const chunk = await readChunk();
            if (chunk == null) {
                break;
            }
            /* c8 ignore next 8 */ // undo this ignore ^ when we have a fd implementation that can seek()
            if (have < 0) {
                /* c8 ignore next 4 */ // toohard to test the else
                if (chunk.length > have) {
                    bufa.push(chunk.subarray(-have));
                } // else discard
            } else {
                bufa.push(chunk);
            }
            have += chunk.length;
        }
        currentChunk = new Uint8Array(bufa.reduce((p, c)=>p + c.length, 0));
        let off = 0;
        for (const b of bufa){
            currentChunk.set(b, off);
            off += b.length;
        }
        offset = 0;
    };
    /** @type {BytesReader} */ return {
        async upTo (length) {
            if (currentChunk.length - offset < length) {
                await read(length);
            }
            return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length));
        },
        async exactly (length, seek = false) {
            if (currentChunk.length - offset < length) {
                await read(length);
            }
            if (currentChunk.length - offset < length) {
                throw new Error('Unexpected end of data');
            }
            const out = currentChunk.subarray(offset, offset + length);
            if (seek) {
                pos += length;
                offset += length;
            }
            return out;
        },
        seek (length) {
            pos += length;
            offset += length;
        },
        get pos () {
            return pos;
        }
    };
}
function asyncIterableReader(asyncIterable) {
    const iterator = asyncIterable[Symbol.asyncIterator]();
    async function readChunk() {
        const next = await iterator.next();
        if (next.done) {
            return null;
        }
        return next.value;
    }
    return chunkReader(readChunk);
}
function limitReader(reader, byteLimit) {
    let bytesRead = 0;
    /** @type {BytesReader} */ return {
        async upTo (length) {
            let bytes = await reader.upTo(length);
            if (bytes.length + bytesRead > byteLimit) {
                bytes = bytes.subarray(0, byteLimit - bytesRead);
            }
            return bytes;
        },
        async exactly (length, seek = false) {
            const bytes = await reader.exactly(length, seek);
            if (bytes.length + bytesRead > byteLimit) {
                throw new Error('Unexpected end of data');
            }
            if (seek) {
                bytesRead += length;
            }
            return bytes;
        },
        seek (length) {
            bytesRead += length;
            reader.seek(length);
        },
        get pos () {
            return reader.pos;
        }
    };
}
}),
"[project]/node_modules/@ipld/car/src/indexer.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CarIndexer",
    ()=>CarIndexer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/decoder.js [app-ssr] (ecmascript)");
;
class CarIndexer {
    /**
   * @param {number} version
   * @param {CID[]} roots
   * @param {AsyncGenerator<BlockIndex>} iterator
   */ constructor(version, roots, iterator){
        this._version = version;
        this._roots = roots;
        this._iterator = iterator;
    }
    get version() {
        return this._version;
    }
    /**
   * Get the list of roots defined by the CAR referenced by this indexer. May be
   * zero or more `CID`s.
   *
   * @function
   * @memberof CarIndexer
   * @instance
   * @async
   * @returns {Promise<CID[]>}
   */ async getRoots() {
        return this._roots;
    }
    /**
   * @returns {AsyncIterator<BlockIndex>}
   */ [Symbol.asyncIterator]() {
        return this._iterator;
    }
    /**
   * Instantiate a {@link CarIndexer} from a `Uint8Array` blob. Only the header
   * is decoded initially, the remainder is processed and emitted via the
   * iterator as it is consumed.
   *
   * @async
   * @static
   * @memberof CarIndexer
   * @param {Uint8Array} bytes
   * @returns {Promise<CarIndexer>}
   */ static async fromBytes(bytes) {
        if (!(bytes instanceof Uint8Array)) {
            throw new TypeError('fromBytes() requires a Uint8Array');
        }
        return decodeIndexerComplete((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesReader"])(bytes));
    }
    /**
   * Instantiate a {@link CarIndexer} from a `AsyncIterable<Uint8Array>`,
   * such as a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).
   * is decoded initially, the remainder is processed and emitted via the
   * iterator as it is consumed.
   *
   * @async
   * @static
   * @memberof CarIndexer
   * @param {AsyncIterable<Uint8Array>} asyncIterable
   * @returns {Promise<CarIndexer>}
   */ static async fromIterable(asyncIterable) {
        if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === 'function')) {
            throw new TypeError('fromIterable() requires an async iterable');
        }
        return decodeIndexerComplete((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["asyncIterableReader"])(asyncIterable));
    }
}
/**
 * @private
 * @param {BytesReader} reader
 * @returns {Promise<CarIndexer>}
 */ async function decodeIndexerComplete(reader) {
    const decoder = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createDecoder"])(reader);
    const { version, roots } = await decoder.header();
    return new CarIndexer(version, roots, decoder.blocksIndex());
}
}),
"[project]/node_modules/@ipld/car/src/promise-fs-opts.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "fsread",
    ()=>fsread,
    "fswrite",
    ()=>fswrite,
    "hasFS",
    ()=>hasFS
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs [external] (fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$util__$5b$external$5d$__$28$util$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/util [external] (util, cjs)");
;
;
const hasFS = Boolean(__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"]);
;
/**
 * @type {any}
 */ let _fsReadFn;
function fsread(fd, buffer, offset, length, position) {
    if (!_fsReadFn) {
        _fsReadFn = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$util__$5b$external$5d$__$28$util$2c$__cjs$29$__["promisify"])(__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].read);
    }
    return _fsReadFn(fd, buffer, offset, length, position);
}
/**
 * @type {any}
 */ let _fsWriteFn;
function fswrite(fd, buffer, offset, length, position) {
    if (!_fsWriteFn) {
        _fsWriteFn = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$util__$5b$external$5d$__$28$util$2c$__cjs$29$__["promisify"])(__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].write);
    }
    return _fsWriteFn(fd, buffer, offset, length, position);
}
}),
"[project]/node_modules/@ipld/car/src/reader-browser.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CarReader",
    ()=>CarReader,
    "__browser",
    ()=>__browser,
    "decodeReaderComplete",
    ()=>decodeReaderComplete
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/decoder.js [app-ssr] (ecmascript)");
;
class CarReader {
    /**
   * @constructs CarReader
   * @param {CarHeader|CarV2Header} header
   * @param {Block[]} blocks
   */ constructor(header, blocks){
        this._header = header;
        this._blocks = blocks;
        this._keys = blocks.map((b)=>b.cid.toString());
    }
    /**
   * @property
   * @memberof CarReader
   * @instance
   */ get version() {
        return this._header.version;
    }
    /**
   * Get the list of roots defined by the CAR referenced by this reader. May be
   * zero or more `CID`s.
   *
   * @function
   * @memberof CarReader
   * @instance
   * @async
   * @returns {Promise<CID[]>}
   */ async getRoots() {
        return this._header.roots;
    }
    /**
   * Check whether a given `CID` exists within the CAR referenced by this
   * reader.
   *
   * @function
   * @memberof CarReader
   * @instance
   * @async
   * @param {CID} key
   * @returns {Promise<boolean>}
   */ async has(key) {
        return this._keys.indexOf(key.toString()) > -1;
    }
    /**
   * Fetch a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) from the CAR
   * referenced by this reader matching the provided `CID`. In the case where
   * the provided `CID` doesn't exist within the CAR, `undefined` will be
   * returned.
   *
   * @function
   * @memberof CarReader
   * @instance
   * @async
   * @param {CID} key
   * @returns {Promise<Block | undefined>}
   */ async get(key) {
        const index = this._keys.indexOf(key.toString());
        return index > -1 ? this._blocks[index] : undefined;
    }
    /**
   * Returns a `BlockIterator` (`AsyncIterable<Block>`) that iterates over all
   * of the `Block`s (`{ cid:CID, bytes:Uint8Array }` pairs) contained within
   * the CAR referenced by this reader.
   *
   * @function
   * @memberof CarReader
   * @instance
   * @async
   * @generator
   * @returns {AsyncGenerator<Block>}
   */ async *blocks() {
        for (const block of this._blocks){
            yield block;
        }
    }
    /**
   * Returns a `CIDIterator` (`AsyncIterable<CID>`) that iterates over all of
   * the `CID`s contained within the CAR referenced by this reader.
   *
   * @function
   * @memberof CarReader
   * @instance
   * @async
   * @generator
   * @returns {AsyncGenerator<CID>}
   */ async *cids() {
        for (const block of this._blocks){
            yield block.cid;
        }
    }
    /**
   * Instantiate a {@link CarReader} from a `Uint8Array` blob. This performs a
   * decode fully in memory and maintains the decoded state in memory for full
   * access to the data via the `CarReader` API.
   *
   * @async
   * @static
   * @memberof CarReader
   * @param {Uint8Array} bytes
   * @returns {Promise<CarReader>}
   */ static async fromBytes(bytes) {
        if (!(bytes instanceof Uint8Array)) {
            throw new TypeError('fromBytes() requires a Uint8Array');
        }
        return decodeReaderComplete((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesReader"])(bytes));
    }
    /**
   * Instantiate a {@link CarReader} from a `AsyncIterable<Uint8Array>`, such as
   * a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).
   * This performs a decode fully in memory and maintains the decoded state in
   * memory for full access to the data via the `CarReader` API.
   *
   * Care should be taken for large archives; this API may not be appropriate
   * where memory is a concern or the archive is potentially larger than the
   * amount of memory that the runtime can handle.
   *
   * @async
   * @static
   * @memberof CarReader
   * @param {AsyncIterable<Uint8Array>} asyncIterable
   * @returns {Promise<CarReader>}
   */ static async fromIterable(asyncIterable) {
        if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === 'function')) {
            throw new TypeError('fromIterable() requires an async iterable');
        }
        return decodeReaderComplete((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["asyncIterableReader"])(asyncIterable));
    }
}
async function decodeReaderComplete(reader) {
    const decoder = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createDecoder"])(reader);
    const header = await decoder.header();
    const blocks = [];
    for await (const block of decoder.blocks()){
        blocks.push(block);
    }
    return new CarReader(header, blocks);
}
const __browser = true;
}),
"[project]/node_modules/@ipld/car/src/reader.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CarReader",
    ()=>CarReader,
    "__browser",
    ()=>__browser
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$promise$2d$fs$2d$opts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/promise-fs-opts.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$reader$2d$browser$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/reader-browser.js [app-ssr] (ecmascript)");
;
;
class CarReader extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$reader$2d$browser$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CarReader"] {
    /**
   * Reads a block directly from a file descriptor for an open CAR file. This
   * function is **only available in Node.js** and not a browser environment.
   *
   * This function can be used in connection with {@link CarIndexer} which emits
   * the `BlockIndex` objects that are required by this function.
   *
   * The user is responsible for opening and closing the file used in this call.
   *
   * @async
   * @static
   * @memberof CarReader
   * @param {FileHandle | number} fd - A file descriptor from the
   * Node.js `fs` module. Either an integer, from `fs.open()` or a `FileHandle`
   * from `fs.promises.open()`.
   * @param {BlockIndex} blockIndex - An index pointing to the location of the
   * Block required. This `BlockIndex` should take the form:
   * `{cid:CID, blockLength:number, blockOffset:number}`.
   * @returns {Promise<Block>} A `{ cid:CID, bytes:Uint8Array }` pair.
   */ static async readRaw(fd, blockIndex) {
        const { cid, blockLength, blockOffset } = blockIndex;
        const bytes = new Uint8Array(blockLength);
        let read;
        if (typeof fd === 'number') {
            read = (await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$promise$2d$fs$2d$opts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fsread"])(fd, bytes, 0, blockLength, blockOffset)).bytesRead;
        } else if (typeof fd === 'object' && typeof fd.read === 'function') {
            read = (await fd.read(bytes, 0, blockLength, blockOffset)).bytesRead;
        } else {
            throw new TypeError('Bad fd');
        }
        if (read !== blockLength) {
            throw new Error(`Failed to read entire block (${read} instead of ${blockLength})`);
        }
        return {
            cid,
            bytes
        };
    }
}
const __browser = !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$promise$2d$fs$2d$opts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hasFS"];
}),
"[project]/node_modules/@ipld/car/src/indexed-reader.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CarIndexedReader",
    ()=>CarIndexedReader,
    "__browser",
    ()=>__browser
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/fs [external] (fs, cjs)");
var __TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/stream [external] (stream, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/cid.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$indexer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/indexer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$reader$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/reader.js [app-ssr] (ecmascript)");
;
;
;
;
;
class CarIndexedReader {
    /**
   * @param {number} version
   * @param {string} path
   * @param {CID[]} roots
   * @param {Map<string, RawLocation>} index
   * @param {string[]} order
   */ constructor(version, path, roots, index, order){
        this._version = version;
        this._path = path;
        this._roots = roots;
        this._index = index;
        this._order = order;
        this._fd = null;
    }
    get version() {
        return this._version;
    }
    /**
   * See {@link CarReader#getRoots}
   *
   * @function
   * @memberof CarIndexedReader
   * @instance
   * @async
   * @returns {Promise<CID[]>}
   */ async getRoots() {
        return this._roots;
    }
    /**
   * See {@link CarReader#has}
   *
   * @function
   * @memberof CarIndexedReader
   * @instance
   * @async
   * @param {CID} key
   * @returns {Promise<boolean>}
   */ async has(key) {
        return this._index.has(key.toString());
    }
    /**
   * See {@link CarReader#get}
   *
   * @function
   * @memberof CarIndexedReader
   * @instance
   * @async
   * @param {CID} key
   * @returns {Promise<Block | undefined>}
   */ async get(key) {
        const blockIndex = this._index.get(key.toString());
        if (!blockIndex) {
            return undefined;
        }
        if (!this._fd) {
            this._fd = await __TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].promises.open(this._path, 'r');
        }
        const readIndex = {
            cid: key,
            length: 0,
            offset: 0,
            blockLength: blockIndex.blockLength,
            blockOffset: blockIndex.blockOffset
        };
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$reader$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CarReader"].readRaw(this._fd, readIndex);
    }
    /**
   * See {@link CarReader#blocks}
   *
   * @function
   * @memberof CarIndexedReader
   * @instance
   * @async
   * @generator
   * @returns {AsyncGenerator<Block>}
   */ async *blocks() {
        for (const cidStr of this._order){
            const block = await this.get(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].parse(cidStr));
            /* c8 ignore next 3 */ if (!block) {
                throw new Error('Unexpected internal error');
            }
            yield block;
        }
    }
    /**
   * See {@link CarReader#cids}
   *
   * @function
   * @memberof CarIndexedReader
   * @instance
   * @async
   * @generator
   * @returns {AsyncGenerator<CID>}
   */ async *cids() {
        for (const cidStr of this._order){
            yield __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].parse(cidStr);
        }
    }
    /**
   * Close the underlying file descriptor maintained by this `CarIndexedReader`.
   * This must be called for proper resource clean-up to occur.
   *
   * @function
   * @memberof CarIndexedReader
   * @instance
   * @async
   * @returns {Promise<void>}
   */ async close() {
        if (this._fd) {
            return this._fd.close();
        }
    }
    /**
   * Instantiate an {@link CarIndexedReader} from a file with the provided
   * `path`. The CAR file is first indexed with a full path that collects `CID`s
   * and block locations. This index is maintained in memory. Subsequent reads
   * operate on a read-only file descriptor, fetching the block from its in-file
   * location.
   *
   * For large archives, the initial indexing may take some time. The returned
   * `Promise` will resolve only after this is complete.
   *
   * @async
   * @static
   * @memberof CarIndexedReader
   * @param {string} path
   * @returns {Promise<CarIndexedReader>}
   */ static async fromFile(path) {
        if (typeof path !== 'string') {
            throw new TypeError('fromFile() requires a file path string');
        }
        const iterable = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$indexer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CarIndexer"].fromIterable(__TURBOPACK__imported__module__$5b$externals$5d2f$stream__$5b$external$5d$__$28$stream$2c$__cjs$29$__["Readable"].from(__TURBOPACK__imported__module__$5b$externals$5d2f$fs__$5b$external$5d$__$28$fs$2c$__cjs$29$__["default"].createReadStream(path)));
        /** @type {Map<string, RawLocation>} */ const index = new Map();
        /** @type {string[]} */ const order = [];
        for await (const { cid, blockLength, blockOffset } of iterable){
            const cidStr = cid.toString();
            index.set(cidStr, {
                blockLength,
                blockOffset
            });
            order.push(cidStr);
        }
        return new CarIndexedReader(iterable.version, path, await iterable.getRoots(), index, order);
    }
}
const __browser = false;
}),
"[project]/node_modules/@ipld/car/src/iterator.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CarBlockIterator",
    ()=>CarBlockIterator,
    "CarCIDIterator",
    ()=>CarCIDIterator,
    "CarIteratorBase",
    ()=>CarIteratorBase
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/decoder.js [app-ssr] (ecmascript)");
;
class CarIteratorBase {
    /**
   * @param {number} version
   * @param {CID[]} roots
   * @param {AsyncIterable<Block>|void} iterable
   */ constructor(version, roots, iterable){
        this._version = version;
        this._roots = roots;
        this._iterable = iterable;
        this._decoded = false;
    }
    get version() {
        return this._version;
    }
    /**
   * @returns {Promise<CID[]>}
   */ async getRoots() {
        return this._roots;
    }
}
class CarBlockIterator extends CarIteratorBase {
    // inherited method
    /**
   * Get the list of roots defined by the CAR referenced by this iterator. May be
   * zero or more `CID`s.
   *
   * @function getRoots
   * @memberof CarBlockIterator
   * @instance
   * @async
   * @returns {Promise<CID[]>}
   */ /**
   * @returns {AsyncIterator<Block>}
   */ [Symbol.asyncIterator]() {
        if (this._decoded) {
            throw new Error('Cannot decode more than once');
        }
        /* c8 ignore next 3 */ if (!this._iterable) {
            throw new Error('Block iterable not found');
        }
        this._decoded = true;
        return this._iterable[Symbol.asyncIterator]();
    }
    /**
   * Instantiate a {@link CarBlockIterator} from a `Uint8Array` blob. Rather
   * than decoding the entire byte array prior to returning the iterator, as in
   * {@link CarReader.fromBytes}, only the header is decoded and the remainder
   * of the CAR is parsed as the `Block`s as yielded.
   *
   * @async
   * @static
   * @memberof CarBlockIterator
   * @param {Uint8Array} bytes
   * @returns {Promise<CarBlockIterator>}
   */ static async fromBytes(bytes) {
        const { version, roots, iterator } = await fromBytes(bytes);
        return new CarBlockIterator(version, roots, iterator);
    }
    /**
   * Instantiate a {@link CarBlockIterator} from a `AsyncIterable<Uint8Array>`,
   * such as a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).
   * Rather than decoding the entire byte array prior to returning the iterator,
   * as in {@link CarReader.fromIterable}, only the header is decoded and the
   * remainder of the CAR is parsed as the `Block`s as yielded.
   *
   * @async
   * @static
   * @param {AsyncIterable<Uint8Array>} asyncIterable
   * @returns {Promise<CarBlockIterator>}
   */ static async fromIterable(asyncIterable) {
        const { version, roots, iterator } = await fromIterable(asyncIterable);
        return new CarBlockIterator(version, roots, iterator);
    }
}
class CarCIDIterator extends CarIteratorBase {
    // inherited method
    /**
   * Get the list of roots defined by the CAR referenced by this iterator. May be
   * zero or more `CID`s.
   *
   * @function getRoots
   * @memberof CarCIDIterator
   * @instance
   * @async
   * @returns {Promise<CID[]>}
   */ /**
   * @returns {AsyncIterator<CID>}
   */ [Symbol.asyncIterator]() {
        if (this._decoded) {
            throw new Error('Cannot decode more than once');
        }
        /* c8 ignore next 3 */ if (!this._iterable) {
            throw new Error('Block iterable not found');
        }
        this._decoded = true;
        const iterable = this._iterable[Symbol.asyncIterator]();
        return {
            async next () {
                const next = await iterable.next();
                if (next.done) {
                    return next;
                }
                return {
                    done: false,
                    value: next.value.cid
                };
            }
        };
    }
    /**
   * Instantiate a {@link CarCIDIterator} from a `Uint8Array` blob. Rather
   * than decoding the entire byte array prior to returning the iterator, as in
   * {@link CarReader.fromBytes}, only the header is decoded and the remainder
   * of the CAR is parsed as the `CID`s as yielded.
   *
   * @async
   * @static
   * @memberof CarCIDIterator
   * @param {Uint8Array} bytes
   * @returns {Promise<CarCIDIterator>}
   */ static async fromBytes(bytes) {
        const { version, roots, iterator } = await fromBytes(bytes);
        return new CarCIDIterator(version, roots, iterator);
    }
    /**
   * Instantiate a {@link CarCIDIterator} from a `AsyncIterable<Uint8Array>`,
   * such as a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).
   * Rather than decoding the entire byte array prior to returning the iterator,
   * as in {@link CarReader.fromIterable}, only the header is decoded and the
   * remainder of the CAR is parsed as the `CID`s as yielded.
   *
   * @async
   * @static
   * @memberof CarCIDIterator
   * @param {AsyncIterable<Uint8Array>} asyncIterable
   * @returns {Promise<CarCIDIterator>}
   */ static async fromIterable(asyncIterable) {
        const { version, roots, iterator } = await fromIterable(asyncIterable);
        return new CarCIDIterator(version, roots, iterator);
    }
}
/**
 * @param {Uint8Array} bytes
 * @returns {Promise<{ version:number, roots:CID[], iterator:AsyncIterable<Block>}>}
 */ async function fromBytes(bytes) {
    if (!(bytes instanceof Uint8Array)) {
        throw new TypeError('fromBytes() requires a Uint8Array');
    }
    return decodeIterator((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesReader"])(bytes));
}
/**
 * @param {AsyncIterable<Uint8Array>} asyncIterable
 * @returns {Promise<{ version:number, roots:CID[], iterator:AsyncIterable<Block>}>}
 */ async function fromIterable(asyncIterable) {
    if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === 'function')) {
        throw new TypeError('fromIterable() requires an async iterable');
    }
    return decodeIterator((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["asyncIterableReader"])(asyncIterable));
}
/**
 * @private
 * @param {BytesReader} reader
 * @returns {Promise<{ version:number, roots:CID[], iterator:AsyncIterable<Block>}>}
 */ async function decodeIterator(reader) {
    const decoder = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createDecoder"])(reader);
    const { version, roots } = await decoder.header();
    return {
        version,
        roots,
        iterator: decoder.blocks()
    };
}
}),
"[project]/node_modules/@ipld/car/src/encoder.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createEncoder",
    ()=>createEncoder,
    "createHeader",
    ()=>createHeader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-cbor/src/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/varint/index.js [app-ssr] (ecmascript)");
;
;
/**
 * @typedef {import('multiformats').CID} CID
 * @typedef {import('./api.js').Block} Block
 * @typedef {import('./coding.js').CarEncoder} CarEncoder
 * @typedef {import('./coding.js').IteratorChannel_Writer<Uint8Array>} IteratorChannel_Writer
 */ const CAR_V1_VERSION = 1;
function createHeader(roots) {
    const headerBytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encode"])({
        version: CAR_V1_VERSION,
        roots
    });
    const varintBytes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].encode(headerBytes.length);
    const header = new Uint8Array(varintBytes.length + headerBytes.length);
    header.set(varintBytes, 0);
    header.set(headerBytes, varintBytes.length);
    return header;
}
/**
 * @param {IteratorChannel_Writer} writer
 * @returns {CarEncoder}
 */ function createEncoder(writer) {
    // none of this is wrapped in a mutex, that needs to happen above this to
    // avoid overwrites
    return {
        /**
     * @param {CID[]} roots
     * @returns {Promise<void>}
     */ async setRoots (roots) {
            const bytes = createHeader(roots);
            await writer.write(bytes);
        },
        /**
     * @param {Block} block
     * @returns {Promise<void>}
     */ async writeBlock (block) {
            const { cid, bytes } = block;
            await writer.write(new Uint8Array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].encode(cid.bytes.length + bytes.length)));
            await writer.write(cid.bytes);
            if (bytes.length) {
                // zero-length blocks are valid, but it'd be safer if we didn't write them
                await writer.write(bytes);
            }
        },
        /**
     * @returns {Promise<void>}
     */ async close () {
            await writer.end();
        },
        /**
     * @returns {number}
     */ version () {
            return CAR_V1_VERSION;
        }
    };
}
;
}),
"[project]/node_modules/@ipld/car/src/iterator-channel.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @template {any} T
 * @typedef {import('./coding.js').IteratorChannel<T>} IteratorChannel
 */ __turbopack_context__.s([
    "create",
    ()=>create
]);
function noop() {}
function create() {
    /** @type {T[]} */ const chunkQueue = [];
    /** @type {Promise<void> | null} */ let drainer = null;
    let drainerResolver = noop;
    let ended = false;
    /** @type {Promise<IteratorResult<T>> | null} */ let outWait = null;
    let outWaitResolver = noop;
    const makeDrainer = ()=>{
        if (!drainer) {
            drainer = new Promise((resolve)=>{
                drainerResolver = ()=>{
                    drainer = null;
                    drainerResolver = noop;
                    resolve();
                };
            });
        }
        return drainer;
    };
    /**
   * @returns {IteratorChannel<T>}
   */ const writer = {
        /**
     * @param {T} chunk
     * @returns {Promise<void>}
     */ write (chunk) {
            chunkQueue.push(chunk);
            const drainer = makeDrainer();
            outWaitResolver();
            return drainer;
        },
        async end () {
            ended = true;
            const drainer = makeDrainer();
            outWaitResolver();
            await drainer;
        }
    };
    /** @type {AsyncIterator<T>} */ const iterator = {
        /** @returns {Promise<IteratorResult<T>>} */ async next () {
            const chunk = chunkQueue.shift();
            if (chunk) {
                if (chunkQueue.length === 0) {
                    drainerResolver();
                }
                return {
                    done: false,
                    value: chunk
                };
            }
            if (ended) {
                drainerResolver();
                return {
                    done: true,
                    value: undefined
                };
            }
            if (!outWait) {
                outWait = new Promise((resolve)=>{
                    outWaitResolver = ()=>{
                        outWait = null;
                        outWaitResolver = noop;
                        return resolve(iterator.next());
                    };
                });
            }
            return outWait;
        }
    };
    return {
        writer,
        iterator
    };
}
}),
"[project]/node_modules/@ipld/car/src/writer-browser.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CarWriter",
    ()=>CarWriter,
    "CarWriterOut",
    ()=>CarWriterOut,
    "__browser",
    ()=>__browser
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/cid.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/decoder.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$encoder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/encoder.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$iterator$2d$channel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/iterator-channel.js [app-ssr] (ecmascript)");
;
;
;
;
class CarWriter {
    /**
   * @param {CID[]} roots
   * @param {CarEncoder} encoder
   */ constructor(roots, encoder){
        this._encoder = encoder;
        /** @type {Promise<void>} */ this._mutex = encoder.setRoots(roots);
        this._ended = false;
    }
    /**
   * Write a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) to the archive.
   *
   * @function
   * @memberof CarWriter
   * @instance
   * @async
   * @param {Block} block - A `{ cid:CID, bytes:Uint8Array }` pair.
   * @returns {Promise<void>} The returned promise will only resolve once the
   * bytes this block generates are written to the `out` iterable.
   */ async put(block) {
        if (!(block.bytes instanceof Uint8Array) || !block.cid) {
            throw new TypeError('Can only write {cid, bytes} objects');
        }
        if (this._ended) {
            throw new Error('Already closed');
        }
        const cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].asCID(block.cid);
        if (!cid) {
            throw new TypeError('Can only write {cid, bytes} objects');
        }
        this._mutex = this._mutex.then(()=>this._encoder.writeBlock({
                cid,
                bytes: block.bytes
            }));
        return this._mutex;
    }
    /**
   * Finalise the CAR archive and signal that the `out` iterable should end once
   * any remaining bytes are written.
   *
   * @function
   * @memberof CarWriter
   * @instance
   * @async
   * @returns {Promise<void>}
   */ async close() {
        if (this._ended) {
            throw new Error('Already closed');
        }
        await this._mutex;
        this._ended = true;
        return this._encoder.close();
    }
    /**
   * Returns the version number of the CAR file being written
   *
   * @returns {number}
   */ version() {
        return this._encoder.version();
    }
    /**
   * Create a new CAR writer "channel" which consists of a
   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair.
   *
   * @async
   * @static
   * @memberof CarWriter
   * @param {CID[] | CID | void} roots
   * @returns {WriterChannel} The channel takes the form of
   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }`.
   */ static create(roots) {
        roots = toRoots(roots);
        const { encoder, iterator } = encodeWriter();
        const writer = new CarWriter(roots, encoder);
        const out = new CarWriterOut(iterator);
        return {
            writer,
            out
        };
    }
    /**
   * Create a new CAR appender "channel" which consists of a
   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair.
   * This appender does not consider roots and does not produce a CAR header.
   * It is designed to append blocks to an _existing_ CAR archive. It is
   * expected that `out` will be concatenated onto the end of an existing
   * archive that already has a properly formatted header.
   *
   * @async
   * @static
   * @memberof CarWriter
   * @returns {WriterChannel} The channel takes the form of
   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }`.
   */ static createAppender() {
        const { encoder, iterator } = encodeWriter();
        encoder.setRoots = ()=>Promise.resolve();
        const writer = new CarWriter([], encoder);
        const out = new CarWriterOut(iterator);
        return {
            writer,
            out
        };
    }
    /**
   * Update the list of roots in the header of an existing CAR as represented
   * in a Uint8Array.
   *
   * This operation is an _overwrite_, the total length of the CAR will not be
   * modified. A rejection will occur if the new header will not be the same
   * length as the existing header, in which case the CAR will not be modified.
   * It is the responsibility of the user to ensure that the roots being
   * replaced encode as the same length as the new roots.
   *
   * The byte array passed in an argument will be modified and also returned
   * upon successful modification.
   *
   * @async
   * @static
   * @memberof CarWriter
   * @param {Uint8Array} bytes
   * @param {CID[]} roots - A new list of roots to replace the existing list in
   * the CAR header. The new header must take up the same number of bytes as the
   * existing header, so the roots should collectively be the same byte length
   * as the existing roots.
   * @returns {Promise<Uint8Array>}
   */ static async updateRootsInBytes(bytes, roots) {
        const reader = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["bytesReader"])(bytes);
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["readHeader"])(reader);
        const newHeader = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$encoder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createHeader"])(roots);
        if (Number(reader.pos) !== newHeader.length) {
            throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${reader.pos} bytes, new header is ${newHeader.length} bytes)`);
        }
        bytes.set(newHeader, 0);
        return bytes;
    }
}
class CarWriterOut {
    /**
   * @param {AsyncIterator<Uint8Array>} iterator
   */ constructor(iterator){
        this._iterator = iterator;
    }
    [Symbol.asyncIterator]() {
        if (this._iterating) {
            throw new Error('Multiple iterator not supported');
        }
        this._iterating = true;
        return this._iterator;
    }
}
function encodeWriter() {
    /** @type {IteratorChannel} */ const iw = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$iterator$2d$channel$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["create"])();
    const { writer, iterator } = iw;
    const encoder = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$encoder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createEncoder"])(writer);
    return {
        encoder,
        iterator
    };
}
/**
 * @private
 * @param {CID[] | CID | void} roots
 * @returns {CID[]}
 */ function toRoots(roots) {
    if (roots === undefined) {
        return [];
    }
    if (!Array.isArray(roots)) {
        const cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].asCID(roots);
        if (!cid) {
            throw new TypeError('roots must be a single CID or an array of CIDs');
        }
        return [
            cid
        ];
    }
    const _roots = [];
    for (const root of roots){
        const _root = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].asCID(root);
        if (!_root) {
            throw new TypeError('roots must be a single CID or an array of CIDs');
        }
        _roots.push(_root);
    }
    return _roots;
}
const __browser = true;
}),
"[project]/node_modules/@ipld/car/src/writer.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CarWriter",
    ()=>CarWriter,
    "__browser",
    ()=>__browser
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/decoder.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$encoder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/encoder.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$promise$2d$fs$2d$opts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/promise-fs-opts.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$writer$2d$browser$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/writer-browser.js [app-ssr] (ecmascript)");
;
;
;
;
class CarWriter extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$writer$2d$browser$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["CarWriter"] {
    /**
   * Update the list of roots in the header of an existing CAR file. The first
   * argument must be a file descriptor for CAR file that is open in read and
   * write mode (not append), e.g. `fs.open` or `fs.promises.open` with `'r+'`
   * mode.
   *
   * This operation is an _overwrite_, the total length of the CAR will not be
   * modified. A rejection will occur if the new header will not be the same
   * length as the existing header, in which case the CAR will not be modified.
   * It is the responsibility of the user to ensure that the roots being
   * replaced encode as the same length as the new roots.
   *
   * This function is **only available in Node.js** and not a browser
   * environment.
   *
   * @async
   * @static
   * @memberof CarWriter
   * @param {FileHandle | number} fd - A file descriptor from the
   * Node.js `fs` module. Either an integer, from `fs.open()` or a `FileHandle`
   * from `fs.promises.open()`.
   * @param {CID[]} roots - A new list of roots to replace the existing list in
   * the CAR header. The new header must take up the same number of bytes as the
   * existing header, so the roots should collectively be the same byte length
   * as the existing roots.
   * @returns {Promise<void>}
   */ static async updateRootsInFile(fd, roots) {
        const chunkSize = 256;
        /** @type {Uint8Array} */ let bytes;
        let offset = 0;
        /** @type {() => Promise<number>} */ let readChunk;
        if (typeof fd === 'number') {
            readChunk = async ()=>(await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$promise$2d$fs$2d$opts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fsread"])(fd, bytes, 0, chunkSize, offset)).bytesRead;
        } else if (typeof fd === 'object' && typeof fd.read === 'function') {
            readChunk = async ()=>(await fd.read(bytes, 0, chunkSize, offset)).bytesRead;
        } else {
            throw new TypeError('Bad fd');
        }
        const fdReader = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["chunkReader"])(async ()=>{
            bytes = new Uint8Array(chunkSize); // need a new chunk each time, can't reuse old
            const read = await readChunk();
            offset += read;
            /* eslint no-warning-comments: 0 */ // TODO: test header > 256 bytes
            return read < chunkSize ? bytes.subarray(0, read) : bytes;
        });
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["readHeader"])(fdReader);
        const newHeader = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$encoder$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createHeader"])(roots);
        if (fdReader.pos !== newHeader.length) {
            throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${fdReader.pos} bytes, new header is ${newHeader.length} bytes)`);
        }
        if (typeof fd === 'number') {
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$promise$2d$fs$2d$opts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["fswrite"])(fd, newHeader, 0, newHeader.length, 0);
        } else if (typeof fd === 'object' && typeof fd.read === 'function') {
            await fd.write(newHeader, 0, newHeader.length, 0);
        }
    }
}
const __browser = !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$promise$2d$fs$2d$opts$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["hasFS"];
}),
"[project]/node_modules/@ipld/car/src/index.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "contentType",
    ()=>contentType
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$buffer$2d$reader$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/buffer-reader.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$buffer$2d$writer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/buffer-writer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$indexed$2d$reader$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/indexed-reader.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$indexer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/indexer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$iterator$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/iterator.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$reader$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/reader.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$writer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/writer.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
const contentType = 'application/vnd.ipld.car';
;
}),
"[project]/node_modules/@ipld/dag-pb/src/pb-decode.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "decodeNode",
    ()=>decodeNode
]);
const textDecoder = new TextDecoder();
/**
 * @typedef {import('./interface.js').RawPBLink} RawPBLink
 */ /**
 * @typedef {import('./interface.js').RawPBNode} RawPBNode
 */ /**
 * @param {Uint8Array} bytes
 * @param {number} offset
 * @returns {[number, number]}
 */ function decodeVarint(bytes, offset) {
    let v = 0;
    for(let shift = 0;; shift += 7){
        /* c8 ignore next 3 */ if (shift >= 64) {
            throw new Error('protobuf: varint overflow');
        }
        /* c8 ignore next 3 */ if (offset >= bytes.length) {
            throw new Error('protobuf: unexpected end of data');
        }
        const b = bytes[offset++];
        v += shift < 28 ? (b & 0x7f) << shift : (b & 0x7f) * 2 ** shift;
        if (b < 0x80) {
            break;
        }
    }
    return [
        v,
        offset
    ];
}
/**
 * @param {Uint8Array} bytes
 * @param {number} offset
 * @returns {[Uint8Array, number]}
 */ function decodeBytes(bytes, offset) {
    let byteLen;
    [byteLen, offset] = decodeVarint(bytes, offset);
    const postOffset = offset + byteLen;
    /* c8 ignore next 3 */ if (byteLen < 0 || postOffset < 0) {
        throw new Error('protobuf: invalid length');
    }
    /* c8 ignore next 3 */ if (postOffset > bytes.length) {
        throw new Error('protobuf: unexpected end of data');
    }
    return [
        bytes.subarray(offset, postOffset),
        postOffset
    ];
}
/**
 * @param {Uint8Array} bytes
 * @param {number} index
 * @returns {[number, number, number]}
 */ function decodeKey(bytes, index) {
    let wire;
    [wire, index] = decodeVarint(bytes, index);
    // [wireType, fieldNum, newIndex]
    return [
        wire & 0x7,
        wire >> 3,
        index
    ];
}
/**
 * @param {Uint8Array} bytes
 * @returns {RawPBLink}
 */ function decodeLink(bytes) {
    /** @type {RawPBLink} */ const link = {};
    const l = bytes.length;
    let index = 0;
    while(index < l){
        let wireType, fieldNum;
        [wireType, fieldNum, index] = decodeKey(bytes, index);
        if (fieldNum === 1) {
            if (link.Hash) {
                throw new Error('protobuf: (PBLink) duplicate Hash section');
            }
            if (wireType !== 2) {
                throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`);
            }
            if (link.Name !== undefined) {
                throw new Error('protobuf: (PBLink) invalid order, found Name before Hash');
            }
            if (link.Tsize !== undefined) {
                throw new Error('protobuf: (PBLink) invalid order, found Tsize before Hash');
            }
            [link.Hash, index] = decodeBytes(bytes, index);
        } else if (fieldNum === 2) {
            if (link.Name !== undefined) {
                throw new Error('protobuf: (PBLink) duplicate Name section');
            }
            if (wireType !== 2) {
                throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`);
            }
            if (link.Tsize !== undefined) {
                throw new Error('protobuf: (PBLink) invalid order, found Tsize before Name');
            }
            let byts;
            [byts, index] = decodeBytes(bytes, index);
            link.Name = textDecoder.decode(byts);
        } else if (fieldNum === 3) {
            if (link.Tsize !== undefined) {
                throw new Error('protobuf: (PBLink) duplicate Tsize section');
            }
            if (wireType !== 0) {
                throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`);
            }
            [link.Tsize, index] = decodeVarint(bytes, index);
        } else {
            throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`);
        }
    }
    /* c8 ignore next 3 */ if (index > l) {
        throw new Error('protobuf: (PBLink) unexpected end of data');
    }
    return link;
}
function decodeNode(bytes) {
    const l = bytes.length;
    let index = 0;
    /** @type {RawPBLink[]|void} */ let links = undefined // eslint-disable-line no-undef-init
    ;
    let linksBeforeData = false;
    /** @type {Uint8Array|void} */ let data = undefined // eslint-disable-line no-undef-init
    ;
    while(index < l){
        let wireType, fieldNum;
        [wireType, fieldNum, index] = decodeKey(bytes, index);
        if (wireType !== 2) {
            throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`);
        }
        if (fieldNum === 1) {
            if (data) {
                throw new Error('protobuf: (PBNode) duplicate Data section');
            }
            [data, index] = decodeBytes(bytes, index);
            if (links) {
                linksBeforeData = true;
            }
        } else if (fieldNum === 2) {
            if (linksBeforeData) {
                throw new Error('protobuf: (PBNode) duplicate Links section');
            } else if (!links) {
                links = [];
            }
            let byts;
            [byts, index] = decodeBytes(bytes, index);
            links.push(decodeLink(byts));
        } else {
            throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`);
        }
    }
    /* c8 ignore next 3 */ if (index > l) {
        throw new Error('protobuf: (PBNode) unexpected end of data');
    }
    /** @type {RawPBNode} */ const node = {};
    if (data) {
        node.Data = data;
    }
    node.Links = links || [];
    return node;
}
}),
"[project]/node_modules/@ipld/dag-pb/src/pb-encode.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "encodeNode",
    ()=>encodeNode
]);
const textEncoder = new TextEncoder();
const maxInt32 = 2 ** 32;
const maxUInt32 = 2 ** 31;
/**
 * @typedef {import('./interface.js').RawPBLink} RawPBLink
 */ /**
 * @typedef {import('./interface.js').RawPBNode} RawPBNode
 */ // the encoders work backward from the end of the bytes array
/**
 * encodeLink() is passed a slice of the parent byte array that ends where this
 * link needs to end, so it packs to the right-most part of the passed `bytes`
 *
 * @param {RawPBLink} link
 * @param {Uint8Array} bytes
 * @returns {number}
 */ function encodeLink(link, bytes) {
    let i = bytes.length;
    if (typeof link.Tsize === 'number') {
        if (link.Tsize < 0) {
            throw new Error('Tsize cannot be negative');
        }
        if (!Number.isSafeInteger(link.Tsize)) {
            throw new Error('Tsize too large for encoding');
        }
        i = encodeVarint(bytes, i, link.Tsize) - 1;
        bytes[i] = 0x18;
    }
    if (typeof link.Name === 'string') {
        const nameBytes = textEncoder.encode(link.Name);
        i -= nameBytes.length;
        bytes.set(nameBytes, i);
        i = encodeVarint(bytes, i, nameBytes.length) - 1;
        bytes[i] = 0x12;
    }
    if (link.Hash) {
        i -= link.Hash.length;
        bytes.set(link.Hash, i);
        i = encodeVarint(bytes, i, link.Hash.length) - 1;
        bytes[i] = 0xa;
    }
    return bytes.length - i;
}
function encodeNode(node) {
    const size = sizeNode(node);
    const bytes = new Uint8Array(size);
    let i = size;
    if (node.Data) {
        i -= node.Data.length;
        bytes.set(node.Data, i);
        i = encodeVarint(bytes, i, node.Data.length) - 1;
        bytes[i] = 0xa;
    }
    if (node.Links) {
        for(let index = node.Links.length - 1; index >= 0; index--){
            const size = encodeLink(node.Links[index], bytes.subarray(0, i));
            i -= size;
            i = encodeVarint(bytes, i, size) - 1;
            bytes[i] = 0x12;
        }
    }
    return bytes;
}
/**
 * work out exactly how many bytes this link takes up
 *
 * @param {RawPBLink} link
 * @returns
 */ function sizeLink(link) {
    let n = 0;
    if (link.Hash) {
        const l = link.Hash.length;
        n += 1 + l + sov(l);
    }
    if (typeof link.Name === 'string') {
        const l = textEncoder.encode(link.Name).length;
        n += 1 + l + sov(l);
    }
    if (typeof link.Tsize === 'number') {
        n += 1 + sov(link.Tsize);
    }
    return n;
}
/**
 * Work out exactly how many bytes this node takes up
 *
 * @param {RawPBNode} node
 * @returns {number}
 */ function sizeNode(node) {
    let n = 0;
    if (node.Data) {
        const l = node.Data.length;
        n += 1 + l + sov(l);
    }
    if (node.Links) {
        for (const link of node.Links){
            const l = sizeLink(link);
            n += 1 + l + sov(l);
        }
    }
    return n;
}
/**
 * @param {Uint8Array} bytes
 * @param {number} offset
 * @param {number} v
 * @returns {number}
 */ function encodeVarint(bytes, offset, v) {
    offset -= sov(v);
    const base = offset;
    while(v >= maxUInt32){
        bytes[offset++] = v & 0x7f | 0x80;
        v /= 128;
    }
    while(v >= 128){
        bytes[offset++] = v & 0x7f | 0x80;
        v >>>= 7;
    }
    bytes[offset] = v;
    return base;
}
/**
 * size of varint
 *
 * @param {number} x
 * @returns {number}
 */ function sov(x) {
    if (x % 2 === 0) {
        x++;
    }
    return Math.floor((len64(x) + 6) / 7);
}
/**
 * golang math/bits, how many bits does it take to represent this integer?
 *
 * @param {number} x
 * @returns {number}
 */ function len64(x) {
    let n = 0;
    if (x >= maxInt32) {
        x = Math.floor(x / maxInt32);
        n = 32;
    }
    if (x >= 1 << 16) {
        x >>>= 16;
        n += 16;
    }
    if (x >= 1 << 8) {
        x >>>= 8;
        n += 8;
    }
    return n + len8tab[x];
}
// golang math/bits
const len8tab = [
    0,
    1,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8
];
}),
"[project]/node_modules/@ipld/dag-pb/src/util.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createLink",
    ()=>createLink,
    "createNode",
    ()=>createNode,
    "prepare",
    ()=>prepare,
    "toByteView",
    ()=>toByteView,
    "validate",
    ()=>validate
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/cid.js [app-ssr] (ecmascript) <locals>");
;
/* eslint-disable complexity, no-nested-ternary */ /**
 * @typedef {import('./interface.js').PBLink} PBLink
 * @typedef {import('./interface.js').PBNode} PBNode
 */ /**
 * @template T
 * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView
 */ /**
 * @template T
 * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView
 */ const pbNodeProperties = [
    'Data',
    'Links'
];
const pbLinkProperties = [
    'Hash',
    'Name',
    'Tsize'
];
const textEncoder = new TextEncoder();
/**
 * @param {PBLink} a
 * @param {PBLink} b
 * @returns {number}
 */ function linkComparator(a, b) {
    if (a === b) {
        return 0;
    }
    const abuf = a.Name ? textEncoder.encode(a.Name) : [];
    const bbuf = b.Name ? textEncoder.encode(b.Name) : [];
    let x = abuf.length;
    let y = bbuf.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i){
        if (abuf[i] !== bbuf[i]) {
            x = abuf[i];
            y = bbuf[i];
            break;
        }
    }
    return x < y ? -1 : y < x ? 1 : 0;
}
/**
 * @param {any} node
 * @param {string[]} properties
 * @returns {boolean}
 */ function hasOnlyProperties(node, properties) {
    return !Object.keys(node).some((p)=>!properties.includes(p));
}
/**
 * Converts a CID, or a PBLink-like object to a PBLink
 *
 * @param {any} link
 * @returns {PBLink}
 */ function asLink(link) {
    if (typeof link.asCID === 'object') {
        const Hash = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].asCID(link);
        if (!Hash) {
            throw new TypeError('Invalid DAG-PB form');
        }
        return {
            Hash
        };
    }
    if (typeof link !== 'object' || Array.isArray(link)) {
        throw new TypeError('Invalid DAG-PB form');
    }
    const pbl = {};
    if (link.Hash) {
        let cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].asCID(link.Hash);
        try {
            if (!cid) {
                if (typeof link.Hash === 'string') {
                    cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].parse(link.Hash);
                } else if (link.Hash instanceof Uint8Array) {
                    cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].decode(link.Hash);
                }
            }
        } catch (/** @type {any} */ e) {
            throw new TypeError(`Invalid DAG-PB form: ${e.message}`);
        }
        if (cid) {
            pbl.Hash = cid;
        }
    }
    if (!pbl.Hash) {
        throw new TypeError('Invalid DAG-PB form');
    }
    if (typeof link.Name === 'string') {
        pbl.Name = link.Name;
    }
    if (typeof link.Tsize === 'number') {
        pbl.Tsize = link.Tsize;
    }
    return pbl;
}
function prepare(node) {
    if (node instanceof Uint8Array || typeof node === 'string') {
        node = {
            Data: node
        };
    }
    if (typeof node !== 'object' || Array.isArray(node)) {
        throw new TypeError('Invalid DAG-PB form');
    }
    /** @type {PBNode} */ const pbn = {};
    if (node.Data !== undefined) {
        if (typeof node.Data === 'string') {
            pbn.Data = textEncoder.encode(node.Data);
        } else if (node.Data instanceof Uint8Array) {
            pbn.Data = node.Data;
        } else {
            throw new TypeError('Invalid DAG-PB form');
        }
    }
    if (node.Links !== undefined) {
        if (Array.isArray(node.Links)) {
            pbn.Links = node.Links.map(asLink);
            pbn.Links.sort(linkComparator);
        } else {
            throw new TypeError('Invalid DAG-PB form');
        }
    } else {
        pbn.Links = [];
    }
    return pbn;
}
function validate(node) {
    /*
  type PBLink struct {
    Hash optional Link
    Name optional String
    Tsize optional Int
  }

  type PBNode struct {
    Links [PBLink]
    Data optional Bytes
  }
  */ // @ts-ignore private property for TS
    if (!node || typeof node !== 'object' || Array.isArray(node) || node instanceof Uint8Array || node['/'] && node['/'] === node.bytes) {
        throw new TypeError('Invalid DAG-PB form');
    }
    if (!hasOnlyProperties(node, pbNodeProperties)) {
        throw new TypeError('Invalid DAG-PB form (extraneous properties)');
    }
    if (node.Data !== undefined && !(node.Data instanceof Uint8Array)) {
        throw new TypeError('Invalid DAG-PB form (Data must be bytes)');
    }
    if (!Array.isArray(node.Links)) {
        throw new TypeError('Invalid DAG-PB form (Links must be a list)');
    }
    for(let i = 0; i < node.Links.length; i++){
        const link = node.Links[i];
        // @ts-ignore private property for TS
        if (!link || typeof link !== 'object' || Array.isArray(link) || link instanceof Uint8Array || link['/'] && link['/'] === link.bytes) {
            throw new TypeError('Invalid DAG-PB form (bad link)');
        }
        if (!hasOnlyProperties(link, pbLinkProperties)) {
            throw new TypeError('Invalid DAG-PB form (extraneous properties on link)');
        }
        if (link.Hash === undefined) {
            throw new TypeError('Invalid DAG-PB form (link must have a Hash)');
        }
        // @ts-ignore private property for TS
        if (link.Hash == null || !link.Hash['/'] || link.Hash['/'] !== link.Hash.bytes) {
            throw new TypeError('Invalid DAG-PB form (link Hash must be a CID)');
        }
        if (link.Name !== undefined && typeof link.Name !== 'string') {
            throw new TypeError('Invalid DAG-PB form (link Name must be a string)');
        }
        if (link.Tsize !== undefined) {
            if (typeof link.Tsize !== 'number' || link.Tsize % 1 !== 0) {
                throw new TypeError('Invalid DAG-PB form (link Tsize must be an integer)');
            }
            if (link.Tsize < 0) {
                throw new TypeError('Invalid DAG-PB form (link Tsize cannot be negative)');
            }
        }
        if (i > 0 && linkComparator(link, node.Links[i - 1]) === -1) {
            throw new TypeError('Invalid DAG-PB form (links must be sorted by Name bytes)');
        }
    }
}
function createNode(data, links = []) {
    return prepare({
        Data: data,
        Links: links
    });
}
function createLink(name, size, cid) {
    return asLink({
        Hash: cid,
        Name: name,
        Tsize: size
    });
}
function toByteView(buf) {
    if (buf instanceof ArrayBuffer) {
        return new Uint8Array(buf, 0, buf.byteLength);
    }
    return buf;
}
}),
"[project]/node_modules/@ipld/dag-pb/src/index.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "code",
    ()=>code,
    "decode",
    ()=>decode,
    "encode",
    ()=>encode,
    "name",
    ()=>name
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/cid.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$pb$2d$decode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-pb/src/pb-decode.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$pb$2d$encode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-pb/src/pb-encode.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-pb/src/util.js [app-ssr] (ecmascript)");
;
;
;
;
const name = 'dag-pb';
const code = 0x70;
function encode(node) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["validate"])(node);
    const pbn = {};
    if (node.Links) {
        pbn.Links = node.Links.map((l)=>{
            const link = {};
            if (l.Hash) {
                link.Hash = l.Hash.bytes; // cid -> bytes
            }
            if (l.Name !== undefined) {
                link.Name = l.Name;
            }
            if (l.Tsize !== undefined) {
                link.Tsize = l.Tsize;
            }
            return link;
        });
    }
    if (node.Data) {
        pbn.Data = node.Data;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$pb$2d$encode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["encodeNode"])(pbn);
}
function decode(bytes) {
    const buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["toByteView"])(bytes);
    const pbn = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$pb$2d$decode$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["decodeNode"])(buf);
    const node = {};
    if (pbn.Data) {
        node.Data = pbn.Data;
    }
    if (pbn.Links) {
        node.Links = pbn.Links.map((l)=>{
            const link = {};
            try {
                link.Hash = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].decode(l.Hash);
            } catch  {
            // ignore parse fail
            }
            if (!link.Hash) {
                throw new Error('Invalid Hash field found in link, expected CID');
            }
            if (l.Name !== undefined) {
                link.Name = l.Name;
            }
            if (l.Tsize !== undefined) {
                link.Tsize = l.Tsize;
            }
            return link;
        });
    }
    return node;
}
;
}),
];

//# sourceMappingURL=node_modules_%40ipld_74b8c19b._.js.map