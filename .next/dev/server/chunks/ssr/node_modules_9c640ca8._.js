module.exports = [
"[project]/node_modules/@web3-storage/capabilities/node_modules/@ucanto/validator/src/util.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @template {string|boolean|number|[unknown, ...unknown[]]} T
 * @param {T} value
 * @returns {T}
 */ __turbopack_context__.s([
    "combine",
    ()=>combine,
    "entries",
    ()=>entries,
    "intersection",
    ()=>intersection,
    "the",
    ()=>the
]);
const the = (value)=>value;
const entries = (object)=>Object.entries(object);
const combine = ([first, ...rest])=>{
    const results = first.map((value)=>[
            value
        ]);
    for (const values of rest){
        const tuples = results.splice(0);
        for (const value of values){
            for (const tuple of tuples){
                results.push([
                    ...tuple,
                    value
                ]);
            }
        }
    }
    return results;
};
const intersection = (left, right)=>{
    const [result, other] = left.length < right.length ? [
        new Set(left),
        new Set(right)
    ] : [
        new Set(right),
        new Set(left)
    ];
    for (const item of result){
        if (!other.has(item)) {
            result.delete(item);
        }
    }
    return [
        ...result
    ];
};
}),
"[project]/node_modules/@web3-storage/capabilities/node_modules/@ucanto/validator/src/error.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DIDKeyResolutionError",
    ()=>DIDKeyResolutionError,
    "DelegationError",
    ()=>DelegationError,
    "EscalatedCapability",
    ()=>EscalatedCapability,
    "Expired",
    ()=>Expired,
    "InvalidSignature",
    ()=>InvalidSignature,
    "MalformedCapability",
    ()=>MalformedCapability,
    "NotValidBefore",
    ()=>NotValidBefore,
    "PrincipalAlignmentError",
    ()=>PrincipalAlignmentError,
    "Revoked",
    ()=>Revoked,
    "SessionEscalation",
    ()=>SessionEscalation,
    "Unauthorized",
    ()=>Unauthorized,
    "UnavailableProof",
    ()=>UnavailableProof,
    "UnknownCapability",
    ()=>UnknownCapability,
    "indent",
    ()=>indent,
    "li",
    ()=>li
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$interface$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/capabilities/node_modules/@ucanto/interface/src/lib.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/capabilities/node_modules/@ucanto/validator/src/util.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$link$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/link.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/node_modules/multiformats/dist/src/link.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/result.js [app-ssr] (ecmascript)");
;
;
;
;
;
class EscalatedCapability extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {API.ParsedCapability} claimed
   * @param {object} delegated
   * @param {API.Failure} cause
   */ constructor(claimed, delegated, cause){
        super();
        this.claimed = claimed;
        this.delegated = delegated;
        this.cause = cause;
        this.name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["the"])('EscalatedCapability');
    }
    describe() {
        return `Constraint violation: ${this.cause.message}`;
    }
}
class DelegationError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {(API.InvalidCapability | API.EscalatedDelegation | API.DelegationError)[]} causes
   * @param {object} context
   */ constructor(causes, context){
        super();
        this.name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["the"])('InvalidClaim');
        this.causes = causes;
        this.context = context;
    }
    describe() {
        return [
            `Can not derive ${this.context} from delegated capabilities:`,
            ...this.causes.map((cause)=>li(cause.message))
        ].join('\n');
    }
    /**
   * @type {API.InvalidCapability | API.EscalatedDelegation | API.DelegationError}
   */ get cause() {
        /* c8 ignore next 9 */ if (this.causes.length !== 1) {
            return this;
        } else {
            const [cause] = this.causes;
            const value = cause.name === 'InvalidClaim' ? cause.cause : cause;
            Object.defineProperties(this, {
                cause: {
                    value
                }
            });
            return value;
        }
    }
}
class SessionEscalation extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {object} source
   * @param {API.Delegation} source.delegation
   * @param {API.Failure} source.cause
   */ constructor({ delegation, cause }){
        super();
        this.name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["the"])('SessionEscalation');
        this.delegation = delegation;
        this.cause = cause;
    }
    describe() {
        const issuer = this.delegation.issuer.did();
        return [
            `Delegation ${this.delegation.cid} issued by ${issuer} has an invalid session`,
            li(this.cause.message)
        ].join('\n');
    }
}
class InvalidSignature extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {API.Delegation} delegation
   * @param {API.Verifier} verifier
   */ constructor(delegation, verifier){
        super();
        this.name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["the"])('InvalidSignature');
        this.delegation = delegation;
        this.verifier = verifier;
    }
    get issuer() {
        return this.delegation.issuer;
    }
    get audience() {
        return this.delegation.audience;
    }
    get key() {
        return this.verifier.toDIDKey();
    }
    describe() {
        const issuer = this.issuer.did();
        const key = this.key;
        return (issuer.startsWith('did:key') ? [
            `Proof ${this.delegation.cid} does not has a valid signature from ${key}`
        ] : [
            `Proof ${this.delegation.cid} issued by ${issuer} does not has a valid signature from ${key}`,
            `  ℹ️ Probably issuer signed with a different key, which got rotated, invalidating delegations that were issued with prior keys`
        ]).join('\n');
    }
}
class UnavailableProof extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {API.UCAN.Link} link
   * @param {Error} [cause]
   */ constructor(link, cause){
        super();
        this.name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["the"])('UnavailableProof');
        this.link = link;
        this.cause = cause;
    }
    describe() {
        return [
            `Linked proof '${this.link}' is not included and could not be resolved`,
            ...this.cause ? [
                li(`Proof resolution failed with: ${this.cause.message}`)
            ] : []
        ].join('\n');
    }
}
class DIDKeyResolutionError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {API.UCAN.DID} did
   * @param {API.Failure} [cause]
   */ constructor(did, cause){
        super();
        this.name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["the"])('DIDKeyResolutionError');
        this.did = did;
        this.cause = cause;
    }
    describe() {
        return `Unable to resolve '${this.did}' key`;
    }
}
class PrincipalAlignmentError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {API.UCAN.Principal} audience
   * @param {API.Delegation} delegation
   */ constructor(audience, delegation){
        super();
        this.name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["the"])('InvalidAudience');
        this.audience = audience;
        this.delegation = delegation;
    }
    describe() {
        return `Delegation audience is '${this.delegation.audience.did()}' instead of '${this.audience.did()}'`;
    }
    toJSON() {
        const { name, audience, message, stack } = this;
        return {
            name,
            audience: audience.did(),
            delegation: {
                audience: this.delegation.audience.did()
            },
            message,
            stack
        };
    }
}
class MalformedCapability extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {API.Capability} capability
   * @param {API.Failure} cause
   */ constructor(capability, cause){
        super();
        this.name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["the"])('MalformedCapability');
        this.capability = capability;
        this.cause = cause;
    }
    describe() {
        return [
            `Encountered malformed '${this.capability.can}' capability: ${format(this.capability)}`,
            li(this.cause.message)
        ].join('\n');
    }
}
class UnknownCapability extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {API.Capability} capability
   */ constructor(capability){
        super();
        this.name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["the"])('UnknownCapability');
        this.capability = capability;
    }
    /* c8 ignore next 3 */ describe() {
        return `Encountered unknown capability: ${format(this.capability)}`;
    }
}
class Expired extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {API.Delegation & { expiration: number }} delegation
   */ constructor(delegation){
        super();
        this.name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["the"])('Expired');
        this.delegation = delegation;
    }
    describe() {
        return `Proof ${this.delegation.cid} has expired on ${new Date(this.delegation.expiration * 1000)}`;
    }
    get expiredAt() {
        return this.delegation.expiration;
    }
    toJSON() {
        const { name, expiredAt, message, stack } = this;
        return {
            name,
            message,
            expiredAt,
            stack
        };
    }
}
class Revoked extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {API.Delegation} delegation
   */ constructor(delegation){
        super();
        this.name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["the"])('Revoked');
        this.delegation = delegation;
    }
    describe() {
        return `Proof ${this.delegation.cid} has been revoked`;
    }
    toJSON() {
        const { name, message, stack } = this;
        return {
            name,
            message,
            stack
        };
    }
}
class NotValidBefore extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {API.Delegation & { notBefore: number }} delegation
   */ constructor(delegation){
        super();
        this.name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["the"])('NotValidBefore');
        this.delegation = delegation;
    }
    describe() {
        return `Proof ${this.delegation.cid} is not valid before ${new Date(this.delegation.notBefore * 1000)}`;
    }
    get validAt() {
        return this.delegation.notBefore;
    }
    toJSON() {
        const { name, validAt, message, stack } = this;
        return {
            name,
            message,
            validAt,
            stack
        };
    }
}
class Unauthorized extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {{
   * capability: API.CapabilityParser
   * delegationErrors: API.DelegationError[]
   * unknownCapabilities: API.Capability[]
   * invalidProofs: API.InvalidProof[]
   * failedProofs: API.InvalidClaim[]
   * }} cause
   */ constructor({ capability, delegationErrors, unknownCapabilities, invalidProofs, failedProofs }){
        super();
        this.name = 'Unauthorized';
        this.capability = capability;
        this.delegationErrors = delegationErrors;
        this.unknownCapabilities = unknownCapabilities;
        this.invalidProofs = invalidProofs;
        this.failedProofs = failedProofs;
    }
    describe() {
        const errors = [
            ...this.failedProofs.map((error)=>li(error.message)),
            ...this.delegationErrors.map((error)=>li(error.message)),
            ...this.invalidProofs.map((error)=>li(error.message))
        ];
        const unknown = this.unknownCapabilities.map((c)=>li(JSON.stringify(c)));
        return [
            `Claim ${this.capability} is not authorized`,
            ...errors.length > 0 ? errors : [
                li(`No matching delegated capability found`)
            ],
            ...unknown.length > 0 ? [
                li(`Encountered unknown capabilities\n${unknown.join('\n')}`)
            ] : []
        ].join('\n');
    }
}
/**
 * @param {unknown} capability
 * @param {string|number} [space]
 */ const format = (capability, space)=>JSON.stringify(capability, (_key, value)=>{
        /* c8 ignore next 2 */ if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isLink"])(value)) {
            return value.toString();
        } else {
            return value;
        }
    }, space);
const indent = (message, indent = '  ')=>`${indent}${message.split('\n').join(`\n${indent}`)}`;
const li = (message)=>indent(`- ${message}`);
}),
"[project]/node_modules/@web3-storage/capabilities/node_modules/@ucanto/validator/src/capability.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "and",
    ()=>and,
    "capability",
    ()=>capability,
    "derive",
    ()=>derive,
    "or",
    ()=>or
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$interface$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/capabilities/node_modules/@ucanto/interface/src/lib.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/capabilities/node_modules/@ucanto/validator/src/util.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/capabilities/node_modules/@ucanto/validator/src/error.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/lib.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$invocation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/invocation.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$delegation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/delegation.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/schema.js [app-ssr] (ecmascript) <export * as Schema>");
;
;
;
;
const capability = ({ derives = defaultDerives, nb = defaultNBSchema, ...etc })=>new Capability({
        derives,
        nb,
        ...etc
    });
const defaultNBSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__["Schema"].struct({});
const or = (left, right)=>new Or(left, right);
const and = (...selectors)=>new And(selectors);
const derive = ({ from, to, derives })=>new Derive(from, to, derives);
/**
 * @template {API.Match} M
 * @implements {API.View<M>}
 */ class View {
    /**
   * @param {API.Source} source
   * @returns {API.MatchResult<M>}
   */ /* c8 ignore next 3 */ match(source) {
        return {
            error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["UnknownCapability"](source.capability)
        };
    }
    /**
   * @param {API.Source[]} capabilities
   * @returns {API.Select<M>}
   */ select(capabilities) {
        return select(this, capabilities);
    }
    /**
   * @template {API.ParsedCapability} U
   * @param {object} source
   * @param {API.TheCapabilityParser<API.DirectMatch<U>>} source.to
   * @param {API.Derives<U, API.InferDeriveProof<M['value']>>} source.derives
   * @returns {API.TheCapabilityParser<API.DerivedMatch<U, M>>}
   */ derive({ derives, to }) {
        return derive({
            derives,
            to,
            from: this
        });
    }
}
/**
 * @template {API.Match} M
 * @implements {API.CapabilityParser<M>}
 * @extends {View<M>}
 */ class Unit extends View {
    /**
   * @template {API.Match} W
   * @param {API.MatchSelector<W>} other
   * @returns {API.CapabilityParser<M | W>}
   */ or(other) {
        return or(this, other);
    }
    /**
   * @template {API.Match} W
   * @param {API.CapabilityParser<W>} other
   * @returns {API.CapabilitiesParser<[M, W]>}
   */ and(other) {
        return and(this, other);
    }
}
/**
 * @template {API.Ability} A
 * @template {API.URI} R
 * @template {API.Caveats} C
 * @implements {API.TheCapabilityParser<API.DirectMatch<API.ParsedCapability<A, R, C>>>}
 * @extends {Unit<API.DirectMatch<API.ParsedCapability<A, R, C>>>}
 */ class Capability extends Unit {
    /**
   * @param {Required<Descriptor<A, R, C>>} descriptor
   */ constructor(descriptor){
        super();
        this.descriptor = descriptor;
        this.schema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__["Schema"].struct({
            can: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__["Schema"].literal(descriptor.can),
            with: descriptor.with,
            nb: descriptor.nb
        });
    }
    /**
   * @param {API.InferCreateOptions<R, C>} options
   */ create(options) {
        const { descriptor, can } = this;
        const decoders = descriptor.nb;
        const data = options.nb || {};
        const resource = descriptor.with.read(options.with);
        if (resource.error) {
            throw Object.assign(new Error(`Invalid 'with' - ${resource.error.message}`), {
                cause: resource
            });
        }
        const nb = descriptor.nb.read(data);
        if (nb.error) {
            throw Object.assign(new Error(`Invalid 'nb' - ${nb.error.message}`), {
                cause: nb
            });
        }
        return createCapability({
            can,
            with: resource.ok,
            nb: nb.ok
        });
    }
    /**
   * @param {API.InferInvokeOptions<R, C>} options
   */ invoke({ with: with_, nb, ...options }) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$invocation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["invoke"])({
            ...options,
            capability: this.create({
                with: with_,
                nb
            })
        });
    }
    /**
   * @param {API.InferDelegationOptions<R, C>} options
   * @returns {Promise<API.Delegation<[API.InferDelegatedCapability<API.ParsedCapability<A, R, C>>]>>}
   */ async delegate({ nb: input = {}, with: with_, ...options }) {
        const { descriptor, can } = this;
        const readers = descriptor.nb;
        const resource = descriptor.with.read(with_);
        if (resource.error) {
            throw Object.assign(new Error(`Invalid 'with' - ${resource.error.message}`), {
                cause: resource
            });
        }
        const nb = descriptor.nb.partial().read(input);
        if (nb.error) {
            throw Object.assign(new Error(`Invalid 'nb' - ${nb.error.message}`), {
                cause: nb
            });
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$delegation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["delegate"])({
            capabilities: [
                createCapability({
                    can,
                    with: resource.ok,
                    nb: nb.ok
                })
            ],
            ...options
        });
    }
    get can() {
        return this.descriptor.can;
    }
    /**
   * @param {API.Source} source
   * @returns {API.MatchResult<API.DirectMatch<API.ParsedCapability<A, R, C>>>}
   */ match(source) {
        const result = parseCapability(this.descriptor, source);
        return result.error ? result : {
            ok: new Match(source, result.ok, this.descriptor)
        };
    }
    toString() {
        return JSON.stringify({
            can: this.descriptor.can
        });
    }
}
/**
 * Normalizes capability by removing empty nb field.
 *
 * @template {API.ParsedCapability} T
 * @param {T} source
 */ const createCapability = ({ can, with: with_, nb })=>/** @type {API.InferCapability<T>} */ ({
        can,
        with: with_,
        ...isEmpty(nb) ? {} : {
            nb
        }
    });
/**
 * @param {object} object
 * @returns {object is {}}
 */ const isEmpty = (object)=>{
    for(const _ in object){
        return false;
    }
    return true;
};
/**
 * @template {API.Match} M
 * @template {API.Match} W
 * @implements {API.CapabilityParser<M|W>}
 * @extends {Unit<M|W>}
 */ class Or extends Unit {
    /**
   * @param {API.Matcher<M>} left
   * @param {API.Matcher<W>} right
   */ constructor(left, right){
        super();
        this.left = left;
        this.right = right;
    }
    /**
   * @param {API.Source} capability
   * @return {API.MatchResult<M|W>}
   */ match(capability) {
        const left = this.left.match(capability);
        if (left.error) {
            const right = this.right.match(capability);
            if (right.error) {
                return right.error.name === 'MalformedCapability' ? right : left;
            } else {
                return right;
            }
        } else {
            return left;
        }
    }
    toString() {
        return `${this.left.toString()}|${this.right.toString()}`;
    }
}
/**
 * @template {API.MatchSelector<API.Match>[]} Selectors
 * @implements {API.CapabilitiesParser<API.InferMembers<Selectors>>}
 * @extends {View<API.Amplify<API.InferMembers<Selectors>>>}
 */ class And extends View {
    /**
   * @param {Selectors} selectors
   */ constructor(selectors){
        super();
        this.selectors = selectors;
    }
    /**
   * @param {API.Source} capability
   * @returns {API.MatchResult<API.Amplify<API.InferMembers<Selectors>>>}
   */ match(capability) {
        const group = [];
        for (const selector of this.selectors){
            const result = selector.match(capability);
            if (result.error) {
                return result;
            } else {
                group.push(result.ok);
            }
        }
        return {
            ok: new AndMatch(group)
        };
    }
    /**
   * @param {API.Source[]} capabilities
   */ select(capabilities) {
        return selectGroup(this, capabilities);
    }
    /**
   * @template E
   * @template {API.Match} X
   * @param {API.MatchSelector<API.Match<E, X>>} other
   * @returns {API.CapabilitiesParser<[...API.InferMembers<Selectors>, API.Match<E, X>]>}
   */ and(other) {
        return new And([
            ...this.selectors,
            other
        ]);
    }
    toString() {
        return `[${this.selectors.map(String).join(', ')}]`;
    }
}
/**
 * @template {API.ParsedCapability} T
 * @template {API.Match} M
 * @implements {API.TheCapabilityParser<API.DerivedMatch<T, M>>}
 * @extends {Unit<API.DerivedMatch<T, M>>}
 */ class Derive extends Unit {
    /**
   * @param {API.MatchSelector<M>} from
   * @param {API.TheCapabilityParser<API.DirectMatch<T>>} to
   * @param {API.Derives<T, API.InferDeriveProof<M['value']>>} derives
   */ constructor(from, to, derives){
        super();
        this.from = from;
        this.to = to;
        this.derives = derives;
    }
    /**
   * @type {typeof this.to['create']}
   */ create(options) {
        return this.to.create(options);
    }
    /**
   * @type {typeof this.to['invoke']}
   */ invoke(options) {
        return this.to.invoke(options);
    }
    /**
   * @type {typeof this.to['delegate']}
   */ delegate(options) {
        return this.to.delegate(options);
    }
    get can() {
        return this.to.can;
    }
    /**
   * @param {API.Source} capability
   * @returns {API.MatchResult<API.DerivedMatch<T, M>>}
   */ match(capability) {
        const match = this.to.match(capability);
        if (match.error) {
            return match;
        } else {
            return {
                ok: new DerivedMatch(match.ok, this.from, this.derives)
            };
        }
    }
    toString() {
        return this.to.toString();
    }
}
/**
 * @template {API.Ability} A
 * @template {API.URI} R
 * @template {API.Caveats} C
 * @implements {API.DirectMatch<API.ParsedCapability<A, R, C>>}
 */ class Match {
    /**
   * @param {API.Source} source
   * @param {API.ParsedCapability<A, R, C>} value
   * @param {Required<Descriptor<A, R, C>>} descriptor
   */ constructor(source, value, descriptor){
        this.source = [
            source
        ];
        this.value = value;
        this.descriptor = descriptor;
    }
    get can() {
        return this.value.can;
    }
    get proofs() {
        const proofs = [
            this.source[0].delegation
        ];
        Object.defineProperties(this, {
            proofs: {
                value: proofs
            }
        });
        return proofs;
    }
    /**
   * @param {API.CanIssue} context
   * @returns {API.DirectMatch<API.ParsedCapability<A, R, C>>|null}
   */ prune(context) {
        if (context.canIssue(this.value, this.source[0].delegation.issuer.did())) {
            return null;
        } else {
            return this;
        }
    }
    /**
   * @param {API.Source[]} capabilities
   * @returns {API.Select<API.DirectMatch<API.ParsedCapability<A, R, C>>>}
   */ select(capabilities) {
        const unknown = [];
        const errors = [];
        const matches = [];
        for (const capability of capabilities){
            const result = resolveCapability(this.descriptor, this.value, capability);
            if (result.ok) {
                const claim = this.descriptor.derives(this.value, result.ok);
                if (claim.error) {
                    errors.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["DelegationError"]([
                        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["EscalatedCapability"](this.value, result.ok, claim.error)
                    ], this));
                } else {
                    matches.push(new Match(capability, result.ok, this.descriptor));
                }
            } else {
                switch(result.error.name){
                    case 'UnknownCapability':
                        unknown.push(result.error.capability);
                        break;
                    case 'MalformedCapability':
                    default:
                        errors.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["DelegationError"]([
                            result.error
                        ], this));
                }
            }
        }
        return {
            matches,
            unknown,
            errors
        };
    }
    toString() {
        const { nb } = this.value;
        return JSON.stringify({
            can: this.descriptor.can,
            with: this.value.with,
            nb: nb && Object.keys(nb).length > 0 ? nb : undefined
        });
    }
}
/**
 * @template {API.ParsedCapability} T
 * @template {API.Match} M
 * @implements {API.DerivedMatch<T, M>}
 */ class DerivedMatch {
    /**
   * @param {API.DirectMatch<T>} selected
   * @param {API.MatchSelector<M>} from
   * @param {API.Derives<T, API.InferDeriveProof<M['value']>>} derives
   */ constructor(selected, from, derives){
        this.selected = selected;
        this.from = from;
        this.derives = derives;
    }
    get can() {
        return this.value.can;
    }
    get source() {
        return this.selected.source;
    }
    get proofs() {
        const proofs = [];
        for (const { delegation } of this.selected.source){
            proofs.push(delegation);
        }
        Object.defineProperties(this, {
            proofs: {
                value: proofs
            }
        });
        return proofs;
    }
    get value() {
        return this.selected.value;
    }
    /**
   * @param {API.CanIssue} context
   */ prune(context) {
        const selected = this.selected.prune(context);
        return selected ? new DerivedMatch(selected, this.from, this.derives) : null;
    }
    /**
   * @param {API.Source[]} capabilities
   */ select(capabilities) {
        const { derives, selected, from } = this;
        const { value } = selected;
        const direct = selected.select(capabilities);
        const derived = from.select(capabilities);
        const matches = [];
        const errors = [];
        for (const match of derived.matches){
            // If capability can not be derived it escalates
            const result = derives(value, match.value);
            if (result.error) {
                errors.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["DelegationError"]([
                    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["EscalatedCapability"](value, match.value, result.error)
                ], this));
            } else {
                matches.push(match);
            }
        }
        return {
            unknown: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["intersection"])(direct.unknown, derived.unknown),
            errors: [
                ...errors,
                ...direct.errors,
                ...derived.errors.map((error)=>new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["DelegationError"]([
                        error
                    ], this))
            ],
            matches: [
                ...direct.matches.map((match)=>new DerivedMatch(match, from, derives)),
                ...matches
            ]
        };
    }
    toString() {
        return this.selected.toString();
    }
}
/**
 * @template {API.MatchSelector<API.Match>[]} Selectors
 * @implements {API.Amplify<API.InferMembers<Selectors>>}
 */ class AndMatch {
    /**
   * @param {API.Match[]} matches
   */ constructor(matches){
        this.matches = matches;
    }
    get selectors() {
        return this.matches;
    }
    /**
   * @returns {API.Source[]}
   */ get source() {
        const source = [];
        for (const match of this.matches){
            source.push(...match.source);
        }
        Object.defineProperties(this, {
            source: {
                value: source
            }
        });
        return source;
    }
    /**
   * @param {API.CanIssue} context
   */ prune(context) {
        const matches = [];
        for (const match of this.matches){
            const pruned = match.prune(context);
            if (pruned) {
                matches.push(pruned);
            }
        }
        return matches.length === 0 ? null : new AndMatch(matches);
    }
    get proofs() {
        const proofs = [];
        for (const { delegation } of this.source){
            proofs.push(delegation);
        }
        Object.defineProperties(this, {
            proofs: {
                value: proofs
            }
        });
        return proofs;
    }
    /**
   * @type {API.InferValue<API.InferMembers<Selectors>>}
   */ get value() {
        const value = [];
        for (const match of this.matches){
            value.push(match.value);
        }
        Object.defineProperties(this, {
            value: {
                value
            }
        });
        return value;
    }
    /**
   * @param {API.Source[]} capabilities
   */ select(capabilities) {
        return selectGroup(this, capabilities);
    }
    toString() {
        return `[${this.matches.map((match)=>match.toString()).join(', ')}]`;
    }
}
/**
 * Resolves ability `pattern` of the delegated capability from the ability
 * of the claimed capability. If pattern matches returns claimed ability
 * otherwise returns given `fallback`.
 *
 * @example
 * ```js
 * resolveAbility('*', 'store/add', null) // => 'store/add'
 * resolveAbility('store/*', 'store/add', null) // => 'store/add'
 * resolveAbility('store/add', 'store/add', null) // => 'store/add'
 * resolveAbility('store/', 'store/add', null) // => null
 * resolveAbility('store/a*', 'store/add', null) // => null
 * resolveAbility('store/list', 'store/add', null) // => null
 * ```
 *
 * @template {API.Ability} T
 * @template U
 * @param {string} pattern
 * @param {T} can
 * @param {U} fallback
 * @returns {T|U}
 */ const resolveAbility = (pattern, can, fallback)=>{
    switch(pattern){
        case can:
        case '*':
            return can;
        default:
            return pattern.endsWith('/*') && can.startsWith(pattern.slice(0, -1)) ? can : fallback;
    }
};
/**
 * Resolves `source` resource of the delegated capability from the resource
 * `uri` of the claimed capability. If `source` is `"ucan:*""` or matches `uri`
 * then it returns `uri` back otherwise it returns `fallback`.
 *
 * @example
 * ```js
 * resolveResource('ucan:*', 'did:key:zAlice', null) // => 'did:key:zAlice'
 * resolveAbility('ucan:*', 'https://example.com', null) // => 'https://example.com'
 * resolveAbility('did:*', 'did:key:zAlice', null) // => null
 * resolveAbility('did:key:zAlice', 'did:key:zAlice', null) // => did:key:zAlice
 * ```
 * @template {string} T
 * @template U
 * @param {T} uri
 * @param {string} source
 * @param {U} fallback
 * @returns {T|U}
 */ const resolveResource = (source, uri, fallback)=>{
    switch(source){
        case uri:
        case 'ucan:*':
            return uri;
        default:
            return fallback;
    }
};
/**
 * Parses capability from the `source` using a provided `parser`.
 *
 * @template {API.Ability} A
 * @template {API.URI} R
 * @template {API.Caveats} C
 * @param {Required<Descriptor<A, R, C>>} descriptor
 * @param {API.Source} source
 * @returns {API.Result<API.ParsedCapability<A, R, C>, API.InvalidCapability>}
 */ const parseCapability = (descriptor, source)=>{
    const { delegation } = source;
    const capability = source.capability;
    if (descriptor.can !== capability.can) {
        return {
            error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["UnknownCapability"](capability)
        };
    }
    const uri = descriptor.with.read(capability.with);
    if (uri.error) {
        return {
            error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["MalformedCapability"](capability, uri.error)
        };
    }
    const nb = descriptor.nb.read(capability.nb || {});
    if (nb.error) {
        return {
            error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["MalformedCapability"](capability, nb.error)
        };
    }
    return {
        ok: new CapabilityView(descriptor.can, uri.ok, nb.ok, delegation)
    };
};
/**
 * Resolves delegated capability `source` from the `claimed` capability using
 * provided capability `parser`. It is similar to `parseCapability` except
 * `source` here is treated as capability pattern which is matched against the
 * `claimed` capability. This means we resolve `can` and `with` fields from the
 * `claimed` capability and inherit all missing `nb` fields from the claimed
 * capability.
 *
 * @template {API.Ability} A
 * @template {API.URI} R
 * @template {API.Caveats} C
 * @param {Required<Descriptor<A, R, C>>} descriptor
 * @param {API.ParsedCapability<A, R, C>} claimed
 * @param {API.Source} source
 * @returns {API.Result<API.ParsedCapability<A, R, C>, API.InvalidCapability>}
 */ const resolveCapability = (descriptor, claimed, { capability, delegation })=>{
    const can = resolveAbility(capability.can, claimed.can, null);
    if (can == null) {
        return {
            error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["UnknownCapability"](capability)
        };
    }
    const resource = resolveResource(capability.with, claimed.with, capability.with);
    const uri = descriptor.with.read(resource);
    if (uri.error) {
        return {
            error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["MalformedCapability"](capability, uri.error)
        };
    }
    const nb = descriptor.nb.read({
        ...claimed.nb,
        ...capability.nb
    });
    if (nb.error) {
        return {
            error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["MalformedCapability"](capability, nb.error)
        };
    }
    return {
        ok: new CapabilityView(can, uri.ok, nb.ok, delegation)
    };
};
/**
 * @template {API.Ability} A
 * @template {API.URI} R
 * @template C
 */ class CapabilityView {
    /**
   * @param {A} can
   * @param {R} with_
   * @param {C} nb
   * @param {API.Delegation} delegation
   */ constructor(can, with_, nb, delegation){
        this.can = can;
        this.with = with_;
        this.delegation = delegation;
        this.nb = nb;
    }
}
/**
 * @template {API.Match} M
 * @param {API.Matcher<M>} matcher
 * @param {API.Source[]} capabilities
 * @returns {API.Select<M>}
 */ const select = (matcher, capabilities)=>{
    const unknown = [];
    const matches = [];
    const errors = [];
    for (const capability of capabilities){
        const result = matcher.match(capability);
        if (result.error) {
            switch(result.error.name){
                case 'UnknownCapability':
                    unknown.push(result.error.capability);
                    break;
                case 'MalformedCapability':
                default:
                    errors.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["DelegationError"]([
                        result.error
                    ], result.error.capability));
            }
        } else {
            matches.push(result.ok);
        }
    }
    return {
        matches,
        errors,
        unknown
    };
};
/**
 * @template {API.Selector<API.Match>[]} S
 * @param {{selectors:S}} self
 * @param {API.Source[]} capabilities
 */ const selectGroup = (self, capabilities)=>{
    let unknown;
    const data = [];
    const errors = [];
    for (const selector of self.selectors){
        const selected = selector.select(capabilities);
        unknown = unknown ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["intersection"])(unknown, selected.unknown) : selected.unknown;
        for (const error of selected.errors){
            errors.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["DelegationError"]([
                error
            ], self));
        }
        data.push(selected.matches);
    }
    const matches = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["combine"])(data).map((group)=>new AndMatch(group));
    return {
        unknown: /* c8 ignore next */ unknown || [],
        errors,
        matches
    };
};
/**
 * @template {API.ParsedCapability} T
 * @template {API.ParsedCapability} U
 * @param {T} claimed
 * @param {U} delegated
 * @return {API.Result<true, API.Failure>}
 */ const defaultDerives = (claimed, delegated)=>{
    if (delegated.with.endsWith('*')) {
        if (!claimed.with.startsWith(delegated.with.slice(0, -1))) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__["Schema"].error(`Resource ${claimed.with} does not match delegated ${delegated.with} `);
        }
    } else if (delegated.with !== claimed.with) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__["Schema"].error(`Resource ${claimed.with} is not contained by ${delegated.with}`);
    }
    /* c8 ignore next 2 */ const caveats = delegated.nb || {};
    const nb = claimed.nb || {};
    const kv = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["entries"])(caveats);
    for (const [name, value] of kv){
        if (nb[name] != value) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__["Schema"].error(`${String(name)}: ${nb[name]} violates ${value}`);
        }
    }
    return {
        ok: true
    };
};
}),
"[project]/node_modules/@web3-storage/capabilities/node_modules/@ucanto/validator/src/authorization.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "create",
    ()=>create,
    "iterate",
    ()=>iterate
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$interface$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/capabilities/node_modules/@ucanto/interface/src/lib.js [app-ssr] (ecmascript)");
;
/**
 * @template {API.ParsedCapability} C
 * @implements {API.Authorization<C>}
 */ class Authorization {
    /**
   * @param {API.Match<C>} match
   * @param {API.Authorization<API.ParsedCapability>[]} proofs
   */ constructor(match, proofs){
        this.match = match;
        this.proofs = proofs;
    }
    get capability() {
        return this.match.value;
    }
    get delegation() {
        return this.match.source[0].delegation;
    }
    get issuer() {
        return this.delegation.issuer;
    }
    get audience() {
        return this.delegation.audience;
    }
}
const create = (match, proofs = [])=>new Authorization(match, proofs);
const iterate = function*({ delegation, proofs }) {
    yield delegation.cid;
    for (const proof of proofs){
        yield* iterate(proof);
    }
};
}),
"[project]/node_modules/@web3-storage/capabilities/node_modules/@ucanto/validator/src/lib.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "access",
    ()=>access,
    "authorize",
    ()=>authorize,
    "claim",
    ()=>claim
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$interface$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/capabilities/node_modules/@ucanto/interface/src/lib.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/lib.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$delegation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/delegation.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__UCAN$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/lib.js [app-ssr] (ecmascript) <export * as UCAN>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/result.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$capability$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/capabilities/node_modules/@ucanto/validator/src/capability.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/schema.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/schema.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/schema/schema.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2f$link$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__$3c$export__match__as__link$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/schema/link.js [app-ssr] (ecmascript) <locals> <export match as link>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$authorization$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/capabilities/node_modules/@ucanto/validator/src/authorization.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/capabilities/node_modules/@ucanto/validator/src/error.js [app-ssr] (ecmascript) <locals>");
;
;
;
;
;
;
;
;
;
/**
 * @param {UCAN.Link} proof
 * @returns {{error:API.UnavailableProof}}
 */ const unavailable = (proof)=>({
        error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["UnavailableProof"](proof)
    });
/**
 *
 * @param {UCAN.DID} did
 * @returns {{error:API.DIDKeyResolutionError}}
 */ const failDIDKeyResolution = (did)=>({
        error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["DIDKeyResolutionError"](did)
    });
/**
 * @param {Required<API.ClaimOptions>} config
 * @param {API.Match<unknown, API.Match>} match
 */ const resolveMatch = async (match, config)=>{
    const promises = [];
    const includes = new Set();
    for (const source of match.source){
        const id = source.delegation.cid.toString();
        if (!includes.has(id)) {
            promises.push(await resolveSources(source, config));
        }
    }
    const groups = await Promise.all(promises);
    const sources = [];
    const errors = [];
    for (const group of groups){
        sources.push(...group.sources);
        errors.push(...group.errors);
    }
    return {
        sources,
        errors
    };
};
/**
 * Takes `proofs` from the delegation which may contain `Delegation` or a link
 * to one and attempts to resolve links by side loading them. Returns set of
 * resolved `Delegation`s and errors for the proofs that could not be resolved.
 *
 * @param {API.Proof[]} proofs
 * @param {Required<API.ProofResolver>} config
 */ const resolveProofs = async (proofs, config)=>{
    /** @type {API.Delegation[]} */ const delegations = [];
    /** @type {API.UnavailableProof[]} */ const errors = [];
    const promises = [];
    for (const proof of proofs){
        // If it is a delegation we can just add it to the resolved set.
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$delegation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isDelegation"])(proof)) {
            delegations.push(proof);
        } else {
            promises.push(new Promise(async (resolve)=>{
                // config.resolve is not supposed to throw, but we catch it just in
                // case it does and consider proof resolution failed.
                try {
                    const result = await config.resolve(proof);
                    if (result.error) {
                        errors.push(result.error);
                    } else {
                        delegations.push(result.ok);
                    }
                } catch (error) {
                    errors.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["UnavailableProof"](proof, error));
                }
                // we don't care about the result, we just need to signal that we are
                // done with this promise.
                resolve(null);
            }));
        }
    }
    // Wait for all the promises to resolve. At this point we have collected all
    // the resolved delegations and errors.
    await Promise.all(promises);
    return {
        delegations,
        errors
    };
};
/**
 * Takes a delegation source and attempts to resolve all the linked proofs.
 *
 * @param {API.Source} from
 * @param {Required<API.ClaimOptions>} config
 * @return {Promise<{sources:API.Source[], errors:ProofError[]}>}
 */ const resolveSources = async ({ delegation }, config)=>{
    const errors = [];
    const sources = [];
    const proofs = [];
    // First we attempt to resolve all the linked proofs.
    const { delegations, errors: failedProofs } = await resolveProofs(delegation.proofs, config);
    // All the proofs that failed to resolve are saved as proof errors.
    for (const error of failedProofs){
        errors.push(new ProofError(error.link, error));
    }
    // All the proofs that resolved are checked for principal alignment. Ones that
    // do not align are saved as proof errors.
    for (const proof of delegations){
        // If proof does not delegate to a matching audience save an proof error.
        if (delegation.issuer.did() !== proof.audience.did()) {
            errors.push(new ProofError(proof.cid, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["PrincipalAlignmentError"](delegation.issuer, proof)));
        } else {
            proofs.push(proof);
        }
    }
    // In the second pass we attempt to proofs that were resolved and are aligned.
    for (const proof of proofs){
        // If proof is not valid (expired, not active yet or has incorrect
        // signature) save a corresponding proof error.
        const validation = await validate(proof, proofs, config);
        if (validation.error) {
            errors.push(new ProofError(proof.cid, validation.error));
        } else {
            // otherwise create source objects for it's capabilities, so we could
            // track which proof in which capability the are from.
            for (const capability of proof.capabilities){
                sources.push({
                    capability,
                    delegation: proof
                });
            }
        }
    }
    return {
        sources,
        errors
    };
};
/**
 * @param {API.ParsedCapability} capability
 * @param {API.DID} issuer
 */ const isSelfIssued = (capability, issuer)=>capability.with === issuer;
const access = async (invocation, { capability, ...config })=>claim(capability, [
        invocation
    ], config);
const claim = async (capability, proofs, { authority, principal, validateAuthorization, resolveDIDKey = failDIDKeyResolution, canIssue = isSelfIssued, resolve = unavailable, proofs: localProofs = [] })=>{
    const config = {
        canIssue,
        resolve,
        principal,
        capability,
        authority,
        validateAuthorization,
        resolveDIDKey,
        proofs: localProofs
    };
    const invalidProofs = [];
    /** @type {API.Source[]} */ const sources = [];
    const { delegations, errors } = await resolveProofs(proofs, config);
    invalidProofs.push(...errors);
    for (const proof of delegations){
        // Validate each proof if valid add ech capability to the list of sources.
        // otherwise collect the error.
        const validation = await validate(proof, delegations, config);
        if (validation.ok) {
            for (const capability of validation.ok.capabilities.values()){
                sources.push({
                    capability,
                    delegation: validation.ok
                });
            }
        } else {
            invalidProofs.push(validation.error);
        }
    }
    // look for the matching capability
    const selection = capability.select(sources);
    const { errors: delegationErrors, unknown: unknownCapabilities } = selection;
    const failedProofs = [];
    for (const matched of selection.matches){
        const selector = matched.prune(config);
        if (selector == null) {
            const authorization = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$authorization$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["create"](matched, []);
            const result = await validateAuthorization(authorization);
            if (result.error) {
                invalidProofs.push(result.error);
            } else {
                return {
                    ok: authorization
                };
            }
        } else {
            const result = await authorize(selector, config);
            if (result.error) {
                failedProofs.push(result.error);
            } else {
                const authorization = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$authorization$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["create"](matched, [
                    result.ok
                ]);
                const approval = await validateAuthorization(authorization);
                if (approval.error) {
                    invalidProofs.push(approval.error);
                } else {
                    return {
                        ok: authorization
                    };
                }
            }
        }
    }
    return {
        error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Unauthorized"]({
            capability,
            delegationErrors,
            unknownCapabilities,
            invalidProofs,
            failedProofs
        })
    };
};
const authorize = async (match, config)=>{
    // load proofs from all delegations
    const { sources, errors: invalidProofs } = await resolveMatch(match, config);
    const selection = match.select(sources);
    const { errors: delegationErrors, unknown: unknownCapabilities } = selection;
    const failedProofs = [];
    for (const matched of selection.matches){
        const selector = matched.prune(config);
        if (selector == null) {
            return {
                ok: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$authorization$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["create"](// @ts-expect-error - it may not be a parsed capability but rather a
                // group of capabilities but we can deal with that in the future.
                matched, [])
            };
        } else {
            const result = await authorize(selector, config);
            if (result.error) {
                failedProofs.push(result.error);
            } else {
                return {
                    ok: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$authorization$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["create"](// @ts-expect-error - it may not be a parsed capability but rather a
                    // group of capabilities but we can deal with that in the future.
                    matched, [
                        result.ok
                    ])
                };
            }
        }
    }
    return {
        error: new InvalidClaim({
            match,
            delegationErrors,
            unknownCapabilities,
            invalidProofs,
            failedProofs
        })
    };
};
class ProofError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {API.UCANLink} proof
   * @param {API.Failure} cause
   */ constructor(proof, cause){
        super();
        this.name = 'ProofError';
        this.proof = proof;
        this.cause = cause;
    }
    describe() {
        return [
            `Capability can not be derived from prf:${this.proof} because:`,
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["li"])(this.cause.message)
        ].join(`\n`);
    }
}
/**
 * @implements {API.InvalidClaim}
 */ class InvalidClaim extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {{
   * match: API.Match
   * delegationErrors: API.DelegationError[]
   * unknownCapabilities: API.Capability[]
   * invalidProofs: ProofError[]
   * failedProofs: API.InvalidClaim[]
   * }} info
   */ constructor(info){
        super();
        this.info = info;
        this.name = 'InvalidClaim';
    }
    get issuer() {
        return this.delegation.issuer;
    }
    get delegation() {
        return this.info.match.source[0].delegation;
    }
    describe() {
        const errors = [
            ...this.info.failedProofs.map((error)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["li"])(error.message)),
            ...this.info.delegationErrors.map((error)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["li"])(error.message)),
            ...this.info.invalidProofs.map((error)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["li"])(error.message))
        ];
        const unknown = this.info.unknownCapabilities.map((c)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["li"])(JSON.stringify(c)));
        return [
            `Capability ${this.info.match} is not authorized because:`,
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["li"])(`Capability can not be (self) issued by '${this.issuer.did()}'`),
            ...errors.length > 0 ? errors : [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["li"])(`Delegated capability not found`)
            ],
            ...unknown.length > 0 ? [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["li"])(`Encountered unknown capabilities\n${unknown.join('\n')}`)
            ] : []
        ].join('\n');
    }
}
/**
 * Validate a delegation to check it is within the time bound and that it is
 * authorized by the issuer.
 *
 * @template {API.Delegation} T
 * @param {T} delegation
 * @param {API.Delegation[]} proofs
 * @param {Required<API.ClaimOptions>} config
 * @returns {Promise<API.Result<T, API.InvalidProof|API.SessionEscalation|API.DIDKeyResolutionError>>}
 */ const validate = async (delegation, proofs, config)=>{
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__UCAN$3e$__["UCAN"].isExpired(delegation.data)) {
        return {
            error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Expired"](delegation)
        };
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__UCAN$3e$__["UCAN"].isTooEarly(delegation.data)) {
        return {
            error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["NotValidBefore"](delegation)
        };
    }
    return await verifyAuthorization(delegation, proofs, config);
};
/**
 * Verifies that delegation has been authorized by the issuer. If issued by the
 * did:key principal checks that the signature is valid. If issued by the root
 * authority checks that the signature is valid. If issued by the principal
 * identified by other DID method attempts to resolve a valid `ucan/attest`
 * attestation from the authority, if attestation is not found falls back to
 * resolving did:key for the issuer and verifying its signature.
 *
 * @template {API.Delegation} T
 * @param {T} delegation
 * @param {API.Delegation[]} proofs
 * @param {Required<API.ClaimOptions>} config
 * @returns {Promise<API.Result<T, API.InvalidSignature|API.SessionEscalation|API.DIDKeyResolutionError>>}
 */ const verifyAuthorization = async (delegation, proofs, config)=>{
    const issuer = delegation.issuer.did();
    // If the issuer is a did:key we just verify a signature
    if (issuer.startsWith('did:key:')) {
        return verifySignature(delegation, config.principal.parse(issuer));
    } else if (issuer === config.authority.did()) {
        return verifySignature(delegation, config.authority);
    } else {
        // If issuer is not a did:key principal nor configured authority, we
        // attempt to resolve embedded authorization session from the authority.
        const session = await verifySession(delegation, proofs, config);
        // If we have valid session we consider authorization valid
        if (session.ok) {
            return {
                ok: delegation
            };
        } else if (session.error.failedProofs.length > 0) {
            return {
                error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["SessionEscalation"]({
                    delegation,
                    cause: session.error
                })
            };
        } else {
            const verifier = await config.resolveDIDKey(issuer);
            if (verifier.error) {
                return verifier;
            } else {
                return verifySignature(delegation, config.principal.parse(verifier.ok).withDID(issuer));
            }
        }
    }
};
/**
 * @template {API.Delegation} T
 * @param {T} delegation
 * @param {API.Verifier} verifier
 * @returns {Promise<API.Result<T, API.InvalidSignature|API.DIDKeyResolutionError>>}
 */ const verifySignature = async (delegation, verifier)=>{
    const valid = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__UCAN$3e$__["UCAN"].verifySignature(delegation.data, verifier);
    return valid ? {
        ok: delegation
    } : {
        error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["InvalidSignature"](delegation, verifier)
    };
};
/**
 * Attempts to find an authorization session - an `ucan/attest` capability
 * delegation where `with` matches `config.authority` and `nb.proof`
 * matches given delegation.
 * @see https://github.com/web3-storage/specs/blob/feat/auth+account/w3-session.md#authorization-session
 *
 * @param {API.Delegation} delegation
 * @param {API.Delegation[]} proofs
 * @param {Required<API.ClaimOptions>} config
 */ const verifySession = async (delegation, proofs, config)=>{
    // Recognize attestations from all authorized principals, not just authority
    const withSchemas = config.proofs.filter((p)=>p.capabilities[0].can === 'ucan/attest' && p.capabilities[0].with === config.authority.did()).map((p)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["literal"](p.audience.did()));
    const withSchema = withSchemas.length ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["union"]([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["literal"](config.authority.did()),
        ...withSchemas
    ]) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["literal"](config.authority.did());
    // Create a schema that will match an authorization for this exact delegation
    const attestation = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$capabilities$2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$capability$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["capability"])({
        with: withSchema,
        can: 'ucan/attest',
        nb: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["struct"]({
            proof: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2f$link$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__$3c$export__match__as__link$3e$__["link"](delegation.cid)
        })
    });
    return await claim(attestation, proofs// We only consider attestations otherwise we will end up doing an
    // exponential scan if there are other proofs that require attestations.
    .filter(isAttestation)// Also filter any proofs that _are_ the delegation we're verifying so
    // we don't recurse indefinitely.
    .filter((p)=>p.cid.toString() !== delegation.cid.toString()), config);
};
/**
 * Checks if the delegation is an attestation.
 *
 * @param {API.Delegation} proof
 */ const isAttestation = (proof)=>proof.capabilities[0]?.can === 'ucan/attest';
}),
"[project]/node_modules/@ucanto/validator/src/util.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @template {string|boolean|number|[unknown, ...unknown[]]} T
 * @param {T} value
 * @returns {T}
 */ __turbopack_context__.s([
    "combine",
    ()=>combine,
    "entries",
    ()=>entries,
    "intersection",
    ()=>intersection,
    "the",
    ()=>the
]);
const the = (value)=>value;
const entries = (object)=>Object.entries(object);
const combine = ([first, ...rest])=>{
    const results = first.map((value)=>[
            value
        ]);
    for (const values of rest){
        const tuples = results.splice(0);
        for (const value of values){
            for (const tuple of tuples){
                results.push([
                    ...tuple,
                    value
                ]);
            }
        }
    }
    return results;
};
const intersection = (left, right)=>{
    const [result, other] = left.length < right.length ? [
        new Set(left),
        new Set(right)
    ] : [
        new Set(right),
        new Set(left)
    ];
    for (const item of result){
        if (!other.has(item)) {
            result.delete(item);
        }
    }
    return [
        ...result
    ];
};
}),
"[project]/node_modules/@ucanto/validator/src/error.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DIDKeyResolutionError",
    ()=>DIDKeyResolutionError,
    "DelegationError",
    ()=>DelegationError,
    "EscalatedCapability",
    ()=>EscalatedCapability,
    "Expired",
    ()=>Expired,
    "InvalidSignature",
    ()=>InvalidSignature,
    "MalformedCapability",
    ()=>MalformedCapability,
    "NotValidBefore",
    ()=>NotValidBefore,
    "PrincipalAlignmentError",
    ()=>PrincipalAlignmentError,
    "Revoked",
    ()=>Revoked,
    "SessionEscalation",
    ()=>SessionEscalation,
    "Unauthorized",
    ()=>Unauthorized,
    "UnavailableProof",
    ()=>UnavailableProof,
    "UnknownCapability",
    ()=>UnknownCapability,
    "indent",
    ()=>indent,
    "li",
    ()=>li
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$interface$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/interface/src/lib.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/validator/src/util.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$link$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/link.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/node_modules/multiformats/dist/src/link.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/result.js [app-ssr] (ecmascript)");
;
;
;
;
;
class EscalatedCapability extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {API.ParsedCapability} claimed
   * @param {object} delegated
   * @param {API.Failure} cause
   */ constructor(claimed, delegated, cause){
        super();
        this.claimed = claimed;
        this.delegated = delegated;
        this.cause = cause;
        this.name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["the"])('EscalatedCapability');
    }
    describe() {
        return `Constraint violation: ${this.cause.message}`;
    }
}
class DelegationError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {(API.InvalidCapability | API.EscalatedDelegation | API.DelegationError)[]} causes
   * @param {object} context
   */ constructor(causes, context){
        super();
        this.name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["the"])('InvalidClaim');
        this.causes = causes;
        this.context = context;
    }
    describe() {
        return [
            `Can not derive ${this.context} from delegated capabilities:`,
            ...this.causes.map((cause)=>li(cause.message))
        ].join('\n');
    }
    /**
   * @type {API.InvalidCapability | API.EscalatedDelegation | API.DelegationError}
   */ get cause() {
        /* c8 ignore next 9 */ if (this.causes.length !== 1) {
            return this;
        } else {
            const [cause] = this.causes;
            const value = cause.name === 'InvalidClaim' ? cause.cause : cause;
            Object.defineProperties(this, {
                cause: {
                    value
                }
            });
            return value;
        }
    }
}
class SessionEscalation extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {object} source
   * @param {API.Delegation} source.delegation
   * @param {API.Failure} source.cause
   */ constructor({ delegation, cause }){
        super();
        this.name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["the"])('SessionEscalation');
        this.delegation = delegation;
        this.cause = cause;
    }
    describe() {
        const issuer = this.delegation.issuer.did();
        return [
            `Delegation ${this.delegation.cid} issued by ${issuer} has an invalid session`,
            li(this.cause.message)
        ].join('\n');
    }
}
class InvalidSignature extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {API.Delegation} delegation
   * @param {API.Verifier} verifier
   */ constructor(delegation, verifier){
        super();
        this.name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["the"])('InvalidSignature');
        this.delegation = delegation;
        this.verifier = verifier;
    }
    get issuer() {
        return this.delegation.issuer;
    }
    get audience() {
        return this.delegation.audience;
    }
    get key() {
        return this.verifier.toDIDKey();
    }
    describe() {
        const issuer = this.issuer.did();
        const key = this.key;
        return (issuer.startsWith('did:key') ? [
            `Proof ${this.delegation.cid} does not has a valid signature from ${key}`
        ] : [
            `Proof ${this.delegation.cid} issued by ${issuer} does not has a valid signature from ${key}`,
            `  ℹ️ Probably issuer signed with a different key, which got rotated, invalidating delegations that were issued with prior keys`
        ]).join('\n');
    }
}
class UnavailableProof extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {API.UCAN.Link} link
   * @param {Error} [cause]
   */ constructor(link, cause){
        super();
        this.name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["the"])('UnavailableProof');
        this.link = link;
        this.cause = cause;
    }
    describe() {
        return [
            `Linked proof '${this.link}' is not included and could not be resolved`,
            ...this.cause ? [
                li(`Proof resolution failed with: ${this.cause.message}`)
            ] : []
        ].join('\n');
    }
}
class DIDKeyResolutionError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {API.UCAN.DID} did
   * @param {API.Failure} [cause]
   */ constructor(did, cause){
        super();
        this.name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["the"])('DIDKeyResolutionError');
        this.did = did;
        this.cause = cause;
    }
    describe() {
        return `Unable to resolve '${this.did}' key`;
    }
}
class PrincipalAlignmentError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {API.UCAN.Principal} audience
   * @param {API.Delegation} delegation
   */ constructor(audience, delegation){
        super();
        this.name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["the"])('InvalidAudience');
        this.audience = audience;
        this.delegation = delegation;
    }
    describe() {
        return `Delegation audience is '${this.delegation.audience.did()}' instead of '${this.audience.did()}'`;
    }
    toJSON() {
        const { name, audience, message, stack } = this;
        return {
            name,
            audience: audience.did(),
            delegation: {
                audience: this.delegation.audience.did()
            },
            message,
            stack
        };
    }
}
class MalformedCapability extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {API.Capability} capability
   * @param {API.Failure} cause
   */ constructor(capability, cause){
        super();
        this.name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["the"])('MalformedCapability');
        this.capability = capability;
        this.cause = cause;
    }
    describe() {
        return [
            `Encountered malformed '${this.capability.can}' capability: ${format(this.capability)}`,
            li(this.cause.message)
        ].join('\n');
    }
}
class UnknownCapability extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {API.Capability} capability
   */ constructor(capability){
        super();
        this.name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["the"])('UnknownCapability');
        this.capability = capability;
    }
    /* c8 ignore next 3 */ describe() {
        return `Encountered unknown capability: ${format(this.capability)}`;
    }
}
class Expired extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {API.Delegation & { expiration: number }} delegation
   */ constructor(delegation){
        super();
        this.name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["the"])('Expired');
        this.delegation = delegation;
    }
    describe() {
        return `Proof ${this.delegation.cid} has expired on ${new Date(this.delegation.expiration * 1000)}`;
    }
    get expiredAt() {
        return this.delegation.expiration;
    }
    toJSON() {
        const { name, expiredAt, message, stack } = this;
        return {
            name,
            message,
            expiredAt,
            stack
        };
    }
}
class Revoked extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {API.Delegation} delegation
   */ constructor(delegation){
        super();
        this.name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["the"])('Revoked');
        this.delegation = delegation;
    }
    describe() {
        return `Proof ${this.delegation.cid} has been revoked`;
    }
    toJSON() {
        const { name, message, stack } = this;
        return {
            name,
            message,
            stack
        };
    }
}
class NotValidBefore extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {API.Delegation & { notBefore: number }} delegation
   */ constructor(delegation){
        super();
        this.name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["the"])('NotValidBefore');
        this.delegation = delegation;
    }
    describe() {
        return `Proof ${this.delegation.cid} is not valid before ${new Date(this.delegation.notBefore * 1000)}`;
    }
    get validAt() {
        return this.delegation.notBefore;
    }
    toJSON() {
        const { name, validAt, message, stack } = this;
        return {
            name,
            message,
            validAt,
            stack
        };
    }
}
class Unauthorized extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {{
   * capability: API.CapabilityParser
   * delegationErrors: API.DelegationError[]
   * unknownCapabilities: API.Capability[]
   * invalidProofs: API.InvalidProof[]
   * failedProofs: API.InvalidClaim[]
   * }} cause
   */ constructor({ capability, delegationErrors, unknownCapabilities, invalidProofs, failedProofs }){
        super();
        this.name = 'Unauthorized';
        this.capability = capability;
        this.delegationErrors = delegationErrors;
        this.unknownCapabilities = unknownCapabilities;
        this.invalidProofs = invalidProofs;
        this.failedProofs = failedProofs;
    }
    describe() {
        const errors = [
            ...this.failedProofs.map((error)=>li(error.message)),
            ...this.delegationErrors.map((error)=>li(error.message)),
            ...this.invalidProofs.map((error)=>li(error.message))
        ];
        const unknown = this.unknownCapabilities.map((c)=>li(JSON.stringify(c)));
        return [
            `Claim ${this.capability} is not authorized`,
            ...errors.length > 0 ? errors : [
                li(`No matching delegated capability found`)
            ],
            ...unknown.length > 0 ? [
                li(`Encountered unknown capabilities\n${unknown.join('\n')}`)
            ] : []
        ].join('\n');
    }
}
/**
 * @param {unknown} capability
 * @param {string|number} [space]
 */ const format = (capability, space)=>JSON.stringify(capability, (_key, value)=>{
        /* c8 ignore next 2 */ if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isLink"])(value)) {
            return value.toString();
        } else {
            return value;
        }
    }, space);
const indent = (message, indent = '  ')=>`${indent}${message.split('\n').join(`\n${indent}`)}`;
const li = (message)=>indent(`- ${message}`);
}),
"[project]/node_modules/@ucanto/validator/src/capability.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "and",
    ()=>and,
    "capability",
    ()=>capability,
    "derive",
    ()=>derive,
    "or",
    ()=>or
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$interface$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/interface/src/lib.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/validator/src/util.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/validator/src/error.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/lib.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$invocation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/invocation.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$delegation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/delegation.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/schema.js [app-ssr] (ecmascript) <export * as Schema>");
;
;
;
;
const capability = ({ derives = defaultDerives, nb = defaultNBSchema, ...etc })=>new Capability({
        derives,
        nb,
        ...etc
    });
const defaultNBSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__["Schema"].struct({});
const or = (left, right)=>new Or(left, right);
const and = (...selectors)=>new And(selectors);
const derive = ({ from, to, derives })=>new Derive(from, to, derives);
/**
 * @template {API.Match} M
 * @implements {API.View<M>}
 */ class View {
    /**
   * @param {API.Source} source
   * @returns {API.MatchResult<M>}
   */ /* c8 ignore next 3 */ match(source) {
        return {
            error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["UnknownCapability"](source.capability)
        };
    }
    /**
   * @param {API.Source[]} capabilities
   * @returns {API.Select<M>}
   */ select(capabilities) {
        return select(this, capabilities);
    }
    /**
   * @template {API.ParsedCapability} U
   * @param {object} source
   * @param {API.TheCapabilityParser<API.DirectMatch<U>>} source.to
   * @param {API.Derives<U, API.InferDeriveProof<M['value']>>} source.derives
   * @returns {API.TheCapabilityParser<API.DerivedMatch<U, M>>}
   */ derive({ derives, to }) {
        return derive({
            derives,
            to,
            from: this
        });
    }
}
/**
 * @template {API.Match} M
 * @implements {API.CapabilityParser<M>}
 * @extends {View<M>}
 */ class Unit extends View {
    /**
   * @template {API.Match} W
   * @param {API.MatchSelector<W>} other
   * @returns {API.CapabilityParser<M | W>}
   */ or(other) {
        return or(this, other);
    }
    /**
   * @template {API.Match} W
   * @param {API.CapabilityParser<W>} other
   * @returns {API.CapabilitiesParser<[M, W]>}
   */ and(other) {
        return and(this, other);
    }
}
/**
 * @template {API.Ability} A
 * @template {API.URI} R
 * @template {API.Caveats} C
 * @implements {API.TheCapabilityParser<API.DirectMatch<API.ParsedCapability<A, R, C>>>}
 * @extends {Unit<API.DirectMatch<API.ParsedCapability<A, R, C>>>}
 */ class Capability extends Unit {
    /**
   * @param {Required<Descriptor<A, R, C>>} descriptor
   */ constructor(descriptor){
        super();
        this.descriptor = descriptor;
        this.schema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__["Schema"].struct({
            can: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__["Schema"].literal(descriptor.can),
            with: descriptor.with,
            nb: descriptor.nb
        });
    }
    /**
   * @param {API.InferCreateOptions<R, C>} options
   */ create(options) {
        const { descriptor, can } = this;
        const decoders = descriptor.nb;
        const data = options.nb || {};
        const resource = descriptor.with.read(options.with);
        if (resource.error) {
            throw Object.assign(new Error(`Invalid 'with' - ${resource.error.message}`), {
                cause: resource
            });
        }
        const nb = descriptor.nb.read(data);
        if (nb.error) {
            throw Object.assign(new Error(`Invalid 'nb' - ${nb.error.message}`), {
                cause: nb
            });
        }
        return createCapability({
            can,
            with: resource.ok,
            nb: nb.ok
        });
    }
    /**
   * @param {API.InferInvokeOptions<R, C>} options
   */ invoke({ with: with_, nb, ...options }) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$invocation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["invoke"])({
            ...options,
            capability: this.create({
                with: with_,
                nb
            })
        });
    }
    /**
   * @param {API.InferDelegationOptions<R, C>} options
   * @returns {Promise<API.Delegation<[API.InferDelegatedCapability<API.ParsedCapability<A, R, C>>]>>}
   */ async delegate({ nb: input = {}, with: with_, ...options }) {
        const { descriptor, can } = this;
        const readers = descriptor.nb;
        const resource = descriptor.with.read(with_);
        if (resource.error) {
            throw Object.assign(new Error(`Invalid 'with' - ${resource.error.message}`), {
                cause: resource
            });
        }
        const nb = descriptor.nb.partial().read(input);
        if (nb.error) {
            throw Object.assign(new Error(`Invalid 'nb' - ${nb.error.message}`), {
                cause: nb
            });
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$delegation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["delegate"])({
            capabilities: [
                createCapability({
                    can,
                    with: resource.ok,
                    nb: nb.ok
                })
            ],
            ...options
        });
    }
    get can() {
        return this.descriptor.can;
    }
    /**
   * @param {API.Source} source
   * @returns {API.MatchResult<API.DirectMatch<API.ParsedCapability<A, R, C>>>}
   */ match(source) {
        const result = parseCapability(this.descriptor, source);
        return result.error ? result : {
            ok: new Match(source, result.ok, this.descriptor)
        };
    }
    toString() {
        return JSON.stringify({
            can: this.descriptor.can
        });
    }
}
/**
 * Normalizes capability by removing empty nb field.
 *
 * @template {API.ParsedCapability} T
 * @param {T} source
 */ const createCapability = ({ can, with: with_, nb })=>/** @type {API.InferCapability<T>} */ ({
        can,
        with: with_,
        ...isEmpty(nb) ? {} : {
            nb
        }
    });
/**
 * @param {object} object
 * @returns {object is {}}
 */ const isEmpty = (object)=>{
    for(const _ in object){
        return false;
    }
    return true;
};
/**
 * @template {API.Match} M
 * @template {API.Match} W
 * @implements {API.CapabilityParser<M|W>}
 * @extends {Unit<M|W>}
 */ class Or extends Unit {
    /**
   * @param {API.Matcher<M>} left
   * @param {API.Matcher<W>} right
   */ constructor(left, right){
        super();
        this.left = left;
        this.right = right;
    }
    /**
   * @param {API.Source} capability
   * @return {API.MatchResult<M|W>}
   */ match(capability) {
        const left = this.left.match(capability);
        if (left.error) {
            const right = this.right.match(capability);
            if (right.error) {
                return right.error.name === 'MalformedCapability' ? right : left;
            } else {
                return right;
            }
        } else {
            return left;
        }
    }
    toString() {
        return `${this.left.toString()}|${this.right.toString()}`;
    }
}
/**
 * @template {API.MatchSelector<API.Match>[]} Selectors
 * @implements {API.CapabilitiesParser<API.InferMembers<Selectors>>}
 * @extends {View<API.Amplify<API.InferMembers<Selectors>>>}
 */ class And extends View {
    /**
   * @param {Selectors} selectors
   */ constructor(selectors){
        super();
        this.selectors = selectors;
    }
    /**
   * @param {API.Source} capability
   * @returns {API.MatchResult<API.Amplify<API.InferMembers<Selectors>>>}
   */ match(capability) {
        const group = [];
        for (const selector of this.selectors){
            const result = selector.match(capability);
            if (result.error) {
                return result;
            } else {
                group.push(result.ok);
            }
        }
        return {
            ok: new AndMatch(group)
        };
    }
    /**
   * @param {API.Source[]} capabilities
   */ select(capabilities) {
        return selectGroup(this, capabilities);
    }
    /**
   * @template E
   * @template {API.Match} X
   * @param {API.MatchSelector<API.Match<E, X>>} other
   * @returns {API.CapabilitiesParser<[...API.InferMembers<Selectors>, API.Match<E, X>]>}
   */ and(other) {
        return new And([
            ...this.selectors,
            other
        ]);
    }
    toString() {
        return `[${this.selectors.map(String).join(', ')}]`;
    }
}
/**
 * @template {API.ParsedCapability} T
 * @template {API.Match} M
 * @implements {API.TheCapabilityParser<API.DerivedMatch<T, M>>}
 * @extends {Unit<API.DerivedMatch<T, M>>}
 */ class Derive extends Unit {
    /**
   * @param {API.MatchSelector<M>} from
   * @param {API.TheCapabilityParser<API.DirectMatch<T>>} to
   * @param {API.Derives<T, API.InferDeriveProof<M['value']>>} derives
   */ constructor(from, to, derives){
        super();
        this.from = from;
        this.to = to;
        this.derives = derives;
    }
    /**
   * @type {typeof this.to['create']}
   */ create(options) {
        return this.to.create(options);
    }
    /**
   * @type {typeof this.to['invoke']}
   */ invoke(options) {
        return this.to.invoke(options);
    }
    /**
   * @type {typeof this.to['delegate']}
   */ delegate(options) {
        return this.to.delegate(options);
    }
    get can() {
        return this.to.can;
    }
    /**
   * @param {API.Source} capability
   * @returns {API.MatchResult<API.DerivedMatch<T, M>>}
   */ match(capability) {
        const match = this.to.match(capability);
        if (match.error) {
            return match;
        } else {
            return {
                ok: new DerivedMatch(match.ok, this.from, this.derives)
            };
        }
    }
    toString() {
        return this.to.toString();
    }
}
/**
 * @template {API.Ability} A
 * @template {API.URI} R
 * @template {API.Caveats} C
 * @implements {API.DirectMatch<API.ParsedCapability<A, R, C>>}
 */ class Match {
    /**
   * @param {API.Source} source
   * @param {API.ParsedCapability<A, R, C>} value
   * @param {Required<Descriptor<A, R, C>>} descriptor
   */ constructor(source, value, descriptor){
        this.source = [
            source
        ];
        this.value = value;
        this.descriptor = descriptor;
    }
    get can() {
        return this.value.can;
    }
    get proofs() {
        const proofs = [
            this.source[0].delegation
        ];
        Object.defineProperties(this, {
            proofs: {
                value: proofs
            }
        });
        return proofs;
    }
    /**
   * @param {API.CanIssue} context
   * @returns {API.DirectMatch<API.ParsedCapability<A, R, C>>|null}
   */ prune(context) {
        if (context.canIssue(this.value, this.source[0].delegation.issuer.did())) {
            return null;
        } else {
            return this;
        }
    }
    /**
   * @param {API.Source[]} capabilities
   * @returns {API.Select<API.DirectMatch<API.ParsedCapability<A, R, C>>>}
   */ select(capabilities) {
        const unknown = [];
        const errors = [];
        const matches = [];
        for (const capability of capabilities){
            const result = resolveCapability(this.descriptor, this.value, capability);
            if (result.ok) {
                const claim = this.descriptor.derives(this.value, result.ok);
                if (claim.error) {
                    errors.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["DelegationError"]([
                        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["EscalatedCapability"](this.value, result.ok, claim.error)
                    ], this));
                } else {
                    matches.push(new Match(capability, result.ok, this.descriptor));
                }
            } else {
                switch(result.error.name){
                    case 'UnknownCapability':
                        unknown.push(result.error.capability);
                        break;
                    case 'MalformedCapability':
                    default:
                        errors.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["DelegationError"]([
                            result.error
                        ], this));
                }
            }
        }
        return {
            matches,
            unknown,
            errors
        };
    }
    toString() {
        const { nb } = this.value;
        return JSON.stringify({
            can: this.descriptor.can,
            with: this.value.with,
            nb: nb && Object.keys(nb).length > 0 ? nb : undefined
        });
    }
}
/**
 * @template {API.ParsedCapability} T
 * @template {API.Match} M
 * @implements {API.DerivedMatch<T, M>}
 */ class DerivedMatch {
    /**
   * @param {API.DirectMatch<T>} selected
   * @param {API.MatchSelector<M>} from
   * @param {API.Derives<T, API.InferDeriveProof<M['value']>>} derives
   */ constructor(selected, from, derives){
        this.selected = selected;
        this.from = from;
        this.derives = derives;
    }
    get can() {
        return this.value.can;
    }
    get source() {
        return this.selected.source;
    }
    get proofs() {
        const proofs = [];
        for (const { delegation } of this.selected.source){
            proofs.push(delegation);
        }
        Object.defineProperties(this, {
            proofs: {
                value: proofs
            }
        });
        return proofs;
    }
    get value() {
        return this.selected.value;
    }
    /**
   * @param {API.CanIssue} context
   */ prune(context) {
        const selected = this.selected.prune(context);
        return selected ? new DerivedMatch(selected, this.from, this.derives) : null;
    }
    /**
   * @param {API.Source[]} capabilities
   */ select(capabilities) {
        const { derives, selected, from } = this;
        const { value } = selected;
        const direct = selected.select(capabilities);
        const derived = from.select(capabilities);
        const matches = [];
        const errors = [];
        for (const match of derived.matches){
            // If capability can not be derived it escalates
            const result = derives(value, match.value);
            if (result.error) {
                errors.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["DelegationError"]([
                    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["EscalatedCapability"](value, match.value, result.error)
                ], this));
            } else {
                matches.push(match);
            }
        }
        return {
            unknown: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["intersection"])(direct.unknown, derived.unknown),
            errors: [
                ...errors,
                ...direct.errors,
                ...derived.errors.map((error)=>new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["DelegationError"]([
                        error
                    ], this))
            ],
            matches: [
                ...direct.matches.map((match)=>new DerivedMatch(match, from, derives)),
                ...matches
            ]
        };
    }
    toString() {
        return this.selected.toString();
    }
}
/**
 * @template {API.MatchSelector<API.Match>[]} Selectors
 * @implements {API.Amplify<API.InferMembers<Selectors>>}
 */ class AndMatch {
    /**
   * @param {API.Match[]} matches
   */ constructor(matches){
        this.matches = matches;
    }
    get selectors() {
        return this.matches;
    }
    /**
   * @returns {API.Source[]}
   */ get source() {
        const source = [];
        for (const match of this.matches){
            source.push(...match.source);
        }
        Object.defineProperties(this, {
            source: {
                value: source
            }
        });
        return source;
    }
    /**
   * @param {API.CanIssue} context
   */ prune(context) {
        const matches = [];
        for (const match of this.matches){
            const pruned = match.prune(context);
            if (pruned) {
                matches.push(pruned);
            }
        }
        return matches.length === 0 ? null : new AndMatch(matches);
    }
    get proofs() {
        const proofs = [];
        for (const { delegation } of this.source){
            proofs.push(delegation);
        }
        Object.defineProperties(this, {
            proofs: {
                value: proofs
            }
        });
        return proofs;
    }
    /**
   * @type {API.InferValue<API.InferMembers<Selectors>>}
   */ get value() {
        const value = [];
        for (const match of this.matches){
            value.push(match.value);
        }
        Object.defineProperties(this, {
            value: {
                value
            }
        });
        return value;
    }
    /**
   * @param {API.Source[]} capabilities
   */ select(capabilities) {
        return selectGroup(this, capabilities);
    }
    toString() {
        return `[${this.matches.map((match)=>match.toString()).join(', ')}]`;
    }
}
/**
 * Resolves ability `pattern` of the delegated capability from the ability
 * of the claimed capability. If pattern matches returns claimed ability
 * otherwise returns given `fallback`.
 *
 * @example
 * ```js
 * resolveAbility('*', 'store/add', null) // => 'store/add'
 * resolveAbility('store/*', 'store/add', null) // => 'store/add'
 * resolveAbility('store/add', 'store/add', null) // => 'store/add'
 * resolveAbility('store/', 'store/add', null) // => null
 * resolveAbility('store/a*', 'store/add', null) // => null
 * resolveAbility('store/list', 'store/add', null) // => null
 * ```
 *
 * @template {API.Ability} T
 * @template U
 * @param {string} pattern
 * @param {T} can
 * @param {U} fallback
 * @returns {T|U}
 */ const resolveAbility = (pattern, can, fallback)=>{
    switch(pattern){
        case can:
        case '*':
            return can;
        default:
            return pattern.endsWith('/*') && can.startsWith(pattern.slice(0, -1)) ? can : fallback;
    }
};
/**
 * Resolves `source` resource of the delegated capability from the resource
 * `uri` of the claimed capability. If `source` is `"ucan:*""` or matches `uri`
 * then it returns `uri` back otherwise it returns `fallback`.
 *
 * @example
 * ```js
 * resolveResource('ucan:*', 'did:key:zAlice', null) // => 'did:key:zAlice'
 * resolveAbility('ucan:*', 'https://example.com', null) // => 'https://example.com'
 * resolveAbility('did:*', 'did:key:zAlice', null) // => null
 * resolveAbility('did:key:zAlice', 'did:key:zAlice', null) // => did:key:zAlice
 * ```
 * @template {string} T
 * @template U
 * @param {T} uri
 * @param {string} source
 * @param {U} fallback
 * @returns {T|U}
 */ const resolveResource = (source, uri, fallback)=>{
    switch(source){
        case uri:
        case 'ucan:*':
            return uri;
        default:
            return fallback;
    }
};
/**
 * Parses capability from the `source` using a provided `parser`.
 *
 * @template {API.Ability} A
 * @template {API.URI} R
 * @template {API.Caveats} C
 * @param {Required<Descriptor<A, R, C>>} descriptor
 * @param {API.Source} source
 * @returns {API.Result<API.ParsedCapability<A, R, C>, API.InvalidCapability>}
 */ const parseCapability = (descriptor, source)=>{
    const { delegation } = source;
    const capability = source.capability;
    if (descriptor.can !== capability.can) {
        return {
            error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["UnknownCapability"](capability)
        };
    }
    const uri = descriptor.with.read(capability.with);
    if (uri.error) {
        return {
            error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["MalformedCapability"](capability, uri.error)
        };
    }
    const nb = descriptor.nb.read(capability.nb || {});
    if (nb.error) {
        return {
            error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["MalformedCapability"](capability, nb.error)
        };
    }
    return {
        ok: new CapabilityView(descriptor.can, uri.ok, nb.ok, delegation)
    };
};
/**
 * Resolves delegated capability `source` from the `claimed` capability using
 * provided capability `parser`. It is similar to `parseCapability` except
 * `source` here is treated as capability pattern which is matched against the
 * `claimed` capability. This means we resolve `can` and `with` fields from the
 * `claimed` capability and inherit all missing `nb` fields from the claimed
 * capability.
 *
 * @template {API.Ability} A
 * @template {API.URI} R
 * @template {API.Caveats} C
 * @param {Required<Descriptor<A, R, C>>} descriptor
 * @param {API.ParsedCapability<A, R, C>} claimed
 * @param {API.Source} source
 * @returns {API.Result<API.ParsedCapability<A, R, C>, API.InvalidCapability>}
 */ const resolveCapability = (descriptor, claimed, { capability, delegation })=>{
    const can = resolveAbility(capability.can, claimed.can, null);
    if (can == null) {
        return {
            error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["UnknownCapability"](capability)
        };
    }
    const resource = resolveResource(capability.with, claimed.with, capability.with);
    const uri = descriptor.with.read(resource);
    if (uri.error) {
        return {
            error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["MalformedCapability"](capability, uri.error)
        };
    }
    const nb = descriptor.nb.read({
        ...claimed.nb,
        ...capability.nb
    });
    if (nb.error) {
        return {
            error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["MalformedCapability"](capability, nb.error)
        };
    }
    return {
        ok: new CapabilityView(can, uri.ok, nb.ok, delegation)
    };
};
/**
 * @template {API.Ability} A
 * @template {API.URI} R
 * @template C
 */ class CapabilityView {
    /**
   * @param {A} can
   * @param {R} with_
   * @param {C} nb
   * @param {API.Delegation} delegation
   */ constructor(can, with_, nb, delegation){
        this.can = can;
        this.with = with_;
        this.delegation = delegation;
        this.nb = nb;
    }
}
/**
 * @template {API.Match} M
 * @param {API.Matcher<M>} matcher
 * @param {API.Source[]} capabilities
 * @returns {API.Select<M>}
 */ const select = (matcher, capabilities)=>{
    const unknown = [];
    const matches = [];
    const errors = [];
    for (const capability of capabilities){
        const result = matcher.match(capability);
        if (result.error) {
            switch(result.error.name){
                case 'UnknownCapability':
                    unknown.push(result.error.capability);
                    break;
                case 'MalformedCapability':
                default:
                    errors.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["DelegationError"]([
                        result.error
                    ], result.error.capability));
            }
        } else {
            matches.push(result.ok);
        }
    }
    return {
        matches,
        errors,
        unknown
    };
};
/**
 * @template {API.Selector<API.Match>[]} S
 * @param {{selectors:S}} self
 * @param {API.Source[]} capabilities
 */ const selectGroup = (self, capabilities)=>{
    let unknown;
    const data = [];
    const errors = [];
    for (const selector of self.selectors){
        const selected = selector.select(capabilities);
        unknown = unknown ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["intersection"])(unknown, selected.unknown) : selected.unknown;
        for (const error of selected.errors){
            errors.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["DelegationError"]([
                error
            ], self));
        }
        data.push(selected.matches);
    }
    const matches = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["combine"])(data).map((group)=>new AndMatch(group));
    return {
        unknown: /* c8 ignore next */ unknown || [],
        errors,
        matches
    };
};
/**
 * @template {API.ParsedCapability} T
 * @template {API.ParsedCapability} U
 * @param {T} claimed
 * @param {U} delegated
 * @return {API.Result<true, API.Failure>}
 */ const defaultDerives = (claimed, delegated)=>{
    if (delegated.with.endsWith('*')) {
        if (!claimed.with.startsWith(delegated.with.slice(0, -1))) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__["Schema"].error(`Resource ${claimed.with} does not match delegated ${delegated.with} `);
        }
    } else if (delegated.with !== claimed.with) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__["Schema"].error(`Resource ${claimed.with} is not contained by ${delegated.with}`);
    }
    /* c8 ignore next 2 */ const caveats = delegated.nb || {};
    const nb = claimed.nb || {};
    const kv = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["entries"])(caveats);
    for (const [name, value] of kv){
        if (nb[name] != value) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__["Schema"].error(`${String(name)}: ${nb[name]} violates ${value}`);
        }
    }
    return {
        ok: true
    };
};
}),
"[project]/node_modules/@ucanto/validator/src/authorization.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "create",
    ()=>create,
    "iterate",
    ()=>iterate
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$interface$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/interface/src/lib.js [app-ssr] (ecmascript)");
;
/**
 * @template {API.ParsedCapability} C
 * @implements {API.Authorization<C>}
 */ class Authorization {
    /**
   * @param {API.Match<C>} match
   * @param {API.Authorization<API.ParsedCapability>[]} proofs
   */ constructor(match, proofs){
        this.match = match;
        this.proofs = proofs;
    }
    get capability() {
        return this.match.value;
    }
    get delegation() {
        return this.match.source[0].delegation;
    }
    get issuer() {
        return this.delegation.issuer;
    }
    get audience() {
        return this.delegation.audience;
    }
}
const create = (match, proofs = [])=>new Authorization(match, proofs);
const iterate = function*({ delegation, proofs }) {
    yield delegation.cid;
    for (const proof of proofs){
        yield* iterate(proof);
    }
};
}),
"[project]/node_modules/@ucanto/validator/src/lib.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "access",
    ()=>access,
    "authorize",
    ()=>authorize,
    "claim",
    ()=>claim
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$interface$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/interface/src/lib.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/lib.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$delegation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/delegation.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__UCAN$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/lib.js [app-ssr] (ecmascript) <export * as UCAN>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/result.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$capability$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/validator/src/capability.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/schema.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/schema.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/schema/schema.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2f$link$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__$3c$export__match__as__link$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/schema/link.js [app-ssr] (ecmascript) <locals> <export match as link>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$authorization$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/validator/src/authorization.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/validator/src/error.js [app-ssr] (ecmascript) <locals>");
;
;
;
;
;
;
;
;
;
/**
 * @param {UCAN.Link} proof
 * @returns {{error:API.UnavailableProof}}
 */ const unavailable = (proof)=>({
        error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["UnavailableProof"](proof)
    });
/**
 *
 * @param {UCAN.DID} did
 * @returns {{error:API.DIDKeyResolutionError}}
 */ const failDIDKeyResolution = (did)=>({
        error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["DIDKeyResolutionError"](did)
    });
/**
 * @param {Required<API.ClaimOptions>} config
 * @param {API.Match<unknown, API.Match>} match
 */ const resolveMatch = async (match, config)=>{
    const promises = [];
    const includes = new Set();
    for (const source of match.source){
        const id = source.delegation.cid.toString();
        if (!includes.has(id)) {
            promises.push(await resolveSources(source, config));
        }
    }
    const groups = await Promise.all(promises);
    const sources = [];
    const errors = [];
    for (const group of groups){
        sources.push(...group.sources);
        errors.push(...group.errors);
    }
    return {
        sources,
        errors
    };
};
/**
 * Takes `proofs` from the delegation which may contain `Delegation` or a link
 * to one and attempts to resolve links by side loading them. Returns set of
 * resolved `Delegation`s and errors for the proofs that could not be resolved.
 *
 * @param {API.Proof[]} proofs
 * @param {Required<API.ProofResolver>} config
 */ const resolveProofs = async (proofs, config)=>{
    /** @type {API.Delegation[]} */ const delegations = [];
    /** @type {API.UnavailableProof[]} */ const errors = [];
    const promises = [];
    for (const proof of proofs){
        // If it is a delegation we can just add it to the resolved set.
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$delegation$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isDelegation"])(proof)) {
            delegations.push(proof);
        } else {
            promises.push(new Promise(async (resolve)=>{
                // config.resolve is not supposed to throw, but we catch it just in
                // case it does and consider proof resolution failed.
                try {
                    const result = await config.resolve(proof);
                    if (result.error) {
                        errors.push(result.error);
                    } else {
                        delegations.push(result.ok);
                    }
                } catch (error) {
                    errors.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["UnavailableProof"](proof, error));
                }
                // we don't care about the result, we just need to signal that we are
                // done with this promise.
                resolve(null);
            }));
        }
    }
    // Wait for all the promises to resolve. At this point we have collected all
    // the resolved delegations and errors.
    await Promise.all(promises);
    return {
        delegations,
        errors
    };
};
/**
 * Takes a delegation source and attempts to resolve all the linked proofs.
 *
 * @param {API.Source} from
 * @param {Required<API.ClaimOptions>} config
 * @return {Promise<{sources:API.Source[], errors:ProofError[]}>}
 */ const resolveSources = async ({ delegation }, config)=>{
    const errors = [];
    const sources = [];
    const proofs = [];
    // First we attempt to resolve all the linked proofs.
    const { delegations, errors: failedProofs } = await resolveProofs(delegation.proofs, config);
    // All the proofs that failed to resolve are saved as proof errors.
    for (const error of failedProofs){
        errors.push(new ProofError(error.link, error));
    }
    // All the proofs that resolved are checked for principal alignment. Ones that
    // do not align are saved as proof errors.
    for (const proof of delegations){
        // If proof does not delegate to a matching audience save an proof error.
        if (delegation.issuer.did() !== proof.audience.did()) {
            errors.push(new ProofError(proof.cid, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["PrincipalAlignmentError"](delegation.issuer, proof)));
        } else {
            proofs.push(proof);
        }
    }
    // In the second pass we attempt to proofs that were resolved and are aligned.
    for (const proof of proofs){
        // If proof is not valid (expired, not active yet or has incorrect
        // signature) save a corresponding proof error.
        const validation = await validate(proof, proofs, config);
        if (validation.error) {
            errors.push(new ProofError(proof.cid, validation.error));
        } else {
            // otherwise create source objects for it's capabilities, so we could
            // track which proof in which capability the are from.
            for (const capability of proof.capabilities){
                sources.push({
                    capability,
                    delegation: proof
                });
            }
        }
    }
    return {
        sources,
        errors
    };
};
/**
 * @param {API.ParsedCapability} capability
 * @param {API.DID} issuer
 */ const isSelfIssued = (capability, issuer)=>capability.with === issuer;
const access = async (invocation, { capability, ...config })=>claim(capability, [
        invocation
    ], config);
const claim = async (capability, proofs, { authority, principal, validateAuthorization, resolveDIDKey = failDIDKeyResolution, canIssue = isSelfIssued, resolve = unavailable, proofs: localProofs = [] })=>{
    const config = {
        canIssue,
        resolve,
        principal,
        capability,
        authority,
        validateAuthorization,
        resolveDIDKey,
        proofs: localProofs
    };
    const invalidProofs = [];
    /** @type {API.Source[]} */ const sources = [];
    const { delegations, errors } = await resolveProofs(proofs, config);
    invalidProofs.push(...errors);
    for (const proof of delegations){
        // Validate each proof if valid add ech capability to the list of sources.
        // otherwise collect the error.
        const validation = await validate(proof, delegations, config);
        if (validation.ok) {
            for (const capability of validation.ok.capabilities.values()){
                sources.push({
                    capability,
                    delegation: validation.ok
                });
            }
        } else {
            invalidProofs.push(validation.error);
        }
    }
    // look for the matching capability
    const selection = capability.select(sources);
    const { errors: delegationErrors, unknown: unknownCapabilities } = selection;
    const failedProofs = [];
    for (const matched of selection.matches){
        const selector = matched.prune(config);
        if (selector == null) {
            const authorization = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$authorization$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["create"](matched, []);
            const result = await validateAuthorization(authorization);
            if (result.error) {
                invalidProofs.push(result.error);
            } else {
                return {
                    ok: authorization
                };
            }
        } else {
            const result = await authorize(selector, config);
            if (result.error) {
                failedProofs.push(result.error);
            } else {
                const authorization = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$authorization$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["create"](matched, [
                    result.ok
                ]);
                const approval = await validateAuthorization(authorization);
                if (approval.error) {
                    invalidProofs.push(approval.error);
                } else {
                    return {
                        ok: authorization
                    };
                }
            }
        }
    }
    return {
        error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Unauthorized"]({
            capability,
            delegationErrors,
            unknownCapabilities,
            invalidProofs,
            failedProofs
        })
    };
};
const authorize = async (match, config)=>{
    // load proofs from all delegations
    const { sources, errors: invalidProofs } = await resolveMatch(match, config);
    const selection = match.select(sources);
    const { errors: delegationErrors, unknown: unknownCapabilities } = selection;
    const failedProofs = [];
    for (const matched of selection.matches){
        const selector = matched.prune(config);
        if (selector == null) {
            return {
                ok: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$authorization$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["create"](// @ts-expect-error - it may not be a parsed capability but rather a
                // group of capabilities but we can deal with that in the future.
                matched, [])
            };
        } else {
            const result = await authorize(selector, config);
            if (result.error) {
                failedProofs.push(result.error);
            } else {
                return {
                    ok: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$authorization$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["create"](// @ts-expect-error - it may not be a parsed capability but rather a
                    // group of capabilities but we can deal with that in the future.
                    matched, [
                        result.ok
                    ])
                };
            }
        }
    }
    return {
        error: new InvalidClaim({
            match,
            delegationErrors,
            unknownCapabilities,
            invalidProofs,
            failedProofs
        })
    };
};
class ProofError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {API.UCANLink} proof
   * @param {API.Failure} cause
   */ constructor(proof, cause){
        super();
        this.name = 'ProofError';
        this.proof = proof;
        this.cause = cause;
    }
    describe() {
        return [
            `Capability can not be derived from prf:${this.proof} because:`,
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["li"])(this.cause.message)
        ].join(`\n`);
    }
}
/**
 * @implements {API.InvalidClaim}
 */ class InvalidClaim extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {{
   * match: API.Match
   * delegationErrors: API.DelegationError[]
   * unknownCapabilities: API.Capability[]
   * invalidProofs: ProofError[]
   * failedProofs: API.InvalidClaim[]
   * }} info
   */ constructor(info){
        super();
        this.info = info;
        this.name = 'InvalidClaim';
    }
    get issuer() {
        return this.delegation.issuer;
    }
    get delegation() {
        return this.info.match.source[0].delegation;
    }
    describe() {
        const errors = [
            ...this.info.failedProofs.map((error)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["li"])(error.message)),
            ...this.info.delegationErrors.map((error)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["li"])(error.message)),
            ...this.info.invalidProofs.map((error)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["li"])(error.message))
        ];
        const unknown = this.info.unknownCapabilities.map((c)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["li"])(JSON.stringify(c)));
        return [
            `Capability ${this.info.match} is not authorized because:`,
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["li"])(`Capability can not be (self) issued by '${this.issuer.did()}'`),
            ...errors.length > 0 ? errors : [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["li"])(`Delegated capability not found`)
            ],
            ...unknown.length > 0 ? [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["li"])(`Encountered unknown capabilities\n${unknown.join('\n')}`)
            ] : []
        ].join('\n');
    }
}
/**
 * Validate a delegation to check it is within the time bound and that it is
 * authorized by the issuer.
 *
 * @template {API.Delegation} T
 * @param {T} delegation
 * @param {API.Delegation[]} proofs
 * @param {Required<API.ClaimOptions>} config
 * @returns {Promise<API.Result<T, API.InvalidProof|API.SessionEscalation|API.DIDKeyResolutionError>>}
 */ const validate = async (delegation, proofs, config)=>{
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__UCAN$3e$__["UCAN"].isExpired(delegation.data)) {
        return {
            error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Expired"](delegation)
        };
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__UCAN$3e$__["UCAN"].isTooEarly(delegation.data)) {
        return {
            error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["NotValidBefore"](delegation)
        };
    }
    return await verifyAuthorization(delegation, proofs, config);
};
/**
 * Verifies that delegation has been authorized by the issuer. If issued by the
 * did:key principal checks that the signature is valid. If issued by the root
 * authority checks that the signature is valid. If issued by the principal
 * identified by other DID method attempts to resolve a valid `ucan/attest`
 * attestation from the authority, if attestation is not found falls back to
 * resolving did:key for the issuer and verifying its signature.
 *
 * @template {API.Delegation} T
 * @param {T} delegation
 * @param {API.Delegation[]} proofs
 * @param {Required<API.ClaimOptions>} config
 * @returns {Promise<API.Result<T, API.InvalidSignature|API.SessionEscalation|API.DIDKeyResolutionError>>}
 */ const verifyAuthorization = async (delegation, proofs, config)=>{
    const issuer = delegation.issuer.did();
    // If the issuer is a did:key we just verify a signature
    if (issuer.startsWith('did:key:')) {
        return verifySignature(delegation, config.principal.parse(issuer));
    } else if (issuer === config.authority.did()) {
        return verifySignature(delegation, config.authority);
    } else {
        // If issuer is not a did:key principal nor configured authority, we
        // attempt to resolve embedded authorization session from the authority.
        const session = await verifySession(delegation, proofs, config);
        // If we have valid session we consider authorization valid
        if (session.ok) {
            return {
                ok: delegation
            };
        } else if (session.error.failedProofs.length > 0) {
            return {
                error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["SessionEscalation"]({
                    delegation,
                    cause: session.error
                })
            };
        } else {
            const result = await config.resolveDIDKey(issuer);
            if (result.error) {
                return result;
            }
            const verifiers = result.ok;
            /** @type {(API.InvalidSignature | API.DIDKeyResolutionError)[]} */ const verificationErrResults = [];
            for (const verifier of verifiers){
                const verificationResult = await verifySignature(delegation, config.principal.parse(verifier).withDID(issuer));
                if (verificationResult.ok) {
                    return verificationResult;
                }
                if (verificationResult.error) {
                    verificationErrResults.push(verificationResult.error);
                }
            }
            // If no verifiers were found, there is no way to verify the signature
            if (verificationErrResults.length === 0) {
                return {
                    error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["DIDKeyResolutionError"](issuer)
                };
            }
            const combinedError = verificationErrResults[0];
            const combinedMessage = verificationErrResults.map((err)=>err.message).join('\n  ');
            // @ts-expect-error - both error types have describe method, override it to return the concatenated message
            combinedError.describe = ()=>combinedMessage;
            return {
                error: combinedError
            };
        }
    }
};
/**
 * @template {API.Delegation} T
 * @param {T} delegation
 * @param {API.Verifier} verifier
 * @returns {Promise<API.Result<T, API.InvalidSignature|API.DIDKeyResolutionError>>}
 */ const verifySignature = async (delegation, verifier)=>{
    const valid = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__UCAN$3e$__["UCAN"].verifySignature(delegation.data, verifier);
    return valid ? {
        ok: delegation
    } : {
        error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["InvalidSignature"](delegation, verifier)
    };
};
/**
 * Attempts to find an authorization session - an `ucan/attest` capability
 * delegation where `with` matches `config.authority` and `nb.proof`
 * matches given delegation.
 * @see https://github.com/storacha/specs/blob/feat/auth+account/w3-session.md#authorization-session
 *
 * @param {API.Delegation} delegation
 * @param {API.Delegation[]} proofs
 * @param {Required<API.ClaimOptions>} config
 */ const verifySession = async (delegation, proofs, config)=>{
    // Recognize attestations from all authorized principals, not just authority
    const withSchemas = config.proofs.filter((p)=>p.capabilities[0].can === 'ucan/attest' && p.capabilities[0].with === config.authority.did()).map((p)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["literal"](p.audience.did()));
    const withSchema = withSchemas.length ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["union"]([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["literal"](config.authority.did()),
        ...withSchemas
    ]) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["literal"](config.authority.did());
    // Create a schema that will match an authorization for this exact delegation
    const attestation = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$capability$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["capability"])({
        with: withSchema,
        can: 'ucan/attest',
        nb: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2f$schema$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["struct"]({
            proof: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2f$link$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__$3c$export__match__as__link$3e$__["link"](delegation.cid)
        })
    });
    return await claim(attestation, proofs// We only consider attestations otherwise we will end up doing an
    // exponential scan if there are other proofs that require attestations.
    .filter(isAttestation)// Also filter any proofs that _are_ the delegation we're verifying so
    // we don't recurse indefinitely.
    .filter((p)=>p.cid.toString() !== delegation.cid.toString()), config);
};
/**
 * Checks if the delegation is an attestation.
 *
 * @param {API.Delegation} proof
 */ const isAttestation = (proof)=>proof.capabilities[0]?.can === 'ucan/attest';
}),
];

//# sourceMappingURL=node_modules_9c640ca8._.js.map