{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40web3-storage/capabilities/node_modules/%40ucanto/validator/src/util.js"],"sourcesContent":["/**\n * @template {string|boolean|number|[unknown, ...unknown[]]} T\n * @param {T} value\n * @returns {T}\n */\nexport const the = value => value\n\n/**\n * @template {{}} O\n * @param {O} object\n * @returns {({ [K in keyof O]: [K, O[K]][] }[keyof O])|[[never, never]]}\n */\n\nexport const entries = object => /** @type {any} */ (Object.entries(object))\n\n/**\n * @template T\n * @param {T[][]} dataset\n * @returns {T[][]}\n */\nexport const combine = ([first, ...rest]) => {\n  const results = first.map(value => [value])\n  for (const values of rest) {\n    const tuples = results.splice(0)\n    for (const value of values) {\n      for (const tuple of tuples) {\n        results.push([...tuple, value])\n      }\n    }\n  }\n  return results\n}\n\n/**\n * @template T\n * @param {T[]} left\n * @param {T[]} right\n * @returns {T[]}\n */\nexport const intersection = (left, right) => {\n  const [result, other] =\n    left.length < right.length\n      ? [new Set(left), new Set(right)]\n      : [new Set(right), new Set(left)]\n\n  for (const item of result) {\n    if (!other.has(item)) {\n      result.delete(item)\n    }\n  }\n\n  return [...result]\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC;;;;;;;;;;AACM,MAAM,MAAM,CAAA,QAAS;AAQrB,MAAM,UAAU,CAAA,SAA8B,OAAO,OAAO,CAAC;AAO7D,MAAM,UAAU,CAAC,CAAC,OAAO,GAAG,KAAK;IACtC,MAAM,UAAU,MAAM,GAAG,CAAC,CAAA,QAAS;YAAC;SAAM;IAC1C,KAAK,MAAM,UAAU,KAAM;QACzB,MAAM,SAAS,QAAQ,MAAM,CAAC;QAC9B,KAAK,MAAM,SAAS,OAAQ;YAC1B,KAAK,MAAM,SAAS,OAAQ;gBAC1B,QAAQ,IAAI,CAAC;uBAAI;oBAAO;iBAAM;YAChC;QACF;IACF;IACA,OAAO;AACT;AAQO,MAAM,eAAe,CAAC,MAAM;IACjC,MAAM,CAAC,QAAQ,MAAM,GACnB,KAAK,MAAM,GAAG,MAAM,MAAM,GACtB;QAAC,IAAI,IAAI;QAAO,IAAI,IAAI;KAAO,GAC/B;QAAC,IAAI,IAAI;QAAQ,IAAI,IAAI;KAAM;IAErC,KAAK,MAAM,QAAQ,OAAQ;QACzB,IAAI,CAAC,MAAM,GAAG,CAAC,OAAO;YACpB,OAAO,MAAM,CAAC;QAChB;IACF;IAEA,OAAO;WAAI;KAAO;AACpB","ignoreList":[0]}},
    {"offset": {"line": 58, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40web3-storage/capabilities/node_modules/%40ucanto/validator/src/error.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport { the } from './util.js'\nimport { isLink } from '@ucanto/core/link'\nimport { fail, Failure } from '@ucanto/core/result'\n\nexport { Failure, fail }\n\nexport class EscalatedCapability extends Failure {\n  /**\n   * @param {API.ParsedCapability} claimed\n   * @param {object} delegated\n   * @param {API.Failure} cause\n   */\n  constructor(claimed, delegated, cause) {\n    super()\n    this.claimed = claimed\n    this.delegated = delegated\n    this.cause = cause\n    this.name = the('EscalatedCapability')\n  }\n  describe() {\n    return `Constraint violation: ${this.cause.message}`\n  }\n}\n\n/**\n * @implements {API.DelegationError}\n */\nexport class DelegationError extends Failure {\n  /**\n   * @param {(API.InvalidCapability | API.EscalatedDelegation | API.DelegationError)[]} causes\n   * @param {object} context\n   */\n  constructor(causes, context) {\n    super()\n    this.name = the('InvalidClaim')\n    this.causes = causes\n    this.context = context\n  }\n  describe() {\n    return [\n      `Can not derive ${this.context} from delegated capabilities:`,\n      ...this.causes.map(cause => li(cause.message)),\n    ].join('\\n')\n  }\n\n  /**\n   * @type {API.InvalidCapability | API.EscalatedDelegation | API.DelegationError}\n   */\n  get cause() {\n    /* c8 ignore next 9 */\n    if (this.causes.length !== 1) {\n      return this\n    } else {\n      const [cause] = this.causes\n      const value = cause.name === 'InvalidClaim' ? cause.cause : cause\n      Object.defineProperties(this, { cause: { value } })\n      return value\n    }\n  }\n}\n\n/**\n * @implements {API.SessionEscalation}\n */\nexport class SessionEscalation extends Failure {\n  /**\n   * @param {object} source\n   * @param {API.Delegation} source.delegation\n   * @param {API.Failure} source.cause\n   */\n  constructor({ delegation, cause }) {\n    super()\n    this.name = the('SessionEscalation')\n    this.delegation = delegation\n    this.cause = cause\n  }\n  describe() {\n    const issuer = this.delegation.issuer.did()\n    return [\n      `Delegation ${this.delegation.cid} issued by ${issuer} has an invalid session`,\n      li(this.cause.message),\n    ].join('\\n')\n  }\n}\n\n/**\n * @implements {API.InvalidSignature}\n */\nexport class InvalidSignature extends Failure {\n  /**\n   * @param {API.Delegation} delegation\n   * @param {API.Verifier} verifier\n   */\n  constructor(delegation, verifier) {\n    super()\n    this.name = the('InvalidSignature')\n    this.delegation = delegation\n    this.verifier = verifier\n  }\n  get issuer() {\n    return this.delegation.issuer\n  }\n  get audience() {\n    return this.delegation.audience\n  }\n  get key() {\n    return this.verifier.toDIDKey()\n  }\n  describe() {\n    const issuer = this.issuer.did()\n    const key = this.key\n    return (\n      issuer.startsWith('did:key')\n        ? [\n            `Proof ${this.delegation.cid} does not has a valid signature from ${key}`,\n          ]\n        : [\n            `Proof ${this.delegation.cid} issued by ${issuer} does not has a valid signature from ${key}`,\n            `  ℹ️ Probably issuer signed with a different key, which got rotated, invalidating delegations that were issued with prior keys`,\n          ]\n    ).join('\\n')\n  }\n}\n\n/**\n * @implements {API.UnavailableProof}\n */\nexport class UnavailableProof extends Failure {\n  /**\n   * @param {API.UCAN.Link} link\n   * @param {Error} [cause]\n   */\n  constructor(link, cause) {\n    super()\n    this.name = the('UnavailableProof')\n    this.link = link\n    this.cause = cause\n  }\n  describe() {\n    return [\n      `Linked proof '${this.link}' is not included and could not be resolved`,\n      ...(this.cause\n        ? [li(`Proof resolution failed with: ${this.cause.message}`)]\n        : []),\n    ].join('\\n')\n  }\n}\n\nexport class DIDKeyResolutionError extends Failure {\n  /**\n   * @param {API.UCAN.DID} did\n   * @param {API.Failure} [cause]\n   */\n  constructor(did, cause) {\n    super()\n    this.name = the('DIDKeyResolutionError')\n    this.did = did\n    this.cause = cause\n  }\n  describe() {\n    return `Unable to resolve '${this.did}' key`\n  }\n}\n\n/**\n * @implements {API.InvalidAudience}\n */\nexport class PrincipalAlignmentError extends Failure {\n  /**\n   * @param {API.UCAN.Principal} audience\n   * @param {API.Delegation} delegation\n   */\n  constructor(audience, delegation) {\n    super()\n    this.name = the('InvalidAudience')\n    this.audience = audience\n    this.delegation = delegation\n  }\n  describe() {\n    return `Delegation audience is '${this.delegation.audience.did()}' instead of '${this.audience.did()}'`\n  }\n  toJSON() {\n    const { name, audience, message, stack } = this\n    return {\n      name,\n      audience: audience.did(),\n      delegation: { audience: this.delegation.audience.did() },\n      message,\n      stack,\n    }\n  }\n}\n\n/**\n * @implements {API.MalformedCapability}\n */\nexport class MalformedCapability extends Failure {\n  /**\n   * @param {API.Capability} capability\n   * @param {API.Failure} cause\n   */\n  constructor(capability, cause) {\n    super()\n    this.name = the('MalformedCapability')\n    this.capability = capability\n    this.cause = cause\n  }\n  describe() {\n    return [\n      `Encountered malformed '${this.capability.can}' capability: ${format(\n        this.capability\n      )}`,\n      li(this.cause.message),\n    ].join('\\n')\n  }\n}\n\nexport class UnknownCapability extends Failure {\n  /**\n   * @param {API.Capability} capability\n   */\n  constructor(capability) {\n    super()\n    this.name = the('UnknownCapability')\n    this.capability = capability\n  }\n  /* c8 ignore next 3 */\n  describe() {\n    return `Encountered unknown capability: ${format(this.capability)}`\n  }\n}\n\nexport class Expired extends Failure {\n  /**\n   * @param {API.Delegation & { expiration: number }} delegation\n   */\n  constructor(delegation) {\n    super()\n    this.name = the('Expired')\n    this.delegation = delegation\n  }\n  describe() {\n    return `Proof ${this.delegation.cid} has expired on ${new Date(\n      this.delegation.expiration * 1000\n    )}`\n  }\n  get expiredAt() {\n    return this.delegation.expiration\n  }\n  toJSON() {\n    const { name, expiredAt, message, stack } = this\n    return {\n      name,\n      message,\n      expiredAt,\n      stack,\n    }\n  }\n}\n\n/**\n * @implements {API.Revoked}\n */\nexport class Revoked extends Failure {\n  /**\n   * @param {API.Delegation} delegation\n   */\n  constructor(delegation) {\n    super()\n    this.name = the('Revoked')\n    this.delegation = delegation\n  }\n  describe() {\n    return `Proof ${this.delegation.cid} has been revoked`\n  }\n  toJSON() {\n    const { name, message, stack } = this\n    return {\n      name,\n      message,\n      stack,\n    }\n  }\n}\n\nexport class NotValidBefore extends Failure {\n  /**\n   * @param {API.Delegation & { notBefore: number }} delegation\n   */\n  constructor(delegation) {\n    super()\n    this.name = the('NotValidBefore')\n    this.delegation = delegation\n  }\n  describe() {\n    return `Proof ${this.delegation.cid} is not valid before ${new Date(\n      this.delegation.notBefore * 1000\n    )}`\n  }\n  get validAt() {\n    return this.delegation.notBefore\n  }\n  toJSON() {\n    const { name, validAt, message, stack } = this\n    return {\n      name,\n      message,\n      validAt,\n      stack,\n    }\n  }\n}\n\n/**\n * @implements {API.Unauthorized}\n */\n\nexport class Unauthorized extends Failure {\n  /**\n   * @param {{\n   * capability: API.CapabilityParser\n   * delegationErrors: API.DelegationError[]\n   * unknownCapabilities: API.Capability[]\n   * invalidProofs: API.InvalidProof[]\n   * failedProofs: API.InvalidClaim[]\n   * }} cause\n   */\n  constructor({\n    capability,\n    delegationErrors,\n    unknownCapabilities,\n    invalidProofs,\n    failedProofs,\n  }) {\n    super()\n    this.name = /** @type {const} */  ('Unauthorized')\n    this.capability = capability\n    this.delegationErrors = delegationErrors\n    this.unknownCapabilities = unknownCapabilities\n    this.invalidProofs = invalidProofs\n    this.failedProofs = failedProofs\n  }\n\n  describe() {\n    const errors = [\n      ...this.failedProofs.map(error => li(error.message)),\n      ...this.delegationErrors.map(error => li(error.message)),\n      ...this.invalidProofs.map(error => li(error.message)),\n    ]\n\n    const unknown = this.unknownCapabilities.map(c => li(JSON.stringify(c)))\n\n    return [\n      `Claim ${this.capability} is not authorized`,\n      ...(errors.length > 0\n        ? errors\n        : [li(`No matching delegated capability found`)]),\n      ...(unknown.length > 0\n        ? [li(`Encountered unknown capabilities\\n${unknown.join('\\n')}`)]\n        : []),\n    ].join('\\n')\n  }\n}\n\n/**\n * @param {unknown} capability\n * @param {string|number} [space]\n */\n\nconst format = (capability, space) =>\n  JSON.stringify(\n    capability,\n    (_key, value) => {\n      /* c8 ignore next 2 */\n      if (isLink(value)) {\n        return value.toString()\n      } else {\n        return value\n      }\n    },\n    space\n  )\n\n/**\n * @param {string} message\n */\nexport const indent = (message, indent = '  ') =>\n  `${indent}${message.split('\\n').join(`\\n${indent}`)}`\n\n/**\n * @param {string} message\n */\nexport const li = message => indent(`- ${message}`)\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 406, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40web3-storage/capabilities/node_modules/%40ucanto/validator/src/capability.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport { entries, combine, intersection } from './util.js'\nimport {\n  EscalatedCapability,\n  MalformedCapability,\n  UnknownCapability,\n  DelegationError as MatchError,\n} from './error.js'\nimport { invoke, delegate, Schema } from '@ucanto/core'\n\n/**\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @typedef {{\n * can: A\n * with: API.Reader<R, API.Resource, API.Failure>\n * nb?: Schema.MapRepresentation<C, unknown>\n * derives?: (claim: {can:A, with: R, nb: C}, proof:{can:A, with:R, nb:C}) => API.Result<{}, API.Failure>\n * }} Descriptor\n */\n\n/**\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} [C={}]\n * @param {Descriptor<A, R, C>} descriptor\n \n * @returns {API.TheCapabilityParser<API.CapabilityMatch<A, R, C>>}\n */\nexport const capability = ({\n  derives = defaultDerives,\n  nb = defaultNBSchema,\n  ...etc\n}) => new Capability({ derives, nb, ...etc })\n\nconst defaultNBSchema =\n  /** @type {Schema.MapRepresentation<any>} */\n  (Schema.struct({}))\n\n/**\n * @template {API.Match} M\n * @template {API.Match} W\n * @param {API.Matcher<M>} left\n * @param {API.Matcher<W>} right\n * @returns {API.CapabilityParser<M|W>}\n */\nexport const or = (left, right) => new Or(left, right)\n\n/**\n * @template {API.MatchSelector<API.Match>[]} Selectors\n * @param {Selectors} selectors\n * @returns {API.CapabilitiesParser<API.InferMembers<Selectors>>}\n */\nexport const and = (...selectors) => new And(selectors)\n\n/**\n * @template {API.Match} M\n * @template {API.ParsedCapability} T\n * @param {object} source\n * @param {API.MatchSelector<M>} source.from\n * @param {API.TheCapabilityParser<API.DirectMatch<T>>} source.to\n * @param {API.Derives<T, API.InferDeriveProof<M['value']>>} source.derives\n \n * @returns {API.TheCapabilityParser<API.DerivedMatch<T, M>>}\n */\nexport const derive = ({ from, to, derives }) => new Derive(from, to, derives)\n\n/**\n * @template {API.Match} M\n * @implements {API.View<M>}\n */\nclass View {\n  /**\n   * @param {API.Source} source\n   * @returns {API.MatchResult<M>}\n   */\n  /* c8 ignore next 3 */\n  match(source) {\n    return { error: new UnknownCapability(source.capability) }\n  }\n\n  /**\n   * @param {API.Source[]} capabilities\n   * @returns {API.Select<M>}\n   */\n  select(capabilities) {\n    return select(this, capabilities)\n  }\n\n  /**\n   * @template {API.ParsedCapability} U\n   * @param {object} source\n   * @param {API.TheCapabilityParser<API.DirectMatch<U>>} source.to\n   * @param {API.Derives<U, API.InferDeriveProof<M['value']>>} source.derives\n   * @returns {API.TheCapabilityParser<API.DerivedMatch<U, M>>}\n   */\n  derive({ derives, to }) {\n    return derive({ derives, to, from: this })\n  }\n}\n\n/**\n * @template {API.Match} M\n * @implements {API.CapabilityParser<M>}\n * @extends {View<M>}\n */\nclass Unit extends View {\n  /**\n   * @template {API.Match} W\n   * @param {API.MatchSelector<W>} other\n   * @returns {API.CapabilityParser<M | W>}\n   */\n  or(other) {\n    return or(this, other)\n  }\n\n  /**\n   * @template {API.Match} W\n   * @param {API.CapabilityParser<W>} other\n   * @returns {API.CapabilitiesParser<[M, W]>}\n   */\n  and(other) {\n    return and(/** @type {API.CapabilityParser<M>} */ (this), other)\n  }\n}\n\n/**\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @implements {API.TheCapabilityParser<API.DirectMatch<API.ParsedCapability<A, R, C>>>}\n * @extends {Unit<API.DirectMatch<API.ParsedCapability<A, R, C>>>}\n */\nclass Capability extends Unit {\n  /**\n   * @param {Required<Descriptor<A, R, C>>} descriptor\n   */\n  constructor(descriptor) {\n    super()\n    this.descriptor = descriptor\n    this.schema = Schema.struct({\n      can: Schema.literal(descriptor.can),\n      with: descriptor.with,\n      nb: descriptor.nb,\n    })\n  }\n\n  /**\n   * @param {API.InferCreateOptions<R, C>} options\n   */\n  create(options) {\n    const { descriptor, can } = this\n    const decoders = descriptor.nb\n    const data = /** @type {C} */ (options.nb || {})\n\n    const resource = descriptor.with.read(options.with)\n    if (resource.error) {\n      throw Object.assign(\n        new Error(`Invalid 'with' - ${resource.error.message}`),\n        {\n          cause: resource,\n        }\n      )\n    }\n\n    const nb = descriptor.nb.read(data)\n    if (nb.error) {\n      throw Object.assign(new Error(`Invalid 'nb' - ${nb.error.message}`), {\n        cause: nb,\n      })\n    }\n\n    return createCapability({ can, with: resource.ok, nb: nb.ok })\n  }\n\n  /**\n   * @param {API.InferInvokeOptions<R, C>} options\n   */\n  invoke({ with: with_, nb, ...options }) {\n    return invoke({\n      ...options,\n      capability: this.create(\n        /** @type {API.InferCreateOptions<R, C>} */\n        ({ with: with_, nb })\n      ),\n    })\n  }\n\n  /**\n   * @param {API.InferDelegationOptions<R, C>} options\n   * @returns {Promise<API.Delegation<[API.InferDelegatedCapability<API.ParsedCapability<A, R, C>>]>>}\n   */\n  async delegate({ nb: input = {}, with: with_, ...options }) {\n    const { descriptor, can } = this\n    const readers = descriptor.nb\n\n    const resource = descriptor.with.read(with_)\n    if (resource.error) {\n      throw Object.assign(\n        new Error(`Invalid 'with' - ${resource.error.message}`),\n        {\n          cause: resource,\n        }\n      )\n    }\n\n    const nb = descriptor.nb.partial().read(input)\n    if (nb.error) {\n      throw Object.assign(new Error(`Invalid 'nb' - ${nb.error.message}`), {\n        cause: nb,\n      })\n    }\n\n    return delegate({\n      capabilities: [createCapability({ can, with: resource.ok, nb: nb.ok })],\n      ...options,\n    })\n  }\n\n  get can() {\n    return this.descriptor.can\n  }\n\n  /**\n   * @param {API.Source} source\n   * @returns {API.MatchResult<API.DirectMatch<API.ParsedCapability<A, R, C>>>}\n   */\n  match(source) {\n    const result = parseCapability(this.descriptor, source)\n    return result.error\n      ? result\n      : { ok: new Match(source, result.ok, this.descriptor) }\n  }\n  toString() {\n    return JSON.stringify({ can: this.descriptor.can })\n  }\n}\n\n/**\n * Normalizes capability by removing empty nb field.\n *\n * @template {API.ParsedCapability} T\n * @param {T} source\n */\n\nconst createCapability = ({ can, with: with_, nb }) =>\n  /** @type {API.InferCapability<T>} */ ({\n    can,\n    with: with_,\n    ...(isEmpty(nb) ? {} : { nb }),\n  })\n\n/**\n * @param {object} object\n * @returns {object is {}}\n */\nconst isEmpty = object => {\n  for (const _ in object) {\n    return false\n  }\n  return true\n}\n\n/**\n * @template {API.Match} M\n * @template {API.Match} W\n * @implements {API.CapabilityParser<M|W>}\n * @extends {Unit<M|W>}\n */\nclass Or extends Unit {\n  /**\n   * @param {API.Matcher<M>} left\n   * @param {API.Matcher<W>} right\n   */\n  constructor(left, right) {\n    super()\n    this.left = left\n    this.right = right\n  }\n\n  /**\n   * @param {API.Source} capability\n   * @return {API.MatchResult<M|W>}\n   */\n  match(capability) {\n    const left = this.left.match(capability)\n    if (left.error) {\n      const right = this.right.match(capability)\n      if (right.error) {\n        return right.error.name === 'MalformedCapability'\n          ? //\n            right\n          : //\n            left\n      } else {\n        return right\n      }\n    } else {\n      return left\n    }\n  }\n\n  toString() {\n    return `${this.left.toString()}|${this.right.toString()}`\n  }\n}\n\n/**\n * @template {API.MatchSelector<API.Match>[]} Selectors\n * @implements {API.CapabilitiesParser<API.InferMembers<Selectors>>}\n * @extends {View<API.Amplify<API.InferMembers<Selectors>>>}\n */\nclass And extends View {\n  /**\n   * @param {Selectors} selectors\n   */\n  constructor(selectors) {\n    super()\n    this.selectors = selectors\n  }\n  /**\n   * @param {API.Source} capability\n   * @returns {API.MatchResult<API.Amplify<API.InferMembers<Selectors>>>}\n   */\n  match(capability) {\n    const group = []\n    for (const selector of this.selectors) {\n      const result = selector.match(capability)\n      if (result.error) {\n        return result\n      } else {\n        group.push(result.ok)\n      }\n    }\n\n    return {\n      ok: new AndMatch(/** @type {API.InferMembers<Selectors>} */ (group)),\n    }\n  }\n\n  /**\n   * @param {API.Source[]} capabilities\n   */\n  select(capabilities) {\n    return selectGroup(this, capabilities)\n  }\n  /**\n   * @template E\n   * @template {API.Match} X\n   * @param {API.MatchSelector<API.Match<E, X>>} other\n   * @returns {API.CapabilitiesParser<[...API.InferMembers<Selectors>, API.Match<E, X>]>}\n   */\n  and(other) {\n    return new And([...this.selectors, other])\n  }\n  toString() {\n    return `[${this.selectors.map(String).join(', ')}]`\n  }\n}\n\n/**\n * @template {API.ParsedCapability} T\n * @template {API.Match} M\n * @implements {API.TheCapabilityParser<API.DerivedMatch<T, M>>}\n * @extends {Unit<API.DerivedMatch<T, M>>}\n */\n\nclass Derive extends Unit {\n  /**\n   * @param {API.MatchSelector<M>} from\n   * @param {API.TheCapabilityParser<API.DirectMatch<T>>} to\n   * @param {API.Derives<T, API.InferDeriveProof<M['value']>>} derives\n   */\n  constructor(from, to, derives) {\n    super()\n    this.from = from\n    this.to = to\n    this.derives = derives\n  }\n\n  /**\n   * @type {typeof this.to['create']}\n   */\n  create(options) {\n    return this.to.create(options)\n  }\n  /**\n   * @type {typeof this.to['invoke']}\n   */\n  invoke(options) {\n    return this.to.invoke(options)\n  }\n  /**\n   * @type {typeof this.to['delegate']}\n   */\n  delegate(options) {\n    return this.to.delegate(options)\n  }\n  get can() {\n    return this.to.can\n  }\n  /**\n   * @param {API.Source} capability\n   * @returns {API.MatchResult<API.DerivedMatch<T, M>>}\n   */\n  match(capability) {\n    const match = this.to.match(capability)\n    if (match.error) {\n      return match\n    } else {\n      return { ok: new DerivedMatch(match.ok, this.from, this.derives) }\n    }\n  }\n  toString() {\n    return this.to.toString()\n  }\n}\n\n/**\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @implements {API.DirectMatch<API.ParsedCapability<A, R, C>>}\n */\nclass Match {\n  /**\n   * @param {API.Source} source\n   * @param {API.ParsedCapability<A, R, C>} value\n   * @param {Required<Descriptor<A, R, C>>} descriptor\n   */\n  constructor(source, value, descriptor) {\n    this.source = [source]\n    this.value = value\n    this.descriptor = descriptor\n  }\n  get can() {\n    return this.value.can\n  }\n\n  get proofs() {\n    const proofs = [this.source[0].delegation]\n    Object.defineProperties(this, {\n      proofs: { value: proofs },\n    })\n    return proofs\n  }\n\n  /**\n   * @param {API.CanIssue} context\n   * @returns {API.DirectMatch<API.ParsedCapability<A, R, C>>|null}\n   */\n  prune(context) {\n    if (context.canIssue(this.value, this.source[0].delegation.issuer.did())) {\n      return null\n    } else {\n      return this\n    }\n  }\n\n  /**\n   * @param {API.Source[]} capabilities\n   * @returns {API.Select<API.DirectMatch<API.ParsedCapability<A, R, C>>>}\n   */\n  select(capabilities) {\n    const unknown = []\n    const errors = []\n    const matches = []\n    for (const capability of capabilities) {\n      const result = resolveCapability(this.descriptor, this.value, capability)\n      if (result.ok) {\n        const claim = this.descriptor.derives(this.value, result.ok)\n        if (claim.error) {\n          errors.push(\n            new MatchError(\n              [new EscalatedCapability(this.value, result.ok, claim.error)],\n              this\n            )\n          )\n        } else {\n          matches.push(new Match(capability, result.ok, this.descriptor))\n        }\n      } else {\n        switch (result.error.name) {\n          case 'UnknownCapability':\n            unknown.push(result.error.capability)\n            break\n          case 'MalformedCapability':\n          default:\n            errors.push(new MatchError([result.error], this))\n        }\n      }\n    }\n\n    return { matches, unknown, errors }\n  }\n  toString() {\n    const { nb } = this.value\n    return JSON.stringify({\n      can: this.descriptor.can,\n      with: this.value.with,\n      nb: nb && Object.keys(nb).length > 0 ? nb : undefined,\n    })\n  }\n}\n\n/**\n * @template {API.ParsedCapability} T\n * @template {API.Match} M\n * @implements {API.DerivedMatch<T, M>}\n */\n\nclass DerivedMatch {\n  /**\n   * @param {API.DirectMatch<T>} selected\n   * @param {API.MatchSelector<M>} from\n   * @param {API.Derives<T, API.InferDeriveProof<M['value']>>} derives\n   */\n  constructor(selected, from, derives) {\n    this.selected = selected\n    this.from = from\n    this.derives = derives\n  }\n  get can() {\n    return this.value.can\n  }\n  get source() {\n    return this.selected.source\n  }\n  get proofs() {\n    const proofs = []\n    for (const { delegation } of this.selected.source) {\n      proofs.push(delegation)\n    }\n    Object.defineProperties(this, { proofs: { value: proofs } })\n    return proofs\n  }\n  get value() {\n    return this.selected.value\n  }\n\n  /**\n   * @param {API.CanIssue} context\n   */\n  prune(context) {\n    const selected =\n      /** @type {API.DirectMatch<T>|null} */\n      (this.selected.prune(context))\n    return selected ? new DerivedMatch(selected, this.from, this.derives) : null\n  }\n\n  /**\n   * @param {API.Source[]} capabilities\n   */\n  select(capabilities) {\n    const { derives, selected, from } = this\n    const { value } = selected\n\n    const direct = selected.select(capabilities)\n\n    const derived = from.select(capabilities)\n    const matches = []\n    const errors = []\n    for (const match of derived.matches) {\n      // If capability can not be derived it escalates\n      const result = derives(value, match.value)\n      if (result.error) {\n        errors.push(\n          new MatchError(\n            [new EscalatedCapability(value, match.value, result.error)],\n            this\n          )\n        )\n      } else {\n        matches.push(match)\n      }\n    }\n\n    return {\n      unknown: intersection(direct.unknown, derived.unknown),\n      errors: [\n        ...errors,\n        ...direct.errors,\n        ...derived.errors.map(error => new MatchError([error], this)),\n      ],\n      matches: [\n        ...direct.matches.map(match => new DerivedMatch(match, from, derives)),\n        ...matches,\n      ],\n    }\n  }\n\n  toString() {\n    return this.selected.toString()\n  }\n}\n\n/**\n * @template {API.MatchSelector<API.Match>[]} Selectors\n * @implements {API.Amplify<API.InferMembers<Selectors>>}\n */\nclass AndMatch {\n  /**\n   * @param {API.Match[]} matches\n   */\n  constructor(matches) {\n    this.matches = matches\n  }\n  get selectors() {\n    return this.matches\n  }\n  /**\n   * @returns {API.Source[]}\n   */\n  get source() {\n    const source = []\n\n    for (const match of this.matches) {\n      source.push(...match.source)\n    }\n    Object.defineProperties(this, { source: { value: source } })\n    return source\n  }\n\n  /**\n   * @param {API.CanIssue} context\n   */\n  prune(context) {\n    const matches = []\n    for (const match of this.matches) {\n      const pruned = match.prune(context)\n      if (pruned) {\n        matches.push(pruned)\n      }\n    }\n    return matches.length === 0 ? null : new AndMatch(matches)\n  }\n\n  get proofs() {\n    const proofs = []\n\n    for (const { delegation } of this.source) {\n      proofs.push(delegation)\n    }\n\n    Object.defineProperties(this, { proofs: { value: proofs } })\n    return proofs\n  }\n  /**\n   * @type {API.InferValue<API.InferMembers<Selectors>>}\n   */\n  get value() {\n    const value = []\n\n    for (const match of this.matches) {\n      value.push(match.value)\n    }\n    Object.defineProperties(this, { value: { value } })\n    return /** @type {any} */ (value)\n  }\n  /**\n   * @param {API.Source[]} capabilities\n   */\n  select(capabilities) {\n    return selectGroup(this, capabilities)\n  }\n  toString() {\n    return `[${this.matches.map(match => match.toString()).join(', ')}]`\n  }\n}\n\n/**\n * Resolves ability `pattern` of the delegated capability from the ability\n * of the claimed capability. If pattern matches returns claimed ability\n * otherwise returns given `fallback`.\n *\n * @example\n * ```js\n * resolveAbility('*', 'store/add', null) // => 'store/add'\n * resolveAbility('store/*', 'store/add', null) // => 'store/add'\n * resolveAbility('store/add', 'store/add', null) // => 'store/add'\n * resolveAbility('store/', 'store/add', null) // => null\n * resolveAbility('store/a*', 'store/add', null) // => null\n * resolveAbility('store/list', 'store/add', null) // => null\n * ```\n *\n * @template {API.Ability} T\n * @template U\n * @param {string} pattern\n * @param {T} can\n * @param {U} fallback\n * @returns {T|U}\n */\nconst resolveAbility = (pattern, can, fallback) => {\n  switch (pattern) {\n    case can:\n    case '*':\n      return can\n    default:\n      return pattern.endsWith('/*') && can.startsWith(pattern.slice(0, -1))\n        ? can\n        : fallback\n  }\n}\n\n/**\n * Resolves `source` resource of the delegated capability from the resource\n * `uri` of the claimed capability. If `source` is `\"ucan:*\"\"` or matches `uri`\n * then it returns `uri` back otherwise it returns `fallback`.\n *\n * @example\n * ```js\n * resolveResource('ucan:*', 'did:key:zAlice', null) // => 'did:key:zAlice'\n * resolveAbility('ucan:*', 'https://example.com', null) // => 'https://example.com'\n * resolveAbility('did:*', 'did:key:zAlice', null) // => null\n * resolveAbility('did:key:zAlice', 'did:key:zAlice', null) // => did:key:zAlice\n * ```\n * @template {string} T\n * @template U\n * @param {T} uri\n * @param {string} source\n * @param {U} fallback\n * @returns {T|U}\n */\nconst resolveResource = (source, uri, fallback) => {\n  switch (source) {\n    case uri:\n    case 'ucan:*':\n      return uri\n    default:\n      return fallback\n  }\n}\n\n/**\n * Parses capability from the `source` using a provided `parser`.\n *\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @param {Required<Descriptor<A, R, C>>} descriptor\n * @param {API.Source} source\n * @returns {API.Result<API.ParsedCapability<A, R, C>, API.InvalidCapability>}\n */\nconst parseCapability = (descriptor, source) => {\n  const { delegation } = source\n  const capability = /** @type {API.Capability<A, R, C>} */ (source.capability)\n\n  if (descriptor.can !== capability.can) {\n    return { error: new UnknownCapability(capability) }\n  }\n\n  const uri = descriptor.with.read(capability.with)\n  if (uri.error) {\n    return { error: new MalformedCapability(capability, uri.error) }\n  }\n\n  const nb = descriptor.nb.read(capability.nb || {})\n  if (nb.error) {\n    return { error: new MalformedCapability(capability, nb.error) }\n  }\n\n  return { ok: new CapabilityView(descriptor.can, uri.ok, nb.ok, delegation) }\n}\n\n/**\n * Resolves delegated capability `source` from the `claimed` capability using\n * provided capability `parser`. It is similar to `parseCapability` except\n * `source` here is treated as capability pattern which is matched against the\n * `claimed` capability. This means we resolve `can` and `with` fields from the\n * `claimed` capability and inherit all missing `nb` fields from the claimed\n * capability.\n *\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @param {Required<Descriptor<A, R, C>>} descriptor\n * @param {API.ParsedCapability<A, R, C>} claimed\n * @param {API.Source} source\n * @returns {API.Result<API.ParsedCapability<A, R, C>, API.InvalidCapability>}\n */\n\nconst resolveCapability = (descriptor, claimed, { capability, delegation }) => {\n  const can = resolveAbility(capability.can, claimed.can, null)\n  if (can == null) {\n    return { error: new UnknownCapability(capability) }\n  }\n\n  const resource = resolveResource(\n    capability.with,\n    claimed.with,\n    capability.with\n  )\n  const uri = descriptor.with.read(resource)\n  if (uri.error) {\n    return { error: new MalformedCapability(capability, uri.error) }\n  }\n\n  const nb = descriptor.nb.read({\n    ...claimed.nb,\n    ...capability.nb,\n  })\n\n  if (nb.error) {\n    return { error: new MalformedCapability(capability, nb.error) }\n  }\n\n  return { ok: new CapabilityView(can, uri.ok, nb.ok, delegation) }\n}\n\n/**\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template C\n */\nclass CapabilityView {\n  /**\n   * @param {A} can\n   * @param {R} with_\n   * @param {C} nb\n   * @param {API.Delegation} delegation\n   */\n  constructor(can, with_, nb, delegation) {\n    this.can = can\n    this.with = with_\n    this.delegation = delegation\n    this.nb = nb\n  }\n}\n\n/**\n * @template {API.Match} M\n * @param {API.Matcher<M>} matcher\n * @param {API.Source[]} capabilities\n * @returns {API.Select<M>}\n */\n\nconst select = (matcher, capabilities) => {\n  const unknown = []\n  const matches = []\n  const errors = []\n  for (const capability of capabilities) {\n    const result = matcher.match(capability)\n    if (result.error) {\n      switch (result.error.name) {\n        case 'UnknownCapability':\n          unknown.push(result.error.capability)\n          break\n        case 'MalformedCapability':\n        default:\n          errors.push(new MatchError([result.error], result.error.capability))\n      }\n    } else {\n      matches.push(result.ok)\n    }\n  }\n\n  return { matches, errors, unknown }\n}\n\n/**\n * @template {API.Selector<API.Match>[]} S\n * @param {{selectors:S}} self\n * @param {API.Source[]} capabilities\n */\n\nconst selectGroup = (self, capabilities) => {\n  let unknown\n  const data = []\n  const errors = []\n  for (const selector of self.selectors) {\n    const selected = selector.select(capabilities)\n    unknown = unknown\n      ? intersection(unknown, selected.unknown)\n      : selected.unknown\n\n    for (const error of selected.errors) {\n      errors.push(new MatchError([error], self))\n    }\n\n    data.push(selected.matches)\n  }\n\n  const matches = combine(data).map(group => new AndMatch(group))\n\n  return {\n    unknown:\n      /* c8 ignore next */\n      unknown || [],\n    errors,\n    matches,\n  }\n}\n\n/**\n * @template {API.ParsedCapability} T\n * @template {API.ParsedCapability} U\n * @param {T} claimed\n * @param {U} delegated\n * @return {API.Result<true, API.Failure>}\n */\nconst defaultDerives = (claimed, delegated) => {\n  if (delegated.with.endsWith('*')) {\n    if (!claimed.with.startsWith(delegated.with.slice(0, -1))) {\n      return Schema.error(\n        `Resource ${claimed.with} does not match delegated ${delegated.with} `\n      )\n    }\n  } else if (delegated.with !== claimed.with) {\n    return Schema.error(\n      `Resource ${claimed.with} is not contained by ${delegated.with}`\n    )\n  }\n\n  /* c8 ignore next 2 */\n  const caveats = delegated.nb || {}\n  const nb = claimed.nb || {}\n  const kv = entries(caveats)\n\n  for (const [name, value] of kv) {\n    if (nb[name] != value) {\n      return Schema.error(`${String(name)}: ${nb[name]} violates ${value}`)\n    }\n  }\n\n  return { ok: true }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1218, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40web3-storage/capabilities/node_modules/%40ucanto/validator/src/authorization.js"],"sourcesContent":["import * as API from '@ucanto/interface'\n\n/**\n * @template {API.ParsedCapability} C\n * @implements {API.Authorization<C>}\n */\nclass Authorization {\n  /**\n   * @param {API.Match<C>} match\n   * @param {API.Authorization<API.ParsedCapability>[]} proofs\n   */\n  constructor(match, proofs) {\n    this.match = match\n    this.proofs = proofs\n  }\n  get capability() {\n    return this.match.value\n  }\n  get delegation() {\n    return this.match.source[0].delegation\n  }\n  get issuer() {\n    return this.delegation.issuer\n  }\n  get audience() {\n    return this.delegation.audience\n  }\n}\n\n/**\n * @template {API.ParsedCapability} C\n * @param {API.Match<C>} match\n * @param {API.Authorization<API.ParsedCapability>[]} proofs\n * @returns {API.Authorization<C>}\n */\nexport const create = (match, proofs = []) => new Authorization(match, proofs)\n\n/**\n *\n * @param {API.Authorization} authorization\n * @returns {Iterable<API.UCANLink>}\n */\nexport const iterate = function* ({ delegation, proofs }) {\n  yield delegation.cid\n  for (const proof of proofs) {\n    yield* iterate(proof)\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;;AAEA;;;CAGC,GACD,MAAM;IACJ;;;GAGC,GACD,YAAY,KAAK,EAAE,MAAM,CAAE;QACzB,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,MAAM,GAAG;IAChB;IACA,IAAI,aAAa;QACf,OAAO,IAAI,CAAC,KAAK,CAAC,KAAK;IACzB;IACA,IAAI,aAAa;QACf,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC,UAAU;IACxC;IACA,IAAI,SAAS;QACX,OAAO,IAAI,CAAC,UAAU,CAAC,MAAM;IAC/B;IACA,IAAI,WAAW;QACb,OAAO,IAAI,CAAC,UAAU,CAAC,QAAQ;IACjC;AACF;AAQO,MAAM,SAAS,CAAC,OAAO,SAAS,EAAE,GAAK,IAAI,cAAc,OAAO;AAOhE,MAAM,UAAU,UAAW,EAAE,UAAU,EAAE,MAAM,EAAE;IACtD,MAAM,WAAW,GAAG;IACpB,KAAK,MAAM,SAAS,OAAQ;QAC1B,OAAO,QAAQ;IACjB;AACF","ignoreList":[0]}},
    {"offset": {"line": 1261, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40web3-storage/capabilities/node_modules/%40ucanto/validator/src/lib.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport { isDelegation, UCAN, ok, fail } from '@ucanto/core'\nimport { capability } from './capability.js'\nimport * as Schema from '@ucanto/core/schema'\nimport * as Authorization from './authorization.js'\nimport {\n  UnavailableProof,\n  Unauthorized,\n  PrincipalAlignmentError,\n  Expired,\n  Revoked,\n  NotValidBefore,\n  InvalidSignature,\n  SessionEscalation,\n  DelegationError,\n  Failure,\n  MalformedCapability,\n  DIDKeyResolutionError,\n  li,\n} from './error.js'\n\nexport { capability } from './capability.js'\nexport * from '@ucanto/core/schema'\n\nexport {\n  Schema,\n  Authorization,\n  Failure,\n  fail,\n  ok,\n  Revoked,\n  UnavailableProof,\n  Unauthorized,\n  MalformedCapability,\n  DIDKeyResolutionError as DIDResolutionError,\n}\n\n/**\n * @param {UCAN.Link} proof\n * @returns {{error:API.UnavailableProof}}\n */\nconst unavailable = proof => ({ error: new UnavailableProof(proof) })\n\n/**\n *\n * @param {UCAN.DID} did\n * @returns {{error:API.DIDKeyResolutionError}}\n */\nconst failDIDKeyResolution = did => ({ error: new DIDKeyResolutionError(did) })\n\n/**\n * @param {Required<API.ClaimOptions>} config\n * @param {API.Match<unknown, API.Match>} match\n */\n\nconst resolveMatch = async (match, config) => {\n  const promises = []\n  const includes = new Set()\n  for (const source of match.source) {\n    const id = source.delegation.cid.toString()\n    if (!includes.has(id)) {\n      promises.push(await resolveSources(source, config))\n    }\n  }\n  const groups = await Promise.all(promises)\n  const sources = []\n  const errors = []\n  for (const group of groups) {\n    sources.push(...group.sources)\n    errors.push(...group.errors)\n  }\n\n  return { sources, errors }\n}\n\n/**\n * Takes `proofs` from the delegation which may contain `Delegation` or a link\n * to one and attempts to resolve links by side loading them. Returns set of\n * resolved `Delegation`s and errors for the proofs that could not be resolved.\n *\n * @param {API.Proof[]} proofs\n * @param {Required<API.ProofResolver>} config\n */\nconst resolveProofs = async (proofs, config) => {\n  /** @type {API.Delegation[]} */\n  const delegations = []\n  /** @type {API.UnavailableProof[]} */\n  const errors = []\n  const promises = []\n  for (const proof of proofs) {\n    // If it is a delegation we can just add it to the resolved set.\n    if (isDelegation(proof)) {\n      delegations.push(proof)\n    }\n    // otherwise we attempt to resolve the link asynchronously. To avoid doing\n    // sequential requests we create promise for each link and then wait for\n    // all of them at the end.\n    else {\n      promises.push(\n        new Promise(async resolve => {\n          // config.resolve is not supposed to throw, but we catch it just in\n          // case it does and consider proof resolution failed.\n          try {\n            const result = await config.resolve(proof)\n            if (result.error) {\n              errors.push(result.error)\n            } else {\n              delegations.push(result.ok)\n            }\n          } catch (error) {\n            errors.push(\n              new UnavailableProof(proof, /** @type {Error} */ (error))\n            )\n          }\n\n          // we don't care about the result, we just need to signal that we are\n          // done with this promise.\n          resolve(null)\n        })\n      )\n    }\n  }\n\n  // Wait for all the promises to resolve. At this point we have collected all\n  // the resolved delegations and errors.\n  await Promise.all(promises)\n  return { delegations, errors }\n}\n\n/**\n * Takes a delegation source and attempts to resolve all the linked proofs.\n *\n * @param {API.Source} from\n * @param {Required<API.ClaimOptions>} config\n * @return {Promise<{sources:API.Source[], errors:ProofError[]}>}\n */\nconst resolveSources = async ({ delegation }, config) => {\n  const errors = []\n  const sources = []\n  const proofs = []\n  // First we attempt to resolve all the linked proofs.\n  const { delegations, errors: failedProofs } = await resolveProofs(\n    delegation.proofs,\n    config\n  )\n\n  // All the proofs that failed to resolve are saved as proof errors.\n  for (const error of failedProofs) {\n    errors.push(new ProofError(error.link, error))\n  }\n\n  // All the proofs that resolved are checked for principal alignment. Ones that\n  // do not align are saved as proof errors.\n  for (const proof of delegations) {\n    // If proof does not delegate to a matching audience save an proof error.\n    if (delegation.issuer.did() !== proof.audience.did()) {\n      errors.push(\n        new ProofError(\n          proof.cid,\n          new PrincipalAlignmentError(delegation.issuer, proof)\n        )\n      )\n    } else {\n      proofs.push(proof)\n    }\n  }\n  // In the second pass we attempt to proofs that were resolved and are aligned.\n  for (const proof of proofs) {\n    // If proof is not valid (expired, not active yet or has incorrect\n    // signature) save a corresponding proof error.\n    const validation = await validate(proof, proofs, config)\n    if (validation.error) {\n      errors.push(new ProofError(proof.cid, validation.error))\n    } else {\n      // otherwise create source objects for it's capabilities, so we could\n      // track which proof in which capability the are from.\n      for (const capability of proof.capabilities) {\n        sources.push(\n          /** @type {API.Source} */ ({\n            capability,\n            delegation: proof,\n          })\n        )\n      }\n    }\n  }\n\n  return { sources, errors }\n}\n\n/**\n * @param {API.ParsedCapability} capability\n * @param {API.DID} issuer\n */\nconst isSelfIssued = (capability, issuer) => capability.with === issuer\n\n/**\n * Finds a valid path in a proof chain of the given `invocation` by exploring\n * every possible option. On success an `Authorization` object is returned that\n * illustrates the valid path. If no valid path is found `Unauthorized` error\n * is returned detailing all explored paths and where they proved to fail.\n *\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {R} URI\n * @template {API.Caveats} C\n * @param {API.Invocation<API.Capability<A, URI, C>>} invocation\n * @param {API.ValidationOptions<API.ParsedCapability<A, R, C>>} options\n * @returns {Promise<API.Result<API.Authorization<API.ParsedCapability<A, R, C>>, API.Unauthorized>>}\n */\nexport const access = async (invocation, { capability, ...config }) =>\n  claim(capability, [invocation], config)\n\n/**\n * Attempts to find a valid proof chain for the claimed `capability` given set\n * of `proofs`. On success an `Authorization` object with detailed proof chain\n * is returned and on failure `Unauthorized` error is returned with details on\n * paths explored and why they have failed.\n *\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @param {API.CapabilityParser<API.Match<API.ParsedCapability<A, R, C>>>} capability\n * @param {API.Proof[]} proofs\n * @param {API.ClaimOptions} config\n * @returns {Promise<API.Result<API.Authorization<API.ParsedCapability<A, R, C>>, API.Unauthorized>>}\n */\nexport const claim = async (\n  capability,\n  proofs,\n  {\n    authority,\n    principal,\n    validateAuthorization,\n    resolveDIDKey = failDIDKeyResolution,\n    canIssue = isSelfIssued,\n    resolve = unavailable,\n    proofs: localProofs = []\n  }\n) => {\n  const config = {\n    canIssue,\n    resolve,\n    principal,\n    capability,\n    authority,\n    validateAuthorization,\n    resolveDIDKey,\n    proofs: localProofs\n  }\n\n  const invalidProofs = []\n\n  /** @type {API.Source[]} */\n  const sources = []\n\n  const { delegations, errors } = await resolveProofs(proofs, config)\n  invalidProofs.push(...errors)\n\n  for (const proof of delegations) {\n    // Validate each proof if valid add ech capability to the list of sources.\n    // otherwise collect the error.\n    const validation = await validate(proof, delegations, config)\n    if (validation.ok) {\n      for (const capability of validation.ok.capabilities.values()) {\n        sources.push(\n          /** @type {API.Source} */ ({\n            capability,\n            delegation: validation.ok,\n          })\n        )\n      }\n    } else {\n      invalidProofs.push(validation.error)\n    }\n  }\n  // look for the matching capability\n  const selection = capability.select(sources)\n\n  const { errors: delegationErrors, unknown: unknownCapabilities } = selection\n  const failedProofs = []\n  for (const matched of selection.matches) {\n    const selector = matched.prune(config)\n    if (selector == null) {\n      const authorization = Authorization.create(matched, [])\n      const result = await validateAuthorization(authorization)\n      if (result.error) {\n        invalidProofs.push(result.error)\n      } else {\n        return { ok: authorization }\n      }\n    } else {\n      const result = await authorize(selector, config)\n      if (result.error) {\n        failedProofs.push(result.error)\n      } else {\n        const authorization = Authorization.create(matched, [result.ok])\n        const approval = await validateAuthorization(authorization)\n        if (approval.error) {\n          invalidProofs.push(approval.error)\n        } else {\n          return { ok: authorization }\n        }\n      }\n    }\n  }\n\n  return {\n    error: new Unauthorized({\n      capability,\n      delegationErrors,\n      unknownCapabilities,\n      invalidProofs,\n      failedProofs,\n    }),\n  }\n}\n\n/**\n * Verifies whether any of the delegated proofs grant give capability.\n *\n * @template {API.Match} Match\n * @param {Match} match\n * @param {Required<API.ClaimOptions>} config\n * @returns {Promise<API.Result<API.Authorization<API.ParsedCapability>, API.InvalidClaim>>}\n */\n\nexport const authorize = async (match, config) => {\n  // load proofs from all delegations\n  const { sources, errors: invalidProofs } = await resolveMatch(match, config)\n\n  const selection = match.select(sources)\n  const { errors: delegationErrors, unknown: unknownCapabilities } = selection\n\n  const failedProofs = []\n  for (const matched of selection.matches) {\n    const selector = matched.prune(config)\n    if (selector == null) {\n      return {\n        ok: Authorization.create(\n          // @ts-expect-error - it may not be a parsed capability but rather a\n          // group of capabilities but we can deal with that in the future.\n          matched,\n          []\n        ),\n      }\n    } else {\n      const result = await authorize(selector, config)\n      if (result.error) {\n        failedProofs.push(result.error)\n      } else {\n        return {\n          ok: Authorization.create(\n            // @ts-expect-error - it may not be a parsed capability but rather a\n            // group of capabilities but we can deal with that in the future.\n            matched,\n            [result.ok]\n          ),\n        }\n      }\n    }\n  }\n\n  return {\n    error: new InvalidClaim({\n      match,\n      delegationErrors,\n      unknownCapabilities,\n      invalidProofs,\n      failedProofs,\n    }),\n  }\n}\n\nclass ProofError extends Failure {\n  /**\n   * @param {API.UCANLink} proof\n   * @param {API.Failure} cause\n   */\n  constructor(proof, cause) {\n    super()\n    this.name = 'ProofError'\n    this.proof = proof\n    this.cause = cause\n  }\n  describe() {\n    return [\n      `Capability can not be derived from prf:${this.proof} because:`,\n      li(this.cause.message),\n    ].join(`\\n`)\n  }\n}\n\n/**\n * @implements {API.InvalidClaim}\n */\nclass InvalidClaim extends Failure {\n  /**\n   * @param {{\n   * match: API.Match\n   * delegationErrors: API.DelegationError[]\n   * unknownCapabilities: API.Capability[]\n   * invalidProofs: ProofError[]\n   * failedProofs: API.InvalidClaim[]\n   * }} info\n   */\n  constructor(info) {\n    super()\n    this.info = info\n    this.name = /** @type {const} */ ('InvalidClaim')\n  }\n  get issuer() {\n    return this.delegation.issuer\n  }\n  get delegation() {\n    return this.info.match.source[0].delegation\n  }\n  describe() {\n    const errors = [\n      ...this.info.failedProofs.map(error => li(error.message)),\n      ...this.info.delegationErrors.map(error => li(error.message)),\n      ...this.info.invalidProofs.map(error => li(error.message)),\n    ]\n\n    const unknown = this.info.unknownCapabilities.map(c =>\n      li(JSON.stringify(c))\n    )\n\n    return [\n      `Capability ${this.info.match} is not authorized because:`,\n      li(`Capability can not be (self) issued by '${this.issuer.did()}'`),\n      ...(errors.length > 0 ? errors : [li(`Delegated capability not found`)]),\n      ...(unknown.length > 0\n        ? [li(`Encountered unknown capabilities\\n${unknown.join('\\n')}`)]\n        : []),\n    ].join('\\n')\n  }\n}\n\n/**\n * Validate a delegation to check it is within the time bound and that it is\n * authorized by the issuer.\n *\n * @template {API.Delegation} T\n * @param {T} delegation\n * @param {API.Delegation[]} proofs\n * @param {Required<API.ClaimOptions>} config\n * @returns {Promise<API.Result<T, API.InvalidProof|API.SessionEscalation|API.DIDKeyResolutionError>>}\n */\nconst validate = async (delegation, proofs, config) => {\n  if (UCAN.isExpired(delegation.data)) {\n    return {\n      error: new Expired(\n        /** @type {API.Delegation & {expiration: number}} */ (delegation)\n      ),\n    }\n  }\n\n  if (UCAN.isTooEarly(delegation.data)) {\n    return {\n      error: new NotValidBefore(\n        /** @type {API.Delegation & {notBefore: number}} */ (delegation)\n      ),\n    }\n  }\n\n  return await verifyAuthorization(delegation, proofs, config)\n}\n\n/**\n * Verifies that delegation has been authorized by the issuer. If issued by the\n * did:key principal checks that the signature is valid. If issued by the root\n * authority checks that the signature is valid. If issued by the principal\n * identified by other DID method attempts to resolve a valid `ucan/attest`\n * attestation from the authority, if attestation is not found falls back to\n * resolving did:key for the issuer and verifying its signature.\n *\n * @template {API.Delegation} T\n * @param {T} delegation\n * @param {API.Delegation[]} proofs\n * @param {Required<API.ClaimOptions>} config\n * @returns {Promise<API.Result<T, API.InvalidSignature|API.SessionEscalation|API.DIDKeyResolutionError>>}\n */\nconst verifyAuthorization = async (delegation, proofs, config) => {\n  const issuer = delegation.issuer.did()\n  // If the issuer is a did:key we just verify a signature\n  if (issuer.startsWith('did:key:')) {\n    return verifySignature(delegation, config.principal.parse(issuer))\n  }\n  // If the issuer is the root authority we use authority itself to verify\n  else if (issuer === config.authority.did()) {\n    return verifySignature(delegation, config.authority)\n  } else {\n    // If issuer is not a did:key principal nor configured authority, we\n    // attempt to resolve embedded authorization session from the authority.\n    const session = await verifySession(delegation, proofs, config)\n    // If we have valid session we consider authorization valid\n    if (session.ok) {\n      return { ok: delegation }\n    } else if (session.error.failedProofs.length > 0) {\n      return {\n        error: new SessionEscalation({ delegation, cause: session.error }),\n      }\n    }\n    // Otherwise we try to resolve did:key from the DID instead\n    // and use that to verify the signature\n    else {\n      const verifier = await config.resolveDIDKey(issuer)\n      if (verifier.error) {\n        return verifier\n      } else {\n        return verifySignature(\n          delegation,\n          config.principal.parse(verifier.ok).withDID(issuer)\n        )\n      }\n    }\n  }\n}\n\n/**\n * @template {API.Delegation} T\n * @param {T} delegation\n * @param {API.Verifier} verifier\n * @returns {Promise<API.Result<T, API.InvalidSignature|API.DIDKeyResolutionError>>}\n */\nconst verifySignature = async (delegation, verifier) => {\n  const valid = await UCAN.verifySignature(delegation.data, verifier)\n  return valid\n    ? { ok: delegation }\n    : { error: new InvalidSignature(delegation, verifier) }\n}\n\n/**\n * Attempts to find an authorization session - an `ucan/attest` capability\n * delegation where `with` matches `config.authority` and `nb.proof`\n * matches given delegation.\n * @see https://github.com/web3-storage/specs/blob/feat/auth+account/w3-session.md#authorization-session\n *\n * @param {API.Delegation} delegation\n * @param {API.Delegation[]} proofs\n * @param {Required<API.ClaimOptions>} config\n */\nconst verifySession = async (delegation, proofs, config) => {\n  // Recognize attestations from all authorized principals, not just authority\n  const withSchemas = config.proofs\n    .filter(p => p.capabilities[0].can === 'ucan/attest' && p.capabilities[0].with === config.authority.did())\n    .map(p => Schema.literal(p.audience.did()))\n\n  const withSchema = withSchemas.length\n    ? Schema.union([Schema.literal(config.authority.did()), ...withSchemas])\n    : Schema.literal(config.authority.did())\n\n  // Create a schema that will match an authorization for this exact delegation\n  const attestation = capability({\n    with: withSchema,\n    can: 'ucan/attest',\n    nb: Schema.struct({\n      proof: Schema.link(delegation.cid),\n    }),\n  })\n\n  return await claim(\n    attestation,\n    proofs\n      // We only consider attestations otherwise we will end up doing an\n      // exponential scan if there are other proofs that require attestations.\n      .filter(isAttestation)\n      // Also filter any proofs that _are_ the delegation we're verifying so\n      // we don't recurse indefinitely.\n      .filter(p => p.cid.toString() !== delegation.cid.toString()),\n    config\n  )\n}\n\n/**\n * Checks if the delegation is an attestation.\n *\n * @param {API.Delegation} proof\n */\nconst isAttestation = proof => proof.capabilities[0]?.can === 'ucan/attest'\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1718, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/validator/src/util.js"],"sourcesContent":["/**\n * @template {string|boolean|number|[unknown, ...unknown[]]} T\n * @param {T} value\n * @returns {T}\n */\nexport const the = value => value\n\n/**\n * @template {{}} O\n * @param {O} object\n * @returns {({ [K in keyof O]: [K, O[K]][] }[keyof O])|[[never, never]]}\n */\n\nexport const entries = object => /** @type {any} */ (Object.entries(object))\n\n/**\n * @template T\n * @param {T[][]} dataset\n * @returns {T[][]}\n */\nexport const combine = ([first, ...rest]) => {\n  const results = first.map(value => [value])\n  for (const values of rest) {\n    const tuples = results.splice(0)\n    for (const value of values) {\n      for (const tuple of tuples) {\n        results.push([...tuple, value])\n      }\n    }\n  }\n  return results\n}\n\n/**\n * @template T\n * @param {T[]} left\n * @param {T[]} right\n * @returns {T[]}\n */\nexport const intersection = (left, right) => {\n  const [result, other] =\n    left.length < right.length\n      ? [new Set(left), new Set(right)]\n      : [new Set(right), new Set(left)]\n\n  for (const item of result) {\n    if (!other.has(item)) {\n      result.delete(item)\n    }\n  }\n\n  return [...result]\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC;;;;;;;;;;AACM,MAAM,MAAM,CAAA,QAAS;AAQrB,MAAM,UAAU,CAAA,SAA8B,OAAO,OAAO,CAAC;AAO7D,MAAM,UAAU,CAAC,CAAC,OAAO,GAAG,KAAK;IACtC,MAAM,UAAU,MAAM,GAAG,CAAC,CAAA,QAAS;YAAC;SAAM;IAC1C,KAAK,MAAM,UAAU,KAAM;QACzB,MAAM,SAAS,QAAQ,MAAM,CAAC;QAC9B,KAAK,MAAM,SAAS,OAAQ;YAC1B,KAAK,MAAM,SAAS,OAAQ;gBAC1B,QAAQ,IAAI,CAAC;uBAAI;oBAAO;iBAAM;YAChC;QACF;IACF;IACA,OAAO;AACT;AAQO,MAAM,eAAe,CAAC,MAAM;IACjC,MAAM,CAAC,QAAQ,MAAM,GACnB,KAAK,MAAM,GAAG,MAAM,MAAM,GACtB;QAAC,IAAI,IAAI;QAAO,IAAI,IAAI;KAAO,GAC/B;QAAC,IAAI,IAAI;QAAQ,IAAI,IAAI;KAAM;IAErC,KAAK,MAAM,QAAQ,OAAQ;QACzB,IAAI,CAAC,MAAM,GAAG,CAAC,OAAO;YACpB,OAAO,MAAM,CAAC;QAChB;IACF;IAEA,OAAO;WAAI;KAAO;AACpB","ignoreList":[0]}},
    {"offset": {"line": 1772, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/validator/src/error.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport { the } from './util.js'\nimport { isLink } from '@ucanto/core/link'\nimport { fail, Failure } from '@ucanto/core/result'\n\nexport { Failure, fail }\n\nexport class EscalatedCapability extends Failure {\n  /**\n   * @param {API.ParsedCapability} claimed\n   * @param {object} delegated\n   * @param {API.Failure} cause\n   */\n  constructor(claimed, delegated, cause) {\n    super()\n    this.claimed = claimed\n    this.delegated = delegated\n    this.cause = cause\n    this.name = the('EscalatedCapability')\n  }\n  describe() {\n    return `Constraint violation: ${this.cause.message}`\n  }\n}\n\n/**\n * @implements {API.DelegationError}\n */\nexport class DelegationError extends Failure {\n  /**\n   * @param {(API.InvalidCapability | API.EscalatedDelegation | API.DelegationError)[]} causes\n   * @param {object} context\n   */\n  constructor(causes, context) {\n    super()\n    this.name = the('InvalidClaim')\n    this.causes = causes\n    this.context = context\n  }\n  describe() {\n    return [\n      `Can not derive ${this.context} from delegated capabilities:`,\n      ...this.causes.map(cause => li(cause.message)),\n    ].join('\\n')\n  }\n\n  /**\n   * @type {API.InvalidCapability | API.EscalatedDelegation | API.DelegationError}\n   */\n  get cause() {\n    /* c8 ignore next 9 */\n    if (this.causes.length !== 1) {\n      return this\n    } else {\n      const [cause] = this.causes\n      const value = cause.name === 'InvalidClaim' ? cause.cause : cause\n      Object.defineProperties(this, { cause: { value } })\n      return value\n    }\n  }\n}\n\n/**\n * @implements {API.SessionEscalation}\n */\nexport class SessionEscalation extends Failure {\n  /**\n   * @param {object} source\n   * @param {API.Delegation} source.delegation\n   * @param {API.Failure} source.cause\n   */\n  constructor({ delegation, cause }) {\n    super()\n    this.name = the('SessionEscalation')\n    this.delegation = delegation\n    this.cause = cause\n  }\n  describe() {\n    const issuer = this.delegation.issuer.did()\n    return [\n      `Delegation ${this.delegation.cid} issued by ${issuer} has an invalid session`,\n      li(this.cause.message),\n    ].join('\\n')\n  }\n}\n\n/**\n * @implements {API.InvalidSignature}\n */\nexport class InvalidSignature extends Failure {\n  /**\n   * @param {API.Delegation} delegation\n   * @param {API.Verifier} verifier\n   */\n  constructor(delegation, verifier) {\n    super()\n    this.name = the('InvalidSignature')\n    this.delegation = delegation\n    this.verifier = verifier\n  }\n  get issuer() {\n    return this.delegation.issuer\n  }\n  get audience() {\n    return this.delegation.audience\n  }\n  get key() {\n    return this.verifier.toDIDKey()\n  }\n  describe() {\n    const issuer = this.issuer.did()\n    const key = this.key\n    return (\n      issuer.startsWith('did:key')\n        ? [\n            `Proof ${this.delegation.cid} does not has a valid signature from ${key}`,\n          ]\n        : [\n            `Proof ${this.delegation.cid} issued by ${issuer} does not has a valid signature from ${key}`,\n            `  ℹ️ Probably issuer signed with a different key, which got rotated, invalidating delegations that were issued with prior keys`,\n          ]\n    ).join('\\n')\n  }\n}\n\n/**\n * @implements {API.UnavailableProof}\n */\nexport class UnavailableProof extends Failure {\n  /**\n   * @param {API.UCAN.Link} link\n   * @param {Error} [cause]\n   */\n  constructor(link, cause) {\n    super()\n    this.name = the('UnavailableProof')\n    this.link = link\n    this.cause = cause\n  }\n  describe() {\n    return [\n      `Linked proof '${this.link}' is not included and could not be resolved`,\n      ...(this.cause\n        ? [li(`Proof resolution failed with: ${this.cause.message}`)]\n        : []),\n    ].join('\\n')\n  }\n}\n\nexport class DIDKeyResolutionError extends Failure {\n  /**\n   * @param {API.UCAN.DID} did\n   * @param {API.Failure} [cause]\n   */\n  constructor(did, cause) {\n    super()\n    this.name = the('DIDKeyResolutionError')\n    this.did = did\n    this.cause = cause\n  }\n  describe() {\n    return `Unable to resolve '${this.did}' key`\n  }\n}\n\n/**\n * @implements {API.InvalidAudience}\n */\nexport class PrincipalAlignmentError extends Failure {\n  /**\n   * @param {API.UCAN.Principal} audience\n   * @param {API.Delegation} delegation\n   */\n  constructor(audience, delegation) {\n    super()\n    this.name = the('InvalidAudience')\n    this.audience = audience\n    this.delegation = delegation\n  }\n  describe() {\n    return `Delegation audience is '${this.delegation.audience.did()}' instead of '${this.audience.did()}'`\n  }\n  toJSON() {\n    const { name, audience, message, stack } = this\n    return {\n      name,\n      audience: audience.did(),\n      delegation: { audience: this.delegation.audience.did() },\n      message,\n      stack,\n    }\n  }\n}\n\n/**\n * @implements {API.MalformedCapability}\n */\nexport class MalformedCapability extends Failure {\n  /**\n   * @param {API.Capability} capability\n   * @param {API.Failure} cause\n   */\n  constructor(capability, cause) {\n    super()\n    this.name = the('MalformedCapability')\n    this.capability = capability\n    this.cause = cause\n  }\n  describe() {\n    return [\n      `Encountered malformed '${this.capability.can}' capability: ${format(\n        this.capability\n      )}`,\n      li(this.cause.message),\n    ].join('\\n')\n  }\n}\n\nexport class UnknownCapability extends Failure {\n  /**\n   * @param {API.Capability} capability\n   */\n  constructor(capability) {\n    super()\n    this.name = the('UnknownCapability')\n    this.capability = capability\n  }\n  /* c8 ignore next 3 */\n  describe() {\n    return `Encountered unknown capability: ${format(this.capability)}`\n  }\n}\n\nexport class Expired extends Failure {\n  /**\n   * @param {API.Delegation & { expiration: number }} delegation\n   */\n  constructor(delegation) {\n    super()\n    this.name = the('Expired')\n    this.delegation = delegation\n  }\n  describe() {\n    return `Proof ${this.delegation.cid} has expired on ${new Date(\n      this.delegation.expiration * 1000\n    )}`\n  }\n  get expiredAt() {\n    return this.delegation.expiration\n  }\n  toJSON() {\n    const { name, expiredAt, message, stack } = this\n    return {\n      name,\n      message,\n      expiredAt,\n      stack,\n    }\n  }\n}\n\n/**\n * @implements {API.Revoked}\n */\nexport class Revoked extends Failure {\n  /**\n   * @param {API.Delegation} delegation\n   */\n  constructor(delegation) {\n    super()\n    this.name = the('Revoked')\n    this.delegation = delegation\n  }\n  describe() {\n    return `Proof ${this.delegation.cid} has been revoked`\n  }\n  toJSON() {\n    const { name, message, stack } = this\n    return {\n      name,\n      message,\n      stack,\n    }\n  }\n}\n\nexport class NotValidBefore extends Failure {\n  /**\n   * @param {API.Delegation & { notBefore: number }} delegation\n   */\n  constructor(delegation) {\n    super()\n    this.name = the('NotValidBefore')\n    this.delegation = delegation\n  }\n  describe() {\n    return `Proof ${this.delegation.cid} is not valid before ${new Date(\n      this.delegation.notBefore * 1000\n    )}`\n  }\n  get validAt() {\n    return this.delegation.notBefore\n  }\n  toJSON() {\n    const { name, validAt, message, stack } = this\n    return {\n      name,\n      message,\n      validAt,\n      stack,\n    }\n  }\n}\n\n/**\n * @implements {API.Unauthorized}\n */\n\nexport class Unauthorized extends Failure {\n  /**\n   * @param {{\n   * capability: API.CapabilityParser\n   * delegationErrors: API.DelegationError[]\n   * unknownCapabilities: API.Capability[]\n   * invalidProofs: API.InvalidProof[]\n   * failedProofs: API.InvalidClaim[]\n   * }} cause\n   */\n  constructor({\n    capability,\n    delegationErrors,\n    unknownCapabilities,\n    invalidProofs,\n    failedProofs,\n  }) {\n    super()\n    this.name = /** @type {const} */  ('Unauthorized')\n    this.capability = capability\n    this.delegationErrors = delegationErrors\n    this.unknownCapabilities = unknownCapabilities\n    this.invalidProofs = invalidProofs\n    this.failedProofs = failedProofs\n  }\n\n  describe() {\n    const errors = [\n      ...this.failedProofs.map(error => li(error.message)),\n      ...this.delegationErrors.map(error => li(error.message)),\n      ...this.invalidProofs.map(error => li(error.message)),\n    ]\n\n    const unknown = this.unknownCapabilities.map(c => li(JSON.stringify(c)))\n\n    return [\n      `Claim ${this.capability} is not authorized`,\n      ...(errors.length > 0\n        ? errors\n        : [li(`No matching delegated capability found`)]),\n      ...(unknown.length > 0\n        ? [li(`Encountered unknown capabilities\\n${unknown.join('\\n')}`)]\n        : []),\n    ].join('\\n')\n  }\n}\n\n/**\n * @param {unknown} capability\n * @param {string|number} [space]\n */\n\nconst format = (capability, space) =>\n  JSON.stringify(\n    capability,\n    (_key, value) => {\n      /* c8 ignore next 2 */\n      if (isLink(value)) {\n        return value.toString()\n      } else {\n        return value\n      }\n    },\n    space\n  )\n\n/**\n * @param {string} message\n */\nexport const indent = (message, indent = '  ') =>\n  `${indent}${message.split('\\n').join(`\\n${indent}`)}`\n\n/**\n * @param {string} message\n */\nexport const li = message => indent(`- ${message}`)\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2120, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/validator/src/capability.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport { entries, combine, intersection } from './util.js'\nimport {\n  EscalatedCapability,\n  MalformedCapability,\n  UnknownCapability,\n  DelegationError as MatchError,\n} from './error.js'\nimport { invoke, delegate, Schema } from '@ucanto/core'\n\n/**\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @typedef {{\n * can: A\n * with: API.Reader<R, API.Resource, API.Failure>\n * nb?: Schema.MapRepresentation<C, unknown>\n * derives?: (claim: {can:A, with: R, nb: C}, proof:{can:A, with:R, nb:C}) => API.Result<{}, API.Failure>\n * }} Descriptor\n */\n\n/**\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} [C={}]\n * @param {Descriptor<A, R, C>} descriptor\n \n * @returns {API.TheCapabilityParser<API.CapabilityMatch<A, R, C>>}\n */\nexport const capability = ({\n  derives = defaultDerives,\n  nb = defaultNBSchema,\n  ...etc\n}) => new Capability({ derives, nb, ...etc })\n\nconst defaultNBSchema =\n  /** @type {Schema.MapRepresentation<any>} */\n  (Schema.struct({}))\n\n/**\n * @template {API.Match} M\n * @template {API.Match} W\n * @param {API.Matcher<M>} left\n * @param {API.Matcher<W>} right\n * @returns {API.CapabilityParser<M|W>}\n */\nexport const or = (left, right) => new Or(left, right)\n\n/**\n * @template {API.MatchSelector<API.Match>[]} Selectors\n * @param {Selectors} selectors\n * @returns {API.CapabilitiesParser<API.InferMembers<Selectors>>}\n */\nexport const and = (...selectors) => new And(selectors)\n\n/**\n * @template {API.Match} M\n * @template {API.ParsedCapability} T\n * @param {object} source\n * @param {API.MatchSelector<M>} source.from\n * @param {API.TheCapabilityParser<API.DirectMatch<T>>} source.to\n * @param {API.Derives<T, API.InferDeriveProof<M['value']>>} source.derives\n \n * @returns {API.TheCapabilityParser<API.DerivedMatch<T, M>>}\n */\nexport const derive = ({ from, to, derives }) => new Derive(from, to, derives)\n\n/**\n * @template {API.Match} M\n * @implements {API.View<M>}\n */\nclass View {\n  /**\n   * @param {API.Source} source\n   * @returns {API.MatchResult<M>}\n   */\n  /* c8 ignore next 3 */\n  match(source) {\n    return { error: new UnknownCapability(source.capability) }\n  }\n\n  /**\n   * @param {API.Source[]} capabilities\n   * @returns {API.Select<M>}\n   */\n  select(capabilities) {\n    return select(this, capabilities)\n  }\n\n  /**\n   * @template {API.ParsedCapability} U\n   * @param {object} source\n   * @param {API.TheCapabilityParser<API.DirectMatch<U>>} source.to\n   * @param {API.Derives<U, API.InferDeriveProof<M['value']>>} source.derives\n   * @returns {API.TheCapabilityParser<API.DerivedMatch<U, M>>}\n   */\n  derive({ derives, to }) {\n    return derive({ derives, to, from: this })\n  }\n}\n\n/**\n * @template {API.Match} M\n * @implements {API.CapabilityParser<M>}\n * @extends {View<M>}\n */\nclass Unit extends View {\n  /**\n   * @template {API.Match} W\n   * @param {API.MatchSelector<W>} other\n   * @returns {API.CapabilityParser<M | W>}\n   */\n  or(other) {\n    return or(this, other)\n  }\n\n  /**\n   * @template {API.Match} W\n   * @param {API.CapabilityParser<W>} other\n   * @returns {API.CapabilitiesParser<[M, W]>}\n   */\n  and(other) {\n    return and(/** @type {API.CapabilityParser<M>} */ (this), other)\n  }\n}\n\n/**\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @implements {API.TheCapabilityParser<API.DirectMatch<API.ParsedCapability<A, R, C>>>}\n * @extends {Unit<API.DirectMatch<API.ParsedCapability<A, R, C>>>}\n */\nclass Capability extends Unit {\n  /**\n   * @param {Required<Descriptor<A, R, C>>} descriptor\n   */\n  constructor(descriptor) {\n    super()\n    this.descriptor = descriptor\n    this.schema = Schema.struct({\n      can: Schema.literal(descriptor.can),\n      with: descriptor.with,\n      nb: descriptor.nb,\n    })\n  }\n\n  /**\n   * @param {API.InferCreateOptions<R, C>} options\n   */\n  create(options) {\n    const { descriptor, can } = this\n    const decoders = descriptor.nb\n    const data = /** @type {C} */ (options.nb || {})\n\n    const resource = descriptor.with.read(options.with)\n    if (resource.error) {\n      throw Object.assign(\n        new Error(`Invalid 'with' - ${resource.error.message}`),\n        {\n          cause: resource,\n        }\n      )\n    }\n\n    const nb = descriptor.nb.read(data)\n    if (nb.error) {\n      throw Object.assign(new Error(`Invalid 'nb' - ${nb.error.message}`), {\n        cause: nb,\n      })\n    }\n\n    return createCapability({ can, with: resource.ok, nb: nb.ok })\n  }\n\n  /**\n   * @param {API.InferInvokeOptions<R, C>} options\n   */\n  invoke({ with: with_, nb, ...options }) {\n    return invoke({\n      ...options,\n      capability: this.create(\n        /** @type {API.InferCreateOptions<R, C>} */\n        ({ with: with_, nb })\n      ),\n    })\n  }\n\n  /**\n   * @param {API.InferDelegationOptions<R, C>} options\n   * @returns {Promise<API.Delegation<[API.InferDelegatedCapability<API.ParsedCapability<A, R, C>>]>>}\n   */\n  async delegate({ nb: input = {}, with: with_, ...options }) {\n    const { descriptor, can } = this\n    const readers = descriptor.nb\n\n    const resource = descriptor.with.read(with_)\n    if (resource.error) {\n      throw Object.assign(\n        new Error(`Invalid 'with' - ${resource.error.message}`),\n        {\n          cause: resource,\n        }\n      )\n    }\n\n    const nb = descriptor.nb.partial().read(input)\n    if (nb.error) {\n      throw Object.assign(new Error(`Invalid 'nb' - ${nb.error.message}`), {\n        cause: nb,\n      })\n    }\n\n    return delegate({\n      capabilities: [createCapability({ can, with: resource.ok, nb: nb.ok })],\n      ...options,\n    })\n  }\n\n  get can() {\n    return this.descriptor.can\n  }\n\n  /**\n   * @param {API.Source} source\n   * @returns {API.MatchResult<API.DirectMatch<API.ParsedCapability<A, R, C>>>}\n   */\n  match(source) {\n    const result = parseCapability(this.descriptor, source)\n    return result.error\n      ? result\n      : { ok: new Match(source, result.ok, this.descriptor) }\n  }\n  toString() {\n    return JSON.stringify({ can: this.descriptor.can })\n  }\n}\n\n/**\n * Normalizes capability by removing empty nb field.\n *\n * @template {API.ParsedCapability} T\n * @param {T} source\n */\n\nconst createCapability = ({ can, with: with_, nb }) =>\n  /** @type {API.InferCapability<T>} */ ({\n    can,\n    with: with_,\n    ...(isEmpty(nb) ? {} : { nb }),\n  })\n\n/**\n * @param {object} object\n * @returns {object is {}}\n */\nconst isEmpty = object => {\n  for (const _ in object) {\n    return false\n  }\n  return true\n}\n\n/**\n * @template {API.Match} M\n * @template {API.Match} W\n * @implements {API.CapabilityParser<M|W>}\n * @extends {Unit<M|W>}\n */\nclass Or extends Unit {\n  /**\n   * @param {API.Matcher<M>} left\n   * @param {API.Matcher<W>} right\n   */\n  constructor(left, right) {\n    super()\n    this.left = left\n    this.right = right\n  }\n\n  /**\n   * @param {API.Source} capability\n   * @return {API.MatchResult<M|W>}\n   */\n  match(capability) {\n    const left = this.left.match(capability)\n    if (left.error) {\n      const right = this.right.match(capability)\n      if (right.error) {\n        return right.error.name === 'MalformedCapability'\n          ? //\n            right\n          : //\n            left\n      } else {\n        return right\n      }\n    } else {\n      return left\n    }\n  }\n\n  toString() {\n    return `${this.left.toString()}|${this.right.toString()}`\n  }\n}\n\n/**\n * @template {API.MatchSelector<API.Match>[]} Selectors\n * @implements {API.CapabilitiesParser<API.InferMembers<Selectors>>}\n * @extends {View<API.Amplify<API.InferMembers<Selectors>>>}\n */\nclass And extends View {\n  /**\n   * @param {Selectors} selectors\n   */\n  constructor(selectors) {\n    super()\n    this.selectors = selectors\n  }\n  /**\n   * @param {API.Source} capability\n   * @returns {API.MatchResult<API.Amplify<API.InferMembers<Selectors>>>}\n   */\n  match(capability) {\n    const group = []\n    for (const selector of this.selectors) {\n      const result = selector.match(capability)\n      if (result.error) {\n        return result\n      } else {\n        group.push(result.ok)\n      }\n    }\n\n    return {\n      ok: new AndMatch(/** @type {API.InferMembers<Selectors>} */ (group)),\n    }\n  }\n\n  /**\n   * @param {API.Source[]} capabilities\n   */\n  select(capabilities) {\n    return selectGroup(this, capabilities)\n  }\n  /**\n   * @template E\n   * @template {API.Match} X\n   * @param {API.MatchSelector<API.Match<E, X>>} other\n   * @returns {API.CapabilitiesParser<[...API.InferMembers<Selectors>, API.Match<E, X>]>}\n   */\n  and(other) {\n    return new And([...this.selectors, other])\n  }\n  toString() {\n    return `[${this.selectors.map(String).join(', ')}]`\n  }\n}\n\n/**\n * @template {API.ParsedCapability} T\n * @template {API.Match} M\n * @implements {API.TheCapabilityParser<API.DerivedMatch<T, M>>}\n * @extends {Unit<API.DerivedMatch<T, M>>}\n */\n\nclass Derive extends Unit {\n  /**\n   * @param {API.MatchSelector<M>} from\n   * @param {API.TheCapabilityParser<API.DirectMatch<T>>} to\n   * @param {API.Derives<T, API.InferDeriveProof<M['value']>>} derives\n   */\n  constructor(from, to, derives) {\n    super()\n    this.from = from\n    this.to = to\n    this.derives = derives\n  }\n\n  /**\n   * @type {typeof this.to['create']}\n   */\n  create(options) {\n    return this.to.create(options)\n  }\n  /**\n   * @type {typeof this.to['invoke']}\n   */\n  invoke(options) {\n    return this.to.invoke(options)\n  }\n  /**\n   * @type {typeof this.to['delegate']}\n   */\n  delegate(options) {\n    return this.to.delegate(options)\n  }\n  get can() {\n    return this.to.can\n  }\n  /**\n   * @param {API.Source} capability\n   * @returns {API.MatchResult<API.DerivedMatch<T, M>>}\n   */\n  match(capability) {\n    const match = this.to.match(capability)\n    if (match.error) {\n      return match\n    } else {\n      return { ok: new DerivedMatch(match.ok, this.from, this.derives) }\n    }\n  }\n  toString() {\n    return this.to.toString()\n  }\n}\n\n/**\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @implements {API.DirectMatch<API.ParsedCapability<A, R, C>>}\n */\nclass Match {\n  /**\n   * @param {API.Source} source\n   * @param {API.ParsedCapability<A, R, C>} value\n   * @param {Required<Descriptor<A, R, C>>} descriptor\n   */\n  constructor(source, value, descriptor) {\n    this.source = [source]\n    this.value = value\n    this.descriptor = descriptor\n  }\n  get can() {\n    return this.value.can\n  }\n\n  get proofs() {\n    const proofs = [this.source[0].delegation]\n    Object.defineProperties(this, {\n      proofs: { value: proofs },\n    })\n    return proofs\n  }\n\n  /**\n   * @param {API.CanIssue} context\n   * @returns {API.DirectMatch<API.ParsedCapability<A, R, C>>|null}\n   */\n  prune(context) {\n    if (context.canIssue(this.value, this.source[0].delegation.issuer.did())) {\n      return null\n    } else {\n      return this\n    }\n  }\n\n  /**\n   * @param {API.Source[]} capabilities\n   * @returns {API.Select<API.DirectMatch<API.ParsedCapability<A, R, C>>>}\n   */\n  select(capabilities) {\n    const unknown = []\n    const errors = []\n    const matches = []\n    for (const capability of capabilities) {\n      const result = resolveCapability(this.descriptor, this.value, capability)\n      if (result.ok) {\n        const claim = this.descriptor.derives(this.value, result.ok)\n        if (claim.error) {\n          errors.push(\n            new MatchError(\n              [new EscalatedCapability(this.value, result.ok, claim.error)],\n              this\n            )\n          )\n        } else {\n          matches.push(new Match(capability, result.ok, this.descriptor))\n        }\n      } else {\n        switch (result.error.name) {\n          case 'UnknownCapability':\n            unknown.push(result.error.capability)\n            break\n          case 'MalformedCapability':\n          default:\n            errors.push(new MatchError([result.error], this))\n        }\n      }\n    }\n\n    return { matches, unknown, errors }\n  }\n  toString() {\n    const { nb } = this.value\n    return JSON.stringify({\n      can: this.descriptor.can,\n      with: this.value.with,\n      nb: nb && Object.keys(nb).length > 0 ? nb : undefined,\n    })\n  }\n}\n\n/**\n * @template {API.ParsedCapability} T\n * @template {API.Match} M\n * @implements {API.DerivedMatch<T, M>}\n */\n\nclass DerivedMatch {\n  /**\n   * @param {API.DirectMatch<T>} selected\n   * @param {API.MatchSelector<M>} from\n   * @param {API.Derives<T, API.InferDeriveProof<M['value']>>} derives\n   */\n  constructor(selected, from, derives) {\n    this.selected = selected\n    this.from = from\n    this.derives = derives\n  }\n  get can() {\n    return this.value.can\n  }\n  get source() {\n    return this.selected.source\n  }\n  get proofs() {\n    const proofs = []\n    for (const { delegation } of this.selected.source) {\n      proofs.push(delegation)\n    }\n    Object.defineProperties(this, { proofs: { value: proofs } })\n    return proofs\n  }\n  get value() {\n    return this.selected.value\n  }\n\n  /**\n   * @param {API.CanIssue} context\n   */\n  prune(context) {\n    const selected =\n      /** @type {API.DirectMatch<T>|null} */\n      (this.selected.prune(context))\n    return selected ? new DerivedMatch(selected, this.from, this.derives) : null\n  }\n\n  /**\n   * @param {API.Source[]} capabilities\n   */\n  select(capabilities) {\n    const { derives, selected, from } = this\n    const { value } = selected\n\n    const direct = selected.select(capabilities)\n\n    const derived = from.select(capabilities)\n    const matches = []\n    const errors = []\n    for (const match of derived.matches) {\n      // If capability can not be derived it escalates\n      const result = derives(value, match.value)\n      if (result.error) {\n        errors.push(\n          new MatchError(\n            [new EscalatedCapability(value, match.value, result.error)],\n            this\n          )\n        )\n      } else {\n        matches.push(match)\n      }\n    }\n\n    return {\n      unknown: intersection(direct.unknown, derived.unknown),\n      errors: [\n        ...errors,\n        ...direct.errors,\n        ...derived.errors.map(error => new MatchError([error], this)),\n      ],\n      matches: [\n        ...direct.matches.map(match => new DerivedMatch(match, from, derives)),\n        ...matches,\n      ],\n    }\n  }\n\n  toString() {\n    return this.selected.toString()\n  }\n}\n\n/**\n * @template {API.MatchSelector<API.Match>[]} Selectors\n * @implements {API.Amplify<API.InferMembers<Selectors>>}\n */\nclass AndMatch {\n  /**\n   * @param {API.Match[]} matches\n   */\n  constructor(matches) {\n    this.matches = matches\n  }\n  get selectors() {\n    return this.matches\n  }\n  /**\n   * @returns {API.Source[]}\n   */\n  get source() {\n    const source = []\n\n    for (const match of this.matches) {\n      source.push(...match.source)\n    }\n    Object.defineProperties(this, { source: { value: source } })\n    return source\n  }\n\n  /**\n   * @param {API.CanIssue} context\n   */\n  prune(context) {\n    const matches = []\n    for (const match of this.matches) {\n      const pruned = match.prune(context)\n      if (pruned) {\n        matches.push(pruned)\n      }\n    }\n    return matches.length === 0 ? null : new AndMatch(matches)\n  }\n\n  get proofs() {\n    const proofs = []\n\n    for (const { delegation } of this.source) {\n      proofs.push(delegation)\n    }\n\n    Object.defineProperties(this, { proofs: { value: proofs } })\n    return proofs\n  }\n  /**\n   * @type {API.InferValue<API.InferMembers<Selectors>>}\n   */\n  get value() {\n    const value = []\n\n    for (const match of this.matches) {\n      value.push(match.value)\n    }\n    Object.defineProperties(this, { value: { value } })\n    return /** @type {any} */ (value)\n  }\n  /**\n   * @param {API.Source[]} capabilities\n   */\n  select(capabilities) {\n    return selectGroup(this, capabilities)\n  }\n  toString() {\n    return `[${this.matches.map(match => match.toString()).join(', ')}]`\n  }\n}\n\n/**\n * Resolves ability `pattern` of the delegated capability from the ability\n * of the claimed capability. If pattern matches returns claimed ability\n * otherwise returns given `fallback`.\n *\n * @example\n * ```js\n * resolveAbility('*', 'store/add', null) // => 'store/add'\n * resolveAbility('store/*', 'store/add', null) // => 'store/add'\n * resolveAbility('store/add', 'store/add', null) // => 'store/add'\n * resolveAbility('store/', 'store/add', null) // => null\n * resolveAbility('store/a*', 'store/add', null) // => null\n * resolveAbility('store/list', 'store/add', null) // => null\n * ```\n *\n * @template {API.Ability} T\n * @template U\n * @param {string} pattern\n * @param {T} can\n * @param {U} fallback\n * @returns {T|U}\n */\nconst resolveAbility = (pattern, can, fallback) => {\n  switch (pattern) {\n    case can:\n    case '*':\n      return can\n    default:\n      return pattern.endsWith('/*') && can.startsWith(pattern.slice(0, -1))\n        ? can\n        : fallback\n  }\n}\n\n/**\n * Resolves `source` resource of the delegated capability from the resource\n * `uri` of the claimed capability. If `source` is `\"ucan:*\"\"` or matches `uri`\n * then it returns `uri` back otherwise it returns `fallback`.\n *\n * @example\n * ```js\n * resolveResource('ucan:*', 'did:key:zAlice', null) // => 'did:key:zAlice'\n * resolveAbility('ucan:*', 'https://example.com', null) // => 'https://example.com'\n * resolveAbility('did:*', 'did:key:zAlice', null) // => null\n * resolveAbility('did:key:zAlice', 'did:key:zAlice', null) // => did:key:zAlice\n * ```\n * @template {string} T\n * @template U\n * @param {T} uri\n * @param {string} source\n * @param {U} fallback\n * @returns {T|U}\n */\nconst resolveResource = (source, uri, fallback) => {\n  switch (source) {\n    case uri:\n    case 'ucan:*':\n      return uri\n    default:\n      return fallback\n  }\n}\n\n/**\n * Parses capability from the `source` using a provided `parser`.\n *\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @param {Required<Descriptor<A, R, C>>} descriptor\n * @param {API.Source} source\n * @returns {API.Result<API.ParsedCapability<A, R, C>, API.InvalidCapability>}\n */\nconst parseCapability = (descriptor, source) => {\n  const { delegation } = source\n  const capability = /** @type {API.Capability<A, R, C>} */ (source.capability)\n\n  if (descriptor.can !== capability.can) {\n    return { error: new UnknownCapability(capability) }\n  }\n\n  const uri = descriptor.with.read(capability.with)\n  if (uri.error) {\n    return { error: new MalformedCapability(capability, uri.error) }\n  }\n\n  const nb = descriptor.nb.read(capability.nb || {})\n  if (nb.error) {\n    return { error: new MalformedCapability(capability, nb.error) }\n  }\n\n  return { ok: new CapabilityView(descriptor.can, uri.ok, nb.ok, delegation) }\n}\n\n/**\n * Resolves delegated capability `source` from the `claimed` capability using\n * provided capability `parser`. It is similar to `parseCapability` except\n * `source` here is treated as capability pattern which is matched against the\n * `claimed` capability. This means we resolve `can` and `with` fields from the\n * `claimed` capability and inherit all missing `nb` fields from the claimed\n * capability.\n *\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @param {Required<Descriptor<A, R, C>>} descriptor\n * @param {API.ParsedCapability<A, R, C>} claimed\n * @param {API.Source} source\n * @returns {API.Result<API.ParsedCapability<A, R, C>, API.InvalidCapability>}\n */\n\nconst resolveCapability = (descriptor, claimed, { capability, delegation }) => {\n  const can = resolveAbility(capability.can, claimed.can, null)\n  if (can == null) {\n    return { error: new UnknownCapability(capability) }\n  }\n\n  const resource = resolveResource(\n    capability.with,\n    claimed.with,\n    capability.with\n  )\n  const uri = descriptor.with.read(resource)\n  if (uri.error) {\n    return { error: new MalformedCapability(capability, uri.error) }\n  }\n\n  const nb = descriptor.nb.read({\n    ...claimed.nb,\n    ...capability.nb,\n  })\n\n  if (nb.error) {\n    return { error: new MalformedCapability(capability, nb.error) }\n  }\n\n  return { ok: new CapabilityView(can, uri.ok, nb.ok, delegation) }\n}\n\n/**\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template C\n */\nclass CapabilityView {\n  /**\n   * @param {A} can\n   * @param {R} with_\n   * @param {C} nb\n   * @param {API.Delegation} delegation\n   */\n  constructor(can, with_, nb, delegation) {\n    this.can = can\n    this.with = with_\n    this.delegation = delegation\n    this.nb = nb\n  }\n}\n\n/**\n * @template {API.Match} M\n * @param {API.Matcher<M>} matcher\n * @param {API.Source[]} capabilities\n * @returns {API.Select<M>}\n */\n\nconst select = (matcher, capabilities) => {\n  const unknown = []\n  const matches = []\n  const errors = []\n  for (const capability of capabilities) {\n    const result = matcher.match(capability)\n    if (result.error) {\n      switch (result.error.name) {\n        case 'UnknownCapability':\n          unknown.push(result.error.capability)\n          break\n        case 'MalformedCapability':\n        default:\n          errors.push(new MatchError([result.error], result.error.capability))\n      }\n    } else {\n      matches.push(result.ok)\n    }\n  }\n\n  return { matches, errors, unknown }\n}\n\n/**\n * @template {API.Selector<API.Match>[]} S\n * @param {{selectors:S}} self\n * @param {API.Source[]} capabilities\n */\n\nconst selectGroup = (self, capabilities) => {\n  let unknown\n  const data = []\n  const errors = []\n  for (const selector of self.selectors) {\n    const selected = selector.select(capabilities)\n    unknown = unknown\n      ? intersection(unknown, selected.unknown)\n      : selected.unknown\n\n    for (const error of selected.errors) {\n      errors.push(new MatchError([error], self))\n    }\n\n    data.push(selected.matches)\n  }\n\n  const matches = combine(data).map(group => new AndMatch(group))\n\n  return {\n    unknown:\n      /* c8 ignore next */\n      unknown || [],\n    errors,\n    matches,\n  }\n}\n\n/**\n * @template {API.ParsedCapability} T\n * @template {API.ParsedCapability} U\n * @param {T} claimed\n * @param {U} delegated\n * @return {API.Result<true, API.Failure>}\n */\nconst defaultDerives = (claimed, delegated) => {\n  if (delegated.with.endsWith('*')) {\n    if (!claimed.with.startsWith(delegated.with.slice(0, -1))) {\n      return Schema.error(\n        `Resource ${claimed.with} does not match delegated ${delegated.with} `\n      )\n    }\n  } else if (delegated.with !== claimed.with) {\n    return Schema.error(\n      `Resource ${claimed.with} is not contained by ${delegated.with}`\n    )\n  }\n\n  /* c8 ignore next 2 */\n  const caveats = delegated.nb || {}\n  const nb = claimed.nb || {}\n  const kv = entries(caveats)\n\n  for (const [name, value] of kv) {\n    if (nb[name] != value) {\n      return Schema.error(`${String(name)}: ${nb[name]} violates ${value}`)\n    }\n  }\n\n  return { ok: true }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2932, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/validator/src/authorization.js"],"sourcesContent":["import * as API from '@ucanto/interface'\n\n/**\n * @template {API.ParsedCapability} C\n * @implements {API.Authorization<C>}\n */\nclass Authorization {\n  /**\n   * @param {API.Match<C>} match\n   * @param {API.Authorization<API.ParsedCapability>[]} proofs\n   */\n  constructor(match, proofs) {\n    this.match = match\n    this.proofs = proofs\n  }\n  get capability() {\n    return this.match.value\n  }\n  get delegation() {\n    return this.match.source[0].delegation\n  }\n  get issuer() {\n    return this.delegation.issuer\n  }\n  get audience() {\n    return this.delegation.audience\n  }\n}\n\n/**\n * @template {API.ParsedCapability} C\n * @param {API.Match<C>} match\n * @param {API.Authorization<API.ParsedCapability>[]} proofs\n * @returns {API.Authorization<C>}\n */\nexport const create = (match, proofs = []) => new Authorization(match, proofs)\n\n/**\n *\n * @param {API.Authorization} authorization\n * @returns {Iterable<API.UCANLink>}\n */\nexport const iterate = function* ({ delegation, proofs }) {\n  yield delegation.cid\n  for (const proof of proofs) {\n    yield* iterate(proof)\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;;AAEA;;;CAGC,GACD,MAAM;IACJ;;;GAGC,GACD,YAAY,KAAK,EAAE,MAAM,CAAE;QACzB,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,MAAM,GAAG;IAChB;IACA,IAAI,aAAa;QACf,OAAO,IAAI,CAAC,KAAK,CAAC,KAAK;IACzB;IACA,IAAI,aAAa;QACf,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC,UAAU;IACxC;IACA,IAAI,SAAS;QACX,OAAO,IAAI,CAAC,UAAU,CAAC,MAAM;IAC/B;IACA,IAAI,WAAW;QACb,OAAO,IAAI,CAAC,UAAU,CAAC,QAAQ;IACjC;AACF;AAQO,MAAM,SAAS,CAAC,OAAO,SAAS,EAAE,GAAK,IAAI,cAAc,OAAO;AAOhE,MAAM,UAAU,UAAW,EAAE,UAAU,EAAE,MAAM,EAAE;IACtD,MAAM,WAAW,GAAG;IACpB,KAAK,MAAM,SAAS,OAAQ;QAC1B,OAAO,QAAQ;IACjB;AACF","ignoreList":[0]}},
    {"offset": {"line": 2975, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/validator/src/lib.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport { isDelegation, UCAN, ok, fail } from '@ucanto/core'\nimport { capability } from './capability.js'\nimport * as Schema from '@ucanto/core/schema'\nimport * as Authorization from './authorization.js'\nimport {\n  UnavailableProof,\n  Unauthorized,\n  PrincipalAlignmentError,\n  Expired,\n  Revoked,\n  NotValidBefore,\n  InvalidSignature,\n  SessionEscalation,\n  Failure,\n  MalformedCapability,\n  DIDKeyResolutionError,\n  li,\n} from './error.js'\n\nexport { capability } from './capability.js'\nexport * from '@ucanto/core/schema'\n\nexport {\n  Schema,\n  Authorization,\n  Failure,\n  fail,\n  ok,\n  Revoked,\n  UnavailableProof,\n  Unauthorized,\n  MalformedCapability,\n  DIDKeyResolutionError as DIDResolutionError,\n}\n\n/**\n * @param {UCAN.Link} proof\n * @returns {{error:API.UnavailableProof}}\n */\nconst unavailable = proof => ({ error: new UnavailableProof(proof) })\n\n/**\n *\n * @param {UCAN.DID} did\n * @returns {{error:API.DIDKeyResolutionError}}\n */\nconst failDIDKeyResolution = did => ({ error: new DIDKeyResolutionError(did) })\n\n/**\n * @param {Required<API.ClaimOptions>} config\n * @param {API.Match<unknown, API.Match>} match\n */\n\nconst resolveMatch = async (match, config) => {\n  const promises = []\n  const includes = new Set()\n  for (const source of match.source) {\n    const id = source.delegation.cid.toString()\n    if (!includes.has(id)) {\n      promises.push(await resolveSources(source, config))\n    }\n  }\n  const groups = await Promise.all(promises)\n  const sources = []\n  const errors = []\n  for (const group of groups) {\n    sources.push(...group.sources)\n    errors.push(...group.errors)\n  }\n\n  return { sources, errors }\n}\n\n/**\n * Takes `proofs` from the delegation which may contain `Delegation` or a link\n * to one and attempts to resolve links by side loading them. Returns set of\n * resolved `Delegation`s and errors for the proofs that could not be resolved.\n *\n * @param {API.Proof[]} proofs\n * @param {Required<API.ProofResolver>} config\n */\nconst resolveProofs = async (proofs, config) => {\n  /** @type {API.Delegation[]} */\n  const delegations = []\n  /** @type {API.UnavailableProof[]} */\n  const errors = []\n  const promises = []\n  for (const proof of proofs) {\n    // If it is a delegation we can just add it to the resolved set.\n    if (isDelegation(proof)) {\n      delegations.push(proof)\n    }\n    // otherwise we attempt to resolve the link asynchronously. To avoid doing\n    // sequential requests we create promise for each link and then wait for\n    // all of them at the end.\n    else {\n      promises.push(\n        new Promise(async resolve => {\n          // config.resolve is not supposed to throw, but we catch it just in\n          // case it does and consider proof resolution failed.\n          try {\n            const result = await config.resolve(proof)\n            if (result.error) {\n              errors.push(result.error)\n            } else {\n              delegations.push(result.ok)\n            }\n          } catch (error) {\n            errors.push(\n              new UnavailableProof(proof, /** @type {Error} */(error))\n            )\n          }\n\n          // we don't care about the result, we just need to signal that we are\n          // done with this promise.\n          resolve(null)\n        })\n      )\n    }\n  }\n\n  // Wait for all the promises to resolve. At this point we have collected all\n  // the resolved delegations and errors.\n  await Promise.all(promises)\n  return { delegations, errors }\n}\n\n/**\n * Takes a delegation source and attempts to resolve all the linked proofs.\n *\n * @param {API.Source} from\n * @param {Required<API.ClaimOptions>} config\n * @return {Promise<{sources:API.Source[], errors:ProofError[]}>}\n */\nconst resolveSources = async ({ delegation }, config) => {\n  const errors = []\n  const sources = []\n  const proofs = []\n  // First we attempt to resolve all the linked proofs.\n  const { delegations, errors: failedProofs } = await resolveProofs(\n    delegation.proofs,\n    config\n  )\n\n  // All the proofs that failed to resolve are saved as proof errors.\n  for (const error of failedProofs) {\n    errors.push(new ProofError(error.link, error))\n  }\n\n  // All the proofs that resolved are checked for principal alignment. Ones that\n  // do not align are saved as proof errors.\n  for (const proof of delegations) {\n    // If proof does not delegate to a matching audience save an proof error.\n    if (delegation.issuer.did() !== proof.audience.did()) {\n      errors.push(\n        new ProofError(\n          proof.cid,\n          new PrincipalAlignmentError(delegation.issuer, proof)\n        )\n      )\n    } else {\n      proofs.push(proof)\n    }\n  }\n  // In the second pass we attempt to proofs that were resolved and are aligned.\n  for (const proof of proofs) {\n    // If proof is not valid (expired, not active yet or has incorrect\n    // signature) save a corresponding proof error.\n    const validation = await validate(proof, proofs, config)\n    if (validation.error) {\n      errors.push(new ProofError(proof.cid, validation.error))\n    } else {\n      // otherwise create source objects for it's capabilities, so we could\n      // track which proof in which capability the are from.\n      for (const capability of proof.capabilities) {\n        sources.push(\n          /** @type {API.Source} */({\n            capability,\n            delegation: proof,\n          })\n        )\n      }\n    }\n  }\n\n  return { sources, errors }\n}\n\n/**\n * @param {API.ParsedCapability} capability\n * @param {API.DID} issuer\n */\nconst isSelfIssued = (capability, issuer) => capability.with === issuer\n\n/**\n * Finds a valid path in a proof chain of the given `invocation` by exploring\n * every possible option. On success an `Authorization` object is returned that\n * illustrates the valid path. If no valid path is found `Unauthorized` error\n * is returned detailing all explored paths and where they proved to fail.\n *\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {R} URI\n * @template {API.Caveats} C\n * @param {API.Invocation<API.Capability<A, URI, C>>} invocation\n * @param {API.ValidationOptions<API.ParsedCapability<A, R, C>>} options\n * @returns {Promise<API.Result<API.Authorization<API.ParsedCapability<A, R, C>>, API.Unauthorized>>}\n */\nexport const access = async (invocation, { capability, ...config }) =>\n  claim(capability, [invocation], config)\n\n/**\n * Attempts to find a valid proof chain for the claimed `capability` given set\n * of `proofs`. On success an `Authorization` object with detailed proof chain\n * is returned and on failure `Unauthorized` error is returned with details on\n * paths explored and why they have failed.\n *\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @param {API.CapabilityParser<API.Match<API.ParsedCapability<A, R, C>>>} capability\n * @param {API.Proof[]} proofs\n * @param {API.ClaimOptions} config\n * @returns {Promise<API.Result<API.Authorization<API.ParsedCapability<A, R, C>>, API.Unauthorized>>}\n */\nexport const claim = async (\n  capability,\n  proofs,\n  {\n    authority,\n    principal,\n    validateAuthorization,\n    resolveDIDKey = failDIDKeyResolution,\n    canIssue = isSelfIssued,\n    resolve = unavailable,\n    proofs: localProofs = [],\n  }\n) => {\n  const config = {\n    canIssue,\n    resolve,\n    principal,\n    capability,\n    authority,\n    validateAuthorization,\n    resolveDIDKey,\n    proofs: localProofs,\n  }\n\n  const invalidProofs = []\n\n  /** @type {API.Source[]} */\n  const sources = []\n\n  const { delegations, errors } = await resolveProofs(proofs, config)\n  invalidProofs.push(...errors)\n\n  for (const proof of delegations) {\n    // Validate each proof if valid add ech capability to the list of sources.\n    // otherwise collect the error.\n    const validation = await validate(proof, delegations, config)\n    if (validation.ok) {\n      for (const capability of validation.ok.capabilities.values()) {\n        sources.push(\n          /** @type {API.Source} */({\n            capability,\n            delegation: validation.ok,\n          })\n        )\n      }\n    } else {\n      invalidProofs.push(validation.error)\n    }\n  }\n  // look for the matching capability\n  const selection = capability.select(sources)\n\n  const { errors: delegationErrors, unknown: unknownCapabilities } = selection\n  const failedProofs = []\n  for (const matched of selection.matches) {\n    const selector = matched.prune(config)\n    if (selector == null) {\n      const authorization = Authorization.create(matched, [])\n      const result = await validateAuthorization(authorization)\n      if (result.error) {\n        invalidProofs.push(result.error)\n      } else {\n        return { ok: authorization }\n      }\n    } else {\n      const result = await authorize(selector, config)\n      if (result.error) {\n        failedProofs.push(result.error)\n      } else {\n        const authorization = Authorization.create(matched, [result.ok])\n        const approval = await validateAuthorization(authorization)\n        if (approval.error) {\n          invalidProofs.push(approval.error)\n        } else {\n          return { ok: authorization }\n        }\n      }\n    }\n  }\n\n  return {\n    error: new Unauthorized({\n      capability,\n      delegationErrors,\n      unknownCapabilities,\n      invalidProofs,\n      failedProofs,\n    }),\n  }\n}\n\n/**\n * Verifies whether any of the delegated proofs grant give capability.\n *\n * @template {API.Match} Match\n * @param {Match} match\n * @param {Required<API.ClaimOptions>} config\n * @returns {Promise<API.Result<API.Authorization<API.ParsedCapability>, API.InvalidClaim>>}\n */\n\nexport const authorize = async (match, config) => {\n  // load proofs from all delegations\n  const { sources, errors: invalidProofs } = await resolveMatch(match, config)\n\n  const selection = match.select(sources)\n  const { errors: delegationErrors, unknown: unknownCapabilities } = selection\n\n  const failedProofs = []\n  for (const matched of selection.matches) {\n    const selector = matched.prune(config)\n    if (selector == null) {\n      return {\n        ok: Authorization.create(\n          // @ts-expect-error - it may not be a parsed capability but rather a\n          // group of capabilities but we can deal with that in the future.\n          matched,\n          []\n        ),\n      }\n    } else {\n      const result = await authorize(selector, config)\n      if (result.error) {\n        failedProofs.push(result.error)\n      } else {\n        return {\n          ok: Authorization.create(\n            // @ts-expect-error - it may not be a parsed capability but rather a\n            // group of capabilities but we can deal with that in the future.\n            matched,\n            [result.ok]\n          ),\n        }\n      }\n    }\n  }\n\n  return {\n    error: new InvalidClaim({\n      match,\n      delegationErrors,\n      unknownCapabilities,\n      invalidProofs,\n      failedProofs,\n    }),\n  }\n}\n\nclass ProofError extends Failure {\n  /**\n   * @param {API.UCANLink} proof\n   * @param {API.Failure} cause\n   */\n  constructor(proof, cause) {\n    super()\n    this.name = 'ProofError'\n    this.proof = proof\n    this.cause = cause\n  }\n  describe() {\n    return [\n      `Capability can not be derived from prf:${this.proof} because:`,\n      li(this.cause.message),\n    ].join(`\\n`)\n  }\n}\n\n/**\n * @implements {API.InvalidClaim}\n */\nclass InvalidClaim extends Failure {\n  /**\n   * @param {{\n   * match: API.Match\n   * delegationErrors: API.DelegationError[]\n   * unknownCapabilities: API.Capability[]\n   * invalidProofs: ProofError[]\n   * failedProofs: API.InvalidClaim[]\n   * }} info\n   */\n  constructor(info) {\n    super()\n    this.info = info\n    this.name = /** @type {const} */ ('InvalidClaim')\n  }\n  get issuer() {\n    return this.delegation.issuer\n  }\n  get delegation() {\n    return this.info.match.source[0].delegation\n  }\n  describe() {\n    const errors = [\n      ...this.info.failedProofs.map(error => li(error.message)),\n      ...this.info.delegationErrors.map(error => li(error.message)),\n      ...this.info.invalidProofs.map(error => li(error.message)),\n    ]\n\n    const unknown = this.info.unknownCapabilities.map(c =>\n      li(JSON.stringify(c))\n    )\n\n    return [\n      `Capability ${this.info.match} is not authorized because:`,\n      li(`Capability can not be (self) issued by '${this.issuer.did()}'`),\n      ...(errors.length > 0 ? errors : [li(`Delegated capability not found`)]),\n      ...(unknown.length > 0\n        ? [li(`Encountered unknown capabilities\\n${unknown.join('\\n')}`)]\n        : []),\n    ].join('\\n')\n  }\n}\n\n/**\n * Validate a delegation to check it is within the time bound and that it is\n * authorized by the issuer.\n *\n * @template {API.Delegation} T\n * @param {T} delegation\n * @param {API.Delegation[]} proofs\n * @param {Required<API.ClaimOptions>} config\n * @returns {Promise<API.Result<T, API.InvalidProof|API.SessionEscalation|API.DIDKeyResolutionError>>}\n */\nconst validate = async (delegation, proofs, config) => {\n  if (UCAN.isExpired(delegation.data)) {\n    return {\n      error: new Expired(\n        /** @type {API.Delegation & {expiration: number}} */(delegation)\n      ),\n    }\n  }\n\n  if (UCAN.isTooEarly(delegation.data)) {\n    return {\n      error: new NotValidBefore(\n        /** @type {API.Delegation & {notBefore: number}} */(delegation)\n      ),\n    }\n  }\n\n  return await verifyAuthorization(delegation, proofs, config)\n}\n\n/**\n * Verifies that delegation has been authorized by the issuer. If issued by the\n * did:key principal checks that the signature is valid. If issued by the root\n * authority checks that the signature is valid. If issued by the principal\n * identified by other DID method attempts to resolve a valid `ucan/attest`\n * attestation from the authority, if attestation is not found falls back to\n * resolving did:key for the issuer and verifying its signature.\n *\n * @template {API.Delegation} T\n * @param {T} delegation\n * @param {API.Delegation[]} proofs\n * @param {Required<API.ClaimOptions>} config\n * @returns {Promise<API.Result<T, API.InvalidSignature|API.SessionEscalation|API.DIDKeyResolutionError>>}\n */\nconst verifyAuthorization = async (delegation, proofs, config) => {\n  const issuer = delegation.issuer.did()\n  // If the issuer is a did:key we just verify a signature\n  if (issuer.startsWith('did:key:')) {\n    return verifySignature(delegation, config.principal.parse(issuer))\n  }\n\n  // If the issuer is the root authority we use authority itself to verify\n  else if (issuer === config.authority.did()) {\n    return verifySignature(delegation, config.authority)\n  } else {\n    // If issuer is not a did:key principal nor configured authority, we\n    // attempt to resolve embedded authorization session from the authority.\n    const session = await verifySession(delegation, proofs, config)\n    // If we have valid session we consider authorization valid\n    if (session.ok) {\n      return { ok: delegation }\n    } else if (session.error.failedProofs.length > 0) {\n      return {\n        error: new SessionEscalation({ delegation, cause: session.error }),\n      }\n    }\n    // Otherwise we try to resolve did:key from the DID instead\n    // and use that to verify the signature\n    else {\n      const result = await config.resolveDIDKey(issuer)\n      if (result.error) {\n        return result\n      }\n\n      const verifiers = result.ok\n      /** @type {(API.InvalidSignature | API.DIDKeyResolutionError)[]} */\n      const verificationErrResults = []\n      for (const verifier of verifiers) {\n        const verificationResult = await verifySignature(\n          delegation,\n          config.principal.parse(verifier).withDID(issuer)\n        )\n        if (verificationResult.ok) {\n          return verificationResult\n        }\n        if (verificationResult.error) {\n          verificationErrResults.push(verificationResult.error)\n        }\n      }\n      \n      // If no verifiers were found, there is no way to verify the signature\n      if (verificationErrResults.length === 0) {\n        return { error: new DIDKeyResolutionError(issuer) }\n      }\n\n      const combinedError = verificationErrResults[0]\n      const combinedMessage = verificationErrResults\n        .map(err => err.message)\n        .join('\\n  ')\n      \n      // @ts-expect-error - both error types have describe method, override it to return the concatenated message\n      combinedError.describe = () => combinedMessage\n\n      return { error: combinedError }\n    }\n  }\n}\n\n/**\n * @template {API.Delegation} T\n * @param {T} delegation\n * @param {API.Verifier} verifier\n * @returns {Promise<API.Result<T, API.InvalidSignature|API.DIDKeyResolutionError>>}\n */\nconst verifySignature = async (delegation, verifier) => {\n  const valid = await UCAN.verifySignature(delegation.data, verifier)\n  return valid\n    ? { ok: delegation }\n    : { error: new InvalidSignature(delegation, verifier) }\n}\n\n/**\n * Attempts to find an authorization session - an `ucan/attest` capability\n * delegation where `with` matches `config.authority` and `nb.proof`\n * matches given delegation.\n * @see https://github.com/storacha/specs/blob/feat/auth+account/w3-session.md#authorization-session\n *\n * @param {API.Delegation} delegation\n * @param {API.Delegation[]} proofs\n * @param {Required<API.ClaimOptions>} config\n */\nconst verifySession = async (delegation, proofs, config) => {\n  // Recognize attestations from all authorized principals, not just authority\n  const withSchemas = config.proofs\n    .filter(\n      p =>\n        p.capabilities[0].can === 'ucan/attest' &&\n        p.capabilities[0].with === config.authority.did()\n    )\n    .map(p => Schema.literal(p.audience.did()))\n\n  const withSchema = withSchemas.length\n    ? Schema.union([Schema.literal(config.authority.did()), ...withSchemas])\n    : Schema.literal(config.authority.did())\n\n  // Create a schema that will match an authorization for this exact delegation\n  const attestation = capability({\n    with: withSchema,\n    can: 'ucan/attest',\n    nb: Schema.struct({\n      proof: Schema.link(delegation.cid),\n    }),\n  })\n\n  return await claim(\n    attestation,\n    proofs\n      // We only consider attestations otherwise we will end up doing an\n      // exponential scan if there are other proofs that require attestations.\n      .filter(isAttestation)\n      // Also filter any proofs that _are_ the delegation we're verifying so\n      // we don't recurse indefinitely.\n      .filter(p => p.cid.toString() !== delegation.cid.toString()),\n    config\n  )\n}\n\n/**\n * Checks if the delegation is an attestation.\n *\n * @param {API.Delegation} proof\n */\nconst isAttestation = proof => proof.capabilities[0]?.can === 'ucan/attest'\n"],"names":[],"mappings":"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","ignoreList":[0]}}]
}