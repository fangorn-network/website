{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 9, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/client/src/connection.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport { Signature, Message, Receipt, sha256 } from '@ucanto/core'\n\n/**\n * Creates a connection to a service.\n *\n * @template {Record<string, any>} T\n * @param {API.ConnectionOptions<T>} options\n * @returns {API.ConnectionView<T>}\n */\nexport const connect = options => new Connection(options)\n\n/**\n * @template {Record<string, any>} T\n * @implements {API.ConnectionView<T>}\n */\nclass Connection {\n  /**\n   * @param {API.ConnectionOptions<T>} options\n   */\n  constructor(options) {\n    this.id = options.id\n    this.options = options\n    this.codec = options.codec\n    this.channel = options.channel\n    this.hasher = options.hasher || sha256\n  }\n  /**\n   * Execute invocations.\n   *\n   * @template {API.Capability} C\n   * @template {API.Tuple<API.ServiceInvocation<C, T>>} I\n   * @param {I} invocations\n   * @returns {Promise<API.InferReceipts<I, T>>}\n   */\n  async execute(...invocations) {\n    return execute(invocations, this)\n  }\n}\n\n/**\n * @template {API.Capability} C\n * @template {Record<string, any>} T\n * @template {API.Tuple<API.ServiceInvocation<C, T>>} I\n * @param {API.Connection<T>} connection\n * @param {I} invocations\n * @returns {Promise<API.InferReceipts<I, T>>}\n */\nexport const execute = async (invocations, connection) => {\n  const input = await Message.build({ invocations })\n  const request = await connection.codec.encode(input, connection)\n  const response = await connection.channel.request(request)\n  // We may fail to decode the response if content type is not supported\n  // or if data was corrupted. We do not want to throw in such case however,\n  // because client will get an Error object as opposed to a receipt, to retain\n  // consistent client API with two kinds of errors we encode caught error as\n  // a receipts per workflow invocation.\n  try {\n    const output = await connection.codec.decode(response)\n    const receipts = input.invocationLinks.map(link => output.get(link))\n    return /** @type {API.InferReceipts<I, T>} */ (receipts)\n  } catch (error) {\n    // No third party code is run during decode and we know\n    // we only throw an Error\n    const { message, name = 'Error', ...cause } = /** @type {Error} */ (error)\n    const receipts = []\n    for await (const ran of input.invocationLinks) {\n      const receipt = await Receipt.issue({\n        ran,\n        result: { error: { ...cause, name, message } },\n        // @ts-expect-error - we can not really sign a receipt without having\n        // an access to a signer which client does not have. In the future\n        // we will change client API requiring a signer to be passed in but\n        // for now we just use a dummy signer.\n        issuer: {\n          did() {\n            return connection.id.did()\n          },\n          sign() {\n            return Signature.createNonStandard('', new Uint8Array())\n          },\n        },\n      })\n\n      receipts.push(receipt)\n    }\n\n    return /** @type {API.InferReceipts<I, T>} */ (receipts)\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;AASO,MAAM,UAAU,CAAA,UAAW,IAAI,WAAW;AAEjD;;;CAGC,GACD,MAAM;IACJ;;GAEC,GACD,YAAY,OAAO,CAAE;QACnB,IAAI,CAAC,EAAE,GAAG,QAAQ,EAAE;QACpB,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,KAAK,GAAG,QAAQ,KAAK;QAC1B,IAAI,CAAC,OAAO,GAAG,QAAQ,OAAO;QAC9B,IAAI,CAAC,MAAM,GAAG,QAAQ,MAAM,IAAI,uKAAM;IACxC;IACA;;;;;;;GAOC,GACD,MAAM,QAAQ,GAAG,WAAW,EAAE;QAC5B,OAAO,QAAQ,aAAa,IAAI;IAClC;AACF;AAUO,MAAM,UAAU,OAAO,aAAa;IACzC,MAAM,QAAQ,MAAM,gMAAO,CAAC,KAAK,CAAC;QAAE;IAAY;IAChD,MAAM,UAAU,MAAM,WAAW,KAAK,CAAC,MAAM,CAAC,OAAO;IACrD,MAAM,WAAW,MAAM,WAAW,OAAO,CAAC,OAAO,CAAC;IAClD,sEAAsE;IACtE,0EAA0E;IAC1E,6EAA6E;IAC7E,2EAA2E;IAC3E,sCAAsC;IACtC,IAAI;QACF,MAAM,SAAS,MAAM,WAAW,KAAK,CAAC,MAAM,CAAC;QAC7C,MAAM,WAAW,MAAM,eAAe,CAAC,GAAG,CAAC,CAAA,OAAQ,OAAO,GAAG,CAAC;QAC9D,OAA+C;IACjD,EAAE,OAAO,OAAO;QACd,uDAAuD;QACvD,yBAAyB;QACzB,MAAM,EAAE,OAAO,EAAE,OAAO,OAAO,EAAE,GAAG,OAAO,GAAyB;QACpE,MAAM,WAAW,EAAE;QACnB,WAAW,MAAM,OAAO,MAAM,eAAe,CAAE;YAC7C,MAAM,UAAU,MAAM,gMAAO,CAAC,KAAK,CAAC;gBAClC;gBACA,QAAQ;oBAAE,OAAO;wBAAE,GAAG,KAAK;wBAAE;wBAAM;oBAAQ;gBAAE;gBAC7C,qEAAqE;gBACrE,kEAAkE;gBAClE,mEAAmE;gBACnE,sCAAsC;gBACtC,QAAQ;oBACN;wBACE,OAAO,WAAW,EAAE,CAAC,GAAG;oBAC1B;oBACA;wBACE,OAAO,2MAAS,CAAC,iBAAiB,CAAC,IAAI,IAAI;oBAC7C;gBACF;YACF;YAEA,SAAS,IAAI,CAAC;QAChB;QAEA,OAA+C;IACjD;AACF","ignoreList":[0]}},
    {"offset": {"line": 100, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/client/src/lib.js"],"sourcesContent":["export * from './connection.js'\n\nexport * from '@ucanto/interface'\nimport { Delegation, invoke, Schema, DAG, ok, error } from '@ucanto/core'\n\nexport const delegate = Delegation.delegate\nexport { invoke, ok, error, Schema, DAG }\n"],"names":[],"mappings":";;;;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEO,MAAM,WAAW,yMAAU,CAAC,QAAQ","ignoreList":[0]}},
    {"offset": {"line": 121, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/transport/src/car/request.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport { CAR, Message } from '@ucanto/core'\n\nexport { CAR as codec }\n\nexport const contentType = CAR.contentType\n\nconst HEADERS = Object.freeze({\n  'content-type': contentType,\n  // We will signal that we want to receive a CAR file in the response\n  accept: contentType,\n})\n\n/**\n * Encodes `AgentMessage` into an `HTTPRequest`.\n *\n * @template {API.AgentMessage} Message\n * @param {Message} message\n * @param {API.EncodeOptions & { headers?: Record<string, string> }} [options]\n * @returns {API.HTTPRequest<Message>}\n */\nexport const encode = (message, options) => {\n  const blocks = new Map()\n  for (const block of message.iterateIPLDBlocks()) {\n    blocks.set(`${block.cid}`, block)\n  }\n\n  /**\n   * Cast to Uint8Array to remove phantom type set by the\n   * CAR encoder which is too specific.\n   *\n   * @type {Uint8Array}\n   */\n  const body = CAR.encode({\n    roots: [message.root],\n    blocks,\n  })\n\n  return {\n    headers: options?.headers || { ...HEADERS },\n    body,\n  }\n}\n\n/**\n * Decodes `AgentMessage` from the received `HTTPRequest`.\n *\n * @template {API.AgentMessage} Message\n * @param {API.HTTPRequest<Message>} request\n * @returns {Promise<Message>}\n */\nexport const decode = async ({ headers, body }) => {\n  const { roots, blocks } = CAR.decode(/** @type {Uint8Array} */ (body))\n  const message = Message.view({ root: roots[0].cid, store: blocks })\n  return /** @type {Message} */ (message)\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AAAA;AAAA;;;;AAIO,MAAM,cAAc,oLAAG,CAAC,WAAW;AAE1C,MAAM,UAAU,OAAO,MAAM,CAAC;IAC5B,gBAAgB;IAChB,oEAAoE;IACpE,QAAQ;AACV;AAUO,MAAM,SAAS,CAAC,SAAS;IAC9B,MAAM,SAAS,IAAI;IACnB,KAAK,MAAM,SAAS,QAAQ,iBAAiB,GAAI;QAC/C,OAAO,GAAG,CAAC,GAAG,MAAM,GAAG,EAAE,EAAE;IAC7B;IAEA;;;;;GAKC,GACD,MAAM,OAAO,oLAAG,CAAC,MAAM,CAAC;QACtB,OAAO;YAAC,QAAQ,IAAI;SAAC;QACrB;IACF;IAEA,OAAO;QACL,SAAS,SAAS,WAAW;YAAE,GAAG,OAAO;QAAC;QAC1C;IACF;AACF;AASO,MAAM,SAAS,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE;IAC5C,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,GAAG,oLAAG,CAAC,MAAM,CAA4B;IAChE,MAAM,UAAU,gMAAO,CAAC,IAAI,CAAC;QAAE,MAAM,KAAK,CAAC,EAAE,CAAC,GAAG;QAAE,OAAO;IAAO;IACjE,OAA+B;AACjC","ignoreList":[0]}},
    {"offset": {"line": 193, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/transport/src/car/response.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport { CAR, Message } from '@ucanto/core'\nexport { CAR as codec }\n\nexport const contentType = CAR.contentType\n\nconst HEADERS = Object.freeze({\n  'content-type': contentType,\n})\n\n/**\n * Encodes `AgentMessage` into an `HTTPRequest`.\n *\n * @template {API.AgentMessage} Message\n * @param {Message} message\n * @param {API.EncodeOptions} [options]\n * @returns {API.HTTPResponse<Message>}\n */\nexport const encode = (message, options) => {\n  const blocks = new Map()\n  for (const block of message.iterateIPLDBlocks()) {\n    blocks.set(`${block.cid}`, block)\n  }\n\n  /**\n   * Cast to Uint8Array to remove phantom type set by the\n   * CAR encoder which is too specific.\n   *\n   * @type {Uint8Array}\n   */\n  const body = CAR.encode({\n    roots: [message.root],\n    blocks,\n  })\n\n  return {\n    headers: { ...HEADERS },\n    body,\n  }\n}\n\n/**\n * Decodes `AgentMessage` from the received `HTTPResponse`.\n *\n * @template {API.AgentMessage} Message\n * @param {API.HTTPResponse<Message>} response\n * @returns {Promise<Message>}\n */\nexport const decode = async ({ headers, body }) => {\n  const { roots, blocks } = CAR.decode(/** @type {Uint8Array} */ (body))\n  const message = Message.view({ root: roots[0].cid, store: blocks })\n  return /** @type {Message} */ (message)\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AAAA;AAAA;;;;AAGO,MAAM,cAAc,oLAAG,CAAC,WAAW;AAE1C,MAAM,UAAU,OAAO,MAAM,CAAC;IAC5B,gBAAgB;AAClB;AAUO,MAAM,SAAS,CAAC,SAAS;IAC9B,MAAM,SAAS,IAAI;IACnB,KAAK,MAAM,SAAS,QAAQ,iBAAiB,GAAI;QAC/C,OAAO,GAAG,CAAC,GAAG,MAAM,GAAG,EAAE,EAAE;IAC7B;IAEA;;;;;GAKC,GACD,MAAM,OAAO,oLAAG,CAAC,MAAM,CAAC;QACtB,OAAO;YAAC,QAAQ,IAAI;SAAC;QACrB;IACF;IAEA,OAAO;QACL,SAAS;YAAE,GAAG,OAAO;QAAC;QACtB;IACF;AACF;AASO,MAAM,SAAS,OAAO,EAAE,OAAO,EAAE,IAAI,EAAE;IAC5C,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,GAAG,oLAAG,CAAC,MAAM,CAA4B;IAChE,MAAM,UAAU,gMAAO,CAAC,IAAI,CAAC;QAAE,MAAM,KAAK,CAAC,EAAE,CAAC,GAAG;QAAE,OAAO;IAAO;IACjE,OAA+B;AACjC","ignoreList":[0]}},
    {"offset": {"line": 263, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/transport/src/codec.js"],"sourcesContent":["import * as API from '@ucanto/interface'\n\n/**\n * @typedef {`${Lowercase<string>}/${Lowercase<string>}`|`${Lowercase<string>}/${Lowercase<string>}+${Lowercase<string>}`} ContentType\n * @typedef {`${Lowercase<string>}/${Lowercase<string>}`|`${Lowercase<string>}/${Lowercase<string>};q=${number}.${number}`} MediaType\n * @param {object} source\n * @param {Record<ContentType, API.Transport.RequestDecoder>} source.decoders\n * @param {Record<MediaType, API.Transport.ResponseEncoder>} source.encoders\n * @returns {API.InboundCodec}\n */\nexport const inbound = source => new Inbound(source)\n\n/**\n * @implements {API.InboundCodec}\n */\nclass Inbound {\n  /**\n   * @param {API.HTTPRequest} request\n   * @returns {API.Result<API.InboundAcceptCodec, API.HTTPError>} transport\n   */\n  accept({ headers }) {\n    const contentType = headers['content-type'] || headers['Content-Type']\n    const decoder = this.decoders[contentType]\n    if (!decoder) {\n      return {\n        error: {\n          status: 415,\n          message: `The server cannot process the request because the payload format is not supported. Please check the content-type header and try again with a supported media type.`,\n          headers: {\n            accept: Object.keys(this.decoders).join(', '),\n          },\n        },\n      }\n    }\n\n    const accept = parseAcceptHeader(headers.accept || headers.Accept || '*/*')\n    for (const { category, type } of accept) {\n      for (const encoder of this.encoders) {\n        const select =\n          (category === '*' || category === encoder.category) &&\n          (type === '*' || type === encoder.type)\n\n        if (select) {\n          return { ok: { ...encoder, decoder } }\n        }\n      }\n    }\n\n    return {\n      error: {\n        status: 406,\n        message: `The requested resource cannot be served in the requested content type. Please specify a supported content type using the Accept header.`,\n        headers: {\n          accept: formatAcceptHeader(Object.values(this.encoders)),\n        },\n      },\n    }\n  }\n\n  /**\n   * @param {object} source\n   * @param {Record<string, API.Transport.RequestDecoder>} source.decoders\n   * @param {Record<string, API.Transport.ResponseEncoder>} source.encoders\n   */\n  constructor({ decoders = {}, encoders = {} }) {\n    this.decoders = decoders\n\n    if (Object.keys(decoders).length === 0) {\n      throw new Error('At least one decoder MUST be provided')\n    }\n\n    // We sort the encoders by preference, so that we can pick the most\n    // preferred one when client accepts multiple content types.\n    this.encoders = Object.entries(encoders)\n      .map(([mediaType, encoder]) => {\n        return { ...parseMediaType(mediaType), encoder }\n      })\n      .sort((a, b) => b.preference - a.preference)\n\n    if (this.encoders.length === 0) {\n      throw new Error('At least one encoder MUST be provided')\n    }\n  }\n}\n\n/**\n * @param {object} source\n * @param {Record<MediaType, API.Transport.RequestEncoder>} source.encoders\n * @param {Record<ContentType, API.Transport.ResponseDecoder>} source.decoders\n * @returns {API.OutboundCodec}\n */\nexport const outbound = source => new Outbound(source)\n\n/**\n * @implements {API.OutboundCodec}\n */\nclass Outbound {\n  /**\n   * @param {object} source\n   * @param {Record<string, API.Transport.RequestEncoder>} source.encoders\n   * @param {Record<string, API.Transport.ResponseDecoder>} source.decoders\n   */\n  constructor({ decoders = {}, encoders = {} }) {\n    this.decoders = decoders\n\n    if (Object.keys(decoders).length === 0) {\n      throw new Error('At least one decoder MUST be provided')\n    }\n\n    // We sort the encoders by preference, so that we can pick the most\n    // preferred one when client accepts multiple content types.\n    this.encoders = Object.entries(encoders)\n      .map(([mediaType, encoder]) => {\n        return { ...parseMediaType(mediaType), encoder }\n      })\n      .sort((a, b) => b.preference - a.preference)\n\n    this.acceptType = formatAcceptHeader(this.encoders)\n\n    if (this.encoders.length === 0) {\n      throw new Error('At least one encoder MUST be provided')\n    }\n\n    this.encoder = this.encoders[0].encoder\n  }\n\n  /**\n   * @template {API.AgentMessage} Message\n   * @param {Message} message\n   */\n  encode(message) {\n    return this.encoder.encode(message, {\n      accept: this.acceptType,\n    })\n  }\n  /**\n   * @template {API.AgentMessage} Message\n   * @param {API.HTTPResponse<Message>} response\n   * @returns {API.Await<Message>}\n   */\n  decode(response) {\n    const { headers } = response\n    const contentType = headers['content-type'] || headers['Content-Type']\n    const decoder = this.decoders[contentType] || this.decoders['*/*']\n    switch (response.status) {\n      case 415:\n      case 406:\n        throw Object.assign(\n          new RangeError(new TextDecoder().decode(response.body)),\n          {\n            status: response.status,\n            headers: response.headers,\n          }\n        )\n    }\n    if (!decoder) {\n      throw Object.assign(\n        TypeError(\n          `Can not decode response with content-type '${contentType}' because no matching transport decoder is configured.`\n        ),\n        {\n          error: true,\n        }\n      )\n    }\n\n    return decoder.decode(response)\n  }\n}\n\n/**\n * @typedef {{ category: string, type: string, preference: number }} Media\n * @param {string} source\n * @returns {Media}\n */\nexport const parseMediaType = source => {\n  const [mediaType = '*/*', mediaRange = ''] = source.trim().split(';')\n  const [category = '*', type = '*'] = mediaType.split('/')\n  const params = new URLSearchParams(mediaRange)\n  const preference = parseFloat(params.get('q') || '0')\n  return {\n    category,\n    type,\n    /* c8 ignore next */\n    preference: isNaN(preference) ? 0 : preference,\n  }\n}\n\n/**\n * @param {Media} media\n */\nexport const formatMediaType = ({ category, type, preference }) =>\n  /** @type {MediaType}  */ (\n    `${category}/${type}${preference ? `;q=${preference}` : ''}`\n  )\n\n/**\n * @param {string} source\n */\nexport const parseAcceptHeader = source =>\n  source\n    .split(',')\n    .map(parseMediaType)\n    .sort((a, b) => b.preference - a.preference)\n\n/**\n * @param {Media[]} source\n */\nexport const formatAcceptHeader = source =>\n  source.map(formatMediaType).join(', ')\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 423, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/transport/src/car.js"],"sourcesContent":["import { CAR } from '@ucanto/core'\nimport * as request from './car/request.js'\nimport * as response from './car/response.js'\nimport * as Codec from './codec.js'\n\nexport { CAR as codec, request, response }\n\nexport const contentType = CAR.contentType\n\nexport const inbound = Codec.inbound({\n  decoders: {\n    [request.contentType]: request,\n  },\n  encoders: {\n    [response.contentType]: response,\n  },\n})\n\nexport const outbound = Codec.outbound({\n  encoders: {\n    [request.contentType]: request,\n  },\n  decoders: {\n    [response.contentType]: response,\n  },\n})\n"],"names":[],"mappings":";;;;;;;;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;;;;;;AAIO,MAAM,cAAc,oLAAG,CAAC,WAAW;AAEnC,MAAM,UAAU,gKAAa,CAAC;IACnC,UAAU;QACR,CAAC,+JAAQ,WAAW,CAAC,EAAE;IACzB;IACA,UAAU;QACR,CAAC,gKAAS,WAAW,CAAC,EAAE;IAC1B;AACF;AAEO,MAAM,WAAW,iKAAc,CAAC;IACrC,UAAU;QACR,CAAC,+JAAQ,WAAW,CAAC,EAAE;IACzB;IACA,UAAU;QACR,CAAC,gKAAS,WAAW,CAAC,EAAE;IAC1B;AACF","ignoreList":[0]}},
    {"offset": {"line": 464, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/transport/src/http.js"],"sourcesContent":["import * as API from '@ucanto/interface'\n\n/**\n * @typedef {{\n * ok: boolean\n * arrayBuffer():API.Await<ArrayBuffer>\n * headers: {\n *  entries?: () => Iterable<[string, string]>\n * } | Headers\n * status?: number\n * statusText?: string\n * url?: string\n * }} FetchResponse\n * @typedef {(url:string, init:API.HTTPRequest) => API.Await<FetchResponse>} Fetcher\n */\n/**\n * @template S\n * @param {object} options\n * @param {URL} options.url\n * @param {(url:string, init:API.HTTPRequest) => API.Await<FetchResponse>} [options.fetch]\n * @param {string} [options.method]\n * @param {Record<string, string>} [options.headers]\n * @returns {API.Channel<S>}\n */\nexport const open = ({ url, method = 'POST', fetch, headers }) => {\n  /* c8 ignore next 9 */\n  if (!fetch) {\n    if (typeof globalThis.fetch !== 'undefined') {\n      fetch = globalThis.fetch.bind(globalThis)\n    } else {\n      throw new TypeError(\n        `ucanto HTTP transport got undefined \\`fetch\\`. Try passing in a \\`fetch\\` implementation explicitly.`\n      )\n    }\n  }\n  return new Channel({ url, method, fetch, headers })\n}\n\n/**\n * @template {Record<string, any>} S\n * @implements {API.Channel<S>}\n */\nclass Channel {\n  /**\n   * @param {object} options\n   * @param {URL} options.url\n   * @param {Fetcher} options.fetch\n   * @param {string} [options.method]\n   * @param {Record<string, string>} [options.headers]\n   */\n  constructor({ url, fetch, method, headers }) {\n    this.fetch = fetch\n    this.method = method\n    this.url = url\n    this.headers = headers\n  }\n  /**\n   * @template {API.Tuple<API.ServiceInvocation<API.Capability, S>>} I\n   * @param {API.HTTPRequest<API.AgentMessage<{ In: API.InferInvocations<I>, Out: API.Tuple<API.Receipt> }>>} request\n   * @returns {Promise<API.HTTPResponse<API.AgentMessage<{ Out: API.InferReceipts<I, S>, In: API.Tuple<API.Invocation> }>>>}\n   */\n  async request({ headers, body }) {\n    const response = await this.fetch(this.url.href, {\n      headers: { ...this.headers, ...headers },\n      body,\n      method: this.method,\n    })\n\n    const buffer = response.ok\n      ? await response.arrayBuffer()\n      : HTTPError.throw(`HTTP Request failed. ${this.method} ${this.url.href} → ${response.status}`, response)\n\n    return {\n      headers: response.headers.entries\n        ? Object.fromEntries(response.headers.entries())\n        : /* c8 ignore next */\n          {},\n      body: new Uint8Array(buffer),\n    }\n  }\n}\n\n/**\n * @typedef {{\n * status?: number\n * statusText?: string\n * url?: string\n * }} Options\n */\nclass HTTPError extends Error {\n  /**\n   * @param {string} message\n   * @param {Options} options\n   * @returns {never}\n   */\n  static throw(message, options) {\n    throw new this(message, options)\n  }\n  /**\n   * @param {string} message\n   * @param {Options} options\n   */\n  constructor(message, { url, status = 500, statusText = 'Server error' }) {\n    super(message)\n    /** @type {'HTTPError'} */\n    this.name = 'HTTPError'\n    this.url = url\n    this.status = status\n    this.statusText = statusText\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;;AAwBO,MAAM,OAAO,CAAC,EAAE,GAAG,EAAE,SAAS,MAAM,EAAE,KAAK,EAAE,OAAO,EAAE;IAC3D,oBAAoB,GACpB,IAAI,CAAC,OAAO;QACV,IAAI,OAAO,WAAW,KAAK,KAAK,aAAa;YAC3C,QAAQ,WAAW,KAAK,CAAC,IAAI,CAAC;QAChC,OAAO;YACL,MAAM,IAAI,UACR,CAAC,oGAAoG,CAAC;QAE1G;IACF;IACA,OAAO,IAAI,QAAQ;QAAE;QAAK;QAAQ;QAAO;IAAQ;AACnD;AAEA;;;CAGC,GACD,MAAM;IACJ;;;;;;GAMC,GACD,YAAY,EAAE,GAAG,EAAE,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,CAAE;QAC3C,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,GAAG,GAAG;QACX,IAAI,CAAC,OAAO,GAAG;IACjB;IACA;;;;GAIC,GACD,MAAM,QAAQ,EAAE,OAAO,EAAE,IAAI,EAAE,EAAE;QAC/B,MAAM,WAAW,MAAM,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE;YAC/C,SAAS;gBAAE,GAAG,IAAI,CAAC,OAAO;gBAAE,GAAG,OAAO;YAAC;YACvC;YACA,QAAQ,IAAI,CAAC,MAAM;QACrB;QAEA,MAAM,SAAS,SAAS,EAAE,GACtB,MAAM,SAAS,WAAW,KAC1B,UAAU,KAAK,CAAC,CAAC,qBAAqB,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,EAAE,SAAS,MAAM,EAAE,EAAE;QAEjG,OAAO;YACL,SAAS,SAAS,OAAO,CAAC,OAAO,GAC7B,OAAO,WAAW,CAAC,SAAS,OAAO,CAAC,OAAO,MAC3C,kBAAkB,GAClB,CAAC;YACL,MAAM,IAAI,WAAW;QACvB;IACF;AACF;AAEA;;;;;;CAMC,GACD,MAAM,kBAAkB;IACtB;;;;GAIC,GACD,OAAO,MAAM,OAAO,EAAE,OAAO,EAAE;QAC7B,MAAM,IAAI,IAAI,CAAC,SAAS;IAC1B;IACA;;;GAGC,GACD,YAAY,OAAO,EAAE,EAAE,GAAG,EAAE,SAAS,GAAG,EAAE,aAAa,cAAc,EAAE,CAAE;QACvE,KAAK,CAAC;QACN,wBAAwB,GACxB,IAAI,CAAC,IAAI,GAAG;QACZ,IAAI,CAAC,GAAG,GAAG;QACX,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,UAAU,GAAG;IACpB;AACF","ignoreList":[0]}},
    {"offset": {"line": 550, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/transport/src/utf8.js"],"sourcesContent":["export const encoder = new TextEncoder()\nexport const decoder = new TextDecoder()\n\n/**\n * @param {string} text\n * @returns {Uint8Array}\n */\nexport const encode = text => encoder.encode(text)\n\n/**\n *\n * @param {Uint8Array} bytes\n * @returns {string}\n */\nexport const decode = bytes => decoder.decode(bytes)\n"],"names":[],"mappings":";;;;;;;;;;AAAO,MAAM,UAAU,IAAI;AACpB,MAAM,UAAU,IAAI;AAMpB,MAAM,SAAS,CAAA,OAAQ,QAAQ,MAAM,CAAC;AAOtC,MAAM,SAAS,CAAA,QAAS,QAAQ,MAAM,CAAC","ignoreList":[0]}},
    {"offset": {"line": 586, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/transport/src/legacy/response.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport * as CBOR from '@ucanto/core/cbor'\nexport const contentType = 'application/cbor'\n\nconst HEADERS = Object.freeze({\n  'content-type': contentType,\n})\n\n/**\n * Encodes `AgentMessage` into a legacy CBOR representation.\n *\n * @template {API.AgentMessage} Message\n * @param {Message} message\n * @param {API.EncodeOptions} [options]\n * @returns {API.HTTPResponse<Message>}\n */\nexport const encode = (message, options) => {\n  const legacyResults = []\n  for (const receipt of message.receipts.values()) {\n    const result = receipt.out\n    if (result.ok) {\n      legacyResults.push(result.ok)\n    } else {\n      legacyResults.push({\n        ...result.error,\n        error: true,\n      })\n    }\n  }\n\n  /** @type {Uint8Array} */\n  const body = CBOR.encode(legacyResults)\n\n  return /** @type {API.HTTPResponse<Message>} */ ({\n    headers: HEADERS,\n    body,\n  })\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AACO,MAAM,cAAc;AAE3B,MAAM,UAAU,OAAO,MAAM,CAAC;IAC5B,gBAAgB;AAClB;AAUO,MAAM,SAAS,CAAC,SAAS;IAC9B,MAAM,gBAAgB,EAAE;IACxB,KAAK,MAAM,WAAW,QAAQ,QAAQ,CAAC,MAAM,GAAI;QAC/C,MAAM,SAAS,QAAQ,GAAG;QAC1B,IAAI,OAAO,EAAE,EAAE;YACb,cAAc,IAAI,CAAC,OAAO,EAAE;QAC9B,OAAO;YACL,cAAc,IAAI,CAAC;gBACjB,GAAG,OAAO,KAAK;gBACf,OAAO;YACT;QACF;IACF;IAEA,uBAAuB,GACvB,MAAM,OAAO,yKAAW,CAAC;IAEzB,OAAiD;QAC/C,SAAS;QACT;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 623, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/transport/src/legacy/request.js"],"sourcesContent":["import * as CAR from '@ucanto/core/car'\nimport * as API from '@ucanto/interface'\nimport { Invocation, Message } from '@ucanto/core'\n\nexport const contentType = 'application/car'\n\n/**\n * @template {API.AgentMessage} Message\n * @param {API.HTTPRequest<Message>} request\n */\nexport const decode = async ({ body }) => {\n  const { roots, blocks } = CAR.decode(/** @type {Uint8Array} */ (body))\n  /** @type {API.IssuedInvocation[]} */\n  const run = []\n  for (const { cid } of roots) {\n    // We don't have a way to know if the root matches a ucan link.\n    const invocation = Invocation.view({\n      root: /** @type {API.Link} */ (cid),\n      blocks,\n    })\n    run.push(invocation)\n  }\n\n  const message = await Message.build({\n    invocations: /** @type {API.Tuple<API.IssuedInvocation>} */ (run),\n  })\n\n  return /** @type {Message} */ (message)\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AAAA;AAAA;;;;AAEO,MAAM,cAAc;AAMpB,MAAM,SAAS,OAAO,EAAE,IAAI,EAAE;IACnC,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,GAAG,wJAAU,CAA4B;IAChE,mCAAmC,GACnC,MAAM,MAAM,EAAE;IACd,KAAK,MAAM,EAAE,GAAG,EAAE,IAAI,MAAO;QAC3B,+DAA+D;QAC/D,MAAM,aAAa,yMAAU,CAAC,IAAI,CAAC;YACjC,MAA+B;YAC/B;QACF;QACA,IAAI,IAAI,CAAC;IACX;IAEA,MAAM,UAAU,MAAM,gMAAO,CAAC,KAAK,CAAC;QAClC,aAA6D;IAC/D;IAEA,OAA+B;AACjC","ignoreList":[0]}},
    {"offset": {"line": 658, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/transport/src/legacy.js"],"sourcesContent":["import * as Codec from './codec.js'\nimport * as CAR from './car.js'\nimport * as response from './legacy/response.js'\nimport * as request from './legacy/request.js'\n\nexport const { contentType } = request\nexport { request, response }\n\n/**\n * This is an inbound codec designed to support legacy clients and encode\n * responses in a legacy (CBOR) format.\n */\nexport const inbound = Codec.inbound({\n  decoders: {\n    [contentType]: request,\n    [CAR.contentType]: CAR.request,\n  },\n  encoders: {\n    // Here we configure encoders such that if accept header is `*/*` (which is\n    // the default if omitted) we will encode the response in CBOR. If\n    // `application/vnd.ipld.car` is set we will encode the response in current\n    // format.\n    // Here we exploit the fact that legacy clients do not send an accept header\n    // and therefore will get response in legacy format. New clients on the other\n    // hand will send `application/vnd.ipld.car` and consequently get response\n    // in current format.\n    '*/*;q=0.1': response,\n    [CAR.contentType]: CAR.response,\n  },\n})\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AAAA;AAAA;AACA;AACA;;;;;AAEO,MAAM,EAAE,WAAW,EAAE,GAAG;;AAOxB,MAAM,UAAU,gKAAa,CAAC;IACnC,UAAU;QACR,CAAC,YAAY,EAAE;QACf,CAAC,kLAAe,CAAC,EAAE,4MAAW;IAChC;IACA,UAAU;QACR,2EAA2E;QAC3E,kEAAkE;QAClE,2EAA2E;QAC3E,UAAU;QACV,4EAA4E;QAC5E,6EAA6E;QAC7E,0EAA0E;QAC1E,qBAAqB;QACrB,aAAa;QACb,CAAC,kLAAe,CAAC,EAAE,+MAAY;IACjC;AACF","ignoreList":[0]}},
    {"offset": {"line": 698, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/transport/src/lib.js"],"sourcesContent":["// top level exports\nexport * as CAR from './car.js'\nexport * as HTTP from './http.js'\nexport * as UTF8 from './utf8.js'\nexport * as Legacy from './legacy.js'\nexport * as Codec from './codec.js'\nexport * from './codec.js'\n"],"names":[],"mappings":"AAAA,oBAAoB;;AACpB;AACA;AACA;AACA;AACA","ignoreList":[0]}},
    {"offset": {"line": 755, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/validator/src/util.js"],"sourcesContent":["/**\n * @template {string|boolean|number|[unknown, ...unknown[]]} T\n * @param {T} value\n * @returns {T}\n */\nexport const the = value => value\n\n/**\n * @template {{}} O\n * @param {O} object\n * @returns {({ [K in keyof O]: [K, O[K]][] }[keyof O])|[[never, never]]}\n */\n\nexport const entries = object => /** @type {any} */ (Object.entries(object))\n\n/**\n * @template T\n * @param {T[][]} dataset\n * @returns {T[][]}\n */\nexport const combine = ([first, ...rest]) => {\n  const results = first.map(value => [value])\n  for (const values of rest) {\n    const tuples = results.splice(0)\n    for (const value of values) {\n      for (const tuple of tuples) {\n        results.push([...tuple, value])\n      }\n    }\n  }\n  return results\n}\n\n/**\n * @template T\n * @param {T[]} left\n * @param {T[]} right\n * @returns {T[]}\n */\nexport const intersection = (left, right) => {\n  const [result, other] =\n    left.length < right.length\n      ? [new Set(left), new Set(right)]\n      : [new Set(right), new Set(left)]\n\n  for (const item of result) {\n    if (!other.has(item)) {\n      result.delete(item)\n    }\n  }\n\n  return [...result]\n}\n"],"names":[],"mappings":"AAAA;;;;CAIC;;;;;;;;;;AACM,MAAM,MAAM,CAAA,QAAS;AAQrB,MAAM,UAAU,CAAA,SAA8B,OAAO,OAAO,CAAC;AAO7D,MAAM,UAAU,CAAC,CAAC,OAAO,GAAG,KAAK;IACtC,MAAM,UAAU,MAAM,GAAG,CAAC,CAAA,QAAS;YAAC;SAAM;IAC1C,KAAK,MAAM,UAAU,KAAM;QACzB,MAAM,SAAS,QAAQ,MAAM,CAAC;QAC9B,KAAK,MAAM,SAAS,OAAQ;YAC1B,KAAK,MAAM,SAAS,OAAQ;gBAC1B,QAAQ,IAAI,CAAC;uBAAI;oBAAO;iBAAM;YAChC;QACF;IACF;IACA,OAAO;AACT;AAQO,MAAM,eAAe,CAAC,MAAM;IACjC,MAAM,CAAC,QAAQ,MAAM,GACnB,KAAK,MAAM,GAAG,MAAM,MAAM,GACtB;QAAC,IAAI,IAAI;QAAO,IAAI,IAAI;KAAO,GAC/B;QAAC,IAAI,IAAI;QAAQ,IAAI,IAAI;KAAM;IAErC,KAAK,MAAM,QAAQ,OAAQ;QACzB,IAAI,CAAC,MAAM,GAAG,CAAC,OAAO;YACpB,OAAO,MAAM,CAAC;QAChB;IACF;IAEA,OAAO;WAAI;KAAO;AACpB","ignoreList":[0]}},
    {"offset": {"line": 809, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/validator/src/error.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport { the } from './util.js'\nimport { isLink } from '@ucanto/core/link'\nimport { fail, Failure } from '@ucanto/core/result'\n\nexport { Failure, fail }\n\nexport class EscalatedCapability extends Failure {\n  /**\n   * @param {API.ParsedCapability} claimed\n   * @param {object} delegated\n   * @param {API.Failure} cause\n   */\n  constructor(claimed, delegated, cause) {\n    super()\n    this.claimed = claimed\n    this.delegated = delegated\n    this.cause = cause\n    this.name = the('EscalatedCapability')\n  }\n  describe() {\n    return `Constraint violation: ${this.cause.message}`\n  }\n}\n\n/**\n * @implements {API.DelegationError}\n */\nexport class DelegationError extends Failure {\n  /**\n   * @param {(API.InvalidCapability | API.EscalatedDelegation | API.DelegationError)[]} causes\n   * @param {object} context\n   */\n  constructor(causes, context) {\n    super()\n    this.name = the('InvalidClaim')\n    this.causes = causes\n    this.context = context\n  }\n  describe() {\n    return [\n      `Can not derive ${this.context} from delegated capabilities:`,\n      ...this.causes.map(cause => li(cause.message)),\n    ].join('\\n')\n  }\n\n  /**\n   * @type {API.InvalidCapability | API.EscalatedDelegation | API.DelegationError}\n   */\n  get cause() {\n    /* c8 ignore next 9 */\n    if (this.causes.length !== 1) {\n      return this\n    } else {\n      const [cause] = this.causes\n      const value = cause.name === 'InvalidClaim' ? cause.cause : cause\n      Object.defineProperties(this, { cause: { value } })\n      return value\n    }\n  }\n}\n\n/**\n * @implements {API.SessionEscalation}\n */\nexport class SessionEscalation extends Failure {\n  /**\n   * @param {object} source\n   * @param {API.Delegation} source.delegation\n   * @param {API.Failure} source.cause\n   */\n  constructor({ delegation, cause }) {\n    super()\n    this.name = the('SessionEscalation')\n    this.delegation = delegation\n    this.cause = cause\n  }\n  describe() {\n    const issuer = this.delegation.issuer.did()\n    return [\n      `Delegation ${this.delegation.cid} issued by ${issuer} has an invalid session`,\n      li(this.cause.message),\n    ].join('\\n')\n  }\n}\n\n/**\n * @implements {API.InvalidSignature}\n */\nexport class InvalidSignature extends Failure {\n  /**\n   * @param {API.Delegation} delegation\n   * @param {API.Verifier} verifier\n   */\n  constructor(delegation, verifier) {\n    super()\n    this.name = the('InvalidSignature')\n    this.delegation = delegation\n    this.verifier = verifier\n  }\n  get issuer() {\n    return this.delegation.issuer\n  }\n  get audience() {\n    return this.delegation.audience\n  }\n  get key() {\n    return this.verifier.toDIDKey()\n  }\n  describe() {\n    const issuer = this.issuer.did()\n    const key = this.key\n    return (\n      issuer.startsWith('did:key')\n        ? [\n            `Proof ${this.delegation.cid} does not has a valid signature from ${key}`,\n          ]\n        : [\n            `Proof ${this.delegation.cid} issued by ${issuer} does not has a valid signature from ${key}`,\n            `  ℹ️ Probably issuer signed with a different key, which got rotated, invalidating delegations that were issued with prior keys`,\n          ]\n    ).join('\\n')\n  }\n}\n\n/**\n * @implements {API.UnavailableProof}\n */\nexport class UnavailableProof extends Failure {\n  /**\n   * @param {API.UCAN.Link} link\n   * @param {Error} [cause]\n   */\n  constructor(link, cause) {\n    super()\n    this.name = the('UnavailableProof')\n    this.link = link\n    this.cause = cause\n  }\n  describe() {\n    return [\n      `Linked proof '${this.link}' is not included and could not be resolved`,\n      ...(this.cause\n        ? [li(`Proof resolution failed with: ${this.cause.message}`)]\n        : []),\n    ].join('\\n')\n  }\n}\n\nexport class DIDKeyResolutionError extends Failure {\n  /**\n   * @param {API.UCAN.DID} did\n   * @param {API.Failure} [cause]\n   */\n  constructor(did, cause) {\n    super()\n    this.name = the('DIDKeyResolutionError')\n    this.did = did\n    this.cause = cause\n  }\n  describe() {\n    return `Unable to resolve '${this.did}' key`\n  }\n}\n\n/**\n * @implements {API.InvalidAudience}\n */\nexport class PrincipalAlignmentError extends Failure {\n  /**\n   * @param {API.UCAN.Principal} audience\n   * @param {API.Delegation} delegation\n   */\n  constructor(audience, delegation) {\n    super()\n    this.name = the('InvalidAudience')\n    this.audience = audience\n    this.delegation = delegation\n  }\n  describe() {\n    return `Delegation audience is '${this.delegation.audience.did()}' instead of '${this.audience.did()}'`\n  }\n  toJSON() {\n    const { name, audience, message, stack } = this\n    return {\n      name,\n      audience: audience.did(),\n      delegation: { audience: this.delegation.audience.did() },\n      message,\n      stack,\n    }\n  }\n}\n\n/**\n * @implements {API.MalformedCapability}\n */\nexport class MalformedCapability extends Failure {\n  /**\n   * @param {API.Capability} capability\n   * @param {API.Failure} cause\n   */\n  constructor(capability, cause) {\n    super()\n    this.name = the('MalformedCapability')\n    this.capability = capability\n    this.cause = cause\n  }\n  describe() {\n    return [\n      `Encountered malformed '${this.capability.can}' capability: ${format(\n        this.capability\n      )}`,\n      li(this.cause.message),\n    ].join('\\n')\n  }\n}\n\nexport class UnknownCapability extends Failure {\n  /**\n   * @param {API.Capability} capability\n   */\n  constructor(capability) {\n    super()\n    this.name = the('UnknownCapability')\n    this.capability = capability\n  }\n  /* c8 ignore next 3 */\n  describe() {\n    return `Encountered unknown capability: ${format(this.capability)}`\n  }\n}\n\nexport class Expired extends Failure {\n  /**\n   * @param {API.Delegation & { expiration: number }} delegation\n   */\n  constructor(delegation) {\n    super()\n    this.name = the('Expired')\n    this.delegation = delegation\n  }\n  describe() {\n    return `Proof ${this.delegation.cid} has expired on ${new Date(\n      this.delegation.expiration * 1000\n    )}`\n  }\n  get expiredAt() {\n    return this.delegation.expiration\n  }\n  toJSON() {\n    const { name, expiredAt, message, stack } = this\n    return {\n      name,\n      message,\n      expiredAt,\n      stack,\n    }\n  }\n}\n\n/**\n * @implements {API.Revoked}\n */\nexport class Revoked extends Failure {\n  /**\n   * @param {API.Delegation} delegation\n   */\n  constructor(delegation) {\n    super()\n    this.name = the('Revoked')\n    this.delegation = delegation\n  }\n  describe() {\n    return `Proof ${this.delegation.cid} has been revoked`\n  }\n  toJSON() {\n    const { name, message, stack } = this\n    return {\n      name,\n      message,\n      stack,\n    }\n  }\n}\n\nexport class NotValidBefore extends Failure {\n  /**\n   * @param {API.Delegation & { notBefore: number }} delegation\n   */\n  constructor(delegation) {\n    super()\n    this.name = the('NotValidBefore')\n    this.delegation = delegation\n  }\n  describe() {\n    return `Proof ${this.delegation.cid} is not valid before ${new Date(\n      this.delegation.notBefore * 1000\n    )}`\n  }\n  get validAt() {\n    return this.delegation.notBefore\n  }\n  toJSON() {\n    const { name, validAt, message, stack } = this\n    return {\n      name,\n      message,\n      validAt,\n      stack,\n    }\n  }\n}\n\n/**\n * @implements {API.Unauthorized}\n */\n\nexport class Unauthorized extends Failure {\n  /**\n   * @param {{\n   * capability: API.CapabilityParser\n   * delegationErrors: API.DelegationError[]\n   * unknownCapabilities: API.Capability[]\n   * invalidProofs: API.InvalidProof[]\n   * failedProofs: API.InvalidClaim[]\n   * }} cause\n   */\n  constructor({\n    capability,\n    delegationErrors,\n    unknownCapabilities,\n    invalidProofs,\n    failedProofs,\n  }) {\n    super()\n    this.name = /** @type {const} */  ('Unauthorized')\n    this.capability = capability\n    this.delegationErrors = delegationErrors\n    this.unknownCapabilities = unknownCapabilities\n    this.invalidProofs = invalidProofs\n    this.failedProofs = failedProofs\n  }\n\n  describe() {\n    const errors = [\n      ...this.failedProofs.map(error => li(error.message)),\n      ...this.delegationErrors.map(error => li(error.message)),\n      ...this.invalidProofs.map(error => li(error.message)),\n    ]\n\n    const unknown = this.unknownCapabilities.map(c => li(JSON.stringify(c)))\n\n    return [\n      `Claim ${this.capability} is not authorized`,\n      ...(errors.length > 0\n        ? errors\n        : [li(`No matching delegated capability found`)]),\n      ...(unknown.length > 0\n        ? [li(`Encountered unknown capabilities\\n${unknown.join('\\n')}`)]\n        : []),\n    ].join('\\n')\n  }\n}\n\n/**\n * @param {unknown} capability\n * @param {string|number} [space]\n */\n\nconst format = (capability, space) =>\n  JSON.stringify(\n    capability,\n    (_key, value) => {\n      /* c8 ignore next 2 */\n      if (isLink(value)) {\n        return value.toString()\n      } else {\n        return value\n      }\n    },\n    space\n  )\n\n/**\n * @param {string} message\n */\nexport const indent = (message, indent = '  ') =>\n  `${indent}${message.split('\\n').join(`\\n${indent}`)}`\n\n/**\n * @param {string} message\n */\nexport const li = message => indent(`- ${message}`)\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1157, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/validator/src/capability.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport { entries, combine, intersection } from './util.js'\nimport {\n  EscalatedCapability,\n  MalformedCapability,\n  UnknownCapability,\n  DelegationError as MatchError,\n} from './error.js'\nimport { invoke, delegate, Schema } from '@ucanto/core'\n\n/**\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @typedef {{\n * can: A\n * with: API.Reader<R, API.Resource, API.Failure>\n * nb?: Schema.MapRepresentation<C, unknown>\n * derives?: (claim: {can:A, with: R, nb: C}, proof:{can:A, with:R, nb:C}) => API.Result<{}, API.Failure>\n * }} Descriptor\n */\n\n/**\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} [C={}]\n * @param {Descriptor<A, R, C>} descriptor\n \n * @returns {API.TheCapabilityParser<API.CapabilityMatch<A, R, C>>}\n */\nexport const capability = ({\n  derives = defaultDerives,\n  nb = defaultNBSchema,\n  ...etc\n}) => new Capability({ derives, nb, ...etc })\n\nconst defaultNBSchema =\n  /** @type {Schema.MapRepresentation<any>} */\n  (Schema.struct({}))\n\n/**\n * @template {API.Match} M\n * @template {API.Match} W\n * @param {API.Matcher<M>} left\n * @param {API.Matcher<W>} right\n * @returns {API.CapabilityParser<M|W>}\n */\nexport const or = (left, right) => new Or(left, right)\n\n/**\n * @template {API.MatchSelector<API.Match>[]} Selectors\n * @param {Selectors} selectors\n * @returns {API.CapabilitiesParser<API.InferMembers<Selectors>>}\n */\nexport const and = (...selectors) => new And(selectors)\n\n/**\n * @template {API.Match} M\n * @template {API.ParsedCapability} T\n * @param {object} source\n * @param {API.MatchSelector<M>} source.from\n * @param {API.TheCapabilityParser<API.DirectMatch<T>>} source.to\n * @param {API.Derives<T, API.InferDeriveProof<M['value']>>} source.derives\n \n * @returns {API.TheCapabilityParser<API.DerivedMatch<T, M>>}\n */\nexport const derive = ({ from, to, derives }) => new Derive(from, to, derives)\n\n/**\n * @template {API.Match} M\n * @implements {API.View<M>}\n */\nclass View {\n  /**\n   * @param {API.Source} source\n   * @returns {API.MatchResult<M>}\n   */\n  /* c8 ignore next 3 */\n  match(source) {\n    return { error: new UnknownCapability(source.capability) }\n  }\n\n  /**\n   * @param {API.Source[]} capabilities\n   * @returns {API.Select<M>}\n   */\n  select(capabilities) {\n    return select(this, capabilities)\n  }\n\n  /**\n   * @template {API.ParsedCapability} U\n   * @param {object} source\n   * @param {API.TheCapabilityParser<API.DirectMatch<U>>} source.to\n   * @param {API.Derives<U, API.InferDeriveProof<M['value']>>} source.derives\n   * @returns {API.TheCapabilityParser<API.DerivedMatch<U, M>>}\n   */\n  derive({ derives, to }) {\n    return derive({ derives, to, from: this })\n  }\n}\n\n/**\n * @template {API.Match} M\n * @implements {API.CapabilityParser<M>}\n * @extends {View<M>}\n */\nclass Unit extends View {\n  /**\n   * @template {API.Match} W\n   * @param {API.MatchSelector<W>} other\n   * @returns {API.CapabilityParser<M | W>}\n   */\n  or(other) {\n    return or(this, other)\n  }\n\n  /**\n   * @template {API.Match} W\n   * @param {API.CapabilityParser<W>} other\n   * @returns {API.CapabilitiesParser<[M, W]>}\n   */\n  and(other) {\n    return and(/** @type {API.CapabilityParser<M>} */ (this), other)\n  }\n}\n\n/**\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @implements {API.TheCapabilityParser<API.DirectMatch<API.ParsedCapability<A, R, C>>>}\n * @extends {Unit<API.DirectMatch<API.ParsedCapability<A, R, C>>>}\n */\nclass Capability extends Unit {\n  /**\n   * @param {Required<Descriptor<A, R, C>>} descriptor\n   */\n  constructor(descriptor) {\n    super()\n    this.descriptor = descriptor\n    this.schema = Schema.struct({\n      can: Schema.literal(descriptor.can),\n      with: descriptor.with,\n      nb: descriptor.nb,\n    })\n  }\n\n  /**\n   * @param {API.InferCreateOptions<R, C>} options\n   */\n  create(options) {\n    const { descriptor, can } = this\n    const decoders = descriptor.nb\n    const data = /** @type {C} */ (options.nb || {})\n\n    const resource = descriptor.with.read(options.with)\n    if (resource.error) {\n      throw Object.assign(\n        new Error(`Invalid 'with' - ${resource.error.message}`),\n        {\n          cause: resource,\n        }\n      )\n    }\n\n    const nb = descriptor.nb.read(data)\n    if (nb.error) {\n      throw Object.assign(new Error(`Invalid 'nb' - ${nb.error.message}`), {\n        cause: nb,\n      })\n    }\n\n    return createCapability({ can, with: resource.ok, nb: nb.ok })\n  }\n\n  /**\n   * @param {API.InferInvokeOptions<R, C>} options\n   */\n  invoke({ with: with_, nb, ...options }) {\n    return invoke({\n      ...options,\n      capability: this.create(\n        /** @type {API.InferCreateOptions<R, C>} */\n        ({ with: with_, nb })\n      ),\n    })\n  }\n\n  /**\n   * @param {API.InferDelegationOptions<R, C>} options\n   * @returns {Promise<API.Delegation<[API.InferDelegatedCapability<API.ParsedCapability<A, R, C>>]>>}\n   */\n  async delegate({ nb: input = {}, with: with_, ...options }) {\n    const { descriptor, can } = this\n    const readers = descriptor.nb\n\n    const resource = descriptor.with.read(with_)\n    if (resource.error) {\n      throw Object.assign(\n        new Error(`Invalid 'with' - ${resource.error.message}`),\n        {\n          cause: resource,\n        }\n      )\n    }\n\n    const nb = descriptor.nb.partial().read(input)\n    if (nb.error) {\n      throw Object.assign(new Error(`Invalid 'nb' - ${nb.error.message}`), {\n        cause: nb,\n      })\n    }\n\n    return delegate({\n      capabilities: [createCapability({ can, with: resource.ok, nb: nb.ok })],\n      ...options,\n    })\n  }\n\n  get can() {\n    return this.descriptor.can\n  }\n\n  /**\n   * @param {API.Source} source\n   * @returns {API.MatchResult<API.DirectMatch<API.ParsedCapability<A, R, C>>>}\n   */\n  match(source) {\n    const result = parseCapability(this.descriptor, source)\n    return result.error\n      ? result\n      : { ok: new Match(source, result.ok, this.descriptor) }\n  }\n  toString() {\n    return JSON.stringify({ can: this.descriptor.can })\n  }\n}\n\n/**\n * Normalizes capability by removing empty nb field.\n *\n * @template {API.ParsedCapability} T\n * @param {T} source\n */\n\nconst createCapability = ({ can, with: with_, nb }) =>\n  /** @type {API.InferCapability<T>} */ ({\n    can,\n    with: with_,\n    ...(isEmpty(nb) ? {} : { nb }),\n  })\n\n/**\n * @param {object} object\n * @returns {object is {}}\n */\nconst isEmpty = object => {\n  for (const _ in object) {\n    return false\n  }\n  return true\n}\n\n/**\n * @template {API.Match} M\n * @template {API.Match} W\n * @implements {API.CapabilityParser<M|W>}\n * @extends {Unit<M|W>}\n */\nclass Or extends Unit {\n  /**\n   * @param {API.Matcher<M>} left\n   * @param {API.Matcher<W>} right\n   */\n  constructor(left, right) {\n    super()\n    this.left = left\n    this.right = right\n  }\n\n  /**\n   * @param {API.Source} capability\n   * @return {API.MatchResult<M|W>}\n   */\n  match(capability) {\n    const left = this.left.match(capability)\n    if (left.error) {\n      const right = this.right.match(capability)\n      if (right.error) {\n        return right.error.name === 'MalformedCapability'\n          ? //\n            right\n          : //\n            left\n      } else {\n        return right\n      }\n    } else {\n      return left\n    }\n  }\n\n  toString() {\n    return `${this.left.toString()}|${this.right.toString()}`\n  }\n}\n\n/**\n * @template {API.MatchSelector<API.Match>[]} Selectors\n * @implements {API.CapabilitiesParser<API.InferMembers<Selectors>>}\n * @extends {View<API.Amplify<API.InferMembers<Selectors>>>}\n */\nclass And extends View {\n  /**\n   * @param {Selectors} selectors\n   */\n  constructor(selectors) {\n    super()\n    this.selectors = selectors\n  }\n  /**\n   * @param {API.Source} capability\n   * @returns {API.MatchResult<API.Amplify<API.InferMembers<Selectors>>>}\n   */\n  match(capability) {\n    const group = []\n    for (const selector of this.selectors) {\n      const result = selector.match(capability)\n      if (result.error) {\n        return result\n      } else {\n        group.push(result.ok)\n      }\n    }\n\n    return {\n      ok: new AndMatch(/** @type {API.InferMembers<Selectors>} */ (group)),\n    }\n  }\n\n  /**\n   * @param {API.Source[]} capabilities\n   */\n  select(capabilities) {\n    return selectGroup(this, capabilities)\n  }\n  /**\n   * @template E\n   * @template {API.Match} X\n   * @param {API.MatchSelector<API.Match<E, X>>} other\n   * @returns {API.CapabilitiesParser<[...API.InferMembers<Selectors>, API.Match<E, X>]>}\n   */\n  and(other) {\n    return new And([...this.selectors, other])\n  }\n  toString() {\n    return `[${this.selectors.map(String).join(', ')}]`\n  }\n}\n\n/**\n * @template {API.ParsedCapability} T\n * @template {API.Match} M\n * @implements {API.TheCapabilityParser<API.DerivedMatch<T, M>>}\n * @extends {Unit<API.DerivedMatch<T, M>>}\n */\n\nclass Derive extends Unit {\n  /**\n   * @param {API.MatchSelector<M>} from\n   * @param {API.TheCapabilityParser<API.DirectMatch<T>>} to\n   * @param {API.Derives<T, API.InferDeriveProof<M['value']>>} derives\n   */\n  constructor(from, to, derives) {\n    super()\n    this.from = from\n    this.to = to\n    this.derives = derives\n  }\n\n  /**\n   * @type {typeof this.to['create']}\n   */\n  create(options) {\n    return this.to.create(options)\n  }\n  /**\n   * @type {typeof this.to['invoke']}\n   */\n  invoke(options) {\n    return this.to.invoke(options)\n  }\n  /**\n   * @type {typeof this.to['delegate']}\n   */\n  delegate(options) {\n    return this.to.delegate(options)\n  }\n  get can() {\n    return this.to.can\n  }\n  /**\n   * @param {API.Source} capability\n   * @returns {API.MatchResult<API.DerivedMatch<T, M>>}\n   */\n  match(capability) {\n    const match = this.to.match(capability)\n    if (match.error) {\n      return match\n    } else {\n      return { ok: new DerivedMatch(match.ok, this.from, this.derives) }\n    }\n  }\n  toString() {\n    return this.to.toString()\n  }\n}\n\n/**\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @implements {API.DirectMatch<API.ParsedCapability<A, R, C>>}\n */\nclass Match {\n  /**\n   * @param {API.Source} source\n   * @param {API.ParsedCapability<A, R, C>} value\n   * @param {Required<Descriptor<A, R, C>>} descriptor\n   */\n  constructor(source, value, descriptor) {\n    this.source = [source]\n    this.value = value\n    this.descriptor = descriptor\n  }\n  get can() {\n    return this.value.can\n  }\n\n  get proofs() {\n    const proofs = [this.source[0].delegation]\n    Object.defineProperties(this, {\n      proofs: { value: proofs },\n    })\n    return proofs\n  }\n\n  /**\n   * @param {API.CanIssue} context\n   * @returns {API.DirectMatch<API.ParsedCapability<A, R, C>>|null}\n   */\n  prune(context) {\n    if (context.canIssue(this.value, this.source[0].delegation.issuer.did())) {\n      return null\n    } else {\n      return this\n    }\n  }\n\n  /**\n   * @param {API.Source[]} capabilities\n   * @returns {API.Select<API.DirectMatch<API.ParsedCapability<A, R, C>>>}\n   */\n  select(capabilities) {\n    const unknown = []\n    const errors = []\n    const matches = []\n    for (const capability of capabilities) {\n      const result = resolveCapability(this.descriptor, this.value, capability)\n      if (result.ok) {\n        const claim = this.descriptor.derives(this.value, result.ok)\n        if (claim.error) {\n          errors.push(\n            new MatchError(\n              [new EscalatedCapability(this.value, result.ok, claim.error)],\n              this\n            )\n          )\n        } else {\n          matches.push(new Match(capability, result.ok, this.descriptor))\n        }\n      } else {\n        switch (result.error.name) {\n          case 'UnknownCapability':\n            unknown.push(result.error.capability)\n            break\n          case 'MalformedCapability':\n          default:\n            errors.push(new MatchError([result.error], this))\n        }\n      }\n    }\n\n    return { matches, unknown, errors }\n  }\n  toString() {\n    const { nb } = this.value\n    return JSON.stringify({\n      can: this.descriptor.can,\n      with: this.value.with,\n      nb: nb && Object.keys(nb).length > 0 ? nb : undefined,\n    })\n  }\n}\n\n/**\n * @template {API.ParsedCapability} T\n * @template {API.Match} M\n * @implements {API.DerivedMatch<T, M>}\n */\n\nclass DerivedMatch {\n  /**\n   * @param {API.DirectMatch<T>} selected\n   * @param {API.MatchSelector<M>} from\n   * @param {API.Derives<T, API.InferDeriveProof<M['value']>>} derives\n   */\n  constructor(selected, from, derives) {\n    this.selected = selected\n    this.from = from\n    this.derives = derives\n  }\n  get can() {\n    return this.value.can\n  }\n  get source() {\n    return this.selected.source\n  }\n  get proofs() {\n    const proofs = []\n    for (const { delegation } of this.selected.source) {\n      proofs.push(delegation)\n    }\n    Object.defineProperties(this, { proofs: { value: proofs } })\n    return proofs\n  }\n  get value() {\n    return this.selected.value\n  }\n\n  /**\n   * @param {API.CanIssue} context\n   */\n  prune(context) {\n    const selected =\n      /** @type {API.DirectMatch<T>|null} */\n      (this.selected.prune(context))\n    return selected ? new DerivedMatch(selected, this.from, this.derives) : null\n  }\n\n  /**\n   * @param {API.Source[]} capabilities\n   */\n  select(capabilities) {\n    const { derives, selected, from } = this\n    const { value } = selected\n\n    const direct = selected.select(capabilities)\n\n    const derived = from.select(capabilities)\n    const matches = []\n    const errors = []\n    for (const match of derived.matches) {\n      // If capability can not be derived it escalates\n      const result = derives(value, match.value)\n      if (result.error) {\n        errors.push(\n          new MatchError(\n            [new EscalatedCapability(value, match.value, result.error)],\n            this\n          )\n        )\n      } else {\n        matches.push(match)\n      }\n    }\n\n    return {\n      unknown: intersection(direct.unknown, derived.unknown),\n      errors: [\n        ...errors,\n        ...direct.errors,\n        ...derived.errors.map(error => new MatchError([error], this)),\n      ],\n      matches: [\n        ...direct.matches.map(match => new DerivedMatch(match, from, derives)),\n        ...matches,\n      ],\n    }\n  }\n\n  toString() {\n    return this.selected.toString()\n  }\n}\n\n/**\n * @template {API.MatchSelector<API.Match>[]} Selectors\n * @implements {API.Amplify<API.InferMembers<Selectors>>}\n */\nclass AndMatch {\n  /**\n   * @param {API.Match[]} matches\n   */\n  constructor(matches) {\n    this.matches = matches\n  }\n  get selectors() {\n    return this.matches\n  }\n  /**\n   * @returns {API.Source[]}\n   */\n  get source() {\n    const source = []\n\n    for (const match of this.matches) {\n      source.push(...match.source)\n    }\n    Object.defineProperties(this, { source: { value: source } })\n    return source\n  }\n\n  /**\n   * @param {API.CanIssue} context\n   */\n  prune(context) {\n    const matches = []\n    for (const match of this.matches) {\n      const pruned = match.prune(context)\n      if (pruned) {\n        matches.push(pruned)\n      }\n    }\n    return matches.length === 0 ? null : new AndMatch(matches)\n  }\n\n  get proofs() {\n    const proofs = []\n\n    for (const { delegation } of this.source) {\n      proofs.push(delegation)\n    }\n\n    Object.defineProperties(this, { proofs: { value: proofs } })\n    return proofs\n  }\n  /**\n   * @type {API.InferValue<API.InferMembers<Selectors>>}\n   */\n  get value() {\n    const value = []\n\n    for (const match of this.matches) {\n      value.push(match.value)\n    }\n    Object.defineProperties(this, { value: { value } })\n    return /** @type {any} */ (value)\n  }\n  /**\n   * @param {API.Source[]} capabilities\n   */\n  select(capabilities) {\n    return selectGroup(this, capabilities)\n  }\n  toString() {\n    return `[${this.matches.map(match => match.toString()).join(', ')}]`\n  }\n}\n\n/**\n * Resolves ability `pattern` of the delegated capability from the ability\n * of the claimed capability. If pattern matches returns claimed ability\n * otherwise returns given `fallback`.\n *\n * @example\n * ```js\n * resolveAbility('*', 'store/add', null) // => 'store/add'\n * resolveAbility('store/*', 'store/add', null) // => 'store/add'\n * resolveAbility('store/add', 'store/add', null) // => 'store/add'\n * resolveAbility('store/', 'store/add', null) // => null\n * resolveAbility('store/a*', 'store/add', null) // => null\n * resolveAbility('store/list', 'store/add', null) // => null\n * ```\n *\n * @template {API.Ability} T\n * @template U\n * @param {string} pattern\n * @param {T} can\n * @param {U} fallback\n * @returns {T|U}\n */\nconst resolveAbility = (pattern, can, fallback) => {\n  switch (pattern) {\n    case can:\n    case '*':\n      return can\n    default:\n      return pattern.endsWith('/*') && can.startsWith(pattern.slice(0, -1))\n        ? can\n        : fallback\n  }\n}\n\n/**\n * Resolves `source` resource of the delegated capability from the resource\n * `uri` of the claimed capability. If `source` is `\"ucan:*\"\"` or matches `uri`\n * then it returns `uri` back otherwise it returns `fallback`.\n *\n * @example\n * ```js\n * resolveResource('ucan:*', 'did:key:zAlice', null) // => 'did:key:zAlice'\n * resolveAbility('ucan:*', 'https://example.com', null) // => 'https://example.com'\n * resolveAbility('did:*', 'did:key:zAlice', null) // => null\n * resolveAbility('did:key:zAlice', 'did:key:zAlice', null) // => did:key:zAlice\n * ```\n * @template {string} T\n * @template U\n * @param {T} uri\n * @param {string} source\n * @param {U} fallback\n * @returns {T|U}\n */\nconst resolveResource = (source, uri, fallback) => {\n  switch (source) {\n    case uri:\n    case 'ucan:*':\n      return uri\n    default:\n      return fallback\n  }\n}\n\n/**\n * Parses capability from the `source` using a provided `parser`.\n *\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @param {Required<Descriptor<A, R, C>>} descriptor\n * @param {API.Source} source\n * @returns {API.Result<API.ParsedCapability<A, R, C>, API.InvalidCapability>}\n */\nconst parseCapability = (descriptor, source) => {\n  const { delegation } = source\n  const capability = /** @type {API.Capability<A, R, C>} */ (source.capability)\n\n  if (descriptor.can !== capability.can) {\n    return { error: new UnknownCapability(capability) }\n  }\n\n  const uri = descriptor.with.read(capability.with)\n  if (uri.error) {\n    return { error: new MalformedCapability(capability, uri.error) }\n  }\n\n  const nb = descriptor.nb.read(capability.nb || {})\n  if (nb.error) {\n    return { error: new MalformedCapability(capability, nb.error) }\n  }\n\n  return { ok: new CapabilityView(descriptor.can, uri.ok, nb.ok, delegation) }\n}\n\n/**\n * Resolves delegated capability `source` from the `claimed` capability using\n * provided capability `parser`. It is similar to `parseCapability` except\n * `source` here is treated as capability pattern which is matched against the\n * `claimed` capability. This means we resolve `can` and `with` fields from the\n * `claimed` capability and inherit all missing `nb` fields from the claimed\n * capability.\n *\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @param {Required<Descriptor<A, R, C>>} descriptor\n * @param {API.ParsedCapability<A, R, C>} claimed\n * @param {API.Source} source\n * @returns {API.Result<API.ParsedCapability<A, R, C>, API.InvalidCapability>}\n */\n\nconst resolveCapability = (descriptor, claimed, { capability, delegation }) => {\n  const can = resolveAbility(capability.can, claimed.can, null)\n  if (can == null) {\n    return { error: new UnknownCapability(capability) }\n  }\n\n  const resource = resolveResource(\n    capability.with,\n    claimed.with,\n    capability.with\n  )\n  const uri = descriptor.with.read(resource)\n  if (uri.error) {\n    return { error: new MalformedCapability(capability, uri.error) }\n  }\n\n  const nb = descriptor.nb.read({\n    ...claimed.nb,\n    ...capability.nb,\n  })\n\n  if (nb.error) {\n    return { error: new MalformedCapability(capability, nb.error) }\n  }\n\n  return { ok: new CapabilityView(can, uri.ok, nb.ok, delegation) }\n}\n\n/**\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template C\n */\nclass CapabilityView {\n  /**\n   * @param {A} can\n   * @param {R} with_\n   * @param {C} nb\n   * @param {API.Delegation} delegation\n   */\n  constructor(can, with_, nb, delegation) {\n    this.can = can\n    this.with = with_\n    this.delegation = delegation\n    this.nb = nb\n  }\n}\n\n/**\n * @template {API.Match} M\n * @param {API.Matcher<M>} matcher\n * @param {API.Source[]} capabilities\n * @returns {API.Select<M>}\n */\n\nconst select = (matcher, capabilities) => {\n  const unknown = []\n  const matches = []\n  const errors = []\n  for (const capability of capabilities) {\n    const result = matcher.match(capability)\n    if (result.error) {\n      switch (result.error.name) {\n        case 'UnknownCapability':\n          unknown.push(result.error.capability)\n          break\n        case 'MalformedCapability':\n        default:\n          errors.push(new MatchError([result.error], result.error.capability))\n      }\n    } else {\n      matches.push(result.ok)\n    }\n  }\n\n  return { matches, errors, unknown }\n}\n\n/**\n * @template {API.Selector<API.Match>[]} S\n * @param {{selectors:S}} self\n * @param {API.Source[]} capabilities\n */\n\nconst selectGroup = (self, capabilities) => {\n  let unknown\n  const data = []\n  const errors = []\n  for (const selector of self.selectors) {\n    const selected = selector.select(capabilities)\n    unknown = unknown\n      ? intersection(unknown, selected.unknown)\n      : selected.unknown\n\n    for (const error of selected.errors) {\n      errors.push(new MatchError([error], self))\n    }\n\n    data.push(selected.matches)\n  }\n\n  const matches = combine(data).map(group => new AndMatch(group))\n\n  return {\n    unknown:\n      /* c8 ignore next */\n      unknown || [],\n    errors,\n    matches,\n  }\n}\n\n/**\n * @template {API.ParsedCapability} T\n * @template {API.ParsedCapability} U\n * @param {T} claimed\n * @param {U} delegated\n * @return {API.Result<true, API.Failure>}\n */\nconst defaultDerives = (claimed, delegated) => {\n  if (delegated.with.endsWith('*')) {\n    if (!claimed.with.startsWith(delegated.with.slice(0, -1))) {\n      return Schema.error(\n        `Resource ${claimed.with} does not match delegated ${delegated.with} `\n      )\n    }\n  } else if (delegated.with !== claimed.with) {\n    return Schema.error(\n      `Resource ${claimed.with} is not contained by ${delegated.with}`\n    )\n  }\n\n  /* c8 ignore next 2 */\n  const caveats = delegated.nb || {}\n  const nb = claimed.nb || {}\n  const kv = entries(caveats)\n\n  for (const [name, value] of kv) {\n    if (nb[name] != value) {\n      return Schema.error(`${String(name)}: ${nb[name]} violates ${value}`)\n    }\n  }\n\n  return { ok: true }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1969, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/validator/src/authorization.js"],"sourcesContent":["import * as API from '@ucanto/interface'\n\n/**\n * @template {API.ParsedCapability} C\n * @implements {API.Authorization<C>}\n */\nclass Authorization {\n  /**\n   * @param {API.Match<C>} match\n   * @param {API.Authorization<API.ParsedCapability>[]} proofs\n   */\n  constructor(match, proofs) {\n    this.match = match\n    this.proofs = proofs\n  }\n  get capability() {\n    return this.match.value\n  }\n  get delegation() {\n    return this.match.source[0].delegation\n  }\n  get issuer() {\n    return this.delegation.issuer\n  }\n  get audience() {\n    return this.delegation.audience\n  }\n}\n\n/**\n * @template {API.ParsedCapability} C\n * @param {API.Match<C>} match\n * @param {API.Authorization<API.ParsedCapability>[]} proofs\n * @returns {API.Authorization<C>}\n */\nexport const create = (match, proofs = []) => new Authorization(match, proofs)\n\n/**\n *\n * @param {API.Authorization} authorization\n * @returns {Iterable<API.UCANLink>}\n */\nexport const iterate = function* ({ delegation, proofs }) {\n  yield delegation.cid\n  for (const proof of proofs) {\n    yield* iterate(proof)\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;;AAEA;;;CAGC,GACD,MAAM;IACJ;;;GAGC,GACD,YAAY,KAAK,EAAE,MAAM,CAAE;QACzB,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,MAAM,GAAG;IAChB;IACA,IAAI,aAAa;QACf,OAAO,IAAI,CAAC,KAAK,CAAC,KAAK;IACzB;IACA,IAAI,aAAa;QACf,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC,UAAU;IACxC;IACA,IAAI,SAAS;QACX,OAAO,IAAI,CAAC,UAAU,CAAC,MAAM;IAC/B;IACA,IAAI,WAAW;QACb,OAAO,IAAI,CAAC,UAAU,CAAC,QAAQ;IACjC;AACF;AAQO,MAAM,SAAS,CAAC,OAAO,SAAS,EAAE,GAAK,IAAI,cAAc,OAAO;AAOhE,MAAM,UAAU,UAAW,EAAE,UAAU,EAAE,MAAM,EAAE;IACtD,MAAM,WAAW,GAAG;IACpB,KAAK,MAAM,SAAS,OAAQ;QAC1B,OAAO,QAAQ;IACjB;AACF","ignoreList":[0]}},
    {"offset": {"line": 2012, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/validator/src/lib.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport { isDelegation, UCAN, ok, fail } from '@ucanto/core'\nimport { capability } from './capability.js'\nimport * as Schema from '@ucanto/core/schema'\nimport * as Authorization from './authorization.js'\nimport {\n  UnavailableProof,\n  Unauthorized,\n  PrincipalAlignmentError,\n  Expired,\n  Revoked,\n  NotValidBefore,\n  InvalidSignature,\n  SessionEscalation,\n  Failure,\n  MalformedCapability,\n  DIDKeyResolutionError,\n  li,\n} from './error.js'\n\nexport { capability } from './capability.js'\nexport * from '@ucanto/core/schema'\n\nexport {\n  Schema,\n  Authorization,\n  Failure,\n  fail,\n  ok,\n  Revoked,\n  UnavailableProof,\n  Unauthorized,\n  MalformedCapability,\n  DIDKeyResolutionError as DIDResolutionError,\n}\n\n/**\n * @param {UCAN.Link} proof\n * @returns {{error:API.UnavailableProof}}\n */\nconst unavailable = proof => ({ error: new UnavailableProof(proof) })\n\n/**\n *\n * @param {UCAN.DID} did\n * @returns {{error:API.DIDKeyResolutionError}}\n */\nconst failDIDKeyResolution = did => ({ error: new DIDKeyResolutionError(did) })\n\n/**\n * @param {Required<API.ClaimOptions>} config\n * @param {API.Match<unknown, API.Match>} match\n */\n\nconst resolveMatch = async (match, config) => {\n  const promises = []\n  const includes = new Set()\n  for (const source of match.source) {\n    const id = source.delegation.cid.toString()\n    if (!includes.has(id)) {\n      promises.push(await resolveSources(source, config))\n    }\n  }\n  const groups = await Promise.all(promises)\n  const sources = []\n  const errors = []\n  for (const group of groups) {\n    sources.push(...group.sources)\n    errors.push(...group.errors)\n  }\n\n  return { sources, errors }\n}\n\n/**\n * Takes `proofs` from the delegation which may contain `Delegation` or a link\n * to one and attempts to resolve links by side loading them. Returns set of\n * resolved `Delegation`s and errors for the proofs that could not be resolved.\n *\n * @param {API.Proof[]} proofs\n * @param {Required<API.ProofResolver>} config\n */\nconst resolveProofs = async (proofs, config) => {\n  /** @type {API.Delegation[]} */\n  const delegations = []\n  /** @type {API.UnavailableProof[]} */\n  const errors = []\n  const promises = []\n  for (const proof of proofs) {\n    // If it is a delegation we can just add it to the resolved set.\n    if (isDelegation(proof)) {\n      delegations.push(proof)\n    }\n    // otherwise we attempt to resolve the link asynchronously. To avoid doing\n    // sequential requests we create promise for each link and then wait for\n    // all of them at the end.\n    else {\n      promises.push(\n        new Promise(async resolve => {\n          // config.resolve is not supposed to throw, but we catch it just in\n          // case it does and consider proof resolution failed.\n          try {\n            const result = await config.resolve(proof)\n            if (result.error) {\n              errors.push(result.error)\n            } else {\n              delegations.push(result.ok)\n            }\n          } catch (error) {\n            errors.push(\n              new UnavailableProof(proof, /** @type {Error} */(error))\n            )\n          }\n\n          // we don't care about the result, we just need to signal that we are\n          // done with this promise.\n          resolve(null)\n        })\n      )\n    }\n  }\n\n  // Wait for all the promises to resolve. At this point we have collected all\n  // the resolved delegations and errors.\n  await Promise.all(promises)\n  return { delegations, errors }\n}\n\n/**\n * Takes a delegation source and attempts to resolve all the linked proofs.\n *\n * @param {API.Source} from\n * @param {Required<API.ClaimOptions>} config\n * @return {Promise<{sources:API.Source[], errors:ProofError[]}>}\n */\nconst resolveSources = async ({ delegation }, config) => {\n  const errors = []\n  const sources = []\n  const proofs = []\n  // First we attempt to resolve all the linked proofs.\n  const { delegations, errors: failedProofs } = await resolveProofs(\n    delegation.proofs,\n    config\n  )\n\n  // All the proofs that failed to resolve are saved as proof errors.\n  for (const error of failedProofs) {\n    errors.push(new ProofError(error.link, error))\n  }\n\n  // All the proofs that resolved are checked for principal alignment. Ones that\n  // do not align are saved as proof errors.\n  for (const proof of delegations) {\n    // If proof does not delegate to a matching audience save an proof error.\n    if (delegation.issuer.did() !== proof.audience.did()) {\n      errors.push(\n        new ProofError(\n          proof.cid,\n          new PrincipalAlignmentError(delegation.issuer, proof)\n        )\n      )\n    } else {\n      proofs.push(proof)\n    }\n  }\n  // In the second pass we attempt to proofs that were resolved and are aligned.\n  for (const proof of proofs) {\n    // If proof is not valid (expired, not active yet or has incorrect\n    // signature) save a corresponding proof error.\n    const validation = await validate(proof, proofs, config)\n    if (validation.error) {\n      errors.push(new ProofError(proof.cid, validation.error))\n    } else {\n      // otherwise create source objects for it's capabilities, so we could\n      // track which proof in which capability the are from.\n      for (const capability of proof.capabilities) {\n        sources.push(\n          /** @type {API.Source} */({\n            capability,\n            delegation: proof,\n          })\n        )\n      }\n    }\n  }\n\n  return { sources, errors }\n}\n\n/**\n * @param {API.ParsedCapability} capability\n * @param {API.DID} issuer\n */\nconst isSelfIssued = (capability, issuer) => capability.with === issuer\n\n/**\n * Finds a valid path in a proof chain of the given `invocation` by exploring\n * every possible option. On success an `Authorization` object is returned that\n * illustrates the valid path. If no valid path is found `Unauthorized` error\n * is returned detailing all explored paths and where they proved to fail.\n *\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {R} URI\n * @template {API.Caveats} C\n * @param {API.Invocation<API.Capability<A, URI, C>>} invocation\n * @param {API.ValidationOptions<API.ParsedCapability<A, R, C>>} options\n * @returns {Promise<API.Result<API.Authorization<API.ParsedCapability<A, R, C>>, API.Unauthorized>>}\n */\nexport const access = async (invocation, { capability, ...config }) =>\n  claim(capability, [invocation], config)\n\n/**\n * Attempts to find a valid proof chain for the claimed `capability` given set\n * of `proofs`. On success an `Authorization` object with detailed proof chain\n * is returned and on failure `Unauthorized` error is returned with details on\n * paths explored and why they have failed.\n *\n * @template {API.Ability} A\n * @template {API.URI} R\n * @template {API.Caveats} C\n * @param {API.CapabilityParser<API.Match<API.ParsedCapability<A, R, C>>>} capability\n * @param {API.Proof[]} proofs\n * @param {API.ClaimOptions} config\n * @returns {Promise<API.Result<API.Authorization<API.ParsedCapability<A, R, C>>, API.Unauthorized>>}\n */\nexport const claim = async (\n  capability,\n  proofs,\n  {\n    authority,\n    principal,\n    validateAuthorization,\n    resolveDIDKey = failDIDKeyResolution,\n    canIssue = isSelfIssued,\n    resolve = unavailable,\n    proofs: localProofs = [],\n  }\n) => {\n  const config = {\n    canIssue,\n    resolve,\n    principal,\n    capability,\n    authority,\n    validateAuthorization,\n    resolveDIDKey,\n    proofs: localProofs,\n  }\n\n  const invalidProofs = []\n\n  /** @type {API.Source[]} */\n  const sources = []\n\n  const { delegations, errors } = await resolveProofs(proofs, config)\n  invalidProofs.push(...errors)\n\n  for (const proof of delegations) {\n    // Validate each proof if valid add ech capability to the list of sources.\n    // otherwise collect the error.\n    const validation = await validate(proof, delegations, config)\n    if (validation.ok) {\n      for (const capability of validation.ok.capabilities.values()) {\n        sources.push(\n          /** @type {API.Source} */({\n            capability,\n            delegation: validation.ok,\n          })\n        )\n      }\n    } else {\n      invalidProofs.push(validation.error)\n    }\n  }\n  // look for the matching capability\n  const selection = capability.select(sources)\n\n  const { errors: delegationErrors, unknown: unknownCapabilities } = selection\n  const failedProofs = []\n  for (const matched of selection.matches) {\n    const selector = matched.prune(config)\n    if (selector == null) {\n      const authorization = Authorization.create(matched, [])\n      const result = await validateAuthorization(authorization)\n      if (result.error) {\n        invalidProofs.push(result.error)\n      } else {\n        return { ok: authorization }\n      }\n    } else {\n      const result = await authorize(selector, config)\n      if (result.error) {\n        failedProofs.push(result.error)\n      } else {\n        const authorization = Authorization.create(matched, [result.ok])\n        const approval = await validateAuthorization(authorization)\n        if (approval.error) {\n          invalidProofs.push(approval.error)\n        } else {\n          return { ok: authorization }\n        }\n      }\n    }\n  }\n\n  return {\n    error: new Unauthorized({\n      capability,\n      delegationErrors,\n      unknownCapabilities,\n      invalidProofs,\n      failedProofs,\n    }),\n  }\n}\n\n/**\n * Verifies whether any of the delegated proofs grant give capability.\n *\n * @template {API.Match} Match\n * @param {Match} match\n * @param {Required<API.ClaimOptions>} config\n * @returns {Promise<API.Result<API.Authorization<API.ParsedCapability>, API.InvalidClaim>>}\n */\n\nexport const authorize = async (match, config) => {\n  // load proofs from all delegations\n  const { sources, errors: invalidProofs } = await resolveMatch(match, config)\n\n  const selection = match.select(sources)\n  const { errors: delegationErrors, unknown: unknownCapabilities } = selection\n\n  const failedProofs = []\n  for (const matched of selection.matches) {\n    const selector = matched.prune(config)\n    if (selector == null) {\n      return {\n        ok: Authorization.create(\n          // @ts-expect-error - it may not be a parsed capability but rather a\n          // group of capabilities but we can deal with that in the future.\n          matched,\n          []\n        ),\n      }\n    } else {\n      const result = await authorize(selector, config)\n      if (result.error) {\n        failedProofs.push(result.error)\n      } else {\n        return {\n          ok: Authorization.create(\n            // @ts-expect-error - it may not be a parsed capability but rather a\n            // group of capabilities but we can deal with that in the future.\n            matched,\n            [result.ok]\n          ),\n        }\n      }\n    }\n  }\n\n  return {\n    error: new InvalidClaim({\n      match,\n      delegationErrors,\n      unknownCapabilities,\n      invalidProofs,\n      failedProofs,\n    }),\n  }\n}\n\nclass ProofError extends Failure {\n  /**\n   * @param {API.UCANLink} proof\n   * @param {API.Failure} cause\n   */\n  constructor(proof, cause) {\n    super()\n    this.name = 'ProofError'\n    this.proof = proof\n    this.cause = cause\n  }\n  describe() {\n    return [\n      `Capability can not be derived from prf:${this.proof} because:`,\n      li(this.cause.message),\n    ].join(`\\n`)\n  }\n}\n\n/**\n * @implements {API.InvalidClaim}\n */\nclass InvalidClaim extends Failure {\n  /**\n   * @param {{\n   * match: API.Match\n   * delegationErrors: API.DelegationError[]\n   * unknownCapabilities: API.Capability[]\n   * invalidProofs: ProofError[]\n   * failedProofs: API.InvalidClaim[]\n   * }} info\n   */\n  constructor(info) {\n    super()\n    this.info = info\n    this.name = /** @type {const} */ ('InvalidClaim')\n  }\n  get issuer() {\n    return this.delegation.issuer\n  }\n  get delegation() {\n    return this.info.match.source[0].delegation\n  }\n  describe() {\n    const errors = [\n      ...this.info.failedProofs.map(error => li(error.message)),\n      ...this.info.delegationErrors.map(error => li(error.message)),\n      ...this.info.invalidProofs.map(error => li(error.message)),\n    ]\n\n    const unknown = this.info.unknownCapabilities.map(c =>\n      li(JSON.stringify(c))\n    )\n\n    return [\n      `Capability ${this.info.match} is not authorized because:`,\n      li(`Capability can not be (self) issued by '${this.issuer.did()}'`),\n      ...(errors.length > 0 ? errors : [li(`Delegated capability not found`)]),\n      ...(unknown.length > 0\n        ? [li(`Encountered unknown capabilities\\n${unknown.join('\\n')}`)]\n        : []),\n    ].join('\\n')\n  }\n}\n\n/**\n * Validate a delegation to check it is within the time bound and that it is\n * authorized by the issuer.\n *\n * @template {API.Delegation} T\n * @param {T} delegation\n * @param {API.Delegation[]} proofs\n * @param {Required<API.ClaimOptions>} config\n * @returns {Promise<API.Result<T, API.InvalidProof|API.SessionEscalation|API.DIDKeyResolutionError>>}\n */\nconst validate = async (delegation, proofs, config) => {\n  if (UCAN.isExpired(delegation.data)) {\n    return {\n      error: new Expired(\n        /** @type {API.Delegation & {expiration: number}} */(delegation)\n      ),\n    }\n  }\n\n  if (UCAN.isTooEarly(delegation.data)) {\n    return {\n      error: new NotValidBefore(\n        /** @type {API.Delegation & {notBefore: number}} */(delegation)\n      ),\n    }\n  }\n\n  return await verifyAuthorization(delegation, proofs, config)\n}\n\n/**\n * Verifies that delegation has been authorized by the issuer. If issued by the\n * did:key principal checks that the signature is valid. If issued by the root\n * authority checks that the signature is valid. If issued by the principal\n * identified by other DID method attempts to resolve a valid `ucan/attest`\n * attestation from the authority, if attestation is not found falls back to\n * resolving did:key for the issuer and verifying its signature.\n *\n * @template {API.Delegation} T\n * @param {T} delegation\n * @param {API.Delegation[]} proofs\n * @param {Required<API.ClaimOptions>} config\n * @returns {Promise<API.Result<T, API.InvalidSignature|API.SessionEscalation|API.DIDKeyResolutionError>>}\n */\nconst verifyAuthorization = async (delegation, proofs, config) => {\n  const issuer = delegation.issuer.did()\n  // If the issuer is a did:key we just verify a signature\n  if (issuer.startsWith('did:key:')) {\n    return verifySignature(delegation, config.principal.parse(issuer))\n  }\n\n  // If the issuer is the root authority we use authority itself to verify\n  else if (issuer === config.authority.did()) {\n    return verifySignature(delegation, config.authority)\n  } else {\n    // If issuer is not a did:key principal nor configured authority, we\n    // attempt to resolve embedded authorization session from the authority.\n    const session = await verifySession(delegation, proofs, config)\n    // If we have valid session we consider authorization valid\n    if (session.ok) {\n      return { ok: delegation }\n    } else if (session.error.failedProofs.length > 0) {\n      return {\n        error: new SessionEscalation({ delegation, cause: session.error }),\n      }\n    }\n    // Otherwise we try to resolve did:key from the DID instead\n    // and use that to verify the signature\n    else {\n      const result = await config.resolveDIDKey(issuer)\n      if (result.error) {\n        return result\n      }\n\n      const verifiers = result.ok\n      /** @type {(API.InvalidSignature | API.DIDKeyResolutionError)[]} */\n      const verificationErrResults = []\n      for (const verifier of verifiers) {\n        const verificationResult = await verifySignature(\n          delegation,\n          config.principal.parse(verifier).withDID(issuer)\n        )\n        if (verificationResult.ok) {\n          return verificationResult\n        }\n        if (verificationResult.error) {\n          verificationErrResults.push(verificationResult.error)\n        }\n      }\n      \n      // If no verifiers were found, there is no way to verify the signature\n      if (verificationErrResults.length === 0) {\n        return { error: new DIDKeyResolutionError(issuer) }\n      }\n\n      const combinedError = verificationErrResults[0]\n      const combinedMessage = verificationErrResults\n        .map(err => err.message)\n        .join('\\n  ')\n      \n      // @ts-expect-error - both error types have describe method, override it to return the concatenated message\n      combinedError.describe = () => combinedMessage\n\n      return { error: combinedError }\n    }\n  }\n}\n\n/**\n * @template {API.Delegation} T\n * @param {T} delegation\n * @param {API.Verifier} verifier\n * @returns {Promise<API.Result<T, API.InvalidSignature|API.DIDKeyResolutionError>>}\n */\nconst verifySignature = async (delegation, verifier) => {\n  const valid = await UCAN.verifySignature(delegation.data, verifier)\n  return valid\n    ? { ok: delegation }\n    : { error: new InvalidSignature(delegation, verifier) }\n}\n\n/**\n * Attempts to find an authorization session - an `ucan/attest` capability\n * delegation where `with` matches `config.authority` and `nb.proof`\n * matches given delegation.\n * @see https://github.com/storacha/specs/blob/feat/auth+account/w3-session.md#authorization-session\n *\n * @param {API.Delegation} delegation\n * @param {API.Delegation[]} proofs\n * @param {Required<API.ClaimOptions>} config\n */\nconst verifySession = async (delegation, proofs, config) => {\n  // Recognize attestations from all authorized principals, not just authority\n  const withSchemas = config.proofs\n    .filter(\n      p =>\n        p.capabilities[0].can === 'ucan/attest' &&\n        p.capabilities[0].with === config.authority.did()\n    )\n    .map(p => Schema.literal(p.audience.did()))\n\n  const withSchema = withSchemas.length\n    ? Schema.union([Schema.literal(config.authority.did()), ...withSchemas])\n    : Schema.literal(config.authority.did())\n\n  // Create a schema that will match an authorization for this exact delegation\n  const attestation = capability({\n    with: withSchema,\n    can: 'ucan/attest',\n    nb: Schema.struct({\n      proof: Schema.link(delegation.cid),\n    }),\n  })\n\n  return await claim(\n    attestation,\n    proofs\n      // We only consider attestations otherwise we will end up doing an\n      // exponential scan if there are other proofs that require attestations.\n      .filter(isAttestation)\n      // Also filter any proofs that _are_ the delegation we're verifying so\n      // we don't recurse indefinitely.\n      .filter(p => p.cid.toString() !== delegation.cid.toString()),\n    config\n  )\n}\n\n/**\n * Checks if the delegation is an attestation.\n *\n * @param {API.Delegation} proof\n */\nconst isAttestation = proof => proof.capabilities[0]?.can === 'ucan/attest'\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2491, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 2496, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/principal/src/verifier.js"],"sourcesContent":["import * as API from '@ucanto/interface'\n\n/**\n * @param {API.DID} did\n * @param {API.PrincipalParser[]} parsers\n * @return {API.Verifier}\n */\nconst parseWith = (did, parsers) => {\n  if (did.startsWith('did:')) {\n    for (const parser of parsers) {\n      try {\n        return parser.parse(did)\n      } catch (_) {}\n    }\n    throw new Error(`Unsupported did ${did}`)\n  } else {\n    throw new Error(`Expected did instead got ${did}`)\n  }\n}\n\n/**\n * @param {API.PrincipalParser} left\n * @param {API.PrincipalParser} right\n * @returns {API.ComposedDIDParser}\n */\nexport const or = (left, right) => new Parser([left, right])\n\n/**\n * @implements {API.ComposedDIDParser}\n */\nclass Parser {\n  /**\n   * @param {API.PrincipalParser[]} variants\n   */\n  constructor(variants) {\n    this.variants = variants\n  }\n\n  /**\n   * @param {API.DID} did\n   */\n  parse(did) {\n    return parseWith(did, this.variants)\n  }\n\n  /**\n   * @param {API.PrincipalParser} parser\n   */\n  or(parser) {\n    return new Parser([...this.variants, parser])\n  }\n}\n\n/**\n * @template {API.DID} ID\n * @template {API.MulticodecCode} SigAlg\n * @param {API.VerifierKey<SigAlg>} key\n * @param {ID} id\n * @returns {API.Verifier<ID, SigAlg>}\n */\nexport const withDID = (key, id) => new VerifierWithDID(id, key)\n\n/**\n * @template {API.DID} ID\n * @template {API.MulticodecCode} SigAlg\n * @implements {API.Verifier<ID, SigAlg>}\n */\nclass VerifierWithDID {\n  /**\n   * @param {ID} id\n   * @param {API.VerifierKey<SigAlg>} key\n   */\n  constructor(id, key) {\n    this.id = id\n    this.key = key\n  }\n  did() {\n    return this.id\n  }\n\n  toDIDKey() {\n    return this.key.toDIDKey()\n  }\n\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @param {API.Signature<T, SigAlg>} signature\n   * @returns {API.Await<boolean>}\n   */\n  verify(payload, signature) {\n    return this.key.verify(payload, signature)\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   */\n  withDID(id) {\n    return withDID(this.key, id)\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;;AAEA;;;;CAIC,GACD,MAAM,YAAY,CAAC,KAAK;IACtB,IAAI,IAAI,UAAU,CAAC,SAAS;QAC1B,KAAK,MAAM,UAAU,QAAS;YAC5B,IAAI;gBACF,OAAO,OAAO,KAAK,CAAC;YACtB,EAAE,OAAO,GAAG,CAAC;QACf;QACA,MAAM,IAAI,MAAM,CAAC,gBAAgB,EAAE,KAAK;IAC1C,OAAO;QACL,MAAM,IAAI,MAAM,CAAC,yBAAyB,EAAE,KAAK;IACnD;AACF;AAOO,MAAM,KAAK,CAAC,MAAM,QAAU,IAAI,OAAO;QAAC;QAAM;KAAM;AAE3D;;CAEC,GACD,MAAM;IACJ;;GAEC,GACD,YAAY,QAAQ,CAAE;QACpB,IAAI,CAAC,QAAQ,GAAG;IAClB;IAEA;;GAEC,GACD,MAAM,GAAG,EAAE;QACT,OAAO,UAAU,KAAK,IAAI,CAAC,QAAQ;IACrC;IAEA;;GAEC,GACD,GAAG,MAAM,EAAE;QACT,OAAO,IAAI,OAAO;eAAI,IAAI,CAAC,QAAQ;YAAE;SAAO;IAC9C;AACF;AASO,MAAM,UAAU,CAAC,KAAK,KAAO,IAAI,gBAAgB,IAAI;AAE5D;;;;CAIC,GACD,MAAM;IACJ;;;GAGC,GACD,YAAY,EAAE,EAAE,GAAG,CAAE;QACnB,IAAI,CAAC,EAAE,GAAG;QACV,IAAI,CAAC,GAAG,GAAG;IACb;IACA,MAAM;QACJ,OAAO,IAAI,CAAC,EAAE;IAChB;IAEA,WAAW;QACT,OAAO,IAAI,CAAC,GAAG,CAAC,QAAQ;IAC1B;IAEA;;;;;GAKC,GACD,OAAO,OAAO,EAAE,SAAS,EAAE;QACzB,OAAO,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,SAAS;IAClC;IAEA;;;GAGC,GACD,QAAQ,EAAE,EAAE;QACV,OAAO,QAAQ,IAAI,CAAC,GAAG,EAAE;IAC3B;AACF","ignoreList":[0]}},
    {"offset": {"line": 2584, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/principal/src/ed25519/verifier.js"],"sourcesContent":["import * as DID from '@ipld/dag-ucan/did'\nimport * as ED25519 from '@noble/ed25519'\nimport { varint } from 'multiformats'\nimport * as API from './type.js'\nimport * as Signature from '@ipld/dag-ucan/signature'\nimport { base58btc } from 'multiformats/bases/base58'\nimport * as Verifier from '../verifier.js'\n\n/** @type {API.EdVerifier['code']} */\nexport const code = 0xed\nexport const name = 'Ed25519'\n\n/** @type {API.SigAlg} */\nexport const signatureCode = Signature.EdDSA\nexport const signatureAlgorithm = 'EdDSA'\nconst PUBLIC_TAG_SIZE = varint.encodingLength(code)\nconst SIZE = 32 + PUBLIC_TAG_SIZE\n\n/**\n * @typedef {API.EdVerifier} EdVerifier\n */\n\n/**\n * Parses `did:key:` string as a VerifyingPrincipal.\n *\n * @param {API.DID|string} did\n * @returns {API.Verifier<API.DID, typeof signatureCode>}\n */\nexport const parse = did => decode(DID.parse(did))\n\n/**\n * Takes ed25519 public key tagged with `0xed` multiformat code and creates a\n * corresponding `Principal` that can be used to verify signatures.\n *\n * @param {Uint8Array} bytes\n * @returns {API.EdVerifier}\n */\nexport const decode = bytes => {\n  const [algorithm] = varint.decode(bytes)\n  if (algorithm !== code) {\n    throw new RangeError(\n      `Unsupported key algorithm with multicode 0x${code.toString(16)}`\n    )\n  } else if (bytes.byteLength !== SIZE) {\n    throw new RangeError(\n      `Expected Uint8Array with byteLength ${SIZE}, instead got Uint8Array with byteLength ${bytes.byteLength}`\n    )\n  } else {\n    return new Ed25519Verifier(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n  }\n}\n\n/**\n * Formats given Principal into `did:key:` format.\n *\n * @param {API.Principal<API.DID>} principal\n */\nexport const format = principal => DID.format(principal)\n\n/**\n * Encodes given Principal by tagging it's ed25519 public key with `0xed`\n * multiformat code.\n *\n * @param {API.Principal<API.DID<\"key\">>} principal\n */\nexport const encode = principal => DID.encode(principal)\n\n/**\n * @implements {API.EdVerifier}\n */\nclass Ed25519Verifier extends Uint8Array {\n  /** @type {typeof code} */\n  get code() {\n    return code\n  }\n  /** @type {typeof signatureCode} */\n  get signatureCode() {\n    return signatureCode\n  }\n  /** @type {typeof signatureAlgorithm} */\n  get signatureAlgorithm() {\n    return signatureAlgorithm\n  }\n  /**\n   * Raw public key without a multiformat code.\n   *\n   * @readonly\n   */\n  get publicKey() {\n    const key = new Uint8Array(this.buffer, this.byteOffset + PUBLIC_TAG_SIZE)\n    Object.defineProperties(this, {\n      publicKey: {\n        value: key,\n      },\n    })\n    return key\n  }\n  /**\n   * DID of the Principal in `did:key` format.\n   * @returns {API.DID<\"key\">}\n   */\n  did() {\n    return `did:key:${base58btc.encode(this)}`\n  }\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @param {API.Signature<T, Signature.EdDSA>} signature\n   * @returns {API.Await<boolean>}\n   */\n  verify(payload, signature) {\n    return (\n      signature.code === signatureCode &&\n      ED25519.verify(signature.raw, payload, this.publicKey)\n    )\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   * @returns {API.Verifier<ID, typeof signatureCode>}\n   */\n  withDID(id) {\n    return Verifier.withDID(this, id)\n  }\n\n  toDIDKey() {\n    return this.did()\n  }\n}\n\n/**\n * @param {API.PrincipalParser} other\n */\nexport const or = other => Verifier.or({ parse }, other)\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;AAGO,MAAM,OAAO;AACb,MAAM,OAAO;AAGb,MAAM,gBAAgB,kKAAe;AACrC,MAAM,qBAAqB;AAClC,MAAM,kBAAkB,iMAAM,CAAC,cAAc,CAAC;AAC9C,MAAM,OAAO,KAAK;AAYX,MAAM,QAAQ,CAAA,MAAO,OAAO,4JAAS,CAAC;AAStC,MAAM,SAAS,CAAA;IACpB,MAAM,CAAC,UAAU,GAAG,iMAAM,CAAC,MAAM,CAAC;IAClC,IAAI,cAAc,MAAM;QACtB,MAAM,IAAI,WACR,CAAC,2CAA2C,EAAE,KAAK,QAAQ,CAAC,KAAK;IAErE,OAAO,IAAI,MAAM,UAAU,KAAK,MAAM;QACpC,MAAM,IAAI,WACR,CAAC,oCAAoC,EAAE,KAAK,yCAAyC,EAAE,MAAM,UAAU,EAAE;IAE7G,OAAO;QACL,OAAO,IAAI,gBAAgB,MAAM,MAAM,EAAE,MAAM,UAAU,EAAE,MAAM,UAAU;IAC7E;AACF;AAOO,MAAM,SAAS,CAAA,YAAa,6JAAU,CAAC;AAQvC,MAAM,SAAS,CAAA,YAAa,6JAAU,CAAC;AAE9C;;CAEC,GACD,MAAM,wBAAwB;IAC5B,wBAAwB,GACxB,IAAI,OAAO;QACT,OAAO;IACT;IACA,iCAAiC,GACjC,IAAI,gBAAgB;QAClB,OAAO;IACT;IACA,sCAAsC,GACtC,IAAI,qBAAqB;QACvB,OAAO;IACT;IACA;;;;GAIC,GACD,IAAI,YAAY;QACd,MAAM,MAAM,IAAI,WAAW,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,UAAU,GAAG;QAC1D,OAAO,gBAAgB,CAAC,IAAI,EAAE;YAC5B,WAAW;gBACT,OAAO;YACT;QACF;QACA,OAAO;IACT;IACA;;;GAGC,GACD,MAAM;QACJ,OAAO,CAAC,QAAQ,EAAE,2KAAS,CAAC,MAAM,CAAC,IAAI,GAAG;IAC5C;IACA;;;;;GAKC,GACD,OAAO,OAAO,EAAE,SAAS,EAAE;QACzB,OACE,UAAU,IAAI,KAAK,iBACnB,mKAAc,CAAC,UAAU,GAAG,EAAE,SAAS,IAAI,CAAC,SAAS;IAEzD;IAEA;;;;GAIC,GACD,QAAQ,EAAE,EAAE;QACV,OAAO,mKAAgB,CAAC,IAAI,EAAE;IAChC;IAEA,WAAW;QACT,OAAO,IAAI,CAAC,GAAG;IACjB;AACF;AAKO,MAAM,KAAK,CAAA,QAAS,8JAAW,CAAC;QAAE;IAAM,GAAG","ignoreList":[0]}},
    {"offset": {"line": 2695, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/principal/src/signer.js"],"sourcesContent":["import * as API from '@ucanto/interface'\n\n/**\n * @template {API.SignerImporter} L\n * @template {API.SignerImporter} R\n * @param {L} left\n * @param {R} right\n * @returns {API.CompositeImporter<[L, R]>}\n */\nexport const or = (left, right) => new Importer([left, right])\n\n/**\n * @template {[API.SignerImporter, ...API.SignerImporter[]]} Importers\n * @implements {API.CompositeImporter<Importers>}\n */\nclass Importer {\n  /**\n   * @param {Importers} variants\n   */\n  constructor(variants) {\n    this.variants = variants\n    this.from = create(variants)\n  }\n\n  /**\n   * @template {API.SignerImporter} Other\n   * @param {Other} other\n   * @returns {API.CompositeImporter<[Other, ...Importers]>}\n   */\n  or(other) {\n    return new Importer([other, ...this.variants])\n  }\n}\n\n/**\n * @template {[API.SignerImporter, ...API.SignerImporter[]]} Importers\n * @param {Importers} importers\n */\nconst create = importers => {\n  /**\n   * @template {API.DID} ID - DID that can be imported, which may be a type union.\n   * @template {API.SigAlg} Alg - Multicodec code corresponding to signature algorithm.\n   * @param {API.SignerArchive<ID, Alg>} archive\n   * @returns {API.Signer<ID, Alg>}\n   */\n  const from = archive => {\n    if (archive.id.startsWith('did:key:')) {\n      return /** @type {API.Signer<ID, Alg>} */ (importWith(archive, importers))\n    } else {\n      for (const [name, key] of Object.entries(archive.keys)) {\n        const id = /** @type {API.DIDKey} */ (name)\n        const signer = /** @type {API.Signer<API.DIDKey, Alg>} */ (\n          importWith(\n            {\n              id,\n              keys: { [id]: key },\n            },\n            importers\n          )\n        )\n\n        return signer.withDID(archive.id)\n      }\n\n      throw new Error(`Archive ${archive.id} contains no keys`)\n    }\n  }\n\n  return /** @type {API.Intersection<Importers[number]['from']>} */ (from)\n}\n\n/**\n * @param {API.SignerArchive} archive\n * @param {API.SignerImporter[]} importers\n * @returns {API.Signer}\n */\nconst importWith = (archive, importers) => {\n  for (const importer of importers) {\n    try {\n      return importer.from(archive)\n    } catch (_) {}\n  }\n  throw new Error(`Unsupported signer`)\n}\n/**\n * @template {number} Code\n * @template {API.DID} ID\n * @param {API.Signer<API.DID<'key'>, Code>} signer\n * @param {ID} id\n * @returns {API.Signer<ID, Code>}\n */\nexport const withDID = ({ signer, verifier }, id) =>\n  new SignerWithDID(signer, verifier.withDID(id))\n\n/**\n * @template {API.DID} ID\n * @template {number} Code\n * @implements {API.Signer<ID, Code>}\n */\nclass SignerWithDID {\n  /**\n   * @param {API.Signer<API.DID<'key'>, Code>} key\n   * @param {API.Verifier<ID, Code>} verifier\n   */\n  constructor(key, verifier) {\n    this.key = key\n    this.verifier = verifier\n  }\n  /** @type {API.Signer<ID, Code>} */\n  get signer() {\n    return this\n  }\n\n  get signatureAlgorithm() {\n    return this.key.signatureAlgorithm\n  }\n  get signatureCode() {\n    return this.key.signatureCode\n  }\n\n  /**\n   * @returns {ID}\n   */\n  did() {\n    return this.verifier.did()\n  }\n\n  toDIDKey() {\n    return this.verifier.toDIDKey()\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   */\n  withDID(id) {\n    return withDID(this.key, id)\n  }\n\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   */\n  sign(payload) {\n    return this.key.sign(payload)\n  }\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @param {API.Signature<T, Code>} signature\n   */\n  verify(payload, signature) {\n    return this.verifier.verify(payload, signature)\n  }\n\n  toArchive() {\n    const { keys } = this.key.toArchive()\n    return {\n      id: this.did(),\n      keys,\n    }\n  }\n}\n"],"names":[],"mappings":";;;;;;AAAA;;AASO,MAAM,KAAK,CAAC,MAAM,QAAU,IAAI,SAAS;QAAC;QAAM;KAAM;AAE7D;;;CAGC,GACD,MAAM;IACJ;;GAEC,GACD,YAAY,QAAQ,CAAE;QACpB,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,IAAI,GAAG,OAAO;IACrB;IAEA;;;;GAIC,GACD,GAAG,KAAK,EAAE;QACR,OAAO,IAAI,SAAS;YAAC;eAAU,IAAI,CAAC,QAAQ;SAAC;IAC/C;AACF;AAEA;;;CAGC,GACD,MAAM,SAAS,CAAA;IACb;;;;;GAKC,GACD,MAAM,OAAO,CAAA;QACX,IAAI,QAAQ,EAAE,CAAC,UAAU,CAAC,aAAa;YACrC,OAA2C,WAAW,SAAS;QACjE,OAAO;YACL,KAAK,MAAM,CAAC,MAAM,IAAI,IAAI,OAAO,OAAO,CAAC,QAAQ,IAAI,EAAG;gBACtD,MAAM,KAAgC;gBACtC,MAAM,SACJ,WACE;oBACE;oBACA,MAAM;wBAAE,CAAC,GAAG,EAAE;oBAAI;gBACpB,GACA;gBAIJ,OAAO,OAAO,OAAO,CAAC,QAAQ,EAAE;YAClC;YAEA,MAAM,IAAI,MAAM,CAAC,QAAQ,EAAE,QAAQ,EAAE,CAAC,iBAAiB,CAAC;QAC1D;IACF;IAEA,OAAmE;AACrE;AAEA;;;;CAIC,GACD,MAAM,aAAa,CAAC,SAAS;IAC3B,KAAK,MAAM,YAAY,UAAW;QAChC,IAAI;YACF,OAAO,SAAS,IAAI,CAAC;QACvB,EAAE,OAAO,GAAG,CAAC;IACf;IACA,MAAM,IAAI,MAAM,CAAC,kBAAkB,CAAC;AACtC;AAQO,MAAM,UAAU,CAAC,EAAE,MAAM,EAAE,QAAQ,EAAE,EAAE,KAC5C,IAAI,cAAc,QAAQ,SAAS,OAAO,CAAC;AAE7C;;;;CAIC,GACD,MAAM;IACJ;;;GAGC,GACD,YAAY,GAAG,EAAE,QAAQ,CAAE;QACzB,IAAI,CAAC,GAAG,GAAG;QACX,IAAI,CAAC,QAAQ,GAAG;IAClB;IACA,iCAAiC,GACjC,IAAI,SAAS;QACX,OAAO,IAAI;IACb;IAEA,IAAI,qBAAqB;QACvB,OAAO,IAAI,CAAC,GAAG,CAAC,kBAAkB;IACpC;IACA,IAAI,gBAAgB;QAClB,OAAO,IAAI,CAAC,GAAG,CAAC,aAAa;IAC/B;IAEA;;GAEC,GACD,MAAM;QACJ,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG;IAC1B;IAEA,WAAW;QACT,OAAO,IAAI,CAAC,QAAQ,CAAC,QAAQ;IAC/B;IAEA;;;GAGC,GACD,QAAQ,EAAE,EAAE;QACV,OAAO,QAAQ,IAAI,CAAC,GAAG,EAAE;IAC3B;IAEA;;;GAGC,GACD,KAAK,OAAO,EAAE;QACZ,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC;IACvB;IACA;;;;GAIC,GACD,OAAO,OAAO,EAAE,SAAS,EAAE;QACzB,OAAO,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,SAAS;IACvC;IAEA,YAAY;QACV,MAAM,EAAE,IAAI,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS;QACnC,OAAO;YACL,IAAI,IAAI,CAAC,GAAG;YACZ;QACF;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 2829, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/principal/src/ed25519/signer.js"],"sourcesContent":["import * as ED25519 from '@noble/ed25519'\nimport { varint } from 'multiformats'\nimport * as API from './type.js'\nimport * as Verifier from './verifier.js'\nimport { base64pad } from 'multiformats/bases/base64'\nimport * as Signature from '@ipld/dag-ucan/signature'\nimport * as Signer from '../signer.js'\nexport * from './type.js'\n\nexport const code = 0x1300\nexport const name = Verifier.name\n\n/** @type {'EdDSA'} */\nexport const signatureAlgorithm = Verifier.signatureAlgorithm\nexport const signatureCode = Verifier.signatureCode\n\nconst PRIVATE_TAG_SIZE = varint.encodingLength(code)\nconst PUBLIC_TAG_SIZE = varint.encodingLength(Verifier.code)\nconst KEY_SIZE = 32\nconst SIZE = PRIVATE_TAG_SIZE + KEY_SIZE + PUBLIC_TAG_SIZE + KEY_SIZE\n\nexport const PUB_KEY_OFFSET = PRIVATE_TAG_SIZE + KEY_SIZE\n\n/**\n * Generates new issuer by generating underlying ED25519 keypair.\n * @returns {Promise<API.EdSigner>}\n */\nexport const generate = () => derive(ED25519.utils.randomPrivateKey())\n\n/**\n * Derives issuer from 32 byte long secret key.\n * @param {Uint8Array} secret\n * @returns {Promise<API.EdSigner>}\n */\nexport const derive = async secret => {\n  if (secret.byteLength !== KEY_SIZE) {\n    throw new Error(\n      `Expected Uint8Array with byteLength of ${KEY_SIZE} instead not ${secret.byteLength}`\n    )\n  }\n\n  const publicKey = await ED25519.getPublicKey(secret)\n  const signer = new Ed25519Signer(SIZE)\n\n  varint.encodeTo(code, signer, 0)\n  signer.set(secret, PRIVATE_TAG_SIZE)\n\n  varint.encodeTo(Verifier.code, signer, PRIVATE_TAG_SIZE + KEY_SIZE)\n  signer.set(publicKey, PRIVATE_TAG_SIZE + KEY_SIZE + PUBLIC_TAG_SIZE)\n\n  return signer\n}\n\n/**\n * @param {API.SignerArchive<API.DID, typeof signatureCode>} archive\n * @returns {API.EdSigner}\n */\nexport const from = ({ id, keys }) => {\n  if (id.startsWith('did:key:')) {\n    const key = keys[/** @type {API.DIDKey} */ (id)]\n    if (key instanceof Uint8Array) {\n      return decode(key)\n    }\n  }\n  throw new TypeError(`Unsupported archive format`)\n}\n\n/**\n * @template {API.SignerImporter} O\n * @param {O} other\n */\nexport const or = other => Signer.or({ from }, other)\n\n/**\n * @param {Uint8Array} bytes\n * @returns {API.EdSigner}\n */\nexport const decode = bytes => {\n  if (bytes.byteLength !== SIZE) {\n    throw new Error(\n      `Expected Uint8Array with byteLength of ${SIZE} instead not ${bytes.byteLength}`\n    )\n  }\n\n  {\n    const [keyCode] = varint.decode(bytes)\n    if (keyCode !== code) {\n      throw new Error(`Given bytes must be a multiformat with ${code} tag`)\n    }\n  }\n\n  {\n    const [code] = varint.decode(bytes.subarray(PUB_KEY_OFFSET))\n    if (code !== Verifier.code) {\n      throw new Error(\n        `Given bytes must contain public key in multiformats with ${Verifier.code} tag`\n      )\n    }\n  }\n\n  return new Ed25519Signer(bytes)\n}\n\n/**\n * @param {API.EdSigner} signer\n * @return {API.ByteView<API.EdSigner & CryptoKeyPair>}\n */\nexport const encode = signer => signer.encode()\n\n/**\n * @template {string} Prefix\n * @param {API.EdSigner} signer\n * @param {API.MultibaseEncoder<Prefix>} [encoder]\n */\nexport const format = (signer, encoder) =>\n  (encoder || base64pad).encode(encode(signer))\n\n/**\n * @template {string} Prefix\n * @param {string} principal\n * @param {API.MultibaseDecoder<Prefix>} [decoder]\n * @returns {API.EdSigner}\n */\nexport const parse = (principal, decoder) =>\n  decode((decoder || base64pad).decode(principal))\n\n/**\n * @implements {API.EdSigner}\n */\nclass Ed25519Signer extends Uint8Array {\n  /** @type {typeof code} */\n  get code() {\n    return code\n  }\n  get signer() {\n    return this\n  }\n  /** @type {API.EdVerifier} */\n  get verifier() {\n    const bytes = new Uint8Array(this.buffer, PRIVATE_TAG_SIZE + KEY_SIZE)\n    const verifier = Verifier.decode(bytes)\n\n    Object.defineProperties(this, {\n      verifier: {\n        value: verifier,\n      },\n    })\n\n    return verifier\n  }\n\n  /**\n   * Raw public key without multiformat code.\n   */\n  get secret() {\n    const secret = new Uint8Array(this.buffer, PRIVATE_TAG_SIZE, KEY_SIZE)\n    Object.defineProperties(this, {\n      secret: {\n        value: secret,\n      },\n    })\n\n    return secret\n  }\n\n  /**\n   * DID of this principal in `did:key` format.\n   */\n  did() {\n    return this.verifier.did()\n  }\n\n  toDIDKey() {\n    return this.verifier.toDIDKey()\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   * @returns {API.Signer<ID, typeof Signature.EdDSA>}\n   */\n  withDID(id) {\n    return Signer.withDID(this, id)\n  }\n\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @returns {Promise<API.SignatureView<T, typeof Signature.EdDSA>>}\n   */\n  async sign(payload) {\n    const raw = await ED25519.sign(payload, this.secret)\n\n    return Signature.create(this.signatureCode, raw)\n  }\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @param {API.Signature<T, typeof this.signatureCode>} signature\n   */\n\n  verify(payload, signature) {\n    return this.verifier.verify(payload, signature)\n  }\n\n  get signatureAlgorithm() {\n    return signatureAlgorithm\n  }\n  get signatureCode() {\n    return Signature.EdDSA\n  }\n\n  encode() {\n    return this\n  }\n\n  toArchive() {\n    const id = this.did()\n    return {\n      id,\n      keys: { [id]: this.encode() },\n    }\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3011, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/principal/src/ed25519.js"],"sourcesContent":["export * from './ed25519/signer.js'\nexport * as Verifier from './ed25519/verifier.js'\nexport * as Signer from './ed25519/signer.js'\n"],"names":[],"mappings":";AAAA;AACA","ignoreList":[0]}},
    {"offset": {"line": 3103, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 3108, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/principal/src/multiformat.js"],"sourcesContent":["import { varint } from 'multiformats'\n\n/**\n *\n * @param {number} code\n * @param {Uint8Array} bytes\n */\nexport const tagWith = (code, bytes) => {\n  const offset = varint.encodingLength(code)\n  const multiformat = new Uint8Array(bytes.byteLength + offset)\n  varint.encodeTo(code, multiformat, 0)\n  multiformat.set(bytes, offset)\n\n  return multiformat\n}\n\n/**\n * @param {number} code\n * @param {Uint8Array} source\n * @param {number} byteOffset\n * @returns\n */\nexport const untagWith = (code, source, byteOffset = 0) => {\n  const bytes = byteOffset !== 0 ? source.subarray(byteOffset) : source\n  const [tag, size] = varint.decode(bytes)\n  if (tag !== code) {\n    throw new Error(\n      `Expected multiformat with 0x${code.toString(\n        16\n      )} tag instead got 0x${tag.toString(16)}`\n    )\n  } else {\n    return new Uint8Array(bytes.buffer, bytes.byteOffset + size)\n  }\n}\n\nexport const encodingLength = varint.encodingLength\nexport const encodeTo = varint.encodeTo\nexport const decode = varint.decode\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;AAAA;;AAOO,MAAM,UAAU,CAAC,MAAM;IAC5B,MAAM,SAAS,iMAAM,CAAC,cAAc,CAAC;IACrC,MAAM,cAAc,IAAI,WAAW,MAAM,UAAU,GAAG;IACtD,iMAAM,CAAC,QAAQ,CAAC,MAAM,aAAa;IACnC,YAAY,GAAG,CAAC,OAAO;IAEvB,OAAO;AACT;AAQO,MAAM,YAAY,CAAC,MAAM,QAAQ,aAAa,CAAC;IACpD,MAAM,QAAQ,eAAe,IAAI,OAAO,QAAQ,CAAC,cAAc;IAC/D,MAAM,CAAC,KAAK,KAAK,GAAG,iMAAM,CAAC,MAAM,CAAC;IAClC,IAAI,QAAQ,MAAM;QAChB,MAAM,IAAI,MACR,CAAC,4BAA4B,EAAE,KAAK,QAAQ,CAC1C,IACA,mBAAmB,EAAE,IAAI,QAAQ,CAAC,KAAK;IAE7C,OAAO;QACL,OAAO,IAAI,WAAW,MAAM,MAAM,EAAE,MAAM,UAAU,GAAG;IACzD;AACF;AAEO,MAAM,iBAAiB,iMAAM,CAAC,cAAc;AAC5C,MAAM,WAAW,iMAAM,CAAC,QAAQ;AAChC,MAAM,SAAS,iMAAM,CAAC,MAAM","ignoreList":[0]}},
    {"offset": {"line": 3146, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/principal/src/rsa/asn1.js"],"sourcesContent":["/**\n * ASN1 Tags as per https://luca.ntop.org/Teaching/Appunti/asn1.html\n */\nconst TAG_SIZE = 1\nexport const INT_TAG = 0x02\nexport const BITSTRING_TAG = 0x03\nexport const OCTET_STRING_TAG = 0x04\nexport const NULL_TAG = 0x05\nexport const OBJECT_TAG = 0x06\nexport const SEQUENCE_TAG = 0x30\n\nexport const UNUSED_BIT_PAD = 0x00\n\n/**\n * @param {number} length\n * @returns {Uint8Array}\n */\nexport const encodeDERLength = length => {\n  if (length <= 127) {\n    return new Uint8Array([length])\n  }\n\n  /** @type {number[]} */\n  const octets = []\n  while (length !== 0) {\n    octets.push(length & 0xff)\n    length = length >>> 8\n  }\n  octets.reverse()\n  return new Uint8Array([0x80 | (octets.length & 0xff), ...octets])\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {{number: number, consumed: number}}\n */\nexport const readDERLength = (bytes, offset = 0) => {\n  if ((bytes[offset] & 0x80) === 0) {\n    return { number: bytes[offset], consumed: 1 }\n  }\n\n  const numberBytes = bytes[offset] & 0x7f\n  /* c8 ignore next 5 */\n  if (bytes.length < numberBytes + 1) {\n    throw new Error(\n      `ASN parsing error: Too few bytes. Expected encoded length's length to be at least ${numberBytes}`\n    )\n  }\n\n  let length = 0\n  for (let i = 0; i < numberBytes; i++) {\n    length = length << 8\n    length = length | bytes[offset + i + 1]\n  }\n\n  return { number: length, consumed: numberBytes + 1 }\n}\n\n/**\n * @param {Uint8Array} input\n * @param {number} expectedTag\n * @param {number} position\n * @returns {number}\n */\nexport const skip = (input, expectedTag, position) => {\n  const parsed = into(input, expectedTag, position)\n  return parsed.position + parsed.length\n}\n\n/**\n * @param {Uint8Array} input\n * @param {number} expectedTag\n * @param {number} offset\n * @returns {{ position: number, length: number }}\n */\nexport const into = (input, expectedTag, offset) => {\n  const actualTag = input[offset]\n  /* c8 ignore next 7 */\n  if (actualTag !== expectedTag) {\n    throw new Error(\n      `ASN parsing error: Expected tag 0x${expectedTag.toString(\n        16\n      )} at position ${offset}, but got 0x${actualTag.toString(16)}.`\n    )\n  }\n\n  // length\n  const length = readDERLength(input, offset + TAG_SIZE)\n  const position = offset + TAG_SIZE + length.consumed\n\n  // content\n  return { position, length: length.number }\n}\n\n/**\n * @param {Uint8Array} input\n */\nexport const encodeBitString = input => {\n  // encode input length + 1 for unused bit pad\n  const length = encodeDERLength(input.byteLength + 1)\n  // allocate a buffer of desired size\n  const bytes = new Uint8Array(\n    TAG_SIZE + // ASN_BITSTRING_TAG\n      length.byteLength +\n      1 + // amount of unused bits at the end of our bitstring\n      input.byteLength\n  )\n\n  let byteOffset = 0\n  // write bytestring tag\n  bytes[byteOffset] = BITSTRING_TAG\n  byteOffset += TAG_SIZE\n\n  // write length of the bytestring\n  bytes.set(length, byteOffset)\n  byteOffset += length.byteLength\n\n  // write unused bits at the end of our bitstring\n  bytes[byteOffset] = UNUSED_BIT_PAD\n  byteOffset += 1\n\n  // write actual data into bitstring\n  bytes.set(input, byteOffset)\n\n  return bytes\n}\n\n/**\n * @param {Uint8Array} input\n */\nexport const encodeOctetString = input => {\n  // encode input length\n  const length = encodeDERLength(input.byteLength)\n  // allocate a buffer of desired size\n  const bytes = new Uint8Array(TAG_SIZE + length.byteLength + input.byteLength)\n\n  let byteOffset = 0\n  // write octet string tag\n  bytes[byteOffset] = OCTET_STRING_TAG\n  byteOffset += TAG_SIZE\n\n  // write octet string length\n  bytes.set(length, byteOffset)\n  byteOffset += length.byteLength\n\n  // write actual data into bitstring\n  bytes.set(input, byteOffset)\n\n  return bytes\n}\n\n/**\n * @param {Uint8Array[]} sequence\n */\nexport const encodeSequence = sequence => {\n  // calculate bytelength for all the parts\n  let byteLength = 0\n  for (const item of sequence) {\n    byteLength += item.byteLength\n  }\n\n  // encode sequence byte length\n  const length = encodeDERLength(byteLength)\n\n  // allocate the buffer to write sequence into\n  const bytes = new Uint8Array(TAG_SIZE + length.byteLength + byteLength)\n\n  let byteOffset = 0\n\n  // write the sequence tag\n  bytes[byteOffset] = SEQUENCE_TAG\n  byteOffset += TAG_SIZE\n\n  // write sequence length\n  bytes.set(length, byteOffset)\n  byteOffset += length.byteLength\n\n  // write each item in the sequence\n  for (const item of sequence) {\n    bytes.set(item, byteOffset)\n    byteOffset += item.byteLength\n  }\n\n  return bytes\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n */\nexport const readSequence = (bytes, offset = 0) => {\n  const { position, length } = into(bytes, SEQUENCE_TAG, offset)\n\n  return new Uint8Array(bytes.buffer, bytes.byteOffset + position, length)\n}\n\n/**\n * @param {Uint8Array} input\n */\nexport const encodeInt = input => {\n  const extra = input.byteLength === 0 || input[0] & 0x80 ? 1 : 0\n\n  // encode input length\n  const length = encodeDERLength(input.byteLength + extra)\n  // allocate a buffer of desired size\n  const bytes = new Uint8Array(\n    TAG_SIZE + // INT_TAG\n      length.byteLength +\n      input.byteLength +\n      extra\n  )\n\n  let byteOffset = 0\n  // write octet string tag\n  bytes[byteOffset] = INT_TAG\n  byteOffset += TAG_SIZE\n\n  // write int length\n  bytes.set(length, byteOffset)\n  byteOffset += length.byteLength\n\n  // add 0 if the most-significant bit is set\n  if (extra > 0) {\n    bytes[byteOffset] = UNUSED_BIT_PAD\n    byteOffset += extra\n  }\n\n  // write actual data into bitstring\n  bytes.set(input, byteOffset)\n\n  return bytes\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {number}\n */\n\nexport const enterSequence = (bytes, offset = 0) =>\n  into(bytes, SEQUENCE_TAG, offset).position\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {number}\n */\nexport const skipSequence = (bytes, offset = 0) =>\n  skip(bytes, SEQUENCE_TAG, offset)\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {number}\n */\nexport const skipInt = (bytes, offset = 0) => skip(bytes, INT_TAG, offset)\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {Uint8Array}\n */\nexport const readBitString = (bytes, offset = 0) => {\n  const { position, length } = into(bytes, BITSTRING_TAG, offset)\n  const tag = bytes[position]\n  /* c8 ignore next 5 */\n  if (tag !== UNUSED_BIT_PAD) {\n    throw new Error(\n      `Can not read bitstring, expected length to be multiple of 8, but got ${tag} unused bits in last byte.`\n    )\n  }\n\n  return new Uint8Array(\n    bytes.buffer,\n    bytes.byteOffset + position + 1,\n    length - 1\n  )\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} byteOffset\n * @returns {Uint8Array}\n */\nexport const readInt = (bytes, byteOffset = 0) => {\n  const { position, length } = into(bytes, INT_TAG, byteOffset)\n  let delta = 0\n\n  // drop leading 0s\n  while (bytes[position + delta] === 0) {\n    delta++\n  }\n\n  return new Uint8Array(\n    bytes.buffer,\n    bytes.byteOffset + position + delta,\n    length - delta\n  )\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {Uint8Array}\n */\nexport const readOctetString = (bytes, offset = 0) => {\n  const { position, length } = into(bytes, OCTET_STRING_TAG, offset)\n\n  return new Uint8Array(bytes.buffer, bytes.byteOffset + position, length)\n}\n\n/**\n * @typedef {(bytes:Uint8Array, offset:number) => Uint8Array} Reader\n * @param {[Reader, ...Reader[]]} readers\n * @param {Uint8Array} source\n * @param {number} byteOffset\n */\nexport const readSequenceWith = (readers, source, byteOffset = 0) => {\n  const results = []\n  const sequence = readSequence(source, byteOffset)\n  let offset = 0\n  for (const read of readers) {\n    const chunk = read(sequence, offset)\n    results.push(chunk)\n    offset = chunk.byteOffset + chunk.byteLength - sequence.byteOffset\n  }\n  return results\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3387, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/principal/src/rsa/spki.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport {\n  encodeSequence,\n  encodeBitString,\n  enterSequence,\n  skipSequence,\n  readBitString,\n} from './asn1.js'\n\n/**\n * @typedef {import('./public-key.js').RSAPublicKey} RSAPublicKey\n */\n/**\n * Described in RFC 5208 Section 4.1: https://tools.ietf.org/html/rfc5280#section-4.1\n * ```\n * SubjectPublicKeyInfo  ::=  SEQUENCE  {\n *    algorithm            AlgorithmIdentifier,\n *    subjectPublicKey     BIT STRING  }\n * ```\n *\n * @typedef {object} SubjectPublicKeyInfo\n * @property {API.ByteView<AlgorithmIdentifier>} algorithm\n * @property {API.ByteView<RSAPublicKey>} subjectPublicKey\n * @typedef {import('./pkcs8.js').AlgorithmIdentifier} AlgorithmIdentifier\n */\n\n/**\n * The ASN.1 DER encoded header that needs to be added to an\n * ASN.1 DER encoded RSAPublicKey to make it a SubjectPublicKeyInfo.\n *\n * This byte sequence is always the same.\n *\n * A human-readable version of this as part of a dumpasn1 dump:\n *\n *     SEQUENCE {\n *       OBJECT IDENTIFIER rsaEncryption (1 2 840 113549 1 1 1)\n *       NULL\n *     }\n *\n * See https://github.com/ucan-wg/ts-ucan/issues/30\n */\nexport const SPKI_PARAMS_ENCODED = new Uint8Array([\n  48, 13, 6, 9, 42, 134, 72, 134, 247, 13, 1, 1, 1, 5, 0,\n])\n\n/**\n * @param {API.ByteView<RSAPublicKey>} key\n * @returns {API.ByteView<SubjectPublicKeyInfo>}\n */\nexport const encode = key =>\n  encodeSequence([SPKI_PARAMS_ENCODED, encodeBitString(key)])\n\n/**\n *\n * @param {API.ByteView<SubjectPublicKeyInfo>} info\n * @returns {API.ByteView<RSAPublicKey>}\n */\nexport const decode = info => {\n  // go into the top-level SEQUENCE\n  const offset = enterSequence(info, 0)\n  // skip the header we expect (SKPI_PARAMS_ENCODED)\n  const keyOffset = skipSequence(info, offset)\n\n  // we expect the bitstring next\n  return readBitString(info, keyOffset)\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;;;AAwCO,MAAM,sBAAsB,IAAI,WAAW;IAChD;IAAI;IAAI;IAAG;IAAG;IAAI;IAAK;IAAI;IAAK;IAAK;IAAI;IAAG;IAAG;IAAG;IAAG;CACtD;AAMM,MAAM,SAAS,CAAA,MACpB,IAAA,6KAAc,EAAC;QAAC;QAAqB,IAAA,8KAAe,EAAC;KAAK;AAOrD,MAAM,SAAS,CAAA;IACpB,iCAAiC;IACjC,MAAM,SAAS,IAAA,4KAAa,EAAC,MAAM;IACnC,kDAAkD;IAClD,MAAM,YAAY,IAAA,2KAAY,EAAC,MAAM;IAErC,+BAA+B;IAC/B,OAAO,IAAA,4KAAa,EAAC,MAAM;AAC7B","ignoreList":[0]}},
    {"offset": {"line": 3432, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/principal/src/rsa/pkcs8.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport { base64url } from 'multiformats/bases/base64'\nimport {\n  encodeSequence,\n  encodeOctetString,\n  enterSequence,\n  skipSequence,\n  skipInt,\n  readOctetString,\n} from './asn1.js'\n\nconst PKSC8_HEADER = new Uint8Array([\n  // version\n  2, 1, 0,\n  // privateKeyAlgorithm\n  48, 13, 6, 9, 42, 134, 72, 134, 247, 13, 1, 1, 1, 5, 0,\n])\n/**\n * @typedef {import('./private-key').RSAPrivateKey} RSAPrivateKey\n * @typedef {object} AlgorithmIdentifier\n * @property {Uint8Array} version\n * @property {Uint8Array} parameters\n *\n * @see https://datatracker.ietf.org/doc/html/rfc5208#section-5\n * @typedef {object} PrivateKeyInfo\n * @property {API.ByteView<number>} version\n * @property {API.ByteView<AlgorithmIdentifier>} privateKeyAlgorithm\n * @property {API.ByteView<RSAPrivateKey>} privateKey\n * @property {API.ByteView<unknown>} [attributes]\n */\n\n/**\n * @param {API.ByteView<PrivateKeyInfo>} info\n * @returns {API.ByteView<RSAPrivateKey>}\n */\nexport const decode = info => {\n  let offset = 0\n  // go into the top-level SEQUENCE\n  offset = enterSequence(info, offset)\n  offset = skipInt(info, offset)\n  offset = skipSequence(info, offset)\n\n  // we expect the bitstring next\n  return readOctetString(info, offset)\n}\n\n/**\n * @param {API.ByteView<RSAPrivateKey>} key\n * @returns {API.ByteView<PrivateKeyInfo>}\n */\nexport const encode = key =>\n  encodeSequence([PKSC8_HEADER, encodeOctetString(key)])\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;;;;AASA,MAAM,eAAe,IAAI,WAAW;IAClC,UAAU;IACV;IAAG;IAAG;IACN,sBAAsB;IACtB;IAAI;IAAI;IAAG;IAAG;IAAI;IAAK;IAAI;IAAK;IAAK;IAAI;IAAG;IAAG;IAAG;IAAG;CACtD;AAmBM,MAAM,SAAS,CAAA;IACpB,IAAI,SAAS;IACb,iCAAiC;IACjC,SAAS,IAAA,4KAAa,EAAC,MAAM;IAC7B,SAAS,IAAA,sKAAO,EAAC,MAAM;IACvB,SAAS,IAAA,2KAAY,EAAC,MAAM;IAE5B,+BAA+B;IAC/B,OAAO,IAAA,8KAAe,EAAC,MAAM;AAC/B;AAMO,MAAM,SAAS,CAAA,MACpB,IAAA,6KAAc,EAAC;QAAC;QAAc,IAAA,gLAAiB,EAAC;KAAK","ignoreList":[0]}},
    {"offset": {"line": 3483, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/principal/src/rsa/public-key.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport { encodeSequence, readInt, encodeInt, readSequenceWith } from './asn1.js'\nimport * as SPKI from './spki.js'\nimport { base64url } from 'multiformats/bases/base64'\n/**\n * RSA public key represenatation\n * @see https://datatracker.ietf.org/doc/html/rfc3447#appendix-A.1\n *\n * @typedef {object} RSAPublicKey\n * @property {API.ByteView<number>} n\n * @property {API.ByteView<number>} e\n */\n\n/**\n * Takes private-key information in [Private-Key Information Syntax](https://datatracker.ietf.org/doc/html/rfc5208#section-5)\n * and extracts all the fields as per [RSA private key syntax](https://datatracker.ietf.org/doc/html/rfc3447#appendix-A.1.2)\n *\n *\n * @param {API.ByteView<RSAPublicKey>} key\n * @param {number} byteOffset\n * @returns {RSAPublicKey}\n */\nexport const decode = (key, byteOffset = 0) => {\n  const [n, e] = readSequenceWith([readInt, readInt], key, byteOffset)\n\n  return { n, e }\n}\n\n/**\n * @param {RSAPublicKey} key\n * @returns {API.ByteView<RSAPublicKey>}\n */\nexport const encode = ({ n, e }) => encodeSequence([encodeInt(n), encodeInt(e)])\n\n/**\n * @param {RSAPublicKey} key\n */\nexport const toSPKI = key => SPKI.encode(encode(key))\n\n/**\n * @param {API.ByteView<SPKI.SubjectPublicKeyInfo>} info\n */\nexport const fromSPKI = info => decode(SPKI.decode(info))\n\n/**\n * @param {RSAPublicKey} key\n * @returns {JsonWebKey}\n */\nexport const toJWK = ({ n, e }) => ({\n  kty: 'RSA',\n  alg: 'RS256',\n  key_ops: ['verify'],\n  ext: true,\n  n: base64url.baseEncode(n),\n  e: base64url.baseEncode(e),\n})\n\n/**\n * @param {JsonWebKey} jwk\n * @returns {RSAPublicKey}\n */\nexport const fromJWK = ({ n, e }) => ({\n  n: base64urlDecode(n),\n  e: base64urlDecode(e),\n})\n\n/**\n * @param {string|undefined} input\n */\nconst base64urlDecode = (input = '') => base64url.baseDecode(input)\n"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;;;;;AAmBO,MAAM,SAAS,CAAC,KAAK,aAAa,CAAC;IACxC,MAAM,CAAC,GAAG,EAAE,GAAG,IAAA,+KAAgB,EAAC;QAAC,sKAAO;QAAE,sKAAO;KAAC,EAAE,KAAK;IAEzD,OAAO;QAAE;QAAG;IAAE;AAChB;AAMO,MAAM,SAAS,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAK,IAAA,6KAAc,EAAC;QAAC,IAAA,wKAAS,EAAC;QAAI,IAAA,wKAAS,EAAC;KAAG;AAKxE,MAAM,SAAS,CAAA,MAAO,qKAAW,CAAC,OAAO;AAKzC,MAAM,WAAW,CAAA,OAAQ,OAAO,qKAAW,CAAC;AAM5C,MAAM,QAAQ,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAK,CAAC;QAClC,KAAK;QACL,KAAK;QACL,SAAS;YAAC;SAAS;QACnB,KAAK;QACL,GAAG,2KAAS,CAAC,UAAU,CAAC;QACxB,GAAG,2KAAS,CAAC,UAAU,CAAC;IAC1B,CAAC;AAMM,MAAM,UAAU,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAK,CAAC;QACpC,GAAG,gBAAgB;QACnB,GAAG,gBAAgB;IACrB,CAAC;AAED;;CAEC,GACD,MAAM,kBAAkB,CAAC,QAAQ,EAAE,GAAK,2KAAS,CAAC,UAAU,CAAC","ignoreList":[0]}},
    {"offset": {"line": 3542, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/principal/src/rsa/private-key.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport { encodeSequence, readInt, readSequenceWith, encodeInt } from './asn1.js'\nimport { base64url } from 'multiformats/bases/base64'\nimport * as PKCS8 from './pkcs8.js'\nimport * as SPKI from './spki.js'\nimport * as PublicKey from './public-key.js'\n\nexport const code = 0x1305\nconst VERSION = new Uint8Array()\n\n/**\n * @see https://datatracker.ietf.org/doc/html/rfc3447#appendix-A.1.2\n * @typedef {object} RSAPrivateKey\n * @property {Uint8Array} v\n * @property {Uint8Array} n\n * @property {Uint8Array} e\n * @property {Uint8Array} d\n * @property {Uint8Array} p\n * @property {Uint8Array} q\n * @property {Uint8Array} dp\n * @property {Uint8Array} dq\n * @property {Uint8Array} qi\n */\n\n/**\n * Takes private-key information in [Private-Key Information Syntax](https://datatracker.ietf.org/doc/html/rfc5208#section-5)\n * and extracts all the fields as per [RSA private key syntax](https://datatracker.ietf.org/doc/html/rfc3447#appendix-A.1.2)\n *\n *\n * @param {API.ByteView<RSAPrivateKey>} source\n * @param {number} byteOffset\n * @returns {RSAPrivateKey}\n */\nexport const decode = (source, byteOffset = 0) => {\n  const [v, n, e, d, p, q, dp, dq, qi] = readSequenceWith(\n    [\n      readInt,\n      readInt,\n      readInt,\n      readInt,\n      readInt,\n      readInt,\n      readInt,\n      readInt,\n      readInt,\n    ],\n    source,\n    byteOffset\n  )\n\n  return { v, n, e, d, p, q, dp, dq, qi }\n}\n\n/**\n * @param {RSAPrivateKey} key\n * @returns {API.ByteView<RSAPrivateKey>}\n */\nexport const encode = ({ v, n, e, d, p, q, dp, dq, qi }) => {\n  return encodeSequence([\n    encodeInt(v),\n    encodeInt(n),\n    encodeInt(e),\n    encodeInt(d),\n    encodeInt(p),\n    encodeInt(q),\n    encodeInt(dp),\n    encodeInt(dq),\n    encodeInt(qi),\n  ])\n}\n\n/**\n * @param {RSAPrivateKey} key\n * @returns {JsonWebKey}\n */\nexport const toJWK = ({ n, e, d, p, q, dp, dq, qi }) => ({\n  kty: 'RSA',\n  alg: 'RS256',\n  key_ops: ['sign'],\n  ext: true,\n  n: base64url.baseEncode(n),\n  e: base64url.baseEncode(e),\n  d: base64url.baseEncode(d),\n  p: base64url.baseEncode(p),\n  q: base64url.baseEncode(q),\n  dp: base64url.baseEncode(dp),\n  dq: base64url.baseEncode(dq),\n  qi: base64url.baseEncode(qi),\n})\n\n/**\n * @param {JsonWebKey} key\n * @returns {RSAPrivateKey}\n */\nexport const fromJWK = ({ n, e, d, p, q, dp, dq, qi }) => ({\n  v: VERSION,\n  n: base64urlDecode(n),\n  e: base64urlDecode(e),\n  d: base64urlDecode(d),\n  p: base64urlDecode(p),\n  q: base64urlDecode(q),\n  dp: base64urlDecode(dp),\n  dq: base64urlDecode(dq),\n  qi: base64urlDecode(qi),\n})\n\n/**\n * @param {RSAPrivateKey} key\n */\nexport const toPKCS8 = key => PKCS8.encode(encode(key))\n\n/**\n * @param {API.ByteView<PKCS8.PrivateKeyInfo>} info\n */\nexport const fromPKCS8 = info => decode(PKCS8.decode(info))\n\n/**\n * @param {RSAPrivateKey} key\n */\nexport const toSPKI = key => SPKI.encode(PublicKey.encode(key))\n\n/**\n *\n * @param {string|undefined} input\n * @returns\n */\nconst base64urlDecode = (input = '') => base64url.baseDecode(input)\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAEO,MAAM,OAAO;AACpB,MAAM,UAAU,IAAI;AAyBb,MAAM,SAAS,CAAC,QAAQ,aAAa,CAAC;IAC3C,MAAM,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI,IAAI,GAAG,GAAG,IAAA,+KAAgB,EACrD;QACE,sKAAO;QACP,sKAAO;QACP,sKAAO;QACP,sKAAO;QACP,sKAAO;QACP,sKAAO;QACP,sKAAO;QACP,sKAAO;QACP,sKAAO;KACR,EACD,QACA;IAGF,OAAO;QAAE;QAAG;QAAG;QAAG;QAAG;QAAG;QAAG;QAAI;QAAI;IAAG;AACxC;AAMO,MAAM,SAAS,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE;IACrD,OAAO,IAAA,6KAAc,EAAC;QACpB,IAAA,wKAAS,EAAC;QACV,IAAA,wKAAS,EAAC;QACV,IAAA,wKAAS,EAAC;QACV,IAAA,wKAAS,EAAC;QACV,IAAA,wKAAS,EAAC;QACV,IAAA,wKAAS,EAAC;QACV,IAAA,wKAAS,EAAC;QACV,IAAA,wKAAS,EAAC;QACV,IAAA,wKAAS,EAAC;KACX;AACH;AAMO,MAAM,QAAQ,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAK,CAAC;QACvD,KAAK;QACL,KAAK;QACL,SAAS;YAAC;SAAO;QACjB,KAAK;QACL,GAAG,2KAAS,CAAC,UAAU,CAAC;QACxB,GAAG,2KAAS,CAAC,UAAU,CAAC;QACxB,GAAG,2KAAS,CAAC,UAAU,CAAC;QACxB,GAAG,2KAAS,CAAC,UAAU,CAAC;QACxB,GAAG,2KAAS,CAAC,UAAU,CAAC;QACxB,IAAI,2KAAS,CAAC,UAAU,CAAC;QACzB,IAAI,2KAAS,CAAC,UAAU,CAAC;QACzB,IAAI,2KAAS,CAAC,UAAU,CAAC;IAC3B,CAAC;AAMM,MAAM,UAAU,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,GAAK,CAAC;QACzD,GAAG;QACH,GAAG,gBAAgB;QACnB,GAAG,gBAAgB;QACnB,GAAG,gBAAgB;QACnB,GAAG,gBAAgB;QACnB,GAAG,gBAAgB;QACnB,IAAI,gBAAgB;QACpB,IAAI,gBAAgB;QACpB,IAAI,gBAAgB;IACtB,CAAC;AAKM,MAAM,UAAU,CAAA,MAAO,sKAAY,CAAC,OAAO;AAK3C,MAAM,YAAY,CAAA,OAAQ,OAAO,sKAAY,CAAC;AAK9C,MAAM,SAAS,CAAA,MAAO,qKAAW,CAAC,8KAAgB,CAAC;AAE1D;;;;CAIC,GACD,MAAM,kBAAkB,CAAC,QAAQ,EAAE,GAAK,2KAAS,CAAC,UAAU,CAAC","ignoreList":[0]}},
    {"offset": {"line": 3650, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/principal/src/rsa.js"],"sourcesContent":["import { webcrypto } from 'one-webcrypto'\nimport { base58btc } from 'multiformats/bases/base58'\nimport * as API from './rsa/type.js'\nimport * as DID from '@ipld/dag-ucan/did'\nimport { tagWith, untagWith } from './multiformat.js'\nimport * as Signature from '@ipld/dag-ucan/signature'\nimport * as SPKI from './rsa/spki.js'\nimport * as PKCS8 from './rsa/pkcs8.js'\nimport * as PrivateKey from './rsa/private-key.js'\nimport * as PublicKey from './rsa/public-key.js'\nimport * as Verifier from './verifier.js'\nimport * as Signer from './signer.js'\nexport * from './rsa/type.js'\n\nexport const name = 'RSA'\n\n/** @type {API.RSASigner['code']} */\nexport const code = 0x1305\n\n/** @type {API.RSAVerifier['code']} */\nconst verifierCode = 0x1205\n\n/** @type {API.SigAlg} */\nexport const signatureCode = Signature.RS256\nexport const signatureAlgorithm = 'RS256'\n\nconst ALG = 'RSASSA-PKCS1-v1_5'\nconst HASH_ALG = 'SHA-256'\nconst KEY_SIZE = 2048\nconst SALT_LENGTH = 128\nconst IMPORT_PARAMS = {\n  name: ALG,\n  hash: { name: HASH_ALG },\n}\n\n/**\n * @param {object} options\n * @param {number} [options.size]\n * @param {boolean} [options.extractable]\n * @returns {Promise<API.RSASigner>}\n */\nexport const generate = async ({\n  size = KEY_SIZE,\n  extractable = false,\n} = {}) => {\n  // We start by generate an RSA keypair using web crypto API.\n  const { publicKey, privateKey } = await webcrypto.subtle.generateKey(\n    {\n      name: ALG,\n      modulusLength: size,\n      publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n      hash: { name: HASH_ALG },\n    },\n\n    extractable,\n    ['sign', 'verify']\n  )\n\n  // Next we need to encode public key, because `RSAVerifier` uses it to\n  // for implementing a `did()` method. To do this we first export\n  // Subject Public Key Info (SPKI) using web crypto API.\n  const spki = await webcrypto.subtle.exportKey('spki', publicKey)\n  // Then we extract public key from the SPKI and tag it with RSA public key\n  // multicode\n  const publicBytes = tagWith(verifierCode, SPKI.decode(new Uint8Array(spki)))\n  // Now that we have publicKey and it's multiformat representation we can\n  // create a verifier.\n  const verifier = new RSAVerifier({ bytes: publicBytes, publicKey })\n\n  // If we generated non extractable key we just wrap actual keys and verifier\n  // in the RSASigner view.\n  if (!extractable) {\n    return new UnextractableRSASigner({\n      privateKey,\n      verifier,\n    })\n  }\n  // Otherwise we export key in Private Key Cryptography Standards (PKCS)\n  // format and extract a bytes corresponding to the private key, which\n  // we tag with RSA private key multiformat code. With both binary and actual\n  // key representation we create a RSASigner view.\n  // Please note that do key export flow during generation so that we can:\n  // 1. Guarantee that it will be exportable.\n  // 2. Make `export` method sync.\n  else {\n    const pkcs8 = await webcrypto.subtle.exportKey('pkcs8', privateKey)\n    const bytes = tagWith(code, PKCS8.decode(new Uint8Array(pkcs8)))\n    return new ExtractableRSASigner({\n      privateKey,\n      bytes,\n      verifier,\n    })\n  }\n}\n\n/**\n * @param {API.SignerArchive<API.DID, typeof signatureCode>} archive\n * @returns {API.RSASigner}\n */\nexport const from = ({ id, keys }) => {\n  if (id.startsWith('did:key:')) {\n    const did = /** @type {API.DIDKey} */ (id)\n    const key = keys[did]\n    if (key instanceof Uint8Array) {\n      return decode(key)\n    } else {\n      return new UnextractableRSASigner({\n        privateKey: key,\n        verifier: RSAVerifier.parse(did),\n      })\n    }\n  } else {\n    throw new TypeError(\n      `RSA can not import from ${id} archive, try generic Signer instead`\n    )\n  }\n}\n\n/**\n * @template {API.SignerImporter} Other\n * @param {Other} other\n */\nexport const or = other => Signer.or({ from }, other)\n\n/**\n * @param {EncodedSigner} bytes\n * @returns {API.RSASigner}\n */\nexport const decode = bytes => {\n  // First we decode RSA key data from the private key with multicode tag.\n  const rsa = PrivateKey.decode(untagWith(code, bytes))\n  // Then we encode RSA key data as public key with multicode tag.\n  const publicBytes = tagWith(verifierCode, PublicKey.encode(rsa))\n\n  return new ExtractableRSASigner({\n    bytes,\n    privateKey: webcrypto.subtle.importKey(\n      'pkcs8',\n      PKCS8.encode(untagWith(code, bytes)),\n      IMPORT_PARAMS,\n      true,\n      ['sign']\n    ),\n\n    verifier: RSAVerifier.decode(publicBytes),\n  })\n}\n\n/**\n * @implements {API.RSAVerifier}\n */\nclass RSAVerifier {\n  /**\n   * @param {object} options\n   * @param {API.Await<CryptoKey>} options.publicKey\n   * @param {API.ByteView<API.RSAVerifier>} options.bytes\n   */\n  constructor({ publicKey, bytes }) {\n    /** @private */\n    this.publicKey = publicKey\n    /** @private */\n    this.bytes = bytes\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   * @returns {API.Verifier<ID, typeof signatureCode>}\n   */\n  withDID(id) {\n    return Verifier.withDID(this, id)\n  }\n\n  toDIDKey() {\n    return this.did()\n  }\n\n  /**\n   * @param {API.ByteView<API.RSAVerifier>} bytes\n   * @returns {API.RSAVerifier}\n   */\n  static decode(bytes) {\n    return new this({\n      bytes,\n      publicKey: webcrypto.subtle.importKey(\n        'spki',\n        SPKI.encode(untagWith(verifierCode, bytes)),\n        IMPORT_PARAMS,\n        true,\n        ['verify']\n      ),\n    })\n  }\n  /**\n   * @param {API.DIDKey} did\n   * @returns {API.RSAVerifier}\n   */\n  static parse(did) {\n    return RSAVerifier.decode(/** @type {Uint8Array} */ (DID.parse(did)))\n  }\n\n  /**\n   * @param {API.PrincipalParser} other\n   */\n  static or(other) {\n    return Verifier.or(this, other)\n  }\n\n  /** @type {typeof verifierCode} */\n  get code() {\n    return verifierCode\n  }\n  /**\n   * @type {typeof signatureCode}\n   */\n  get signatureCode() {\n    return signatureCode\n  }\n  /**\n   * @type {typeof signatureAlgorithm}\n   */\n  get signatureAlgorithm() {\n    return signatureAlgorithm\n  }\n  /**\n   * DID of the Principal in `did:key` format.\n   * @returns {API.DID<\"key\">}\n   */\n  did() {\n    return `did:key:${base58btc.encode(this.bytes)}`\n  }\n\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @param {API.Signature<T, typeof this.signatureCode>} signature\n   * @returns {Promise<boolean>}\n   */\n  async verify(payload, signature) {\n    // if signature code does not match RS256 it's not signed by corresponding\n    // signer.\n    if (signature.code !== signatureCode) {\n      return false\n    }\n\n    return webcrypto.subtle.verify(\n      { name: ALG, hash: { name: HASH_ALG } },\n      await this.publicKey,\n      signature.raw,\n      payload\n    )\n  }\n}\n\nconst RSAVerifier$ = /** @type {API.ComposedDIDParser} */ (RSAVerifier)\nexport { RSAVerifier as Verifier }\n\n/**\n * @typedef {API.ByteView<API.Signer<API.DID<'key'>, typeof signatureCode> & CryptoKey>} EncodedSigner\n */\n\nclass RSASigner {\n  /**\n   * @param {object} options\n   * @param {API.Await<CryptoKey>} options.privateKey\n   * @param {API.RSAVerifier} options.verifier\n   */\n  constructor({ privateKey, verifier }) {\n    /** @readonly */\n    this.verifier = verifier\n    /** @protected */\n    this.privateKey = privateKey\n  }\n  get signer() {\n    return this\n  }\n\n  /**\n   * @type {typeof code}\n   */\n  get code() {\n    return code\n  }\n  /**\n   * @type {typeof signatureCode}\n   */\n  get signatureCode() {\n    return signatureCode\n  }\n  /**\n   * @type {typeof signatureAlgorithm}\n   */\n  get signatureAlgorithm() {\n    return signatureAlgorithm\n  }\n\n  did() {\n    return this.verifier.did()\n  }\n\n  toDIDKey() {\n    return this.verifier.toDIDKey()\n  }\n\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @param {API.Signature<T, typeof this.signatureCode>} signature\n   */\n  verify(payload, signature) {\n    return this.verifier.verify(payload, signature)\n  }\n  /**\n   * @template T\n   * @param {API.ByteView<T>} payload\n   * @returns {Promise<API.SignatureView<T, typeof signatureCode>>}\n   */\n  async sign(payload) {\n    const buffer = await webcrypto.subtle.sign(\n      { name: ALG, saltLength: SALT_LENGTH },\n      await this.privateKey,\n      payload\n    )\n\n    return Signature.create(signatureCode, new Uint8Array(buffer))\n  }\n}\n\n/**\n * @implements {API.RSASigner}\n */\nclass ExtractableRSASigner extends RSASigner {\n  /**\n   * @param {object} options\n   * @param {API.Await<CryptoKey>} options.privateKey\n   * @param {EncodedSigner} options.bytes\n   * @param {API.RSAVerifier} options.verifier\n   */\n  constructor(options) {\n    super(options)\n    this.bytes = options.bytes\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   * @returns {API.Signer<ID, typeof signatureCode>}\n   */\n  withDID(id) {\n    return Signer.withDID(this, id)\n  }\n\n  toArchive() {\n    const id = this.did()\n    return {\n      id,\n      keys: { [id]: this.bytes },\n    }\n  }\n}\n\n/**\n * @implements {API.RSASigner}\n */\nclass UnextractableRSASigner extends RSASigner {\n  /**\n   * @param {object} options\n   * @param {CryptoKey} options.privateKey\n   * @param {API.RSAVerifier} options.verifier\n   */\n  constructor(options) {\n    super(options)\n    this.privateKey = options.privateKey\n  }\n\n  /**\n   * @template {API.DID} ID\n   * @param {ID} id\n   * @returns {API.Signer<ID, typeof signatureCode>}\n   */\n  withDID(id) {\n    return Signer.withDID(this, id)\n  }\n\n  toArchive() {\n    const id = this.did()\n    return {\n      id,\n      keys: { [id]: this.privateKey },\n    }\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AAGO,MAAM,OAAO;AAGb,MAAM,OAAO;AAEpB,oCAAoC,GACpC,MAAM,eAAe;AAGd,MAAM,gBAAgB,kKAAe;AACrC,MAAM,qBAAqB;AAElC,MAAM,MAAM;AACZ,MAAM,WAAW;AACjB,MAAM,WAAW;AACjB,MAAM,cAAc;AACpB,MAAM,gBAAgB;IACpB,MAAM;IACN,MAAM;QAAE,MAAM;IAAS;AACzB;AAQO,MAAM,WAAW,OAAO,EAC7B,OAAO,QAAQ,EACf,cAAc,KAAK,EACpB,GAAG,CAAC,CAAC;IACJ,4DAA4D;IAC5D,MAAM,EAAE,SAAS,EAAE,UAAU,EAAE,GAAG,MAAM,sJAAS,CAAC,MAAM,CAAC,WAAW,CAClE;QACE,MAAM;QACN,eAAe;QACf,gBAAgB,IAAI,WAAW;YAAC;YAAM;YAAM;SAAK;QACjD,MAAM;YAAE,MAAM;QAAS;IACzB,GAEA,aACA;QAAC;QAAQ;KAAS;IAGpB,sEAAsE;IACtE,gEAAgE;IAChE,uDAAuD;IACvD,MAAM,OAAO,MAAM,sJAAS,CAAC,MAAM,CAAC,SAAS,CAAC,QAAQ;IACtD,0EAA0E;IAC1E,YAAY;IACZ,MAAM,cAAc,IAAA,sKAAO,EAAC,cAAc,qKAAW,CAAC,IAAI,WAAW;IACrE,wEAAwE;IACxE,qBAAqB;IACrB,MAAM,WAAW,IAAI,YAAY;QAAE,OAAO;QAAa;IAAU;IAEjE,4EAA4E;IAC5E,yBAAyB;IACzB,IAAI,CAAC,aAAa;QAChB,OAAO,IAAI,uBAAuB;YAChC;YACA;QACF;IACF,OAQK;QACH,MAAM,QAAQ,MAAM,sJAAS,CAAC,MAAM,CAAC,SAAS,CAAC,SAAS;QACxD,MAAM,QAAQ,IAAA,sKAAO,EAAC,MAAM,sKAAY,CAAC,IAAI,WAAW;QACxD,OAAO,IAAI,qBAAqB;YAC9B;YACA;YACA;QACF;IACF;AACF;AAMO,MAAM,OAAO,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE;IAC/B,IAAI,GAAG,UAAU,CAAC,aAAa;QAC7B,MAAM,MAAiC;QACvC,MAAM,MAAM,IAAI,CAAC,IAAI;QACrB,IAAI,eAAe,YAAY;YAC7B,OAAO,OAAO;QAChB,OAAO;YACL,OAAO,IAAI,uBAAuB;gBAChC,YAAY;gBACZ,UAAU,YAAY,KAAK,CAAC;YAC9B;QACF;IACF,OAAO;QACL,MAAM,IAAI,UACR,CAAC,wBAAwB,EAAE,GAAG,oCAAoC,CAAC;IAEvE;AACF;AAMO,MAAM,KAAK,CAAA,QAAS,4JAAS,CAAC;QAAE;IAAK,GAAG;AAMxC,MAAM,SAAS,CAAA;IACpB,wEAAwE;IACxE,MAAM,MAAM,+KAAiB,CAAC,IAAA,wKAAS,EAAC,MAAM;IAC9C,gEAAgE;IAChE,MAAM,cAAc,IAAA,sKAAO,EAAC,cAAc,8KAAgB,CAAC;IAE3D,OAAO,IAAI,qBAAqB;QAC9B;QACA,YAAY,sJAAS,CAAC,MAAM,CAAC,SAAS,CACpC,SACA,sKAAY,CAAC,IAAA,wKAAS,EAAC,MAAM,SAC7B,eACA,MACA;YAAC;SAAO;QAGV,UAAU,YAAY,MAAM,CAAC;IAC/B;AACF;AAEA;;CAEC,GACD,MAAM;IACJ;;;;GAIC,GACD,YAAY,EAAE,SAAS,EAAE,KAAK,EAAE,CAAE;QAChC,aAAa,GACb,IAAI,CAAC,SAAS,GAAG;QACjB,aAAa,GACb,IAAI,CAAC,KAAK,GAAG;IACf;IAEA;;;;GAIC,GACD,QAAQ,EAAE,EAAE;QACV,OAAO,mKAAgB,CAAC,IAAI,EAAE;IAChC;IAEA,WAAW;QACT,OAAO,IAAI,CAAC,GAAG;IACjB;IAEA;;;GAGC,GACD,OAAO,OAAO,KAAK,EAAE;QACnB,OAAO,IAAI,IAAI,CAAC;YACd;YACA,WAAW,sJAAS,CAAC,MAAM,CAAC,SAAS,CACnC,QACA,qKAAW,CAAC,IAAA,wKAAS,EAAC,cAAc,SACpC,eACA,MACA;gBAAC;aAAS;QAEd;IACF;IACA;;;GAGC,GACD,OAAO,MAAM,GAAG,EAAE;QAChB,OAAO,YAAY,MAAM,CAA4B,4JAAS,CAAC;IACjE;IAEA;;GAEC,GACD,OAAO,GAAG,KAAK,EAAE;QACf,OAAO,8JAAW,CAAC,IAAI,EAAE;IAC3B;IAEA,gCAAgC,GAChC,IAAI,OAAO;QACT,OAAO;IACT;IACA;;GAEC,GACD,IAAI,gBAAgB;QAClB,OAAO;IACT;IACA;;GAEC,GACD,IAAI,qBAAqB;QACvB,OAAO;IACT;IACA;;;GAGC,GACD,MAAM;QACJ,OAAO,CAAC,QAAQ,EAAE,2KAAS,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,GAAG;IAClD;IAEA;;;;;GAKC,GACD,MAAM,OAAO,OAAO,EAAE,SAAS,EAAE;QAC/B,0EAA0E;QAC1E,UAAU;QACV,IAAI,UAAU,IAAI,KAAK,eAAe;YACpC,OAAO;QACT;QAEA,OAAO,sJAAS,CAAC,MAAM,CAAC,MAAM,CAC5B;YAAE,MAAM;YAAK,MAAM;gBAAE,MAAM;YAAS;QAAE,GACtC,MAAM,IAAI,CAAC,SAAS,EACpB,UAAU,GAAG,EACb;IAEJ;AACF;AAEA,MAAM,eAAqD;;AAG3D;;CAEC,GAED,MAAM;IACJ;;;;GAIC,GACD,YAAY,EAAE,UAAU,EAAE,QAAQ,EAAE,CAAE;QACpC,cAAc,GACd,IAAI,CAAC,QAAQ,GAAG;QAChB,eAAe,GACf,IAAI,CAAC,UAAU,GAAG;IACpB;IACA,IAAI,SAAS;QACX,OAAO,IAAI;IACb;IAEA;;GAEC,GACD,IAAI,OAAO;QACT,OAAO;IACT;IACA;;GAEC,GACD,IAAI,gBAAgB;QAClB,OAAO;IACT;IACA;;GAEC,GACD,IAAI,qBAAqB;QACvB,OAAO;IACT;IAEA,MAAM;QACJ,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG;IAC1B;IAEA,WAAW;QACT,OAAO,IAAI,CAAC,QAAQ,CAAC,QAAQ;IAC/B;IAEA;;;;GAIC,GACD,OAAO,OAAO,EAAE,SAAS,EAAE;QACzB,OAAO,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,SAAS;IACvC;IACA;;;;GAIC,GACD,MAAM,KAAK,OAAO,EAAE;QAClB,MAAM,SAAS,MAAM,sJAAS,CAAC,MAAM,CAAC,IAAI,CACxC;YAAE,MAAM;YAAK,YAAY;QAAY,GACrC,MAAM,IAAI,CAAC,UAAU,EACrB;QAGF,OAAO,mKAAgB,CAAC,eAAe,IAAI,WAAW;IACxD;AACF;AAEA;;CAEC,GACD,MAAM,6BAA6B;IACjC;;;;;GAKC,GACD,YAAY,OAAO,CAAE;QACnB,KAAK,CAAC;QACN,IAAI,CAAC,KAAK,GAAG,QAAQ,KAAK;IAC5B;IAEA;;;;GAIC,GACD,QAAQ,EAAE,EAAE;QACV,OAAO,iKAAc,CAAC,IAAI,EAAE;IAC9B;IAEA,YAAY;QACV,MAAM,KAAK,IAAI,CAAC,GAAG;QACnB,OAAO;YACL;YACA,MAAM;gBAAE,CAAC,GAAG,EAAE,IAAI,CAAC,KAAK;YAAC;QAC3B;IACF;AACF;AAEA;;CAEC,GACD,MAAM,+BAA+B;IACnC;;;;GAIC,GACD,YAAY,OAAO,CAAE;QACnB,KAAK,CAAC;QACN,IAAI,CAAC,UAAU,GAAG,QAAQ,UAAU;IACtC;IAEA;;;;GAIC,GACD,QAAQ,EAAE,EAAE;QACV,OAAO,iKAAc,CAAC,IAAI,EAAE;IAC9B;IAEA,YAAY;QACV,MAAM,KAAK,IAAI,CAAC,GAAG;QACnB,OAAO;YACL;YACA,MAAM;gBAAE,CAAC,GAAG,EAAE,IAAI,CAAC,UAAU;YAAC;QAChC;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 4013, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/principal/src/absentee.js"],"sourcesContent":["import * as Signature from '@ipld/dag-ucan/signature'\nimport * as UCAN from '@ipld/dag-ucan'\n\n/**\n * @template {UCAN.DID} ID\n * @param {{id: ID }} id\n * @returns {UCAN.Signer<ID, Signature.NON_STANDARD>}\n */\nexport const from = ({ id }) => new Absentee(id)\n\n/**\n * An absentee is a special type of signer that produces an absent signature,\n * which signals that verifier needs to verify authorization interactively.\n *\n * @template {UCAN.DID} ID\n * @implements {UCAN.Signer<ID, Signature.NON_STANDARD>}\n */\nclass Absentee {\n  /**\n   * @param {ID} id\n   */\n  constructor(id) {\n    this.id = id\n  }\n  did() {\n    return this.id\n  }\n  /* c8 ignore next 3 */\n  get signatureCode() {\n    return Signature.NON_STANDARD\n  }\n  get signatureAlgorithm() {\n    return ''\n  }\n  sign() {\n    return Signature.createNonStandard(\n      this.signatureAlgorithm,\n      new Uint8Array(0)\n    )\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAOO,MAAM,OAAO,CAAC,EAAE,EAAE,EAAE,GAAK,IAAI,SAAS;AAE7C;;;;;;CAMC,GACD,MAAM;IACJ;;GAEC,GACD,YAAY,EAAE,CAAE;QACd,IAAI,CAAC,EAAE,GAAG;IACZ;IACA,MAAM;QACJ,OAAO,IAAI,CAAC,EAAE;IAChB;IACA,oBAAoB,GACpB,IAAI,gBAAgB;QAClB,OAAO,yKAAsB;IAC/B;IACA,IAAI,qBAAqB;QACvB,OAAO;IACT;IACA,OAAO;QACL,OAAO,8KAA2B,CAChC,IAAI,CAAC,kBAAkB,EACvB,IAAI,WAAW;IAEnB;AACF","ignoreList":[0]}},
    {"offset": {"line": 4051, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/principal/src/lib.js"],"sourcesContent":["import * as ed25519 from './ed25519.js'\nimport * as RSA from './rsa.js'\nimport * as Absentee from './absentee.js'\nexport * from './multiformat.js'\nexport const Verifier = ed25519.Verifier.or(RSA.Verifier)\nexport const Signer = ed25519.or(RSA)\n\n// exports\nexport { ed25519, RSA, Absentee }\n"],"names":[],"mappings":";;;;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;;;;;AACO,MAAM,WAAW,mNAAgB,CAAC,EAAE,CAAC,oJAAI,QAAQ;AACjD,MAAM,SAAS,uKAAU,CAAC","ignoreList":[0]}}]
}