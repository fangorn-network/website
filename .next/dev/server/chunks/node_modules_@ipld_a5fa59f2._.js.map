{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 9, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/dag-ucan/src/utf8.js"],"sourcesContent":["export const encoder = new TextEncoder()\nexport const decoder = new TextDecoder()\n\n/**\n * @template T\n * @param {import('./ucan').ToString<T>} text\n * @returns {import('./ucan').ByteView<T>}\n */\nexport const encode = text => encoder.encode(text)\n\n/**\n * @template T\n * @param {import('./ucan').ByteView<T>} bytes\n * @returns {import('./ucan').ToString<T>}\n */\nexport const decode = bytes => decoder.decode(bytes)\n"],"names":[],"mappings":";;;;;;;;;;AAAO,MAAM,UAAU,IAAI;AACpB,MAAM,UAAU,IAAI;AAOpB,MAAM,SAAS,CAAA,OAAQ,QAAQ,MAAM,CAAC;AAOtC,MAAM,SAAS,CAAA,QAAS,QAAQ,MAAM,CAAC","ignoreList":[0]}},
    {"offset": {"line": 27, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/dag-ucan/src/did.js"],"sourcesContent":["import * as UCAN from \"./ucan.js\"\nimport { base58btc } from \"multiformats/bases/base58\"\nimport { varint } from \"multiformats\"\nimport * as UTF8 from \"./utf8.js\"\n\nconst DID_PREFIX = \"did:\"\nconst DID_PREFIX_SIZE = DID_PREFIX.length\nconst DID_KEY_PREFIX = `did:key:`\nconst DID_KEY_PREFIX_SIZE = DID_KEY_PREFIX.length\n\nexport const ED25519 = 0xed\nexport const RSA = 0x1205\nexport const P256 = 0x1200\nexport const P384 = 0x1201\nexport const P521 = 0x1202\nexport const SECP256K1 = 0xe7\nexport const BLS12381G1 = 0xea\nexport const BLS12381G2 = 0xeb\nexport const DID_CORE = 0x0d1d\nconst METHOD_OFFSET = varint.encodingLength(DID_CORE)\n\n/**\n * @typedef {typeof ED25519|typeof RSA|typeof P256|typeof P384|typeof P521|typeof DID_CORE} Code\n */\n\n/**\n * Parses a DID string into a DID buffer view\n *\n * @template {UCAN.DID} ID\n * @param {ID|UCAN.ToString<unknown>} did\n * @returns {UCAN.PrincipalView<ID>}\n */\nexport const parse = did => {\n  if (!did.startsWith(DID_PREFIX)) {\n    throw new RangeError(`Invalid DID \"${did}\", must start with 'did:'`)\n  } else if (did.startsWith(DID_KEY_PREFIX)) {\n    const key = base58btc.decode(did.slice(DID_KEY_PREFIX_SIZE))\n    return decode(key)\n  } else {\n    const suffix = UTF8.encode(did.slice(DID_PREFIX_SIZE))\n    const bytes = new Uint8Array(suffix.byteLength + METHOD_OFFSET)\n    varint.encodeTo(DID_CORE, bytes)\n    bytes.set(suffix, METHOD_OFFSET)\n    return new DID(bytes)\n  }\n}\n\n/**\n * @template {UCAN.DID} ID\n * @param {UCAN.Principal<ID>} id\n * @returns {ID}\n */\nexport const format = id => id.did()\n\n/**\n * @template {UCAN.DID} ID\n * @param {UCAN.PrincipalView<ID>|UCAN.ByteView<UCAN.Principal<ID>>|UCAN.Principal<ID>|ID|UCAN.ToJSONString<unknown>} principal\n * @returns {UCAN.PrincipalView<ID>}\n */\nexport const from = principal => {\n  if (principal instanceof DID) {\n    return principal\n  } else if (principal instanceof Uint8Array) {\n    return decode(principal)\n  } else if (typeof principal === \"string\") {\n    return parse(principal)\n  } else {\n    return parse(principal.did())\n  }\n}\n\n/**\n * @template {UCAN.DID} ID\n * @param {UCAN.ByteView<UCAN.Principal<ID>>} bytes\n * @returns {UCAN.PrincipalView<ID>}\n */\nexport const decode = bytes => {\n  const [code] = varint.decode(bytes)\n  const { buffer, byteOffset, byteLength } = bytes\n  switch (code) {\n    case P256:\n      if (bytes.length > 35) {\n        throw new RangeError(`Only p256-pub compressed is supported.`)\n      }\n    case ED25519:\n    case RSA:\n    case P384:\n    case P521:\n    case BLS12381G1:\n    case BLS12381G2:\n    case SECP256K1:\n      return /** @type {UCAN.PrincipalView<any>} */ (\n        new DIDKey(buffer, byteOffset, byteLength)\n      )\n    case DID_CORE:\n      return new DID(buffer, byteOffset, byteLength)\n    default:\n      throw new RangeError(\n        `Unsupported DID encoding, unknown multicode 0x${code.toString(16)}.`\n      )\n  }\n}\n\n/**\n * @template {UCAN.DID} ID\n * @param {UCAN.Principal<ID>} principal\n * @returns {UCAN.PrincipalView<ID>}\n */\nexport const encode = principal => parse(principal.did())\n\n/**\n * @template {UCAN.DID} ID\n * @implements {UCAN.PrincipalView<ID>}\n * @extends {Uint8Array}\n */\nclass DID extends Uint8Array {\n  /**\n   * @returns {ID}\n   */\n  did() {\n    const bytes = new Uint8Array(this.buffer, this.byteOffset + METHOD_OFFSET)\n    return /** @type {ID} */ (`did:${UTF8.decode(bytes)}`)\n  }\n\n  toJSON() {\n    return this.did()\n  }\n}\n\n/**\n * @implements {UCAN.PrincipalView<UCAN.DID<\"key\">>}\n * @extends {DID<UCAN.DID<\"key\">>}\n */\nclass DIDKey extends DID {\n  /**\n   * @return {`did:key:${string}`}\n   */\n  did() {\n    return `did:key:${base58btc.encode(this)}`\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AAAA;AACA;;;;;AAEA,MAAM,aAAa;AACnB,MAAM,kBAAkB,WAAW,MAAM;AACzC,MAAM,iBAAiB,CAAC,QAAQ,CAAC;AACjC,MAAM,sBAAsB,eAAe,MAAM;AAE1C,MAAM,UAAU;AAChB,MAAM,MAAM;AACZ,MAAM,OAAO;AACb,MAAM,OAAO;AACb,MAAM,OAAO;AACb,MAAM,YAAY;AAClB,MAAM,aAAa;AACnB,MAAM,aAAa;AACnB,MAAM,WAAW;AACxB,MAAM,gBAAgB,mMAAM,CAAC,cAAc,CAAC;AAarC,MAAM,QAAQ,CAAA;IACnB,IAAI,CAAC,IAAI,UAAU,CAAC,aAAa;QAC/B,MAAM,IAAI,WAAW,CAAC,aAAa,EAAE,IAAI,yBAAyB,CAAC;IACrE,OAAO,IAAI,IAAI,UAAU,CAAC,iBAAiB;QACzC,MAAM,MAAM,6KAAS,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC;QACvC,OAAO,OAAO;IAChB,OAAO;QACL,MAAM,SAAS,gKAAW,CAAC,IAAI,KAAK,CAAC;QACrC,MAAM,QAAQ,IAAI,WAAW,OAAO,UAAU,GAAG;QACjD,mMAAM,CAAC,QAAQ,CAAC,UAAU;QAC1B,MAAM,GAAG,CAAC,QAAQ;QAClB,OAAO,IAAI,IAAI;IACjB;AACF;AAOO,MAAM,SAAS,CAAA,KAAM,GAAG,GAAG;AAO3B,MAAM,OAAO,CAAA;IAClB,IAAI,qBAAqB,KAAK;QAC5B,OAAO;IACT,OAAO,IAAI,qBAAqB,YAAY;QAC1C,OAAO,OAAO;IAChB,OAAO,IAAI,OAAO,cAAc,UAAU;QACxC,OAAO,MAAM;IACf,OAAO;QACL,OAAO,MAAM,UAAU,GAAG;IAC5B;AACF;AAOO,MAAM,SAAS,CAAA;IACpB,MAAM,CAAC,KAAK,GAAG,mMAAM,CAAC,MAAM,CAAC;IAC7B,MAAM,EAAE,MAAM,EAAE,UAAU,EAAE,UAAU,EAAE,GAAG;IAC3C,OAAQ;QACN,KAAK;YACH,IAAI,MAAM,MAAM,GAAG,IAAI;gBACrB,MAAM,IAAI,WAAW,CAAC,sCAAsC,CAAC;YAC/D;QACF,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;YACH,OACE,IAAI,OAAO,QAAQ,YAAY;QAEnC,KAAK;YACH,OAAO,IAAI,IAAI,QAAQ,YAAY;QACrC;YACE,MAAM,IAAI,WACR,CAAC,8CAA8C,EAAE,KAAK,QAAQ,CAAC,IAAI,CAAC,CAAC;IAE3E;AACF;AAOO,MAAM,SAAS,CAAA,YAAa,MAAM,UAAU,GAAG;AAEtD;;;;CAIC,GACD,MAAM,YAAY;IAChB;;GAEC,GACD,MAAM;QACJ,MAAM,QAAQ,IAAI,WAAW,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,UAAU,GAAG;QAC5D,OAA0B,CAAC,IAAI,EAAE,gKAAW,CAAC,QAAQ;IACvD;IAEA,SAAS;QACP,OAAO,IAAI,CAAC,GAAG;IACjB;AACF;AAEA;;;CAGC,GACD,MAAM,eAAe;IACnB;;GAEC,GACD,MAAM;QACJ,OAAO,CAAC,QAAQ,EAAE,6KAAS,CAAC,MAAM,CAAC,IAAI,GAAG;IAC5C;AACF","ignoreList":[0]}},
    {"offset": {"line": 158, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/dag-ucan/src/signature.js"],"sourcesContent":["import * as UCAN from \"./ucan.js\"\nimport { varint } from \"multiformats\"\nimport { base64url, base64 } from \"multiformats/bases/base64\"\nimport * as UTF8 from \"./utf8.js\"\n\nexport const NON_STANDARD = 0xd000\nexport const ES256K = 0xd0e7\nexport const BLS12381G1 = 0xd0ea\nexport const BLS12381G2 = 0xd0eb\nexport const EdDSA = 0xd0ed\nexport const ES256 = 0xd01200\nexport const ES384 = 0xd01201\nexport const ES512 = 0xd01202\nexport const RS256 = 0xd01205\nexport const EIP191 = 0xd191\n\n/**\n * @param {number} code\n * @returns {string}\n */\nconst codeName = code => {\n  switch (code) {\n    case ES256K:\n      return \"ES256K\"\n    case BLS12381G1:\n      return \"BLS12381G1\"\n    case BLS12381G2:\n      return \"BLS12381G2\"\n    case EdDSA:\n      return \"EdDSA\"\n    case ES256:\n      return \"ES256\"\n    case ES384:\n      return \"ES384\"\n    case ES512:\n      return \"ES512\"\n    case RS256:\n      return \"RS256\"\n    case EIP191:\n      return \"EIP191\"\n    default:\n      throw new RangeError(\n        `Unknown signature algorithm code 0x${code.toString(16)}`\n      )\n  }\n}\n\n/**\n *\n * @param {string} name\n */\nexport const nameCode = name => {\n  switch (name) {\n    case \"ES256K\":\n      return ES256K\n    case \"BLS12381G1\":\n      return BLS12381G1\n    case \"BLS12381G2\":\n      return BLS12381G2\n    case \"EdDSA\":\n      return EdDSA\n    case \"ES256\":\n      return ES256\n    case \"ES384\":\n      return ES384\n    case \"ES512\":\n      return ES512\n    case \"RS256\":\n      return RS256\n    case \"EIP191\":\n      return EIP191\n    default:\n      return NON_STANDARD\n  }\n}\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @implements {UCAN.SignatureView<T, A>}\n */\nexport class Signature extends Uint8Array {\n  get code() {\n    const [code] = varint.decode(this)\n    Object.defineProperties(this, { code: { value: code } })\n    return /** @type {A} */ (code)\n  }\n\n  get size() {\n    const value = size(this)\n    Object.defineProperties(this, { size: { value } })\n    return value\n  }\n  get algorithm() {\n    const value = algorithm(this)\n    Object.defineProperties(this, { algorithm: { value } })\n    return value\n  }\n\n  get raw() {\n    const { buffer, byteOffset, size, code } = this\n    const codeSize = varint.encodingLength(code)\n    const rawSize = varint.encodingLength(size)\n    const value = new Uint8Array(buffer, byteOffset + codeSize + rawSize, size)\n    Object.defineProperties(this, { raw: { value } })\n    return value\n  }\n\n  /**\n   * Verify that this signature was created by the given key.\n   *\n   * @param {UCAN.Crypto.Verifier<A>} signer\n   * @param {UCAN.ByteView<T>} payload\n   */\n  async verify(signer, payload) {\n    try {\n      if ((await signer.verify(payload, this)) === true) {\n        return { ok: {} }\n      } else {\n        throw new Error(\"Invalid signature\")\n      }\n    } catch (cause) {\n      return { error: /** @type {Error} */ (cause) }\n    }\n  }\n\n  toJSON() {\n    return toJSON(this)\n  }\n}\n\n/**\n * @param {UCAN.Signature} signature\n */\nconst algorithm = signature => {\n  const { code, raw, buffer, byteOffset } = signature\n  if (code === NON_STANDARD) {\n    const offset =\n      raw.byteLength +\n      varint.encodingLength(code) +\n      varint.encodingLength(raw.byteLength)\n    const bytes = new Uint8Array(buffer, byteOffset + offset)\n    return UTF8.decode(bytes)\n  } else {\n    return codeName(code)\n  }\n}\n\n/**\n * @param {UCAN.Signature} signature\n */\nconst size = signature => {\n  const offset = varint.encodingLength(signature.code)\n  const [size] = varint.decode(\n    new Uint8Array(signature.buffer, signature.byteOffset + offset)\n  )\n  return size\n}\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @param {A} code\n * @param {Uint8Array} raw\n * @returns {UCAN.SignatureView<T, A>}\n */\nexport const create = (code, raw) => {\n  const _ = codeName(code)\n  const codeSize = varint.encodingLength(code)\n  const rawSize = varint.encodingLength(raw.byteLength)\n\n  /** @type {Signature<T, A>} */\n  const signature = new Signature(codeSize + rawSize + raw.byteLength)\n  varint.encodeTo(code, signature)\n  varint.encodeTo(raw.byteLength, signature, codeSize)\n  signature.set(raw, codeSize + rawSize)\n  Object.defineProperties(signature, {\n    code: { value: code },\n    size: { value: raw.byteLength },\n  })\n  return signature\n}\n\n/**\n * @template {unknown} T\n * @param {string} name\n * @param {Uint8Array} raw\n * @return {UCAN.SignatureView<T>}\n */\nexport const createNamed = (name, raw) => {\n  const code = nameCode(name)\n  return code === NON_STANDARD\n    ? createNonStandard(name, raw)\n    : create(code, raw)\n}\n\n/**\n * @template {unknown} T\n * @param {string} name\n * @param {Uint8Array} raw\n * @return {UCAN.SignatureView<T, typeof NON_STANDARD>}\n */\nexport const createNonStandard = (name, raw) => {\n  const code = NON_STANDARD\n  const codeSize = varint.encodingLength(code)\n  const rawSize = varint.encodingLength(raw.byteLength)\n  const nameBytes = UTF8.encode(name)\n  /** @type {Signature<T, typeof NON_STANDARD>} */\n  const signature = new Signature(\n    codeSize + rawSize + raw.byteLength + nameBytes.byteLength\n  )\n  varint.encodeTo(code, signature)\n  varint.encodeTo(raw.byteLength, signature, codeSize)\n  signature.set(raw, codeSize + rawSize)\n  signature.set(nameBytes, codeSize + rawSize + raw.byteLength)\n\n  return signature\n}\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @param {UCAN.ByteView<UCAN.Signature<T, A>>} bytes\n * @returns {UCAN.SignatureView<T, A>}\n */\nexport const view = bytes =>\n  new Signature(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @param {UCAN.ByteView<UCAN.Signature<T, A>>} bytes\n * @returns {UCAN.SignatureView<T, A>}\n */\nexport const decode = bytes => {\n  if (!(bytes instanceof Uint8Array)) {\n    throw new TypeError(\n      `Can only decode Uint8Array into a Signature, instead got ${JSON.stringify(\n        bytes\n      )}`\n    )\n  }\n\n  /** @type {UCAN.SignatureView<T, A>} */\n  const signature = view(bytes)\n  const { code, algorithm, raw } = signature\n  return signature\n}\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @param {UCAN.Signature<T, A>} signature\n * @returns {UCAN.ByteView<UCAN.Signature<T, A>>}\n */\nexport const encode = signature => decode(signature)\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @template {string} [Prefix=\"u\"]\n * @param {UCAN.Signature<T, A>} signature\n * @param {UCAN.MultibaseEncoder<Prefix>} [base]\n * @returns {UCAN.ToString<UCAN.Signature<T, A>>}\n */\nexport const format = (signature, base) => (base || base64url).encode(signature)\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @template {string} [Prefix=\"u\"]\n * @param {UCAN.ToString<UCAN.Signature<T, A>>} signature\n * @param {UCAN.MultibaseDecoder<Prefix>} [base]\n * @returns {UCAN.SignatureView<T, A>}\n */\nexport const parse = (signature, base) =>\n  /** @type {UCAN.SignatureView<T, A>} */ (\n    decode((base || base64url).decode(signature))\n  )\n\n/**\n * @template {UCAN.Signature} Signature\n * @param {Signature} signature\n * @returns {UCAN.SignatureJSON<Signature>}\n */\nexport const toJSON = signature => ({\n  \"/\": { bytes: base64.baseEncode(signature) },\n})\n\n/**\n * @template {unknown} T\n * @template {UCAN.SigAlg} A\n * @param {UCAN.SignatureJSON<UCAN.Signature<T, A>>} json\n * @returns {UCAN.SignatureView<T, A>}\n */\nexport const fromJSON = json => decode(base64.baseDecode(json[\"/\"].bytes))\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAAA;AACA;AACA;;;;;AAEO,MAAM,eAAe;AACrB,MAAM,SAAS;AACf,MAAM,aAAa;AACnB,MAAM,aAAa;AACnB,MAAM,QAAQ;AACd,MAAM,QAAQ;AACd,MAAM,QAAQ;AACd,MAAM,QAAQ;AACd,MAAM,QAAQ;AACd,MAAM,SAAS;AAEtB;;;CAGC,GACD,MAAM,WAAW,CAAA;IACf,OAAQ;QACN,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT;YACE,MAAM,IAAI,WACR,CAAC,mCAAmC,EAAE,KAAK,QAAQ,CAAC,KAAK;IAE/D;AACF;AAMO,MAAM,WAAW,CAAA;IACtB,OAAQ;QACN,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT,KAAK;YACH,OAAO;QACT;YACE,OAAO;IACX;AACF;AAOO,MAAM,kBAAkB;IAC7B,IAAI,OAAO;QACT,MAAM,CAAC,KAAK,GAAG,mMAAM,CAAC,MAAM,CAAC,IAAI;QACjC,OAAO,gBAAgB,CAAC,IAAI,EAAE;YAAE,MAAM;gBAAE,OAAO;YAAK;QAAE;QACtD,OAAyB;IAC3B;IAEA,IAAI,OAAO;QACT,MAAM,QAAQ,KAAK,IAAI;QACvB,OAAO,gBAAgB,CAAC,IAAI,EAAE;YAAE,MAAM;gBAAE;YAAM;QAAE;QAChD,OAAO;IACT;IACA,IAAI,YAAY;QACd,MAAM,QAAQ,UAAU,IAAI;QAC5B,OAAO,gBAAgB,CAAC,IAAI,EAAE;YAAE,WAAW;gBAAE;YAAM;QAAE;QACrD,OAAO;IACT;IAEA,IAAI,MAAM;QACR,MAAM,EAAE,MAAM,EAAE,UAAU,EAAE,IAAI,EAAE,IAAI,EAAE,GAAG,IAAI;QAC/C,MAAM,WAAW,mMAAM,CAAC,cAAc,CAAC;QACvC,MAAM,UAAU,mMAAM,CAAC,cAAc,CAAC;QACtC,MAAM,QAAQ,IAAI,WAAW,QAAQ,aAAa,WAAW,SAAS;QACtE,OAAO,gBAAgB,CAAC,IAAI,EAAE;YAAE,KAAK;gBAAE;YAAM;QAAE;QAC/C,OAAO;IACT;IAEA;;;;;GAKC,GACD,MAAM,OAAO,MAAM,EAAE,OAAO,EAAE;QAC5B,IAAI;YACF,IAAI,AAAC,MAAM,OAAO,MAAM,CAAC,SAAS,IAAI,MAAO,MAAM;gBACjD,OAAO;oBAAE,IAAI,CAAC;gBAAE;YAClB,OAAO;gBACL,MAAM,IAAI,MAAM;YAClB;QACF,EAAE,OAAO,OAAO;YACd,OAAO;gBAAE,OAA6B;YAAO;QAC/C;IACF;IAEA,SAAS;QACP,OAAO,OAAO,IAAI;IACpB;AACF;AAEA;;CAEC,GACD,MAAM,YAAY,CAAA;IAChB,MAAM,EAAE,IAAI,EAAE,GAAG,EAAE,MAAM,EAAE,UAAU,EAAE,GAAG;IAC1C,IAAI,SAAS,cAAc;QACzB,MAAM,SACJ,IAAI,UAAU,GACd,mMAAM,CAAC,cAAc,CAAC,QACtB,mMAAM,CAAC,cAAc,CAAC,IAAI,UAAU;QACtC,MAAM,QAAQ,IAAI,WAAW,QAAQ,aAAa;QAClD,OAAO,gKAAW,CAAC;IACrB,OAAO;QACL,OAAO,SAAS;IAClB;AACF;AAEA;;CAEC,GACD,MAAM,OAAO,CAAA;IACX,MAAM,SAAS,mMAAM,CAAC,cAAc,CAAC,UAAU,IAAI;IACnD,MAAM,CAAC,KAAK,GAAG,mMAAM,CAAC,MAAM,CAC1B,IAAI,WAAW,UAAU,MAAM,EAAE,UAAU,UAAU,GAAG;IAE1D,OAAO;AACT;AASO,MAAM,SAAS,CAAC,MAAM;IAC3B,MAAM,IAAI,SAAS;IACnB,MAAM,WAAW,mMAAM,CAAC,cAAc,CAAC;IACvC,MAAM,UAAU,mMAAM,CAAC,cAAc,CAAC,IAAI,UAAU;IAEpD,4BAA4B,GAC5B,MAAM,YAAY,IAAI,UAAU,WAAW,UAAU,IAAI,UAAU;IACnE,mMAAM,CAAC,QAAQ,CAAC,MAAM;IACtB,mMAAM,CAAC,QAAQ,CAAC,IAAI,UAAU,EAAE,WAAW;IAC3C,UAAU,GAAG,CAAC,KAAK,WAAW;IAC9B,OAAO,gBAAgB,CAAC,WAAW;QACjC,MAAM;YAAE,OAAO;QAAK;QACpB,MAAM;YAAE,OAAO,IAAI,UAAU;QAAC;IAChC;IACA,OAAO;AACT;AAQO,MAAM,cAAc,CAAC,MAAM;IAChC,MAAM,OAAO,SAAS;IACtB,OAAO,SAAS,eACZ,kBAAkB,MAAM,OACxB,OAAO,MAAM;AACnB;AAQO,MAAM,oBAAoB,CAAC,MAAM;IACtC,MAAM,OAAO;IACb,MAAM,WAAW,mMAAM,CAAC,cAAc,CAAC;IACvC,MAAM,UAAU,mMAAM,CAAC,cAAc,CAAC,IAAI,UAAU;IACpD,MAAM,YAAY,gKAAW,CAAC;IAC9B,8CAA8C,GAC9C,MAAM,YAAY,IAAI,UACpB,WAAW,UAAU,IAAI,UAAU,GAAG,UAAU,UAAU;IAE5D,mMAAM,CAAC,QAAQ,CAAC,MAAM;IACtB,mMAAM,CAAC,QAAQ,CAAC,IAAI,UAAU,EAAE,WAAW;IAC3C,UAAU,GAAG,CAAC,KAAK,WAAW;IAC9B,UAAU,GAAG,CAAC,WAAW,WAAW,UAAU,IAAI,UAAU;IAE5D,OAAO;AACT;AAQO,MAAM,OAAO,CAAA,QAClB,IAAI,UAAU,MAAM,MAAM,EAAE,MAAM,UAAU,EAAE,MAAM,UAAU;AAQzD,MAAM,SAAS,CAAA;IACpB,IAAI,CAAC,CAAC,iBAAiB,UAAU,GAAG;QAClC,MAAM,IAAI,UACR,CAAC,yDAAyD,EAAE,KAAK,SAAS,CACxE,QACC;IAEP;IAEA,qCAAqC,GACrC,MAAM,YAAY,KAAK;IACvB,MAAM,EAAE,IAAI,EAAE,SAAS,EAAE,GAAG,EAAE,GAAG;IACjC,OAAO;AACT;AAQO,MAAM,SAAS,CAAA,YAAa,OAAO;AAUnC,MAAM,SAAS,CAAC,WAAW,OAAS,CAAC,QAAQ,6KAAS,EAAE,MAAM,CAAC;AAU/D,MAAM,QAAQ,CAAC,WAAW,OAE7B,OAAO,CAAC,QAAQ,6KAAS,EAAE,MAAM,CAAC;AAQ/B,MAAM,SAAS,CAAA,YAAa,CAAC;QAClC,KAAK;YAAE,OAAO,0KAAM,CAAC,UAAU,CAAC;QAAW;IAC7C,CAAC;AAQM,MAAM,WAAW,CAAA,OAAQ,OAAO,0KAAM,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK","ignoreList":[0]}},
    {"offset": {"line": 413, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/dag-ucan/src/schema.js"],"sourcesContent":["import * as UCAN from \"./ucan.js\"\nimport * as UTF8 from \"./utf8.js\"\nimport * as Link from \"multiformats/link\"\nimport { identity } from \"multiformats/hashes/identity\"\nimport * as DID from \"./did.js\"\nimport * as raw from \"multiformats/codecs/raw\"\nimport * as Signature from \"./signature.js\"\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {Record<string, unknown>|UCAN.Payload<C>} data\n * @returns {UCAN.Payload<C>}\n */\nexport const readPayload = data =>\n  readPayloadWith(data, {\n    readPrincipal,\n    readProof,\n  })\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {Record<string, unknown>|UCAN.Payload<C>} data\n * @returns {UCAN.Payload<C>}\n */\nexport const readJWTPayload = data =>\n  readPayloadWith(data, {\n    readPrincipal: readStringPrincipal,\n    readProof: readStringProof,\n  })\n/**\n *\n * @template {UCAN.Capabilities} C\n * @param {Record<string, unknown>|UCAN.Payload<C>} data\n * @param {object} readers\n * @param {(source:unknown, context:string) => UCAN.Principal} readers.readPrincipal\n * @param {(source:unknown, context:string) => UCAN.Link} readers.readProof\n * @returns {UCAN.Payload<C>}\n */\nconst readPayloadWith = (data, { readPrincipal, readProof }) => ({\n  iss: readPrincipal(data.iss, \"iss\"),\n  aud: readPrincipal(data.aud, \"aud\"),\n  att: readCapabilities(data.att, \"att\"),\n  prf: readOptionalArray(data.prf, readProof, \"prf\") || [],\n  exp: readNullable(data.exp === Infinity ? null : data.exp, readInt, \"exp\"),\n  nbf: readOptional(data.nbf, readInt, \"nbf\"),\n  fct: readOptionalArray(data.fct, readFact, \"fct\") || [],\n  nnc: readOptional(data.nnc, readString, \"nnc\"),\n})\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @param {UCAN.ByteView<UCAN.Signature<T, A>>|unknown} source\n */\nexport const readSignature = source => {\n  if (source instanceof Uint8Array) {\n    return Signature.decode(source)\n  } else {\n    throw new TypeError(\n      `Can only decode Uint8Array into a Signature, instead got ${JSON.stringify(\n        source\n      )}`\n    )\n  }\n}\n\n/**\n * @param {unknown} input\n * @param {string} name\n * @returns {number}\n */\nexport const readInt = (input, name) =>\n  Number.isInteger(input)\n    ? /** @type {number} */ (input)\n    : ParseError.throw(\n        `Expected ${name} to be integer, instead got ${JSON.stringify(input)}`\n      )\n\n/**\n * @param {unknown} input\n * @param {string} context\n */\n\nexport const readCapability = (input, context) =>\n  readStruct(input, asCapability, context)\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {unknown|C} input\n * @param {string} context\n * @returns {C}\n */\nexport const readCapabilities = (input, context) =>\n  /** @type {C} */ (readArray(input, readCapability, context))\n\n/**\n * @template {UCAN.Capability} C\n * @param {object & {can?:unknown, with?:unknown}|C} input\n * @returns {C}\n */\nexport const asCapability = input =>\n  /** @type {C} */ ({\n    ...input,\n    can: readAbility(input.can),\n    with: readResource(input.with),\n  })\n\n/**\n * @param {unknown} input\n */\nconst readAbility = input =>\n  typeof input !== \"string\"\n    ? ParseError.throw(\n        `Capability has invalid 'can: ${JSON.stringify(\n          input\n        )}', value must be a string`\n      )\n    : input.slice(1, -1).includes(\"/\")\n    ? /** @type {UCAN.Ability} */ (input.toLocaleLowerCase())\n    : input === \"*\"\n    ? input\n    : ParseError.throw(\n        `Capability has invalid 'can: \"${input}\"', value must have at least one path segment`\n      )\n\n/**\n * @param {unknown} input\n */\nconst readResource = input =>\n  typeof input !== \"string\"\n    ? ParseError.throw(\n        `Capability has invalid 'with: ${JSON.stringify(\n          input\n        )}', value must be a string`\n      )\n    : parseURL(input) ||\n      ParseError.throw(\n        `Capability has invalid 'with: \"${input}\"', value must be a valid URI string`\n      )\n\n/**\n * @param {string} input\n */\nconst parseURL = input => {\n  try {\n    new URL(input)\n    return input\n  } catch (_) {\n    return null\n  }\n}\n/**\n * @template T\n * @param {unknown} input\n * @param {(input:unknown, context:string) => T} read\n * @param {string} context\n * @returns {T[]}\n */\nexport const readArray = (input, read, context) =>\n  Array.isArray(input)\n    ? input.map((element, n) => read(element, `${context}[${n}]`))\n    : ParseError.throw(`${context} must be an array`)\n\n/**\n * @template T\n * @param {unknown} input\n * @param {(input:unknown, context: string) => T} reader\n * @param {string} context\n * @returns {T[]|undefined}\n */\nexport const readOptionalArray = (input, reader, context) =>\n  input === undefined ? input : readArray(input, reader, context)\n\n/**\n * @template T\n * @param {unknown} input\n * @param {(input:object) => T} reader\n * @param {string} context\n * @returns {T}\n */\nexport const readStruct = (input, reader, context) =>\n  input != null && typeof input === \"object\"\n    ? reader(input)\n    : ParseError.throw(\n        `${context} must be of type object, instead got ${input}`\n      )\n\n/**\n * @param {unknown} input\n * @param {string} context\n * @returns {UCAN.Fact}\n */\nexport const readFact = (input, context) => readStruct(input, Object, context)\n\n/**\n * @param {unknown} source\n * @param {string} context\n * @returns {UCAN.Link}\n */\nexport const readProof = (source, context) =>\n  Link.isLink(source)\n    ? /** @type {UCAN.Link} */ (source)\n    : fail(\n        `Expected ${context} to be IPLD link, instead got ${JSON.stringify(\n          source\n        )}`\n      )\n\n/**\n * @param {unknown} source\n * @param {string} context\n * @returns {UCAN.Link}\n */\nexport const readStringProof = (source, context) =>\n  parseProof(readString(source, context))\n\n/**\n * @param {string} source\n * @returns {UCAN.Link}\n */\nconst parseProof = source => {\n  // First we attempt to read proof as CID, if we fail fallback to reading it as\n  // an inline proof.\n  try {\n    return Link.parse(source)\n  } catch (error) {\n    return Link.create(raw.code, identity.digest(UTF8.encode(source)))\n  }\n}\n\n/**\n * @param {unknown} input\n * @param {string} context\n */\nexport const readPrincipal = (input, context) =>\n  DID.decode(readBytes(input, context))\n\n/**\n * @param {unknown} source\n * @param {string} context\n */\nexport const readStringPrincipal = (source, context) =>\n  DID.parse(readString(source, context))\n\n/**\n * @template T\n * @param {unknown} source\n * @param {(source:unknown, context:string) => T} read\n * @param {string} [context]\n * @returns {T|undefined}\n */\nexport const readOptional = (source, read, context = \"Field\") =>\n  source !== undefined ? read(source, context) : undefined\n\n/**\n * @template T\n * @param {unknown} source\n * @param {(source:unknown, context:string) => T} read\n * @param {string} context\n * @returns {T|null}\n */\nexport const readNullable = (source, read, context) =>\n  source === null ? null : read(source, context)\n\n/**\n * @param {unknown} source\n * @param {string} [context]\n * @returns {string}\n */\nexport const readString = (source, context = \"Field\") =>\n  typeof source === \"string\"\n    ? source\n    : fail(`${context} has invalid value ${source}`)\n\n/**\n *\n * @param {unknown} source\n * @param {string} context\n * @returns {Uint8Array}\n */\nexport const readBytes = (source, context) =>\n  source instanceof Uint8Array\n    ? source\n    : fail(\n        `Expected ${context} to be Uint8Array, instead got ${JSON.stringify(\n          source\n        )}`\n      )\n\n/**\n * @param {unknown} input\n * @param {string} context\n * @returns {UCAN.Version}\n */\nexport const readVersion = (input, context) =>\n  /\\d+\\.\\d+\\.\\d+/.test(/** @type {string} */ (input))\n    ? /** @type {UCAN.Version} */ (input)\n    : ParseError.throw(`Invalid version '${context}: ${JSON.stringify(input)}'`)\n\n/**\n * @template {string|number|boolean|null} T\n * @param {unknown} input\n * @param {T} literal\n * @param {string} context\n * @returns {T}\n */\nexport const readLiteral = (input, literal, context) =>\n  input === literal\n    ? literal\n    : ParseError.throw(\n        `Expected ${context} to be a ${JSON.stringify(\n          literal\n        )} instead got ${JSON.stringify(input)}`\n      )\n\nexport class ParseError extends TypeError {\n  get name() {\n    return \"ParseError\"\n  }\n  /**\n   * @param {string} message\n   * @returns {never}\n   */\n  static throw(message) {\n    throw new this(message)\n  }\n}\n\n/**\n * @param {string} reason\n */\nexport const fail = reason => ParseError.throw(reason)\n\nexport { fail as throw }\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 577, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/dag-ucan/src/formatter.js"],"sourcesContent":["import * as UCAN from \"./ucan.js\"\nimport * as DID from \"./did.js\"\nimport * as json from \"@ipld/dag-json\"\nimport { base64url } from \"multiformats/bases/base64\"\nimport * as Signature from \"./signature.js\"\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.Model<C>} model\n * @returns {UCAN.JWT<C>}\n */\nexport const format = model => {\n  const header = formatHeader(model.v, model.s.algorithm)\n  const payload = formatPayload(model)\n  const signature = formatSignature(model.s)\n  return /** @type {UCAN.JWT<C>} */ (`${header}.${payload}.${signature}`)\n}\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.Payload<C>} payload\n * @param {UCAN.Version} version\n * @param {string} alg\n */\nexport const formatSignPayload = (payload, version, alg) =>\n  `${formatHeader(version, alg)}.${formatPayload(payload)}`\n\n/**\n * @param {UCAN.Version} version\n * @param {string} alg\n */\nexport const formatHeader = (version, alg) =>\n  base64url.baseEncode(encodeHeader(version, alg))\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.Payload<C>} data\n */\nexport const formatPayload = data => base64url.baseEncode(encodePayload(data))\n\n/**\n * @param {UCAN.Signature<string>} signature\n */\nexport const formatSignature = signature => base64url.baseEncode(signature.raw)\n\n/**\n * @param {UCAN.Version} v\n * @param {string} alg\n * @returns {UCAN.ByteView<UCAN.JWTHeader>}\n */\nconst encodeHeader = (v, alg) =>\n  json.encode({\n    alg,\n    ucv: v,\n    typ: \"JWT\",\n  })\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.Payload<C>} data\n * @returns {UCAN.ByteView<UCAN.JWTPayload<C>>}\n */\nconst encodePayload = data =>\n  json.encode({\n    iss: DID.format(data.iss),\n    aud: DID.format(data.aud),\n    att: data.att,\n    exp: data.exp,\n    prf: data.prf.map(encodeProof),\n    // leave out optionals and empty fields\n    ...(data.fct.length > 0 && { fct: data.fct }),\n    ...(data.nnc && { nnc: data.nnc }),\n    ...(data.nbf && { nbf: data.nbf }),\n  })\n\n/**\n * @param {UCAN.Link} proof\n * @returns {UCAN.ToString<UCAN.Link>}\n */\nconst encodeProof = proof =>\n  /** @type {UCAN.ToString<UCAN.Link>} */ (proof.toString())\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAOO,MAAM,SAAS,CAAA;IACpB,MAAM,SAAS,aAAa,MAAM,CAAC,EAAE,MAAM,CAAC,CAAC,SAAS;IACtD,MAAM,UAAU,cAAc;IAC9B,MAAM,YAAY,gBAAgB,MAAM,CAAC;IACzC,OAAmC,GAAG,OAAO,CAAC,EAAE,QAAQ,CAAC,EAAE,WAAW;AACxE;AAQO,MAAM,oBAAoB,CAAC,SAAS,SAAS,MAClD,GAAG,aAAa,SAAS,KAAK,CAAC,EAAE,cAAc,UAAU;AAMpD,MAAM,eAAe,CAAC,SAAS,MACpC,6KAAS,CAAC,UAAU,CAAC,aAAa,SAAS;AAMtC,MAAM,gBAAgB,CAAA,OAAQ,6KAAS,CAAC,UAAU,CAAC,cAAc;AAKjE,MAAM,kBAAkB,CAAA,YAAa,6KAAS,CAAC,UAAU,CAAC,UAAU,GAAG;AAE9E;;;;CAIC,GACD,MAAM,eAAe,CAAC,GAAG,MACvB,iKAAW,CAAC;QACV;QACA,KAAK;QACL,KAAK;IACP;AAEF;;;;CAIC,GACD,MAAM,gBAAgB,CAAA,OACpB,iKAAW,CAAC;QACV,KAAK,+JAAU,CAAC,KAAK,GAAG;QACxB,KAAK,+JAAU,CAAC,KAAK,GAAG;QACxB,KAAK,KAAK,GAAG;QACb,KAAK,KAAK,GAAG;QACb,KAAK,KAAK,GAAG,CAAC,GAAG,CAAC;QAClB,uCAAuC;QACvC,GAAI,KAAK,GAAG,CAAC,MAAM,GAAG,KAAK;YAAE,KAAK,KAAK,GAAG;QAAC,CAAC;QAC5C,GAAI,KAAK,GAAG,IAAI;YAAE,KAAK,KAAK,GAAG;QAAC,CAAC;QACjC,GAAI,KAAK,GAAG,IAAI;YAAE,KAAK,KAAK,GAAG;QAAC,CAAC;IACnC;AAEF;;;CAGC,GACD,MAAM,cAAc,CAAA,QACuB,MAAM,QAAQ","ignoreList":[0]}},
    {"offset": {"line": 647, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/dag-ucan/src/view.js"],"sourcesContent":["import * as UCAN from \"./ucan.js\"\nimport * as DID from \"./did.js\"\nimport { encode as encodeJSON } from \"@ipld/dag-json\"\nimport { decode as decodeUTF8 } from \"./utf8.js\"\n\n/**\n * @param {unknown} data\n */\nconst toJSON = data => JSON.parse(decodeUTF8(encodeJSON(data)))\n\n/**\n * @template {UCAN.Capabilities} C\n */\nexport class View {\n  /**\n   * @param {UCAN.UCAN<C>} model\n   */\n  constructor(model) {\n    /** @readonly */\n    this.model = model\n  }\n\n  get version() {\n    return this.model.v\n  }\n\n  get issuer() {\n    return DID.from(this.model.iss)\n  }\n\n  get audience() {\n    return DID.from(this.model.aud)\n  }\n\n  /**\n   * @returns {C}\n   */\n  get capabilities() {\n    return this.model.att\n  }\n\n  /**\n   * @returns {number}\n   */\n  get expiration() {\n    const { exp } = this.model\n    return exp === null ? Infinity : exp\n  }\n\n  /**\n   * @returns {undefined|number}\n   */\n  get notBefore() {\n    return this.model.nbf\n  }\n\n  /**\n   * @returns {undefined|string}\n   */\n\n  get nonce() {\n    return this.model.nnc\n  }\n\n  /**\n   * @returns {UCAN.Fact[]}\n   */\n  get facts() {\n    return this.model.fct\n  }\n\n  /**\n   * @returns {UCAN.Link[]}\n   */\n\n  get proofs() {\n    return this.model.prf\n  }\n\n  get signature() {\n    return this.model.s\n  }\n\n  // compatibility with UCAN.UCAN\n  get jwt() {\n    return this.model.jwt\n  }\n  get s() {\n    return this.model.s\n  }\n  get v() {\n    return this.model.v\n  }\n  get iss() {\n    return this.model.iss\n  }\n  get aud() {\n    return this.model.aud\n  }\n  get att() {\n    return this.model.att\n  }\n  get exp() {\n    return this.model.exp\n  }\n  get nbf() {\n    return this.model.nbf\n  }\n  get nnc() {\n    return this.model.nnc\n  }\n  get fct() {\n    return this.model.fct\n  }\n  get prf() {\n    return this.model.prf\n  }\n\n  /**\n   * @returns {UCAN.ToJSON<UCAN.UCAN<C>, UCAN.UCANJSON<this>>}\n   */\n  toJSON() {\n    const { v, iss, aud, s, att, prf, exp, fct, nnc, nbf } = this.model\n\n    return {\n      iss,\n      aud,\n      v,\n      s,\n      exp,\n      ...toJSON({\n        att,\n        prf,\n        ...(fct.length > 0 && { fct }),\n      }),\n      ...(nnc != null && { nnc }),\n      ...(nbf && { nbf }),\n    }\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEA;;CAEC,GACD,MAAM,SAAS,CAAA,OAAQ,KAAK,KAAK,CAAC,IAAA,gKAAU,EAAC,IAAA,iKAAU,EAAC;AAKjD,MAAM;IACX;;GAEC,GACD,YAAY,KAAK,CAAE;QACjB,cAAc,GACd,IAAI,CAAC,KAAK,GAAG;IACf;IAEA,IAAI,UAAU;QACZ,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC;IACrB;IAEA,IAAI,SAAS;QACX,OAAO,6JAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG;IAChC;IAEA,IAAI,WAAW;QACb,OAAO,6JAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG;IAChC;IAEA;;GAEC,GACD,IAAI,eAAe;QACjB,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG;IACvB;IAEA;;GAEC,GACD,IAAI,aAAa;QACf,MAAM,EAAE,GAAG,EAAE,GAAG,IAAI,CAAC,KAAK;QAC1B,OAAO,QAAQ,OAAO,WAAW;IACnC;IAEA;;GAEC,GACD,IAAI,YAAY;QACd,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG;IACvB;IAEA;;GAEC,GAED,IAAI,QAAQ;QACV,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG;IACvB;IAEA;;GAEC,GACD,IAAI,QAAQ;QACV,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG;IACvB;IAEA;;GAEC,GAED,IAAI,SAAS;QACX,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG;IACvB;IAEA,IAAI,YAAY;QACd,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC;IACrB;IAEA,+BAA+B;IAC/B,IAAI,MAAM;QACR,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG;IACvB;IACA,IAAI,IAAI;QACN,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC;IACrB;IACA,IAAI,IAAI;QACN,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC;IACrB;IACA,IAAI,MAAM;QACR,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG;IACvB;IACA,IAAI,MAAM;QACR,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG;IACvB;IACA,IAAI,MAAM;QACR,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG;IACvB;IACA,IAAI,MAAM;QACR,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG;IACvB;IACA,IAAI,MAAM;QACR,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG;IACvB;IACA,IAAI,MAAM;QACR,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG;IACvB;IACA,IAAI,MAAM;QACR,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG;IACvB;IACA,IAAI,MAAM;QACR,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG;IACvB;IAEA;;GAEC,GACD,SAAS;QACP,MAAM,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,CAAC,KAAK;QAEnE,OAAO;YACL;YACA;YACA;YACA;YACA;YACA,GAAG,OAAO;gBACR;gBACA;gBACA,GAAI,IAAI,MAAM,GAAG,KAAK;oBAAE;gBAAI,CAAC;YAC/B,EAAE;YACF,GAAI,OAAO,QAAQ;gBAAE;YAAI,CAAC;YAC1B,GAAI,OAAO;gBAAE;YAAI,CAAC;QACpB;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 775, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/dag-ucan/src/codec/cbor.js"],"sourcesContent":["import * as UCAN from \"../ucan.js\"\nimport * as CBOR from \"@ipld/dag-cbor\"\nimport { readPayload, readVersion, readSignature } from \"../schema.js\"\nimport { format } from \"../formatter.js\"\nimport * as Signature from \"../signature.js\"\nimport { View } from \"../view.js\"\n\nexport const name = \"dag-ucan\"\nexport const code = CBOR.code\n\n/**\n * Creates a UCAN view from the underlying data model. Please note that this\n * function does no verification of the model and it is callers responsibility\n * to ensure that:\n *\n * 1. Data model is correct contains all the field etc...\n * 2. Payload of the signature will match paylodad when model is serialized\n *    with DAG-JSON.\n *\n * In other words you should never use this function unless you've parsed or\n * decoded a valid UCAN and want to wrap it into a view.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.FromModel<C>} model\n * @returns {UCAN.View<C>}\n */\nexport const from = model => new CBORView(model)\n\n/**\n * Encodes given UCAN (in either IPLD or JWT representation) and encodes it into\n * corresponding bytes representation. UCAN in IPLD representation is encoded as\n * DAG-CBOR which JWT representation is encoded as raw bytes of JWT string.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.Model<C>} model\n * @returns {UCAN.ByteView<UCAN.Model<C>>}\n */\nexport const encode = model => {\n  const { fct, nnc, nbf, ...payload } = readPayload(model)\n\n  return /** @type {Uint8Array} */ (\n    CBOR.encode({\n      // leave out optionals unless they are set\n      ...(fct.length > 0 && { fct }),\n      ...(nnc != null && { nnc }),\n      ...(nbf && { nbf }),\n      ...payload,\n      // add version and signature\n      v: readVersion(model.v, \"v\"),\n      s: encodeSignature(model.s, \"s\"),\n    })\n  )\n}\n\n/**\n * @param {UCAN.Signature} signature\n * @param {string} context\n */\nconst encodeSignature = (signature, context) => {\n  try {\n    return Signature.encode(signature)\n  } catch (cause) {\n    throw new Error(\n      `Expected signature ${context}, instead got ${JSON.stringify(signature)}`,\n      // @ts-expect-error - types don't know about second arg\n      { cause }\n    )\n  }\n}\n\n/**\n * Decodes UCAN in primary CBOR representation. It does not validate UCAN, it's\n * signature or proof chain. This is to say decoded UCAN may be invalid.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.ByteView<UCAN.Model<C>>} bytes\n * @returns {UCAN.View<C>}\n */\nexport const decode = bytes => {\n  const model = CBOR.decode(bytes)\n  return new CBORView({\n    ...readPayload(model),\n    v: readVersion(model.v, \"v\"),\n    s: readSignature(model.s),\n  })\n}\n\nexport { format }\n\n/**\n * @template {UCAN.Capabilities} C\n * @extends {View<C>}\n */\nclass CBORView extends View {\n  /** @type {UCAN.MulticodecCode<typeof code, \"CBOR\">} */\n  get code() {\n    return code\n  }\n  format() {\n    return format(this.model)\n  }\n  encode() {\n    return encode(this.model)\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAEO,MAAM,OAAO;AACb,MAAM,OAAO,+JAAS;AAkBtB,MAAM,OAAO,CAAA,QAAS,IAAI,SAAS;AAWnC,MAAM,SAAS,CAAA;IACpB,MAAM,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,SAAS,GAAG,IAAA,uKAAW,EAAC;IAElD,OACE,iKAAW,CAAC;QACV,0CAA0C;QAC1C,GAAI,IAAI,MAAM,GAAG,KAAK;YAAE;QAAI,CAAC;QAC7B,GAAI,OAAO,QAAQ;YAAE;QAAI,CAAC;QAC1B,GAAI,OAAO;YAAE;QAAI,CAAC;QAClB,GAAG,OAAO;QACV,4BAA4B;QAC5B,GAAG,IAAA,uKAAW,EAAC,MAAM,CAAC,EAAE;QACxB,GAAG,gBAAgB,MAAM,CAAC,EAAE;IAC9B;AAEJ;AAEA;;;CAGC,GACD,MAAM,kBAAkB,CAAC,WAAW;IAClC,IAAI;QACF,OAAO,qKAAgB,CAAC;IAC1B,EAAE,OAAO,OAAO;QACd,MAAM,IAAI,MACR,CAAC,mBAAmB,EAAE,QAAQ,cAAc,EAAE,KAAK,SAAS,CAAC,YAAY,EACzE,uDAAuD;QACvD;YAAE;QAAM;IAEZ;AACF;AAUO,MAAM,SAAS,CAAA;IACpB,MAAM,QAAQ,iKAAW,CAAC;IAC1B,OAAO,IAAI,SAAS;QAClB,GAAG,IAAA,uKAAW,EAAC,MAAM;QACrB,GAAG,IAAA,uKAAW,EAAC,MAAM,CAAC,EAAE;QACxB,GAAG,IAAA,yKAAa,EAAC,MAAM,CAAC;IAC1B;AACF;;AAIA;;;CAGC,GACD,MAAM,iBAAiB,8JAAI;IACzB,qDAAqD,GACrD,IAAI,OAAO;QACT,OAAO;IACT;IACA,SAAS;QACP,OAAO,IAAA,qKAAM,EAAC,IAAI,CAAC,KAAK;IAC1B;IACA,SAAS;QACP,OAAO,OAAO,IAAI,CAAC,KAAK;IAC1B;AACF","ignoreList":[0]}},
    {"offset": {"line": 861, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/dag-ucan/src/parser.js"],"sourcesContent":["import * as UCAN from \"./ucan.js\"\nimport * as json from \"@ipld/dag-json\"\nimport * as Schema from \"./schema.js\"\nimport { base64url } from \"multiformats/bases/base64\"\nimport { createNamed as createSignature } from \"./signature.js\"\n\n/**\n * Parse JWT formatted UCAN. Note than no validation takes place here.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.JWT<C>|string} jwt\n * @returns {UCAN.Model<C>}\n */\nexport const parse = jwt => {\n  const segments = jwt.split(\".\")\n  const [header, payload, signature] =\n    segments.length === 3\n      ? segments\n      : Schema.throw(\n          `Can't parse UCAN: ${jwt}: Expected JWT format: 3 dot-separated base64url-encoded values.`\n        )\n\n  const { ucv, alg } = parseHeader(header)\n\n  return {\n    ...parsePayload(payload),\n    v: ucv,\n    s: createSignature(alg, base64url.baseDecode(signature)),\n  }\n}\n\n/**\n * @param {string} header\n */\nexport const parseHeader = header => {\n  const { ucv, alg, typ } = json.decode(base64url.baseDecode(header))\n\n  return {\n    typ: Schema.readLiteral(typ, \"JWT\", \"typ\"),\n    ucv: Schema.readVersion(ucv, \"ucv\"),\n    alg: Schema.readString(alg, \"alg\"),\n  }\n}\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {string} source\n * @returns {UCAN.Payload<C>}\n */\nexport const parsePayload = source => {\n  /** @type {Record<string, unknown>} */\n  const payload = json.decode(base64url.baseDecode(source))\n  return Schema.readJWTPayload(payload)\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AASO,MAAM,QAAQ,CAAA;IACnB,MAAM,WAAW,IAAI,KAAK,CAAC;IAC3B,MAAM,CAAC,QAAQ,SAAS,UAAU,GAChC,SAAS,MAAM,KAAK,IAChB,WACA,iKAAY,CACV,CAAC,kBAAkB,EAAE,IAAI,gEAAgE,CAAC;IAGlG,MAAM,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,YAAY;IAEjC,OAAO;QACL,GAAG,aAAa,QAAQ;QACxB,GAAG;QACH,GAAG,IAAA,0KAAe,EAAC,KAAK,6KAAS,CAAC,UAAU,CAAC;IAC/C;AACF;AAKO,MAAM,cAAc,CAAA;IACzB,MAAM,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,iKAAW,CAAC,6KAAS,CAAC,UAAU,CAAC;IAE3D,OAAO;QACL,KAAK,uKAAkB,CAAC,KAAK,OAAO;QACpC,KAAK,uKAAkB,CAAC,KAAK;QAC7B,KAAK,sKAAiB,CAAC,KAAK;IAC9B;AACF;AAOO,MAAM,eAAe,CAAA;IAC1B,oCAAoC,GACpC,MAAM,UAAU,iKAAW,CAAC,6KAAS,CAAC,UAAU,CAAC;IACjD,OAAO,0KAAqB,CAAC;AAC/B","ignoreList":[0]}},
    {"offset": {"line": 905, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/dag-ucan/src/codec/jwt.js"],"sourcesContent":["import * as UCAN from \"../ucan.js\"\nimport * as UTF8 from \"../utf8.js\"\nimport { parse } from \"../parser.js\"\nimport { code } from \"multiformats/codecs/raw\"\nimport { View } from \"../view.js\"\n\nexport { code }\nexport const name = \"dag-ucan\"\n\n/**\n * Creates a UCAN view from the underlying data model. Please note that this\n * function does no verification of the model and it is callers responsibility\n * to ensure that:\n *\n * 1. Data model is correct contains all the field etc...\n * 2. Payload of the signature will match paylodad when model is serialized\n *    with DAG-JSON.\n *\n * In other words you should never use this function unless you've parsed or\n * decoded a valid UCAN and want to wrap it into a view.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.FromJWT<C>} model\n * @returns {UCAN.View<C>}\n */\nexport const from = model => new JWTView(model)\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.ByteView<UCAN.FromJWT<C>>} bytes\n * @returns {UCAN.View<C>}\n */\nexport const decode = bytes => {\n  const jwt = /** @type {UCAN.JWT<C>} */ (UTF8.decode(bytes))\n\n  return new JWTView({ ...parse(jwt), jwt })\n}\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.FromJWT<C>} model\n * @returns {UCAN.ByteView<UCAN.UCAN<C>>}\n */\nexport const encode = ({ jwt }) => UTF8.encode(jwt)\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.FromJWT<C>} model\n * @returns {UCAN.JWT<C>}\n */\nexport const format = ({ jwt }) => jwt\n\n/**\n * @template {UCAN.Capabilities} C\n * @extends {View<C>}\n */\nclass JWTView extends View {\n  /**\n   * @param {UCAN.FromJWT<C>} model\n   */\n  constructor(model) {\n    super(model)\n    this.model = model\n  }\n  /** @type {UCAN.MulticodecCode<typeof code, \"Raw\">} */\n  get code() {\n    return code\n  }\n  format() {\n    return format(this.model)\n  }\n  encode() {\n    return encode(this.model)\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;;;;;;;AAGO,MAAM,OAAO;AAkBb,MAAM,OAAO,CAAA,QAAS,IAAI,QAAQ;AAOlC,MAAM,SAAS,CAAA;IACpB,MAAM,MAAkC,gKAAW,CAAC;IAEpD,OAAO,IAAI,QAAQ;QAAE,GAAG,IAAA,iKAAK,EAAC,IAAI;QAAE;IAAI;AAC1C;AAOO,MAAM,SAAS,CAAC,EAAE,GAAG,EAAE,GAAK,gKAAW,CAAC;AAOxC,MAAM,SAAS,CAAC,EAAE,GAAG,EAAE,GAAK;AAEnC;;;CAGC,GACD,MAAM,gBAAgB,8JAAI;IACxB;;GAEC,GACD,YAAY,KAAK,CAAE;QACjB,KAAK,CAAC;QACN,IAAI,CAAC,KAAK,GAAG;IACf;IACA,oDAAoD,GACpD,IAAI,OAAO;QACT,OAAO,sKAAI;IACb;IACA,SAAS;QACP,OAAO,OAAO,IAAI,CAAC,KAAK;IAC1B;IACA,SAAS;QACP,OAAO,OAAO,IAAI,CAAC,KAAK;IAC1B;AACF","ignoreList":[0]}},
    {"offset": {"line": 963, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/dag-ucan/src/lib.js"],"sourcesContent":["import * as UCAN from \"./ucan.js\"\nimport * as CBOR from \"./codec/cbor.js\"\nimport * as JWT from \"./codec/jwt.js\"\nimport * as UTF8 from \"./utf8.js\"\nimport { readPayload } from \"./schema.js\"\nimport { parse as parseDID } from \"./did.js\"\nimport { parse as parseJWT } from \"./parser.js\"\nimport { formatSignPayload } from \"./formatter.js\"\nimport { sha256 } from \"multiformats/hashes/sha2\"\nimport { create as createLink } from \"multiformats/link\"\nimport { format as formatDID } from \"./did.js\"\n\nexport * from \"./ucan.js\"\n\nexport const VERSION = \"0.9.1\"\nexport const name = \"dag-ucan\"\nexport const code = /** @type {UCAN.Code} */ (CBOR.code)\n\n/**\n * We cast sha256 to workaround typescripts limited inference problem when using\n * sha256 as default. If hasher is omitted type `A` should match sha256.code\n * but TS fails to deduce that.\n * @type {UCAN.MultihashHasher<any>}\n */\nconst defaultHasher = sha256\n\n/**\n * Encodes given UCAN (in either IPLD or JWT representation) and encodes it into\n * corresponding bytes representation. UCAN in IPLD representation is encoded as\n * DAG-CBOR which JWT representation is encoded as raw bytes of JWT string.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.UCAN<C>} ucan\n * @returns {UCAN.ByteView<UCAN.UCAN<C>>}\n */\nexport const encode = ucan => (ucan.jwt ? JWT.encode(ucan) : CBOR.encode(ucan))\n\n/**\n * Decodes binary encoded UCAN. It assumes UCAN is in primary IPLD\n * representation and attempts to decode it with DAG-CBOR, if that\n * fails it falls back to secondary representation and parses it as\n * a JWT.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.ByteView<UCAN.UCAN<C>>} bytes\n * @returns {UCAN.View<C>}\n */\nexport const decode = bytes => {\n  try {\n    return CBOR.decode(bytes)\n  } catch (_) {\n    return JWT.decode(/** @type {UCAN.ByteView<UCAN.FromJWT<C>>} */ (bytes))\n  }\n}\n\n/**\n * Convenience function to create a CID for the given UCAN. If UCAN is\n * in JWT representation get CID with RAW multicodec, while UCANs in IPLD\n * representation get UCAN multicodec code.\n *\n * @template {UCAN.Capabilities} C\n * @template {number} [A=typeof sha256.code] - Multihash code\n * @param {UCAN.View<C>} ucan\n * @param {{hasher?: UCAN.MultihashHasher<A>}} [options]\n */\nexport const link = async (ucan, options) => {\n  const { cid } = await write(ucan, options)\n  return cid\n}\n\n/**\n * @template {UCAN.Capabilities} C\n * @template {number} [A=typeof sha256.code] - Multihash code\n * @param {UCAN.UCAN<C>} ucan\n * @param {{hasher?: UCAN.MultihashHasher<A>}} options\n * @returns {Promise<UCAN.Block<C, UCAN.Code, A>>}\n */\nexport const write = async (ucan, { hasher = defaultHasher } = {}) => {\n  const [code, bytes] = ucan.jwt\n    ? [/** @type {UCAN.Code} */ (JWT.code), JWT.encode(ucan)]\n    : [/** @type {UCAN.Code} */ (CBOR.code), CBOR.encode(ucan)]\n  const digest = await hasher.digest(bytes)\n\n  return {\n    bytes,\n    cid: createLink(code, digest),\n    data: ucan,\n  }\n}\n\n/**\n * Parses UCAN formatted as JWT string. Returns UCAN view in IPLD representation\n * when serializing it back would produce original string, otherwise returns UCAN\n * view in secondary JWT representation which is not as compact, but it retains\n * key order and whitespaces so it could be formatted back to same JWT string.\n * View will have `type` field with either `\"IPLD\"` or `\"JWT\"` value telling\n * in which representation UCAN is.\n *\n * Note: Parsing does not perform validation of capabilities or semantics of the\n * UCAN, it only ensures structure is spec compliant and throws `ParseError`\n * if it is not.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.JWT<C>|string} jwt\n * @returns {UCAN.View<C>}\n */\nexport const parse = jwt => {\n  const model = parseJWT(jwt)\n\n  // If formatting UCAN produces same jwt string we can use IPLD representation\n  // otherwise we need to fallback to raw representation. This decision will\n  // affect how we `encode` the UCAN.\n  return CBOR.format(model) === jwt\n    ? CBOR.from(model)\n    : JWT.from({ ...model, jwt: /** @type {UCAN.JWT<C>} */ (jwt) })\n}\n\n/**\n * Takes UCAN object and formats it into JWT string.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.UCAN<C>} ucan\n * @returns {UCAN.JWT<C>}\n */\nexport const format = ucan => (ucan.jwt ? JWT.format(ucan) : CBOR.format(ucan))\n\n/**\n * Creates a new signed token with a given `options.issuer`. If expiration is\n * not set it defaults to 30 seconds from now. Returns UCAN in primary - IPLD\n * representation.\n *\n * @template {number} A\n * @template {UCAN.Capabilities} C\n * @param {UCAN.UCANOptions<C, A>} options\n * @returns {Promise<UCAN.View<C>>}\n */\nexport const issue = async ({\n  issuer,\n  audience,\n  capabilities,\n  lifetimeInSeconds = 30,\n  expiration = now() + lifetimeInSeconds,\n  notBefore,\n  facts = [],\n  proofs = [],\n  nonce,\n}) => {\n  const v = VERSION\n  const data = readPayload({\n    iss: parseDID(issuer.did()),\n    aud: parseDID(audience.did()),\n    att: capabilities,\n    fct: facts,\n    exp: expiration,\n    nbf: notBefore,\n    prf: proofs,\n    nnc: nonce,\n  })\n  const payload = encodeSignaturePayload(data, v, issuer.signatureAlgorithm)\n\n  return CBOR.from({\n    ...data,\n    v,\n    s: await issuer.sign(payload),\n  })\n}\n\n/**\n *\n * @param {UCAN.Payload} payload\n * @param {UCAN.Version} version\n * @param {string} algorithm\n * @returns\n */\nconst encodeSignaturePayload = (payload, version, algorithm) =>\n  UTF8.encode(formatSignPayload(payload, version, algorithm))\n\n/**\n * Verifies UCAN signature.\n *\n * @param {UCAN.View} ucan\n * @param {UCAN.Verifier} verifier\n */\nexport const verifySignature = (ucan, verifier) =>\n  formatDID(ucan.issuer) === verifier.did() &&\n  verifier.verify(\n    encodeSignaturePayload(ucan.model, ucan.model.v, ucan.signature.algorithm),\n    ucan.signature\n  )\n\n/**\n * Check if a UCAN is expired.\n *\n * @param {UCAN.View} ucan\n */\nexport const isExpired = ucan => ucan.expiration <= now()\n\n/**\n * Check if a UCAN is not active yet.\n * @param {UCAN.View} ucan\n */\nexport const isTooEarly = ucan =>\n  ucan.notBefore != null && now() <= ucan.notBefore\n\n/**\n * Returns UTC Unix timestamp for comparing it against time window of the UCAN.\n */\nexport const now = () => Math.floor(Date.now() / 1000)\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;AAKO,MAAM,UAAU;AAChB,MAAM,OAAO;AACb,MAAM,OAAiC,uLAAS;AAEvD;;;;;CAKC,GACD,MAAM,gBAAgB,yKAAM;AAWrB,MAAM,SAAS,CAAA,OAAS,KAAK,GAAG,GAAG,wLAAU,CAAC,QAAQ,yLAAW,CAAC;AAYlE,MAAM,SAAS,CAAA;IACpB,IAAI;QACF,OAAO,yLAAW,CAAC;IACrB,EAAE,OAAO,GAAG;QACV,OAAO,wLAAU,CAAgD;IACnE;AACF;AAYO,MAAM,OAAO,OAAO,MAAM;IAC/B,MAAM,EAAE,GAAG,EAAE,GAAG,MAAM,MAAM,MAAM;IAClC,OAAO;AACT;AASO,MAAM,QAAQ,OAAO,MAAM,EAAE,SAAS,aAAa,EAAE,GAAG,CAAC,CAAC;IAC/D,MAAM,CAAC,MAAM,MAAM,GAAG,KAAK,GAAG,GAC1B;QAA2B,sKAAQ;QAAG,wLAAU,CAAC;KAAM,GACvD;QAA2B,uLAAS;QAAG,yLAAW,CAAC;KAAM;IAC7D,MAAM,SAAS,MAAM,OAAO,MAAM,CAAC;IAEnC,OAAO;QACL;QACA,KAAK,IAAA,+KAAU,EAAC,MAAM;QACtB,MAAM;IACR;AACF;AAkBO,MAAM,QAAQ,CAAA;IACnB,MAAM,QAAQ,IAAA,iKAAQ,EAAC;IAEvB,6EAA6E;IAC7E,0EAA0E;IAC1E,mCAAmC;IACnC,OAAO,qKAAW,CAAC,WAAW,MAC1B,uLAAS,CAAC,SACV,sLAAQ,CAAC;QAAE,GAAG,KAAK;QAAE,KAAiC;IAAK;AACjE;AASO,MAAM,SAAS,CAAA,OAAS,KAAK,GAAG,GAAG,wLAAU,CAAC,QAAQ,qKAAW,CAAC;AAYlE,MAAM,QAAQ,OAAO,EAC1B,MAAM,EACN,QAAQ,EACR,YAAY,EACZ,oBAAoB,EAAE,EACtB,aAAa,QAAQ,iBAAiB,EACtC,SAAS,EACT,QAAQ,EAAE,EACV,SAAS,EAAE,EACX,KAAK,EACN;IACC,MAAM,IAAI;IACV,MAAM,OAAO,IAAA,uKAAW,EAAC;QACvB,KAAK,IAAA,8JAAQ,EAAC,OAAO,GAAG;QACxB,KAAK,IAAA,8JAAQ,EAAC,SAAS,GAAG;QAC1B,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;IACP;IACA,MAAM,UAAU,uBAAuB,MAAM,GAAG,OAAO,kBAAkB;IAEzE,OAAO,uLAAS,CAAC;QACf,GAAG,IAAI;QACP;QACA,GAAG,MAAM,OAAO,IAAI,CAAC;IACvB;AACF;AAEA;;;;;;CAMC,GACD,MAAM,yBAAyB,CAAC,SAAS,SAAS,YAChD,gKAAW,CAAC,IAAA,gLAAiB,EAAC,SAAS,SAAS;AAQ3C,MAAM,kBAAkB,CAAC,MAAM,WACpC,IAAA,+JAAS,EAAC,KAAK,MAAM,MAAM,SAAS,GAAG,MACvC,SAAS,MAAM,CACb,uBAAuB,KAAK,KAAK,EAAE,KAAK,KAAK,CAAC,CAAC,EAAE,KAAK,SAAS,CAAC,SAAS,GACzE,KAAK,SAAS;AAQX,MAAM,YAAY,CAAA,OAAQ,KAAK,UAAU,IAAI;AAM7C,MAAM,aAAa,CAAA,OACxB,KAAK,SAAS,IAAI,QAAQ,SAAS,KAAK,SAAS;AAK5C,MAAM,MAAM,IAAM,KAAK,KAAK,CAAC,KAAK,GAAG,KAAK","ignoreList":[0]}},
    {"offset": {"line": 1160, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/dag-cbor/src/index.js"],"sourcesContent":["import * as cborg from 'cborg'\nimport { CID } from 'multiformats/cid'\n\n// https://github.com/ipfs/go-ipfs/issues/3570#issuecomment-273931692\nconst CID_CBOR_TAG = 42\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView\n */\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} buf\n * @returns {ByteView<T>}\n */\nexport function toByteView (buf) {\n  if (buf instanceof ArrayBuffer) {\n    return new Uint8Array(buf, 0, buf.byteLength)\n  }\n\n  return buf\n}\n\n/**\n * cidEncoder will receive all Objects during encode, it needs to filter out\n * anything that's not a CID and return `null` for that so it's encoded as\n * normal.\n *\n * @param {any} obj\n * @returns {cborg.Token[]|null}\n */\nfunction cidEncoder (obj) {\n  if (obj.asCID !== obj && obj['/'] !== obj.bytes) {\n    return null // any other kind of object\n  }\n  const cid = CID.asCID(obj)\n  /* c8 ignore next 4 */\n  // very unlikely case, and it'll probably throw a recursion error in cborg\n  if (!cid) {\n    return null\n  }\n  const bytes = new Uint8Array(cid.bytes.byteLength + 1)\n  bytes.set(cid.bytes, 1) // prefix is 0x00, for historical reasons\n  return [\n    new cborg.Token(cborg.Type.tag, CID_CBOR_TAG),\n    new cborg.Token(cborg.Type.bytes, bytes)\n  ]\n}\n\n// eslint-disable-next-line jsdoc/require-returns-check\n/**\n * Intercept all `undefined` values from an object walk and reject the entire\n * object if we find one.\n *\n * @returns {null}\n */\nfunction undefinedEncoder () {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded')\n}\n\n/**\n * Intercept all `number` values from an object walk and reject the entire\n * object if we find something that doesn't fit the IPLD data model (NaN &\n * Infinity).\n *\n * @param {number} num\n * @returns {null}\n */\nfunction numberEncoder (num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  return null\n}\n\n/**\n * @param {Map<any, any>} map\n * @returns {null}\n */\nfunction mapEncoder (map) {\n  for (const key of map.keys()) {\n    if (typeof key !== 'string' || key.length === 0) {\n      throw new Error('Non-string Map keys are not supported by the IPLD Data Model and cannot be encoded')\n    }\n  }\n  return null\n}\n\nconst _encodeOptions = {\n  float64: true,\n  typeEncoders: {\n    Map: mapEncoder,\n    Object: cidEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n}\n\nexport const encodeOptions = {\n  ..._encodeOptions,\n  typeEncoders: {\n    ..._encodeOptions.typeEncoders\n  }\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {CID}\n */\nfunction cidDecoder (bytes) {\n  if (bytes[0] !== 0) {\n    throw new Error('Invalid CID for CBOR tag 42; expected leading 0x00')\n  }\n  return CID.decode(bytes.subarray(1)) // ignore leading 0x00\n}\n\nconst _decodeOptions = {\n  allowIndefinite: false,\n  coerceUndefinedToNull: true,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true, // this will lead to BigInt for ints outside of\n  // safe-integer range, which may surprise users\n  strict: true,\n  useMaps: false,\n  rejectDuplicateMapKeys: true,\n  /** @type {import('cborg').TagDecoder[]} */\n  tags: []\n}\n_decodeOptions.tags[CID_CBOR_TAG] = cidDecoder\n\nexport const decodeOptions = {\n  ..._decodeOptions,\n  tags: _decodeOptions.tags.slice()\n}\n\nexport const name = 'dag-cbor'\nexport const code = 0x71\n\n/**\n * @template T\n * @param {T} node\n * @returns {ByteView<T>}\n */\nexport const encode = (node) => cborg.encode(node, _encodeOptions)\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} data\n * @returns {T}\n */\nexport const decode = (data) => cborg.decode(toByteView(data), _decodeOptions)\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AACA;;;AAEA,qEAAqE;AACrE,MAAM,eAAe;AAiBd,SAAS,WAAY,GAAG;IAC7B,IAAI,eAAe,aAAa;QAC9B,OAAO,IAAI,WAAW,KAAK,GAAG,IAAI,UAAU;IAC9C;IAEA,OAAO;AACT;AAEA;;;;;;;CAOC,GACD,SAAS,WAAY,GAAG;IACtB,IAAI,IAAI,KAAK,KAAK,OAAO,GAAG,CAAC,IAAI,KAAK,IAAI,KAAK,EAAE;QAC/C,OAAO,KAAK,2BAA2B;;IACzC;IACA,MAAM,MAAM,2KAAG,CAAC,KAAK,CAAC;IACtB,oBAAoB,GACpB,0EAA0E;IAC1E,IAAI,CAAC,KAAK;QACR,OAAO;IACT;IACA,MAAM,QAAQ,IAAI,WAAW,IAAI,KAAK,CAAC,UAAU,GAAG;IACpD,MAAM,GAAG,CAAC,IAAI,KAAK,EAAE,IAAG,yCAAyC;IACjE,OAAO;QACL,IAAI,gJAAW,CAAC,+IAAU,CAAC,GAAG,EAAE;QAChC,IAAI,gJAAW,CAAC,+IAAU,CAAC,KAAK,EAAE;KACnC;AACH;AAEA,uDAAuD;AACvD;;;;;CAKC,GACD,SAAS;IACP,MAAM,IAAI,MAAM;AAClB;AAEA;;;;;;;CAOC,GACD,SAAS,cAAe,GAAG;IACzB,IAAI,OAAO,KAAK,CAAC,MAAM;QACrB,MAAM,IAAI,MAAM;IAClB;IACA,IAAI,QAAQ,YAAY,QAAQ,CAAC,UAAU;QACzC,MAAM,IAAI,MAAM;IAClB;IACA,OAAO;AACT;AAEA;;;CAGC,GACD,SAAS,WAAY,GAAG;IACtB,KAAK,MAAM,OAAO,IAAI,IAAI,GAAI;QAC5B,IAAI,OAAO,QAAQ,YAAY,IAAI,MAAM,KAAK,GAAG;YAC/C,MAAM,IAAI,MAAM;QAClB;IACF;IACA,OAAO;AACT;AAEA,MAAM,iBAAiB;IACrB,SAAS;IACT,cAAc;QACZ,KAAK;QACL,QAAQ;QACR,WAAW;QACX,QAAQ;IACV;AACF;AAEO,MAAM,gBAAgB;IAC3B,GAAG,cAAc;IACjB,cAAc;QACZ,GAAG,eAAe,YAAY;IAChC;AACF;AAEA;;;CAGC,GACD,SAAS,WAAY,KAAK;IACxB,IAAI,KAAK,CAAC,EAAE,KAAK,GAAG;QAClB,MAAM,IAAI,MAAM;IAClB;IACA,OAAO,2KAAG,CAAC,MAAM,CAAC,MAAM,QAAQ,CAAC,IAAI,sBAAsB;;AAC7D;AAEA,MAAM,iBAAiB;IACrB,iBAAiB;IACjB,uBAAuB;IACvB,UAAU;IACV,eAAe;IACf,aAAa;IACb,+CAA+C;IAC/C,QAAQ;IACR,SAAS;IACT,wBAAwB;IACxB,yCAAyC,GACzC,MAAM,EAAE;AACV;AACA,eAAe,IAAI,CAAC,aAAa,GAAG;AAE7B,MAAM,gBAAgB;IAC3B,GAAG,cAAc;IACjB,MAAM,eAAe,IAAI,CAAC,KAAK;AACjC;AAEO,MAAM,OAAO;AACb,MAAM,OAAO;AAOb,MAAM,SAAS,CAAC,OAAS,kJAAY,CAAC,MAAM;AAO5C,MAAM,SAAS,CAAC,OAAS,kJAAY,CAAC,WAAW,OAAO","ignoreList":[0]}},
    {"offset": {"line": 1301, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/dag-json/src/index.js"],"sourcesContent":["/* eslint max-depth: [\"error\", 7] */\nimport { Token, Type } from 'cborg'\nimport * as cborgJson from 'cborg/json'\nimport { CID } from 'multiformats'\nimport { base64 } from 'multiformats/bases/base64'\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView\n */\n/**\n * @template T\n * @typedef {import('multiformats').ToString<T>} ToString\n */\n/**\n * @typedef {import('cborg/interface').DecodeTokenizer} DecodeTokenizer\n */\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} buf\n * @returns {ByteView<T>}\n */\nfunction toByteView (buf) {\n  if (buf instanceof ArrayBuffer) {\n    return new Uint8Array(buf, 0, buf.byteLength)\n  }\n\n  return buf\n}\n\n/**\n * cidEncoder will receive all Objects during encode, it needs to filter out\n * anything that's not a CID and return `null` for that so it's encoded as\n * normal. Encoding a CID means replacing it with a `{\"/\":\"<CidString>}`\n * object as per the DAG-JSON spec.\n *\n * @param {any} obj\n * @returns {Token[]|null}\n */\nfunction cidEncoder (obj) {\n  if (obj.asCID !== obj && obj['/'] !== obj.bytes) {\n    return null // any other kind of object\n  }\n  const cid = CID.asCID(obj)\n  /* c8 ignore next 4 */\n  // very unlikely case, and it'll probably throw a recursion error in cborg\n  if (!cid) {\n    return null\n  }\n  const cidString = cid.toString()\n\n  return [\n    new Token(Type.map, Infinity, 1),\n    new Token(Type.string, '/', 1), // key\n    new Token(Type.string, cidString, cidString.length), // value\n    new Token(Type.break, undefined, 1)\n  ]\n}\n\n/**\n * bytesEncoder will receive all Uint8Arrays (and friends) during encode, it\n * needs to replace it with a `{\"/\":{\"bytes\":\"Base64ByteString\"}}` object as\n * per the DAG-JSON spec.\n *\n * @param {Uint8Array} bytes\n * @returns {Token[]|null}\n */\nfunction bytesEncoder (bytes) {\n  const bytesString = base64.encode(bytes).slice(1) // no mbase prefix\n  return [\n    new Token(Type.map, Infinity, 1),\n    new Token(Type.string, '/', 1), // key\n    new Token(Type.map, Infinity, 1), // value\n    new Token(Type.string, 'bytes', 5), // inner key\n    new Token(Type.string, bytesString, bytesString.length), // inner value\n    new Token(Type.break, undefined, 1),\n    new Token(Type.break, undefined, 1)\n  ]\n}\n\n/**\n * taBytesEncoder wraps bytesEncoder() but for the more exotic typed arrays so\n * that we access the underlying ArrayBuffer data\n *\n * @param {Int8Array|Uint16Array|Int16Array|Uint32Array|Int32Array|Float32Array|Float64Array|Uint8ClampedArray|BigInt64Array|BigUint64Array} obj\n * @returns {Token[]|null}\n */\nfunction taBytesEncoder (obj) {\n  return bytesEncoder(new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength))\n}\n\n/**\n * abBytesEncoder wraps bytesEncoder() but for plain ArrayBuffers\n *\n * @param {ArrayBuffer} ab\n * @returns {Token[]|null}\n */\nfunction abBytesEncoder (ab) {\n  return bytesEncoder(new Uint8Array(ab))\n}\n\n// eslint-disable-next-line jsdoc/require-returns-check\n/**\n * Intercept all `undefined` values from an object walk and reject the entire\n * object if we find one.\n *\n * @returns {null}\n */\nfunction undefinedEncoder () {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded')\n}\n\n/**\n * Intercept all `number` values from an object walk and reject the entire\n * object if we find something that doesn't fit the IPLD data model (NaN &\n * Infinity).\n *\n * @param {number} num\n * @returns {null}\n */\nfunction numberEncoder (num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  return null // process with standard number encoder\n}\n\nconst encodeOptions = {\n  typeEncoders: {\n    Object: cidEncoder,\n    Buffer: bytesEncoder,\n    Uint8Array: bytesEncoder,\n    Int8Array: taBytesEncoder,\n    Uint16Array: taBytesEncoder,\n    Int16Array: taBytesEncoder,\n    Uint32Array: taBytesEncoder,\n    Int32Array: taBytesEncoder,\n    Float32Array: taBytesEncoder,\n    Float64Array: taBytesEncoder,\n    Uint8ClampedArray: taBytesEncoder,\n    BigInt64Array: taBytesEncoder,\n    BigUint64Array: taBytesEncoder,\n    DataView: taBytesEncoder,\n    ArrayBuffer: abBytesEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n}\n\n/**\n * @implements {DecodeTokenizer}\n */\nclass DagJsonTokenizer extends cborgJson.Tokenizer {\n  /**\n   * @param {Uint8Array} data\n   * @param {object} [options]\n   */\n  constructor (data, options) {\n    super(data, options)\n    /** @type {Token[]} */\n    this.tokenBuffer = []\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  done () {\n    return this.tokenBuffer.length === 0 && super.done()\n  }\n\n  /**\n   * @returns {Token}\n   */\n  _next () {\n    if (this.tokenBuffer.length > 0) {\n      // @ts-ignore https://github.com/Microsoft/TypeScript/issues/30406\n      return this.tokenBuffer.pop()\n    }\n    return super.next()\n  }\n\n  /**\n   * Implements rules outlined in https://github.com/ipld/specs/pull/356\n   *\n   * @returns {Token}\n   */\n  next () {\n    const token = this._next()\n\n    if (token.type === Type.map) {\n      const keyToken = this._next()\n      if (keyToken.type === Type.string && keyToken.value === '/') {\n        const valueToken = this._next()\n        if (valueToken.type === Type.string) { // *must* be a CID\n          const breakToken = this._next() // swallow the end-of-map token\n          if (breakToken.type !== Type.break) {\n            throw new Error('Invalid encoded CID form')\n          }\n          this.tokenBuffer.push(valueToken) // CID.parse will pick this up after our tag token\n          return new Token(Type.tag, 42, 0)\n        }\n        if (valueToken.type === Type.map) {\n          const innerKeyToken = this._next()\n          if (innerKeyToken.type === Type.string && innerKeyToken.value === 'bytes') {\n            const innerValueToken = this._next()\n            if (innerValueToken.type === Type.string) { // *must* be Bytes\n              for (let i = 0; i < 2; i++) {\n                const breakToken = this._next() // swallow two end-of-map tokens\n                if (breakToken.type !== Type.break) {\n                  throw new Error('Invalid encoded Bytes form')\n                }\n              }\n              const bytes = base64.decode(`m${innerValueToken.value}`)\n              return new Token(Type.bytes, bytes, innerValueToken.value.length)\n            }\n            this.tokenBuffer.push(innerValueToken) // bail\n          }\n          this.tokenBuffer.push(innerKeyToken) // bail\n        }\n        this.tokenBuffer.push(valueToken) // bail\n      }\n      this.tokenBuffer.push(keyToken) // bail\n    }\n    return token\n  }\n}\n\nconst decodeOptions = {\n  allowIndefinite: false,\n  allowUndefined: false,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true, // this will lead to BigInt for ints outside of\n  // safe-integer range, which may surprise users\n  strict: true,\n  useMaps: false,\n  rejectDuplicateMapKeys: true,\n  /** @type {import('cborg').TagDecoder[]} */\n  tags: []\n}\n\n// we're going to get TAG(42)STRING(\"bafy...\") from the tokenizer so we only need\n// to deal with the STRING(\"bafy...\") at this point\ndecodeOptions.tags[42] = CID.parse\n\nexport const name = 'dag-json'\nexport const code = 0x0129\n\n/**\n * @template T\n * @param {T} node\n * @returns {ByteView<T>}\n */\nexport const encode = (node) => cborgJson.encode(node, encodeOptions)\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} data\n * @returns {T}\n */\nexport const decode = (data) => {\n  const buf = toByteView(data)\n  // the tokenizer is stateful so we need a single instance of it\n  const options = Object.assign(decodeOptions, { tokenizer: new DagJsonTokenizer(buf, decodeOptions) })\n  return cborgJson.decode(buf, options)\n}\n\n/**\n * @template T\n * @param {T} node\n * @returns {ToString<T>}\n */\nexport const format = (node) => utf8Decoder.decode(encode(node))\nexport { format as stringify }\nconst utf8Decoder = new TextDecoder()\n\n/**\n * @template T\n * @param {ToString<T>} data\n * @returns {T}\n */\nexport const parse = (data) => decode(utf8Encoder.encode(data))\nconst utf8Encoder = new TextEncoder()\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1564, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/car/src/decoder-common.js"],"sourcesContent":["import varint from 'varint'\n\nexport const CIDV0_BYTES = {\n  SHA2_256: 0x12,\n  LENGTH: 0x20,\n  DAG_PB: 0x70\n}\n\nexport const V2_HEADER_LENGTH = /* characteristics */ 16 /* v1 offset */ + 8 /* v1 size */ + 8 /* index offset */ + 8\n\n/**\n * Decodes varint and seeks the buffer\n *\n * ```js\n * // needs bytes to be read first\n * const bytes = reader.upTo(8) // maybe async\n * ```\n *\n * @param {Uint8Array} bytes\n * @param {import('./coding.js').Seekable} seeker\n * @returns {number}\n */\nexport function decodeVarint (bytes, seeker) {\n  if (!bytes.length) {\n    throw new Error('Unexpected end of data')\n  }\n  const i = varint.decode(bytes)\n  seeker.seek(/** @type {number} */(varint.decode.bytes))\n  return i\n}\n\n/**\n * Decode v2 header\n *\n * ```js\n * // needs bytes to be read first\n * const bytes = reader.exactly(V2_HEADER_LENGTH, true) // maybe async\n * ```\n *\n * @param {Uint8Array} bytes\n * @returns {import('./coding.js').CarV2FixedHeader}\n */\nexport function decodeV2Header (bytes) {\n  const dv = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n  let offset = 0\n  const header = {\n    version: 2,\n    /** @type {[bigint, bigint]} */\n    characteristics: [\n      dv.getBigUint64(offset, true),\n      dv.getBigUint64(offset += 8, true)\n    ],\n    dataOffset: Number(dv.getBigUint64(offset += 8, true)),\n    dataSize: Number(dv.getBigUint64(offset += 8, true)),\n    indexOffset: Number(dv.getBigUint64(offset += 8, true))\n  }\n  return header\n}\n\n/**\n * Checks the length of the multihash to be read afterwards\n *\n * ```js\n * // needs bytes to be read first\n * const bytes = reader.upTo(8) // maybe async\n * ```\n *\n * @param {Uint8Array} bytes\n */\nexport function getMultihashLength (bytes) {\n  // | code | length | .... |\n  // where both code and length are varints, so we have to decode\n  // them first before we can know total length\n\n  varint.decode(bytes) // code\n  const codeLength = /** @type {number} */(varint.decode.bytes)\n  const length = varint.decode(bytes.subarray(varint.decode.bytes))\n  const lengthLength = /** @type {number} */(varint.decode.bytes)\n  const mhLength = codeLength + lengthLength + length\n\n  return mhLength\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;;AAEO,MAAM,cAAc;IACzB,UAAU;IACV,QAAQ;IACR,QAAQ;AACV;AAEO,MAAM,mBAAmB,mBAAmB,GAAG,GAAG,aAAa,MAAK,EAAE,WAAW,MAAK,EAAE,gBAAgB,MAAK;AAc7G,SAAS,aAAc,KAAK,EAAE,MAAM;IACzC,IAAI,CAAC,MAAM,MAAM,EAAE;QACjB,MAAM,IAAI,MAAM;IAClB;IACA,MAAM,IAAI,4IAAM,CAAC,MAAM,CAAC;IACxB,OAAO,IAAI,CAAuB,4IAAM,CAAC,MAAM,CAAC,KAAK;IACrD,OAAO;AACT;AAaO,SAAS,eAAgB,KAAK;IACnC,MAAM,KAAK,IAAI,SAAS,MAAM,MAAM,EAAE,MAAM,UAAU,EAAE,MAAM,UAAU;IACxE,IAAI,SAAS;IACb,MAAM,SAAS;QACb,SAAS;QACT,6BAA6B,GAC7B,iBAAiB;YACf,GAAG,YAAY,CAAC,QAAQ;YACxB,GAAG,YAAY,CAAC,UAAU,GAAG;SAC9B;QACD,YAAY,OAAO,GAAG,YAAY,CAAC,UAAU,GAAG;QAChD,UAAU,OAAO,GAAG,YAAY,CAAC,UAAU,GAAG;QAC9C,aAAa,OAAO,GAAG,YAAY,CAAC,UAAU,GAAG;IACnD;IACA,OAAO;AACT;AAYO,SAAS,mBAAoB,KAAK;IACvC,2BAA2B;IAC3B,+DAA+D;IAC/D,6CAA6C;IAE7C,4IAAM,CAAC,MAAM,CAAC,QAAO,OAAO;IAC5B,MAAM,aAAmC,4IAAM,CAAC,MAAM,CAAC,KAAK;IAC5D,MAAM,SAAS,4IAAM,CAAC,MAAM,CAAC,MAAM,QAAQ,CAAC,4IAAM,CAAC,MAAM,CAAC,KAAK;IAC/D,MAAM,eAAqC,4IAAM,CAAC,MAAM,CAAC,KAAK;IAC9D,MAAM,WAAW,aAAa,eAAe;IAE7C,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 1622, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/car/src/header-validator.js"],"sourcesContent":["/* eslint-disable jsdoc/check-indentation, max-depth */\n\n/**\n * Auto-generated with @ipld/schema@v4.2.0 at Thu Sep 14 2023 from IPLD Schema:\n *\n * # CarV1HeaderOrV2Pragma is a more relaxed form, and can parse {version:x} where\n * # roots are optional. This is typically useful for the {verison:2} CARv2\n * # pragma.\n *\n * type CarV1HeaderOrV2Pragma struct {\n *   roots optional [&Any]\n *   # roots is _not_ optional for CarV1 but we defer that check within code to\n *   # gracefully handle the V2 case where it's just {version:X}\n *   version Int\n * }\n *\n * # CarV1Header is the strict form of the header, and requires roots to be\n * # present. This is compatible with the CARv1 specification.\n *\n * # type CarV1Header struct {\n * #   roots [&Any]\n * #   version Int\n * # }\n *\n */\n\nconst Kinds = {\n  Null: /**\n         * @param obj\n         * @returns {undefined|null}\n         */ (/** @type {any} */ obj) => obj === null ? obj : undefined,\n  Int: /**\n        * @param obj\n        * @returns {undefined|number}\n        */ (/** @type {any} */ obj) => Number.isInteger(obj) ? obj : undefined,\n  Float: /**\n          * @param obj\n          * @returns {undefined|number}\n          */ (/** @type {any} */ obj) => typeof obj === 'number' && Number.isFinite(obj) ? obj : undefined,\n  String: /**\n           * @param obj\n           * @returns {undefined|string}\n           */ (/** @type {any} */ obj) => typeof obj === 'string' ? obj : undefined,\n  Bool: /**\n         * @param obj\n         * @returns {undefined|boolean}\n         */ (/** @type {any} */ obj) => typeof obj === 'boolean' ? obj : undefined,\n  Bytes: /**\n          * @param obj\n          * @returns {undefined|Uint8Array}\n          */ (/** @type {any} */ obj) => obj instanceof Uint8Array ? obj : undefined,\n  Link: /**\n         * @param obj\n         * @returns {undefined|object}\n         */ (/** @type {any} */ obj) => obj !== null && typeof obj === 'object' && obj.asCID === obj ? obj : undefined,\n  List: /**\n         * @param obj\n         * @returns {undefined|Array<any>}\n         */ (/** @type {any} */ obj) => Array.isArray(obj) ? obj : undefined,\n  Map: /**\n        * @param obj\n        * @returns {undefined|object}\n        */ (/** @type {any} */ obj) => obj !== null && typeof obj === 'object' && obj.asCID !== obj && !Array.isArray(obj) && !(obj instanceof Uint8Array) ? obj : undefined\n}\n/** @type {{ [k in string]: (obj:any)=>undefined|any}} */\nconst Types = {\n  'CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)': Kinds.Link,\n  'CarV1HeaderOrV2Pragma > roots (anon)': /**\n                                           * @param obj\n                                           * @returns {undefined|any}\n                                           */ (/** @type {any} */ obj) => {\n    if (Kinds.List(obj) === undefined) {\n      return undefined\n    }\n    for (let i = 0; i < obj.length; i++) {\n      let v = obj[i]\n      v = Types['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v)\n      if (v === undefined) {\n        return undefined\n      }\n      if (v !== obj[i]) {\n        const ret = obj.slice(0, i)\n        for (let j = i; j < obj.length; j++) {\n          let v = obj[j]\n          v = Types['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v)\n          if (v === undefined) {\n            return undefined\n          }\n          ret.push(v)\n        }\n        return ret\n      }\n    }\n    return obj\n  },\n  Int: Kinds.Int,\n  CarV1HeaderOrV2Pragma: /**\n                          * @param obj\n                          * @returns {undefined|any}\n                          */ (/** @type {any} */ obj) => {\n    if (Kinds.Map(obj) === undefined) {\n      return undefined\n    }\n    const entries = Object.entries(obj)\n    /** @type {{[k in string]: any}} */\n    let ret = obj\n    let requiredCount = 1\n    for (let i = 0; i < entries.length; i++) {\n      const [key, value] = entries[i]\n      switch (key) {\n        case 'roots':\n          {\n            const v = Types['CarV1HeaderOrV2Pragma > roots (anon)'](obj[key])\n            if (v === undefined) {\n              return undefined\n            }\n            if (v !== value || ret !== obj) {\n              if (ret === obj) {\n                /** @type {{[k in string]: any}} */\n                ret = {}\n                for (let j = 0; j < i; j++) {\n                  ret[entries[j][0]] = entries[j][1]\n                }\n              }\n              ret.roots = v\n            }\n          }\n          break\n        case 'version':\n          {\n            requiredCount--\n            const v = Types.Int(obj[key])\n            if (v === undefined) {\n              return undefined\n            }\n            if (v !== value || ret !== obj) {\n              if (ret === obj) {\n                /** @type {{[k in string]: any}} */\n                ret = {}\n                for (let j = 0; j < i; j++) {\n                  ret[entries[j][0]] = entries[j][1]\n                }\n              }\n              ret.version = v\n            }\n          }\n          break\n        default:\n          return undefined\n      }\n    }\n\n    if (requiredCount > 0) {\n      return undefined\n    }\n    return ret\n  }\n}\n/** @type {{ [k in string]: (obj:any)=>undefined|any}} */\nconst Reprs = {\n  'CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)': Kinds.Link,\n  'CarV1HeaderOrV2Pragma > roots (anon)': /**\n                                           * @param obj\n                                           * @returns {undefined|any}\n                                           */ (/** @type {any} */ obj) => {\n    if (Kinds.List(obj) === undefined) {\n      return undefined\n    }\n    for (let i = 0; i < obj.length; i++) {\n      let v = obj[i]\n      v = Reprs['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v)\n      if (v === undefined) {\n        return undefined\n      }\n      if (v !== obj[i]) {\n        const ret = obj.slice(0, i)\n        for (let j = i; j < obj.length; j++) {\n          let v = obj[j]\n          v = Reprs['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v)\n          if (v === undefined) {\n            return undefined\n          }\n          ret.push(v)\n        }\n        return ret\n      }\n    }\n    return obj\n  },\n  Int: Kinds.Int,\n  CarV1HeaderOrV2Pragma: /**\n                          * @param obj\n                          * @returns {undefined|any}\n                          */ (/** @type {any} */ obj) => {\n    if (Kinds.Map(obj) === undefined) {\n      return undefined\n    }\n    const entries = Object.entries(obj)\n    /** @type {{[k in string]: any}} */\n    let ret = obj\n    let requiredCount = 1\n    for (let i = 0; i < entries.length; i++) {\n      const [key, value] = entries[i]\n      switch (key) {\n        case 'roots':\n          {\n            const v = Reprs['CarV1HeaderOrV2Pragma > roots (anon)'](value)\n            if (v === undefined) {\n              return undefined\n            }\n            if (v !== value || ret !== obj) {\n              if (ret === obj) {\n                /** @type {{[k in string]: any}} */\n                ret = {}\n                for (let j = 0; j < i; j++) {\n                  ret[entries[j][0]] = entries[j][1]\n                }\n              }\n              ret.roots = v\n            }\n          }\n          break\n        case 'version':\n          {\n            requiredCount--\n            const v = Reprs.Int(value)\n            if (v === undefined) {\n              return undefined\n            }\n            if (v !== value || ret !== obj) {\n              if (ret === obj) {\n                /** @type {{[k in string]: any}} */\n                ret = {}\n                for (let j = 0; j < i; j++) {\n                  ret[entries[j][0]] = entries[j][1]\n                }\n              }\n              ret.version = v\n            }\n          }\n          break\n        default:\n          return undefined\n      }\n    }\n    if (requiredCount > 0) {\n      return undefined\n    }\n    return ret\n  }\n}\n\nexport const CarV1HeaderOrV2Pragma = {\n  toTyped: Types.CarV1HeaderOrV2Pragma,\n  toRepresentation: Reprs.CarV1HeaderOrV2Pragma\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1872, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/car/src/buffer-decoder.js"],"sourcesContent":["import { decode as decodeDagCbor } from '@ipld/dag-cbor'\nimport { CID } from 'multiformats/cid'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { CIDV0_BYTES, decodeV2Header, decodeVarint, getMultihashLength, V2_HEADER_LENGTH } from './decoder-common.js'\nimport { CarV1HeaderOrV2Pragma } from './header-validator.js'\n\n/**\n * @typedef {import('./api.js').Block} Block\n * @typedef {import('./api.js').BlockHeader} BlockHeader\n * @typedef {import('./api.js').BlockIndex} BlockIndex\n * @typedef {import('./coding.js').BytesBufferReader} BytesBufferReader\n * @typedef {import('./coding.js').CarHeader} CarHeader\n * @typedef {import('./coding.js').CarV2Header} CarV2Header\n * @typedef {import('./coding.js').CarV2FixedHeader} CarV2FixedHeader\n */\n\n/**\n * Reads header data from a `BytesReader`. The header may either be in the form\n * of a `CarHeader` or `CarV2Header` depending on the CAR being read.\n *\n * @name decoder.readHeader(reader)\n * @param {BytesBufferReader} reader\n * @param {number} [strictVersion]\n * @returns {CarHeader | CarV2Header}\n */\nexport function readHeader (reader, strictVersion) {\n  const length = decodeVarint(reader.upTo(8), reader)\n  if (length === 0) {\n    throw new Error('Invalid CAR header (zero length)')\n  }\n  const header = reader.exactly(length, true)\n  const block = decodeDagCbor(header)\n  if (CarV1HeaderOrV2Pragma.toTyped(block) === undefined) {\n    throw new Error('Invalid CAR header format')\n  }\n  if ((block.version !== 1 && block.version !== 2) || (strictVersion !== undefined && block.version !== strictVersion)) {\n    throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== undefined ? ` (expected ${strictVersion})` : ''}`)\n  }\n  if (block.version === 1) {\n    // CarV1HeaderOrV2Pragma makes roots optional, let's make it mandatory\n    if (!Array.isArray(block.roots)) {\n      throw new Error('Invalid CAR header format')\n    }\n    return block\n  }\n  // version 2\n  if (block.roots !== undefined) {\n    throw new Error('Invalid CAR header format')\n  }\n  const v2Header = decodeV2Header(reader.exactly(V2_HEADER_LENGTH, true))\n  reader.seek(v2Header.dataOffset - reader.pos)\n  const v1Header = readHeader(reader, 1)\n  return Object.assign(v1Header, v2Header)\n}\n\n/**\n * Reads CID sync\n *\n * @param {BytesBufferReader} reader\n * @returns {CID}\n */\nfunction readCid (reader) {\n  const first = reader.exactly(2, false)\n  if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {\n    // cidv0 32-byte sha2-256\n    const bytes = reader.exactly(34, true)\n    const multihash = Digest.decode(bytes)\n    return CID.create(0, CIDV0_BYTES.DAG_PB, multihash)\n  }\n\n  const version = decodeVarint(reader.upTo(8), reader)\n  if (version !== 1) {\n    throw new Error(`Unexpected CID version (${version})`)\n  }\n  const codec = decodeVarint(reader.upTo(8), reader)\n  const bytes = reader.exactly(getMultihashLength(reader.upTo(8)), true)\n  const multihash = Digest.decode(bytes)\n  return CID.create(version, codec, multihash)\n}\n\n/**\n * Reads the leading data of an individual block from CAR data from a\n * `BytesBufferReader`. Returns a `BlockHeader` object which contains\n * `{ cid, length, blockLength }` which can be used to either index the block\n * or read the block binary data.\n *\n * @name async decoder.readBlockHead(reader)\n * @param {BytesBufferReader} reader\n * @returns {BlockHeader}\n */\nexport function readBlockHead (reader) {\n  // length includes a CID + Binary, where CID has a variable length\n  // we have to deal with\n  const start = reader.pos\n  let length = decodeVarint(reader.upTo(8), reader)\n  if (length === 0) {\n    throw new Error('Invalid CAR section (zero length)')\n  }\n  length += (reader.pos - start)\n  const cid = readCid(reader)\n  const blockLength = length - Number(reader.pos - start) // subtract CID length\n\n  return { cid, length, blockLength }\n}\n\n/**\n * Returns Car header and blocks from a Uint8Array\n *\n * @param {Uint8Array} bytes\n * @returns {{ header : CarHeader | CarV2Header , blocks: Block[]}}\n */\nexport function fromBytes (bytes) {\n  let reader = bytesReader(bytes)\n  const header = readHeader(reader)\n  if (header.version === 2) {\n    const v1length = reader.pos - header.dataOffset\n    reader = limitReader(reader, header.dataSize - v1length)\n  }\n\n  const blocks = []\n  while (reader.upTo(8).length > 0) {\n    const { cid, blockLength } = readBlockHead(reader)\n\n    blocks.push({ cid, bytes: reader.exactly(blockLength, true) })\n  }\n\n  return {\n    header, blocks\n  }\n}\n\n/**\n * Creates a `BytesBufferReader` from a `Uint8Array`.\n *\n * @name decoder.bytesReader(bytes)\n * @param {Uint8Array} bytes\n * @returns {BytesBufferReader}\n */\nexport function bytesReader (bytes) {\n  let pos = 0\n\n  /** @type {BytesBufferReader} */\n  return {\n    upTo (length) {\n      return bytes.subarray(pos, pos + Math.min(length, bytes.length - pos))\n    },\n\n    exactly (length, seek = false) {\n      if (length > bytes.length - pos) {\n        throw new Error('Unexpected end of data')\n      }\n\n      const out = bytes.subarray(pos, pos + length)\n      if (seek) {\n        pos += length\n      }\n      return out\n    },\n\n    seek (length) {\n      pos += length\n    },\n\n    get pos () {\n      return pos\n    }\n  }\n}\n\n/**\n * Wraps a `BytesBufferReader` in a limiting `BytesBufferReader` which limits maximum read\n * to `byteLimit` bytes. It _does not_ update `pos` of the original\n * `BytesBufferReader`.\n *\n * @name decoder.limitReader(reader, byteLimit)\n * @param {BytesBufferReader} reader\n * @param {number} byteLimit\n * @returns {BytesBufferReader}\n */\nexport function limitReader (reader, byteLimit) {\n  let bytesRead = 0\n\n  /** @type {BytesBufferReader} */\n  return {\n    upTo (length) {\n      let bytes = reader.upTo(length)\n      if (bytes.length + bytesRead > byteLimit) {\n        bytes = bytes.subarray(0, byteLimit - bytesRead)\n      }\n      return bytes\n    },\n\n    exactly (length, seek = false) {\n      const bytes = reader.exactly(length, seek)\n      if (bytes.length + bytesRead > byteLimit) {\n        throw new Error('Unexpected end of data')\n      }\n      if (seek) {\n        bytesRead += length\n      }\n      return bytes\n    },\n\n    seek (length) {\n      bytesRead += length\n      reader.seek(length)\n    },\n\n    get pos () {\n      return reader.pos\n    }\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2040, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/car/src/buffer-reader-browser.js"],"sourcesContent":["import * as BufferDecoder from './buffer-decoder.js'\n\n/**\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('./api.js').Block} Block\n * @typedef {import('./api.js').CarBufferReader} ICarBufferReader\n * @typedef {import('./coding.js').CarHeader} CarHeader\n * @typedef {import('./coding.js').CarV2Header} CarV2Header\n */\n\n/**\n * Provides blockstore-like access to a CAR.\n *\n * Implements the `RootsBufferReader` interface:\n * {@link ICarBufferReader.getRoots `getRoots()`}. And the `BlockBufferReader` interface:\n * {@link ICarBufferReader.get `get()`}, {@link ICarBufferReader.has `has()`},\n * {@link ICarBufferReader.blocks `blocks()`} and\n * {@link ICarBufferReader.cids `cids()`}.\n *\n * Load this class with either `import { CarBufferReader } from '@ipld/car/buffer-reader'`\n * (`const { CarBufferReader } = require('@ipld/car/buffer-reader')`). Or\n * `import { CarBufferReader } from '@ipld/car'` (`const { CarBufferReader } = require('@ipld/car')`).\n * The former will likely result in smaller bundle sizes where this is\n * important.\n *\n * @name CarBufferReader\n * @class\n * @implements {ICarBufferReader}\n * @property {number} version The version number of the CAR referenced by this\n * reader (should be `1` or `2`).\n */\nexport class CarBufferReader {\n  /**\n   * @constructs CarBufferReader\n   * @param {CarHeader|CarV2Header} header\n   * @param {Block[]} blocks\n   */\n  constructor (header, blocks) {\n    this._header = header\n    this._blocks = blocks\n    this._cids = undefined\n  }\n\n  /**\n   * @property {number} version of the CAR\n   * @memberof CarBufferReader\n   * @instance\n   */\n  get version () {\n    return this._header.version\n  }\n\n  /**\n   * Get the list of roots defined by the CAR referenced by this reader. May be\n   * zero or more `CID`s.\n   *\n   * @function\n   * @memberof CarBufferReader\n   * @instance\n   * @returns {CID[]}\n   */\n  getRoots () {\n    return this._header.roots\n  }\n\n  /**\n   * Check whether a given `CID` exists within the CAR referenced by this\n   * reader.\n   *\n   * @function\n   * @memberof CarBufferReader\n   * @instance\n   * @param {CID} key\n   * @returns {boolean}\n   */\n  has (key) {\n    return this._blocks.some(b => b.cid.equals(key))\n  }\n\n  /**\n   * Fetch a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) from the CAR\n   * referenced by this reader matching the provided `CID`. In the case where\n   * the provided `CID` doesn't exist within the CAR, `undefined` will be\n   * returned.\n   *\n   * @function\n   * @memberof CarBufferReader\n   * @instance\n   * @param {CID} key\n   * @returns {Block | undefined}\n   */\n  get (key) {\n    return this._blocks.find(b => b.cid.equals(key))\n  }\n\n  /**\n   * Returns a `Block[]` of the `Block`s (`{ cid:CID, bytes:Uint8Array }` pairs) contained within\n   * the CAR referenced by this reader.\n   *\n   * @function\n   * @memberof CarBufferReader\n   * @instance\n   * @returns {Block[]}\n   */\n  blocks () {\n    return this._blocks\n  }\n\n  /**\n   * Returns a `CID[]` of the `CID`s contained within the CAR referenced by this reader.\n   *\n   * @function\n   * @memberof CarBufferReader\n   * @instance\n   * @returns {CID[]}\n   */\n  cids () {\n    if (!this._cids) {\n      this._cids = this._blocks.map(b => b.cid)\n    }\n    return this._cids\n  }\n\n  /**\n   * Instantiate a {@link CarBufferReader} from a `Uint8Array` blob. This performs a\n   * decode fully in memory and maintains the decoded state in memory for full\n   * access to the data via the `CarReader` API.\n   *\n   * @static\n   * @memberof CarBufferReader\n   * @param {Uint8Array} bytes\n   * @returns {CarBufferReader}\n   */\n  static fromBytes (bytes) {\n    if (!(bytes instanceof Uint8Array)) {\n      throw new TypeError('fromBytes() requires a Uint8Array')\n    }\n\n    const { header, blocks } = BufferDecoder.fromBytes(bytes)\n    return new CarBufferReader(header, blocks)\n  }\n}\n\nexport const __browser = true\n"],"names":[],"mappings":";;;;;;AAAA;;AA+BO,MAAM;IACX;;;;GAIC,GACD,YAAa,MAAM,EAAE,MAAM,CAAE;QAC3B,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,KAAK,GAAG;IACf;IAEA;;;;GAIC,GACD,IAAI,UAAW;QACb,OAAO,IAAI,CAAC,OAAO,CAAC,OAAO;IAC7B;IAEA;;;;;;;;GAQC,GACD,WAAY;QACV,OAAO,IAAI,CAAC,OAAO,CAAC,KAAK;IAC3B;IAEA;;;;;;;;;GASC,GACD,IAAK,GAAG,EAAE;QACR,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAA,IAAK,EAAE,GAAG,CAAC,MAAM,CAAC;IAC7C;IAEA;;;;;;;;;;;GAWC,GACD,IAAK,GAAG,EAAE;QACR,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAA,IAAK,EAAE,GAAG,CAAC,MAAM,CAAC;IAC7C;IAEA;;;;;;;;GAQC,GACD,SAAU;QACR,OAAO,IAAI,CAAC,OAAO;IACrB;IAEA;;;;;;;GAOC,GACD,OAAQ;QACN,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE;YACf,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAA,IAAK,EAAE,GAAG;QAC1C;QACA,OAAO,IAAI,CAAC,KAAK;IACnB;IAEA;;;;;;;;;GASC,GACD,OAAO,UAAW,KAAK,EAAE;QACvB,IAAI,CAAC,CAAC,iBAAiB,UAAU,GAAG;YAClC,MAAM,IAAI,UAAU;QACtB;QAEA,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,GAAG,wKAAuB,CAAC;QACnD,OAAO,IAAI,gBAAgB,QAAQ;IACrC;AACF;AAEO,MAAM,YAAY","ignoreList":[0]}},
    {"offset": {"line": 2148, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/car/src/buffer-reader.js"],"sourcesContent":["import fs from 'fs'\nimport { CarBufferReader as BrowserCarBufferReader } from './buffer-reader-browser.js'\n\n/**\n * @typedef {import('./api.js').Block} Block\n * @typedef {import('./api.js').BlockIndex} BlockIndex\n * @typedef {import('./api.js').CarBufferReader} ICarBufferReader\n */\n\nconst fsread = fs.readSync\n\n/**\n * @class\n * @implements {ICarBufferReader}\n */\nexport class CarBufferReader extends BrowserCarBufferReader {\n  /**\n   * Reads a block directly from a file descriptor for an open CAR file. This\n   * function is **only available in Node.js** and not a browser environment.\n   *\n   * This function can be used in connection with {@link CarIndexer} which emits\n   * the `BlockIndex` objects that are required by this function.\n   *\n   * The user is responsible for opening and closing the file used in this call.\n   *\n   * @static\n   * @memberof CarBufferReader\n   * @param {number} fd - A file descriptor from the\n   * Node.js `fs` module. An integer, from `fs.open()`.\n   * @param {BlockIndex} blockIndex - An index pointing to the location of the\n   * Block required. This `BlockIndex` should take the form:\n   * `{cid:CID, blockLength:number, blockOffset:number}`.\n   * @returns {Block} A `{ cid:CID, bytes:Uint8Array }` pair.\n   */\n  static readRaw (fd, blockIndex) {\n    const { cid, blockLength, blockOffset } = blockIndex\n    const bytes = new Uint8Array(blockLength)\n    let read\n    if (typeof fd === 'number') {\n      read = fsread(fd, bytes, 0, blockLength, blockOffset)\n    } else {\n      throw new TypeError('Bad fd')\n    }\n    if (read !== blockLength) {\n      throw new Error(`Failed to read entire block (${read} instead of ${blockLength})`)\n    }\n    return { cid, bytes }\n  }\n}\n\nexport const __browser = false\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAEA;;;;CAIC,GAED,MAAM,SAAS,wGAAE,CAAC,QAAQ;AAMnB,MAAM,wBAAwB,wLAAsB;IACzD;;;;;;;;;;;;;;;;;GAiBC,GACD,OAAO,QAAS,EAAE,EAAE,UAAU,EAAE;QAC9B,MAAM,EAAE,GAAG,EAAE,WAAW,EAAE,WAAW,EAAE,GAAG;QAC1C,MAAM,QAAQ,IAAI,WAAW;QAC7B,IAAI;QACJ,IAAI,OAAO,OAAO,UAAU;YAC1B,OAAO,OAAO,IAAI,OAAO,GAAG,aAAa;QAC3C,OAAO;YACL,MAAM,IAAI,UAAU;QACtB;QACA,IAAI,SAAS,aAAa;YACxB,MAAM,IAAI,MAAM,CAAC,6BAA6B,EAAE,KAAK,YAAY,EAAE,YAAY,CAAC,CAAC;QACnF;QACA,OAAO;YAAE;YAAK;QAAM;IACtB;AACF;AAEO,MAAM,YAAY","ignoreList":[0]}},
    {"offset": {"line": 2204, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/car/src/buffer-writer.js"],"sourcesContent":["import * as CBOR from '@ipld/dag-cbor'\nimport { Token, Type } from 'cborg'\nimport { tokensToLength } from 'cborg/length'\nimport varint from 'varint'\n\n/**\n * @typedef {import('./api.js').CID} CID\n * @typedef {import('./api.js').Block} Block\n * @typedef {import('./api.js').CarBufferWriter} Writer\n * @typedef {import('./api.js').CarBufferWriterOptions} Options\n * @typedef {import('./coding.js').CarEncoder} CarEncoder\n */\n\n/**\n * A simple CAR writer that writes to a pre-allocated buffer.\n *\n * @class\n * @name CarBufferWriter\n * @implements {Writer}\n */\nclass CarBufferWriter {\n  /**\n   * @param {Uint8Array} bytes\n   * @param {number} headerSize\n   */\n  constructor (bytes, headerSize) {\n    /** @readonly */\n    this.bytes = bytes\n    this.byteOffset = headerSize\n\n    /**\n     * @readonly\n     * @type {CID[]}\n     */\n    this.roots = []\n    this.headerSize = headerSize\n  }\n\n  /**\n   * Add a root to this writer, to be used to create a header when the CAR is\n   * finalized with {@link CarBufferWriter.close `close()`}\n   *\n   * @param {CID} root\n   * @param {{resize?:boolean}} [options]\n   * @returns {CarBufferWriter}\n   */\n  addRoot (root, options) {\n    addRoot(this, root, options)\n    return this\n  }\n\n  /**\n   * Write a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) to the archive.\n   * Throws if there is not enough capacity.\n   *\n   * @param {Block} block - A `{ cid:CID, bytes:Uint8Array }` pair.\n   * @returns {CarBufferWriter}\n   */\n  write (block) {\n    addBlock(this, block)\n    return this\n  }\n\n  /**\n   * Finalize the CAR and return it as a `Uint8Array`.\n   *\n   * @param {object} [options]\n   * @param {boolean} [options.resize]\n   * @returns {Uint8Array}\n   */\n  close (options) {\n    return close(this, options)\n  }\n}\n\n/**\n * @param {CarBufferWriter} writer\n * @param {CID} root\n * @param {{resize?:boolean}} [options]\n */\nexport const addRoot = (writer, root, options = {}) => {\n  const { resize = false } = options\n  const { bytes, headerSize, byteOffset, roots } = writer\n  writer.roots.push(root)\n  const size = headerLength(writer)\n  // If there is not enough space for the new root\n  if (size > headerSize) {\n    // Check if we root would fit if we were to resize the head.\n    if (size - headerSize + byteOffset < bytes.byteLength) {\n      // If resize is enabled resize head\n      if (resize) {\n        resizeHeader(writer, size)\n      // otherwise remove head and throw an error suggesting to resize\n      } else {\n        roots.pop()\n        throw new RangeError(`Header of size ${headerSize} has no capacity for new root ${root}.\n  However there is a space in the buffer and you could call addRoot(root, { resize: root }) to resize header to make a space for this root.`)\n      }\n    // If head would not fit even with resize pop new root and throw error\n    } else {\n      roots.pop()\n      throw new RangeError(`Buffer has no capacity for a new root ${root}`)\n    }\n  }\n}\n\n/**\n * Calculates number of bytes required for storing given block in CAR. Useful in\n * estimating size of an `ArrayBuffer` for the `CarBufferWriter`.\n *\n * @name CarBufferWriter.blockLength(Block)\n * @param {Block} block\n * @returns {number}\n */\nexport const blockLength = ({ cid, bytes }) => {\n  const size = cid.bytes.byteLength + bytes.byteLength\n  return varint.encodingLength(size) + size\n}\n\n/**\n * @param {CarBufferWriter} writer\n * @param {Block} block\n */\nexport const addBlock = (writer, { cid, bytes }) => {\n  const byteLength = cid.bytes.byteLength + bytes.byteLength\n  const size = varint.encode(byteLength)\n  if (writer.byteOffset + size.length + byteLength > writer.bytes.byteLength) {\n    throw new RangeError('Buffer has no capacity for this block')\n  } else {\n    writeBytes(writer, size)\n    writeBytes(writer, cid.bytes)\n    writeBytes(writer, bytes)\n  }\n}\n\n/**\n * @param {CarBufferWriter} writer\n * @param {object} [options]\n * @param {boolean} [options.resize]\n */\nexport const close = (writer, options = {}) => {\n  const { resize = false } = options\n  const { roots, bytes, byteOffset, headerSize } = writer\n\n  const headerBytes = CBOR.encode({ version: 1, roots })\n  const varintBytes = varint.encode(headerBytes.length)\n\n  const size = varintBytes.length + headerBytes.byteLength\n  const offset = headerSize - size\n\n  // If header size estimate was accurate we just write header and return\n  // view into buffer.\n  if (offset === 0) {\n    writeHeader(writer, varintBytes, headerBytes)\n    return bytes.subarray(0, byteOffset)\n    // If header was overestimated and `{resize: true}` is passed resize header\n  } else if (resize) {\n    resizeHeader(writer, size)\n    writeHeader(writer, varintBytes, headerBytes)\n    return bytes.subarray(0, writer.byteOffset)\n  } else {\n    throw new RangeError(`Header size was overestimated.\nYou can use close({ resize: true }) to resize header`)\n  }\n}\n\n/**\n * @param {CarBufferWriter} writer\n * @param {number} byteLength\n */\nexport const resizeHeader = (writer, byteLength) => {\n  const { bytes, headerSize } = writer\n  // Move data section to a new offset\n  bytes.set(bytes.subarray(headerSize, writer.byteOffset), byteLength)\n  // Update header size & byteOffset\n  writer.byteOffset += byteLength - headerSize\n  writer.headerSize = byteLength\n}\n\n/**\n * @param {CarBufferWriter} writer\n * @param {number[]|Uint8Array} bytes\n */\n\nconst writeBytes = (writer, bytes) => {\n  writer.bytes.set(bytes, writer.byteOffset)\n  writer.byteOffset += bytes.length\n}\n/**\n * @param {{bytes:Uint8Array}} writer\n * @param {number[]} varint\n * @param {Uint8Array} header\n */\nconst writeHeader = ({ bytes }, varint, header) => {\n  bytes.set(varint)\n  bytes.set(header, varint.length)\n}\n\nconst headerPreludeTokens = [\n  new Token(Type.map, 2),\n  new Token(Type.string, 'version'),\n  new Token(Type.uint, 1),\n  new Token(Type.string, 'roots')\n]\n\nconst CID_TAG = new Token(Type.tag, 42)\n\n/**\n * Calculates header size given the array of byteLength for roots.\n *\n * @name CarBufferWriter.calculateHeaderLength(rootLengths)\n * @param {number[]} rootLengths\n * @returns {number}\n */\nexport const calculateHeaderLength = (rootLengths) => {\n  const tokens = [...headerPreludeTokens]\n  tokens.push(new Token(Type.array, rootLengths.length))\n  for (const rootLength of rootLengths) {\n    tokens.push(CID_TAG)\n    tokens.push(new Token(Type.bytes, { length: rootLength + 1 }))\n  }\n  const length = tokensToLength(tokens) // no options needed here because we have simple tokens\n  return varint.encodingLength(length) + length\n}\n\n/**\n * Calculates header size given the array of roots.\n *\n * @name CarBufferWriter.headerLength({ roots })\n * @param {object} options\n * @param {CID[]} options.roots\n * @returns {number}\n */\nexport const headerLength = ({ roots }) =>\n  calculateHeaderLength(roots.map(cid => cid.bytes.byteLength))\n\n/**\n * Estimates header size given a count of the roots and the expected byte length\n * of the root CIDs. The default length works for a standard CIDv1 with a\n * single-byte multihash code, such as SHA2-256 (i.e. the most common CIDv1).\n *\n * @name CarBufferWriter.estimateHeaderLength(rootCount[, rootByteLength])\n * @param {number} rootCount\n * @param {number} [rootByteLength]\n * @returns {number}\n */\nexport const estimateHeaderLength = (rootCount, rootByteLength = 36) =>\n  calculateHeaderLength(new Array(rootCount).fill(rootByteLength))\n\n/**\n * Creates synchronous CAR writer that can be used to encode blocks into a given\n * buffer. Optionally you could pass `byteOffset` and `byteLength` to specify a\n * range inside buffer to write into. If car file is going to have `roots` you\n * need to either pass them under `options.roots` (from which header size will\n * be calculated) or provide `options.headerSize` to allocate required space\n * in the buffer. You may also provide known `roots` and `headerSize` to\n * allocate space for the roots that may not be known ahead of time.\n *\n * Note: Incorrect `headerSize` may lead to copying bytes inside a buffer\n * which will have a negative impact on performance.\n *\n * @name CarBufferWriter.createWriter(buffer[, options])\n * @param {ArrayBuffer} buffer\n * @param {object} [options]\n * @param {CID[]} [options.roots]\n * @param {number} [options.byteOffset]\n * @param {number} [options.byteLength]\n * @param {number} [options.headerSize]\n * @returns {CarBufferWriter}\n */\nexport const createWriter = (buffer, options = {}) => {\n  const {\n    roots = [],\n    byteOffset = 0,\n    byteLength = buffer.byteLength,\n    headerSize = headerLength({ roots })\n  } = options\n  const bytes = new Uint8Array(buffer, byteOffset, byteLength)\n\n  const writer = new CarBufferWriter(bytes, headerSize)\n  for (const root of roots) {\n    writer.addRoot(root)\n  }\n\n  return writer\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2416, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/car/src/decoder.js"],"sourcesContent":["import { decode as decodeDagCbor } from '@ipld/dag-cbor'\nimport { CID } from 'multiformats/cid'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { CIDV0_BYTES, decodeV2Header, decodeVarint, getMultihashLength, V2_HEADER_LENGTH } from './decoder-common.js'\nimport { CarV1HeaderOrV2Pragma } from './header-validator.js'\n\n/**\n * @typedef {import('./api.js').Block} Block\n * @typedef {import('./api.js').BlockHeader} BlockHeader\n * @typedef {import('./api.js').BlockIndex} BlockIndex\n * @typedef {import('./coding.js').BytesReader} BytesReader\n * @typedef {import('./coding.js').CarHeader} CarHeader\n * @typedef {import('./coding.js').CarV2Header} CarV2Header\n * @typedef {import('./coding.js').CarV2FixedHeader} CarV2FixedHeader\n * @typedef {import('./coding.js').CarDecoder} CarDecoder\n */\n\n/**\n * Reads header data from a `BytesReader`. The header may either be in the form\n * of a `CarHeader` or `CarV2Header` depending on the CAR being read.\n *\n * @name async decoder.readHeader(reader)\n * @param {BytesReader} reader\n * @param {number} [strictVersion]\n * @returns {Promise<CarHeader|CarV2Header>}\n */\nexport async function readHeader (reader, strictVersion) {\n  const length = decodeVarint(await reader.upTo(8), reader)\n  if (length === 0) {\n    throw new Error('Invalid CAR header (zero length)')\n  }\n  const header = await reader.exactly(length, true)\n  const block = decodeDagCbor(header)\n  if (CarV1HeaderOrV2Pragma.toTyped(block) === undefined) {\n    throw new Error('Invalid CAR header format')\n  }\n  if ((block.version !== 1 && block.version !== 2) || (strictVersion !== undefined && block.version !== strictVersion)) {\n    throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== undefined ? ` (expected ${strictVersion})` : ''}`)\n  }\n  if (block.version === 1) {\n    // CarV1HeaderOrV2Pragma makes roots optional, let's make it mandatory\n    if (!Array.isArray(block.roots)) {\n      throw new Error('Invalid CAR header format')\n    }\n    return block\n  }\n  // version 2\n  if (block.roots !== undefined) {\n    throw new Error('Invalid CAR header format')\n  }\n  const v2Header = decodeV2Header(await reader.exactly(V2_HEADER_LENGTH, true))\n  reader.seek(v2Header.dataOffset - reader.pos)\n  const v1Header = await readHeader(reader, 1)\n  return Object.assign(v1Header, v2Header)\n}\n\n/**\n * @param {BytesReader} reader\n * @returns {Promise<CID>}\n */\nasync function readCid (reader) {\n  const first = await reader.exactly(2, false)\n  if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {\n    // cidv0 32-byte sha2-256\n    const bytes = await reader.exactly(34, true)\n    const multihash = Digest.decode(bytes)\n    return CID.create(0, CIDV0_BYTES.DAG_PB, multihash)\n  }\n\n  const version = decodeVarint(await reader.upTo(8), reader)\n  if (version !== 1) {\n    throw new Error(`Unexpected CID version (${version})`)\n  }\n  const codec = decodeVarint(await reader.upTo(8), reader)\n  const bytes = await reader.exactly(getMultihashLength(await reader.upTo(8)), true)\n  const multihash = Digest.decode(bytes)\n  return CID.create(version, codec, multihash)\n}\n\n/**\n * Reads the leading data of an individual block from CAR data from a\n * `BytesReader`. Returns a `BlockHeader` object which contains\n * `{ cid, length, blockLength }` which can be used to either index the block\n * or read the block binary data.\n *\n * @name async decoder.readBlockHead(reader)\n * @param {BytesReader} reader\n * @returns {Promise<BlockHeader>}\n */\nexport async function readBlockHead (reader) {\n  // length includes a CID + Binary, where CID has a variable length\n  // we have to deal with\n  const start = reader.pos\n  let length = decodeVarint(await reader.upTo(8), reader)\n  if (length === 0) {\n    throw new Error('Invalid CAR section (zero length)')\n  }\n  length += (reader.pos - start)\n  const cid = await readCid(reader)\n  const blockLength = length - Number(reader.pos - start) // subtract CID length\n\n  return { cid, length, blockLength }\n}\n\n/**\n * @param {BytesReader} reader\n * @returns {Promise<Block>}\n */\nasync function readBlock (reader) {\n  const { cid, blockLength } = await readBlockHead(reader)\n  const bytes = await reader.exactly(blockLength, true)\n  return { bytes, cid }\n}\n\n/**\n * @param {BytesReader} reader\n * @returns {Promise<BlockIndex>}\n */\nasync function readBlockIndex (reader) {\n  const offset = reader.pos\n  const { cid, length, blockLength } = await readBlockHead(reader)\n  const index = { cid, length, blockLength, offset, blockOffset: reader.pos }\n  reader.seek(index.blockLength)\n  return index\n}\n\n/**\n * Creates a `CarDecoder` from a `BytesReader`. The `CarDecoder` is as async\n * interface that will consume the bytes from the `BytesReader` to yield a\n * `header()` and either `blocks()` or `blocksIndex()` data.\n *\n * @name decoder.createDecoder(reader)\n * @param {BytesReader} reader\n * @returns {CarDecoder}\n */\nexport function createDecoder (reader) {\n  const headerPromise = (async () => {\n    const header = await readHeader(reader)\n    if (header.version === 2) {\n      const v1length = reader.pos - header.dataOffset\n      reader = limitReader(reader, header.dataSize - v1length)\n    }\n    return header\n  })()\n\n  return {\n    header: () => headerPromise,\n\n    async * blocks () {\n      await headerPromise\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlock(reader)\n      }\n    },\n\n    async * blocksIndex () {\n      await headerPromise\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlockIndex(reader)\n      }\n    }\n  }\n}\n\n/**\n * Creates a `BytesReader` from a `Uint8Array`.\n *\n * @name decoder.bytesReader(bytes)\n * @param {Uint8Array} bytes\n * @returns {BytesReader}\n */\nexport function bytesReader (bytes) {\n  let pos = 0\n\n  /** @type {BytesReader} */\n  return {\n    async upTo (length) {\n      const out = bytes.subarray(pos, pos + Math.min(length, bytes.length - pos))\n      return out\n    },\n\n    async exactly (length, seek = false) {\n      if (length > bytes.length - pos) {\n        throw new Error('Unexpected end of data')\n      }\n      const out = bytes.subarray(pos, pos + length)\n      if (seek) {\n        pos += length\n      }\n      return out\n    },\n\n    seek (length) {\n      pos += length\n    },\n\n    get pos () {\n      return pos\n    }\n  }\n}\n\n/**\n * reusable reader for streams and files, we just need a way to read an\n * additional chunk (of some undetermined size) and a way to close the\n * reader when finished\n *\n * @param {() => Promise<Uint8Array|null>} readChunk\n * @returns {BytesReader}\n */\nexport function chunkReader (readChunk /*, closer */) {\n  let pos = 0\n  let have = 0\n  let offset = 0\n  let currentChunk = new Uint8Array(0)\n\n  const read = async (/** @type {number} */ length) => {\n    have = currentChunk.length - offset\n    const bufa = /** @type {Uint8Array<ArrayBufferLike>[]} */([currentChunk.subarray(offset)])\n    while (have < length) {\n      const chunk = await readChunk()\n      if (chunk == null) {\n        break\n      }\n      /* c8 ignore next 8 */\n      // undo this ignore ^ when we have a fd implementation that can seek()\n      if (have < 0) { // because of a seek()\n        /* c8 ignore next 4 */\n        // toohard to test the else\n        if (chunk.length > have) {\n          bufa.push(chunk.subarray(-have))\n        } // else discard\n      } else {\n        bufa.push(chunk)\n      }\n      have += chunk.length\n    }\n    currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0))\n    let off = 0\n    for (const b of bufa) {\n      currentChunk.set(b, off)\n      off += b.length\n    }\n    offset = 0\n  }\n\n  /** @type {BytesReader} */\n  return {\n    async upTo (length) {\n      if (currentChunk.length - offset < length) {\n        await read(length)\n      }\n      return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length))\n    },\n\n    async exactly (length, seek = false) {\n      if (currentChunk.length - offset < length) {\n        await read(length)\n      }\n      if (currentChunk.length - offset < length) {\n        throw new Error('Unexpected end of data')\n      }\n      const out = currentChunk.subarray(offset, offset + length)\n      if (seek) {\n        pos += length\n        offset += length\n      }\n      return out\n    },\n\n    seek (length) {\n      pos += length\n      offset += length\n    },\n\n    get pos () {\n      return pos\n    }\n  }\n}\n\n/**\n * Creates a `BytesReader` from an `AsyncIterable<Uint8Array>`, which allows for\n * consumption of CAR data from a streaming source.\n *\n * @name decoder.asyncIterableReader(asyncIterable)\n * @param {AsyncIterable<Uint8Array>} asyncIterable\n * @returns {BytesReader}\n */\nexport function asyncIterableReader (asyncIterable) {\n  const iterator = asyncIterable[Symbol.asyncIterator]()\n\n  async function readChunk () {\n    const next = await iterator.next()\n    if (next.done) {\n      return null\n    }\n    return next.value\n  }\n\n  return chunkReader(readChunk)\n}\n\n/**\n * Wraps a `BytesReader` in a limiting `BytesReader` which limits maximum read\n * to `byteLimit` bytes. It _does not_ update `pos` of the original\n * `BytesReader`.\n *\n * @name decoder.limitReader(reader, byteLimit)\n * @param {BytesReader} reader\n * @param {number} byteLimit\n * @returns {BytesReader}\n */\nexport function limitReader (reader, byteLimit) {\n  let bytesRead = 0\n\n  /** @type {BytesReader} */\n  return {\n    async upTo (length) {\n      let bytes = await reader.upTo(length)\n      if (bytes.length + bytesRead > byteLimit) {\n        bytes = bytes.subarray(0, byteLimit - bytesRead)\n      }\n      return bytes\n    },\n\n    async exactly (length, seek = false) {\n      const bytes = await reader.exactly(length, seek)\n      if (bytes.length + bytesRead > byteLimit) {\n        throw new Error('Unexpected end of data')\n      }\n      if (seek) {\n        bytesRead += length\n      }\n      return bytes\n    },\n\n    seek (length) {\n      bytesRead += length\n      reader.seek(length)\n    },\n\n    get pos () {\n      return reader.pos\n    }\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2694, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/car/src/indexer.js"],"sourcesContent":["import {\n  asyncIterableReader,\n  bytesReader,\n  createDecoder\n} from './decoder.js'\n\n/**\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('./api.js').Block} Block\n * @typedef {import('./api.js').RootsReader} RootsReader\n * @typedef {import('./api.js').BlockIndex} BlockIndex\n * @typedef {import('./coding.js').BytesReader} BytesReader\n */\n\n/**\n * Provides an iterator over all of the `Block`s in a CAR, returning their CIDs\n * and byte-location information. Implements an `AsyncIterable<BlockIndex>`.\n * Where a `BlockIndex` is a\n * `{ cid:CID, length:number, offset:number, blockLength:number, blockOffset:number }`.\n *\n * As an implementer of `AsyncIterable`, this class can be used directly in a\n * `for await (const blockIndex of iterator) {}` loop. Where the `iterator` is\n * constructed using {@link CarIndexer.fromBytes} or\n * {@link CarIndexer.fromIterable}.\n *\n * An iteration can only be performce _once_ per instantiation.\n *\n * `CarIndexer` also implements the `RootsReader` interface and provides\n * the {@link CarIndexer.getRoots `getRoots()`} method.\n *\n * Load this class with either\n * `import { CarIndexer } from '@ipld/car/indexer'`\n * (`const { CarIndexer } = require('@ipld/car/indexer')`). Or\n * `import { CarIndexer } from '@ipld/car'`\n * (`const { CarIndexer } = require('@ipld/car')`). The former will likely\n * result in smaller bundle sizes where this is important.\n *\n * @name CarIndexer\n * @class\n * @implements {RootsReader}\n * @implements {AsyncIterable<BlockIndex>}\n * @property {number} version The version number of the CAR referenced by this\n * reader (should be `1`).\n */\nexport class CarIndexer {\n  /**\n   * @param {number} version\n   * @param {CID[]} roots\n   * @param {AsyncGenerator<BlockIndex>} iterator\n   */\n  constructor (version, roots, iterator) {\n    this._version = version\n    this._roots = roots\n    this._iterator = iterator\n  }\n\n  get version () {\n    return this._version\n  }\n\n  /**\n   * Get the list of roots defined by the CAR referenced by this indexer. May be\n   * zero or more `CID`s.\n   *\n   * @function\n   * @memberof CarIndexer\n   * @instance\n   * @async\n   * @returns {Promise<CID[]>}\n   */\n  async getRoots () {\n    return this._roots\n  }\n\n  /**\n   * @returns {AsyncIterator<BlockIndex>}\n   */\n  [Symbol.asyncIterator] () {\n    return this._iterator\n  }\n\n  /**\n   * Instantiate a {@link CarIndexer} from a `Uint8Array` blob. Only the header\n   * is decoded initially, the remainder is processed and emitted via the\n   * iterator as it is consumed.\n   *\n   * @async\n   * @static\n   * @memberof CarIndexer\n   * @param {Uint8Array} bytes\n   * @returns {Promise<CarIndexer>}\n   */\n  static async fromBytes (bytes) {\n    if (!(bytes instanceof Uint8Array)) {\n      throw new TypeError('fromBytes() requires a Uint8Array')\n    }\n    return decodeIndexerComplete(bytesReader(bytes))\n  }\n\n  /**\n   * Instantiate a {@link CarIndexer} from a `AsyncIterable<Uint8Array>`,\n   * such as a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).\n   * is decoded initially, the remainder is processed and emitted via the\n   * iterator as it is consumed.\n   *\n   * @async\n   * @static\n   * @memberof CarIndexer\n   * @param {AsyncIterable<Uint8Array>} asyncIterable\n   * @returns {Promise<CarIndexer>}\n   */\n  static async fromIterable (asyncIterable) {\n    if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === 'function')) {\n      throw new TypeError('fromIterable() requires an async iterable')\n    }\n    return decodeIndexerComplete(asyncIterableReader(asyncIterable))\n  }\n}\n\n/**\n * @private\n * @param {BytesReader} reader\n * @returns {Promise<CarIndexer>}\n */\nasync function decodeIndexerComplete (reader) {\n  const decoder = createDecoder(reader)\n  const { version, roots } = await decoder.header()\n\n  return new CarIndexer(version, roots, decoder.blocksIndex())\n}\n"],"names":[],"mappings":";;;;AAAA;;AA4CO,MAAM;IACX;;;;GAIC,GACD,YAAa,OAAO,EAAE,KAAK,EAAE,QAAQ,CAAE;QACrC,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,SAAS,GAAG;IACnB;IAEA,IAAI,UAAW;QACb,OAAO,IAAI,CAAC,QAAQ;IACtB;IAEA;;;;;;;;;GASC,GACD,MAAM,WAAY;QAChB,OAAO,IAAI,CAAC,MAAM;IACpB;IAEA;;GAEC,GACD,CAAC,OAAO,aAAa,CAAC,GAAI;QACxB,OAAO,IAAI,CAAC,SAAS;IACvB;IAEA;;;;;;;;;;GAUC,GACD,aAAa,UAAW,KAAK,EAAE;QAC7B,IAAI,CAAC,CAAC,iBAAiB,UAAU,GAAG;YAClC,MAAM,IAAI,UAAU;QACtB;QACA,OAAO,sBAAsB,IAAA,gKAAW,EAAC;IAC3C;IAEA;;;;;;;;;;;GAWC,GACD,aAAa,aAAc,aAAa,EAAE;QACxC,IAAI,CAAC,iBAAiB,CAAC,CAAC,OAAO,aAAa,CAAC,OAAO,aAAa,CAAC,KAAK,UAAU,GAAG;YAClF,MAAM,IAAI,UAAU;QACtB;QACA,OAAO,sBAAsB,IAAA,wKAAmB,EAAC;IACnD;AACF;AAEA;;;;CAIC,GACD,eAAe,sBAAuB,MAAM;IAC1C,MAAM,UAAU,IAAA,kKAAa,EAAC;IAC9B,MAAM,EAAE,OAAO,EAAE,KAAK,EAAE,GAAG,MAAM,QAAQ,MAAM;IAE/C,OAAO,IAAI,WAAW,SAAS,OAAO,QAAQ,WAAW;AAC3D","ignoreList":[0]}},
    {"offset": {"line": 2777, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/car/src/promise-fs-opts.js"],"sourcesContent":["import fs from 'fs'\nimport { promisify } from 'util'\n\nconst hasFS = Boolean(fs)\n\nexport { hasFS }\n\n/**\n * @type {any}\n */\nlet _fsReadFn\n/**\n * @description This function is needed not to initialize the `fs.read` on load time. To run in cf workers without polyfill.\n * @param {number} fd\n * @param {Uint8Array} buffer\n * @param {number} offset\n * @param {number} length\n * @param {number} position\n * @returns {Promise<{ bytesRead: number, buffer: Uint8Array }>}\n */\nexport function fsread (fd, buffer, offset, length, position) {\n  if (!_fsReadFn) {\n    _fsReadFn = promisify(fs.read)\n  }\n  return _fsReadFn(fd, buffer, offset, length, position)\n}\n\n/**\n * @type {any}\n */\nlet _fsWriteFn\n/**\n * @description This function is needed not to initialize the `fs.write` on load time. To run in cf workers without polyfill.\n * @param {number} fd\n * @param {Uint8Array} buffer\n * @param {number} offset\n * @param {number} length\n * @param {number} position\n * @returns {Promise<{ bytesRead: number, buffer: Uint8Array }>}\n */\nexport function fswrite (fd, buffer, offset, length, position) {\n  if (!_fsWriteFn) {\n    _fsWriteFn = promisify(fs.write)\n  }\n  return _fsWriteFn(fd, buffer, offset, length, position)\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;;;AAEA,MAAM,QAAQ,QAAQ,wGAAE;;AAIxB;;CAEC,GACD,IAAI;AAUG,SAAS,OAAQ,EAAE,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,QAAQ;IAC1D,IAAI,CAAC,WAAW;QACd,YAAY,IAAA,8GAAS,EAAC,wGAAE,CAAC,IAAI;IAC/B;IACA,OAAO,UAAU,IAAI,QAAQ,QAAQ,QAAQ;AAC/C;AAEA;;CAEC,GACD,IAAI;AAUG,SAAS,QAAS,EAAE,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,QAAQ;IAC3D,IAAI,CAAC,YAAY;QACf,aAAa,IAAA,8GAAS,EAAC,wGAAE,CAAC,KAAK;IACjC;IACA,OAAO,WAAW,IAAI,QAAQ,QAAQ,QAAQ;AAChD","ignoreList":[0]}},
    {"offset": {"line": 2813, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/car/src/reader-browser.js"],"sourcesContent":["import { asyncIterableReader, bytesReader, createDecoder } from './decoder.js'\n\n/**\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('./api.js').Block} Block\n * @typedef {import('./api.js').CarReader} CarReaderIface\n * @typedef {import('./coding.js').BytesReader} BytesReader\n * @typedef {import('./coding.js').CarHeader} CarHeader\n * @typedef {import('./coding.js').CarV2Header} CarV2Header\n */\n\n/**\n * Provides blockstore-like access to a CAR.\n *\n * Implements the `RootsReader` interface:\n * {@link CarReader.getRoots `getRoots()`}. And the `BlockReader` interface:\n * {@link CarReader.get `get()`}, {@link CarReader.has `has()`},\n * {@link CarReader.blocks `blocks()`} (defined as a `BlockIterator`) and\n * {@link CarReader.cids `cids()`} (defined as a `CIDIterator`).\n *\n * Load this class with either `import { CarReader } from '@ipld/car/reader'`\n * (`const { CarReader } = require('@ipld/car/reader')`). Or\n * `import { CarReader } from '@ipld/car'` (`const { CarReader } = require('@ipld/car')`).\n * The former will likely result in smaller bundle sizes where this is\n * important.\n *\n * @name CarReader\n * @class\n * @implements {CarReaderIface}\n * @property {number} version The version number of the CAR referenced by this\n * reader (should be `1` or `2`).\n */\nexport class CarReader {\n  /**\n   * @constructs CarReader\n   * @param {CarHeader|CarV2Header} header\n   * @param {Block[]} blocks\n   */\n  constructor (header, blocks) {\n    this._header = header\n    this._blocks = blocks\n    this._keys = blocks.map((b) => b.cid.toString())\n  }\n\n  /**\n   * @property\n   * @memberof CarReader\n   * @instance\n   */\n  get version () {\n    return this._header.version\n  }\n\n  /**\n   * Get the list of roots defined by the CAR referenced by this reader. May be\n   * zero or more `CID`s.\n   *\n   * @function\n   * @memberof CarReader\n   * @instance\n   * @async\n   * @returns {Promise<CID[]>}\n   */\n  async getRoots () {\n    return this._header.roots\n  }\n\n  /**\n   * Check whether a given `CID` exists within the CAR referenced by this\n   * reader.\n   *\n   * @function\n   * @memberof CarReader\n   * @instance\n   * @async\n   * @param {CID} key\n   * @returns {Promise<boolean>}\n   */\n  async has (key) {\n    return this._keys.indexOf(key.toString()) > -1\n  }\n\n  /**\n   * Fetch a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) from the CAR\n   * referenced by this reader matching the provided `CID`. In the case where\n   * the provided `CID` doesn't exist within the CAR, `undefined` will be\n   * returned.\n   *\n   * @function\n   * @memberof CarReader\n   * @instance\n   * @async\n   * @param {CID} key\n   * @returns {Promise<Block | undefined>}\n   */\n  async get (key) {\n    const index = this._keys.indexOf(key.toString())\n    return index > -1 ? this._blocks[index] : undefined\n  }\n\n  /**\n   * Returns a `BlockIterator` (`AsyncIterable<Block>`) that iterates over all\n   * of the `Block`s (`{ cid:CID, bytes:Uint8Array }` pairs) contained within\n   * the CAR referenced by this reader.\n   *\n   * @function\n   * @memberof CarReader\n   * @instance\n   * @async\n   * @generator\n   * @returns {AsyncGenerator<Block>}\n   */\n  async * blocks () {\n    for (const block of this._blocks) {\n      yield block\n    }\n  }\n\n  /**\n   * Returns a `CIDIterator` (`AsyncIterable<CID>`) that iterates over all of\n   * the `CID`s contained within the CAR referenced by this reader.\n   *\n   * @function\n   * @memberof CarReader\n   * @instance\n   * @async\n   * @generator\n   * @returns {AsyncGenerator<CID>}\n   */\n  async * cids () {\n    for (const block of this._blocks) {\n      yield block.cid\n    }\n  }\n\n  /**\n   * Instantiate a {@link CarReader} from a `Uint8Array` blob. This performs a\n   * decode fully in memory and maintains the decoded state in memory for full\n   * access to the data via the `CarReader` API.\n   *\n   * @async\n   * @static\n   * @memberof CarReader\n   * @param {Uint8Array} bytes\n   * @returns {Promise<CarReader>}\n   */\n  static async fromBytes (bytes) {\n    if (!(bytes instanceof Uint8Array)) {\n      throw new TypeError('fromBytes() requires a Uint8Array')\n    }\n    return decodeReaderComplete(bytesReader(bytes))\n  }\n\n  /**\n   * Instantiate a {@link CarReader} from a `AsyncIterable<Uint8Array>`, such as\n   * a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).\n   * This performs a decode fully in memory and maintains the decoded state in\n   * memory for full access to the data via the `CarReader` API.\n   *\n   * Care should be taken for large archives; this API may not be appropriate\n   * where memory is a concern or the archive is potentially larger than the\n   * amount of memory that the runtime can handle.\n   *\n   * @async\n   * @static\n   * @memberof CarReader\n   * @param {AsyncIterable<Uint8Array>} asyncIterable\n   * @returns {Promise<CarReader>}\n   */\n  static async fromIterable (asyncIterable) {\n    if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === 'function')) {\n      throw new TypeError('fromIterable() requires an async iterable')\n    }\n    return decodeReaderComplete(asyncIterableReader(asyncIterable))\n  }\n}\n\n/**\n * @private\n * @param {BytesReader} reader\n * @returns {Promise<CarReader>}\n */\nexport async function decodeReaderComplete (reader) {\n  const decoder = createDecoder(reader)\n  const header = await decoder.header()\n  const blocks = []\n  for await (const block of decoder.blocks()) {\n    blocks.push(block)\n  }\n\n  return new CarReader(header, blocks)\n}\n\nexport const __browser = true\n"],"names":[],"mappings":";;;;;;;;AAAA;;AAgCO,MAAM;IACX;;;;GAIC,GACD,YAAa,MAAM,EAAE,MAAM,CAAE;QAC3B,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,KAAK,GAAG,OAAO,GAAG,CAAC,CAAC,IAAM,EAAE,GAAG,CAAC,QAAQ;IAC/C;IAEA;;;;GAIC,GACD,IAAI,UAAW;QACb,OAAO,IAAI,CAAC,OAAO,CAAC,OAAO;IAC7B;IAEA;;;;;;;;;GASC,GACD,MAAM,WAAY;QAChB,OAAO,IAAI,CAAC,OAAO,CAAC,KAAK;IAC3B;IAEA;;;;;;;;;;GAUC,GACD,MAAM,IAAK,GAAG,EAAE;QACd,OAAO,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,QAAQ,MAAM,CAAC;IAC/C;IAEA;;;;;;;;;;;;GAYC,GACD,MAAM,IAAK,GAAG,EAAE;QACd,MAAM,QAAQ,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,QAAQ;QAC7C,OAAO,QAAQ,CAAC,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG;IAC5C;IAEA;;;;;;;;;;;GAWC,GACD,OAAQ,SAAU;QAChB,KAAK,MAAM,SAAS,IAAI,CAAC,OAAO,CAAE;YAChC,MAAM;QACR;IACF;IAEA;;;;;;;;;;GAUC,GACD,OAAQ,OAAQ;QACd,KAAK,MAAM,SAAS,IAAI,CAAC,OAAO,CAAE;YAChC,MAAM,MAAM,GAAG;QACjB;IACF;IAEA;;;;;;;;;;GAUC,GACD,aAAa,UAAW,KAAK,EAAE;QAC7B,IAAI,CAAC,CAAC,iBAAiB,UAAU,GAAG;YAClC,MAAM,IAAI,UAAU;QACtB;QACA,OAAO,qBAAqB,IAAA,gKAAW,EAAC;IAC1C;IAEA;;;;;;;;;;;;;;;GAeC,GACD,aAAa,aAAc,aAAa,EAAE;QACxC,IAAI,CAAC,iBAAiB,CAAC,CAAC,OAAO,aAAa,CAAC,OAAO,aAAa,CAAC,KAAK,UAAU,GAAG;YAClF,MAAM,IAAI,UAAU;QACtB;QACA,OAAO,qBAAqB,IAAA,wKAAmB,EAAC;IAClD;AACF;AAOO,eAAe,qBAAsB,MAAM;IAChD,MAAM,UAAU,IAAA,kKAAa,EAAC;IAC9B,MAAM,SAAS,MAAM,QAAQ,MAAM;IACnC,MAAM,SAAS,EAAE;IACjB,WAAW,MAAM,SAAS,QAAQ,MAAM,GAAI;QAC1C,OAAO,IAAI,CAAC;IACd;IAEA,OAAO,IAAI,UAAU,QAAQ;AAC/B;AAEO,MAAM,YAAY","ignoreList":[0]}},
    {"offset": {"line": 2964, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/car/src/reader.js"],"sourcesContent":["import { fsread, hasFS } from './promise-fs-opts.js'\nimport { CarReader as BrowserCarReader } from './reader-browser.js'\n\n/**\n * @typedef {import('./api.js').Block} Block\n * @typedef {import('./api.js').BlockIndex} BlockIndex\n * @typedef {import('./api.js').CarReader} CarReaderIface\n * @typedef {import('fs').promises.FileHandle} FileHandle\n */\n\n/**\n * @class\n * @implements {CarReaderIface}\n */\nexport class CarReader extends BrowserCarReader {\n  /**\n   * Reads a block directly from a file descriptor for an open CAR file. This\n   * function is **only available in Node.js** and not a browser environment.\n   *\n   * This function can be used in connection with {@link CarIndexer} which emits\n   * the `BlockIndex` objects that are required by this function.\n   *\n   * The user is responsible for opening and closing the file used in this call.\n   *\n   * @async\n   * @static\n   * @memberof CarReader\n   * @param {FileHandle | number} fd - A file descriptor from the\n   * Node.js `fs` module. Either an integer, from `fs.open()` or a `FileHandle`\n   * from `fs.promises.open()`.\n   * @param {BlockIndex} blockIndex - An index pointing to the location of the\n   * Block required. This `BlockIndex` should take the form:\n   * `{cid:CID, blockLength:number, blockOffset:number}`.\n   * @returns {Promise<Block>} A `{ cid:CID, bytes:Uint8Array }` pair.\n   */\n  static async readRaw (fd, blockIndex) {\n    const { cid, blockLength, blockOffset } = blockIndex\n    const bytes = new Uint8Array(blockLength)\n    let read\n    if (typeof fd === 'number') {\n      read = (await fsread(fd, bytes, 0, blockLength, blockOffset)).bytesRead\n    } else if (typeof fd === 'object' && typeof fd.read === 'function') { // FileDescriptor\n      read = (await fd.read(bytes, 0, blockLength, blockOffset)).bytesRead\n    } else {\n      throw new TypeError('Bad fd')\n    }\n    if (read !== blockLength) {\n      throw new Error(`Failed to read entire block (${read} instead of ${blockLength})`)\n    }\n    return { cid, bytes }\n  }\n}\n\nexport const __browser = !hasFS\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAaO,MAAM,kBAAkB,wKAAgB;IAC7C;;;;;;;;;;;;;;;;;;;GAmBC,GACD,aAAa,QAAS,EAAE,EAAE,UAAU,EAAE;QACpC,MAAM,EAAE,GAAG,EAAE,WAAW,EAAE,WAAW,EAAE,GAAG;QAC1C,MAAM,QAAQ,IAAI,WAAW;QAC7B,IAAI;QACJ,IAAI,OAAO,OAAO,UAAU;YAC1B,OAAO,CAAC,MAAM,IAAA,yKAAM,EAAC,IAAI,OAAO,GAAG,aAAa,YAAY,EAAE,SAAS;QACzE,OAAO,IAAI,OAAO,OAAO,YAAY,OAAO,GAAG,IAAI,KAAK,YAAY;YAClE,OAAO,CAAC,MAAM,GAAG,IAAI,CAAC,OAAO,GAAG,aAAa,YAAY,EAAE,SAAS;QACtE,OAAO;YACL,MAAM,IAAI,UAAU;QACtB;QACA,IAAI,SAAS,aAAa;YACxB,MAAM,IAAI,MAAM,CAAC,6BAA6B,EAAE,KAAK,YAAY,EAAE,YAAY,CAAC,CAAC;QACnF;QACA,OAAO;YAAE;YAAK;QAAM;IACtB;AACF;AAEO,MAAM,YAAY,CAAC,wKAAK","ignoreList":[0]}},
    {"offset": {"line": 3019, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/car/src/indexed-reader.js"],"sourcesContent":["import fs from 'fs'\nimport { Readable } from 'stream'\nimport { CID } from 'multiformats/cid'\nimport { CarIndexer } from './indexer.js'\nimport { CarReader as NodeCarReader } from './reader.js'\n\n/**\n * @typedef {import('fs').promises.FileHandle} FileHandle\n * @typedef {import('./api.js').Block} Block\n * @typedef {import('./api.js').BlockIndex} BlockIndex\n * @typedef {import('./api.js').CarReader} CarReaderIface\n * @typedef {import('./reader-browser.js').CarReader} CarReader\n * @typedef {{ blockLength:number, blockOffset:number }} RawLocation\n */\n\n/**\n * A form of {@link CarReader} that pre-indexes a CAR archive from a file and\n * provides random access to blocks within the file using the index data. This\n * function is **only available in Node.js** and not a browser environment.\n *\n * For large CAR files, using this form of `CarReader` can be singificantly more\n * efficient in terms of memory. The index consists of a list of `CID`s and\n * their location within the archive (see {@link CarIndexer}). For large numbers\n * of blocks, this index can also occupy a significant amount of memory. In some\n * cases it may be necessary to expand the memory capacity of a Node.js instance\n * to allow this index to fit. (e.g. by running with\n * `NODE_OPTIONS=\"--max-old-space-size=16384\"`).\n *\n * As an `CarIndexedReader` instance maintains an open file descriptor for its\n * CAR file, an additional {@link CarReader#close} method is attached. This\n * _must_ be called to have full clean-up of resources after use.\n *\n * Load this class with either\n * `import { CarIndexedReader } from '@ipld/car/indexed-reader'`\n * (`const { CarIndexedReader } = require('@ipld/car/indexed-reader')`). Or\n * `import { CarIndexedReader } from '@ipld/car'`\n * (`const { CarIndexedReader } = require('@ipld/car')`). The former will likely\n * result in smaller bundle sizes where this is important.\n *\n * @name CarIndexedReader\n * @class\n * @implements {CarReaderIface}\n * @extends {CarReader}\n * @property {number} version The version number of the CAR referenced by this\n * reader (should be `1`).\n */\nexport class CarIndexedReader {\n  /**\n   * @param {number} version\n   * @param {string} path\n   * @param {CID[]} roots\n   * @param {Map<string, RawLocation>} index\n   * @param {string[]} order\n   */\n  constructor (version, path, roots, index, order) {\n    this._version = version\n    this._path = path\n    this._roots = roots\n    this._index = index\n    this._order = order\n    this._fd = null\n  }\n\n  get version () {\n    return this._version\n  }\n\n  /**\n   * See {@link CarReader#getRoots}\n   *\n   * @function\n   * @memberof CarIndexedReader\n   * @instance\n   * @async\n   * @returns {Promise<CID[]>}\n   */\n  async getRoots () {\n    return this._roots\n  }\n\n  /**\n   * See {@link CarReader#has}\n   *\n   * @function\n   * @memberof CarIndexedReader\n   * @instance\n   * @async\n   * @param {CID} key\n   * @returns {Promise<boolean>}\n   */\n  async has (key) {\n    return this._index.has(key.toString())\n  }\n\n  /**\n   * See {@link CarReader#get}\n   *\n   * @function\n   * @memberof CarIndexedReader\n   * @instance\n   * @async\n   * @param {CID} key\n   * @returns {Promise<Block | undefined>}\n   */\n  async get (key) {\n    const blockIndex = this._index.get(key.toString())\n    if (!blockIndex) {\n      return undefined\n    }\n    if (!this._fd) {\n      this._fd = await fs.promises.open(this._path, 'r')\n    }\n    const readIndex = {\n      cid: key,\n      length: 0,\n      offset: 0,\n      blockLength: blockIndex.blockLength,\n      blockOffset: blockIndex.blockOffset\n    }\n    return NodeCarReader.readRaw(this._fd, readIndex)\n  }\n\n  /**\n   * See {@link CarReader#blocks}\n   *\n   * @function\n   * @memberof CarIndexedReader\n   * @instance\n   * @async\n   * @generator\n   * @returns {AsyncGenerator<Block>}\n   */\n  async * blocks () {\n    for (const cidStr of this._order) {\n      const block = await this.get(CID.parse(cidStr))\n      /* c8 ignore next 3 */\n      if (!block) {\n        throw new Error('Unexpected internal error')\n      }\n      yield block\n    }\n  }\n\n  /**\n   * See {@link CarReader#cids}\n   *\n   * @function\n   * @memberof CarIndexedReader\n   * @instance\n   * @async\n   * @generator\n   * @returns {AsyncGenerator<CID>}\n   */\n  async * cids () {\n    for (const cidStr of this._order) {\n      yield CID.parse(cidStr)\n    }\n  }\n\n  /**\n   * Close the underlying file descriptor maintained by this `CarIndexedReader`.\n   * This must be called for proper resource clean-up to occur.\n   *\n   * @function\n   * @memberof CarIndexedReader\n   * @instance\n   * @async\n   * @returns {Promise<void>}\n   */\n  async close () {\n    if (this._fd) {\n      return this._fd.close()\n    }\n  }\n\n  /**\n   * Instantiate an {@link CarIndexedReader} from a file with the provided\n   * `path`. The CAR file is first indexed with a full path that collects `CID`s\n   * and block locations. This index is maintained in memory. Subsequent reads\n   * operate on a read-only file descriptor, fetching the block from its in-file\n   * location.\n   *\n   * For large archives, the initial indexing may take some time. The returned\n   * `Promise` will resolve only after this is complete.\n   *\n   * @async\n   * @static\n   * @memberof CarIndexedReader\n   * @param {string} path\n   * @returns {Promise<CarIndexedReader>}\n   */\n  static async fromFile (path) {\n    if (typeof path !== 'string') {\n      throw new TypeError('fromFile() requires a file path string')\n    }\n\n    const iterable = await CarIndexer.fromIterable(Readable.from(fs.createReadStream(path)))\n    /** @type {Map<string, RawLocation>} */\n    const index = new Map()\n    /** @type {string[]} */\n    const order = []\n    for await (const { cid, blockLength, blockOffset } of iterable) {\n      const cidStr = cid.toString()\n      index.set(cidStr, { blockLength, blockOffset })\n      order.push(cidStr)\n    }\n    return new CarIndexedReader(iterable.version, path, await iterable.getRoots(), index, order)\n  }\n}\n\nexport const __browser = false\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AA0CO,MAAM;IACX;;;;;;GAMC,GACD,YAAa,OAAO,EAAE,IAAI,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK,CAAE;QAC/C,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,GAAG,GAAG;IACb;IAEA,IAAI,UAAW;QACb,OAAO,IAAI,CAAC,QAAQ;IACtB;IAEA;;;;;;;;GAQC,GACD,MAAM,WAAY;QAChB,OAAO,IAAI,CAAC,MAAM;IACpB;IAEA;;;;;;;;;GASC,GACD,MAAM,IAAK,GAAG,EAAE;QACd,OAAO,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,QAAQ;IACrC;IAEA;;;;;;;;;GASC,GACD,MAAM,IAAK,GAAG,EAAE;QACd,MAAM,aAAa,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,QAAQ;QAC/C,IAAI,CAAC,YAAY;YACf,OAAO;QACT;QACA,IAAI,CAAC,IAAI,CAAC,GAAG,EAAE;YACb,IAAI,CAAC,GAAG,GAAG,MAAM,wGAAE,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE;QAChD;QACA,MAAM,YAAY;YAChB,KAAK;YACL,QAAQ;YACR,QAAQ;YACR,aAAa,WAAW,WAAW;YACnC,aAAa,WAAW,WAAW;QACrC;QACA,OAAO,6JAAa,CAAC,OAAO,CAAC,IAAI,CAAC,GAAG,EAAE;IACzC;IAEA;;;;;;;;;GASC,GACD,OAAQ,SAAU;QAChB,KAAK,MAAM,UAAU,IAAI,CAAC,MAAM,CAAE;YAChC,MAAM,QAAQ,MAAM,IAAI,CAAC,GAAG,CAAC,2KAAG,CAAC,KAAK,CAAC;YACvC,oBAAoB,GACpB,IAAI,CAAC,OAAO;gBACV,MAAM,IAAI,MAAM;YAClB;YACA,MAAM;QACR;IACF;IAEA;;;;;;;;;GASC,GACD,OAAQ,OAAQ;QACd,KAAK,MAAM,UAAU,IAAI,CAAC,MAAM,CAAE;YAChC,MAAM,2KAAG,CAAC,KAAK,CAAC;QAClB;IACF;IAEA;;;;;;;;;GASC,GACD,MAAM,QAAS;QACb,IAAI,IAAI,CAAC,GAAG,EAAE;YACZ,OAAO,IAAI,CAAC,GAAG,CAAC,KAAK;QACvB;IACF;IAEA;;;;;;;;;;;;;;;GAeC,GACD,aAAa,SAAU,IAAI,EAAE;QAC3B,IAAI,OAAO,SAAS,UAAU;YAC5B,MAAM,IAAI,UAAU;QACtB;QAEA,MAAM,WAAW,MAAM,+JAAU,CAAC,YAAY,CAAC,iHAAQ,CAAC,IAAI,CAAC,wGAAE,CAAC,gBAAgB,CAAC;QACjF,qCAAqC,GACrC,MAAM,QAAQ,IAAI;QAClB,qBAAqB,GACrB,MAAM,QAAQ,EAAE;QAChB,WAAW,MAAM,EAAE,GAAG,EAAE,WAAW,EAAE,WAAW,EAAE,IAAI,SAAU;YAC9D,MAAM,SAAS,IAAI,QAAQ;YAC3B,MAAM,GAAG,CAAC,QAAQ;gBAAE;gBAAa;YAAY;YAC7C,MAAM,IAAI,CAAC;QACb;QACA,OAAO,IAAI,iBAAiB,SAAS,OAAO,EAAE,MAAM,MAAM,SAAS,QAAQ,IAAI,OAAO;IACxF;AACF;AAEO,MAAM,YAAY","ignoreList":[0]}},
    {"offset": {"line": 3186, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/car/src/iterator.js"],"sourcesContent":["import {\n  asyncIterableReader,\n  bytesReader,\n  createDecoder\n} from './decoder.js'\n\n/**\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('./api.js').Block} Block\n * @typedef {import('./api.js').RootsReader} RootsReader\n * @typedef {import('./coding.js').BytesReader} BytesReader\n */\n\n/**\n * @class\n * @implements {RootsReader}\n * @property {number} version The version number of the CAR referenced by this reader (should be `1`).\n */\nexport class CarIteratorBase {\n  /**\n   * @param {number} version\n   * @param {CID[]} roots\n   * @param {AsyncIterable<Block>|void} iterable\n   */\n  constructor (version, roots, iterable) {\n    this._version = version\n    this._roots = roots\n    this._iterable = iterable\n    this._decoded = false\n  }\n\n  get version () {\n    return this._version\n  }\n\n  /**\n   * @returns {Promise<CID[]>}\n   */\n  async getRoots () {\n    return this._roots\n  }\n}\n\n/**\n * Provides an iterator over all of the `Block`s in a CAR. Implements a\n * `BlockIterator` interface, or `AsyncIterable<Block>`. Where a `Block` is\n * a `{ cid:CID, bytes:Uint8Array }` pair.\n *\n * As an implementer of `AsyncIterable`, this class can be used directly in a\n * `for await (const block of iterator) {}` loop. Where the `iterator` is\n * constructed using {@link CarBlockiterator.fromBytes} or\n * {@link CarBlockiterator.fromIterable}.\n *\n * An iteration can only be performce _once_ per instantiation.\n *\n * `CarBlockIterator` also implements the `RootsReader` interface and provides\n * the {@link CarBlockiterator.getRoots `getRoots()`} method.\n *\n * Load this class with either\n * `import { CarBlockIterator } from '@ipld/car/iterator'`\n * (`const { CarBlockIterator } = require('@ipld/car/iterator')`). Or\n * `import { CarBlockIterator } from '@ipld/car'`\n * (`const { CarBlockIterator } = require('@ipld/car')`).\n *\n * @name CarBlockIterator\n * @class\n * @implements {RootsReader}\n * @implements {AsyncIterable<Block>}\n * @property {number} version The version number of the CAR referenced by this\n * iterator (should be `1`).\n */\nexport class CarBlockIterator extends CarIteratorBase {\n  // inherited method\n  /**\n   * Get the list of roots defined by the CAR referenced by this iterator. May be\n   * zero or more `CID`s.\n   *\n   * @function getRoots\n   * @memberof CarBlockIterator\n   * @instance\n   * @async\n   * @returns {Promise<CID[]>}\n   */\n\n  /**\n   * @returns {AsyncIterator<Block>}\n   */\n  [Symbol.asyncIterator] () {\n    if (this._decoded) {\n      throw new Error('Cannot decode more than once')\n    }\n    /* c8 ignore next 3 */\n    if (!this._iterable) {\n      throw new Error('Block iterable not found')\n    }\n    this._decoded = true\n    return this._iterable[Symbol.asyncIterator]()\n  }\n\n  /**\n   * Instantiate a {@link CarBlockIterator} from a `Uint8Array` blob. Rather\n   * than decoding the entire byte array prior to returning the iterator, as in\n   * {@link CarReader.fromBytes}, only the header is decoded and the remainder\n   * of the CAR is parsed as the `Block`s as yielded.\n   *\n   * @async\n   * @static\n   * @memberof CarBlockIterator\n   * @param {Uint8Array} bytes\n   * @returns {Promise<CarBlockIterator>}\n   */\n  static async fromBytes (bytes) {\n    const { version, roots, iterator } = await fromBytes(bytes)\n    return new CarBlockIterator(version, roots, iterator)\n  }\n\n  /**\n   * Instantiate a {@link CarBlockIterator} from a `AsyncIterable<Uint8Array>`,\n   * such as a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).\n   * Rather than decoding the entire byte array prior to returning the iterator,\n   * as in {@link CarReader.fromIterable}, only the header is decoded and the\n   * remainder of the CAR is parsed as the `Block`s as yielded.\n   *\n   * @async\n   * @static\n   * @param {AsyncIterable<Uint8Array>} asyncIterable\n   * @returns {Promise<CarBlockIterator>}\n   */\n  static async fromIterable (asyncIterable) {\n    const { version, roots, iterator } = await fromIterable(asyncIterable)\n    return new CarBlockIterator(version, roots, iterator)\n  }\n}\n\n/**\n * Provides an iterator over all of the `CID`s in a CAR. Implements a\n * `CIDIterator` interface, or `AsyncIterable<CID>`. Similar to\n * {@link CarBlockIterator} but only yields the CIDs in the CAR.\n *\n * As an implementer of `AsyncIterable`, this class can be used directly in a\n * `for await (const cid of iterator) {}` loop. Where the `iterator` is\n * constructed using {@link CarCIDiterator.fromBytes} or\n * {@link CarCIDiterator.fromIterable}.\n *\n * An iteration can only be performce _once_ per instantiation.\n *\n * `CarCIDIterator` also implements the `RootsReader` interface and provides\n * the {@link CarCIDiterator.getRoots `getRoots()`} method.\n *\n * Load this class with either\n * `import { CarCIDIterator } from '@ipld/car/iterator'`\n * (`const { CarCIDIterator } = require('@ipld/car/iterator')`). Or\n * `import { CarCIDIterator } from '@ipld/car'`\n * (`const { CarCIDIterator } = require('@ipld/car')`).\n *\n * @name CarCIDIterator\n * @class\n * @implements {RootsReader}\n * @implements {AsyncIterable<CID>}\n * @property {number} version The version number of the CAR referenced by this\n * iterator (should be `1`).\n */\nexport class CarCIDIterator extends CarIteratorBase {\n  // inherited method\n  /**\n   * Get the list of roots defined by the CAR referenced by this iterator. May be\n   * zero or more `CID`s.\n   *\n   * @function getRoots\n   * @memberof CarCIDIterator\n   * @instance\n   * @async\n   * @returns {Promise<CID[]>}\n   */\n\n  /**\n   * @returns {AsyncIterator<CID>}\n   */\n  [Symbol.asyncIterator] () {\n    if (this._decoded) {\n      throw new Error('Cannot decode more than once')\n    }\n    /* c8 ignore next 3 */\n    if (!this._iterable) {\n      throw new Error('Block iterable not found')\n    }\n    this._decoded = true\n    const iterable = this._iterable[Symbol.asyncIterator]()\n    return {\n      async next () {\n        const next = await iterable.next()\n        if (next.done) {\n          return next\n        }\n        return { done: false, value: next.value.cid }\n      }\n    }\n  }\n\n  /**\n   * Instantiate a {@link CarCIDIterator} from a `Uint8Array` blob. Rather\n   * than decoding the entire byte array prior to returning the iterator, as in\n   * {@link CarReader.fromBytes}, only the header is decoded and the remainder\n   * of the CAR is parsed as the `CID`s as yielded.\n   *\n   * @async\n   * @static\n   * @memberof CarCIDIterator\n   * @param {Uint8Array} bytes\n   * @returns {Promise<CarCIDIterator>}\n   */\n  static async fromBytes (bytes) {\n    const { version, roots, iterator } = await fromBytes(bytes)\n    return new CarCIDIterator(version, roots, iterator)\n  }\n\n  /**\n   * Instantiate a {@link CarCIDIterator} from a `AsyncIterable<Uint8Array>`,\n   * such as a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).\n   * Rather than decoding the entire byte array prior to returning the iterator,\n   * as in {@link CarReader.fromIterable}, only the header is decoded and the\n   * remainder of the CAR is parsed as the `CID`s as yielded.\n   *\n   * @async\n   * @static\n   * @memberof CarCIDIterator\n   * @param {AsyncIterable<Uint8Array>} asyncIterable\n   * @returns {Promise<CarCIDIterator>}\n   */\n  static async fromIterable (asyncIterable) {\n    const { version, roots, iterator } = await fromIterable(asyncIterable)\n    return new CarCIDIterator(version, roots, iterator)\n  }\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {Promise<{ version:number, roots:CID[], iterator:AsyncIterable<Block>}>}\n */\nasync function fromBytes (bytes) {\n  if (!(bytes instanceof Uint8Array)) {\n    throw new TypeError('fromBytes() requires a Uint8Array')\n  }\n  return decodeIterator(bytesReader(bytes))\n}\n\n/**\n * @param {AsyncIterable<Uint8Array>} asyncIterable\n * @returns {Promise<{ version:number, roots:CID[], iterator:AsyncIterable<Block>}>}\n */\nasync function fromIterable (asyncIterable) {\n  if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === 'function')) {\n    throw new TypeError('fromIterable() requires an async iterable')\n  }\n  return decodeIterator(asyncIterableReader(asyncIterable))\n}\n\n/**\n * @private\n * @param {BytesReader} reader\n * @returns {Promise<{ version:number, roots:CID[], iterator:AsyncIterable<Block>}>}\n */\nasync function decodeIterator (reader) {\n  const decoder = createDecoder(reader)\n  const { version, roots } = await decoder.header()\n  return { version, roots, iterator: decoder.blocks() }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3372, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/car/src/encoder.js"],"sourcesContent":["import { encode as dagCborEncode } from '@ipld/dag-cbor'\nimport varint from 'varint'\n\n/**\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('./api.js').Block} Block\n * @typedef {import('./coding.js').CarEncoder} CarEncoder\n * @typedef {import('./coding.js').IteratorChannel_Writer<Uint8Array>} IteratorChannel_Writer\n */\n\nconst CAR_V1_VERSION = 1\n\n/**\n * Create a header from an array of roots.\n *\n * @param {CID[]} roots\n * @returns {Uint8Array}\n */\nexport function createHeader (roots) {\n  const headerBytes = dagCborEncode({ version: CAR_V1_VERSION, roots })\n  const varintBytes = varint.encode(headerBytes.length)\n  const header = new Uint8Array(varintBytes.length + headerBytes.length)\n  header.set(varintBytes, 0)\n  header.set(headerBytes, varintBytes.length)\n  return header\n}\n\n/**\n * @param {IteratorChannel_Writer} writer\n * @returns {CarEncoder}\n */\nfunction createEncoder (writer) {\n  // none of this is wrapped in a mutex, that needs to happen above this to\n  // avoid overwrites\n\n  return {\n    /**\n     * @param {CID[]} roots\n     * @returns {Promise<void>}\n     */\n    async setRoots (roots) {\n      const bytes = createHeader(roots)\n      await writer.write(bytes)\n    },\n\n    /**\n     * @param {Block} block\n     * @returns {Promise<void>}\n     */\n    async writeBlock (block) {\n      const { cid, bytes } = block\n      await writer.write(new Uint8Array(varint.encode(cid.bytes.length + bytes.length)))\n      await writer.write(cid.bytes)\n      if (bytes.length) {\n        // zero-length blocks are valid, but it'd be safer if we didn't write them\n        await writer.write(bytes)\n      }\n    },\n\n    /**\n     * @returns {Promise<void>}\n     */\n    async close () {\n      await writer.end()\n    },\n\n    /**\n     * @returns {number}\n     */\n    version () {\n      return CAR_V1_VERSION\n    }\n  }\n}\n\nexport { createEncoder }\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAEA;;;;;CAKC,GAED,MAAM,iBAAiB;AAQhB,SAAS,aAAc,KAAK;IACjC,MAAM,cAAc,IAAA,iKAAa,EAAC;QAAE,SAAS;QAAgB;IAAM;IACnE,MAAM,cAAc,4IAAM,CAAC,MAAM,CAAC,YAAY,MAAM;IACpD,MAAM,SAAS,IAAI,WAAW,YAAY,MAAM,GAAG,YAAY,MAAM;IACrE,OAAO,GAAG,CAAC,aAAa;IACxB,OAAO,GAAG,CAAC,aAAa,YAAY,MAAM;IAC1C,OAAO;AACT;AAEA;;;CAGC,GACD,SAAS,cAAe,MAAM;IAC5B,yEAAyE;IACzE,mBAAmB;IAEnB,OAAO;QACL;;;KAGC,GACD,MAAM,UAAU,KAAK;YACnB,MAAM,QAAQ,aAAa;YAC3B,MAAM,OAAO,KAAK,CAAC;QACrB;QAEA;;;KAGC,GACD,MAAM,YAAY,KAAK;YACrB,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG;YACvB,MAAM,OAAO,KAAK,CAAC,IAAI,WAAW,4IAAM,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,MAAM,GAAG,MAAM,MAAM;YAC/E,MAAM,OAAO,KAAK,CAAC,IAAI,KAAK;YAC5B,IAAI,MAAM,MAAM,EAAE;gBAChB,0EAA0E;gBAC1E,MAAM,OAAO,KAAK,CAAC;YACrB;QACF;QAEA;;KAEC,GACD,MAAM;YACJ,MAAM,OAAO,GAAG;QAClB;QAEA;;KAEC,GACD;YACE,OAAO;QACT;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 3442, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/car/src/iterator-channel.js"],"sourcesContent":["/**\n * @template {any} T\n * @typedef {import('./coding.js').IteratorChannel<T>} IteratorChannel\n */\n\nfunction noop () {}\n\n/**\n * @template {any} T\n * @returns {IteratorChannel<T>}\n */\nexport function create () {\n  /** @type {T[]} */\n  const chunkQueue = []\n  /** @type {Promise<void> | null} */\n  let drainer = null\n  let drainerResolver = noop\n  let ended = false\n  /** @type {Promise<IteratorResult<T>> | null} */\n  let outWait = null\n  let outWaitResolver = noop\n\n  const makeDrainer = () => {\n    if (!drainer) {\n      drainer = new Promise((resolve) => {\n        drainerResolver = () => {\n          drainer = null\n          drainerResolver = noop\n          resolve()\n        }\n      })\n    }\n    return drainer\n  }\n\n  /**\n   * @returns {IteratorChannel<T>}\n   */\n  const writer = {\n    /**\n     * @param {T} chunk\n     * @returns {Promise<void>}\n     */\n    write (chunk) {\n      chunkQueue.push(chunk)\n      const drainer = makeDrainer()\n      outWaitResolver()\n      return drainer\n    },\n\n    async end () {\n      ended = true\n      const drainer = makeDrainer()\n      outWaitResolver()\n      await drainer\n    }\n  }\n\n  /** @type {AsyncIterator<T>} */\n  const iterator = {\n    /** @returns {Promise<IteratorResult<T>>} */\n    async next () {\n      const chunk = chunkQueue.shift()\n      if (chunk) {\n        if (chunkQueue.length === 0) {\n          drainerResolver()\n        }\n        return { done: false, value: chunk }\n      }\n\n      if (ended) {\n        drainerResolver()\n        return { done: true, value: undefined }\n      }\n\n      if (!outWait) {\n        outWait = new Promise((resolve) => {\n          outWaitResolver = () => {\n            outWait = null\n            outWaitResolver = noop\n            return resolve(iterator.next())\n          }\n        })\n      }\n\n      return outWait\n    }\n  }\n\n  return { writer, iterator }\n}\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;AAED,SAAS,QAAS;AAMX,SAAS;IACd,gBAAgB,GAChB,MAAM,aAAa,EAAE;IACrB,iCAAiC,GACjC,IAAI,UAAU;IACd,IAAI,kBAAkB;IACtB,IAAI,QAAQ;IACZ,8CAA8C,GAC9C,IAAI,UAAU;IACd,IAAI,kBAAkB;IAEtB,MAAM,cAAc;QAClB,IAAI,CAAC,SAAS;YACZ,UAAU,IAAI,QAAQ,CAAC;gBACrB,kBAAkB;oBAChB,UAAU;oBACV,kBAAkB;oBAClB;gBACF;YACF;QACF;QACA,OAAO;IACT;IAEA;;GAEC,GACD,MAAM,SAAS;QACb;;;KAGC,GACD,OAAO,KAAK;YACV,WAAW,IAAI,CAAC;YAChB,MAAM,UAAU;YAChB;YACA,OAAO;QACT;QAEA,MAAM;YACJ,QAAQ;YACR,MAAM,UAAU;YAChB;YACA,MAAM;QACR;IACF;IAEA,6BAA6B,GAC7B,MAAM,WAAW;QACf,0CAA0C,GAC1C,MAAM;YACJ,MAAM,QAAQ,WAAW,KAAK;YAC9B,IAAI,OAAO;gBACT,IAAI,WAAW,MAAM,KAAK,GAAG;oBAC3B;gBACF;gBACA,OAAO;oBAAE,MAAM;oBAAO,OAAO;gBAAM;YACrC;YAEA,IAAI,OAAO;gBACT;gBACA,OAAO;oBAAE,MAAM;oBAAM,OAAO;gBAAU;YACxC;YAEA,IAAI,CAAC,SAAS;gBACZ,UAAU,IAAI,QAAQ,CAAC;oBACrB,kBAAkB;wBAChB,UAAU;wBACV,kBAAkB;wBAClB,OAAO,QAAQ,SAAS,IAAI;oBAC9B;gBACF;YACF;YAEA,OAAO;QACT;IACF;IAEA,OAAO;QAAE;QAAQ;IAAS;AAC5B","ignoreList":[0]}},
    {"offset": {"line": 3528, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/car/src/writer-browser.js"],"sourcesContent":["import { CID } from 'multiformats/cid'\nimport { bytesReader, readHeader } from './decoder.js'\nimport { createEncoder, createHeader } from './encoder.js'\nimport { create as iteratorChannel } from './iterator-channel.js'\n\n/**\n * @typedef {import('./api.js').Block} Block\n * @typedef {import('./api.js').BlockWriter} BlockWriter\n * @typedef {import('./api.js').WriterChannel} WriterChannel\n * @typedef {import('./coding.js').CarEncoder} CarEncoder\n * @typedef {import('./coding.js').IteratorChannel<Uint8Array>} IteratorChannel\n */\n\n/**\n * Provides a writer interface for the creation of CAR files.\n *\n * Creation of a `CarWriter` involves the instatiation of an input / output pair\n * in the form of a `WriterChannel`, which is a\n * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair. These two\n * components form what can be thought of as a stream-like interface. The\n * `writer` component (an instantiated `CarWriter`), has methods to\n * {@link CarWriter.put `put()`} new blocks and {@link CarWriter.put `close()`}\n * the writing operation (finalising the CAR archive). The `out` component is\n * an `AsyncIterable` that yields the bytes of the archive. This can be\n * redirected to a file or other sink. In Node.js, you can use the\n * [`Readable.from()`](https://nodejs.org/api/stream.html#stream_stream_readable_from_iterable_options)\n * API to convert this to a standard Node.js stream, or it can be directly fed\n * to a\n * [`stream.pipeline()`](https://nodejs.org/api/stream.html#stream_stream_pipeline_source_transforms_destination_callback).\n *\n * The channel will provide a form of backpressure. The `Promise` from a\n * `write()` won't resolve until the resulting data is drained from the `out`\n * iterable.\n *\n * It is also possible to ignore the `Promise` from `write()` calls and allow\n * the generated data to queue in memory. This should be avoided for large CAR\n * archives of course due to the memory costs and potential for memory overflow.\n *\n * Load this class with either\n * `import { CarWriter } from '@ipld/car/writer'`\n * (`const { CarWriter } = require('@ipld/car/writer')`). Or\n * `import { CarWriter } from '@ipld/car'`\n * (`const { CarWriter } = require('@ipld/car')`). The former will likely\n * result in smaller bundle sizes where this is important.\n *\n * @name CarWriter\n * @class\n * @implements {BlockWriter}\n */\nexport class CarWriter {\n  /**\n   * @param {CID[]} roots\n   * @param {CarEncoder} encoder\n   */\n  constructor (roots, encoder) {\n    this._encoder = encoder\n    /** @type {Promise<void>} */\n    this._mutex = encoder.setRoots(roots)\n    this._ended = false\n  }\n\n  /**\n   * Write a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) to the archive.\n   *\n   * @function\n   * @memberof CarWriter\n   * @instance\n   * @async\n   * @param {Block} block - A `{ cid:CID, bytes:Uint8Array }` pair.\n   * @returns {Promise<void>} The returned promise will only resolve once the\n   * bytes this block generates are written to the `out` iterable.\n   */\n  async put (block) {\n    if (!(block.bytes instanceof Uint8Array) || !block.cid) {\n      throw new TypeError('Can only write {cid, bytes} objects')\n    }\n    if (this._ended) {\n      throw new Error('Already closed')\n    }\n    const cid = CID.asCID(block.cid)\n    if (!cid) {\n      throw new TypeError('Can only write {cid, bytes} objects')\n    }\n    this._mutex = this._mutex.then(() => this._encoder.writeBlock({ cid, bytes: block.bytes }))\n    return this._mutex\n  }\n\n  /**\n   * Finalise the CAR archive and signal that the `out` iterable should end once\n   * any remaining bytes are written.\n   *\n   * @function\n   * @memberof CarWriter\n   * @instance\n   * @async\n   * @returns {Promise<void>}\n   */\n  async close () {\n    if (this._ended) {\n      throw new Error('Already closed')\n    }\n    await this._mutex\n    this._ended = true\n    return this._encoder.close()\n  }\n\n  /**\n   * Returns the version number of the CAR file being written\n   *\n   * @returns {number}\n   */\n  version () {\n    return this._encoder.version()\n  }\n\n  /**\n   * Create a new CAR writer \"channel\" which consists of a\n   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair.\n   *\n   * @async\n   * @static\n   * @memberof CarWriter\n   * @param {CID[] | CID | void} roots\n   * @returns {WriterChannel} The channel takes the form of\n   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }`.\n   */\n  static create (roots) {\n    roots = toRoots(roots)\n    const { encoder, iterator } = encodeWriter()\n    const writer = new CarWriter(roots, encoder)\n    const out = new CarWriterOut(iterator)\n    return { writer, out }\n  }\n\n  /**\n   * Create a new CAR appender \"channel\" which consists of a\n   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair.\n   * This appender does not consider roots and does not produce a CAR header.\n   * It is designed to append blocks to an _existing_ CAR archive. It is\n   * expected that `out` will be concatenated onto the end of an existing\n   * archive that already has a properly formatted header.\n   *\n   * @async\n   * @static\n   * @memberof CarWriter\n   * @returns {WriterChannel} The channel takes the form of\n   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }`.\n   */\n  static createAppender () {\n    const { encoder, iterator } = encodeWriter()\n    encoder.setRoots = () => Promise.resolve()\n    const writer = new CarWriter([], encoder)\n    const out = new CarWriterOut(iterator)\n    return { writer, out }\n  }\n\n  /**\n   * Update the list of roots in the header of an existing CAR as represented\n   * in a Uint8Array.\n   *\n   * This operation is an _overwrite_, the total length of the CAR will not be\n   * modified. A rejection will occur if the new header will not be the same\n   * length as the existing header, in which case the CAR will not be modified.\n   * It is the responsibility of the user to ensure that the roots being\n   * replaced encode as the same length as the new roots.\n   *\n   * The byte array passed in an argument will be modified and also returned\n   * upon successful modification.\n   *\n   * @async\n   * @static\n   * @memberof CarWriter\n   * @param {Uint8Array} bytes\n   * @param {CID[]} roots - A new list of roots to replace the existing list in\n   * the CAR header. The new header must take up the same number of bytes as the\n   * existing header, so the roots should collectively be the same byte length\n   * as the existing roots.\n   * @returns {Promise<Uint8Array>}\n   */\n  static async updateRootsInBytes (bytes, roots) {\n    const reader = bytesReader(bytes)\n    await readHeader(reader)\n    const newHeader = createHeader(roots)\n    if (Number(reader.pos) !== newHeader.length) {\n      throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${reader.pos} bytes, new header is ${newHeader.length} bytes)`)\n    }\n    bytes.set(newHeader, 0)\n    return bytes\n  }\n}\n\n/**\n * @class\n * @implements {AsyncIterable<Uint8Array>}\n */\nexport class CarWriterOut {\n  /**\n   * @param {AsyncIterator<Uint8Array>} iterator\n   */\n  constructor (iterator) {\n    this._iterator = iterator\n  }\n\n  [Symbol.asyncIterator] () {\n    if (this._iterating) {\n      throw new Error('Multiple iterator not supported')\n    }\n    this._iterating = true\n    return this._iterator\n  }\n}\n\nfunction encodeWriter () {\n  /** @type {IteratorChannel} */\n  const iw = iteratorChannel()\n  const { writer, iterator } = iw\n  const encoder = createEncoder(writer)\n  return { encoder, iterator }\n}\n\n/**\n * @private\n * @param {CID[] | CID | void} roots\n * @returns {CID[]}\n */\nfunction toRoots (roots) {\n  if (roots === undefined) {\n    return []\n  }\n\n  if (!Array.isArray(roots)) {\n    const cid = CID.asCID(roots)\n    if (!cid) {\n      throw new TypeError('roots must be a single CID or an array of CIDs')\n    }\n    return [cid]\n  }\n\n  const _roots = []\n  for (const root of roots) {\n    const _root = CID.asCID(root)\n    if (!_root) {\n      throw new TypeError('roots must be a single CID or an array of CIDs')\n    }\n    _roots.push(_root)\n  }\n  return _roots\n}\n\nexport const __browser = true\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3735, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/car/src/writer.js"],"sourcesContent":["import { readHeader, chunkReader } from './decoder.js'\nimport { createHeader } from './encoder.js'\nimport { fsread, fswrite, hasFS } from './promise-fs-opts.js'\nimport { CarWriter as BrowserCarWriter } from './writer-browser.js'\n\n/**\n * @typedef {import('multiformats/cid').CID} CID\n * @typedef {import('./api.js').BlockWriter} BlockWriter\n * @typedef {import('fs').promises.FileHandle} FileHandle\n */\n\n/**\n * @class\n * @implements {BlockWriter}\n */\nexport class CarWriter extends BrowserCarWriter {\n  /**\n   * Update the list of roots in the header of an existing CAR file. The first\n   * argument must be a file descriptor for CAR file that is open in read and\n   * write mode (not append), e.g. `fs.open` or `fs.promises.open` with `'r+'`\n   * mode.\n   *\n   * This operation is an _overwrite_, the total length of the CAR will not be\n   * modified. A rejection will occur if the new header will not be the same\n   * length as the existing header, in which case the CAR will not be modified.\n   * It is the responsibility of the user to ensure that the roots being\n   * replaced encode as the same length as the new roots.\n   *\n   * This function is **only available in Node.js** and not a browser\n   * environment.\n   *\n   * @async\n   * @static\n   * @memberof CarWriter\n   * @param {FileHandle | number} fd - A file descriptor from the\n   * Node.js `fs` module. Either an integer, from `fs.open()` or a `FileHandle`\n   * from `fs.promises.open()`.\n   * @param {CID[]} roots - A new list of roots to replace the existing list in\n   * the CAR header. The new header must take up the same number of bytes as the\n   * existing header, so the roots should collectively be the same byte length\n   * as the existing roots.\n   * @returns {Promise<void>}\n   */\n  static async updateRootsInFile (fd, roots) {\n    const chunkSize = 256\n    /** @type {Uint8Array} */\n    let bytes\n    let offset = 0\n\n    /** @type {() => Promise<number>} */\n    let readChunk\n    if (typeof fd === 'number') {\n      readChunk = async () => (await fsread(fd, bytes, 0, chunkSize, offset)).bytesRead\n    } else if (typeof fd === 'object' && typeof fd.read === 'function') { // FileDescriptor\n      readChunk = async () => (await fd.read(bytes, 0, chunkSize, offset)).bytesRead\n    } else {\n      throw new TypeError('Bad fd')\n    }\n    const fdReader = chunkReader(async () => {\n      bytes = new Uint8Array(chunkSize) // need a new chunk each time, can't reuse old\n      const read = await readChunk()\n      offset += read\n      /* eslint no-warning-comments: 0 */\n      // TODO: test header > 256 bytes\n      return read < chunkSize ? bytes.subarray(0, read) : bytes\n    })\n\n    await readHeader(fdReader)\n    const newHeader = createHeader(roots)\n    if (fdReader.pos !== newHeader.length) {\n      throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${fdReader.pos} bytes, new header is ${newHeader.length} bytes)`)\n    }\n    if (typeof fd === 'number') {\n      await fswrite(fd, newHeader, 0, newHeader.length, 0)\n    } else if (typeof fd === 'object' && typeof fd.read === 'function') { // FileDescriptor\n      await fd.write(newHeader, 0, newHeader.length, 0)\n    }\n  }\n}\n\nexport const __browser = !hasFS\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;;;;;AAYO,MAAM,kBAAkB,wKAAgB;IAC7C;;;;;;;;;;;;;;;;;;;;;;;;;;GA0BC,GACD,aAAa,kBAAmB,EAAE,EAAE,KAAK,EAAE;QACzC,MAAM,YAAY;QAClB,uBAAuB,GACvB,IAAI;QACJ,IAAI,SAAS;QAEb,kCAAkC,GAClC,IAAI;QACJ,IAAI,OAAO,OAAO,UAAU;YAC1B,YAAY,UAAY,CAAC,MAAM,IAAA,yKAAM,EAAC,IAAI,OAAO,GAAG,WAAW,OAAO,EAAE,SAAS;QACnF,OAAO,IAAI,OAAO,OAAO,YAAY,OAAO,GAAG,IAAI,KAAK,YAAY;YAClE,YAAY,UAAY,CAAC,MAAM,GAAG,IAAI,CAAC,OAAO,GAAG,WAAW,OAAO,EAAE,SAAS;QAChF,OAAO;YACL,MAAM,IAAI,UAAU;QACtB;QACA,MAAM,WAAW,IAAA,gKAAW,EAAC;YAC3B,QAAQ,IAAI,WAAW,YAAW,8CAA8C;YAChF,MAAM,OAAO,MAAM;YACnB,UAAU;YACV,iCAAiC,GACjC,gCAAgC;YAChC,OAAO,OAAO,YAAY,MAAM,QAAQ,CAAC,GAAG,QAAQ;QACtD;QAEA,MAAM,IAAA,+JAAU,EAAC;QACjB,MAAM,YAAY,IAAA,iKAAY,EAAC;QAC/B,IAAI,SAAS,GAAG,KAAK,UAAU,MAAM,EAAE;YACrC,MAAM,IAAI,MAAM,CAAC,4EAA4E,EAAE,SAAS,GAAG,CAAC,sBAAsB,EAAE,UAAU,MAAM,CAAC,OAAO,CAAC;QAC/J;QACA,IAAI,OAAO,OAAO,UAAU;YAC1B,MAAM,IAAA,0KAAO,EAAC,IAAI,WAAW,GAAG,UAAU,MAAM,EAAE;QACpD,OAAO,IAAI,OAAO,OAAO,YAAY,OAAO,GAAG,IAAI,KAAK,YAAY;YAClE,MAAM,GAAG,KAAK,CAAC,WAAW,GAAG,UAAU,MAAM,EAAE;QACjD;IACF;AACF;AAEO,MAAM,YAAY,CAAC,wKAAK","ignoreList":[0]}},
    {"offset": {"line": 3812, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/car/src/index.js"],"sourcesContent":["import { CarBufferReader } from './buffer-reader.js'\nimport * as CarBufferWriter from './buffer-writer.js'\nimport { CarIndexedReader } from './indexed-reader.js'\nimport { CarIndexer } from './indexer.js'\nimport { CarBlockIterator, CarCIDIterator } from './iterator.js'\nimport { CarReader } from './reader.js'\nimport { CarWriter } from './writer.js'\n\n// @see https://www.iana.org/assignments/media-types/application/vnd.ipld.car\nexport const contentType = 'application/vnd.ipld.car'\n\nexport {\n  CarReader,\n  CarBufferReader,\n  CarIndexer,\n  CarBlockIterator,\n  CarCIDIterator,\n  CarWriter,\n  CarIndexedReader,\n  CarBufferWriter\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAGO,MAAM,cAAc","ignoreList":[0]}},
    {"offset": {"line": 3836, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/dag-pb/src/pb-decode.js"],"sourcesContent":["const textDecoder = new TextDecoder()\n\n/**\n * @typedef {import('./interface.js').RawPBLink} RawPBLink\n */\n\n/**\n * @typedef {import('./interface.js').RawPBNode} RawPBNode\n */\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {[number, number]}\n */\nfunction decodeVarint (bytes, offset) {\n  let v = 0\n\n  for (let shift = 0; ; shift += 7) {\n    /* c8 ignore next 3 */\n    if (shift >= 64) {\n      throw new Error('protobuf: varint overflow')\n    }\n    /* c8 ignore next 3 */\n    if (offset >= bytes.length) {\n      throw new Error('protobuf: unexpected end of data')\n    }\n\n    const b = bytes[offset++]\n    v += shift < 28 ? (b & 0x7f) << shift : (b & 0x7f) * (2 ** shift)\n    if (b < 0x80) {\n      break\n    }\n  }\n  return [v, offset]\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @returns {[Uint8Array, number]}\n */\nfunction decodeBytes (bytes, offset) {\n  let byteLen\n  ;[byteLen, offset] = decodeVarint(bytes, offset)\n  const postOffset = offset + byteLen\n\n  /* c8 ignore next 3 */\n  if (byteLen < 0 || postOffset < 0) {\n    throw new Error('protobuf: invalid length')\n  }\n  /* c8 ignore next 3 */\n  if (postOffset > bytes.length) {\n    throw new Error('protobuf: unexpected end of data')\n  }\n\n  return [bytes.subarray(offset, postOffset), postOffset]\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} index\n * @returns {[number, number, number]}\n */\nfunction decodeKey (bytes, index) {\n  let wire\n  ;[wire, index] = decodeVarint(bytes, index)\n  // [wireType, fieldNum, newIndex]\n  return [wire & 0x7, wire >> 3, index]\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {RawPBLink}\n */\nfunction decodeLink (bytes) {\n  /** @type {RawPBLink} */\n  const link = {}\n  const l = bytes.length\n  let index = 0\n\n  while (index < l) {\n    let wireType, fieldNum\n    ;[wireType, fieldNum, index] = decodeKey(bytes, index)\n\n    if (fieldNum === 1) {\n      if (link.Hash) {\n        throw new Error('protobuf: (PBLink) duplicate Hash section')\n      }\n      if (wireType !== 2) {\n        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`)\n      }\n      if (link.Name !== undefined) {\n        throw new Error('protobuf: (PBLink) invalid order, found Name before Hash')\n      }\n      if (link.Tsize !== undefined) {\n        throw new Error('protobuf: (PBLink) invalid order, found Tsize before Hash')\n      }\n\n      [link.Hash, index] = decodeBytes(bytes, index)\n    } else if (fieldNum === 2) {\n      if (link.Name !== undefined) {\n        throw new Error('protobuf: (PBLink) duplicate Name section')\n      }\n      if (wireType !== 2) {\n        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`)\n      }\n      if (link.Tsize !== undefined) {\n        throw new Error('protobuf: (PBLink) invalid order, found Tsize before Name')\n      }\n\n      let byts\n      ;[byts, index] = decodeBytes(bytes, index)\n      link.Name = textDecoder.decode(byts)\n    } else if (fieldNum === 3) {\n      if (link.Tsize !== undefined) {\n        throw new Error('protobuf: (PBLink) duplicate Tsize section')\n      }\n      if (wireType !== 0) {\n        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`)\n      }\n\n      [link.Tsize, index] = decodeVarint(bytes, index)\n    } else {\n      throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`)\n    }\n  }\n\n  /* c8 ignore next 3 */\n  if (index > l) {\n    throw new Error('protobuf: (PBLink) unexpected end of data')\n  }\n\n  return link\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {RawPBNode}\n */\nexport function decodeNode (bytes) {\n  const l = bytes.length\n  let index = 0\n  /** @type {RawPBLink[]|void} */\n  let links = undefined // eslint-disable-line no-undef-init\n  let linksBeforeData = false\n  /** @type {Uint8Array|void} */\n  let data = undefined // eslint-disable-line no-undef-init\n\n  while (index < l) {\n    let wireType, fieldNum\n    ;[wireType, fieldNum, index] = decodeKey(bytes, index)\n\n    if (wireType !== 2) {\n      throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`)\n    }\n\n    if (fieldNum === 1) {\n      if (data) {\n        throw new Error('protobuf: (PBNode) duplicate Data section')\n      }\n\n      [data, index] = decodeBytes(bytes, index)\n      if (links) {\n        linksBeforeData = true\n      }\n    } else if (fieldNum === 2) {\n      if (linksBeforeData) { // interleaved Links/Data/Links\n        throw new Error('protobuf: (PBNode) duplicate Links section')\n      } else if (!links) {\n        links = []\n      }\n      let byts\n      ;[byts, index] = decodeBytes(bytes, index)\n      links.push(decodeLink(byts))\n    } else {\n      throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`)\n    }\n  }\n\n  /* c8 ignore next 3 */\n  if (index > l) {\n    throw new Error('protobuf: (PBNode) unexpected end of data')\n  }\n\n  /** @type {RawPBNode} */\n  const node = {}\n  if (data) {\n    node.Data = data\n  }\n  node.Links = links || []\n  return node\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4005, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/dag-pb/src/pb-encode.js"],"sourcesContent":["const textEncoder = new TextEncoder()\nconst maxInt32 = 2 ** 32\nconst maxUInt32 = 2 ** 31\n\n/**\n * @typedef {import('./interface.js').RawPBLink} RawPBLink\n */\n\n/**\n * @typedef {import('./interface.js').RawPBNode} RawPBNode\n */\n\n// the encoders work backward from the end of the bytes array\n\n/**\n * encodeLink() is passed a slice of the parent byte array that ends where this\n * link needs to end, so it packs to the right-most part of the passed `bytes`\n *\n * @param {RawPBLink} link\n * @param {Uint8Array} bytes\n * @returns {number}\n */\nfunction encodeLink (link, bytes) {\n  let i = bytes.length\n\n  if (typeof link.Tsize === 'number') {\n    if (link.Tsize < 0) {\n      throw new Error('Tsize cannot be negative')\n    }\n    if (!Number.isSafeInteger(link.Tsize)) {\n      throw new Error('Tsize too large for encoding')\n    }\n    i = encodeVarint(bytes, i, link.Tsize) - 1\n    bytes[i] = 0x18\n  }\n\n  if (typeof link.Name === 'string') {\n    const nameBytes = textEncoder.encode(link.Name)\n    i -= nameBytes.length\n    bytes.set(nameBytes, i)\n    i = encodeVarint(bytes, i, nameBytes.length) - 1\n    bytes[i] = 0x12\n  }\n\n  if (link.Hash) {\n    i -= link.Hash.length\n    bytes.set(link.Hash, i)\n    i = encodeVarint(bytes, i, link.Hash.length) - 1\n    bytes[i] = 0xa\n  }\n\n  return bytes.length - i\n}\n\n/**\n * Encodes a PBNode into a new byte array of precisely the correct size\n *\n * @param {RawPBNode} node\n * @returns {Uint8Array}\n */\nexport function encodeNode (node) {\n  const size = sizeNode(node)\n  const bytes = new Uint8Array(size)\n  let i = size\n\n  if (node.Data) {\n    i -= node.Data.length\n    bytes.set(node.Data, i)\n    i = encodeVarint(bytes, i, node.Data.length) - 1\n    bytes[i] = 0xa\n  }\n\n  if (node.Links) {\n    for (let index = node.Links.length - 1; index >= 0; index--) {\n      const size = encodeLink(node.Links[index], bytes.subarray(0, i))\n      i -= size\n      i = encodeVarint(bytes, i, size) - 1\n      bytes[i] = 0x12\n    }\n  }\n\n  return bytes\n}\n\n/**\n * work out exactly how many bytes this link takes up\n *\n * @param {RawPBLink} link\n * @returns\n */\nfunction sizeLink (link) {\n  let n = 0\n\n  if (link.Hash) {\n    const l = link.Hash.length\n    n += 1 + l + sov(l)\n  }\n\n  if (typeof link.Name === 'string') {\n    const l = textEncoder.encode(link.Name).length\n    n += 1 + l + sov(l)\n  }\n\n  if (typeof link.Tsize === 'number') {\n    n += 1 + sov(link.Tsize)\n  }\n\n  return n\n}\n\n/**\n * Work out exactly how many bytes this node takes up\n *\n * @param {RawPBNode} node\n * @returns {number}\n */\nfunction sizeNode (node) {\n  let n = 0\n\n  if (node.Data) {\n    const l = node.Data.length\n    n += 1 + l + sov(l)\n  }\n\n  if (node.Links) {\n    for (const link of node.Links) {\n      const l = sizeLink(link)\n      n += 1 + l + sov(l)\n    }\n  }\n\n  return n\n}\n\n/**\n * @param {Uint8Array} bytes\n * @param {number} offset\n * @param {number} v\n * @returns {number}\n */\nfunction encodeVarint (bytes, offset, v) {\n  offset -= sov(v)\n  const base = offset\n\n  while (v >= maxUInt32) {\n    bytes[offset++] = (v & 0x7f) | 0x80\n    v /= 128\n  }\n\n  while (v >= 128) {\n    bytes[offset++] = (v & 0x7f) | 0x80\n    v >>>= 7\n  }\n\n  bytes[offset] = v\n\n  return base\n}\n\n/**\n * size of varint\n *\n * @param {number} x\n * @returns {number}\n */\nfunction sov (x) {\n  if (x % 2 === 0) {\n    x++\n  }\n  return Math.floor((len64(x) + 6) / 7)\n}\n\n/**\n * golang math/bits, how many bits does it take to represent this integer?\n *\n * @param {number} x\n * @returns {number}\n */\nfunction len64 (x) {\n  let n = 0\n  if (x >= maxInt32) {\n    x = Math.floor(x / maxInt32)\n    n = 32\n  }\n  if (x >= (1 << 16)) {\n    x >>>= 16\n    n += 16\n  }\n  if (x >= (1 << 8)) {\n    x >>>= 8\n    n += 8\n  }\n  return n + len8tab[x]\n}\n\n// golang math/bits\nconst len8tab = [\n  0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,\n  5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,\n  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8\n]\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4424, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/dag-pb/src/util.js"],"sourcesContent":["import { CID } from 'multiformats/cid'\n\n/* eslint-disable complexity, no-nested-ternary */\n\n/**\n * @typedef {import('./interface.js').PBLink} PBLink\n * @typedef {import('./interface.js').PBNode} PBNode\n */\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView\n */\n\nconst pbNodeProperties = ['Data', 'Links']\nconst pbLinkProperties = ['Hash', 'Name', 'Tsize']\n\nconst textEncoder = new TextEncoder()\n\n/**\n * @param {PBLink} a\n * @param {PBLink} b\n * @returns {number}\n */\nfunction linkComparator (a, b) {\n  if (a === b) {\n    return 0\n  }\n\n  const abuf = a.Name ? textEncoder.encode(a.Name) : []\n  const bbuf = b.Name ? textEncoder.encode(b.Name) : []\n\n  let x = abuf.length\n  let y = bbuf.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (abuf[i] !== bbuf[i]) {\n      x = abuf[i]\n      y = bbuf[i]\n      break\n    }\n  }\n\n  return x < y ? -1 : y < x ? 1 : 0\n}\n\n/**\n * @param {any} node\n * @param {string[]} properties\n * @returns {boolean}\n */\nfunction hasOnlyProperties (node, properties) {\n  return !Object.keys(node).some((p) => !properties.includes(p))\n}\n\n/**\n * Converts a CID, or a PBLink-like object to a PBLink\n *\n * @param {any} link\n * @returns {PBLink}\n */\nfunction asLink (link) {\n  if (typeof link.asCID === 'object') {\n    const Hash = CID.asCID(link)\n    if (!Hash) {\n      throw new TypeError('Invalid DAG-PB form')\n    }\n    return { Hash }\n  }\n\n  if (typeof link !== 'object' || Array.isArray(link)) {\n    throw new TypeError('Invalid DAG-PB form')\n  }\n\n  const pbl = {}\n\n  if (link.Hash) {\n    let cid = CID.asCID(link.Hash)\n    try {\n      if (!cid) {\n        if (typeof link.Hash === 'string') {\n          cid = CID.parse(link.Hash)\n        } else if (link.Hash instanceof Uint8Array) {\n          cid = CID.decode(link.Hash)\n        }\n      }\n    } catch (/** @type {any} */ e) {\n      throw new TypeError(`Invalid DAG-PB form: ${e.message}`)\n    }\n\n    if (cid) {\n      pbl.Hash = cid\n    }\n  }\n\n  if (!pbl.Hash) {\n    throw new TypeError('Invalid DAG-PB form')\n  }\n\n  if (typeof link.Name === 'string') {\n    pbl.Name = link.Name\n  }\n\n  if (typeof link.Tsize === 'number') {\n    pbl.Tsize = link.Tsize\n  }\n\n  return pbl\n}\n\n/**\n * @param {any} node\n * @returns {PBNode}\n */\nexport function prepare (node) {\n  if (node instanceof Uint8Array || typeof node === 'string') {\n    node = { Data: node }\n  }\n\n  if (typeof node !== 'object' || Array.isArray(node)) {\n    throw new TypeError('Invalid DAG-PB form')\n  }\n\n  /** @type {PBNode} */\n  const pbn = {}\n\n  if (node.Data !== undefined) {\n    if (typeof node.Data === 'string') {\n      pbn.Data = textEncoder.encode(node.Data)\n    } else if (node.Data instanceof Uint8Array) {\n      pbn.Data = node.Data\n    } else {\n      throw new TypeError('Invalid DAG-PB form')\n    }\n  }\n\n  if (node.Links !== undefined) {\n    if (Array.isArray(node.Links)) {\n      pbn.Links = node.Links.map(asLink)\n      pbn.Links.sort(linkComparator)\n    } else {\n      throw new TypeError('Invalid DAG-PB form')\n    }\n  } else {\n    pbn.Links = []\n  }\n\n  return pbn\n}\n\n/**\n * @param {PBNode} node\n */\nexport function validate (node) {\n  /*\n  type PBLink struct {\n    Hash optional Link\n    Name optional String\n    Tsize optional Int\n  }\n\n  type PBNode struct {\n    Links [PBLink]\n    Data optional Bytes\n  }\n  */\n  // @ts-ignore private property for TS\n  if (!node || typeof node !== 'object' || Array.isArray(node) || node instanceof Uint8Array || (node['/'] && node['/'] === node.bytes)) {\n    throw new TypeError('Invalid DAG-PB form')\n  }\n\n  if (!hasOnlyProperties(node, pbNodeProperties)) {\n    throw new TypeError('Invalid DAG-PB form (extraneous properties)')\n  }\n\n  if (node.Data !== undefined && !(node.Data instanceof Uint8Array)) {\n    throw new TypeError('Invalid DAG-PB form (Data must be bytes)')\n  }\n\n  if (!Array.isArray(node.Links)) {\n    throw new TypeError('Invalid DAG-PB form (Links must be a list)')\n  }\n\n  for (let i = 0; i < node.Links.length; i++) {\n    const link = node.Links[i]\n    // @ts-ignore private property for TS\n    if (!link || typeof link !== 'object' || Array.isArray(link) || link instanceof Uint8Array || (link['/'] && link['/'] === link.bytes)) {\n      throw new TypeError('Invalid DAG-PB form (bad link)')\n    }\n\n    if (!hasOnlyProperties(link, pbLinkProperties)) {\n      throw new TypeError('Invalid DAG-PB form (extraneous properties on link)')\n    }\n\n    if (link.Hash === undefined) {\n      throw new TypeError('Invalid DAG-PB form (link must have a Hash)')\n    }\n\n    // @ts-ignore private property for TS\n    if (link.Hash == null || !link.Hash['/'] || link.Hash['/'] !== link.Hash.bytes) {\n      throw new TypeError('Invalid DAG-PB form (link Hash must be a CID)')\n    }\n\n    if (link.Name !== undefined && typeof link.Name !== 'string') {\n      throw new TypeError('Invalid DAG-PB form (link Name must be a string)')\n    }\n\n    if (link.Tsize !== undefined) {\n      if (typeof link.Tsize !== 'number' || link.Tsize % 1 !== 0) {\n        throw new TypeError('Invalid DAG-PB form (link Tsize must be an integer)')\n      }\n      if (link.Tsize < 0) {\n        throw new TypeError('Invalid DAG-PB form (link Tsize cannot be negative)')\n      }\n    }\n\n    if (i > 0 && linkComparator(link, node.Links[i - 1]) === -1) {\n      throw new TypeError('Invalid DAG-PB form (links must be sorted by Name bytes)')\n    }\n  }\n}\n\n/**\n * @param {Uint8Array} data\n * @param {PBLink[]} [links]\n * @returns {PBNode}\n */\nexport function createNode (data, links = []) {\n  return prepare({ Data: data, Links: links })\n}\n\n/**\n * @param {string} name\n * @param {number} size\n * @param {CID} cid\n * @returns {PBLink}\n */\nexport function createLink (name, size, cid) {\n  return asLink({ Hash: cid, Name: name, Tsize: size })\n}\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} buf\n * @returns {ByteView<T>}\n */\nexport function toByteView (buf) {\n  if (buf instanceof ArrayBuffer) {\n    return new Uint8Array(buf, 0, buf.byteLength)\n  }\n\n  return buf\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4643, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/dag-pb/src/index.js"],"sourcesContent":["import { CID } from 'multiformats/cid'\nimport { decodeNode } from './pb-decode.js'\nimport { encodeNode } from './pb-encode.js'\nimport { prepare, validate, createNode, createLink, toByteView } from './util.js'\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView\n */\n\n/**\n * @typedef {import('./interface.js').PBLink} PBLink\n * @typedef {import('./interface.js').PBNode} PBNode\n */\n\nexport const name = 'dag-pb'\nexport const code = 0x70\n\n/**\n * @param {PBNode} node\n * @returns {ByteView<PBNode>}\n */\nexport function encode (node) {\n  validate(node)\n\n  const pbn = {}\n  if (node.Links) {\n    pbn.Links = node.Links.map((l) => {\n      const link = {}\n      if (l.Hash) {\n        link.Hash = l.Hash.bytes // cid -> bytes\n      }\n      if (l.Name !== undefined) {\n        link.Name = l.Name\n      }\n      if (l.Tsize !== undefined) {\n        link.Tsize = l.Tsize\n      }\n      return link\n    })\n  }\n  if (node.Data) {\n    pbn.Data = node.Data\n  }\n\n  return encodeNode(pbn)\n}\n\n/**\n * @param {ByteView<PBNode> | ArrayBufferView<PBNode>} bytes\n * @returns {PBNode}\n */\nexport function decode (bytes) {\n  const buf = toByteView(bytes)\n  const pbn = decodeNode(buf)\n\n  const node = {}\n\n  if (pbn.Data) {\n    node.Data = pbn.Data\n  }\n\n  if (pbn.Links) {\n    node.Links = pbn.Links.map((l) => {\n      const link = {}\n      try {\n        link.Hash = CID.decode(l.Hash)\n      } catch {\n        // ignore parse fail\n      }\n      if (!link.Hash) {\n        throw new Error('Invalid Hash field found in link, expected CID')\n      }\n      if (l.Name !== undefined) {\n        link.Name = l.Name\n      }\n      if (l.Tsize !== undefined) {\n        link.Tsize = l.Tsize\n      }\n      return link\n    })\n  }\n\n  return node\n}\n\nexport { prepare, validate, createNode, createLink }\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;;;;;AAiBO,MAAM,OAAO;AACb,MAAM,OAAO;AAMb,SAAS,OAAQ,IAAI;IAC1B,IAAA,gKAAQ,EAAC;IAET,MAAM,MAAM,CAAC;IACb,IAAI,KAAK,KAAK,EAAE;QACd,IAAI,KAAK,GAAG,KAAK,KAAK,CAAC,GAAG,CAAC,CAAC;YAC1B,MAAM,OAAO,CAAC;YACd,IAAI,EAAE,IAAI,EAAE;gBACV,KAAK,IAAI,GAAG,EAAE,IAAI,CAAC,KAAK,EAAC,eAAe;YAC1C;YACA,IAAI,EAAE,IAAI,KAAK,WAAW;gBACxB,KAAK,IAAI,GAAG,EAAE,IAAI;YACpB;YACA,IAAI,EAAE,KAAK,KAAK,WAAW;gBACzB,KAAK,KAAK,GAAG,EAAE,KAAK;YACtB;YACA,OAAO;QACT;IACF;IACA,IAAI,KAAK,IAAI,EAAE;QACb,IAAI,IAAI,GAAG,KAAK,IAAI;IACtB;IAEA,OAAO,IAAA,0KAAU,EAAC;AACpB;AAMO,SAAS,OAAQ,KAAK;IAC3B,MAAM,MAAM,IAAA,kKAAU,EAAC;IACvB,MAAM,MAAM,IAAA,0KAAU,EAAC;IAEvB,MAAM,OAAO,CAAC;IAEd,IAAI,IAAI,IAAI,EAAE;QACZ,KAAK,IAAI,GAAG,IAAI,IAAI;IACtB;IAEA,IAAI,IAAI,KAAK,EAAE;QACb,KAAK,KAAK,GAAG,IAAI,KAAK,CAAC,GAAG,CAAC,CAAC;YAC1B,MAAM,OAAO,CAAC;YACd,IAAI;gBACF,KAAK,IAAI,GAAG,2KAAG,CAAC,MAAM,CAAC,EAAE,IAAI;YAC/B,EAAE,OAAM;YACN,oBAAoB;YACtB;YACA,IAAI,CAAC,KAAK,IAAI,EAAE;gBACd,MAAM,IAAI,MAAM;YAClB;YACA,IAAI,EAAE,IAAI,KAAK,WAAW;gBACxB,KAAK,IAAI,GAAG,EAAE,IAAI;YACpB;YACA,IAAI,EAAE,KAAK,KAAK,WAAW;gBACzB,KAAK,KAAK,GAAG,EAAE,KAAK;YACtB;YACA,OAAO;QACT;IACF;IAEA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 4720, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/unixfs/node_modules/protobufjs/src/util/longbits.js"],"sourcesContent":["\"use strict\";\nmodule.exports = LongBits;\n\nvar util = require(\"../util/minimal\");\n\n/**\n * Constructs new long bits.\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @constructor\n * @param {number} lo Low 32 bits, unsigned\n * @param {number} hi High 32 bits, unsigned\n */\nfunction LongBits(lo, hi) {\n\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n\n    /**\n     * Low bits.\n     * @type {number}\n     */\n    this.lo = lo >>> 0;\n\n    /**\n     * High bits.\n     * @type {number}\n     */\n    this.hi = hi >>> 0;\n}\n\n/**\n * Zero bits.\n * @memberof util.LongBits\n * @type {util.LongBits}\n */\nvar zero = LongBits.zero = new LongBits(0, 0);\n\nzero.toNumber = function() { return 0; };\nzero.zzEncode = zero.zzDecode = function() { return this; };\nzero.length = function() { return 1; };\n\n/**\n * Zero hash.\n * @memberof util.LongBits\n * @type {string}\n */\nvar zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n\n/**\n * Constructs new long bits from the specified number.\n * @param {number} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.fromNumber = function fromNumber(value) {\n    if (value === 0)\n        return zero;\n    var sign = value < 0;\n    if (sign)\n        value = -value;\n    var lo = value >>> 0,\n        hi = (value - lo) / 4294967296 >>> 0;\n    if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n            lo = 0;\n            if (++hi > 4294967295)\n                hi = 0;\n        }\n    }\n    return new LongBits(lo, hi);\n};\n\n/**\n * Constructs new long bits from a number, long or string.\n * @param {Long|number|string} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.from = function from(value) {\n    if (typeof value === \"number\")\n        return LongBits.fromNumber(value);\n    if (util.isString(value)) {\n        /* istanbul ignore else */\n        if (util.Long)\n            value = util.Long.fromString(value);\n        else\n            return LongBits.fromNumber(parseInt(value, 10));\n    }\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n};\n\n/**\n * Converts this long bits to a possibly unsafe JavaScript number.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {number} Possibly unsafe number\n */\nLongBits.prototype.toNumber = function toNumber(unsigned) {\n    if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0,\n            hi = ~this.hi     >>> 0;\n        if (!lo)\n            hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n};\n\n/**\n * Converts this long bits to a long.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long} Long\n */\nLongBits.prototype.toLong = function toLong(unsigned) {\n    return util.Long\n        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))\n        /* istanbul ignore next */\n        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n};\n\nvar charCodeAt = String.prototype.charCodeAt;\n\n/**\n * Constructs new long bits from the specified 8 characters long hash.\n * @param {string} hash Hash\n * @returns {util.LongBits} Bits\n */\nLongBits.fromHash = function fromHash(hash) {\n    if (hash === zeroHash)\n        return zero;\n    return new LongBits(\n        ( charCodeAt.call(hash, 0)\n        | charCodeAt.call(hash, 1) << 8\n        | charCodeAt.call(hash, 2) << 16\n        | charCodeAt.call(hash, 3) << 24) >>> 0\n    ,\n        ( charCodeAt.call(hash, 4)\n        | charCodeAt.call(hash, 5) << 8\n        | charCodeAt.call(hash, 6) << 16\n        | charCodeAt.call(hash, 7) << 24) >>> 0\n    );\n};\n\n/**\n * Converts this long bits to a 8 characters long hash.\n * @returns {string} Hash\n */\nLongBits.prototype.toHash = function toHash() {\n    return String.fromCharCode(\n        this.lo        & 255,\n        this.lo >>> 8  & 255,\n        this.lo >>> 16 & 255,\n        this.lo >>> 24      ,\n        this.hi        & 255,\n        this.hi >>> 8  & 255,\n        this.hi >>> 16 & 255,\n        this.hi >>> 24\n    );\n};\n\n/**\n * Zig-zag encodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzEncode = function zzEncode() {\n    var mask =   this.hi >> 31;\n    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Zig-zag decodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzDecode = function zzDecode() {\n    var mask = -(this.lo & 1);\n    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Calculates the length of this longbits when encoded as a varint.\n * @returns {number} Length\n */\nLongBits.prototype.length = function length() {\n    var part0 =  this.lo,\n        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,\n        part2 =  this.hi >>> 24;\n    return part2 === 0\n         ? part1 === 0\n           ? part0 < 16384\n             ? part0 < 128 ? 1 : 2\n             : part0 < 2097152 ? 3 : 4\n           : part1 < 16384\n             ? part1 < 128 ? 5 : 6\n             : part1 < 2097152 ? 7 : 8\n         : part2 < 128 ? 9 : 10;\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4858, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/unixfs/node_modules/protobufjs/src/util/minimal.js"],"sourcesContent":["\"use strict\";\nvar util = exports;\n\n// used to return a Promise where callback is omitted\nutil.asPromise = require(\"@protobufjs/aspromise\");\n\n// converts to / from base64 encoded strings\nutil.base64 = require(\"@protobufjs/base64\");\n\n// base class of rpc.Service\nutil.EventEmitter = require(\"@protobufjs/eventemitter\");\n\n// float handling accross browsers\nutil.float = require(\"@protobufjs/float\");\n\n// requires modules optionally and hides the call from bundlers\nutil.inquire = require(\"@protobufjs/inquire\");\n\n// converts to / from utf8 encoded strings\nutil.utf8 = require(\"@protobufjs/utf8\");\n\n// provides a node-like buffer pool in the browser\nutil.pool = require(\"@protobufjs/pool\");\n\n// utility to work with the low and high bits of a 64 bit value\nutil.LongBits = require(\"./longbits\");\n\n/**\n * Whether running within node or not.\n * @memberof util\n * @type {boolean}\n */\nutil.isNode = Boolean(typeof global !== \"undefined\"\n                   && global\n                   && global.process\n                   && global.process.versions\n                   && global.process.versions.node);\n\n/**\n * Global object reference.\n * @memberof util\n * @type {Object}\n */\nutil.global = util.isNode && global\n           || typeof window !== \"undefined\" && window\n           || typeof self   !== \"undefined\" && self\n           || this; // eslint-disable-line no-invalid-this\n\n/**\n * An immuable empty array.\n * @memberof util\n * @type {Array.<*>}\n * @const\n */\nutil.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\n\n/**\n * An immutable empty object.\n * @type {Object}\n * @const\n */\nutil.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\n\n/**\n * Tests if the specified value is an integer.\n * @function\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is an integer\n */\nutil.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n};\n\n/**\n * Tests if the specified value is a string.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a string\n */\nutil.isString = function isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n};\n\n/**\n * Tests if the specified value is a non-null object.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a non-null object\n */\nutil.isObject = function isObject(value) {\n    return value && typeof value === \"object\";\n};\n\n/**\n * Checks if a property on a message is considered to be present.\n * This is an alias of {@link util.isSet}.\n * @function\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isset =\n\n/**\n * Checks if a property on a message is considered to be present.\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isSet = function isSet(obj, prop) {\n    var value = obj[prop];\n    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n    return false;\n};\n\n/**\n * Any compatible Buffer instance.\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\n * @interface Buffer\n * @extends Uint8Array\n */\n\n/**\n * Node's Buffer class if available.\n * @type {Constructor<Buffer>}\n */\nutil.Buffer = (function() {\n    try {\n        var Buffer = util.inquire(\"buffer\").Buffer;\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\n    } catch (e) {\n        /* istanbul ignore next */\n        return null;\n    }\n})();\n\n// Internal alias of or polyfull for Buffer.from.\nutil._Buffer_from = null;\n\n// Internal alias of or polyfill for Buffer.allocUnsafe.\nutil._Buffer_allocUnsafe = null;\n\n/**\n * Creates a new buffer of whatever type supported by the environment.\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\n * @returns {Uint8Array|Buffer} Buffer\n */\nutil.newBuffer = function newBuffer(sizeOrArray) {\n    /* istanbul ignore next */\n    return typeof sizeOrArray === \"number\"\n        ? util.Buffer\n            ? util._Buffer_allocUnsafe(sizeOrArray)\n            : new util.Array(sizeOrArray)\n        : util.Buffer\n            ? util._Buffer_from(sizeOrArray)\n            : typeof Uint8Array === \"undefined\"\n                ? sizeOrArray\n                : new Uint8Array(sizeOrArray);\n};\n\n/**\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\n * @type {Constructor<Uint8Array>}\n */\nutil.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */ : Array;\n\n/**\n * Any compatible Long instance.\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\n * @interface Long\n * @property {number} low Low bits\n * @property {number} high High bits\n * @property {boolean} unsigned Whether unsigned or not\n */\n\n/**\n * Long.js's Long class if available.\n * @type {Constructor<Long>}\n */\nutil.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long\n         || /* istanbul ignore next */ util.global.Long\n         || util.inquire(\"long\");\n\n/**\n * Regular expression used to verify 2 bit (`bool`) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key2Re = /^true|false|0|1$/;\n\n/**\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n\n/**\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n\n/**\n * Converts a number or long to an 8 characters long hash string.\n * @param {Long|number} value Value to convert\n * @returns {string} Hash\n */\nutil.longToHash = function longToHash(value) {\n    return value\n        ? util.LongBits.from(value).toHash()\n        : util.LongBits.zeroHash;\n};\n\n/**\n * Converts an 8 characters long hash string to a long or number.\n * @param {string} hash Hash\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long|number} Original value\n */\nutil.longFromHash = function longFromHash(hash, unsigned) {\n    var bits = util.LongBits.fromHash(hash);\n    if (util.Long)\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n    return bits.toNumber(Boolean(unsigned));\n};\n\n/**\n * Merges the properties of the source object into the destination object.\n * @memberof util\n * @param {Object.<string,*>} dst Destination object\n * @param {Object.<string,*>} src Source object\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\n * @returns {Object.<string,*>} Destination object\n */\nfunction merge(dst, src, ifNotSet) { // used by converters\n    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === undefined || !ifNotSet)\n            dst[keys[i]] = src[keys[i]];\n    return dst;\n}\n\nutil.merge = merge;\n\n/**\n * Converts the first character of a string to lower case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.lcFirst = function lcFirst(str) {\n    return str.charAt(0).toLowerCase() + str.substring(1);\n};\n\n/**\n * Creates a custom error constructor.\n * @memberof util\n * @param {string} name Error name\n * @returns {Constructor<Error>} Custom error constructor\n */\nfunction newError(name) {\n\n    function CustomError(message, properties) {\n\n        if (!(this instanceof CustomError))\n            return new CustomError(message, properties);\n\n        // Error.call(this, message);\n        // ^ just returns a new error instance because the ctor can be called as a function\n\n        Object.defineProperty(this, \"message\", { get: function() { return message; } });\n\n        /* istanbul ignore next */\n        if (Error.captureStackTrace) // node\n            Error.captureStackTrace(this, CustomError);\n        else\n            Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" });\n\n        if (properties)\n            merge(this, properties);\n    }\n\n    CustomError.prototype = Object.create(Error.prototype, {\n        constructor: {\n            value: CustomError,\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        },\n        name: {\n            get: function get() { return name; },\n            set: undefined,\n            enumerable: false,\n            // configurable: false would accurately preserve the behavior of\n            // the original, but I'm guessing that was not intentional.\n            // For an actual error subclass, this property would\n            // be configurable.\n            configurable: true,\n        },\n        toString: {\n            value: function value() { return this.name + \": \" + this.message; },\n            writable: true,\n            enumerable: false,\n            configurable: true,\n        },\n    });\n\n    return CustomError;\n}\n\nutil.newError = newError;\n\n/**\n * Constructs a new protocol error.\n * @classdesc Error subclass indicating a protocol specifc error.\n * @memberof util\n * @extends Error\n * @template T extends Message<T>\n * @constructor\n * @param {string} message Error message\n * @param {Object.<string,*>} [properties] Additional properties\n * @example\n * try {\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\n * } catch (e) {\n *     if (e instanceof ProtocolError && e.instance)\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\n * }\n */\nutil.ProtocolError = newError(\"ProtocolError\");\n\n/**\n * So far decoded message instance.\n * @name util.ProtocolError#instance\n * @type {Message<T>}\n */\n\n/**\n * A OneOf getter as returned by {@link util.oneOfGetter}.\n * @typedef OneOfGetter\n * @type {function}\n * @returns {string|undefined} Set field name, if any\n */\n\n/**\n * Builds a getter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfGetter} Unbound getter\n */\nutil.oneOfGetter = function getOneOf(fieldNames) {\n    var fieldMap = {};\n    for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n\n    /**\n     * @returns {string|undefined} Set field name, if any\n     * @this Object\n     * @ignore\n     */\n    return function() { // eslint-disable-line consistent-return\n        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\n            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\n                return keys[i];\n    };\n};\n\n/**\n * A OneOf setter as returned by {@link util.oneOfSetter}.\n * @typedef OneOfSetter\n * @type {function}\n * @param {string|undefined} value Field name\n * @returns {undefined}\n */\n\n/**\n * Builds a setter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfSetter} Unbound setter\n */\nutil.oneOfSetter = function setOneOf(fieldNames) {\n\n    /**\n     * @param {string} name Field name\n     * @returns {undefined}\n     * @this Object\n     * @ignore\n     */\n    return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n            if (fieldNames[i] !== name)\n                delete this[fieldNames[i]];\n    };\n};\n\n/**\n * Default conversion options used for {@link Message#toJSON} implementations.\n *\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\n *\n * - Longs become strings\n * - Enums become string keys\n * - Bytes become base64 encoded strings\n * - (Sub-)Messages become plain objects\n * - Maps become plain objects with all string keys\n * - Repeated fields become arrays\n * - NaN and Infinity for float and double fields become strings\n *\n * @type {IConversionOptions}\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\n */\nutil.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    json: true\n};\n\n// Sets up buffer utility according to the environment (called in index-minimal)\nutil._configure = function() {\n    var Buffer = util.Buffer;\n    /* istanbul ignore if */\n    if (!Buffer) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n    }\n    // because node 4.x buffers are incompatible & immutable\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\n        /* istanbul ignore next */\n        function Buffer_from(value, encoding) {\n            return new Buffer(value, encoding);\n        };\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\n        /* istanbul ignore next */\n        function Buffer_allocUnsafe(size) {\n            return new Buffer(size);\n        };\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5183, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/unixfs/node_modules/protobufjs/src/writer.js"],"sourcesContent":["\"use strict\";\nmodule.exports = Writer;\n\nvar util      = require(\"./util/minimal\");\n\nvar BufferWriter; // cyclic\n\nvar LongBits  = util.LongBits,\n    base64    = util.base64,\n    utf8      = util.utf8;\n\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */\nfunction Op(fn, len, val) {\n\n    /**\n     * Function to call.\n     * @type {function(Uint8Array, number, *)}\n     */\n    this.fn = fn;\n\n    /**\n     * Value byte length.\n     * @type {number}\n     */\n    this.len = len;\n\n    /**\n     * Next operation.\n     * @type {Writer.Op|undefined}\n     */\n    this.next = undefined;\n\n    /**\n     * Value to write.\n     * @type {*}\n     */\n    this.val = val; // type varies\n}\n\n/* istanbul ignore next */\nfunction noop() {} // eslint-disable-line no-empty-function\n\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @ignore\n */\nfunction State(writer) {\n\n    /**\n     * Current head.\n     * @type {Writer.Op}\n     */\n    this.head = writer.head;\n\n    /**\n     * Current tail.\n     * @type {Writer.Op}\n     */\n    this.tail = writer.tail;\n\n    /**\n     * Current buffer length.\n     * @type {number}\n     */\n    this.len = writer.len;\n\n    /**\n     * Next state.\n     * @type {State|null}\n     */\n    this.next = writer.states;\n}\n\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */\nfunction Writer() {\n\n    /**\n     * Current length.\n     * @type {number}\n     */\n    this.len = 0;\n\n    /**\n     * Operations head.\n     * @type {Object}\n     */\n    this.head = new Op(noop, 0, 0);\n\n    /**\n     * Operations tail\n     * @type {Object}\n     */\n    this.tail = this.head;\n\n    /**\n     * Linked forked states.\n     * @type {Object|null}\n     */\n    this.states = null;\n\n    // When a value is written, the writer calculates its byte length and puts it into a linked\n    // list of operations to perform when finish() is called. This both allows us to allocate\n    // buffers of the exact required size and reduces the amount of work we have to do compared\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\n    // part is just a linked list walk calling operations with already prepared values.\n}\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup() {\n            return (Writer.create = function create_buffer() {\n                return new BufferWriter();\n            })();\n        }\n        /* istanbul ignore next */\n        : function create_array() {\n            return new Writer();\n        };\n};\n\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */\nWriter.create = create();\n\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */\nWriter.alloc = function alloc(size) {\n    return new util.Array(size);\n};\n\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\n/* istanbul ignore else */\nif (util.Array !== Array)\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n * @private\n */\nWriter.prototype._push = function push(fn, len, val) {\n    this.tail = this.tail.next = new Op(fn, len, val);\n    this.len += len;\n    return this;\n};\n\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\n\nfunction writeVarint32(val, buf, pos) {\n    while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */\nfunction VarintOp(len, val) {\n    this.len = len;\n    this.next = undefined;\n    this.val = val;\n}\n\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.uint32 = function write_uint32(value) {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0)\n                < 128       ? 1\n        : value < 16384     ? 2\n        : value < 2097152   ? 3\n        : value < 268435456 ? 4\n        :                     5,\n    value)).len;\n    return this;\n};\n\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.int32 = function write_int32(value) {\n    return value < 0\n        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n        : this.uint32(value);\n};\n\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sint32 = function write_sint32(value) {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\n\nfunction writeVarint64(val, buf, pos) {\n    while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\n\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.uint64 = function write_uint64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.int64 = Writer.prototype.uint64;\n\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sint64 = function write_sint64(value) {\n    var bits = LongBits.from(value).zzEncode();\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bool = function write_bool(value) {\n    return this._push(writeByte, 1, value ? 1 : 0);\n};\n\nfunction writeFixed32(val, buf, pos) {\n    buf[pos    ] =  val         & 255;\n    buf[pos + 1] =  val >>> 8   & 255;\n    buf[pos + 2] =  val >>> 16  & 255;\n    buf[pos + 3] =  val >>> 24;\n}\n\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.fixed32 = function write_fixed32(value) {\n    return this._push(writeFixed32, 4, value >>> 0);\n};\n\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\n\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.fixed64 = function write_fixed64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\n\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.float = function write_float(value) {\n    return this._push(util.float.writeFloatLE, 4, value);\n};\n\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.double = function write_double(value) {\n    return this._push(util.float.writeDoubleLE, 8, value);\n};\n\nvar writeBytes = util.Array.prototype.set\n    ? function writeBytes_set(val, buf, pos) {\n        buf.set(val, pos); // also works for plain array values\n    }\n    /* istanbul ignore next */\n    : function writeBytes_for(val, buf, pos) {\n        for (var i = 0; i < val.length; ++i)\n            buf[pos + i] = val[i];\n    };\n\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bytes = function write_bytes(value) {\n    var len = value.length >>> 0;\n    if (!len)\n        return this._push(writeByte, 1, 0);\n    if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n    }\n    return this.uint32(len)._push(writeBytes, len, value);\n};\n\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.string = function write_string(value) {\n    var len = utf8.length(value);\n    return len\n        ? this.uint32(len)._push(utf8.write, len, value)\n        : this._push(writeByte, 1, 0);\n};\n\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */\nWriter.prototype.fork = function fork() {\n    this.states = new State(this);\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n    return this;\n};\n\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */\nWriter.prototype.reset = function reset() {\n    if (this.states) {\n        this.head   = this.states.head;\n        this.tail   = this.states.tail;\n        this.len    = this.states.len;\n        this.states = this.states.next;\n    } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len  = 0;\n    }\n    return this;\n};\n\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */\nWriter.prototype.ldelim = function ldelim() {\n    var head = this.head,\n        tail = this.tail,\n        len  = this.len;\n    this.reset().uint32(len);\n    if (len) {\n        this.tail.next = head.next; // skip noop\n        this.tail = tail;\n        this.len += len;\n    }\n    return this;\n};\n\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */\nWriter.prototype.finish = function finish() {\n    var head = this.head.next, // skip noop\n        buf  = this.constructor.alloc(this.len),\n        pos  = 0;\n    while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n    }\n    // this.head = this.tail = null;\n    return buf;\n};\n\nWriter._configure = function(BufferWriter_) {\n    BufferWriter = BufferWriter_;\n    Writer.create = create();\n    BufferWriter._configure();\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5534, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/unixfs/node_modules/protobufjs/src/writer_buffer.js"],"sourcesContent":["\"use strict\";\nmodule.exports = BufferWriter;\n\n// extends Writer\nvar Writer = require(\"./writer\");\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n\nvar util = require(\"./util/minimal\");\n\n/**\n * Constructs a new buffer writer instance.\n * @classdesc Wire format writer using node buffers.\n * @extends Writer\n * @constructor\n */\nfunction BufferWriter() {\n    Writer.call(this);\n}\n\nBufferWriter._configure = function () {\n    /**\n     * Allocates a buffer of the specified size.\n     * @function\n     * @param {number} size Buffer size\n     * @returns {Buffer} Buffer\n     */\n    BufferWriter.alloc = util._Buffer_allocUnsafe;\n\n    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\"\n        ? function writeBytesBuffer_set(val, buf, pos) {\n          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n          // also works for plain array values\n        }\n        /* istanbul ignore next */\n        : function writeBytesBuffer_copy(val, buf, pos) {\n          if (val.copy) // Buffer values\n            val.copy(buf, pos, 0, val.length);\n          else for (var i = 0; i < val.length;) // plain array values\n            buf[pos++] = val[i++];\n        };\n};\n\n\n/**\n * @override\n */\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n    if (util.isString(value))\n        value = util._Buffer_from(value, \"base64\");\n    var len = value.length >>> 0;\n    this.uint32(len);\n    if (len)\n        this._push(BufferWriter.writeBytesBuffer, len, value);\n    return this;\n};\n\nfunction writeStringBuffer(val, buf, pos) {\n    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)\n        util.utf8.write(val, buf, pos);\n    else if (buf.utf8Write)\n        buf.utf8Write(val, pos);\n    else\n        buf.write(val, pos);\n}\n\n/**\n * @override\n */\nBufferWriter.prototype.string = function write_string_buffer(value) {\n    var len = util.Buffer.byteLength(value);\n    this.uint32(len);\n    if (len)\n        this._push(writeStringBuffer, len, value);\n    return this;\n};\n\n\n/**\n * Finishes the write operation.\n * @name BufferWriter#finish\n * @function\n * @returns {Buffer} Finished buffer\n */\n\nBufferWriter._configure();\n"],"names":[],"mappings":"AACA,OAAO,OAAO,GAAG;AAEjB,iBAAiB;AACjB,IAAI;AACJ,CAAC,aAAa,SAAS,GAAG,OAAO,MAAM,CAAC,OAAO,SAAS,CAAC,EAAE,WAAW,GAAG;AAEzE,IAAI;AAEJ;;;;;CAKC,GACD,SAAS;IACL,OAAO,IAAI,CAAC,IAAI;AACpB;AAEA,aAAa,UAAU,GAAG;IACtB;;;;;KAKC,GACD,aAAa,KAAK,GAAG,KAAK,mBAAmB;IAE7C,aAAa,gBAAgB,GAAG,KAAK,MAAM,IAAI,KAAK,MAAM,CAAC,SAAS,YAAY,cAAc,KAAK,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,IAAI,KAAK,QAC3H,SAAS,qBAAqB,GAAG,EAAE,GAAG,EAAE,GAAG;QAC3C,IAAI,GAAG,CAAC,KAAK,MAAM,sGAAsG;IACzH,oCAAoC;IACtC,IAEE,SAAS,sBAAsB,GAAG,EAAE,GAAG,EAAE,GAAG;QAC5C,IAAI,IAAI,IAAI,EACV,IAAI,IAAI,CAAC,KAAK,KAAK,GAAG,IAAI,MAAM;aAC7B,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,MAAM,EACjC,GAAG,CAAC,MAAM,GAAG,GAAG,CAAC,IAAI;IACzB;AACR;AAGA;;CAEC,GACD,aAAa,SAAS,CAAC,KAAK,GAAG,SAAS,mBAAmB,KAAK;IAC5D,IAAI,KAAK,QAAQ,CAAC,QACd,QAAQ,KAAK,YAAY,CAAC,OAAO;IACrC,IAAI,MAAM,MAAM,MAAM,KAAK;IAC3B,IAAI,CAAC,MAAM,CAAC;IACZ,IAAI,KACA,IAAI,CAAC,KAAK,CAAC,aAAa,gBAAgB,EAAE,KAAK;IACnD,OAAO,IAAI;AACf;AAEA,SAAS,kBAAkB,GAAG,EAAE,GAAG,EAAE,GAAG;IACpC,IAAI,IAAI,MAAM,GAAG,IACb,KAAK,IAAI,CAAC,KAAK,CAAC,KAAK,KAAK;SACzB,IAAI,IAAI,SAAS,EAClB,IAAI,SAAS,CAAC,KAAK;SAEnB,IAAI,KAAK,CAAC,KAAK;AACvB;AAEA;;CAEC,GACD,aAAa,SAAS,CAAC,MAAM,GAAG,SAAS,oBAAoB,KAAK;IAC9D,IAAI,MAAM,KAAK,MAAM,CAAC,UAAU,CAAC;IACjC,IAAI,CAAC,MAAM,CAAC;IACZ,IAAI,KACA,IAAI,CAAC,KAAK,CAAC,mBAAmB,KAAK;IACvC,OAAO,IAAI;AACf;AAGA;;;;;CAKC,GAED,aAAa,UAAU","ignoreList":[0]}},
    {"offset": {"line": 5594, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/unixfs/node_modules/protobufjs/src/reader.js"],"sourcesContent":["\"use strict\";\nmodule.exports = Reader;\n\nvar util      = require(\"./util/minimal\");\n\nvar BufferReader; // cyclic\n\nvar LongBits  = util.LongBits,\n    utf8      = util.utf8;\n\n/* istanbul ignore next */\nfunction indexOutOfRange(reader, writeLength) {\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n}\n\n/**\n * Constructs a new reader instance using the specified buffer.\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n * @param {Uint8Array} buffer Buffer to read from\n */\nfunction Reader(buffer) {\n\n    /**\n     * Read buffer.\n     * @type {Uint8Array}\n     */\n    this.buf = buffer;\n\n    /**\n     * Read buffer position.\n     * @type {number}\n     */\n    this.pos = 0;\n\n    /**\n     * Read buffer length.\n     * @type {number}\n     */\n    this.len = buffer.length;\n}\n\nvar create_array = typeof Uint8Array !== \"undefined\"\n    ? function create_typed_array(buffer) {\n        if (buffer instanceof Uint8Array || Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    }\n    /* istanbul ignore next */\n    : function create_array(buffer) {\n        if (Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    };\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup(buffer) {\n            return (Reader.create = function create_buffer(buffer) {\n                return util.Buffer.isBuffer(buffer)\n                    ? new BufferReader(buffer)\n                    /* istanbul ignore next */\n                    : create_array(buffer);\n            })(buffer);\n        }\n        /* istanbul ignore next */\n        : create_array;\n};\n\n/**\n * Creates a new reader using the specified buffer.\n * @function\n * @param {Uint8Array|Buffer} buffer Buffer to read from\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\n * @throws {Error} If `buffer` is not a valid buffer\n */\nReader.create = create();\n\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\n\n/**\n * Reads a varint as an unsigned 32 bit value.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.uint32 = (function read_uint32_setup() {\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\n    return function read_uint32() {\n        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;\n\n        /* istanbul ignore if */\n        if ((this.pos += 5) > this.len) {\n            this.pos = this.len;\n            throw indexOutOfRange(this, 10);\n        }\n        return value;\n    };\n})();\n\n/**\n * Reads a varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.int32 = function read_int32() {\n    return this.uint32() | 0;\n};\n\n/**\n * Reads a zig-zag encoded varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.sint32 = function read_sint32() {\n    var value = this.uint32();\n    return value >>> 1 ^ -(value & 1) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readLongVarint() {\n    // tends to deopt with local vars for octet etc.\n    var bits = new LongBits(0, 0);\n    var i = 0;\n    if (this.len - this.pos > 4) { // fast route (lo)\n        for (; i < 4; ++i) {\n            // 1st..4th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 5th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return bits;\n        i = 0;\n    } else {\n        for (; i < 3; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 1st..3th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 4th\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n    }\n    if (this.len - this.pos > 4) { // fast route (hi)\n        for (; i < 5; ++i) {\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    } else {\n        for (; i < 5; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    }\n    /* istanbul ignore next */\n    throw Error(\"invalid varint encoding\");\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads a varint as a signed 64 bit value.\n * @name Reader#int64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as an unsigned 64 bit value.\n * @name Reader#uint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a zig-zag encoded varint as a signed 64 bit value.\n * @name Reader#sint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as a boolean.\n * @returns {boolean} Value read\n */\nReader.prototype.bool = function read_bool() {\n    return this.uint32() !== 0;\n};\n\nfunction readFixed32_end(buf, end) { // note that this uses `end`, not `pos`\n    return (buf[end - 4]\n          | buf[end - 3] << 8\n          | buf[end - 2] << 16\n          | buf[end - 1] << 24) >>> 0;\n}\n\n/**\n * Reads fixed 32 bits as an unsigned 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.fixed32 = function read_fixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4);\n};\n\n/**\n * Reads fixed 32 bits as a signed 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.sfixed32 = function read_sfixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readFixed64(/* this: Reader */) {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 8);\n\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads fixed 64 bits.\n * @name Reader#fixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads zig-zag encoded fixed 64 bits.\n * @name Reader#sfixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a float (32 bit) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.float = function read_float() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readFloatLE(this.buf, this.pos);\n    this.pos += 4;\n    return value;\n};\n\n/**\n * Reads a double (64 bit float) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.double = function read_double() {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readDoubleLE(this.buf, this.pos);\n    this.pos += 8;\n    return value;\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @returns {Uint8Array} Value read\n */\nReader.prototype.bytes = function read_bytes() {\n    var length = this.uint32(),\n        start  = this.pos,\n        end    = this.pos + length;\n\n    /* istanbul ignore if */\n    if (end > this.len)\n        throw indexOutOfRange(this, length);\n\n    this.pos += length;\n    if (Array.isArray(this.buf)) // plain array\n        return this.buf.slice(start, end);\n\n    if (start === end) { // fix for IE 10/Win8 and others' subarray returning array of size 1\n        var nativeBuffer = util.Buffer;\n        return nativeBuffer\n            ? nativeBuffer.alloc(0)\n            : new this.buf.constructor(0);\n    }\n    return this._slice.call(this.buf, start, end);\n};\n\n/**\n * Reads a string preceeded by its byte length as a varint.\n * @returns {string} Value read\n */\nReader.prototype.string = function read_string() {\n    var bytes = this.bytes();\n    return utf8.read(bytes, 0, bytes.length);\n};\n\n/**\n * Skips the specified number of bytes if specified, otherwise skips a varint.\n * @param {number} [length] Length if known, otherwise a varint is assumed\n * @returns {Reader} `this`\n */\nReader.prototype.skip = function skip(length) {\n    if (typeof length === \"number\") {\n        /* istanbul ignore if */\n        if (this.pos + length > this.len)\n            throw indexOutOfRange(this, length);\n        this.pos += length;\n    } else {\n        do {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n        } while (this.buf[this.pos++] & 128);\n    }\n    return this;\n};\n\n/**\n * Skips the next element of the specified wire type.\n * @param {number} wireType Wire type received\n * @returns {Reader} `this`\n */\nReader.prototype.skipType = function(wireType) {\n    switch (wireType) {\n        case 0:\n            this.skip();\n            break;\n        case 1:\n            this.skip(8);\n            break;\n        case 2:\n            this.skip(this.uint32());\n            break;\n        case 3:\n            while ((wireType = this.uint32() & 7) !== 4) {\n                this.skipType(wireType);\n            }\n            break;\n        case 5:\n            this.skip(4);\n            break;\n\n        /* istanbul ignore next */\n        default:\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n    }\n    return this;\n};\n\nReader._configure = function(BufferReader_) {\n    BufferReader = BufferReader_;\n    Reader.create = create();\n    BufferReader._configure();\n\n    var fn = util.Long ? \"toLong\" : /* istanbul ignore next */ \"toNumber\";\n    util.merge(Reader.prototype, {\n\n        int64: function read_int64() {\n            return readLongVarint.call(this)[fn](false);\n        },\n\n        uint64: function read_uint64() {\n            return readLongVarint.call(this)[fn](true);\n        },\n\n        sint64: function read_sint64() {\n            return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n\n        fixed64: function read_fixed64() {\n            return readFixed64.call(this)[fn](true);\n        },\n\n        sfixed64: function read_sfixed64() {\n            return readFixed64.call(this)[fn](false);\n        }\n\n    });\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5884, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/unixfs/node_modules/protobufjs/src/reader_buffer.js"],"sourcesContent":["\"use strict\";\nmodule.exports = BufferReader;\n\n// extends Reader\nvar Reader = require(\"./reader\");\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\n\nvar util = require(\"./util/minimal\");\n\n/**\n * Constructs a new buffer reader instance.\n * @classdesc Wire format reader using node buffers.\n * @extends Reader\n * @constructor\n * @param {Buffer} buffer Buffer to read from\n */\nfunction BufferReader(buffer) {\n    Reader.call(this, buffer);\n\n    /**\n     * Read buffer.\n     * @name BufferReader#buf\n     * @type {Buffer}\n     */\n}\n\nBufferReader._configure = function () {\n    /* istanbul ignore else */\n    if (util.Buffer)\n        BufferReader.prototype._slice = util.Buffer.prototype.slice;\n};\n\n\n/**\n * @override\n */\nBufferReader.prototype.string = function read_string_buffer() {\n    var len = this.uint32(); // modifies pos\n    return this.buf.utf8Slice\n        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))\n        : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @name BufferReader#bytes\n * @function\n * @returns {Buffer} Value read\n */\n\nBufferReader._configure();\n"],"names":[],"mappings":"AACA,OAAO,OAAO,GAAG;AAEjB,iBAAiB;AACjB,IAAI;AACJ,CAAC,aAAa,SAAS,GAAG,OAAO,MAAM,CAAC,OAAO,SAAS,CAAC,EAAE,WAAW,GAAG;AAEzE,IAAI;AAEJ;;;;;;CAMC,GACD,SAAS,aAAa,MAAM;IACxB,OAAO,IAAI,CAAC,IAAI,EAAE;AAElB;;;;KAIC,GACL;AAEA,aAAa,UAAU,GAAG;IACtB,wBAAwB,GACxB,IAAI,KAAK,MAAM,EACX,aAAa,SAAS,CAAC,MAAM,GAAG,KAAK,MAAM,CAAC,SAAS,CAAC,KAAK;AACnE;AAGA;;CAEC,GACD,aAAa,SAAS,CAAC,MAAM,GAAG,SAAS;IACrC,IAAI,MAAM,IAAI,CAAC,MAAM,IAAI,eAAe;IACxC,OAAO,IAAI,CAAC,GAAG,CAAC,SAAS,GACnB,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG,KAAK,GAAG,CAAC,IAAI,CAAC,GAAG,GAAG,KAAK,IAAI,CAAC,GAAG,KACzE,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,SAAS,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG,KAAK,GAAG,CAAC,IAAI,CAAC,GAAG,GAAG,KAAK,IAAI,CAAC,GAAG;AAC3F;AAEA;;;;;CAKC,GAED,aAAa,UAAU","ignoreList":[0]}},
    {"offset": {"line": 5921, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/unixfs/node_modules/protobufjs/src/rpc/service.js"],"sourcesContent":["\"use strict\";\nmodule.exports = Service;\n\nvar util = require(\"../util/minimal\");\n\n// Extends EventEmitter\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n\n/**\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\n *\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\n * @typedef rpc.ServiceMethodCallback\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {Error|null} error Error, if any\n * @param {TRes} [response] Response message\n * @returns {undefined}\n */\n\n/**\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\n * @typedef rpc.ServiceMethod\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\n */\n\n/**\n * Constructs a new RPC service instance.\n * @classdesc An RPC service as returned by {@link Service#create}.\n * @exports rpc.Service\n * @extends util.EventEmitter\n * @constructor\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n */\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\n\n    if (typeof rpcImpl !== \"function\")\n        throw TypeError(\"rpcImpl must be a function\");\n\n    util.EventEmitter.call(this);\n\n    /**\n     * RPC implementation. Becomes `null` once the service is ended.\n     * @type {RPCImpl|null}\n     */\n    this.rpcImpl = rpcImpl;\n\n    /**\n     * Whether requests are length-delimited.\n     * @type {boolean}\n     */\n    this.requestDelimited = Boolean(requestDelimited);\n\n    /**\n     * Whether responses are length-delimited.\n     * @type {boolean}\n     */\n    this.responseDelimited = Boolean(responseDelimited);\n}\n\n/**\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\n * @param {Constructor<TReq>} requestCtor Request constructor\n * @param {Constructor<TRes>} responseCtor Response constructor\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\n * @returns {undefined}\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n */\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n\n    if (!request)\n        throw TypeError(\"request must be specified\");\n\n    var self = this;\n    if (!callback)\n        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\n\n    if (!self.rpcImpl) {\n        setTimeout(function() { callback(Error(\"already ended\")); }, 0);\n        return undefined;\n    }\n\n    try {\n        return self.rpcImpl(\n            method,\n            requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\n            function rpcCallback(err, response) {\n\n                if (err) {\n                    self.emit(\"error\", err, method);\n                    return callback(err);\n                }\n\n                if (response === null) {\n                    self.end(/* endedByRPC */ true);\n                    return undefined;\n                }\n\n                if (!(response instanceof responseCtor)) {\n                    try {\n                        response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n                    } catch (err) {\n                        self.emit(\"error\", err, method);\n                        return callback(err);\n                    }\n                }\n\n                self.emit(\"data\", response, method);\n                return callback(null, response);\n            }\n        );\n    } catch (err) {\n        self.emit(\"error\", err, method);\n        setTimeout(function() { callback(err); }, 0);\n        return undefined;\n    }\n};\n\n/**\n * Ends this service and emits the `end` event.\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\n * @returns {rpc.Service} `this`\n */\nService.prototype.end = function end(endedByRPC) {\n    if (this.rpcImpl) {\n        if (!endedByRPC) // signal end to rpcImpl\n            this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n    }\n    return this;\n};\n"],"names":[],"mappings":"AACA,OAAO,OAAO,GAAG;AAEjB,IAAI;AAEJ,uBAAuB;AACvB,CAAC,QAAQ,SAAS,GAAG,OAAO,MAAM,CAAC,KAAK,YAAY,CAAC,SAAS,CAAC,EAAE,WAAW,GAAG;AAE/E;;;;;;;;;;CAUC,GAED;;;;;;;;;CASC,GAED;;;;;;;;;CASC,GACD,SAAS,QAAQ,OAAO,EAAE,gBAAgB,EAAE,iBAAiB;IAEzD,IAAI,OAAO,YAAY,YACnB,MAAM,UAAU;IAEpB,KAAK,YAAY,CAAC,IAAI,CAAC,IAAI;IAE3B;;;KAGC,GACD,IAAI,CAAC,OAAO,GAAG;IAEf;;;KAGC,GACD,IAAI,CAAC,gBAAgB,GAAG,QAAQ;IAEhC;;;KAGC,GACD,IAAI,CAAC,iBAAiB,GAAG,QAAQ;AACrC;AAEA;;;;;;;;;;CAUC,GACD,QAAQ,SAAS,CAAC,OAAO,GAAG,SAAS,QAAQ,MAAM,EAAE,WAAW,EAAE,YAAY,EAAE,OAAO,EAAE,QAAQ;IAE7F,IAAI,CAAC,SACD,MAAM,UAAU;IAEpB,IAAI,OAAO,IAAI;IACf,IAAI,CAAC,UACD,OAAO,KAAK,SAAS,CAAC,SAAS,MAAM,QAAQ,aAAa,cAAc;IAE5E,IAAI,CAAC,KAAK,OAAO,EAAE;QACf,WAAW;YAAa,SAAS,MAAM;QAAmB,GAAG;QAC7D,OAAO;IACX;IAEA,IAAI;QACA,OAAO,KAAK,OAAO,CACf,QACA,WAAW,CAAC,KAAK,gBAAgB,GAAG,oBAAoB,SAAS,CAAC,SAAS,MAAM,IACjF,SAAS,YAAY,GAAG,EAAE,QAAQ;YAE9B,IAAI,KAAK;gBACL,KAAK,IAAI,CAAC,SAAS,KAAK;gBACxB,OAAO,SAAS;YACpB;YAEA,IAAI,aAAa,MAAM;gBACnB,KAAK,GAAG,CAAC,cAAc,GAAG;gBAC1B,OAAO;YACX;YAEA,IAAI,CAAC,CAAC,oBAAoB,YAAY,GAAG;gBACrC,IAAI;oBACA,WAAW,YAAY,CAAC,KAAK,iBAAiB,GAAG,oBAAoB,SAAS,CAAC;gBACnF,EAAE,OAAO,KAAK;oBACV,KAAK,IAAI,CAAC,SAAS,KAAK;oBACxB,OAAO,SAAS;gBACpB;YACJ;YAEA,KAAK,IAAI,CAAC,QAAQ,UAAU;YAC5B,OAAO,SAAS,MAAM;QAC1B;IAER,EAAE,OAAO,KAAK;QACV,KAAK,IAAI,CAAC,SAAS,KAAK;QACxB,WAAW;YAAa,SAAS;QAAM,GAAG;QAC1C,OAAO;IACX;AACJ;AAEA;;;;CAIC,GACD,QAAQ,SAAS,CAAC,GAAG,GAAG,SAAS,IAAI,UAAU;IAC3C,IAAI,IAAI,CAAC,OAAO,EAAE;QACd,IAAI,CAAC,YACD,IAAI,CAAC,OAAO,CAAC,MAAM,MAAM;QAC7B,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,IAAI,CAAC,OAAO,GAAG;IACxB;IACA,OAAO,IAAI;AACf","ignoreList":[0]}},
    {"offset": {"line": 6034, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/unixfs/node_modules/protobufjs/src/rpc.js"],"sourcesContent":["\"use strict\";\n\n/**\n * Streaming RPC helpers.\n * @namespace\n */\nvar rpc = exports;\n\n/**\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\n * @typedef RPCImpl\n * @type {function}\n * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called\n * @param {Uint8Array} requestData Request data\n * @param {RPCImplCallback} callback Callback function\n * @returns {undefined}\n * @example\n * function rpcImpl(method, requestData, callback) {\n *     if (protobuf.util.lcFirst(method.name) !== \"myMethod\") // compatible with static code\n *         throw Error(\"no such method\");\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\n *         callback(err, responseData);\n *     });\n * }\n */\n\n/**\n * Node-style callback as used by {@link RPCImpl}.\n * @typedef RPCImplCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error\n * @returns {undefined}\n */\n\nrpc.Service = require(\"./rpc/service\");\n"],"names":[],"mappings":"AAEA;;;CAGC,GACD,IAAI,MAAM;AAEV;;;;;;;;;;;;;;;;CAgBC,GAED;;;;;;;CAOC,GAED,IAAI,OAAO","ignoreList":[0]}},
    {"offset": {"line": 6066, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/unixfs/node_modules/protobufjs/src/roots.js"],"sourcesContent":["\"use strict\";\nmodule.exports = {};\n\n/**\n * Named roots.\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\n * Can also be used manually to make roots available across modules.\n * @name roots\n * @type {Object.<string,Root>}\n * @example\n * // pbjs -r myroot -o compiled.js ...\n *\n * // in another module:\n * require(\"./compiled.js\");\n *\n * // in any subsequent module:\n * var root = protobuf.roots[\"myroot\"];\n */\n"],"names":[],"mappings":"AACA,OAAO,OAAO,GAAG,CAAC,GAElB;;;;;;;;;;;;;;CAcC","ignoreList":[0]}},
    {"offset": {"line": 6085, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/unixfs/node_modules/protobufjs/src/index-minimal.js"],"sourcesContent":["\"use strict\";\nvar protobuf = exports;\n\n/**\n * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\n * @name build\n * @type {string}\n * @const\n */\nprotobuf.build = \"minimal\";\n\n// Serialization\nprotobuf.Writer       = require(\"./writer\");\nprotobuf.BufferWriter = require(\"./writer_buffer\");\nprotobuf.Reader       = require(\"./reader\");\nprotobuf.BufferReader = require(\"./reader_buffer\");\n\n// Utility\nprotobuf.util         = require(\"./util/minimal\");\nprotobuf.rpc          = require(\"./rpc\");\nprotobuf.roots        = require(\"./roots\");\nprotobuf.configure    = configure;\n\n/* istanbul ignore next */\n/**\n * Reconfigures the library according to the environment.\n * @returns {undefined}\n */\nfunction configure() {\n    protobuf.util._configure();\n    protobuf.Writer._configure(protobuf.BufferWriter);\n    protobuf.Reader._configure(protobuf.BufferReader);\n}\n\n// Set up buffer utility according to the environment\nconfigure();\n"],"names":[],"mappings":"AACA,IAAI,WAAW;AAEf;;;;;CAKC,GACD,SAAS,KAAK,GAAG;AAEjB,gBAAgB;AAChB,SAAS,MAAM;AACf,SAAS,YAAY;AACrB,SAAS,MAAM;AACf,SAAS,YAAY;AAErB,UAAU;AACV,SAAS,IAAI;AACb,SAAS,GAAG;AACZ,SAAS,KAAK;AACd,SAAS,SAAS,GAAM;AAExB,wBAAwB,GACxB;;;CAGC,GACD,SAAS;IACL,SAAS,IAAI,CAAC,UAAU;IACxB,SAAS,MAAM,CAAC,UAAU,CAAC,SAAS,YAAY;IAChD,SAAS,MAAM,CAAC,UAAU,CAAC,SAAS,YAAY;AACpD;AAEA,qDAAqD;AACrD","ignoreList":[0]}},
    {"offset": {"line": 6116, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/unixfs/node_modules/protobufjs/minimal.js"],"sourcesContent":["// minimal library entry point.\n\n\"use strict\";\nmodule.exports = require(\"./src/index-minimal\");\n"],"names":[],"mappings":"AAAA,+BAA+B;AAG/B,OAAO,OAAO","ignoreList":[0]}}]
}