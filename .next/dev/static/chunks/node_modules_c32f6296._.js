(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/depd/lib/browser/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*!
 * depd
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ /**
 * Module exports.
 * @public
 */ module.exports = depd;
/**
 * Create deprecate for namespace in caller.
 */ function depd(namespace) {
    if (!namespace) {
        throw new TypeError('argument namespace is required');
    }
    function deprecate(message) {
    // no-op in browser
    }
    deprecate._file = undefined;
    deprecate._ignored = true;
    deprecate._namespace = namespace;
    deprecate._traced = false;
    deprecate._warned = Object.create(null);
    deprecate.function = wrapfunction;
    deprecate.property = wrapproperty;
    return deprecate;
}
/**
 * Return a wrapped function in a deprecation message.
 *
 * This is a no-op version of the wrapper, which does nothing but call
 * validation.
 */ function wrapfunction(fn, message) {
    if (typeof fn !== 'function') {
        throw new TypeError('argument fn must be a function');
    }
    return fn;
}
/**
 * Wrap property in a deprecation message.
 *
 * This is a no-op version of the wrapper, which does nothing but call
 * validation.
 */ function wrapproperty(obj, prop, message) {
    if (!obj || typeof obj !== 'object' && typeof obj !== 'function') {
        throw new TypeError('argument obj must be object');
    }
    var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
    if (!descriptor) {
        throw new TypeError('must call property on owner object');
    }
    if (!descriptor.configurable) {
        throw new TypeError('property must be configurable');
    }
}
}),
"[project]/node_modules/inherits/inherits_browser.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

if (typeof Object.create === 'function') {
    // implementation from standard node.js 'util' module
    module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                    value: ctor,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
        }
    };
} else {
    // old school shim for old browsers
    module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {};
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
        }
    };
}
}),
"[project]/node_modules/assertion-error/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/*!
 * assertion-error
 * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>
 * MIT Licensed
 */ /*!
 * Return a function that will copy properties from
 * one object to another excluding any originally
 * listed. Returned function will create a new `{}`.
 *
 * @param {String} excluded properties ...
 * @return {Function}
 */ function exclude() {
    var excludes = [].slice.call(arguments);
    function excludeProps(res, obj) {
        Object.keys(obj).forEach(function(key) {
            if (!~excludes.indexOf(key)) res[key] = obj[key];
        });
    }
    return function extendExclude() {
        var args = [].slice.call(arguments), i = 0, res = {};
        for(; i < args.length; i++){
            excludeProps(res, args[i]);
        }
        return res;
    };
}
;
/*!
 * Primary Exports
 */ module.exports = AssertionError;
/**
 * ### AssertionError
 *
 * An extension of the JavaScript `Error` constructor for
 * assertion and validation scenarios.
 *
 * @param {String} message
 * @param {Object} properties to include (optional)
 * @param {callee} start stack function (optional)
 */ function AssertionError(message, _props, ssf) {
    var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON'), props = extend(_props || {});
    // default values
    this.message = message || 'Unspecified AssertionError';
    this.showDiff = false;
    // copy from properties
    for(var key in props){
        this[key] = props[key];
    }
    // capture stack trace
    ssf = ssf || AssertionError;
    if (Error.captureStackTrace) {
        Error.captureStackTrace(this, ssf);
    } else {
        try {
            throw new Error();
        } catch (e) {
            this.stack = e.stack;
        }
    }
}
/*!
 * Inherit from Error.prototype
 */ AssertionError.prototype = Object.create(Error.prototype);
/*!
 * Statically set name
 */ AssertionError.prototype.name = 'AssertionError';
/*!
 * Ensure correct constructor
 */ AssertionError.prototype.constructor = AssertionError;
/**
 * Allow errors to be converted to JSON for static transfer.
 *
 * @param {Boolean} include stack (default: `true`)
 * @return {Object} object that can be `JSON.stringify`
 */ AssertionError.prototype.toJSON = function(stack) {
    var extend = exclude('constructor', 'toJSON', 'stack'), props = extend({
        name: this.name
    }, this);
    // include stack if exists and not turned off
    if (false !== stack && this.stack) {
        props.stack = this.stack;
    }
    return props;
};
}),
"[project]/node_modules/sprintf-js/src/sprintf.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/* global window, exports, define */ !function() {
    'use strict';
    var re = {
        not_string: /[^s]/,
        not_bool: /[^t]/,
        not_type: /[^T]/,
        not_primitive: /[^v]/,
        number: /[diefg]/,
        numeric_arg: /[bcdiefguxX]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[+-]/
    };
    function sprintf(key) {
        // `arguments` is not an array, but should be fine for this call
        return sprintf_format(sprintf_parse(key), arguments);
    }
    function vsprintf(fmt, argv) {
        return sprintf.apply(null, [
            fmt
        ].concat(argv || []));
    }
    function sprintf_format(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, arg, output = '', i, k, ph, pad, pad_character, pad_length, is_positive, sign;
        for(i = 0; i < tree_length; i++){
            if (typeof parse_tree[i] === 'string') {
                output += parse_tree[i];
            } else if (typeof parse_tree[i] === 'object') {
                ph = parse_tree[i]; // convenience purposes only
                if (ph.keys) {
                    arg = argv[cursor];
                    for(k = 0; k < ph.keys.length; k++){
                        if (arg == undefined) {
                            throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k - 1]));
                        }
                        arg = arg[ph.keys[k]];
                    }
                } else if (ph.param_no) {
                    arg = argv[ph.param_no];
                } else {
                    arg = argv[cursor++];
                }
                if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
                    arg = arg();
                }
                if (re.numeric_arg.test(ph.type) && typeof arg !== 'number' && isNaN(arg)) {
                    throw new TypeError(sprintf('[sprintf] expecting number but found %T', arg));
                }
                if (re.number.test(ph.type)) {
                    is_positive = arg >= 0;
                }
                switch(ph.type){
                    case 'b':
                        arg = parseInt(arg, 10).toString(2);
                        break;
                    case 'c':
                        arg = String.fromCharCode(parseInt(arg, 10));
                        break;
                    case 'd':
                    case 'i':
                        arg = parseInt(arg, 10);
                        break;
                    case 'j':
                        arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
                        break;
                    case 'e':
                        arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
                        break;
                    case 'f':
                        arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
                        break;
                    case 'g':
                        arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
                        break;
                    case 'o':
                        arg = (parseInt(arg, 10) >>> 0).toString(8);
                        break;
                    case 's':
                        arg = String(arg);
                        arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                        break;
                    case 't':
                        arg = String(!!arg);
                        arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                        break;
                    case 'T':
                        arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
                        arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                        break;
                    case 'u':
                        arg = parseInt(arg, 10) >>> 0;
                        break;
                    case 'v':
                        arg = arg.valueOf();
                        arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                        break;
                    case 'x':
                        arg = (parseInt(arg, 10) >>> 0).toString(16);
                        break;
                    case 'X':
                        arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
                        break;
                }
                if (re.json.test(ph.type)) {
                    output += arg;
                } else {
                    if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
                        sign = is_positive ? '+' : '-';
                        arg = arg.toString().replace(re.sign, '');
                    } else {
                        sign = '';
                    }
                    pad_character = ph.pad_char ? ph.pad_char === '0' ? '0' : ph.pad_char.charAt(1) : ' ';
                    pad_length = ph.width - (sign + arg).length;
                    pad = ph.width ? pad_length > 0 ? pad_character.repeat(pad_length) : '' : '';
                    output += ph.align ? sign + arg + pad : pad_character === '0' ? sign + pad + arg : pad + sign + arg;
                }
            }
        }
        return output;
    }
    var sprintf_cache = Object.create(null);
    function sprintf_parse(fmt) {
        if (sprintf_cache[fmt]) {
            return sprintf_cache[fmt];
        }
        var _fmt = fmt, match, parse_tree = [], arg_names = 0;
        while(_fmt){
            if ((match = re.text.exec(_fmt)) !== null) {
                parse_tree.push(match[0]);
            } else if ((match = re.modulo.exec(_fmt)) !== null) {
                parse_tree.push('%');
            } else if ((match = re.placeholder.exec(_fmt)) !== null) {
                if (match[2]) {
                    arg_names |= 1;
                    var field_list = [], replacement_field = match[2], field_match = [];
                    if ((field_match = re.key.exec(replacement_field)) !== null) {
                        field_list.push(field_match[1]);
                        while((replacement_field = replacement_field.substring(field_match[0].length)) !== ''){
                            if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                                field_list.push(field_match[1]);
                            } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                                field_list.push(field_match[1]);
                            } else {
                                throw new SyntaxError('[sprintf] failed to parse named argument key');
                            }
                        }
                    } else {
                        throw new SyntaxError('[sprintf] failed to parse named argument key');
                    }
                    match[2] = field_list;
                } else {
                    arg_names |= 2;
                }
                if (arg_names === 3) {
                    throw new Error('[sprintf] mixing positional and named placeholders is not (yet) supported');
                }
                parse_tree.push({
                    placeholder: match[0],
                    param_no: match[1],
                    keys: match[2],
                    sign: match[3],
                    pad_char: match[4],
                    align: match[5],
                    width: match[6],
                    precision: match[7],
                    type: match[8]
                });
            } else {
                throw new SyntaxError('[sprintf] unexpected placeholder');
            }
            _fmt = _fmt.substring(match[0].length);
        }
        return sprintf_cache[fmt] = parse_tree;
    }
    /**
     * export to either browser or node.js
     */ /* eslint-disable quote-props */ if ("TURBOPACK compile-time truthy", 1) {
        exports['sprintf'] = sprintf;
        exports['vsprintf'] = vsprintf;
    }
    if (typeof window !== 'undefined') {
        window['sprintf'] = sprintf;
        window['vsprintf'] = vsprintf;
        if (typeof define === 'function' && define['amd']) {
            ((r)=>r !== undefined && __turbopack_context__.v(r))(function() {
                return {
                    'sprintf': sprintf,
                    'vsprintf': vsprintf
                };
            }(__turbopack_context__.r, exports, module));
        }
    }
/* eslint-enable quote-props */ }(); // eslint-disable-line
}),
"[project]/node_modules/@openagenda/verror/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from, except, desc)=>{
    if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from[key],
            enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
// src/index.js
var src_exports = {};
__export(src_exports, {
    BadGateway: ()=>BadGateway,
    BadRequest: ()=>BadRequest,
    Conflict: ()=>Conflict,
    Forbidden: ()=>Forbidden,
    GeneralError: ()=>GeneralError,
    Gone: ()=>Gone,
    LengthRequired: ()=>LengthRequired,
    MethodNotAllowed: ()=>MethodNotAllowed,
    NotAcceptable: ()=>NotAcceptable,
    NotAuthenticated: ()=>NotAuthenticated,
    NotFound: ()=>NotFound,
    NotImplemented: ()=>NotImplemented,
    PaymentError: ()=>PaymentError,
    Timeout: ()=>Timeout,
    TooManyRequests: ()=>TooManyRequests,
    Unavailable: ()=>Unavailable,
    Unprocessable: ()=>Unprocessable,
    VError: ()=>verror_default,
    default: ()=>src_default
});
module.exports = __toCommonJS(src_exports);
// src/verror.js
var import_inherits = __toESM(__turbopack_context__.r("[project]/node_modules/inherits/inherits_browser.js [app-client] (ecmascript)"));
var import_assertion_error2 = __toESM(__turbopack_context__.r("[project]/node_modules/assertion-error/index.js [app-client] (ecmascript)"));
// src/assert.js
function isError(arg) {
    return Object.prototype.toString.call(arg) === "[object Error]" || arg instanceof Error;
}
function isObject(arg) {
    return typeof arg === "object" && arg !== null;
}
function isString(arg) {
    return typeof arg === "string";
}
function isFunc(arg) {
    return typeof arg === "function";
}
// src/parseConstructorArguments.js
var import_sprintf_js = __turbopack_context__.r("[project]/node_modules/sprintf-js/src/sprintf.js [app-client] (ecmascript)");
var import_assertion_error = __toESM(__turbopack_context__.r("[project]/node_modules/assertion-error/index.js [app-client] (ecmascript)"));
function parseConstructorArguments(...argv) {
    let options;
    let sprintfArgs;
    if (argv.length === 0) {
        options = {};
        sprintfArgs = [];
    } else if (isError(argv[0])) {
        options = {
            cause: argv[0]
        };
        sprintfArgs = argv.slice(1);
    } else if (typeof argv[0] === "object") {
        options = {};
        for(const k in argv[0]){
            if (Object.prototype.hasOwnProperty.call(argv[0], k)) {
                options[k] = argv[0][k];
            }
        }
        sprintfArgs = argv.slice(1);
    } else {
        if (!isString(argv[0])) {
            throw new import_assertion_error.default("first argument to VError, or WError constructor must be a string, object, or Error");
        }
        options = {};
        sprintfArgs = argv;
    }
    if (!isObject(options)) throw new import_assertion_error.default("options (object) is required");
    if (options.meta && !isObject(options.meta)) throw new import_assertion_error.default("options.meta must be an object");
    return {
        options,
        shortMessage: sprintfArgs.length === 0 ? "" : import_sprintf_js.sprintf.apply(null, sprintfArgs)
    };
}
// src/utils.js
function defineProperty(target, descriptor) {
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
}
function defineProperties(target, props) {
    for(let i = 0; i < props.length; i++){
        defineProperty(target, props[i]);
    }
}
// src/verror.js
var META = "@@verror/meta";
var reserved = [
    "name",
    "message",
    "shortMessage",
    "cause",
    "info",
    "stack",
    "fileName",
    "lineNumber"
];
function mergeMeta(instance, meta2) {
    if (!meta2) {
        return;
    }
    for(const k in meta2){
        if (Object.prototype.hasOwnProperty.call(meta2, k)) {
            if (reserved.includes(k)) {
                throw new import_assertion_error2.default(`"${k}" is a reserved meta`);
            }
            instance[META][k] = meta2[k];
            instance[k] = meta2[k];
        }
    }
}
function VError(...args) {
    if (!(this instanceof VError)) {
        return new VError(...args);
    }
    const { options, shortMessage } = parseConstructorArguments(...args);
    const { cause: cause2, constructorOpt, info: info2, name, skipCauseMessage, meta: meta2 } = options;
    let message = shortMessage;
    if (cause2) {
        if (!isError(cause2)) throw new import_assertion_error2.default("cause is not an Error");
        if (!skipCauseMessage && cause2.message) {
            message = message === "" ? cause2.message : `${message}: ${cause2.message}`;
        }
    }
    Error.call(this, message);
    if (name) {
        if (!isString(name)) throw new import_assertion_error2.default(`error's "name" must be a string`);
        this.name = name;
    }
    this.message = message;
    this.shortMessage = shortMessage;
    if (cause2) {
        this.cause = cause2;
    }
    this.info = {};
    if (info2) {
        for(const k in info2){
            if (Object.prototype.hasOwnProperty.call(info2, k)) {
                this.info[k] = info2[k];
            }
        }
    }
    defineProperty(this, {
        key: META,
        value: {}
    });
    mergeMeta(this, VError.meta(this));
    mergeMeta(this, meta2);
    if (Error.captureStackTrace) {
        Error.captureStackTrace(this, constructorOpt || this.constructor);
    } else {
        this.stack = new Error().stack;
    }
}
(0, import_inherits.default)(VError, Error);
defineProperties(VError.prototype, [
    {
        key: "toString",
        value: function toString() {
            let str = Object.prototype.hasOwnProperty.call(this, "name") && this.name || this.constructor.name || this.constructor.prototype.name;
            if (this.message) {
                str += `: ${this.message}`;
            }
            return str;
        }
    },
    {
        key: "toJSON",
        value: function toJSON() {
            const obj = {
                name: this.name,
                message: this.message,
                shortMessage: this.shortMessage,
                cause: this.cause,
                info: this.info
            };
            for(const key in this[META]){
                if (Object.prototype.hasOwnProperty.call(this[META], key) && !(key in obj)) {
                    obj[key] = this[META][key];
                }
            }
            return obj;
        }
    }
]);
defineProperties(VError, [
    {
        key: "cause",
        value: function cause(err) {
            if (!isError(err)) throw new import_assertion_error2.default("err must be an Error");
            return isError(err.cause) ? err.cause : null;
        }
    },
    {
        key: "info",
        value: function info(err) {
            if (!isError(err)) throw new import_assertion_error2.default("err must be an Error");
            const cause2 = VError.cause(err);
            const rv = cause2 !== null ? VError.info(cause2) : {};
            if (isObject(err.info)) {
                for(const k in err.info){
                    if (Object.prototype.hasOwnProperty.call(err.info, k)) {
                        rv[k] = err.info[k];
                    }
                }
            }
            return rv;
        }
    },
    {
        key: "meta",
        value: function meta(err) {
            if (!isError(err)) throw new import_assertion_error2.default("err must be an Error");
            const cause2 = VError.cause(err);
            const rv = cause2 !== null ? VError.meta(cause2) : {};
            if (isObject(err[META])) {
                for(const k in err[META]){
                    if (Object.prototype.hasOwnProperty.call(err[META], k)) {
                        rv[k] = err[META][k];
                    }
                }
            }
            return rv;
        }
    },
    {
        key: "findCauseByName",
        value: function findCauseByName(err, name) {
            if (!isError(err)) throw new import_assertion_error2.default("err must be an Error");
            if (!isString(name)) throw new import_assertion_error2.default("name (string) is required");
            if (name.length <= 0) throw new import_assertion_error2.default("name cannot be empty");
            for(let cause2 = err; cause2 !== null; cause2 = VError.cause(cause2)){
                if (!isError(err)) throw new import_assertion_error2.default("cause must be an Error");
                if (cause2.name === name) {
                    return cause2;
                }
            }
            return null;
        }
    },
    {
        key: "findCauseByType",
        value: function findCauseByType(err, type) {
            if (!isError(err)) throw new import_assertion_error2.default("err must be an Error");
            if (!isFunc(type)) throw new import_assertion_error2.default("type (func) is required");
            for(let cause2 = err; cause2 !== null; cause2 = VError.cause(cause2)){
                if (!isError(err)) throw new import_assertion_error2.default("cause must be an Error");
                if (cause2 instanceof type) {
                    return cause2;
                }
            }
            return null;
        }
    },
    {
        key: "hasCauseWithName",
        value: function hasCauseWithName(err, name) {
            return VError.findCauseByName(err, name) !== null;
        }
    },
    {
        key: "hasCauseWithType",
        value: function hasCauseWithType(err, type) {
            return VError.findCauseByType(err, type) !== null;
        }
    },
    {
        key: "fullStack",
        value: function fullStack(err) {
            if (!isError(err)) throw new import_assertion_error2.default("err must be an Error");
            const cause2 = VError.cause(err);
            if (cause2) {
                return `${err.stack}
caused by: ${VError.fullStack(cause2)}`;
            }
            return err.stack;
        }
    },
    {
        key: "errorFromList",
        value: function errorFromList(errors) {
            if (!Array.isArray(errors)) {
                throw new import_assertion_error2.default("list of errors (array) is required");
            }
            errors.forEach(function(error) {
                if (!isObject(error)) {
                    throw new import_assertion_error2.default("errors ([object]) is required");
                }
            });
            if (errors.length === 0) {
                return null;
            }
            errors.forEach((e)=>{
                if (!isError(e)) throw new import_assertion_error2.default("error must be an Error");
            });
            if (errors.length === 1) {
                return errors[0];
            }
            return new MultiError(errors);
        }
    },
    {
        key: "errorForEach",
        value: function errorForEach(err, func) {
            if (!isError(err)) throw new import_assertion_error2.default("err must be an Error");
            if (!isFunc(func)) throw new import_assertion_error2.default("func (func) is required");
            if (err instanceof MultiError) {
                err.errors.forEach((e)=>{
                    func(e);
                });
            } else {
                func(err);
            }
        }
    }
]);
VError.prototype.name = "VError";
function MultiError(errors) {
    if (!(this instanceof MultiError)) {
        return new MultiError(errors);
    }
    if (!Array.isArray(errors)) {
        throw new import_assertion_error2.default("list of errors (array) is required");
    }
    if (errors.length <= 0) {
        throw new import_assertion_error2.default("must be at least one error is required");
    }
    VError.call(this, {
        cause: errors[0],
        meta: {
            errors: [
                ...errors
            ]
        }
    }, "first of %d error%s", errors.length, errors.length === 1 ? "" : "s");
}
(0, import_inherits.default)(MultiError, VError);
MultiError.prototype.name = "MultiError";
function WError(...args) {
    if (!(this instanceof WError)) {
        return new WError(...args);
    }
    const { options, shortMessage } = parseConstructorArguments(...args);
    options.skipCauseMessage = true;
    VError.call(this, options, "%s", shortMessage);
}
(0, import_inherits.default)(WError, VError);
defineProperties(WError.prototype, [
    {
        key: "toString",
        value: function toString2() {
            let str = Object.prototype.hasOwnProperty.call(this, "name") && this.name || this.constructor.name || this.constructor.prototype.name;
            if (this.message) {
                str += `: ${this.message}`;
            }
            if (this.cause && this.cause.message) {
                str += `; caused by ${this.cause.toString()}`;
            }
            return str;
        }
    }
]);
WError.prototype.name = "WError";
VError.VError = VError;
VError.WError = WError;
VError.MultiError = MultiError;
VError.META = META;
var verror_default = VError;
// src/http.js
var http_exports = {};
__export(http_exports, {
    BadGateway: ()=>BadGateway,
    BadRequest: ()=>BadRequest,
    Conflict: ()=>Conflict,
    Forbidden: ()=>Forbidden,
    GeneralError: ()=>GeneralError,
    Gone: ()=>Gone,
    LengthRequired: ()=>LengthRequired,
    MethodNotAllowed: ()=>MethodNotAllowed,
    NotAcceptable: ()=>NotAcceptable,
    NotAuthenticated: ()=>NotAuthenticated,
    NotFound: ()=>NotFound,
    NotImplemented: ()=>NotImplemented,
    PaymentError: ()=>PaymentError,
    Timeout: ()=>Timeout,
    TooManyRequests: ()=>TooManyRequests,
    Unavailable: ()=>Unavailable,
    Unprocessable: ()=>Unprocessable,
    VError: ()=>verror_default
});
var import_inherits2 = __toESM(__turbopack_context__.r("[project]/node_modules/inherits/inherits_browser.js [app-client] (ecmascript)"));
var import_depd = __toESM(__turbopack_context__.r("[project]/node_modules/depd/lib/browser/index.js [app-client] (ecmascript)"));
var deprecate = (0, import_depd.default)("@openangeda/verror");
function createError(name, statusCode, className) {
    const ExtendedError = function(...args) {
        if (!(this instanceof ExtendedError)) {
            return new ExtendedError(...args);
        }
        const { options, shortMessage } = parseConstructorArguments(...args);
        options.meta = {
            code: statusCode,
            statusCode,
            className,
            ...options.meta
        };
        verror_default.call(this, options, shortMessage);
        deprecate.property(this, "code", "use `statusCode` instead of `code`");
    };
    Object.defineProperty(ExtendedError, "name", {
        configurable: true,
        value: name
    });
    (0, import_inherits2.default)(ExtendedError, verror_default);
    ExtendedError.prototype.name = name;
    return ExtendedError;
}
var BadRequest = createError("BadRequest", 400, "bad-request");
var NotAuthenticated = createError("NotAuthenticated", 401, "not-authenticated");
var PaymentError = createError("PaymentError", 402, "payment-error");
var Forbidden = createError("Forbidden", 403, "forbidden");
var NotFound = createError("NotFound", 404, "not-found");
var MethodNotAllowed = createError("MethodNotAllowed", 405, "method-not-allowed");
var NotAcceptable = createError("NotAcceptable", 406, "not-acceptable");
var Timeout = createError("Timeout", 408, "timeout");
var Conflict = createError("Conflict", 409, "conflict");
var Gone = createError("Gone", 410, "gone");
var LengthRequired = createError("LengthRequired", 411, "length-required");
var Unprocessable = createError("Unprocessable", 422, "unprocessable");
var TooManyRequests = createError("TooManyRequests", 429, "too-many-requests");
var GeneralError = createError("GeneralError", 500, "general-error");
var NotImplemented = createError("NotImplemented", 501, "not-implemented");
var BadGateway = createError("BadGateway", 502, "bad-gateway");
var Unavailable = createError("Unavailable", 503, "unavailable");
// src/index.js
var httpAliases = {
    400: BadRequest,
    401: NotAuthenticated,
    402: PaymentError,
    403: Forbidden,
    404: NotFound,
    405: MethodNotAllowed,
    406: NotAcceptable,
    408: Timeout,
    409: Conflict,
    410: Gone,
    411: LengthRequired,
    422: Unprocessable,
    429: TooManyRequests,
    500: GeneralError,
    501: NotImplemented,
    502: BadGateway,
    503: Unavailable
};
Object.assign(verror_default, http_exports, httpAliases);
var src_default = verror_default;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
    BadGateway,
    BadRequest,
    Conflict,
    Forbidden,
    GeneralError,
    Gone,
    LengthRequired,
    MethodNotAllowed,
    NotAcceptable,
    NotAuthenticated,
    NotFound,
    NotImplemented,
    PaymentError,
    Timeout,
    TooManyRequests,
    Unavailable,
    Unprocessable,
    VError
});
}),
"[project]/node_modules/@openagenda/verror/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = __turbopack_context__.r("[project]/node_modules/@openagenda/verror/dist/index.js [app-client] (ecmascript)").default;
}),
"[project]/node_modules/bech32/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.bech32m = exports.bech32 = void 0;
const ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
const ALPHABET_MAP = {};
for(let z = 0; z < ALPHABET.length; z++){
    const x = ALPHABET.charAt(z);
    ALPHABET_MAP[x] = z;
}
function polymodStep(pre) {
    const b = pre >> 25;
    return (pre & 0x1ffffff) << 5 ^ -(b >> 0 & 1) & 0x3b6a57b2 ^ -(b >> 1 & 1) & 0x26508e6d ^ -(b >> 2 & 1) & 0x1ea119fa ^ -(b >> 3 & 1) & 0x3d4233dd ^ -(b >> 4 & 1) & 0x2a1462b3;
}
function prefixChk(prefix) {
    let chk = 1;
    for(let i = 0; i < prefix.length; ++i){
        const c = prefix.charCodeAt(i);
        if (c < 33 || c > 126) return 'Invalid prefix (' + prefix + ')';
        chk = polymodStep(chk) ^ c >> 5;
    }
    chk = polymodStep(chk);
    for(let i = 0; i < prefix.length; ++i){
        const v = prefix.charCodeAt(i);
        chk = polymodStep(chk) ^ v & 0x1f;
    }
    return chk;
}
function convert(data, inBits, outBits, pad) {
    let value = 0;
    let bits = 0;
    const maxV = (1 << outBits) - 1;
    const result = [];
    for(let i = 0; i < data.length; ++i){
        value = value << inBits | data[i];
        bits += inBits;
        while(bits >= outBits){
            bits -= outBits;
            result.push(value >> bits & maxV);
        }
    }
    if (pad) {
        if (bits > 0) {
            result.push(value << outBits - bits & maxV);
        }
    } else {
        if (bits >= inBits) return 'Excess padding';
        if (value << outBits - bits & maxV) return 'Non-zero padding';
    }
    return result;
}
function toWords(bytes) {
    return convert(bytes, 8, 5, true);
}
function fromWordsUnsafe(words) {
    const res = convert(words, 5, 8, false);
    if (Array.isArray(res)) return res;
}
function fromWords(words) {
    const res = convert(words, 5, 8, false);
    if (Array.isArray(res)) return res;
    throw new Error(res);
}
function getLibraryFromEncoding(encoding) {
    let ENCODING_CONST;
    if (encoding === 'bech32') {
        ENCODING_CONST = 1;
    } else {
        ENCODING_CONST = 0x2bc830a3;
    }
    function encode(prefix, words, LIMIT) {
        LIMIT = LIMIT || 90;
        if (prefix.length + 7 + words.length > LIMIT) throw new TypeError('Exceeds length limit');
        prefix = prefix.toLowerCase();
        // determine chk mod
        let chk = prefixChk(prefix);
        if (typeof chk === 'string') throw new Error(chk);
        let result = prefix + '1';
        for(let i = 0; i < words.length; ++i){
            const x = words[i];
            if (x >> 5 !== 0) throw new Error('Non 5-bit word');
            chk = polymodStep(chk) ^ x;
            result += ALPHABET.charAt(x);
        }
        for(let i = 0; i < 6; ++i){
            chk = polymodStep(chk);
        }
        chk ^= ENCODING_CONST;
        for(let i = 0; i < 6; ++i){
            const v = chk >> (5 - i) * 5 & 0x1f;
            result += ALPHABET.charAt(v);
        }
        return result;
    }
    function __decode(str, LIMIT) {
        LIMIT = LIMIT || 90;
        if (str.length < 8) return str + ' too short';
        if (str.length > LIMIT) return 'Exceeds length limit';
        // don't allow mixed case
        const lowered = str.toLowerCase();
        const uppered = str.toUpperCase();
        if (str !== lowered && str !== uppered) return 'Mixed-case string ' + str;
        str = lowered;
        const split = str.lastIndexOf('1');
        if (split === -1) return 'No separator character for ' + str;
        if (split === 0) return 'Missing prefix for ' + str;
        const prefix = str.slice(0, split);
        const wordChars = str.slice(split + 1);
        if (wordChars.length < 6) return 'Data too short';
        let chk = prefixChk(prefix);
        if (typeof chk === 'string') return chk;
        const words = [];
        for(let i = 0; i < wordChars.length; ++i){
            const c = wordChars.charAt(i);
            const v = ALPHABET_MAP[c];
            if (v === undefined) return 'Unknown character ' + c;
            chk = polymodStep(chk) ^ v;
            // not in the checksum?
            if (i + 6 >= wordChars.length) continue;
            words.push(v);
        }
        if (chk !== ENCODING_CONST) return 'Invalid checksum for ' + str;
        return {
            prefix,
            words
        };
    }
    function decodeUnsafe(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === 'object') return res;
    }
    function decode(str, LIMIT) {
        const res = __decode(str, LIMIT);
        if (typeof res === 'object') return res;
        throw new Error(res);
    }
    return {
        decodeUnsafe,
        decode,
        encode,
        toWords,
        fromWordsUnsafe,
        fromWords
    };
}
exports.bech32 = getLibraryFromEncoding('bech32');
exports.bech32m = getLibraryFromEncoding('bech32m');
}),
"[project]/node_modules/base64-js/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
for(var i = 0, len = code.length; i < len; ++i){
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
}
// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;
function getLens(b64) {
    var len = b64.length;
    if (len % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4');
    }
    // Trim off extra bytes after placeholder bytes are found
    // See: https://github.com/beatgammit/base64-js/issues/42
    var validLen = b64.indexOf('=');
    if (validLen === -1) validLen = len;
    var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
    return [
        validLen,
        placeHoldersLen
    ];
}
// base64 is 4/3 + up to two characters of the original data
function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    // if there are placeholders, only get up to the last complete 4 chars
    var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i;
    for(i = 0; i < len; i += 4){
        tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
        arr[curByte++] = tmp >> 16 & 0xFF;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
        arr[curByte++] = tmp & 0xFF;
    }
    if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 0xFF;
        arr[curByte++] = tmp & 0xFF;
    }
    return arr;
}
function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}
function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for(var i = start; i < end; i += 3){
        tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
        output.push(tripletToBase64(tmp));
    }
    return output.join('');
}
function fromByteArray(uint8) {
    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
    ;
    var parts = [];
    var maxChunkLength = 16383 // must be multiple of 3
    ;
    // go through the array every three bytes, we'll deal with trailing stuff later
    for(var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength){
        parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    }
    // pad the end with zeros, but make sure to not forget the extra bytes
    if (extraBytes === 1) {
        tmp = uint8[len - 1];
        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
    } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1];
        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
    }
    return parts.join('');
}
}),
"[project]/node_modules/ieee754/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ exports.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for(; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8){}
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for(; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8){}
    if (e === 0) {
        e = 1 - eBias;
    } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};
exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
    } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
        }
        if (e + eBias >= 1) {
            value += rt / c;
        } else {
            value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
            e++;
            c /= 2;
        }
        if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
        } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
        } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
        }
    }
    for(; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8){}
    e = e << mLen | m;
    eLen += mLen;
    for(; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8){}
    buffer[offset + i - d] |= s * 128;
};
}),
"[project]/node_modules/buffer/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ /* eslint-disable no-proto */ const base64 = __turbopack_context__.r("[project]/node_modules/base64-js/index.js [app-client] (ecmascript)");
const ieee754 = __turbopack_context__.r("[project]/node_modules/ieee754/index.js [app-client] (ecmascript)");
const customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
 : null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
const K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */ Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
    console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
}
function typedArraySupport() {
    // Can typed array instances can be augmented?
    try {
        const arr = new Uint8Array(1);
        const proto = {
            foo: function() {
                return 42;
            }
        };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
    } catch (e) {
        return false;
    }
}
Object.defineProperty(Buffer.prototype, 'parent', {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.buffer;
    }
});
Object.defineProperty(Buffer.prototype, 'offset', {
    enumerable: true,
    get: function() {
        if (!Buffer.isBuffer(this)) return undefined;
        return this.byteOffset;
    }
});
function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    // Return an augmented `Uint8Array` instance
    const buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */ function Buffer(arg, encodingOrOffset, length) {
    // Common case.
    if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
            throw new TypeError('The "string" argument must be of type string. Received type number');
        }
        return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
}
Buffer.poolSize = 8192; // not used by this implementation
function from(value, encodingOrOffset, length) {
    if (typeof value === 'string') {
        return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
    }
    if (value == null) {
        throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === 'number') {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    const valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
        return Buffer.from(valueOf, encodingOrOffset, length);
    }
    const b = fromObject(value);
    if (b) return b;
    if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {
        return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
    }
    throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/ Buffer.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
};
// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);
function assertSize(size) {
    if (typeof size !== 'number') {
        throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
}
function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
        return createBuffer(size);
    }
    if (fill !== undefined) {
        // Only pay attention to encoding if it's a string. This
        // prevents accidentally sending in a number that would
        // be interpreted as a start offset.
        return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/ Buffer.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
};
function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */ Buffer.allocUnsafe = function(size) {
    return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */ Buffer.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
};
function fromString(string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
        encoding = 'utf8';
    }
    if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding);
    }
    const length = byteLength(string, encoding) | 0;
    let buf = createBuffer(length);
    const actual = buf.write(string, encoding);
    if (actual !== length) {
        // Writing a hex string, for example, that contains invalid characters will
        // cause everything after the first invalid character to be ignored. (e.g.
        // 'abxxcd' will be treated as 'ab')
        buf = buf.slice(0, actual);
    }
    return buf;
}
function fromArrayLike(array) {
    const length = array.length < 0 ? 0 : checked(array.length) | 0;
    const buf = createBuffer(length);
    for(let i = 0; i < length; i += 1){
        buf[i] = array[i] & 255;
    }
    return buf;
}
function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
}
function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
    }
    let buf;
    if (byteOffset === undefined && length === undefined) {
        buf = new Uint8Array(array);
    } else if (length === undefined) {
        buf = new Uint8Array(array, byteOffset);
    } else {
        buf = new Uint8Array(array, byteOffset, length);
    }
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(buf, Buffer.prototype);
    return buf;
}
function fromObject(obj) {
    if (Buffer.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
            return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
    }
    if (obj.length !== undefined) {
        if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
            return createBuffer(0);
        }
        return fromArrayLike(obj);
    }
    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
    }
}
function checked(length) {
    // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= K_MAX_LENGTH) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
    }
    return length | 0;
}
function SlowBuffer(length) {
    if (+length != length) {
        length = 0;
    }
    return Buffer.alloc(+length);
}
Buffer.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
    ;
};
Buffer.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a === b) return 0;
    let x = a.length;
    let y = b.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i){
        if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
        }
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
Buffer.isEncoding = function isEncoding(encoding) {
    switch(String(encoding).toLowerCase()){
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
            return true;
        default:
            return false;
    }
};
Buffer.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
        return Buffer.alloc(0);
    }
    let i;
    if (length === undefined) {
        length = 0;
        for(i = 0; i < list.length; ++i){
            length += list[i].length;
        }
    }
    const buffer = Buffer.allocUnsafe(length);
    let pos = 0;
    for(i = 0; i < list.length; ++i){
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
                if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
                buf.copy(buffer, pos);
            } else {
                Uint8Array.prototype.set.call(buffer, buf, pos);
            }
        } else if (!Buffer.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
            buf.copy(buffer, pos);
        }
        pos += buf.length;
    }
    return buffer;
};
function byteLength(string, encoding) {
    if (Buffer.isBuffer(string)) {
        return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
    }
    if (typeof string !== 'string') {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + typeof string);
    }
    const len = string.length;
    const mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0) return 0;
    // Use a for loop to avoid recursion
    let loweredCase = false;
    for(;;){
        switch(encoding){
            case 'ascii':
            case 'latin1':
            case 'binary':
                return len;
            case 'utf8':
            case 'utf-8':
                return utf8ToBytes(string).length;
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
                return len * 2;
            case 'hex':
                return len >>> 1;
            case 'base64':
                return base64ToBytes(string).length;
            default:
                if (loweredCase) {
                    return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
                    ;
                }
                encoding = ('' + encoding).toLowerCase();
                loweredCase = true;
        }
    }
}
Buffer.byteLength = byteLength;
function slowToString(encoding, start, end) {
    let loweredCase = false;
    // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
    if (start === undefined || start < 0) {
        start = 0;
    }
    // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.
    if (start > this.length) {
        return '';
    }
    if (end === undefined || end > this.length) {
        end = this.length;
    }
    if (end <= 0) {
        return '';
    }
    // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
        return '';
    }
    if (!encoding) encoding = 'utf8';
    while(true){
        switch(encoding){
            case 'hex':
                return hexSlice(this, start, end);
            case 'utf8':
            case 'utf-8':
                return utf8Slice(this, start, end);
            case 'ascii':
                return asciiSlice(this, start, end);
            case 'latin1':
            case 'binary':
                return latin1Slice(this, start, end);
            case 'base64':
                return base64Slice(this, start, end);
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
                return utf16leSlice(this, start, end);
            default:
                if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
                encoding = (encoding + '').toLowerCase();
                loweredCase = true;
        }
    }
}
// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true;
function swap(b, n, m) {
    const i = b[n];
    b[n] = b[m];
    b[m] = i;
}
Buffer.prototype.swap16 = function swap16() {
    const len = this.length;
    if (len % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits');
    }
    for(let i = 0; i < len; i += 2){
        swap(this, i, i + 1);
    }
    return this;
};
Buffer.prototype.swap32 = function swap32() {
    const len = this.length;
    if (len % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits');
    }
    for(let i = 0; i < len; i += 4){
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
    }
    return this;
};
Buffer.prototype.swap64 = function swap64() {
    const len = this.length;
    if (len % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits');
    }
    for(let i = 0; i < len; i += 8){
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
    }
    return this;
};
Buffer.prototype.toString = function toString() {
    const length = this.length;
    if (length === 0) return '';
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
};
Buffer.prototype.toLocaleString = Buffer.prototype.toString;
Buffer.prototype.equals = function equals(b) {
    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
};
Buffer.prototype.inspect = function inspect() {
    let str = '';
    const max = exports.INSPECT_MAX_BYTES;
    str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
    if (this.length > max) str += ' ... ';
    return '<Buffer ' + str + '>';
};
if (customInspectSymbol) {
    Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
}
Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
        target = Buffer.from(target, target.offset, target.byteLength);
    }
    if (!Buffer.isBuffer(target)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + typeof target);
    }
    if (start === undefined) {
        start = 0;
    }
    if (end === undefined) {
        end = target ? target.length : 0;
    }
    if (thisStart === undefined) {
        thisStart = 0;
    }
    if (thisEnd === undefined) {
        thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError('out of range index');
    }
    if (thisStart >= thisEnd && start >= end) {
        return 0;
    }
    if (thisStart >= thisEnd) {
        return -1;
    }
    if (start >= end) {
        return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    let x = thisEnd - thisStart;
    let y = end - start;
    const len = Math.min(x, y);
    const thisCopy = this.slice(thisStart, thisEnd);
    const targetCopy = target.slice(start, end);
    for(let i = 0; i < len; ++i){
        if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
        }
    }
    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
};
// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1;
    // Normalize byteOffset
    if (typeof byteOffset === 'string') {
        encoding = byteOffset;
        byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000;
    }
    byteOffset = +byteOffset; // Coerce to Number.
    if (numberIsNaN(byteOffset)) {
        // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
        byteOffset = dir ? 0 : buffer.length - 1;
    }
    // Normalize byteOffset: negative offsets start from the end of the buffer
    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
    }
    // Normalize val
    if (typeof val === 'string') {
        val = Buffer.from(val, encoding);
    }
    // Finally, search either indexOf (if dir is true) or lastIndexOf
    if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) {
            return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === 'number') {
        val = val & 0xFF; // Search for a byte value [0-255]
        if (typeof Uint8Array.prototype.indexOf === 'function') {
            if (dir) {
                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
                return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
        }
        return arrayIndexOf(buffer, [
            val
        ], byteOffset, encoding, dir);
    }
    throw new TypeError('val must be string, number or Buffer');
}
function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    let indexSize = 1;
    let arrLength = arr.length;
    let valLength = val.length;
    if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase();
        if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
            if (arr.length < 2 || val.length < 2) {
                return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
        }
    }
    function read(buf, i) {
        if (indexSize === 1) {
            return buf[i];
        } else {
            return buf.readUInt16BE(i * indexSize);
        }
    }
    let i;
    if (dir) {
        let foundIndex = -1;
        for(i = byteOffset; i < arrLength; i++){
            if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                if (foundIndex === -1) foundIndex = i;
                if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
            } else {
                if (foundIndex !== -1) i -= i - foundIndex;
                foundIndex = -1;
            }
        }
    } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for(i = byteOffset; i >= 0; i--){
            let found = true;
            for(let j = 0; j < valLength; j++){
                if (read(arr, i + j) !== read(val, j)) {
                    found = false;
                    break;
                }
            }
            if (found) return i;
        }
    }
    return -1;
}
Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
};
Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};
Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};
function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    const remaining = buf.length - offset;
    if (!length) {
        length = remaining;
    } else {
        length = Number(length);
        if (length > remaining) {
            length = remaining;
        }
    }
    const strLen = string.length;
    if (length > strLen / 2) {
        length = strLen / 2;
    }
    let i;
    for(i = 0; i < length; ++i){
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
    }
    return i;
}
function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}
function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
}
function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
}
function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}
Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
        encoding = 'utf8';
        length = this.length;
        offset = 0;
    // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
        encoding = offset;
        length = this.length;
        offset = 0;
    // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
            length = length >>> 0;
            if (encoding === undefined) encoding = 'utf8';
        } else {
            encoding = length;
            length = undefined;
        }
    } else {
        throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
    }
    const remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError('Attempt to write outside buffer bounds');
    }
    if (!encoding) encoding = 'utf8';
    let loweredCase = false;
    for(;;){
        switch(encoding){
            case 'hex':
                return hexWrite(this, string, offset, length);
            case 'utf8':
            case 'utf-8':
                return utf8Write(this, string, offset, length);
            case 'ascii':
            case 'latin1':
            case 'binary':
                return asciiWrite(this, string, offset, length);
            case 'base64':
                // Warning: maxLength not taken into account in base64Write
                return base64Write(this, string, offset, length);
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
                return ucs2Write(this, string, offset, length);
            default:
                if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
                encoding = ('' + encoding).toLowerCase();
                loweredCase = true;
        }
    }
};
Buffer.prototype.toJSON = function toJSON() {
    return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
    };
};
function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
    } else {
        return base64.fromByteArray(buf.slice(start, end));
    }
}
function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    const res = [];
    let i = start;
    while(i < end){
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
        if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch(bytesPerSequence){
                case 1:
                    if (firstByte < 0x80) {
                        codePoint = firstByte;
                    }
                    break;
                case 2:
                    secondByte = buf[i + 1];
                    if ((secondByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                        if (tempCodePoint > 0x7F) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 3:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                        if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                            codePoint = tempCodePoint;
                        }
                    }
                    break;
                case 4:
                    secondByte = buf[i + 1];
                    thirdByte = buf[i + 2];
                    fourthByte = buf[i + 3];
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                        tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                        if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                            codePoint = tempCodePoint;
                        }
                    }
            }
        }
        if (codePoint === null) {
            // we did not generate a valid codePoint so insert a
            // replacement char (U+FFFD) and advance only 1 byte
            codePoint = 0xFFFD;
            bytesPerSequence = 1;
        } else if (codePoint > 0xFFFF) {
            // encode to utf16 (surrogate pair dance)
            codePoint -= 0x10000;
            res.push(codePoint >>> 10 & 0x3FF | 0xD800);
            codePoint = 0xDC00 | codePoint & 0x3FF;
        }
        res.push(codePoint);
        i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
}
// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
const MAX_ARGUMENTS_LENGTH = 0x1000;
function decodeCodePointsArray(codePoints) {
    const len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
        ;
    }
    // Decode in chunks to avoid "call stack size exceeded".
    let res = '';
    let i = 0;
    while(i < len){
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }
    return res;
}
function asciiSlice(buf, start, end) {
    let ret = '';
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i){
        ret += String.fromCharCode(buf[i] & 0x7F);
    }
    return ret;
}
function latin1Slice(buf, start, end) {
    let ret = '';
    end = Math.min(buf.length, end);
    for(let i = start; i < end; ++i){
        ret += String.fromCharCode(buf[i]);
    }
    return ret;
}
function hexSlice(buf, start, end) {
    const len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    let out = '';
    for(let i = start; i < end; ++i){
        out += hexSliceLookupTable[buf[i]];
    }
    return out;
}
function utf16leSlice(buf, start, end) {
    const bytes = buf.slice(start, end);
    let res = '';
    // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
    for(let i = 0; i < bytes.length - 1; i += 2){
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
}
Buffer.prototype.slice = function slice(start, end) {
    const len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;
    if (start < 0) {
        start += len;
        if (start < 0) start = 0;
    } else if (start > len) {
        start = len;
    }
    if (end < 0) {
        end += len;
        if (end < 0) end = 0;
    } else if (end > len) {
        end = len;
    }
    if (end < start) end = start;
    const newBuf = this.subarray(start, end);
    // Return an augmented `Uint8Array` instance
    Object.setPrototypeOf(newBuf, Buffer.prototype);
    return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */ function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}
Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100)){
        val += this[offset + i] * mul;
    }
    return val;
};
Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        checkOffset(offset, byteLength, this.length);
    }
    let val = this[offset + --byteLength];
    let mul = 1;
    while(byteLength > 0 && (mul *= 0x100)){
        val += this[offset + --byteLength] * mul;
    }
    return val;
};
Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
};
Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
};
Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
};
Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};
Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};
Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 8);
    }
    const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
    const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
    return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 8);
    }
    const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
    return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});
Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let val = this[offset];
    let mul = 1;
    let i = 0;
    while(++i < byteLength && (mul *= 0x100)){
        val += this[offset + i] * mul;
    }
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    let i = byteLength;
    let mul = 1;
    let val = this[offset + --i];
    while(i > 0 && (mul *= 0x100)){
        val += this[offset + --i] * mul;
    }
    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
};
Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
};
Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 2, this.length);
    const val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
};
Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};
Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};
Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 8);
    }
    const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24) // Overflow
    ;
    return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
    offset = offset >>> 0;
    validateNumber(offset, 'offset');
    const first = this[offset];
    const last = this[offset + 7];
    if (first === undefined || last === undefined) {
        boundsError(offset, this.length - 8);
    }
    const val = (first << 24) + // Overflow
    this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
    return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
});
Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
};
Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
};
Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
};
Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert) checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
};
function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
}
Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let mul = 1;
    let i = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100)){
        this[offset + i] = value / mul & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength = byteLength >>> 0;
    if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength) - 1;
        checkInt(this, value, offset, byteLength, maxBytes, 0);
    }
    let i = byteLength - 1;
    let mul = 1;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        this[offset + i] = value / mul & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
function wrtBigUInt64LE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    lo = lo >> 8;
    buf[offset++] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    hi = hi >> 8;
    buf[offset++] = hi;
    return offset;
}
function wrtBigUInt64BE(buf, value, offset, min, max) {
    checkIntBI(value, min, max, buf, offset, 7);
    let lo = Number(value & BigInt(0xffffffff));
    buf[offset + 7] = lo;
    lo = lo >> 8;
    buf[offset + 6] = lo;
    lo = lo >> 8;
    buf[offset + 5] = lo;
    lo = lo >> 8;
    buf[offset + 4] = lo;
    let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
    buf[offset + 3] = hi;
    hi = hi >> 8;
    buf[offset + 2] = hi;
    hi = hi >> 8;
    buf[offset + 1] = hi;
    hi = hi >> 8;
    buf[offset] = hi;
    return offset + 8;
}
Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
});
Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
});
Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = 0;
    let mul = 1;
    let sub = 0;
    this[offset] = value & 0xFF;
    while(++i < byteLength && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength - 1);
        checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }
    let i = byteLength - 1;
    let mul = 1;
    let sub = 0;
    this[offset + i] = value & 0xFF;
    while(--i >= 0 && (mul *= 0x100)){
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }
    return offset + byteLength;
};
Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
};
Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    return offset + 2;
};
Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
    return offset + 2;
};
Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
};
Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0) value = 0xffffffff + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
    return offset + 4;
};
Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
    return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
    return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
});
function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
    if (offset < 0) throw new RangeError('Index out of range');
}
function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
}
Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
};
Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
};
function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
}
Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
};
Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
};
// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start;
    // Copy 0 bytes; we're done
    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0;
    // Fatal error conditions
    if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds');
    }
    if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
    if (end < 0) throw new RangeError('sourceEnd out of bounds');
    // Are we oob?
    if (end > this.length) end = this.length;
    if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
    }
    const len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
        // Use built-in when available, missing from IE11
        this.copyWithin(targetStart, start, end);
    } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    }
    return len;
};
// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
        if (typeof start === 'string') {
            encoding = start;
            start = 0;
            end = this.length;
        } else if (typeof end === 'string') {
            encoding = end;
            end = this.length;
        }
        if (encoding !== undefined && typeof encoding !== 'string') {
            throw new TypeError('encoding must be a string');
        }
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
            throw new TypeError('Unknown encoding: ' + encoding);
        }
        if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {
                // Fast path: If `val` fits into a single byte, use that numeric value.
                val = code;
            }
        }
    } else if (typeof val === 'number') {
        val = val & 255;
    } else if (typeof val === 'boolean') {
        val = Number(val);
    }
    // Invalid ranges are not set to a default, so can range check early.
    if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError('Out of range index');
    }
    if (end <= start) {
        return this;
    }
    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    let i;
    if (typeof val === 'number') {
        for(i = start; i < end; ++i){
            this[i] = val;
        }
    } else {
        const bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for(i = 0; i < end - start; ++i){
            this[i + start] = bytes[i % len];
        }
    }
    return this;
};
// CUSTOM ERRORS
// =============
// Simplified versions from Node, changed for Buffer-only usage
const errors = {};
function E(sym, getMessage, Base) {
    errors[sym] = class NodeError extends Base {
        constructor(){
            super();
            Object.defineProperty(this, 'message', {
                value: getMessage.apply(this, arguments),
                writable: true,
                configurable: true
            });
            // Add the error code to the name to include it in the stack trace.
            this.name = `${this.name} [${sym}]`;
            // Access the stack to generate the error message including the error code
            // from the name.
            this.stack; // eslint-disable-line no-unused-expressions
            // Reset the name to the actual name.
            delete this.name;
        }
        get code() {
            return sym;
        }
        set code(value) {
            Object.defineProperty(this, 'code', {
                configurable: true,
                enumerable: true,
                value,
                writable: true
            });
        }
        toString() {
            return `${this.name} [${sym}]: ${this.message}`;
        }
    };
}
E('ERR_BUFFER_OUT_OF_BOUNDS', function(name) {
    if (name) {
        return `${name} is outside of buffer bounds`;
    }
    return 'Attempt to access memory outside buffer bounds';
}, RangeError);
E('ERR_INVALID_ARG_TYPE', function(name, actual) {
    return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
}, TypeError);
E('ERR_OUT_OF_RANGE', function(str, range, input) {
    let msg = `The value of "${str}" is out of range.`;
    let received = input;
    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
    } else if (typeof input === 'bigint') {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
        }
        received += 'n';
    }
    msg += ` It must be ${range}. Received ${received}`;
    return msg;
}, RangeError);
function addNumericalSeparator(val) {
    let res = '';
    let i = val.length;
    const start = val[0] === '-' ? 1 : 0;
    for(; i >= start + 4; i -= 3){
        res = `_${val.slice(i - 3, i)}${res}`;
    }
    return `${val.slice(0, i)}${res}`;
}
// CHECK FUNCTIONS
// ===============
function checkBounds(buf, offset, byteLength) {
    validateNumber(offset, 'offset');
    if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
        boundsError(offset, buf.length - (byteLength + 1));
    }
}
function checkIntBI(value, min, max, buf, offset, byteLength) {
    if (value > max || value < min) {
        const n = typeof min === 'bigint' ? 'n' : '';
        let range;
        if (byteLength > 3) {
            if (min === 0 || min === BigInt(0)) {
                range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
            } else {
                range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` + `${(byteLength + 1) * 8 - 1}${n}`;
            }
        } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors.ERR_OUT_OF_RANGE('value', range, value);
    }
    checkBounds(buf, offset, byteLength);
}
function validateNumber(value, name) {
    if (typeof value !== 'number') {
        throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value);
    }
}
function boundsError(value, length, type) {
    if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value);
    }
    if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
    }
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', `>= ${type ? 1 : 0} and <= ${length}`, value);
}
// HELPER FUNCTIONS
// ================
const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
function base64clean(str) {
    // Node takes equal signs as end of the Base64 encoding
    str = str.split('=')[0];
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = str.trim().replace(INVALID_BASE64_RE, '');
    // Node converts strings with length < 2 to ''
    if (str.length < 2) return '';
    // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
    while(str.length % 4 !== 0){
        str = str + '=';
    }
    return str;
}
function utf8ToBytes(string, units) {
    units = units || Infinity;
    let codePoint;
    const length = string.length;
    let leadSurrogate = null;
    const bytes = [];
    for(let i = 0; i < length; ++i){
        codePoint = string.charCodeAt(i);
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
            // last char was a lead
            if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                    continue;
                }
                // valid lead
                leadSurrogate = codePoint;
                continue;
            }
            // 2 leads in a row
            if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
            }
            // valid surrogate pair
            codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
        } else if (leadSurrogate) {
            // valid bmp char, but last char was a lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        }
        leadSurrogate = null;
        // encode utf8
        if (codePoint < 0x80) {
            if ((units -= 1) < 0) break;
            bytes.push(codePoint);
        } else if (codePoint < 0x800) {
            if ((units -= 2) < 0) break;
            bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x10000) {
            if ((units -= 3) < 0) break;
            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else if (codePoint < 0x110000) {
            if ((units -= 4) < 0) break;
            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
        } else {
            throw new Error('Invalid code point');
        }
    }
    return bytes;
}
function asciiToBytes(str) {
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        // Node's code seems to be doing this and not & 0x7F..
        byteArray.push(str.charCodeAt(i) & 0xFF);
    }
    return byteArray;
}
function utf16leToBytes(str, units) {
    let c, hi, lo;
    const byteArray = [];
    for(let i = 0; i < str.length; ++i){
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
    }
    return byteArray;
}
function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
}
function blitBuffer(src, dst, offset, length) {
    let i;
    for(i = 0; i < length; ++i){
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
    }
    return i;
}
// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}
function numberIsNaN(obj) {
    // For IE11 support
    return obj !== obj // eslint-disable-line no-self-compare
    ;
}
// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
const hexSliceLookupTable = function() {
    const alphabet = '0123456789abcdef';
    const table = new Array(256);
    for(let i = 0; i < 16; ++i){
        const i16 = i * 16;
        for(let j = 0; j < 16; ++j){
            table[i16 + j] = alphabet[i] + alphabet[j];
        }
    }
    return table;
}();
// Return not function with Error if BigInt not supported
function defineBigIntMethod(fn) {
    return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn;
}
function BufferBigIntNotDefined() {
    throw new Error('BigInt not supported');
}
}),
"[project]/node_modules/events/events.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var R = typeof Reflect === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;
if (R && typeof R.ownKeys === 'function') {
    ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
    ReflectOwnKeys = function ReflectOwnKeys(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
    };
} else {
    ReflectOwnKeys = function ReflectOwnKeys(target) {
        return Object.getOwnPropertyNames(target);
    };
}
function ProcessEmitWarning(warning) {
    if (console && console.warn) console.warn(warning);
}
var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
    return value !== value;
};
function EventEmitter() {
    EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;
// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;
// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;
function checkListener(listener) {
    if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
    }
}
Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
    enumerable: true,
    get: function() {
        return defaultMaxListeners;
    },
    set: function(arg) {
        if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
        }
        defaultMaxListeners = arg;
    }
});
EventEmitter.init = function() {
    if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
        this._events = Object.create(null);
        this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || undefined;
};
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
    }
    this._maxListeners = n;
    return this;
};
function _getMaxListeners(that) {
    if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function emit(type) {
    var args = [];
    for(var i = 1; i < arguments.length; i++)args.push(arguments[i]);
    var doError = type === 'error';
    var events = this._events;
    if (events !== undefined) doError = doError && events.error === undefined;
    else if (!doError) return false;
    // If there is no 'error' event listener then throw.
    if (doError) {
        var er;
        if (args.length > 0) er = args[0];
        if (er instanceof Error) {
            // Note: The comments on the `throw` lines are intentional, they show
            // up in Node's output if this results in an unhandled exception.
            throw er; // Unhandled 'error' event
        }
        // At least give some kind of context to the user
        var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
        err.context = er;
        throw err; // Unhandled 'error' event
    }
    var handler = events[type];
    if (handler === undefined) return false;
    if (typeof handler === 'function') {
        ReflectApply(handler, this, args);
    } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for(var i = 0; i < len; ++i)ReflectApply(listeners[i], this, args);
    }
    return true;
};
function _addListener(target, type, listener, prepend) {
    var m;
    var events;
    var existing;
    checkListener(listener);
    events = target._events;
    if (events === undefined) {
        events = target._events = Object.create(null);
        target._eventsCount = 0;
    } else {
        // To avoid recursion in the case that type === "newListener"! Before
        // adding it to the listeners, first emit "newListener".
        if (events.newListener !== undefined) {
            target.emit('newListener', type, listener.listener ? listener.listener : listener);
            // Re-assign `events` because a newListener handler could have caused the
            // this._events to be assigned to a new object
            events = target._events;
        }
        existing = events[type];
    }
    if (existing === undefined) {
        // Optimize the case of one listener. Don't need the extra array object.
        existing = events[type] = listener;
        ++target._eventsCount;
    } else {
        if (typeof existing === 'function') {
            // Adding the second element, need to change to array.
            existing = events[type] = prepend ? [
                listener,
                existing
            ] : [
                existing,
                listener
            ];
        // If we've already got an array, just append.
        } else if (prepend) {
            existing.unshift(listener);
        } else {
            existing.push(listener);
        }
        // Check for listener leak
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            // No error code for this since it is a Warning
            // eslint-disable-next-line no-restricted-syntax
            var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
            w.name = 'MaxListenersExceededWarning';
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            ProcessEmitWarning(w);
        }
    }
    return target;
}
EventEmitter.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function prependListener(type, listener) {
    return _addListener(this, type, listener, true);
};
function onceWrapper() {
    if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0) return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
    }
}
function _onceWrap(target, type, listener) {
    var state = {
        fired: false,
        wrapFn: undefined,
        target: target,
        type: type,
        listener: listener
    };
    var wrapped = onceWrapper.bind(state);
    wrapped.listener = listener;
    state.wrapFn = wrapped;
    return wrapped;
}
EventEmitter.prototype.once = function once(type, listener) {
    checkListener(listener);
    this.on(type, _onceWrap(this, type, listener));
    return this;
};
EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
    checkListener(listener);
    this.prependListener(type, _onceWrap(this, type, listener));
    return this;
};
// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener = function removeListener(type, listener) {
    var list, events, position, i, originalListener;
    checkListener(listener);
    events = this._events;
    if (events === undefined) return this;
    list = events[type];
    if (list === undefined) return this;
    if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0) this._events = Object.create(null);
        else {
            delete events[type];
            if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
        }
    } else if (typeof list !== 'function') {
        position = -1;
        for(i = list.length - 1; i >= 0; i--){
            if (list[i] === listener || list[i].listener === listener) {
                originalListener = list[i].listener;
                position = i;
                break;
            }
        }
        if (position < 0) return this;
        if (position === 0) list.shift();
        else {
            spliceOne(list, position);
        }
        if (list.length === 1) events[type] = list[0];
        if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
    }
    return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
    var listeners, events, i;
    events = this._events;
    if (events === undefined) return this;
    // not listening for removeListener, no need to emit
    if (events.removeListener === undefined) {
        if (arguments.length === 0) {
            this._events = Object.create(null);
            this._eventsCount = 0;
        } else if (events[type] !== undefined) {
            if (--this._eventsCount === 0) this._events = Object.create(null);
            else delete events[type];
        }
        return this;
    }
    // emit removeListener for all listeners on all events
    if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for(i = 0; i < keys.length; ++i){
            key = keys[i];
            if (key === 'removeListener') continue;
            this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
    }
    listeners = events[type];
    if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
    } else if (listeners !== undefined) {
        // LIFO order
        for(i = listeners.length - 1; i >= 0; i--){
            this.removeListener(type, listeners[i]);
        }
    }
    return this;
};
function _listeners(target, type, unwrap) {
    var events = target._events;
    if (events === undefined) return [];
    var evlistener = events[type];
    if (evlistener === undefined) return [];
    if (typeof evlistener === 'function') return unwrap ? [
        evlistener.listener || evlistener
    ] : [
        evlistener
    ];
    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}
EventEmitter.prototype.listeners = function listeners(type) {
    return _listeners(this, type, true);
};
EventEmitter.prototype.rawListeners = function rawListeners(type) {
    return _listeners(this, type, false);
};
EventEmitter.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === 'function') {
        return emitter.listenerCount(type);
    } else {
        return listenerCount.call(emitter, type);
    }
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
    var events = this._events;
    if (events !== undefined) {
        var evlistener = events[type];
        if (typeof evlistener === 'function') {
            return 1;
        } else if (evlistener !== undefined) {
            return evlistener.length;
        }
    }
    return 0;
}
EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(arr, n) {
    var copy = new Array(n);
    for(var i = 0; i < n; ++i)copy[i] = arr[i];
    return copy;
}
function spliceOne(list, index) {
    for(; index + 1 < list.length; index++)list[index] = list[index + 1];
    list.pop();
}
function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for(var i = 0; i < ret.length; ++i){
        ret[i] = arr[i].listener || arr[i];
    }
    return ret;
}
function once(emitter, name) {
    return new Promise(function(resolve, reject) {
        function errorListener(err) {
            emitter.removeListener(name, resolver);
            reject(err);
        }
        function resolver() {
            if (typeof emitter.removeListener === 'function') {
                emitter.removeListener('error', errorListener);
            }
            resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, {
            once: true
        });
        if (name !== 'error') {
            addErrorHandlerIfEventEmitter(emitter, errorListener, {
                once: true
            });
        }
    });
}
function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
    if (typeof emitter.on === 'function') {
        eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
    }
}
function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
    if (typeof emitter.on === 'function') {
        if (flags.once) {
            emitter.once(name, listener);
        } else {
            emitter.on(name, listener);
        }
    } else if (typeof emitter.addEventListener === 'function') {
        // EventTarget does not have `error` event semantics like Node
        // EventEmitters, we do not listen for `error` events here.
        emitter.addEventListener(name, function wrapListener(arg) {
            // IE does not have builtin `{ once: true }` support so we
            // have to do it manually.
            if (flags.once) {
                emitter.removeEventListener(name, wrapListener);
            }
            listener(arg);
        });
    } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
    }
}
}),
"[project]/node_modules/has-symbols/shams.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./shams')} */ /* eslint complexity: [2, 18], max-statements: [2, 33] */ module.exports = function hasSymbols() {
    if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
        return false;
    }
    if (typeof Symbol.iterator === 'symbol') {
        return true;
    }
    /** @type {{ [k in symbol]?: unknown }} */ var obj = {};
    var sym = Symbol('test');
    var symObj = Object(sym);
    if (typeof sym === 'string') {
        return false;
    }
    if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
        return false;
    }
    if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
        return false;
    }
    // temp disabled per https://github.com/ljharb/object.assign/issues/17
    // if (sym instanceof Symbol) { return false; }
    // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
    // if (!(symObj instanceof Symbol)) { return false; }
    // if (typeof Symbol.prototype.toString !== 'function') { return false; }
    // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }
    var symVal = 42;
    obj[sym] = symVal;
    for(var _ in obj){
        return false;
    } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
    if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
        return false;
    }
    if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
        return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === 'function') {
        // eslint-disable-next-line no-extra-parens
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
        }
    }
    return true;
};
}),
"[project]/node_modules/has-symbols/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __turbopack_context__.r("[project]/node_modules/has-symbols/shams.js [app-client] (ecmascript)");
/** @type {import('.')} */ module.exports = function hasNativeSymbols() {
    if (typeof origSymbol !== 'function') {
        return false;
    }
    if (typeof Symbol !== 'function') {
        return false;
    }
    if (typeof origSymbol('foo') !== 'symbol') {
        return false;
    }
    if (typeof Symbol('bar') !== 'symbol') {
        return false;
    }
    return hasSymbolSham();
};
}),
"[project]/node_modules/has-tostringtag/shams.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var hasSymbols = __turbopack_context__.r("[project]/node_modules/has-symbols/shams.js [app-client] (ecmascript)");
/** @type {import('.')} */ module.exports = function hasToStringTagShams() {
    return hasSymbols() && !!Symbol.toStringTag;
};
}),
"[project]/node_modules/es-object-atoms/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('.')} */ module.exports = Object;
}),
"[project]/node_modules/es-errors/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('.')} */ module.exports = Error;
}),
"[project]/node_modules/es-errors/eval.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./eval')} */ module.exports = EvalError;
}),
"[project]/node_modules/es-errors/range.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./range')} */ module.exports = RangeError;
}),
"[project]/node_modules/es-errors/ref.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./ref')} */ module.exports = ReferenceError;
}),
"[project]/node_modules/es-errors/syntax.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./syntax')} */ module.exports = SyntaxError;
}),
"[project]/node_modules/es-errors/type.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./type')} */ module.exports = TypeError;
}),
"[project]/node_modules/es-errors/uri.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./uri')} */ module.exports = URIError;
}),
"[project]/node_modules/math-intrinsics/abs.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./abs')} */ module.exports = Math.abs;
}),
"[project]/node_modules/math-intrinsics/floor.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./floor')} */ module.exports = Math.floor;
}),
"[project]/node_modules/math-intrinsics/max.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./max')} */ module.exports = Math.max;
}),
"[project]/node_modules/math-intrinsics/min.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./min')} */ module.exports = Math.min;
}),
"[project]/node_modules/math-intrinsics/pow.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./pow')} */ module.exports = Math.pow;
}),
"[project]/node_modules/math-intrinsics/round.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./round')} */ module.exports = Math.round;
}),
"[project]/node_modules/math-intrinsics/isNaN.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./isNaN')} */ module.exports = Number.isNaN || function isNaN(a) {
    return a !== a;
};
}),
"[project]/node_modules/math-intrinsics/sign.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var $isNaN = __turbopack_context__.r("[project]/node_modules/math-intrinsics/isNaN.js [app-client] (ecmascript)");
/** @type {import('./sign')} */ module.exports = function sign(number) {
    if ($isNaN(number) || number === 0) {
        return number;
    }
    return number < 0 ? -1 : +1;
};
}),
"[project]/node_modules/gopd/gOPD.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./gOPD')} */ module.exports = Object.getOwnPropertyDescriptor;
}),
"[project]/node_modules/gopd/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('.')} */ var $gOPD = __turbopack_context__.r("[project]/node_modules/gopd/gOPD.js [app-client] (ecmascript)");
if ($gOPD) {
    try {
        $gOPD([], 'length');
    } catch (e) {
        // IE 8 has a broken gOPD
        $gOPD = null;
    }
}
module.exports = $gOPD;
}),
"[project]/node_modules/es-define-property/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('.')} */ var $defineProperty = Object.defineProperty || false;
if ($defineProperty) {
    try {
        $defineProperty({}, 'a', {
            value: 1
        });
    } catch (e) {
        // IE 8 has a broken defineProperty
        $defineProperty = false;
    }
}
module.exports = $defineProperty;
}),
"[project]/node_modules/get-proto/Reflect.getPrototypeOf.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./Reflect.getPrototypeOf')} */ module.exports = typeof Reflect !== 'undefined' && Reflect.getPrototypeOf || null;
}),
"[project]/node_modules/get-proto/Object.getPrototypeOf.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var $Object = __turbopack_context__.r("[project]/node_modules/es-object-atoms/index.js [app-client] (ecmascript)");
/** @type {import('./Object.getPrototypeOf')} */ module.exports = $Object.getPrototypeOf || null;
}),
"[project]/node_modules/get-proto/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var reflectGetProto = __turbopack_context__.r("[project]/node_modules/get-proto/Reflect.getPrototypeOf.js [app-client] (ecmascript)");
var originalGetProto = __turbopack_context__.r("[project]/node_modules/get-proto/Object.getPrototypeOf.js [app-client] (ecmascript)");
var getDunderProto = __turbopack_context__.r("[project]/node_modules/dunder-proto/get.js [app-client] (ecmascript)");
/** @type {import('.')} */ module.exports = reflectGetProto ? function getProto(O) {
    // @ts-expect-error TS can't narrow inside a closure, for some reason
    return reflectGetProto(O);
} : originalGetProto ? function getProto(O) {
    if (!O || typeof O !== 'object' && typeof O !== 'function') {
        throw new TypeError('getProto: not an object');
    }
    // @ts-expect-error TS can't narrow inside a closure, for some reason
    return originalGetProto(O);
} : getDunderProto ? function getProto(O) {
    // @ts-expect-error TS can't narrow inside a closure, for some reason
    return getDunderProto(O);
} : null;
}),
"[project]/node_modules/function-bind/implementation.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* eslint no-invalid-this: 1 */ var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';
var concatty = function concatty(a, b) {
    var arr = [];
    for(var i = 0; i < a.length; i += 1){
        arr[i] = a[i];
    }
    for(var j = 0; j < b.length; j += 1){
        arr[j + a.length] = b[j];
    }
    return arr;
};
var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for(var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1){
        arr[j] = arrLike[i];
    }
    return arr;
};
var joiny = function(arr, joiner) {
    var str = '';
    for(var i = 0; i < arr.length; i += 1){
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};
module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
        if (this instanceof bound) {
            var result = target.apply(this, concatty(args, arguments));
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(that, concatty(args, arguments));
    };
    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for(var i = 0; i < boundLength; i++){
        boundArgs[i] = '$' + i;
    }
    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);
    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }
    return bound;
};
}),
"[project]/node_modules/function-bind/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var implementation = __turbopack_context__.r("[project]/node_modules/function-bind/implementation.js [app-client] (ecmascript)");
module.exports = Function.prototype.bind || implementation;
}),
"[project]/node_modules/call-bind-apply-helpers/functionCall.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./functionCall')} */ module.exports = Function.prototype.call;
}),
"[project]/node_modules/call-bind-apply-helpers/functionApply.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./functionApply')} */ module.exports = Function.prototype.apply;
}),
"[project]/node_modules/call-bind-apply-helpers/reflectApply.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('./reflectApply')} */ module.exports = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;
}),
"[project]/node_modules/call-bind-apply-helpers/actualApply.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var bind = __turbopack_context__.r("[project]/node_modules/function-bind/index.js [app-client] (ecmascript)");
var $apply = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionApply.js [app-client] (ecmascript)");
var $call = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionCall.js [app-client] (ecmascript)");
var $reflectApply = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/reflectApply.js [app-client] (ecmascript)");
/** @type {import('./actualApply')} */ module.exports = $reflectApply || bind.call($call, $apply);
}),
"[project]/node_modules/call-bind-apply-helpers/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var bind = __turbopack_context__.r("[project]/node_modules/function-bind/index.js [app-client] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/es-errors/type.js [app-client] (ecmascript)");
var $call = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionCall.js [app-client] (ecmascript)");
var $actualApply = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/actualApply.js [app-client] (ecmascript)");
/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */ module.exports = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== 'function') {
        throw new $TypeError('a function is required');
    }
    return $actualApply(bind, $call, args);
};
}),
"[project]/node_modules/call-bind-apply-helpers/applyBind.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var bind = __turbopack_context__.r("[project]/node_modules/function-bind/index.js [app-client] (ecmascript)");
var $apply = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionApply.js [app-client] (ecmascript)");
var actualApply = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/actualApply.js [app-client] (ecmascript)");
/** @type {import('./applyBind')} */ module.exports = function applyBind() {
    return actualApply(bind, $apply, arguments);
};
}),
"[project]/node_modules/dunder-proto/get.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var callBind = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/index.js [app-client] (ecmascript)");
var gOPD = __turbopack_context__.r("[project]/node_modules/gopd/index.js [app-client] (ecmascript)");
var hasProtoAccessor;
try {
    // eslint-disable-next-line no-extra-parens, no-proto
    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ [].__proto__ === Array.prototype;
} catch (e) {
    if (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {
        throw e;
    }
}
// eslint-disable-next-line no-extra-parens
var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, '__proto__');
var $Object = Object;
var $getPrototypeOf = $Object.getPrototypeOf;
/** @type {import('./get')} */ module.exports = desc && typeof desc.get === 'function' ? callBind([
    desc.get
]) : typeof $getPrototypeOf === 'function' ? /** @type {import('./get')} */ function getDunder(value) {
    // eslint-disable-next-line eqeqeq
    return $getPrototypeOf(value == null ? value : $Object(value));
} : false;
}),
"[project]/node_modules/hasown/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = __turbopack_context__.r("[project]/node_modules/function-bind/index.js [app-client] (ecmascript)");
/** @type {import('.')} */ module.exports = bind.call(call, $hasOwn);
}),
"[project]/node_modules/get-intrinsic/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var undefined1;
var $Object = __turbopack_context__.r("[project]/node_modules/es-object-atoms/index.js [app-client] (ecmascript)");
var $Error = __turbopack_context__.r("[project]/node_modules/es-errors/index.js [app-client] (ecmascript)");
var $EvalError = __turbopack_context__.r("[project]/node_modules/es-errors/eval.js [app-client] (ecmascript)");
var $RangeError = __turbopack_context__.r("[project]/node_modules/es-errors/range.js [app-client] (ecmascript)");
var $ReferenceError = __turbopack_context__.r("[project]/node_modules/es-errors/ref.js [app-client] (ecmascript)");
var $SyntaxError = __turbopack_context__.r("[project]/node_modules/es-errors/syntax.js [app-client] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/es-errors/type.js [app-client] (ecmascript)");
var $URIError = __turbopack_context__.r("[project]/node_modules/es-errors/uri.js [app-client] (ecmascript)");
var abs = __turbopack_context__.r("[project]/node_modules/math-intrinsics/abs.js [app-client] (ecmascript)");
var floor = __turbopack_context__.r("[project]/node_modules/math-intrinsics/floor.js [app-client] (ecmascript)");
var max = __turbopack_context__.r("[project]/node_modules/math-intrinsics/max.js [app-client] (ecmascript)");
var min = __turbopack_context__.r("[project]/node_modules/math-intrinsics/min.js [app-client] (ecmascript)");
var pow = __turbopack_context__.r("[project]/node_modules/math-intrinsics/pow.js [app-client] (ecmascript)");
var round = __turbopack_context__.r("[project]/node_modules/math-intrinsics/round.js [app-client] (ecmascript)");
var sign = __turbopack_context__.r("[project]/node_modules/math-intrinsics/sign.js [app-client] (ecmascript)");
var $Function = Function;
// eslint-disable-next-line consistent-return
var getEvalledConstructor = function(expressionSyntax) {
    try {
        return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
    } catch (e) {}
};
var $gOPD = __turbopack_context__.r("[project]/node_modules/gopd/index.js [app-client] (ecmascript)");
var $defineProperty = __turbopack_context__.r("[project]/node_modules/es-define-property/index.js [app-client] (ecmascript)");
var throwTypeError = function() {
    throw new $TypeError();
};
var ThrowTypeError = $gOPD ? function() {
    try {
        // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
        arguments.callee; // IE 8 does not throw here
        return throwTypeError;
    } catch (calleeThrows) {
        try {
            // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
            return $gOPD(arguments, 'callee').get;
        } catch (gOPDthrows) {
            return throwTypeError;
        }
    }
}() : throwTypeError;
var hasSymbols = __turbopack_context__.r("[project]/node_modules/has-symbols/index.js [app-client] (ecmascript)")();
var getProto = __turbopack_context__.r("[project]/node_modules/get-proto/index.js [app-client] (ecmascript)");
var $ObjectGPO = __turbopack_context__.r("[project]/node_modules/get-proto/Object.getPrototypeOf.js [app-client] (ecmascript)");
var $ReflectGPO = __turbopack_context__.r("[project]/node_modules/get-proto/Reflect.getPrototypeOf.js [app-client] (ecmascript)");
var $apply = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionApply.js [app-client] (ecmascript)");
var $call = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionCall.js [app-client] (ecmascript)");
var needsEval = {};
var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);
var INTRINSICS = {
    __proto__: null,
    '%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
    '%Array%': Array,
    '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
    '%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
    '%AsyncFromSyncIteratorPrototype%': undefined,
    '%AsyncFunction%': needsEval,
    '%AsyncGenerator%': needsEval,
    '%AsyncGeneratorFunction%': needsEval,
    '%AsyncIteratorPrototype%': needsEval,
    '%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
    '%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
    '%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
    '%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
    '%Boolean%': Boolean,
    '%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
    '%Date%': Date,
    '%decodeURI%': decodeURI,
    '%decodeURIComponent%': decodeURIComponent,
    '%encodeURI%': encodeURI,
    '%encodeURIComponent%': encodeURIComponent,
    '%Error%': $Error,
    '%eval%': eval,
    '%EvalError%': $EvalError,
    '%Float16Array%': typeof Float16Array === 'undefined' ? undefined : Float16Array,
    '%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
    '%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
    '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
    '%Function%': $Function,
    '%GeneratorFunction%': needsEval,
    '%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
    '%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
    '%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
    '%isFinite%': isFinite,
    '%isNaN%': isNaN,
    '%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
    '%JSON%': typeof JSON === 'object' ? JSON : undefined,
    '%Map%': typeof Map === 'undefined' ? undefined : Map,
    '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
    '%Math%': Math,
    '%Number%': Number,
    '%Object%': $Object,
    '%Object.getOwnPropertyDescriptor%': $gOPD,
    '%parseFloat%': parseFloat,
    '%parseInt%': parseInt,
    '%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
    '%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
    '%RangeError%': $RangeError,
    '%ReferenceError%': $ReferenceError,
    '%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
    '%RegExp%': RegExp,
    '%Set%': typeof Set === 'undefined' ? undefined : Set,
    '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
    '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
    '%String%': String,
    '%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
    '%Symbol%': hasSymbols ? Symbol : undefined,
    '%SyntaxError%': $SyntaxError,
    '%ThrowTypeError%': ThrowTypeError,
    '%TypedArray%': TypedArray,
    '%TypeError%': $TypeError,
    '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
    '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
    '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
    '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
    '%URIError%': $URIError,
    '%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
    '%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
    '%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,
    '%Function.prototype.call%': $call,
    '%Function.prototype.apply%': $apply,
    '%Object.defineProperty%': $defineProperty,
    '%Object.getPrototypeOf%': $ObjectGPO,
    '%Math.abs%': abs,
    '%Math.floor%': floor,
    '%Math.max%': max,
    '%Math.min%': min,
    '%Math.pow%': pow,
    '%Math.round%': round,
    '%Math.sign%': sign,
    '%Reflect.getPrototypeOf%': $ReflectGPO
};
if (getProto) {
    try {
        null.error; // eslint-disable-line no-unused-expressions
    } catch (e) {
        // https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
        var errorProto = getProto(getProto(e));
        INTRINSICS['%Error.prototype%'] = errorProto;
    }
}
var doEval = function doEval(name) {
    var value;
    if (name === '%AsyncFunction%') {
        value = getEvalledConstructor('async function () {}');
    } else if (name === '%GeneratorFunction%') {
        value = getEvalledConstructor('function* () {}');
    } else if (name === '%AsyncGeneratorFunction%') {
        value = getEvalledConstructor('async function* () {}');
    } else if (name === '%AsyncGenerator%') {
        var fn = doEval('%AsyncGeneratorFunction%');
        if (fn) {
            value = fn.prototype;
        }
    } else if (name === '%AsyncIteratorPrototype%') {
        var gen = doEval('%AsyncGenerator%');
        if (gen && getProto) {
            value = getProto(gen.prototype);
        }
    }
    INTRINSICS[name] = value;
    return value;
};
var LEGACY_ALIASES = {
    __proto__: null,
    '%ArrayBufferPrototype%': [
        'ArrayBuffer',
        'prototype'
    ],
    '%ArrayPrototype%': [
        'Array',
        'prototype'
    ],
    '%ArrayProto_entries%': [
        'Array',
        'prototype',
        'entries'
    ],
    '%ArrayProto_forEach%': [
        'Array',
        'prototype',
        'forEach'
    ],
    '%ArrayProto_keys%': [
        'Array',
        'prototype',
        'keys'
    ],
    '%ArrayProto_values%': [
        'Array',
        'prototype',
        'values'
    ],
    '%AsyncFunctionPrototype%': [
        'AsyncFunction',
        'prototype'
    ],
    '%AsyncGenerator%': [
        'AsyncGeneratorFunction',
        'prototype'
    ],
    '%AsyncGeneratorPrototype%': [
        'AsyncGeneratorFunction',
        'prototype',
        'prototype'
    ],
    '%BooleanPrototype%': [
        'Boolean',
        'prototype'
    ],
    '%DataViewPrototype%': [
        'DataView',
        'prototype'
    ],
    '%DatePrototype%': [
        'Date',
        'prototype'
    ],
    '%ErrorPrototype%': [
        'Error',
        'prototype'
    ],
    '%EvalErrorPrototype%': [
        'EvalError',
        'prototype'
    ],
    '%Float32ArrayPrototype%': [
        'Float32Array',
        'prototype'
    ],
    '%Float64ArrayPrototype%': [
        'Float64Array',
        'prototype'
    ],
    '%FunctionPrototype%': [
        'Function',
        'prototype'
    ],
    '%Generator%': [
        'GeneratorFunction',
        'prototype'
    ],
    '%GeneratorPrototype%': [
        'GeneratorFunction',
        'prototype',
        'prototype'
    ],
    '%Int8ArrayPrototype%': [
        'Int8Array',
        'prototype'
    ],
    '%Int16ArrayPrototype%': [
        'Int16Array',
        'prototype'
    ],
    '%Int32ArrayPrototype%': [
        'Int32Array',
        'prototype'
    ],
    '%JSONParse%': [
        'JSON',
        'parse'
    ],
    '%JSONStringify%': [
        'JSON',
        'stringify'
    ],
    '%MapPrototype%': [
        'Map',
        'prototype'
    ],
    '%NumberPrototype%': [
        'Number',
        'prototype'
    ],
    '%ObjectPrototype%': [
        'Object',
        'prototype'
    ],
    '%ObjProto_toString%': [
        'Object',
        'prototype',
        'toString'
    ],
    '%ObjProto_valueOf%': [
        'Object',
        'prototype',
        'valueOf'
    ],
    '%PromisePrototype%': [
        'Promise',
        'prototype'
    ],
    '%PromiseProto_then%': [
        'Promise',
        'prototype',
        'then'
    ],
    '%Promise_all%': [
        'Promise',
        'all'
    ],
    '%Promise_reject%': [
        'Promise',
        'reject'
    ],
    '%Promise_resolve%': [
        'Promise',
        'resolve'
    ],
    '%RangeErrorPrototype%': [
        'RangeError',
        'prototype'
    ],
    '%ReferenceErrorPrototype%': [
        'ReferenceError',
        'prototype'
    ],
    '%RegExpPrototype%': [
        'RegExp',
        'prototype'
    ],
    '%SetPrototype%': [
        'Set',
        'prototype'
    ],
    '%SharedArrayBufferPrototype%': [
        'SharedArrayBuffer',
        'prototype'
    ],
    '%StringPrototype%': [
        'String',
        'prototype'
    ],
    '%SymbolPrototype%': [
        'Symbol',
        'prototype'
    ],
    '%SyntaxErrorPrototype%': [
        'SyntaxError',
        'prototype'
    ],
    '%TypedArrayPrototype%': [
        'TypedArray',
        'prototype'
    ],
    '%TypeErrorPrototype%': [
        'TypeError',
        'prototype'
    ],
    '%Uint8ArrayPrototype%': [
        'Uint8Array',
        'prototype'
    ],
    '%Uint8ClampedArrayPrototype%': [
        'Uint8ClampedArray',
        'prototype'
    ],
    '%Uint16ArrayPrototype%': [
        'Uint16Array',
        'prototype'
    ],
    '%Uint32ArrayPrototype%': [
        'Uint32Array',
        'prototype'
    ],
    '%URIErrorPrototype%': [
        'URIError',
        'prototype'
    ],
    '%WeakMapPrototype%': [
        'WeakMap',
        'prototype'
    ],
    '%WeakSetPrototype%': [
        'WeakSet',
        'prototype'
    ]
};
var bind = __turbopack_context__.r("[project]/node_modules/function-bind/index.js [app-client] (ecmascript)");
var hasOwn = __turbopack_context__.r("[project]/node_modules/hasown/index.js [app-client] (ecmascript)");
var $concat = bind.call($call, Array.prototype.concat);
var $spliceApply = bind.call($apply, Array.prototype.splice);
var $replace = bind.call($call, String.prototype.replace);
var $strSlice = bind.call($call, String.prototype.slice);
var $exec = bind.call($call, RegExp.prototype.exec);
/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */ var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */ 
var stringToPath = function stringToPath(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === '%' && last !== '%') {
        throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
    } else if (last === '%' && first !== '%') {
        throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
    }
    var result = [];
    $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
    });
    return result;
};
/* end adaptation */ var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = '%' + alias[0] + '%';
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
            value = doEval(intrinsicName);
        }
        if (typeof value === 'undefined' && !allowMissing) {
            throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
        }
        return {
            alias: alias,
            name: intrinsicName,
            value: value
        };
    }
    throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};
module.exports = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== 'string' || name.length === 0) {
        throw new $TypeError('intrinsic name must be a non-empty string');
    }
    if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
        throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
    var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([
            0,
            1
        ], alias));
    }
    for(var i = 1, isOwn = true; i < parts.length; i += 1){
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) {
            throw new $SyntaxError('property names with quotes must have matching quotes');
        }
        if (part === 'constructor' || !isOwn) {
            skipFurtherCaching = true;
        }
        intrinsicBaseName += '.' + part;
        intrinsicRealName = '%' + intrinsicBaseName + '%';
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
            if (!(part in value)) {
                if (!allowMissing) {
                    throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
                }
                return void undefined;
            }
            if ($gOPD && i + 1 >= parts.length) {
                var desc = $gOPD(value, part);
                isOwn = !!desc;
                // By convention, when a data property is converted to an accessor
                // property to emulate a data property that does not suffer from
                // the override mistake, that accessor's getter is marked with
                // an `originalValue` property. Here, when we detect this, we
                // uphold the illusion by pretending to see that original data
                // property, i.e., returning the value rather than the getter
                // itself.
                if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
                    value = desc.get;
                } else {
                    value = value[part];
                }
            } else {
                isOwn = hasOwn(value, part);
                value = value[part];
            }
            if (isOwn && !skipFurtherCaching) {
                INTRINSICS[intrinsicRealName] = value;
            }
        }
    }
    return value;
};
}),
"[project]/node_modules/call-bound/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var GetIntrinsic = __turbopack_context__.r("[project]/node_modules/get-intrinsic/index.js [app-client] (ecmascript)");
var callBindBasic = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/index.js [app-client] (ecmascript)");
/** @type {(thisArg: string, searchString: string, position?: number) => number} */ var $indexOf = callBindBasic([
    GetIntrinsic('%String.prototype.indexOf%')
]);
/** @type {import('.')} */ module.exports = function callBoundIntrinsic(name, allowMissing) {
    /* eslint no-extra-parens: 0 */ var intrinsic = GetIntrinsic(name, !!allowMissing);
    if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
        return callBindBasic([
            intrinsic
        ]);
    }
    return intrinsic;
};
}),
"[project]/node_modules/is-arguments/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var hasToStringTag = __turbopack_context__.r("[project]/node_modules/has-tostringtag/shams.js [app-client] (ecmascript)")();
var callBound = __turbopack_context__.r("[project]/node_modules/call-bound/index.js [app-client] (ecmascript)");
var $toString = callBound('Object.prototype.toString');
/** @type {import('.')} */ var isStandardArguments = function isArguments(value) {
    if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
        return false;
    }
    return $toString(value) === '[object Arguments]';
};
/** @type {import('.')} */ var isLegacyArguments = function isArguments(value) {
    if (isStandardArguments(value)) {
        return true;
    }
    return value !== null && typeof value === 'object' && 'length' in value && typeof value.length === 'number' && value.length >= 0 && $toString(value) !== '[object Array]' && 'callee' in value && $toString(value.callee) === '[object Function]';
};
var supportsStandardArguments = function() {
    return isStandardArguments(arguments);
}();
// @ts-expect-error TODO make this not error
isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests
/** @type {import('.')} */ module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
}),
"[project]/node_modules/is-regex/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var callBound = __turbopack_context__.r("[project]/node_modules/call-bound/index.js [app-client] (ecmascript)");
var hasToStringTag = __turbopack_context__.r("[project]/node_modules/has-tostringtag/shams.js [app-client] (ecmascript)")();
var hasOwn = __turbopack_context__.r("[project]/node_modules/hasown/index.js [app-client] (ecmascript)");
var gOPD = __turbopack_context__.r("[project]/node_modules/gopd/index.js [app-client] (ecmascript)");
/** @type {import('.')} */ var fn;
if (hasToStringTag) {
    /** @type {(receiver: ThisParameterType<typeof RegExp.prototype.exec>, ...args: Parameters<typeof RegExp.prototype.exec>) => ReturnType<typeof RegExp.prototype.exec>} */ var $exec = callBound('RegExp.prototype.exec');
    /** @type {object} */ var isRegexMarker = {};
    var throwRegexMarker = function() {
        throw isRegexMarker;
    };
    /** @type {{ toString(): never, valueOf(): never, [Symbol.toPrimitive]?(): never }} */ var badStringifier = {
        toString: throwRegexMarker,
        valueOf: throwRegexMarker
    };
    if (typeof Symbol.toPrimitive === 'symbol') {
        badStringifier[Symbol.toPrimitive] = throwRegexMarker;
    }
    /** @type {import('.')} */ // @ts-expect-error TS can't figure out that the $exec call always throws
    // eslint-disable-next-line consistent-return
    fn = function isRegex(value) {
        if (!value || typeof value !== 'object') {
            return false;
        }
        // eslint-disable-next-line no-extra-parens
        var descriptor = /** @type {NonNullable<typeof gOPD>} */ gOPD(value, 'lastIndex');
        var hasLastIndexDataProperty = descriptor && hasOwn(descriptor, 'value');
        if (!hasLastIndexDataProperty) {
            return false;
        }
        try {
            // eslint-disable-next-line no-extra-parens
            $exec(value, badStringifier);
        } catch (e) {
            return e === isRegexMarker;
        }
    };
} else {
    /** @type {(receiver: ThisParameterType<typeof Object.prototype.toString>, ...args: Parameters<typeof Object.prototype.toString>) => ReturnType<typeof Object.prototype.toString>} */ var $toString = callBound('Object.prototype.toString');
    /** @const @type {'[object RegExp]'} */ var regexClass = '[object RegExp]';
    /** @type {import('.')} */ fn = function isRegex(value) {
        // In older browsers, typeof regex incorrectly returns 'function'
        if (!value || typeof value !== 'object' && typeof value !== 'function') {
            return false;
        }
        return $toString(value) === regexClass;
    };
}
module.exports = fn;
}),
"[project]/node_modules/safe-regex-test/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var callBound = __turbopack_context__.r("[project]/node_modules/call-bound/index.js [app-client] (ecmascript)");
var isRegex = __turbopack_context__.r("[project]/node_modules/is-regex/index.js [app-client] (ecmascript)");
var $exec = callBound('RegExp.prototype.exec');
var $TypeError = __turbopack_context__.r("[project]/node_modules/es-errors/type.js [app-client] (ecmascript)");
/** @type {import('.')} */ module.exports = function regexTester(regex) {
    if (!isRegex(regex)) {
        throw new $TypeError('`regex` must be a RegExp');
    }
    return function test(s) {
        return $exec(regex, s) !== null;
    };
};
}),
"[project]/node_modules/generator-function/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// eslint-disable-next-line no-extra-parens, no-empty-function
const cached = (function*() {}).constructor;
/** @type {import('.')} */ module.exports = ()=>cached;
}),
"[project]/node_modules/is-generator-function/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var callBound = __turbopack_context__.r("[project]/node_modules/call-bound/index.js [app-client] (ecmascript)");
var safeRegexTest = __turbopack_context__.r("[project]/node_modules/safe-regex-test/index.js [app-client] (ecmascript)");
var isFnRegex = safeRegexTest(/^\s*(?:function)?\*/);
var hasToStringTag = __turbopack_context__.r("[project]/node_modules/has-tostringtag/shams.js [app-client] (ecmascript)")();
var getProto = __turbopack_context__.r("[project]/node_modules/get-proto/index.js [app-client] (ecmascript)");
var toStr = callBound('Object.prototype.toString');
var fnToStr = callBound('Function.prototype.toString');
var getGeneratorFunction = __turbopack_context__.r("[project]/node_modules/generator-function/index.js [app-client] (ecmascript)");
/** @type {import('.')} */ module.exports = function isGeneratorFunction(fn) {
    if (typeof fn !== 'function') {
        return false;
    }
    if (isFnRegex(fnToStr(fn))) {
        return true;
    }
    if (!hasToStringTag) {
        var str = toStr(fn);
        return str === '[object GeneratorFunction]';
    }
    if (!getProto) {
        return false;
    }
    var GeneratorFunction = getGeneratorFunction();
    return GeneratorFunction && getProto(fn) === GeneratorFunction.prototype;
};
}),
"[project]/node_modules/is-callable/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var fnToStr = Function.prototype.toString;
var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
var badArrayLike;
var isCallableMarker;
if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
    try {
        badArrayLike = Object.defineProperty({}, 'length', {
            get: function() {
                throw isCallableMarker;
            }
        });
        isCallableMarker = {};
        // eslint-disable-next-line no-throw-literal
        reflectApply(function() {
            throw 42;
        }, null, badArrayLike);
    } catch (_) {
        if (_ !== isCallableMarker) {
            reflectApply = null;
        }
    }
} else {
    reflectApply = null;
}
var constructorRegex = /^\s*class\b/;
var isES6ClassFn = function isES6ClassFunction(value) {
    try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
    } catch (e) {
        return false; // not a function
    }
};
var tryFunctionObject = function tryFunctionToStr(value) {
    try {
        if (isES6ClassFn(value)) {
            return false;
        }
        fnToStr.call(value);
        return true;
    } catch (e) {
        return false;
    }
};
var toStr = Object.prototype.toString;
var objectClass = '[object Object]';
var fnClass = '[object Function]';
var genClass = '[object GeneratorFunction]';
var ddaClass = '[object HTMLAllCollection]'; // IE 11
var ddaClass2 = '[object HTML document.all class]';
var ddaClass3 = '[object HTMLCollection]'; // IE 9-10
var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`
var isIE68 = !(0 in [
    , 
]); // eslint-disable-line no-sparse-arrays, comma-spacing
var isDDA = function isDocumentDotAll() {
    return false;
};
if (typeof document === 'object') {
    // Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
    var all = document.all;
    if (toStr.call(all) === toStr.call(document.all)) {
        isDDA = function isDocumentDotAll(value) {
            /* globals document: false */ // in IE 6-8, typeof document.all is "object" and it's truthy
            if ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {
                try {
                    var str = toStr.call(value);
                    return (str === ddaClass || str === ddaClass2 || str === ddaClass3 // opera 12.16
                     || str === objectClass // IE 6-8
                    ) && value('') == null; // eslint-disable-line eqeqeq
                } catch (e) {}
            }
            return false;
        };
    }
}
module.exports = reflectApply ? function isCallable(value) {
    if (isDDA(value)) {
        return true;
    }
    if (!value) {
        return false;
    }
    if (typeof value !== 'function' && typeof value !== 'object') {
        return false;
    }
    try {
        reflectApply(value, null, badArrayLike);
    } catch (e) {
        if (e !== isCallableMarker) {
            return false;
        }
    }
    return !isES6ClassFn(value) && tryFunctionObject(value);
} : function isCallable(value) {
    if (isDDA(value)) {
        return true;
    }
    if (!value) {
        return false;
    }
    if (typeof value !== 'function' && typeof value !== 'object') {
        return false;
    }
    if (hasToStringTag) {
        return tryFunctionObject(value);
    }
    if (isES6ClassFn(value)) {
        return false;
    }
    var strClass = toStr.call(value);
    if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
        return false;
    }
    return tryFunctionObject(value);
};
}),
"[project]/node_modules/for-each/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var isCallable = __turbopack_context__.r("[project]/node_modules/is-callable/index.js [app-client] (ecmascript)");
var toStr = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;
/** @type {<This, A extends readonly unknown[]>(arr: A, iterator: (this: This | void, value: A[number], index: number, arr: A) => void, receiver: This | undefined) => void} */ var forEachArray = function forEachArray(array, iterator, receiver) {
    for(var i = 0, len = array.length; i < len; i++){
        if (hasOwnProperty.call(array, i)) {
            if (receiver == null) {
                iterator(array[i], i, array);
            } else {
                iterator.call(receiver, array[i], i, array);
            }
        }
    }
};
/** @type {<This, S extends string>(string: S, iterator: (this: This | void, value: S[number], index: number, string: S) => void, receiver: This | undefined) => void} */ var forEachString = function forEachString(string, iterator, receiver) {
    for(var i = 0, len = string.length; i < len; i++){
        // no such thing as a sparse string.
        if (receiver == null) {
            iterator(string.charAt(i), i, string);
        } else {
            iterator.call(receiver, string.charAt(i), i, string);
        }
    }
};
/** @type {<This, O>(obj: O, iterator: (this: This | void, value: O[keyof O], index: keyof O, obj: O) => void, receiver: This | undefined) => void} */ var forEachObject = function forEachObject(object, iterator, receiver) {
    for(var k in object){
        if (hasOwnProperty.call(object, k)) {
            if (receiver == null) {
                iterator(object[k], k, object);
            } else {
                iterator.call(receiver, object[k], k, object);
            }
        }
    }
};
/** @type {(x: unknown) => x is readonly unknown[]} */ function isArray(x) {
    return toStr.call(x) === '[object Array]';
}
/** @type {import('.')._internal} */ module.exports = function forEach(list, iterator, thisArg) {
    if (!isCallable(iterator)) {
        throw new TypeError('iterator must be a function');
    }
    var receiver;
    if (arguments.length >= 3) {
        receiver = thisArg;
    }
    if (isArray(list)) {
        forEachArray(list, iterator, receiver);
    } else if (typeof list === 'string') {
        forEachString(list, iterator, receiver);
    } else {
        forEachObject(list, iterator, receiver);
    }
};
}),
"[project]/node_modules/possible-typed-array-names/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {import('.')} */ module.exports = [
    'Float16Array',
    'Float32Array',
    'Float64Array',
    'Int8Array',
    'Int16Array',
    'Int32Array',
    'Uint8Array',
    'Uint8ClampedArray',
    'Uint16Array',
    'Uint32Array',
    'BigInt64Array',
    'BigUint64Array'
];
}),
"[project]/node_modules/available-typed-arrays/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var possibleNames = __turbopack_context__.r("[project]/node_modules/possible-typed-array-names/index.js [app-client] (ecmascript)");
var g = typeof globalThis === 'undefined' ? /*TURBOPACK member replacement*/ __turbopack_context__.g : globalThis;
/** @type {import('.')} */ module.exports = function availableTypedArrays() {
    var /** @type {ReturnType<typeof availableTypedArrays>} */ out = [];
    for(var i = 0; i < possibleNames.length; i++){
        if (typeof g[possibleNames[i]] === 'function') {
            // @ts-expect-error
            out[out.length] = possibleNames[i];
        }
    }
    return out;
};
}),
"[project]/node_modules/define-data-property/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var $defineProperty = __turbopack_context__.r("[project]/node_modules/es-define-property/index.js [app-client] (ecmascript)");
var $SyntaxError = __turbopack_context__.r("[project]/node_modules/es-errors/syntax.js [app-client] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/es-errors/type.js [app-client] (ecmascript)");
var gopd = __turbopack_context__.r("[project]/node_modules/gopd/index.js [app-client] (ecmascript)");
/** @type {import('.')} */ module.exports = function defineDataProperty(obj, property, value) {
    if (!obj || typeof obj !== 'object' && typeof obj !== 'function') {
        throw new $TypeError('`obj` must be an object or a function`');
    }
    if (typeof property !== 'string' && typeof property !== 'symbol') {
        throw new $TypeError('`property` must be a string or a symbol`');
    }
    if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
        throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
    }
    if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
        throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
    }
    if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
        throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
    }
    if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
        throw new $TypeError('`loose`, if provided, must be a boolean');
    }
    var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
    var nonWritable = arguments.length > 4 ? arguments[4] : null;
    var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
    var loose = arguments.length > 6 ? arguments[6] : false;
    /* @type {false | TypedPropertyDescriptor<unknown>} */ var desc = !!gopd && gopd(obj, property);
    if ($defineProperty) {
        $defineProperty(obj, property, {
            configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
            enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
            value: value,
            writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
    } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        // must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
        obj[property] = value; // eslint-disable-line no-param-reassign
    } else {
        throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
    }
};
}),
"[project]/node_modules/has-property-descriptors/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var $defineProperty = __turbopack_context__.r("[project]/node_modules/es-define-property/index.js [app-client] (ecmascript)");
var hasPropertyDescriptors = function hasPropertyDescriptors() {
    return !!$defineProperty;
};
hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
    // node v0.6 has a bug where array lengths can be Set but not Defined
    if (!$defineProperty) {
        return null;
    }
    try {
        return $defineProperty([], 'length', {
            value: 1
        }).length !== 1;
    } catch (e) {
        // In Firefox 4-22, defining length on an array throws an exception.
        return true;
    }
};
module.exports = hasPropertyDescriptors;
}),
"[project]/node_modules/set-function-length/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var GetIntrinsic = __turbopack_context__.r("[project]/node_modules/get-intrinsic/index.js [app-client] (ecmascript)");
var define = __turbopack_context__.r("[project]/node_modules/define-data-property/index.js [app-client] (ecmascript)");
var hasDescriptors = __turbopack_context__.r("[project]/node_modules/has-property-descriptors/index.js [app-client] (ecmascript)")();
var gOPD = __turbopack_context__.r("[project]/node_modules/gopd/index.js [app-client] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/es-errors/type.js [app-client] (ecmascript)");
var $floor = GetIntrinsic('%Math.floor%');
/** @type {import('.')} */ module.exports = function setFunctionLength(fn, length) {
    if (typeof fn !== 'function') {
        throw new $TypeError('`fn` is not a function');
    }
    if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
        throw new $TypeError('`length` must be a positive 32-bit integer');
    }
    var loose = arguments.length > 2 && !!arguments[2];
    var functionLengthIsConfigurable = true;
    var functionLengthIsWritable = true;
    if ('length' in fn && gOPD) {
        var desc = gOPD(fn, 'length');
        if (desc && !desc.configurable) {
            functionLengthIsConfigurable = false;
        }
        if (desc && !desc.writable) {
            functionLengthIsWritable = false;
        }
    }
    if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
        if (hasDescriptors) {
            define(fn, 'length', length, true, true);
        } else {
            define(fn, 'length', length);
        }
    }
    return fn;
};
}),
"[project]/node_modules/call-bind/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var setFunctionLength = __turbopack_context__.r("[project]/node_modules/set-function-length/index.js [app-client] (ecmascript)");
var $defineProperty = __turbopack_context__.r("[project]/node_modules/es-define-property/index.js [app-client] (ecmascript)");
var callBindBasic = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/index.js [app-client] (ecmascript)");
var applyBind = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/applyBind.js [app-client] (ecmascript)");
module.exports = function callBind(originalFunction) {
    var func = callBindBasic(arguments);
    var adjustedLength = originalFunction.length - (arguments.length - 1);
    return setFunctionLength(func, 1 + (adjustedLength > 0 ? adjustedLength : 0), true);
};
if ($defineProperty) {
    $defineProperty(module.exports, 'apply', {
        value: applyBind
    });
} else {
    module.exports.apply = applyBind;
}
}),
"[project]/node_modules/which-typed-array/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var forEach = __turbopack_context__.r("[project]/node_modules/for-each/index.js [app-client] (ecmascript)");
var availableTypedArrays = __turbopack_context__.r("[project]/node_modules/available-typed-arrays/index.js [app-client] (ecmascript)");
var callBind = __turbopack_context__.r("[project]/node_modules/call-bind/index.js [app-client] (ecmascript)");
var callBound = __turbopack_context__.r("[project]/node_modules/call-bound/index.js [app-client] (ecmascript)");
var gOPD = __turbopack_context__.r("[project]/node_modules/gopd/index.js [app-client] (ecmascript)");
var getProto = __turbopack_context__.r("[project]/node_modules/get-proto/index.js [app-client] (ecmascript)");
var $toString = callBound('Object.prototype.toString');
var hasToStringTag = __turbopack_context__.r("[project]/node_modules/has-tostringtag/shams.js [app-client] (ecmascript)")();
var g = typeof globalThis === 'undefined' ? /*TURBOPACK member replacement*/ __turbopack_context__.g : globalThis;
var typedArrays = availableTypedArrays();
var $slice = callBound('String.prototype.slice');
/** @type {<T = unknown>(array: readonly T[], value: unknown) => number} */ var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
    for(var i = 0; i < array.length; i += 1){
        if (array[i] === value) {
            return i;
        }
    }
    return -1;
};
/** @typedef {import('./types').Getter} Getter */ /** @type {import('./types').Cache} */ var cache = {
    __proto__: null
};
if (hasToStringTag && gOPD && getProto) {
    forEach(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        if (Symbol.toStringTag in arr && getProto) {
            var proto = getProto(arr);
            // @ts-expect-error TS won't narrow inside a closure
            var descriptor = gOPD(proto, Symbol.toStringTag);
            if (!descriptor && proto) {
                var superProto = getProto(proto);
                // @ts-expect-error TS won't narrow inside a closure
                descriptor = gOPD(superProto, Symbol.toStringTag);
            }
            // @ts-expect-error TODO: fix
            cache['$' + typedArray] = callBind(descriptor.get);
        }
    });
} else {
    forEach(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        var fn = arr.slice || arr.set;
        if (fn) {
            cache['$' + typedArray] = // @ts-expect-error TODO FIXME
            callBind(fn);
        }
    });
}
/** @type {(value: object) => false | import('.').TypedArrayName} */ var tryTypedArrays = function tryAllTypedArrays(value) {
    /** @type {ReturnType<typeof tryAllTypedArrays>} */ var found = false;
    forEach(cache, /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */ function(getter, typedArray) {
        if (!found) {
            try {
                // @ts-expect-error a throw is fine here
                if ('$' + getter(value) === typedArray) {
                    found = $slice(typedArray, 1);
                }
            } catch (e) {}
        }
    });
    return found;
};
/** @type {(value: object) => false | import('.').TypedArrayName} */ var trySlices = function tryAllSlices(value) {
    /** @type {ReturnType<typeof tryAllSlices>} */ var found = false;
    forEach(cache, /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */ function(getter, name) {
        if (!found) {
            try {
                // @ts-expect-error a throw is fine here
                getter(value);
                found = $slice(name, 1);
            } catch (e) {}
        }
    });
    return found;
};
/** @type {import('.')} */ module.exports = function whichTypedArray(value) {
    if (!value || typeof value !== 'object') {
        return false;
    }
    if (!hasToStringTag) {
        /** @type {string} */ var tag = $slice($toString(value), 8, -1);
        if ($indexOf(typedArrays, tag) > -1) {
            return tag;
        }
        if (tag !== 'Object') {
            return false;
        }
        // node < 0.6 hits here on real Typed Arrays
        return trySlices(value);
    }
    if (!gOPD) {
        return null;
    } // unknown engine
    return tryTypedArrays(value);
};
}),
"[project]/node_modules/is-typed-array/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var whichTypedArray = __turbopack_context__.r("[project]/node_modules/which-typed-array/index.js [app-client] (ecmascript)");
/** @type {import('.')} */ module.exports = function isTypedArray(value) {
    return !!whichTypedArray(value);
};
}),
"[project]/node_modules/util/support/types.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Currently in sync with Node.js lib/internal/util/types.js
// https://github.com/nodejs/node/commit/112cc7c27551254aa2b17098fb774867f05ed0d9
var isArgumentsObject = __turbopack_context__.r("[project]/node_modules/is-arguments/index.js [app-client] (ecmascript)");
var isGeneratorFunction = __turbopack_context__.r("[project]/node_modules/is-generator-function/index.js [app-client] (ecmascript)");
var whichTypedArray = __turbopack_context__.r("[project]/node_modules/which-typed-array/index.js [app-client] (ecmascript)");
var isTypedArray = __turbopack_context__.r("[project]/node_modules/is-typed-array/index.js [app-client] (ecmascript)");
function uncurryThis(f) {
    return f.call.bind(f);
}
var BigIntSupported = typeof BigInt !== 'undefined';
var SymbolSupported = typeof Symbol !== 'undefined';
var ObjectToString = uncurryThis(Object.prototype.toString);
var numberValue = uncurryThis(Number.prototype.valueOf);
var stringValue = uncurryThis(String.prototype.valueOf);
var booleanValue = uncurryThis(Boolean.prototype.valueOf);
if (BigIntSupported) {
    var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
}
if (SymbolSupported) {
    var symbolValue = uncurryThis(Symbol.prototype.valueOf);
}
function checkBoxedPrimitive(value, prototypeValueOf) {
    if (typeof value !== 'object') {
        return false;
    }
    try {
        prototypeValueOf(value);
        return true;
    } catch (e) {
        return false;
    }
}
exports.isArgumentsObject = isArgumentsObject;
exports.isGeneratorFunction = isGeneratorFunction;
exports.isTypedArray = isTypedArray;
// Taken from here and modified for better browser support
// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
function isPromise(input) {
    return typeof Promise !== 'undefined' && input instanceof Promise || input !== null && typeof input === 'object' && typeof input.then === 'function' && typeof input.catch === 'function';
}
exports.isPromise = isPromise;
function isArrayBufferView(value) {
    if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
        return ArrayBuffer.isView(value);
    }
    return isTypedArray(value) || isDataView(value);
}
exports.isArrayBufferView = isArrayBufferView;
function isUint8Array(value) {
    return whichTypedArray(value) === 'Uint8Array';
}
exports.isUint8Array = isUint8Array;
function isUint8ClampedArray(value) {
    return whichTypedArray(value) === 'Uint8ClampedArray';
}
exports.isUint8ClampedArray = isUint8ClampedArray;
function isUint16Array(value) {
    return whichTypedArray(value) === 'Uint16Array';
}
exports.isUint16Array = isUint16Array;
function isUint32Array(value) {
    return whichTypedArray(value) === 'Uint32Array';
}
exports.isUint32Array = isUint32Array;
function isInt8Array(value) {
    return whichTypedArray(value) === 'Int8Array';
}
exports.isInt8Array = isInt8Array;
function isInt16Array(value) {
    return whichTypedArray(value) === 'Int16Array';
}
exports.isInt16Array = isInt16Array;
function isInt32Array(value) {
    return whichTypedArray(value) === 'Int32Array';
}
exports.isInt32Array = isInt32Array;
function isFloat32Array(value) {
    return whichTypedArray(value) === 'Float32Array';
}
exports.isFloat32Array = isFloat32Array;
function isFloat64Array(value) {
    return whichTypedArray(value) === 'Float64Array';
}
exports.isFloat64Array = isFloat64Array;
function isBigInt64Array(value) {
    return whichTypedArray(value) === 'BigInt64Array';
}
exports.isBigInt64Array = isBigInt64Array;
function isBigUint64Array(value) {
    return whichTypedArray(value) === 'BigUint64Array';
}
exports.isBigUint64Array = isBigUint64Array;
function isMapToString(value) {
    return ObjectToString(value) === '[object Map]';
}
isMapToString.working = typeof Map !== 'undefined' && isMapToString(new Map());
function isMap(value) {
    if (typeof Map === 'undefined') {
        return false;
    }
    return isMapToString.working ? isMapToString(value) : value instanceof Map;
}
exports.isMap = isMap;
function isSetToString(value) {
    return ObjectToString(value) === '[object Set]';
}
isSetToString.working = typeof Set !== 'undefined' && isSetToString(new Set());
function isSet(value) {
    if (typeof Set === 'undefined') {
        return false;
    }
    return isSetToString.working ? isSetToString(value) : value instanceof Set;
}
exports.isSet = isSet;
function isWeakMapToString(value) {
    return ObjectToString(value) === '[object WeakMap]';
}
isWeakMapToString.working = typeof WeakMap !== 'undefined' && isWeakMapToString(new WeakMap());
function isWeakMap(value) {
    if (typeof WeakMap === 'undefined') {
        return false;
    }
    return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
}
exports.isWeakMap = isWeakMap;
function isWeakSetToString(value) {
    return ObjectToString(value) === '[object WeakSet]';
}
isWeakSetToString.working = typeof WeakSet !== 'undefined' && isWeakSetToString(new WeakSet());
function isWeakSet(value) {
    return isWeakSetToString(value);
}
exports.isWeakSet = isWeakSet;
function isArrayBufferToString(value) {
    return ObjectToString(value) === '[object ArrayBuffer]';
}
isArrayBufferToString.working = typeof ArrayBuffer !== 'undefined' && isArrayBufferToString(new ArrayBuffer());
function isArrayBuffer(value) {
    if (typeof ArrayBuffer === 'undefined') {
        return false;
    }
    return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
}
exports.isArrayBuffer = isArrayBuffer;
function isDataViewToString(value) {
    return ObjectToString(value) === '[object DataView]';
}
isDataViewToString.working = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined' && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
function isDataView(value) {
    if (typeof DataView === 'undefined') {
        return false;
    }
    return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
}
exports.isDataView = isDataView;
// Store a copy of SharedArrayBuffer in case it's deleted elsewhere
var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
function isSharedArrayBufferToString(value) {
    return ObjectToString(value) === '[object SharedArrayBuffer]';
}
function isSharedArrayBuffer(value) {
    if (typeof SharedArrayBufferCopy === 'undefined') {
        return false;
    }
    if (typeof isSharedArrayBufferToString.working === 'undefined') {
        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
    }
    return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
}
exports.isSharedArrayBuffer = isSharedArrayBuffer;
function isAsyncFunction(value) {
    return ObjectToString(value) === '[object AsyncFunction]';
}
exports.isAsyncFunction = isAsyncFunction;
function isMapIterator(value) {
    return ObjectToString(value) === '[object Map Iterator]';
}
exports.isMapIterator = isMapIterator;
function isSetIterator(value) {
    return ObjectToString(value) === '[object Set Iterator]';
}
exports.isSetIterator = isSetIterator;
function isGeneratorObject(value) {
    return ObjectToString(value) === '[object Generator]';
}
exports.isGeneratorObject = isGeneratorObject;
function isWebAssemblyCompiledModule(value) {
    return ObjectToString(value) === '[object WebAssembly.Module]';
}
exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
function isNumberObject(value) {
    return checkBoxedPrimitive(value, numberValue);
}
exports.isNumberObject = isNumberObject;
function isStringObject(value) {
    return checkBoxedPrimitive(value, stringValue);
}
exports.isStringObject = isStringObject;
function isBooleanObject(value) {
    return checkBoxedPrimitive(value, booleanValue);
}
exports.isBooleanObject = isBooleanObject;
function isBigIntObject(value) {
    return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
}
exports.isBigIntObject = isBigIntObject;
function isSymbolObject(value) {
    return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
}
exports.isSymbolObject = isSymbolObject;
function isBoxedPrimitive(value) {
    return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
}
exports.isBoxedPrimitive = isBoxedPrimitive;
function isAnyArrayBuffer(value) {
    return typeof Uint8Array !== 'undefined' && (isArrayBuffer(value) || isSharedArrayBuffer(value));
}
exports.isAnyArrayBuffer = isAnyArrayBuffer;
[
    'isProxy',
    'isExternal',
    'isModuleNamespaceObject'
].forEach(function(method) {
    Object.defineProperty(exports, method, {
        enumerable: false,
        value: function() {
            throw new Error(method + ' is not supported in userland');
        }
    });
});
}),
"[project]/node_modules/util/support/isBufferBrowser.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = function isBuffer(arg) {
    return arg && typeof arg === 'object' && typeof arg.copy === 'function' && typeof arg.fill === 'function' && typeof arg.readUInt8 === 'function';
};
}),
"[project]/node_modules/util/util.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for(var i = 0; i < keys.length; i++){
        descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
};
var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
    if (!isString(f)) {
        var objects = [];
        for(var i = 0; i < arguments.length; i++){
            objects.push(inspect(arguments[i]));
        }
        return objects.join(' ');
    }
    var i = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f).replace(formatRegExp, function(x) {
        if (x === '%%') return '%';
        if (i >= len) return x;
        switch(x){
            case '%s':
                return String(args[i++]);
            case '%d':
                return Number(args[i++]);
            case '%j':
                try {
                    return JSON.stringify(args[i++]);
                } catch (_) {
                    return '[Circular]';
                }
            default:
                return x;
        }
    });
    for(var x = args[i]; i < len; x = args[++i]){
        if (isNull(x) || !isObject(x)) {
            str += ' ' + x;
        } else {
            str += ' ' + inspect(x);
        }
    }
    return str;
};
// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
    if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] !== 'undefined' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].noDeprecation === true) {
        return fn;
    }
    // Allow for deprecating things in the process of starting up.
    if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] === 'undefined') {
        return function() {
            return exports.deprecate(fn, msg).apply(this, arguments);
        };
    }
    var warned = false;
    function deprecated() {
        if (!warned) {
            if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].throwDeprecation) {
                throw new Error(msg);
            } else if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].traceDeprecation) {
                console.trace(msg);
            } else {
                console.error(msg);
            }
            warned = true;
        }
        return fn.apply(this, arguments);
    }
    return deprecated;
};
var debugs = {};
var debugEnvRegex = /^$/;
if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.NODE_DEBUG) {
    var debugEnv = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.NODE_DEBUG;
    debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, '\\$&').replace(/\*/g, '.*').replace(/,/g, '$|^').toUpperCase();
    debugEnvRegex = new RegExp('^' + debugEnv + '$', 'i');
}
exports.debuglog = function(set) {
    set = set.toUpperCase();
    if (!debugs[set]) {
        if (debugEnvRegex.test(set)) {
            var pid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].pid;
            debugs[set] = function() {
                var msg = exports.format.apply(exports, arguments);
                console.error('%s %d: %s', set, pid, msg);
            };
        } else {
            debugs[set] = function() {};
        }
    }
    return debugs[set];
};
/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */ /* legacy: obj, showHidden, depth, colors*/ function inspect(obj, opts) {
    // default options
    var ctx = {
        seen: [],
        stylize: stylizeNoColor
    };
    // legacy...
    if (arguments.length >= 3) ctx.depth = arguments[2];
    if (arguments.length >= 4) ctx.colors = arguments[3];
    if (isBoolean(opts)) {
        // legacy...
        ctx.showHidden = opts;
    } else if (opts) {
        // got an "options" object
        exports._extend(ctx, opts);
    }
    // set default options
    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
    if (isUndefined(ctx.depth)) ctx.depth = 2;
    if (isUndefined(ctx.colors)) ctx.colors = false;
    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
    if (ctx.colors) ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;
// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
    'bold': [
        1,
        22
    ],
    'italic': [
        3,
        23
    ],
    'underline': [
        4,
        24
    ],
    'inverse': [
        7,
        27
    ],
    'white': [
        37,
        39
    ],
    'grey': [
        90,
        39
    ],
    'black': [
        30,
        39
    ],
    'blue': [
        34,
        39
    ],
    'cyan': [
        36,
        39
    ],
    'green': [
        32,
        39
    ],
    'magenta': [
        35,
        39
    ],
    'red': [
        31,
        39
    ],
    'yellow': [
        33,
        39
    ]
};
// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
    'special': 'cyan',
    'number': 'yellow',
    'boolean': 'yellow',
    'undefined': 'grey',
    'null': 'bold',
    'string': 'green',
    'date': 'magenta',
    // "name": intentionally not styling
    'regexp': 'red'
};
function stylizeWithColor(str, styleType) {
    var style = inspect.styles[styleType];
    if (style) {
        return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
    } else {
        return str;
    }
}
function stylizeNoColor(str, styleType) {
    return str;
}
function arrayToHash(array) {
    var hash = {};
    array.forEach(function(val, idx) {
        hash[val] = true;
    });
    return hash;
}
function formatValue(ctx, value, recurseTimes) {
    // Provide a hook for user-specified inspect functions.
    // Check that value is an object with an inspect function on it
    if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
    value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
    !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
            ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
    }
    // Primitive types cannot have properties
    var primitive = formatPrimitive(ctx, value);
    if (primitive) {
        return primitive;
    }
    // Look up the keys of the object.
    var keys = Object.keys(value);
    var visibleKeys = arrayToHash(keys);
    if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
    }
    // IE doesn't make error fields non-enumerable
    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
    if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
        return formatError(value);
    }
    // Some type of object without properties can be shortcutted.
    if (keys.length === 0) {
        if (isFunction(value)) {
            var name = value.name ? ': ' + value.name : '';
            return ctx.stylize('[Function' + name + ']', 'special');
        }
        if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }
        if (isDate(value)) {
            return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }
        if (isError(value)) {
            return formatError(value);
        }
    }
    var base = '', array = false, braces = [
        '{',
        '}'
    ];
    // Make Array say that they are Array
    if (isArray(value)) {
        array = true;
        braces = [
            '[',
            ']'
        ];
    }
    // Make functions say that they are functions
    if (isFunction(value)) {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
    }
    // Make RegExps say that they are RegExps
    if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
    }
    // Make dates with properties first say the date
    if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
    }
    // Make error with message first say the error
    if (isError(value)) {
        base = ' ' + formatError(value);
    }
    if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
    }
    if (recurseTimes < 0) {
        if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
            return ctx.stylize('[Object]', 'special');
        }
    }
    ctx.seen.push(value);
    var output;
    if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
    } else {
        output = keys.map(function(key) {
            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
    }
    ctx.seen.pop();
    return reduceToSingleString(output, base, braces);
}
function formatPrimitive(ctx, value) {
    if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
    if (isString(value)) {
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
        return ctx.stylize(simple, 'string');
    }
    if (isNumber(value)) return ctx.stylize('' + value, 'number');
    if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
    // For some reason typeof null is "object", so special case here.
    if (isNull(value)) return ctx.stylize('null', 'null');
}
function formatError(value) {
    return '[' + Error.prototype.toString.call(value) + ']';
}
function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
    var output = [];
    for(var i = 0, l = value.length; i < l; ++i){
        if (hasOwnProperty(value, String(i))) {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
        } else {
            output.push('');
        }
    }
    keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
        }
    });
    return output;
}
function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name, str, desc;
    desc = Object.getOwnPropertyDescriptor(value, key) || {
        value: value[key]
    };
    if (desc.get) {
        if (desc.set) {
            str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
            str = ctx.stylize('[Getter]', 'special');
        }
    } else {
        if (desc.set) {
            str = ctx.stylize('[Setter]', 'special');
        }
    }
    if (!hasOwnProperty(visibleKeys, key)) {
        name = '[' + key + ']';
    }
    if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
            if (isNull(recurseTimes)) {
                str = formatValue(ctx, desc.value, null);
            } else {
                str = formatValue(ctx, desc.value, recurseTimes - 1);
            }
            if (str.indexOf('\n') > -1) {
                if (array) {
                    str = str.split('\n').map(function(line) {
                        return '  ' + line;
                    }).join('\n').slice(2);
                } else {
                    str = '\n' + str.split('\n').map(function(line) {
                        return '   ' + line;
                    }).join('\n');
                }
            }
        } else {
            str = ctx.stylize('[Circular]', 'special');
        }
    }
    if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
            return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name = name.slice(1, -1);
            name = ctx.stylize(name, 'name');
        } else {
            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
            name = ctx.stylize(name, 'string');
        }
    }
    return name + ': ' + str;
}
function reduceToSingleString(output, base, braces) {
    var numLinesEst = 0;
    var length = output.reduce(function(prev, cur) {
        numLinesEst++;
        if (cur.indexOf('\n') >= 0) numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
    }, 0);
    if (length > 60) {
        return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
    }
    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}
// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
exports.types = __turbopack_context__.r("[project]/node_modules/util/support/types.js [app-client] (ecmascript)");
function isArray(ar) {
    return Array.isArray(ar);
}
exports.isArray = isArray;
function isBoolean(arg) {
    return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;
function isNull(arg) {
    return arg === null;
}
exports.isNull = isNull;
function isNullOrUndefined(arg) {
    return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;
function isNumber(arg) {
    return typeof arg === 'number';
}
exports.isNumber = isNumber;
function isString(arg) {
    return typeof arg === 'string';
}
exports.isString = isString;
function isSymbol(arg) {
    return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;
function isUndefined(arg) {
    return arg === void 0;
}
exports.isUndefined = isUndefined;
function isRegExp(re) {
    return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;
exports.types.isRegExp = isRegExp;
function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;
function isDate(d) {
    return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;
exports.types.isDate = isDate;
function isError(e) {
    return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;
exports.types.isNativeError = isError;
function isFunction(arg) {
    return typeof arg === 'function';
}
exports.isFunction = isFunction;
function isPrimitive(arg) {
    return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
    typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;
exports.isBuffer = __turbopack_context__.r("[project]/node_modules/util/support/isBufferBrowser.js [app-client] (ecmascript)");
function objectToString(o) {
    return Object.prototype.toString.call(o);
}
function pad(n) {
    return n < 10 ? '0' + n.toString(10) : n.toString(10);
}
var months = [
    'Jan',
    'Feb',
    'Mar',
    'Apr',
    'May',
    'Jun',
    'Jul',
    'Aug',
    'Sep',
    'Oct',
    'Nov',
    'Dec'
];
// 26 Feb 16:19:34
function timestamp() {
    var d = new Date();
    var time = [
        pad(d.getHours()),
        pad(d.getMinutes()),
        pad(d.getSeconds())
    ].join(':');
    return [
        d.getDate(),
        months[d.getMonth()],
        time
    ].join(' ');
}
// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
    console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};
/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */ exports.inherits = __turbopack_context__.r("[project]/node_modules/inherits/inherits_browser.js [app-client] (ecmascript)");
exports._extend = function(origin, add) {
    // Don't do anything if add isn't an object
    if (!add || !isObject(add)) return origin;
    var keys = Object.keys(add);
    var i = keys.length;
    while(i--){
        origin[keys[i]] = add[keys[i]];
    }
    return origin;
};
function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
}
var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;
exports.promisify = function promisify(original) {
    if (typeof original !== 'function') throw new TypeError('The "original" argument must be of type Function');
    if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn = original[kCustomPromisifiedSymbol];
        if (typeof fn !== 'function') {
            throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
            value: fn,
            enumerable: false,
            writable: false,
            configurable: true
        });
        return fn;
    }
    function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function(resolve, reject) {
            promiseResolve = resolve;
            promiseReject = reject;
        });
        var args = [];
        for(var i = 0; i < arguments.length; i++){
            args.push(arguments[i]);
        }
        args.push(function(err, value) {
            if (err) {
                promiseReject(err);
            } else {
                promiseResolve(value);
            }
        });
        try {
            original.apply(this, args);
        } catch (err) {
            promiseReject(err);
        }
        return promise;
    }
    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
    if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
    });
    return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
};
exports.promisify.custom = kCustomPromisifiedSymbol;
function callbackifyOnRejected(reason, cb) {
    // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
    // Because `null` is a special error value in callbacks which means "no error
    // occurred", we error-wrap so the callback consumer can distinguish between
    // "the promise rejected with null" or "the promise fulfilled with undefined".
    if (!reason) {
        var newReason = new Error('Promise was rejected with a falsy value');
        newReason.reason = reason;
        reason = newReason;
    }
    return cb(reason);
}
function callbackify(original) {
    if (typeof original !== 'function') {
        throw new TypeError('The "original" argument must be of type Function');
    }
    // We DO NOT return the promise as it gives the user a false sense that
    // the promise is actually somehow related to the callback's execution
    // and that the callback throwing will reject the promise.
    function callbackified() {
        var args = [];
        for(var i = 0; i < arguments.length; i++){
            args.push(arguments[i]);
        }
        var maybeCb = args.pop();
        if (typeof maybeCb !== 'function') {
            throw new TypeError('The last argument must be of type Function');
        }
        var self = this;
        var cb = function() {
            return maybeCb.apply(self, arguments);
        };
        // In true node style we process the callback on `nextTick` with all the
        // implications (stack, `uncaughtException`, `async_hooks`)
        original.apply(this, args).then(function(ret) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(cb.bind(null, null, ret));
        }, function(rej) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].nextTick(callbackifyOnRejected.bind(null, rej, cb));
        });
    }
    Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
    Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
    return callbackified;
}
exports.callbackify = callbackify;
}),
"[project]/node_modules/safe-buffer/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ /* eslint-disable node/no-deprecated-api */ var buffer = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
var Buffer = buffer.Buffer;
// alternative to using Object.keys for old browsers
function copyProps(src, dst) {
    for(var key in src){
        dst[key] = src[key];
    }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
    module.exports = buffer;
} else {
    // Copy properties from require('buffer')
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
}
function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer(arg, encodingOrOffset, length);
}
SafeBuffer.prototype = Object.create(Buffer.prototype);
// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer);
SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === 'number') {
        throw new TypeError('Argument must not be a number');
    }
    return Buffer(arg, encodingOrOffset, length);
};
SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
    }
    var buf = Buffer(size);
    if (fill !== undefined) {
        if (typeof encoding === 'string') {
            buf.fill(fill, encoding);
        } else {
            buf.fill(fill);
        }
    } else {
        buf.fill(0);
    }
    return buf;
};
SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
    }
    return Buffer(size);
};
SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== 'number') {
        throw new TypeError('Argument must be a number');
    }
    return buffer.SlowBuffer(size);
};
}),
"[project]/node_modules/string_decoder/lib/string_decoder.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
/*<replacement>*/ var Buffer = __turbopack_context__.r("[project]/node_modules/safe-buffer/index.js [app-client] (ecmascript)").Buffer;
/*</replacement>*/ var isEncoding = Buffer.isEncoding || function(encoding) {
    encoding = '' + encoding;
    switch(encoding && encoding.toLowerCase()){
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
        case 'raw':
            return true;
        default:
            return false;
    }
};
function _normalizeEncoding(enc) {
    if (!enc) return 'utf8';
    var retried;
    while(true){
        switch(enc){
            case 'utf8':
            case 'utf-8':
                return 'utf8';
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
                return 'utf16le';
            case 'latin1':
            case 'binary':
                return 'latin1';
            case 'base64':
            case 'ascii':
            case 'hex':
                return enc;
            default:
                if (retried) return; // undefined
                enc = ('' + enc).toLowerCase();
                retried = true;
        }
    }
}
;
// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
    return nenc || enc;
}
// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch(this.encoding){
        case 'utf16le':
            this.text = utf16Text;
            this.end = utf16End;
            nb = 4;
            break;
        case 'utf8':
            this.fillLast = utf8FillLast;
            nb = 4;
            break;
        case 'base64':
            this.text = base64Text;
            this.end = base64End;
            nb = 3;
            break;
        default:
            this.write = simpleWrite;
            this.end = simpleEnd;
            return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer.allocUnsafe(nb);
}
StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0) return '';
    var r;
    var i;
    if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === undefined) return '';
        i = this.lastNeed;
        this.lastNeed = 0;
    } else {
        i = 0;
    }
    if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || '';
};
StringDecoder.prototype.end = utf8End;
// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;
// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
};
// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
    if (byte <= 0x7F) return 0;
    else if (byte >> 5 === 0x06) return 2;
    else if (byte >> 4 === 0x0E) return 3;
    else if (byte >> 3 === 0x1E) return 4;
    return byte >> 6 === 0x02 ? -1 : -2;
}
// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
    var j = buf.length - 1;
    if (j < i) return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 1;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) self.lastNeed = nb - 2;
        return nb;
    }
    if (--j < i || nb === -2) return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
        if (nb > 0) {
            if (nb === 2) nb = 0;
            else self.lastNeed = nb - 3;
        }
        return nb;
    }
    return 0;
}
// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
    if ((buf[0] & 0xC0) !== 0x80) {
        self.lastNeed = 0;
        return '\ufffd';
    }
    if (self.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 0xC0) !== 0x80) {
            self.lastNeed = 1;
            return '\ufffd';
        }
        if (self.lastNeed > 2 && buf.length > 2) {
            if ((buf[2] & 0xC0) !== 0x80) {
                self.lastNeed = 2;
                return '\ufffd';
            }
        }
    }
}
// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf, p);
    if (r !== undefined) return r;
    if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
}
// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed) return buf.toString('utf8', i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString('utf8', i, end);
}
// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';
    if (this.lastNeed) return r + '\ufffd';
    return r;
}
// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
        var r = buf.toString('utf16le', i);
        if (r) {
            var c = r.charCodeAt(r.length - 1);
            if (c >= 0xD800 && c <= 0xDBFF) {
                this.lastNeed = 2;
                this.lastTotal = 4;
                this.lastChar[0] = buf[buf.length - 2];
                this.lastChar[1] = buf[buf.length - 1];
                return r.slice(0, -1);
            }
        }
        return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString('utf16le', i, buf.length - 1);
}
// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';
    if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString('utf16le', 0, end);
    }
    return r;
}
function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0) return buf.toString('base64', i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
    } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString('base64', i, buf.length - n);
}
function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : '';
    if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
    return r;
}
// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
    return buf.toString(this.encoding);
}
function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : '';
}
}),
"[project]/node_modules/bn.js/lib/bn.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

(function(module1, exports) {
    'use strict';
    // Utils
    function assert(val, msg) {
        if (!val) throw new Error(msg || 'Assertion failed');
    }
    // Could use `inherits` module, but don't want to move from single file
    // architecture yet.
    function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
    }
    // BN
    function BN(number, base, endian) {
        if (BN.isBN(number)) {
            return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        // Reduction context
        this.red = null;
        if (number !== null) {
            if (base === 'le' || base === 'be') {
                endian = base;
                base = 10;
            }
            this._init(number || 0, base || 10, endian || 'be');
        }
    }
    if ("TURBOPACK compile-time truthy", 1) {
        module1.exports = BN;
    } else //TURBOPACK unreachable
    ;
    BN.BN = BN;
    BN.wordSize = 26;
    var Buffer;
    try {
        if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
            Buffer = window.Buffer;
        } else {
            Buffer = ({}).Buffer;
        }
    } catch (e) {}
    BN.isBN = function isBN(num) {
        if (num instanceof BN) {
            return true;
        }
        return num !== null && typeof num === 'object' && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
    };
    BN.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
    };
    BN.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
    };
    BN.prototype._init = function init(number, base, endian) {
        if (typeof number === 'number') {
            return this._initNumber(number, base, endian);
        }
        if (typeof number === 'object') {
            return this._initArray(number, base, endian);
        }
        if (base === 'hex') {
            base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, '');
        var start = 0;
        if (number[0] === '-') {
            start++;
            this.negative = 1;
        }
        if (start < number.length) {
            if (base === 16) {
                this._parseHex(number, start, endian);
            } else {
                this._parseBase(number, base, start);
                if (endian === 'le') {
                    this._initArray(this.toArray(), base, endian);
                }
            }
        }
    };
    BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
            this.negative = 1;
            number = -number;
        }
        if (number < 0x4000000) {
            this.words = [
                number & 0x3ffffff
            ];
            this.length = 1;
        } else if (number < 0x10000000000000) {
            this.words = [
                number & 0x3ffffff,
                number / 0x4000000 & 0x3ffffff
            ];
            this.length = 2;
        } else {
            assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
            this.words = [
                number & 0x3ffffff,
                number / 0x4000000 & 0x3ffffff,
                1
            ];
            this.length = 3;
        }
        if (endian !== 'le') return;
        // Reverse the bytes
        this._initArray(this.toArray(), base, endian);
    };
    BN.prototype._initArray = function _initArray(number, base, endian) {
        // Perhaps a Uint8Array
        assert(typeof number.length === 'number');
        if (number.length <= 0) {
            this.words = [
                0
            ];
            this.length = 1;
            return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for(var i = 0; i < this.length; i++){
            this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === 'be') {
            for(i = number.length - 1, j = 0; i >= 0; i -= 3){
                w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
                this.words[j] |= w << off & 0x3ffffff;
                this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
                off += 24;
                if (off >= 26) {
                    off -= 26;
                    j++;
                }
            }
        } else if (endian === 'le') {
            for(i = 0, j = 0; i < number.length; i += 3){
                w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
                this.words[j] |= w << off & 0x3ffffff;
                this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
                off += 24;
                if (off >= 26) {
                    off -= 26;
                    j++;
                }
            }
        }
        return this._strip();
    };
    function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        // '0' - '9'
        if (c >= 48 && c <= 57) {
            return c - 48;
        // 'A' - 'F'
        } else if (c >= 65 && c <= 70) {
            return c - 55;
        // 'a' - 'f'
        } else if (c >= 97 && c <= 102) {
            return c - 87;
        } else {
            assert(false, 'Invalid character in ' + string);
        }
    }
    function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
            r |= parseHex4Bits(string, index - 1) << 4;
        }
        return r;
    }
    BN.prototype._parseHex = function _parseHex(number, start, endian) {
        // Create possibly bigger array to ensure that it fits the number
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for(var i = 0; i < this.length; i++){
            this.words[i] = 0;
        }
        // 24-bits chunks
        var off = 0;
        var j = 0;
        var w;
        if (endian === 'be') {
            for(i = number.length - 1; i >= start; i -= 2){
                w = parseHexByte(number, start, i) << off;
                this.words[j] |= w & 0x3ffffff;
                if (off >= 18) {
                    off -= 18;
                    j += 1;
                    this.words[j] |= w >>> 26;
                } else {
                    off += 8;
                }
            }
        } else {
            var parseLength = number.length - start;
            for(i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2){
                w = parseHexByte(number, start, i) << off;
                this.words[j] |= w & 0x3ffffff;
                if (off >= 18) {
                    off -= 18;
                    j += 1;
                    this.words[j] |= w >>> 26;
                } else {
                    off += 8;
                }
            }
        }
        this._strip();
    };
    function parseBase(str, start, end, mul) {
        var r = 0;
        var b = 0;
        var len = Math.min(str.length, end);
        for(var i = start; i < len; i++){
            var c = str.charCodeAt(i) - 48;
            r *= mul;
            // 'a'
            if (c >= 49) {
                b = c - 49 + 0xa;
            // 'A'
            } else if (c >= 17) {
                b = c - 17 + 0xa;
            // '0' - '9'
            } else {
                b = c;
            }
            assert(c >= 0 && b < mul, 'Invalid character');
            r += b;
        }
        return r;
    }
    BN.prototype._parseBase = function _parseBase(number, base, start) {
        // Initialize as zero
        this.words = [
            0
        ];
        this.length = 1;
        // Find length of limb in base
        for(var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base){
            limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for(var i = start; i < end; i += limbLen){
            word = parseBase(number, i, i + limbLen, base);
            this.imuln(limbPow);
            if (this.words[0] + word < 0x4000000) {
                this.words[0] += word;
            } else {
                this._iaddn(word);
            }
        }
        if (mod !== 0) {
            var pow = 1;
            word = parseBase(number, i, number.length, base);
            for(i = 0; i < mod; i++){
                pow *= base;
            }
            this.imuln(pow);
            if (this.words[0] + word < 0x4000000) {
                this.words[0] += word;
            } else {
                this._iaddn(word);
            }
        }
        this._strip();
    };
    BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for(var i = 0; i < this.length; i++){
            dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
    };
    function move(dest, src) {
        dest.words = src.words;
        dest.length = src.length;
        dest.negative = src.negative;
        dest.red = src.red;
    }
    BN.prototype._move = function _move(dest) {
        move(dest, this);
    };
    BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
    };
    BN.prototype._expand = function _expand(size) {
        while(this.length < size){
            this.words[this.length++] = 0;
        }
        return this;
    };
    // Remove leading `0` from `this`
    BN.prototype._strip = function strip() {
        while(this.length > 1 && this.words[this.length - 1] === 0){
            this.length--;
        }
        return this._normSign();
    };
    BN.prototype._normSign = function _normSign() {
        // -0 = 0
        if (this.length === 1 && this.words[0] === 0) {
            this.negative = 0;
        }
        return this;
    };
    // Check Symbol.for because not everywhere where Symbol defined
    // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
    if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
        try {
            BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;
        } catch (e) {
            BN.prototype.inspect = inspect;
        }
    } else {
        BN.prototype.inspect = inspect;
    }
    function inspect() {
        return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
    }
    /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */ var zeros = [
        '',
        '0',
        '00',
        '000',
        '0000',
        '00000',
        '000000',
        '0000000',
        '00000000',
        '000000000',
        '0000000000',
        '00000000000',
        '000000000000',
        '0000000000000',
        '00000000000000',
        '000000000000000',
        '0000000000000000',
        '00000000000000000',
        '000000000000000000',
        '0000000000000000000',
        '00000000000000000000',
        '000000000000000000000',
        '0000000000000000000000',
        '00000000000000000000000',
        '000000000000000000000000',
        '0000000000000000000000000'
    ];
    var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
    ];
    var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        10000000,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64000000,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        24300000,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
    ];
    BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === 'hex') {
            out = '';
            var off = 0;
            var carry = 0;
            for(var i = 0; i < this.length; i++){
                var w = this.words[i];
                var word = ((w << off | carry) & 0xffffff).toString(16);
                carry = w >>> 24 - off & 0xffffff;
                off += 2;
                if (off >= 26) {
                    off -= 26;
                    i--;
                }
                if (carry !== 0 || i !== this.length - 1) {
                    out = zeros[6 - word.length] + word + out;
                } else {
                    out = word + out;
                }
            }
            if (carry !== 0) {
                out = carry.toString(16) + out;
            }
            while(out.length % padding !== 0){
                out = '0' + out;
            }
            if (this.negative !== 0) {
                out = '-' + out;
            }
            return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
            // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
            var groupSize = groupSizes[base];
            // var groupBase = Math.pow(base, groupSize);
            var groupBase = groupBases[base];
            out = '';
            var c = this.clone();
            c.negative = 0;
            while(!c.isZero()){
                var r = c.modrn(groupBase).toString(base);
                c = c.idivn(groupBase);
                if (!c.isZero()) {
                    out = zeros[groupSize - r.length] + r + out;
                } else {
                    out = r + out;
                }
            }
            if (this.isZero()) {
                out = '0' + out;
            }
            while(out.length % padding !== 0){
                out = '0' + out;
            }
            if (this.negative !== 0) {
                out = '-' + out;
            }
            return out;
        }
        assert(false, 'Base should be between 2 and 36');
    };
    BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
            ret += this.words[1] * 0x4000000;
        } else if (this.length === 3 && this.words[2] === 0x01) {
            // NOTE: at this stage it is known that the top bit is set
            ret += 0x10000000000000 + this.words[1] * 0x4000000;
        } else if (this.length > 2) {
            assert(false, 'Number can only safely store up to 53 bits');
        }
        return this.negative !== 0 ? -ret : ret;
    };
    BN.prototype.toJSON = function toJSON() {
        return this.toString(16, 2);
    };
    if (Buffer) {
        BN.prototype.toBuffer = function toBuffer(endian, length) {
            return this.toArrayLike(Buffer, endian, length);
        };
    }
    BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
    };
    var allocate = function allocate(ArrayType, size) {
        if (ArrayType.allocUnsafe) {
            return ArrayType.allocUnsafe(size);
        }
        return new ArrayType(size);
    };
    BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        this._strip();
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, 'byte array longer than desired length');
        assert(reqLength > 0, 'Requested array length <= 0');
        var res = allocate(ArrayType, reqLength);
        var postfix = endian === 'le' ? 'LE' : 'BE';
        this['_toArrayLike' + postfix](res, byteLength);
        return res;
    };
    BN.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {
        var position = 0;
        var carry = 0;
        for(var i = 0, shift = 0; i < this.length; i++){
            var word = this.words[i] << shift | carry;
            res[position++] = word & 0xff;
            if (position < res.length) {
                res[position++] = word >> 8 & 0xff;
            }
            if (position < res.length) {
                res[position++] = word >> 16 & 0xff;
            }
            if (shift === 6) {
                if (position < res.length) {
                    res[position++] = word >> 24 & 0xff;
                }
                carry = 0;
                shift = 0;
            } else {
                carry = word >>> 24;
                shift += 2;
            }
        }
        if (position < res.length) {
            res[position++] = carry;
            while(position < res.length){
                res[position++] = 0;
            }
        }
    };
    BN.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {
        var position = res.length - 1;
        var carry = 0;
        for(var i = 0, shift = 0; i < this.length; i++){
            var word = this.words[i] << shift | carry;
            res[position--] = word & 0xff;
            if (position >= 0) {
                res[position--] = word >> 8 & 0xff;
            }
            if (position >= 0) {
                res[position--] = word >> 16 & 0xff;
            }
            if (shift === 6) {
                if (position >= 0) {
                    res[position--] = word >> 24 & 0xff;
                }
                carry = 0;
                shift = 0;
            } else {
                carry = word >>> 24;
                shift += 2;
            }
        }
        if (position >= 0) {
            res[position--] = carry;
            while(position >= 0){
                res[position--] = 0;
            }
        }
    };
    if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
            return 32 - Math.clz32(w);
        };
    } else {
        BN.prototype._countBits = function _countBits(w) {
            var t = w;
            var r = 0;
            if (t >= 0x1000) {
                r += 13;
                t >>>= 13;
            }
            if (t >= 0x40) {
                r += 7;
                t >>>= 7;
            }
            if (t >= 0x8) {
                r += 4;
                t >>>= 4;
            }
            if (t >= 0x02) {
                r += 2;
                t >>>= 2;
            }
            return r + t;
        };
    }
    BN.prototype._zeroBits = function _zeroBits(w) {
        // Short-cut
        if (w === 0) return 26;
        var t = w;
        var r = 0;
        if ((t & 0x1fff) === 0) {
            r += 13;
            t >>>= 13;
        }
        if ((t & 0x7f) === 0) {
            r += 7;
            t >>>= 7;
        }
        if ((t & 0xf) === 0) {
            r += 4;
            t >>>= 4;
        }
        if ((t & 0x3) === 0) {
            r += 2;
            t >>>= 2;
        }
        if ((t & 0x1) === 0) {
            r++;
        }
        return r;
    };
    // Return number of used bits in a BN
    BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
        var w = new Array(num.bitLength());
        for(var bit = 0; bit < w.length; bit++){
            var off = bit / 26 | 0;
            var wbit = bit % 26;
            w[bit] = num.words[off] >>> wbit & 0x01;
        }
        return w;
    }
    // Number of trailing zero bits
    BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r = 0;
        for(var i = 0; i < this.length; i++){
            var b = this._zeroBits(this.words[i]);
            r += b;
            if (b !== 26) break;
        }
        return r;
    };
    BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
    };
    BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
            return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
    };
    BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
            return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
    };
    BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
    };
    // Return negative clone of `this`
    BN.prototype.neg = function neg() {
        return this.clone().ineg();
    };
    BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
            this.negative ^= 1;
        }
        return this;
    };
    // Or `num` with `this` in-place
    BN.prototype.iuor = function iuor(num) {
        while(this.length < num.length){
            this.words[this.length++] = 0;
        }
        for(var i = 0; i < num.length; i++){
            this.words[i] = this.words[i] | num.words[i];
        }
        return this._strip();
    };
    BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
    };
    // Or `num` with `this`
    BN.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
    };
    BN.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
    };
    // And `num` with `this` in-place
    BN.prototype.iuand = function iuand(num) {
        // b = min-length(num, this)
        var b;
        if (this.length > num.length) {
            b = num;
        } else {
            b = this;
        }
        for(var i = 0; i < b.length; i++){
            this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this._strip();
    };
    BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
    };
    // And `num` with `this`
    BN.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
    };
    BN.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
    };
    // Xor `num` with `this` in-place
    BN.prototype.iuxor = function iuxor(num) {
        // a.length > b.length
        var a;
        var b;
        if (this.length > num.length) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        for(var i = 0; i < b.length; i++){
            this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
            for(; i < a.length; i++){
                this.words[i] = a.words[i];
            }
        }
        this.length = a.length;
        return this._strip();
    };
    BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
    };
    // Xor `num` with `this`
    BN.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
    };
    BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
    };
    // Not ``this`` with ``width`` bitwidth
    BN.prototype.inotn = function inotn(width) {
        assert(typeof width === 'number' && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        // Extend the buffer with leading zeroes
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
            bytesNeeded--;
        }
        // Handle complete words
        for(var i = 0; i < bytesNeeded; i++){
            this.words[i] = ~this.words[i] & 0x3ffffff;
        }
        // Handle the residue
        if (bitsLeft > 0) {
            this.words[i] = ~this.words[i] & 0x3ffffff >> 26 - bitsLeft;
        }
        // And remove leading zeroes
        return this._strip();
    };
    BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
    };
    // Set `bit` of `this`
    BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === 'number' && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
            this.words[off] = this.words[off] | 1 << wbit;
        } else {
            this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this._strip();
    };
    // Add `num` to `this` in-place
    BN.prototype.iadd = function iadd(num) {
        var r;
        // negative + positive
        if (this.negative !== 0 && num.negative === 0) {
            this.negative = 0;
            r = this.isub(num);
            this.negative ^= 1;
            return this._normSign();
        // positive + negative
        } else if (this.negative === 0 && num.negative !== 0) {
            num.negative = 0;
            r = this.isub(num);
            num.negative = 1;
            return r._normSign();
        }
        // a.length > b.length
        var a, b;
        if (this.length > num.length) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        var carry = 0;
        for(var i = 0; i < b.length; i++){
            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
            this.words[i] = r & 0x3ffffff;
            carry = r >>> 26;
        }
        for(; carry !== 0 && i < a.length; i++){
            r = (a.words[i] | 0) + carry;
            this.words[i] = r & 0x3ffffff;
            carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
            this.words[this.length] = carry;
            this.length++;
        // Copy the rest of the words
        } else if (a !== this) {
            for(; i < a.length; i++){
                this.words[i] = a.words[i];
            }
        }
        return this;
    };
    // Add `num` to `this`
    BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
            num.negative = 0;
            res = this.sub(num);
            num.negative ^= 1;
            return res;
        } else if (num.negative === 0 && this.negative !== 0) {
            this.negative = 0;
            res = num.sub(this);
            this.negative = 1;
            return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
    };
    // Subtract `num` from `this` in-place
    BN.prototype.isub = function isub(num) {
        // this - (-num) = this + num
        if (num.negative !== 0) {
            num.negative = 0;
            var r = this.iadd(num);
            num.negative = 1;
            return r._normSign();
        // -this - num = -(this + num)
        } else if (this.negative !== 0) {
            this.negative = 0;
            this.iadd(num);
            this.negative = 1;
            return this._normSign();
        }
        // At this point both numbers are positive
        var cmp = this.cmp(num);
        // Optimization - zeroify
        if (cmp === 0) {
            this.negative = 0;
            this.length = 1;
            this.words[0] = 0;
            return this;
        }
        // a > b
        var a, b;
        if (cmp > 0) {
            a = this;
            b = num;
        } else {
            a = num;
            b = this;
        }
        var carry = 0;
        for(var i = 0; i < b.length; i++){
            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 0x3ffffff;
        }
        for(; carry !== 0 && i < a.length; i++){
            r = (a.words[i] | 0) + carry;
            carry = r >> 26;
            this.words[i] = r & 0x3ffffff;
        }
        // Copy rest of the words
        if (carry === 0 && i < a.length && a !== this) {
            for(; i < a.length; i++){
                this.words[i] = a.words[i];
            }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
            this.negative = 1;
        }
        return this._strip();
    };
    // Subtract `num` from `this`
    BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
    };
    function smallMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        var len = self.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        // Peel one iteration (compiler can't do it, because of code complexity)
        var a = self.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 0x3ffffff;
        var carry = r / 0x4000000 | 0;
        out.words[0] = lo;
        for(var k = 1; k < len; k++){
            // Sum all words with the same `i + j = k` and accumulate `ncarry`,
            // note that ncarry could be >= 0x3ffffff
            var ncarry = carry >>> 26;
            var rword = carry & 0x3ffffff;
            var maxJ = Math.min(k, num.length - 1);
            for(var j = Math.max(0, k - self.length + 1); j <= maxJ; j++){
                var i = k - j | 0;
                a = self.words[i] | 0;
                b = num.words[j] | 0;
                r = a * b + rword;
                ncarry += r / 0x4000000 | 0;
                rword = r & 0x3ffffff;
            }
            out.words[k] = rword | 0;
            carry = ncarry | 0;
        }
        if (carry !== 0) {
            out.words[k] = carry | 0;
        } else {
            out.length--;
        }
        return out._strip();
    }
    // TODO(indutny): it may be reasonable to omit it for users who don't need
    // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
    // multiplication (like elliptic secp256k1).
    var comb10MulTo = function comb10MulTo(self, num, out) {
        var a = self.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 0x1fff;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 0x1fff;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 0x1fff;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 0x1fff;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 0x1fff;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 0x1fff;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 0x1fff;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 0x1fff;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 0x1fff;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 0x1fff;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 0x1fff;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 0x1fff;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 0x1fff;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 0x1fff;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 0x1fff;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 0x1fff;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 0x1fff;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 0x1fff;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 0x1fff;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 0x1fff;
        var bh9 = b9 >>> 13;
        out.negative = self.negative ^ num.negative;
        out.length = 19;
        /* k = 0 */ lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 0x3ffffff;
        /* k = 1 */ lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 0x3ffffff;
        /* k = 2 */ lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 0x3ffffff;
        /* k = 3 */ lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 0x3ffffff;
        /* k = 4 */ lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 0x3ffffff;
        /* k = 5 */ lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 0x3ffffff;
        /* k = 6 */ lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 0x3ffffff;
        /* k = 7 */ lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 0x3ffffff;
        /* k = 8 */ lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 0x3ffffff;
        /* k = 9 */ lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 0x3ffffff;
        /* k = 10 */ lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 0x3ffffff;
        /* k = 11 */ lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 0x3ffffff;
        /* k = 12 */ lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 0x3ffffff;
        /* k = 13 */ lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 0x3ffffff;
        /* k = 14 */ lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 0x3ffffff;
        /* k = 15 */ lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 0x3ffffff;
        /* k = 16 */ lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 0x3ffffff;
        /* k = 17 */ lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 0x3ffffff;
        /* k = 18 */ lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 0x3ffffff;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
            o[19] = c;
            out.length++;
        }
        return out;
    };
    // Polyfill comb
    if (!Math.imul) {
        comb10MulTo = smallMulTo;
    }
    function bigMulTo(self, num, out) {
        out.negative = num.negative ^ self.negative;
        out.length = self.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for(var k = 0; k < out.length - 1; k++){
            // Sum all words with the same `i + j = k` and accumulate `ncarry`,
            // note that ncarry could be >= 0x3ffffff
            var ncarry = hncarry;
            hncarry = 0;
            var rword = carry & 0x3ffffff;
            var maxJ = Math.min(k, num.length - 1);
            for(var j = Math.max(0, k - self.length + 1); j <= maxJ; j++){
                var i = k - j;
                var a = self.words[i] | 0;
                var b = num.words[j] | 0;
                var r = a * b;
                var lo = r & 0x3ffffff;
                ncarry = ncarry + (r / 0x4000000 | 0) | 0;
                lo = lo + rword | 0;
                rword = lo & 0x3ffffff;
                ncarry = ncarry + (lo >>> 26) | 0;
                hncarry += ncarry >>> 26;
                ncarry &= 0x3ffffff;
            }
            out.words[k] = rword;
            carry = ncarry;
            ncarry = hncarry;
        }
        if (carry !== 0) {
            out.words[k] = carry;
        } else {
            out.length--;
        }
        return out._strip();
    }
    function jumboMulTo(self, num, out) {
        // Temporary disable, see https://github.com/indutny/bn.js/issues/211
        // var fftm = new FFTM();
        // return fftm.mulp(self, num, out);
        return bigMulTo(self, num, out);
    }
    BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
            res = comb10MulTo(this, num, out);
        } else if (len < 63) {
            res = smallMulTo(this, num, out);
        } else if (len < 1024) {
            res = bigMulTo(this, num, out);
        } else {
            res = jumboMulTo(this, num, out);
        }
        return res;
    };
    // Cooley-Tukey algorithm for FFT
    // slightly revisited to rely on looping instead of recursion
    function FFTM(x, y) {
        this.x = x;
        this.y = y;
    }
    FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for(var i = 0; i < N; i++){
            t[i] = this.revBin(i, l, N);
        }
        return t;
    };
    // Returns binary-reversed representation of `x`
    FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1) return x;
        var rb = 0;
        for(var i = 0; i < l; i++){
            rb |= (x & 1) << l - i - 1;
            x >>= 1;
        }
        return rb;
    };
    // Performs "tweedling" phase, therefore 'emulating'
    // behaviour of the recursive algorithm
    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for(var i = 0; i < N; i++){
            rtws[i] = rws[rbt[i]];
            itws[i] = iws[rbt[i]];
        }
    };
    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for(var s = 1; s < N; s <<= 1){
            var l = s << 1;
            var rtwdf = Math.cos(2 * Math.PI / l);
            var itwdf = Math.sin(2 * Math.PI / l);
            for(var p = 0; p < N; p += l){
                var rtwdf_ = rtwdf;
                var itwdf_ = itwdf;
                for(var j = 0; j < s; j++){
                    var re = rtws[p + j];
                    var ie = itws[p + j];
                    var ro = rtws[p + j + s];
                    var io = itws[p + j + s];
                    var rx = rtwdf_ * ro - itwdf_ * io;
                    io = rtwdf_ * io + itwdf_ * ro;
                    ro = rx;
                    rtws[p + j] = re + ro;
                    itws[p + j] = ie + io;
                    rtws[p + j + s] = re - ro;
                    itws[p + j + s] = ie - io;
                    /* jshint maxdepth : false */ if (j !== l) {
                        rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                        itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                        rtwdf_ = rx;
                    }
                }
            }
        }
    };
    FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for(N = N / 2 | 0; N; N = N >>> 1){
            i++;
        }
        return 1 << i + 1 + odd;
    };
    FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1) return;
        for(var i = 0; i < N / 2; i++){
            var t = rws[i];
            rws[i] = rws[N - i - 1];
            rws[N - i - 1] = t;
            t = iws[i];
            iws[i] = -iws[N - i - 1];
            iws[N - i - 1] = -t;
        }
    };
    FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for(var i = 0; i < N / 2; i++){
            var w = Math.round(ws[2 * i + 1] / N) * 0x2000 + Math.round(ws[2 * i] / N) + carry;
            ws[i] = w & 0x3ffffff;
            if (w < 0x4000000) {
                carry = 0;
            } else {
                carry = w / 0x4000000 | 0;
            }
        }
        return ws;
    };
    FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for(var i = 0; i < len; i++){
            carry = carry + (ws[i] | 0);
            rws[2 * i] = carry & 0x1fff;
            carry = carry >>> 13;
            rws[2 * i + 1] = carry & 0x1fff;
            carry = carry >>> 13;
        }
        // Pad with zeroes
        for(i = 2 * len; i < N; ++i){
            rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~0x1fff) === 0);
    };
    FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for(var i = 0; i < N; i++){
            ph[i] = 0;
        }
        return ph;
    };
    FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for(var i = 0; i < N; i++){
            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
            rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out._strip();
    };
    // Multiply `this` by `num`
    BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
    };
    // Multiply employing FFT
    BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
    };
    // In-place Multiplication
    BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
    };
    BN.prototype.imuln = function imuln(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(typeof num === 'number');
        assert(num < 0x4000000);
        // Carry
        var carry = 0;
        for(var i = 0; i < this.length; i++){
            var w = (this.words[i] | 0) * num;
            var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
            carry >>= 26;
            carry += w / 0x4000000 | 0;
            // NOTE: lo is 27bit maximum
            carry += lo >>> 26;
            this.words[i] = lo & 0x3ffffff;
        }
        if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
        }
        this.length = num === 0 ? 1 : this.length;
        return isNegNum ? this.ineg() : this;
    };
    BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
    };
    // `this` * `this`
    BN.prototype.sqr = function sqr() {
        return this.mul(this);
    };
    // `this` * `this` in-place
    BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
    };
    // Math.pow(`this`, `num`)
    BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0) return new BN(1);
        // Skip leading zeroes
        var res = this;
        for(var i = 0; i < w.length; i++, res = res.sqr()){
            if (w[i] !== 0) break;
        }
        if (++i < w.length) {
            for(var q = res.sqr(); i < w.length; i++, q = q.sqr()){
                if (w[i] === 0) continue;
                res = res.mul(q);
            }
        }
        return res;
    };
    // Shift-left in-place
    BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === 'number' && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 0x3ffffff >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
            var carry = 0;
            for(i = 0; i < this.length; i++){
                var newCarry = this.words[i] & carryMask;
                var c = (this.words[i] | 0) - newCarry << r;
                this.words[i] = c | carry;
                carry = newCarry >>> 26 - r;
            }
            if (carry) {
                this.words[i] = carry;
                this.length++;
            }
        }
        if (s !== 0) {
            for(i = this.length - 1; i >= 0; i--){
                this.words[i + s] = this.words[i];
            }
            for(i = 0; i < s; i++){
                this.words[i] = 0;
            }
            this.length += s;
        }
        return this._strip();
    };
    BN.prototype.ishln = function ishln(bits) {
        // TODO(indutny): implement me
        assert(this.negative === 0);
        return this.iushln(bits);
    };
    // Shift-right in-place
    // NOTE: `hint` is a lowest bit before trailing zeroes
    // NOTE: if `extended` is present - it will be filled with destroyed bits
    BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === 'number' && bits >= 0);
        var h;
        if (hint) {
            h = (hint - hint % 26) / 26;
        } else {
            h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        // Extended mode, copy masked part
        if (maskedWords) {
            for(var i = 0; i < s; i++){
                maskedWords.words[i] = this.words[i];
            }
            maskedWords.length = s;
        }
        if (s === 0) {
        // No-op, we should not move anything at all
        } else if (this.length > s) {
            this.length -= s;
            for(i = 0; i < this.length; i++){
                this.words[i] = this.words[i + s];
            }
        } else {
            this.words[0] = 0;
            this.length = 1;
        }
        var carry = 0;
        for(i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--){
            var word = this.words[i] | 0;
            this.words[i] = carry << 26 - r | word >>> r;
            carry = word & mask;
        }
        // Push carried bits as a mask
        if (maskedWords && carry !== 0) {
            maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
            this.words[0] = 0;
            this.length = 1;
        }
        return this._strip();
    };
    BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        // TODO(indutny): implement me
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
    };
    // Shift-left
    BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
    };
    BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
    };
    // Shift-right
    BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
    };
    BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
    };
    // Test if n bit is set
    BN.prototype.testn = function testn(bit) {
        assert(typeof bit === 'number' && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        // Fast case: bit is much higher than all existing words
        if (this.length <= s) return false;
        // Check bit and return
        var w = this.words[s];
        return !!(w & q);
    };
    // Return only lowers bits of number (in-place)
    BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === 'number' && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, 'imaskn works only with positive numbers');
        if (this.length <= s) {
            return this;
        }
        if (r !== 0) {
            s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
            var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
            this.words[this.length - 1] &= mask;
        }
        return this._strip();
    };
    // Return only lowers bits of number
    BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
    };
    // Add plain number `num` to `this`
    BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === 'number');
        assert(num < 0x4000000);
        if (num < 0) return this.isubn(-num);
        // Possible sign change
        if (this.negative !== 0) {
            if (this.length === 1 && (this.words[0] | 0) <= num) {
                this.words[0] = num - (this.words[0] | 0);
                this.negative = 0;
                return this;
            }
            this.negative = 0;
            this.isubn(num);
            this.negative = 1;
            return this;
        }
        // Add without checks
        return this._iaddn(num);
    };
    BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        // Carry
        for(var i = 0; i < this.length && this.words[i] >= 0x4000000; i++){
            this.words[i] -= 0x4000000;
            if (i === this.length - 1) {
                this.words[i + 1] = 1;
            } else {
                this.words[i + 1]++;
            }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
    };
    // Subtract plain number `num` from `this`
    BN.prototype.isubn = function isubn(num) {
        assert(typeof num === 'number');
        assert(num < 0x4000000);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
            this.negative = 0;
            this.iaddn(num);
            this.negative = 1;
            return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
            this.words[0] = -this.words[0];
            this.negative = 1;
        } else {
            // Carry
            for(var i = 0; i < this.length && this.words[i] < 0; i++){
                this.words[i] += 0x4000000;
                this.words[i + 1] -= 1;
            }
        }
        return this._strip();
    };
    BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
    };
    BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
    };
    BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
    };
    BN.prototype.abs = function abs() {
        return this.clone().iabs();
    };
    BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for(i = 0; i < num.length; i++){
            w = (this.words[i + shift] | 0) + carry;
            var right = (num.words[i] | 0) * mul;
            w -= right & 0x3ffffff;
            carry = (w >> 26) - (right / 0x4000000 | 0);
            this.words[i + shift] = w & 0x3ffffff;
        }
        for(; i < this.length - shift; i++){
            w = (this.words[i + shift] | 0) + carry;
            carry = w >> 26;
            this.words[i + shift] = w & 0x3ffffff;
        }
        if (carry === 0) return this._strip();
        // Subtraction overflow
        assert(carry === -1);
        carry = 0;
        for(i = 0; i < this.length; i++){
            w = -(this.words[i] | 0) + carry;
            carry = w >> 26;
            this.words[i] = w & 0x3ffffff;
        }
        this.negative = 1;
        return this._strip();
    };
    BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        // Normalize
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
            b = b.ushln(shift);
            a.iushln(shift);
            bhi = b.words[b.length - 1] | 0;
        }
        // Initialize quotient
        var m = a.length - b.length;
        var q;
        if (mode !== 'mod') {
            q = new BN(null);
            q.length = m + 1;
            q.words = new Array(q.length);
            for(var i = 0; i < q.length; i++){
                q.words[i] = 0;
            }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
            a = diff;
            if (q) {
                q.words[m] = 1;
            }
        }
        for(var j = m - 1; j >= 0; j--){
            var qj = (a.words[b.length + j] | 0) * 0x4000000 + (a.words[b.length + j - 1] | 0);
            // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
            // (0x7ffffff)
            qj = Math.min(qj / bhi | 0, 0x3ffffff);
            a._ishlnsubmul(b, qj, j);
            while(a.negative !== 0){
                qj--;
                a.negative = 0;
                a._ishlnsubmul(b, 1, j);
                if (!a.isZero()) {
                    a.negative ^= 1;
                }
            }
            if (q) {
                q.words[j] = qj;
            }
        }
        if (q) {
            q._strip();
        }
        a._strip();
        // Denormalize
        if (mode !== 'div' && shift !== 0) {
            a.iushrn(shift);
        }
        return {
            div: q || null,
            mod: a
        };
    };
    // NOTE: 1) `mode` can be set to `mod` to request mod only,
    //       to `div` to request div only, or be absent to
    //       request both div & mod
    //       2) `positive` is true if unsigned mod is requested
    BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
            return {
                div: new BN(0),
                mod: new BN(0)
            };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
            res = this.neg().divmod(num, mode);
            if (mode !== 'mod') {
                div = res.div.neg();
            }
            if (mode !== 'div') {
                mod = res.mod.neg();
                if (positive && mod.negative !== 0) {
                    mod.iadd(num);
                }
            }
            return {
                div: div,
                mod: mod
            };
        }
        if (this.negative === 0 && num.negative !== 0) {
            res = this.divmod(num.neg(), mode);
            if (mode !== 'mod') {
                div = res.div.neg();
            }
            return {
                div: div,
                mod: res.mod
            };
        }
        if ((this.negative & num.negative) !== 0) {
            res = this.neg().divmod(num.neg(), mode);
            if (mode !== 'div') {
                mod = res.mod.neg();
                if (positive && mod.negative !== 0) {
                    mod.isub(num);
                }
            }
            return {
                div: res.div,
                mod: mod
            };
        }
        // Both numbers are positive at this point
        // Strip both numbers to approximate shift value
        if (num.length > this.length || this.cmp(num) < 0) {
            return {
                div: new BN(0),
                mod: this
            };
        }
        // Very short reduction
        if (num.length === 1) {
            if (mode === 'div') {
                return {
                    div: this.divn(num.words[0]),
                    mod: null
                };
            }
            if (mode === 'mod') {
                return {
                    div: null,
                    mod: new BN(this.modrn(num.words[0]))
                };
            }
            return {
                div: this.divn(num.words[0]),
                mod: new BN(this.modrn(num.words[0]))
            };
        }
        return this._wordDiv(num, mode);
    };
    // Find `this` / `num`
    BN.prototype.div = function div(num) {
        return this.divmod(num, 'div', false).div;
    };
    // Find `this` % `num`
    BN.prototype.mod = function mod(num) {
        return this.divmod(num, 'mod', false).mod;
    };
    BN.prototype.umod = function umod(num) {
        return this.divmod(num, 'mod', true).mod;
    };
    // Find Round(`this` / `num`)
    BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        // Fast case - exact division
        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        // Round down
        if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;
        // Round up
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN.prototype.modrn = function modrn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(num <= 0x3ffffff);
        var p = (1 << 26) % num;
        var acc = 0;
        for(var i = this.length - 1; i >= 0; i--){
            acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return isNegNum ? -acc : acc;
    };
    // WARNING: DEPRECATED
    BN.prototype.modn = function modn(num) {
        return this.modrn(num);
    };
    // In-place division by number
    BN.prototype.idivn = function idivn(num) {
        var isNegNum = num < 0;
        if (isNegNum) num = -num;
        assert(num <= 0x3ffffff);
        var carry = 0;
        for(var i = this.length - 1; i >= 0; i--){
            var w = (this.words[i] | 0) + carry * 0x4000000;
            this.words[i] = w / num | 0;
            carry = w % num;
        }
        this._strip();
        return isNegNum ? this.ineg() : this;
    };
    BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
    };
    BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
            x = x.umod(p);
        } else {
            x = x.clone();
        }
        // A * x + B * y = x
        var A = new BN(1);
        var B = new BN(0);
        // C * x + D * y = y
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while(x.isEven() && y.isEven()){
            x.iushrn(1);
            y.iushrn(1);
            ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while(!x.isZero()){
            for(var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
            if (i > 0) {
                x.iushrn(i);
                while(i-- > 0){
                    if (A.isOdd() || B.isOdd()) {
                        A.iadd(yp);
                        B.isub(xp);
                    }
                    A.iushrn(1);
                    B.iushrn(1);
                }
            }
            for(var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
            if (j > 0) {
                y.iushrn(j);
                while(j-- > 0){
                    if (C.isOdd() || D.isOdd()) {
                        C.iadd(yp);
                        D.isub(xp);
                    }
                    C.iushrn(1);
                    D.iushrn(1);
                }
            }
            if (x.cmp(y) >= 0) {
                x.isub(y);
                A.isub(C);
                B.isub(D);
            } else {
                y.isub(x);
                C.isub(A);
                D.isub(B);
            }
        }
        return {
            a: C,
            b: D,
            gcd: y.iushln(g)
        };
    };
    // This is reduced incarnation of the binary EEA
    // above, designated to invert members of the
    // _prime_ fields F(p) at a maximal speed
    BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
            a = a.umod(p);
        } else {
            a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while(a.cmpn(1) > 0 && b.cmpn(1) > 0){
            for(var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
            if (i > 0) {
                a.iushrn(i);
                while(i-- > 0){
                    if (x1.isOdd()) {
                        x1.iadd(delta);
                    }
                    x1.iushrn(1);
                }
            }
            for(var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
            if (j > 0) {
                b.iushrn(j);
                while(j-- > 0){
                    if (x2.isOdd()) {
                        x2.iadd(delta);
                    }
                    x2.iushrn(1);
                }
            }
            if (a.cmp(b) >= 0) {
                a.isub(b);
                x1.isub(x2);
            } else {
                b.isub(a);
                x2.isub(x1);
            }
        }
        var res;
        if (a.cmpn(1) === 0) {
            res = x1;
        } else {
            res = x2;
        }
        if (res.cmpn(0) < 0) {
            res.iadd(p);
        }
        return res;
    };
    BN.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        // Remove common factor of two
        for(var shift = 0; a.isEven() && b.isEven(); shift++){
            a.iushrn(1);
            b.iushrn(1);
        }
        do {
            while(a.isEven()){
                a.iushrn(1);
            }
            while(b.isEven()){
                b.iushrn(1);
            }
            var r = a.cmp(b);
            if (r < 0) {
                // Swap `a` and `b` to make `a` always bigger than `b`
                var t = a;
                a = b;
                b = t;
            } else if (r === 0 || b.cmpn(1) === 0) {
                break;
            }
            a.isub(b);
        }while (true)
        return b.iushln(shift);
    };
    // Invert number in the field F(num)
    BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
    };
    BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
    };
    BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
    };
    // And first word and num
    BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
    };
    // Increment at the bit position in-line
    BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === 'number');
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        // Fast case: bit is much higher than all existing words
        if (this.length <= s) {
            this._expand(s + 1);
            this.words[s] |= q;
            return this;
        }
        // Add bit and propagate, if needed
        var carry = q;
        for(var i = s; carry !== 0 && i < this.length; i++){
            var w = this.words[i] | 0;
            w += carry;
            carry = w >>> 26;
            w &= 0x3ffffff;
            this.words[i] = w;
        }
        if (carry !== 0) {
            this.words[i] = carry;
            this.length++;
        }
        return this;
    };
    BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
    };
    BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this._strip();
        var res;
        if (this.length > 1) {
            res = 1;
        } else {
            if (negative) {
                num = -num;
            }
            assert(num <= 0x3ffffff, 'Number is too big');
            var w = this.words[0] | 0;
            res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
    };
    // Compare two numbers and return:
    // 1 - if `this` > `num`
    // 0 - if `this` == `num`
    // -1 - if `this` < `num`
    BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
    };
    // Unsigned comparison
    BN.prototype.ucmp = function ucmp(num) {
        // At this point both numbers have the same sign
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for(var i = this.length - 1; i >= 0; i--){
            var a = this.words[i] | 0;
            var b = num.words[i] | 0;
            if (a === b) continue;
            if (a < b) {
                res = -1;
            } else if (a > b) {
                res = 1;
            }
            break;
        }
        return res;
    };
    BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
    };
    BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
    };
    BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
    };
    BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
    };
    BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
    };
    BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
    };
    BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
    };
    BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
    };
    BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
    };
    BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
    };
    //
    // A reduce context, could be using montgomery or something better, depending
    // on the `m` itself.
    //
    BN.red = function red(num) {
        return new Red(num);
    };
    BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, 'Already a number in reduction context');
        assert(this.negative === 0, 'red works only with positives');
        return ctx.convertTo(this)._forceRed(ctx);
    };
    BN.prototype.fromRed = function fromRed() {
        assert(this.red, 'fromRed works only with numbers in reduction context');
        return this.red.convertFrom(this);
    };
    BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
    };
    BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, 'Already a number in reduction context');
        return this._forceRed(ctx);
    };
    BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, 'redAdd works only with red numbers');
        return this.red.add(this, num);
    };
    BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, 'redIAdd works only with red numbers');
        return this.red.iadd(this, num);
    };
    BN.prototype.redSub = function redSub(num) {
        assert(this.red, 'redSub works only with red numbers');
        return this.red.sub(this, num);
    };
    BN.prototype.redISub = function redISub(num) {
        assert(this.red, 'redISub works only with red numbers');
        return this.red.isub(this, num);
    };
    BN.prototype.redShl = function redShl(num) {
        assert(this.red, 'redShl works only with red numbers');
        return this.red.shl(this, num);
    };
    BN.prototype.redMul = function redMul(num) {
        assert(this.red, 'redMul works only with red numbers');
        this.red._verify2(this, num);
        return this.red.mul(this, num);
    };
    BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, 'redMul works only with red numbers');
        this.red._verify2(this, num);
        return this.red.imul(this, num);
    };
    BN.prototype.redSqr = function redSqr() {
        assert(this.red, 'redSqr works only with red numbers');
        this.red._verify1(this);
        return this.red.sqr(this);
    };
    BN.prototype.redISqr = function redISqr() {
        assert(this.red, 'redISqr works only with red numbers');
        this.red._verify1(this);
        return this.red.isqr(this);
    };
    // Square root over p
    BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, 'redSqrt works only with red numbers');
        this.red._verify1(this);
        return this.red.sqrt(this);
    };
    BN.prototype.redInvm = function redInvm() {
        assert(this.red, 'redInvm works only with red numbers');
        this.red._verify1(this);
        return this.red.invm(this);
    };
    // Return negative clone of `this` % `red modulo`
    BN.prototype.redNeg = function redNeg() {
        assert(this.red, 'redNeg works only with red numbers');
        this.red._verify1(this);
        return this.red.neg(this);
    };
    BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, 'redPow(normalNum)');
        this.red._verify1(this);
        return this.red.pow(this, num);
    };
    // Prime numbers with efficient reduction
    var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
    };
    // Pseudo-Mersenne prime
    function MPrime(name, p) {
        // P = 2 ^ N - K
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
        // Assumes that `num` is less than `P^2`
        // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
        var r = num;
        var rlen;
        do {
            this.split(r, this.tmp);
            r = this.imulK(r);
            r = r.iadd(this.tmp);
            rlen = r.bitLength();
        }while (rlen > this.n)
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
            r.words[0] = 0;
            r.length = 1;
        } else if (cmp > 0) {
            r.isub(this.p);
        } else {
            if (r.strip !== undefined) {
                // r is a BN v4 instance
                r.strip();
            } else {
                // r is a BN v5 instance
                r._strip();
            }
        }
        return r;
    };
    MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
    };
    function K256() {
        MPrime.call(this, 'k256', 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
    }
    inherits(K256, MPrime);
    K256.prototype.split = function split(input, output) {
        // 256 = 9 * 26 + 22
        var mask = 0x3fffff;
        var outLen = Math.min(input.length, 9);
        for(var i = 0; i < outLen; i++){
            output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
            input.words[0] = 0;
            input.length = 1;
            return;
        }
        // Shift by 9 limbs
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for(i = 10; i < input.length; i++){
            var next = input.words[i] | 0;
            input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
            prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
            input.length -= 10;
        } else {
            input.length -= 9;
        }
    };
    K256.prototype.imulK = function imulK(num) {
        // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
        var lo = 0;
        for(var i = 0; i < num.length; i++){
            var w = num.words[i] | 0;
            lo += w * 0x3d1;
            num.words[i] = lo & 0x3ffffff;
            lo = w * 0x40 + (lo / 0x4000000 | 0);
        }
        // Fast length reduction
        if (num.words[num.length - 1] === 0) {
            num.length--;
            if (num.words[num.length - 1] === 0) {
                num.length--;
            }
        }
        return num;
    };
    function P224() {
        MPrime.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
    }
    inherits(P224, MPrime);
    function P192() {
        MPrime.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
    }
    inherits(P192, MPrime);
    function P25519() {
        // 2 ^ 255 - 19
        MPrime.call(this, '25519', '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
    }
    inherits(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
        // K = 0x13
        var carry = 0;
        for(var i = 0; i < num.length; i++){
            var hi = (num.words[i] | 0) * 0x13 + carry;
            var lo = hi & 0x3ffffff;
            hi >>>= 26;
            num.words[i] = lo;
            carry = hi;
        }
        if (carry !== 0) {
            num.words[num.length++] = carry;
        }
        return num;
    };
    // Exported mostly for testing purposes, use plain name instead
    BN._prime = function prime(name) {
        // Cached version of prime
        if (primes[name]) return primes[name];
        var prime;
        if (name === 'k256') {
            prime = new K256();
        } else if (name === 'p224') {
            prime = new P224();
        } else if (name === 'p192') {
            prime = new P192();
        } else if (name === 'p25519') {
            prime = new P25519();
        } else {
            throw new Error('Unknown prime ' + name);
        }
        primes[name] = prime;
        return prime;
    };
    //
    // Base reduction engine
    //
    function Red(m) {
        if (typeof m === 'string') {
            var prime = BN._prime(m);
            this.m = prime.p;
            this.prime = prime;
        } else {
            assert(m.gtn(1), 'modulus must be greater than 1');
            this.m = m;
            this.prime = null;
        }
    }
    Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, 'red works only with positives');
        assert(a.red, 'red works only with red numbers');
    };
    Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, 'red works only with positives');
        assert(a.red && a.red === b.red, 'red works only with red numbers');
    };
    Red.prototype.imod = function imod(a) {
        if (this.prime) return this.prime.ireduce(a)._forceRed(this);
        move(a, a.umod(this.m)._forceRed(this));
        return a;
    };
    Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
            return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
    };
    Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
        }
        return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
            res.isub(this.m);
        }
        return res;
    };
    Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
            res.iadd(this.m);
        }
        return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
            res.iadd(this.m);
        }
        return res;
    };
    Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
    };
    Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
    };
    Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
    };
    Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
    };
    Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
    };
    Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero()) return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        // Fast case
        if (mod3 === 3) {
            var pow = this.m.add(new BN(1)).iushrn(2);
            return this.pow(a, pow);
        }
        // Tonelli-Shanks algorithm (Totally unoptimized and slow)
        //
        // Find Q and S, that Q * 2 ^ S = (P - 1)
        var q = this.m.subn(1);
        var s = 0;
        while(!q.isZero() && q.andln(1) === 0){
            s++;
            q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        // Find quadratic non-residue
        // NOTE: Max is such because of generalized Riemann hypothesis.
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while(this.pow(z, lpow).cmp(nOne) !== 0){
            z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while(t.cmp(one) !== 0){
            var tmp = t;
            for(var i = 0; tmp.cmp(one) !== 0; i++){
                tmp = tmp.redSqr();
            }
            assert(i < m);
            var b = this.pow(c, new BN(1).iushln(m - i - 1));
            r = r.redMul(b);
            c = b.redSqr();
            t = t.redMul(c);
            m = i;
        }
        return r;
    };
    Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
            inv.negative = 0;
            return this.imod(inv).redNeg();
        } else {
            return this.imod(inv);
        }
    };
    Red.prototype.pow = function pow(a, num) {
        if (num.isZero()) return new BN(1).toRed(this);
        if (num.cmpn(1) === 0) return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for(var i = 2; i < wnd.length; i++){
            wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
            start = 26;
        }
        for(i = num.length - 1; i >= 0; i--){
            var word = num.words[i];
            for(var j = start - 1; j >= 0; j--){
                var bit = word >> j & 1;
                if (res !== wnd[0]) {
                    res = this.sqr(res);
                }
                if (bit === 0 && current === 0) {
                    currentLen = 0;
                    continue;
                }
                current <<= 1;
                current |= bit;
                currentLen++;
                if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
                res = this.mul(res, wnd[current]);
                currentLen = 0;
                current = 0;
            }
            start = 26;
        }
        return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
    };
    //
    // Montgomery method engine
    //
    BN.mont = function mont(num) {
        return new Mont(num);
    };
    function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
            this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
    }
    inherits(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
    };
    Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
            a.words[0] = 0;
            a.length = 1;
            return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
        }
        return res._forceRed(this);
    };
    Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
            res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
            res = u.iadd(this.m);
        }
        return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a) {
        // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
    };
})(("TURBOPACK compile-time value", "object") === 'undefined' || module, /*TURBOPACK member replacement*/ __turbopack_context__.e);
}),
"[project]/node_modules/js-sha3/src/sha3.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */ /*jslint bitwise: true */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
(function() {
    'use strict';
    var INPUT_ERROR = 'input is invalid type';
    var FINALIZE_ERROR = 'finalize already called';
    var WINDOW = typeof window === 'object';
    var root = WINDOW ? window : {};
    if (root.JS_SHA3_NO_WINDOW) {
        WINDOW = false;
    }
    var WEB_WORKER = !WINDOW && typeof self === 'object';
    var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] === 'object' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].versions && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].versions.node;
    if (NODE_JS) {
        root = /*TURBOPACK member replacement*/ __turbopack_context__.g;
    } else if (WEB_WORKER) {
        root = self;
    }
    var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && ("TURBOPACK compile-time value", "object") === 'object' && module.exports;
    var AMD = typeof define === 'function' && define.amd;
    var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
    var HEX_CHARS = '0123456789abcdef'.split('');
    var SHAKE_PADDING = [
        31,
        7936,
        2031616,
        520093696
    ];
    var CSHAKE_PADDING = [
        4,
        1024,
        262144,
        67108864
    ];
    var KECCAK_PADDING = [
        1,
        256,
        65536,
        16777216
    ];
    var PADDING = [
        6,
        1536,
        393216,
        100663296
    ];
    var SHIFT = [
        0,
        8,
        16,
        24
    ];
    var RC = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
    ];
    var BITS = [
        224,
        256,
        384,
        512
    ];
    var SHAKE_BITS = [
        128,
        256
    ];
    var OUTPUT_TYPES = [
        'hex',
        'buffer',
        'arrayBuffer',
        'array',
        'digest'
    ];
    var CSHAKE_BYTEPAD = {
        '128': 168,
        '256': 136
    };
    if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
            return Object.prototype.toString.call(obj) === '[object Array]';
        };
    }
    if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
            return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
    }
    var createOutputMethod = function(bits, padding, outputType) {
        return function(message) {
            return new Keccak(bits, padding, bits).update(message)[outputType]();
        };
    };
    var createShakeOutputMethod = function(bits, padding, outputType) {
        return function(message, outputBits) {
            return new Keccak(bits, padding, outputBits).update(message)[outputType]();
        };
    };
    var createCshakeOutputMethod = function(bits, padding, outputType) {
        return function(message, outputBits, n, s) {
            return methods['cshake' + bits].update(message, outputBits, n, s)[outputType]();
        };
    };
    var createKmacOutputMethod = function(bits, padding, outputType) {
        return function(key, message, outputBits, s) {
            return methods['kmac' + bits].update(key, message, outputBits, s)[outputType]();
        };
    };
    var createOutputMethods = function(method, createMethod, bits, padding) {
        for(var i = 0; i < OUTPUT_TYPES.length; ++i){
            var type = OUTPUT_TYPES[i];
            method[type] = createMethod(bits, padding, type);
        }
        return method;
    };
    var createMethod = function(bits, padding) {
        var method = createOutputMethod(bits, padding, 'hex');
        method.create = function() {
            return new Keccak(bits, padding, bits);
        };
        method.update = function(message) {
            return method.create().update(message);
        };
        return createOutputMethods(method, createOutputMethod, bits, padding);
    };
    var createShakeMethod = function(bits, padding) {
        var method = createShakeOutputMethod(bits, padding, 'hex');
        method.create = function(outputBits) {
            return new Keccak(bits, padding, outputBits);
        };
        method.update = function(message, outputBits) {
            return method.create(outputBits).update(message);
        };
        return createOutputMethods(method, createShakeOutputMethod, bits, padding);
    };
    var createCshakeMethod = function(bits, padding) {
        var w = CSHAKE_BYTEPAD[bits];
        var method = createCshakeOutputMethod(bits, padding, 'hex');
        method.create = function(outputBits, n, s) {
            if (!n && !s) {
                return methods['shake' + bits].create(outputBits);
            } else {
                return new Keccak(bits, padding, outputBits).bytepad([
                    n,
                    s
                ], w);
            }
        };
        method.update = function(message, outputBits, n, s) {
            return method.create(outputBits, n, s).update(message);
        };
        return createOutputMethods(method, createCshakeOutputMethod, bits, padding);
    };
    var createKmacMethod = function(bits, padding) {
        var w = CSHAKE_BYTEPAD[bits];
        var method = createKmacOutputMethod(bits, padding, 'hex');
        method.create = function(key, outputBits, s) {
            return new Kmac(bits, padding, outputBits).bytepad([
                'KMAC',
                s
            ], w).bytepad([
                key
            ], w);
        };
        method.update = function(key, message, outputBits, s) {
            return method.create(key, outputBits, s).update(message);
        };
        return createOutputMethods(method, createKmacOutputMethod, bits, padding);
    };
    var algorithms = [
        {
            name: 'keccak',
            padding: KECCAK_PADDING,
            bits: BITS,
            createMethod: createMethod
        },
        {
            name: 'sha3',
            padding: PADDING,
            bits: BITS,
            createMethod: createMethod
        },
        {
            name: 'shake',
            padding: SHAKE_PADDING,
            bits: SHAKE_BITS,
            createMethod: createShakeMethod
        },
        {
            name: 'cshake',
            padding: CSHAKE_PADDING,
            bits: SHAKE_BITS,
            createMethod: createCshakeMethod
        },
        {
            name: 'kmac',
            padding: CSHAKE_PADDING,
            bits: SHAKE_BITS,
            createMethod: createKmacMethod
        }
    ];
    var methods = {}, methodNames = [];
    for(var i = 0; i < algorithms.length; ++i){
        var algorithm = algorithms[i];
        var bits = algorithm.bits;
        for(var j = 0; j < bits.length; ++j){
            var methodName = algorithm.name + '_' + bits[j];
            methodNames.push(methodName);
            methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
            if (algorithm.name !== 'sha3') {
                var newMethodName = algorithm.name + bits[j];
                methodNames.push(newMethodName);
                methods[newMethodName] = methods[methodName];
            }
        }
    }
    function Keccak(bits, padding, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding;
        this.outputBits = outputBits;
        this.reset = true;
        this.finalized = false;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;
        for(var i = 0; i < 50; ++i){
            this.s[i] = 0;
        }
    }
    Keccak.prototype.update = function(message) {
        if (this.finalized) {
            throw new Error(FINALIZE_ERROR);
        }
        var notString, type = typeof message;
        if (type !== 'string') {
            if (type === 'object') {
                if (message === null) {
                    throw new Error(INPUT_ERROR);
                } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
                    message = new Uint8Array(message);
                } else if (!Array.isArray(message)) {
                    if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                        throw new Error(INPUT_ERROR);
                    }
                }
            } else {
                throw new Error(INPUT_ERROR);
            }
            notString = true;
        }
        var blocks = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index = 0, s = this.s, i, code;
        while(index < length){
            if (this.reset) {
                this.reset = false;
                blocks[0] = this.block;
                for(i = 1; i < blockCount + 1; ++i){
                    blocks[i] = 0;
                }
            }
            if (notString) {
                for(i = this.start; index < length && i < byteCount; ++index){
                    blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
                }
            } else {
                for(i = this.start; index < length && i < byteCount; ++index){
                    code = message.charCodeAt(index);
                    if (code < 0x80) {
                        blocks[i >> 2] |= code << SHIFT[i++ & 3];
                    } else if (code < 0x800) {
                        blocks[i >> 2] |= (0xc0 | code >> 6) << SHIFT[i++ & 3];
                        blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
                    } else if (code < 0xd800 || code >= 0xe000) {
                        blocks[i >> 2] |= (0xe0 | code >> 12) << SHIFT[i++ & 3];
                        blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];
                        blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
                    } else {
                        code = 0x10000 + ((code & 0x3ff) << 10 | message.charCodeAt(++index) & 0x3ff);
                        blocks[i >> 2] |= (0xf0 | code >> 18) << SHIFT[i++ & 3];
                        blocks[i >> 2] |= (0x80 | code >> 12 & 0x3f) << SHIFT[i++ & 3];
                        blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];
                        blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
                    }
                }
            }
            this.lastByteIndex = i;
            if (i >= byteCount) {
                this.start = i - byteCount;
                this.block = blocks[blockCount];
                for(i = 0; i < blockCount; ++i){
                    s[i] ^= blocks[i];
                }
                f(s);
                this.reset = true;
            } else {
                this.start = i;
            }
        }
        return this;
    };
    Keccak.prototype.encode = function(x, right) {
        var o = x & 255, n = 1;
        var bytes = [
            o
        ];
        x = x >> 8;
        o = x & 255;
        while(o > 0){
            bytes.unshift(o);
            x = x >> 8;
            o = x & 255;
            ++n;
        }
        if (right) {
            bytes.push(n);
        } else {
            bytes.unshift(n);
        }
        this.update(bytes);
        return bytes.length;
    };
    Keccak.prototype.encodeString = function(str) {
        var notString, type = typeof str;
        if (type !== 'string') {
            if (type === 'object') {
                if (str === null) {
                    throw new Error(INPUT_ERROR);
                } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
                    str = new Uint8Array(str);
                } else if (!Array.isArray(str)) {
                    if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
                        throw new Error(INPUT_ERROR);
                    }
                }
            } else {
                throw new Error(INPUT_ERROR);
            }
            notString = true;
        }
        var bytes = 0, length = str.length;
        if (notString) {
            bytes = length;
        } else {
            for(var i = 0; i < str.length; ++i){
                var code = str.charCodeAt(i);
                if (code < 0x80) {
                    bytes += 1;
                } else if (code < 0x800) {
                    bytes += 2;
                } else if (code < 0xd800 || code >= 0xe000) {
                    bytes += 3;
                } else {
                    code = 0x10000 + ((code & 0x3ff) << 10 | str.charCodeAt(++i) & 0x3ff);
                    bytes += 4;
                }
            }
        }
        bytes += this.encode(bytes * 8);
        this.update(str);
        return bytes;
    };
    Keccak.prototype.bytepad = function(strs, w) {
        var bytes = this.encode(w);
        for(var i = 0; i < strs.length; ++i){
            bytes += this.encodeString(strs[i]);
        }
        var paddingBytes = w - bytes % w;
        var zeros = [];
        zeros.length = paddingBytes;
        this.update(zeros);
        return this;
    };
    Keccak.prototype.finalize = function() {
        if (this.finalized) {
            return;
        }
        this.finalized = true;
        var blocks = this.blocks, i = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
        blocks[i >> 2] |= this.padding[i & 3];
        if (this.lastByteIndex === this.byteCount) {
            blocks[0] = blocks[blockCount];
            for(i = 1; i < blockCount + 1; ++i){
                blocks[i] = 0;
            }
        }
        blocks[blockCount - 1] |= 0x80000000;
        for(i = 0; i < blockCount; ++i){
            s[i] ^= blocks[i];
        }
        f(s);
    };
    Keccak.prototype.toString = Keccak.prototype.hex = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i = 0, j = 0;
        var hex = '', block;
        while(j < outputBlocks){
            for(i = 0; i < blockCount && j < outputBlocks; ++i, ++j){
                block = s[i];
                hex += HEX_CHARS[block >> 4 & 0x0F] + HEX_CHARS[block & 0x0F] + HEX_CHARS[block >> 12 & 0x0F] + HEX_CHARS[block >> 8 & 0x0F] + HEX_CHARS[block >> 20 & 0x0F] + HEX_CHARS[block >> 16 & 0x0F] + HEX_CHARS[block >> 28 & 0x0F] + HEX_CHARS[block >> 24 & 0x0F];
            }
            if (j % blockCount === 0) {
                f(s);
                i = 0;
            }
        }
        if (extraBytes) {
            block = s[i];
            hex += HEX_CHARS[block >> 4 & 0x0F] + HEX_CHARS[block & 0x0F];
            if (extraBytes > 1) {
                hex += HEX_CHARS[block >> 12 & 0x0F] + HEX_CHARS[block >> 8 & 0x0F];
            }
            if (extraBytes > 2) {
                hex += HEX_CHARS[block >> 20 & 0x0F] + HEX_CHARS[block >> 16 & 0x0F];
            }
        }
        return hex;
    };
    Keccak.prototype.arrayBuffer = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i = 0, j = 0;
        var bytes = this.outputBits >> 3;
        var buffer;
        if (extraBytes) {
            buffer = new ArrayBuffer(outputBlocks + 1 << 2);
        } else {
            buffer = new ArrayBuffer(bytes);
        }
        var array = new Uint32Array(buffer);
        while(j < outputBlocks){
            for(i = 0; i < blockCount && j < outputBlocks; ++i, ++j){
                array[j] = s[i];
            }
            if (j % blockCount === 0) {
                f(s);
            }
        }
        if (extraBytes) {
            array[i] = s[i];
            buffer = buffer.slice(0, bytes);
        }
        return buffer;
    };
    Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
    Keccak.prototype.digest = Keccak.prototype.array = function() {
        this.finalize();
        var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i = 0, j = 0;
        var array = [], offset, block;
        while(j < outputBlocks){
            for(i = 0; i < blockCount && j < outputBlocks; ++i, ++j){
                offset = j << 2;
                block = s[i];
                array[offset] = block & 0xFF;
                array[offset + 1] = block >> 8 & 0xFF;
                array[offset + 2] = block >> 16 & 0xFF;
                array[offset + 3] = block >> 24 & 0xFF;
            }
            if (j % blockCount === 0) {
                f(s);
            }
        }
        if (extraBytes) {
            offset = j << 2;
            block = s[i];
            array[offset] = block & 0xFF;
            if (extraBytes > 1) {
                array[offset + 1] = block >> 8 & 0xFF;
            }
            if (extraBytes > 2) {
                array[offset + 2] = block >> 16 & 0xFF;
            }
        }
        return array;
    };
    function Kmac(bits, padding, outputBits) {
        Keccak.call(this, bits, padding, outputBits);
    }
    Kmac.prototype = new Keccak();
    Kmac.prototype.finalize = function() {
        this.encode(this.outputBits, true);
        return Keccak.prototype.finalize.call(this);
    };
    var f = function(s) {
        var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
        for(n = 0; n < 48; n += 2){
            c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
            c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
            c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
            c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
            c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
            c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
            c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
            c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
            c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
            c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
            h = c8 ^ (c2 << 1 | c3 >>> 31);
            l = c9 ^ (c3 << 1 | c2 >>> 31);
            s[0] ^= h;
            s[1] ^= l;
            s[10] ^= h;
            s[11] ^= l;
            s[20] ^= h;
            s[21] ^= l;
            s[30] ^= h;
            s[31] ^= l;
            s[40] ^= h;
            s[41] ^= l;
            h = c0 ^ (c4 << 1 | c5 >>> 31);
            l = c1 ^ (c5 << 1 | c4 >>> 31);
            s[2] ^= h;
            s[3] ^= l;
            s[12] ^= h;
            s[13] ^= l;
            s[22] ^= h;
            s[23] ^= l;
            s[32] ^= h;
            s[33] ^= l;
            s[42] ^= h;
            s[43] ^= l;
            h = c2 ^ (c6 << 1 | c7 >>> 31);
            l = c3 ^ (c7 << 1 | c6 >>> 31);
            s[4] ^= h;
            s[5] ^= l;
            s[14] ^= h;
            s[15] ^= l;
            s[24] ^= h;
            s[25] ^= l;
            s[34] ^= h;
            s[35] ^= l;
            s[44] ^= h;
            s[45] ^= l;
            h = c4 ^ (c8 << 1 | c9 >>> 31);
            l = c5 ^ (c9 << 1 | c8 >>> 31);
            s[6] ^= h;
            s[7] ^= l;
            s[16] ^= h;
            s[17] ^= l;
            s[26] ^= h;
            s[27] ^= l;
            s[36] ^= h;
            s[37] ^= l;
            s[46] ^= h;
            s[47] ^= l;
            h = c6 ^ (c0 << 1 | c1 >>> 31);
            l = c7 ^ (c1 << 1 | c0 >>> 31);
            s[8] ^= h;
            s[9] ^= l;
            s[18] ^= h;
            s[19] ^= l;
            s[28] ^= h;
            s[29] ^= l;
            s[38] ^= h;
            s[39] ^= l;
            s[48] ^= h;
            s[49] ^= l;
            b0 = s[0];
            b1 = s[1];
            b32 = s[11] << 4 | s[10] >>> 28;
            b33 = s[10] << 4 | s[11] >>> 28;
            b14 = s[20] << 3 | s[21] >>> 29;
            b15 = s[21] << 3 | s[20] >>> 29;
            b46 = s[31] << 9 | s[30] >>> 23;
            b47 = s[30] << 9 | s[31] >>> 23;
            b28 = s[40] << 18 | s[41] >>> 14;
            b29 = s[41] << 18 | s[40] >>> 14;
            b20 = s[2] << 1 | s[3] >>> 31;
            b21 = s[3] << 1 | s[2] >>> 31;
            b2 = s[13] << 12 | s[12] >>> 20;
            b3 = s[12] << 12 | s[13] >>> 20;
            b34 = s[22] << 10 | s[23] >>> 22;
            b35 = s[23] << 10 | s[22] >>> 22;
            b16 = s[33] << 13 | s[32] >>> 19;
            b17 = s[32] << 13 | s[33] >>> 19;
            b48 = s[42] << 2 | s[43] >>> 30;
            b49 = s[43] << 2 | s[42] >>> 30;
            b40 = s[5] << 30 | s[4] >>> 2;
            b41 = s[4] << 30 | s[5] >>> 2;
            b22 = s[14] << 6 | s[15] >>> 26;
            b23 = s[15] << 6 | s[14] >>> 26;
            b4 = s[25] << 11 | s[24] >>> 21;
            b5 = s[24] << 11 | s[25] >>> 21;
            b36 = s[34] << 15 | s[35] >>> 17;
            b37 = s[35] << 15 | s[34] >>> 17;
            b18 = s[45] << 29 | s[44] >>> 3;
            b19 = s[44] << 29 | s[45] >>> 3;
            b10 = s[6] << 28 | s[7] >>> 4;
            b11 = s[7] << 28 | s[6] >>> 4;
            b42 = s[17] << 23 | s[16] >>> 9;
            b43 = s[16] << 23 | s[17] >>> 9;
            b24 = s[26] << 25 | s[27] >>> 7;
            b25 = s[27] << 25 | s[26] >>> 7;
            b6 = s[36] << 21 | s[37] >>> 11;
            b7 = s[37] << 21 | s[36] >>> 11;
            b38 = s[47] << 24 | s[46] >>> 8;
            b39 = s[46] << 24 | s[47] >>> 8;
            b30 = s[8] << 27 | s[9] >>> 5;
            b31 = s[9] << 27 | s[8] >>> 5;
            b12 = s[18] << 20 | s[19] >>> 12;
            b13 = s[19] << 20 | s[18] >>> 12;
            b44 = s[29] << 7 | s[28] >>> 25;
            b45 = s[28] << 7 | s[29] >>> 25;
            b26 = s[38] << 8 | s[39] >>> 24;
            b27 = s[39] << 8 | s[38] >>> 24;
            b8 = s[48] << 14 | s[49] >>> 18;
            b9 = s[49] << 14 | s[48] >>> 18;
            s[0] = b0 ^ ~b2 & b4;
            s[1] = b1 ^ ~b3 & b5;
            s[10] = b10 ^ ~b12 & b14;
            s[11] = b11 ^ ~b13 & b15;
            s[20] = b20 ^ ~b22 & b24;
            s[21] = b21 ^ ~b23 & b25;
            s[30] = b30 ^ ~b32 & b34;
            s[31] = b31 ^ ~b33 & b35;
            s[40] = b40 ^ ~b42 & b44;
            s[41] = b41 ^ ~b43 & b45;
            s[2] = b2 ^ ~b4 & b6;
            s[3] = b3 ^ ~b5 & b7;
            s[12] = b12 ^ ~b14 & b16;
            s[13] = b13 ^ ~b15 & b17;
            s[22] = b22 ^ ~b24 & b26;
            s[23] = b23 ^ ~b25 & b27;
            s[32] = b32 ^ ~b34 & b36;
            s[33] = b33 ^ ~b35 & b37;
            s[42] = b42 ^ ~b44 & b46;
            s[43] = b43 ^ ~b45 & b47;
            s[4] = b4 ^ ~b6 & b8;
            s[5] = b5 ^ ~b7 & b9;
            s[14] = b14 ^ ~b16 & b18;
            s[15] = b15 ^ ~b17 & b19;
            s[24] = b24 ^ ~b26 & b28;
            s[25] = b25 ^ ~b27 & b29;
            s[34] = b34 ^ ~b36 & b38;
            s[35] = b35 ^ ~b37 & b39;
            s[44] = b44 ^ ~b46 & b48;
            s[45] = b45 ^ ~b47 & b49;
            s[6] = b6 ^ ~b8 & b0;
            s[7] = b7 ^ ~b9 & b1;
            s[16] = b16 ^ ~b18 & b10;
            s[17] = b17 ^ ~b19 & b11;
            s[26] = b26 ^ ~b28 & b20;
            s[27] = b27 ^ ~b29 & b21;
            s[36] = b36 ^ ~b38 & b30;
            s[37] = b37 ^ ~b39 & b31;
            s[46] = b46 ^ ~b48 & b40;
            s[47] = b47 ^ ~b49 & b41;
            s[8] = b8 ^ ~b0 & b2;
            s[9] = b9 ^ ~b1 & b3;
            s[18] = b18 ^ ~b10 & b12;
            s[19] = b19 ^ ~b11 & b13;
            s[28] = b28 ^ ~b20 & b22;
            s[29] = b29 ^ ~b21 & b23;
            s[38] = b38 ^ ~b30 & b32;
            s[39] = b39 ^ ~b31 & b33;
            s[48] = b48 ^ ~b40 & b42;
            s[49] = b49 ^ ~b41 & b43;
            s[0] ^= RC[n];
            s[1] ^= RC[n + 1];
        }
    };
    if (COMMON_JS) {
        module.exports = methods;
    } else {
        for(i = 0; i < methodNames.length; ++i){
            root[methodNames[i]] = methods[methodNames[i]];
        }
        if (AMD) {
            ((r)=>r !== undefined && __turbopack_context__.v(r))(function() {
                return methods;
            }(__turbopack_context__.r, exports, module));
        }
    }
})();
}),
"[project]/node_modules/minimalistic-assert/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = assert;
function assert(val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
}
assert.equal = function assertEqual(l, r, msg) {
    if (l != r) throw new Error(msg || 'Assertion failed: ' + l + ' != ' + r);
};
}),
"[project]/node_modules/hash.js/lib/hash/utils.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var assert = __turbopack_context__.r("[project]/node_modules/minimalistic-assert/index.js [app-client] (ecmascript)");
var inherits = __turbopack_context__.r("[project]/node_modules/inherits/inherits_browser.js [app-client] (ecmascript)");
exports.inherits = inherits;
function isSurrogatePair(msg, i) {
    if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
        return false;
    }
    if (i < 0 || i + 1 >= msg.length) {
        return false;
    }
    return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}
function toArray(msg, enc) {
    if (Array.isArray(msg)) return msg.slice();
    if (!msg) return [];
    var res = [];
    if (typeof msg === 'string') {
        if (!enc) {
            // Inspired by stringToUtf8ByteArray() in closure-library by Google
            // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
            // Apache License 2.0
            // https://github.com/google/closure-library/blob/master/LICENSE
            var p = 0;
            for(var i = 0; i < msg.length; i++){
                var c = msg.charCodeAt(i);
                if (c < 128) {
                    res[p++] = c;
                } else if (c < 2048) {
                    res[p++] = c >> 6 | 192;
                    res[p++] = c & 63 | 128;
                } else if (isSurrogatePair(msg, i)) {
                    c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
                    res[p++] = c >> 18 | 240;
                    res[p++] = c >> 12 & 63 | 128;
                    res[p++] = c >> 6 & 63 | 128;
                    res[p++] = c & 63 | 128;
                } else {
                    res[p++] = c >> 12 | 224;
                    res[p++] = c >> 6 & 63 | 128;
                    res[p++] = c & 63 | 128;
                }
            }
        } else if (enc === 'hex') {
            msg = msg.replace(/[^a-z0-9]+/ig, '');
            if (msg.length % 2 !== 0) msg = '0' + msg;
            for(i = 0; i < msg.length; i += 2)res.push(parseInt(msg[i] + msg[i + 1], 16));
        }
    } else {
        for(i = 0; i < msg.length; i++)res[i] = msg[i] | 0;
    }
    return res;
}
exports.toArray = toArray;
function toHex(msg) {
    var res = '';
    for(var i = 0; i < msg.length; i++)res += zero2(msg[i].toString(16));
    return res;
}
exports.toHex = toHex;
function htonl(w) {
    var res = w >>> 24 | w >>> 8 & 0xff00 | w << 8 & 0xff0000 | (w & 0xff) << 24;
    return res >>> 0;
}
exports.htonl = htonl;
function toHex32(msg, endian) {
    var res = '';
    for(var i = 0; i < msg.length; i++){
        var w = msg[i];
        if (endian === 'little') w = htonl(w);
        res += zero8(w.toString(16));
    }
    return res;
}
exports.toHex32 = toHex32;
function zero2(word) {
    if (word.length === 1) return '0' + word;
    else return word;
}
exports.zero2 = zero2;
function zero8(word) {
    if (word.length === 7) return '0' + word;
    else if (word.length === 6) return '00' + word;
    else if (word.length === 5) return '000' + word;
    else if (word.length === 4) return '0000' + word;
    else if (word.length === 3) return '00000' + word;
    else if (word.length === 2) return '000000' + word;
    else if (word.length === 1) return '0000000' + word;
    else return word;
}
exports.zero8 = zero8;
function join32(msg, start, end, endian) {
    var len = end - start;
    assert(len % 4 === 0);
    var res = new Array(len / 4);
    for(var i = 0, k = start; i < res.length; i++, k += 4){
        var w;
        if (endian === 'big') w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
        else w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
        res[i] = w >>> 0;
    }
    return res;
}
exports.join32 = join32;
function split32(msg, endian) {
    var res = new Array(msg.length * 4);
    for(var i = 0, k = 0; i < msg.length; i++, k += 4){
        var m = msg[i];
        if (endian === 'big') {
            res[k] = m >>> 24;
            res[k + 1] = m >>> 16 & 0xff;
            res[k + 2] = m >>> 8 & 0xff;
            res[k + 3] = m & 0xff;
        } else {
            res[k + 3] = m >>> 24;
            res[k + 2] = m >>> 16 & 0xff;
            res[k + 1] = m >>> 8 & 0xff;
            res[k] = m & 0xff;
        }
    }
    return res;
}
exports.split32 = split32;
function rotr32(w, b) {
    return w >>> b | w << 32 - b;
}
exports.rotr32 = rotr32;
function rotl32(w, b) {
    return w << b | w >>> 32 - b;
}
exports.rotl32 = rotl32;
function sum32(a, b) {
    return a + b >>> 0;
}
exports.sum32 = sum32;
function sum32_3(a, b, c) {
    return a + b + c >>> 0;
}
exports.sum32_3 = sum32_3;
function sum32_4(a, b, c, d) {
    return a + b + c + d >>> 0;
}
exports.sum32_4 = sum32_4;
function sum32_5(a, b, c, d, e) {
    return a + b + c + d + e >>> 0;
}
exports.sum32_5 = sum32_5;
function sum64(buf, pos, ah, al) {
    var bh = buf[pos];
    var bl = buf[pos + 1];
    var lo = al + bl >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    buf[pos] = hi >>> 0;
    buf[pos + 1] = lo;
}
exports.sum64 = sum64;
function sum64_hi(ah, al, bh, bl) {
    var lo = al + bl >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    return hi >>> 0;
}
exports.sum64_hi = sum64_hi;
function sum64_lo(ah, al, bh, bl) {
    var lo = al + bl;
    return lo >>> 0;
}
exports.sum64_lo = sum64_lo;
function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
    var carry = 0;
    var lo = al;
    lo = lo + bl >>> 0;
    carry += lo < al ? 1 : 0;
    lo = lo + cl >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = lo + dl >>> 0;
    carry += lo < dl ? 1 : 0;
    var hi = ah + bh + ch + dh + carry;
    return hi >>> 0;
}
exports.sum64_4_hi = sum64_4_hi;
function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
    var lo = al + bl + cl + dl;
    return lo >>> 0;
}
exports.sum64_4_lo = sum64_4_lo;
function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var carry = 0;
    var lo = al;
    lo = lo + bl >>> 0;
    carry += lo < al ? 1 : 0;
    lo = lo + cl >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = lo + dl >>> 0;
    carry += lo < dl ? 1 : 0;
    lo = lo + el >>> 0;
    carry += lo < el ? 1 : 0;
    var hi = ah + bh + ch + dh + eh + carry;
    return hi >>> 0;
}
exports.sum64_5_hi = sum64_5_hi;
function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var lo = al + bl + cl + dl + el;
    return lo >>> 0;
}
exports.sum64_5_lo = sum64_5_lo;
function rotr64_hi(ah, al, num) {
    var r = al << 32 - num | ah >>> num;
    return r >>> 0;
}
exports.rotr64_hi = rotr64_hi;
function rotr64_lo(ah, al, num) {
    var r = ah << 32 - num | al >>> num;
    return r >>> 0;
}
exports.rotr64_lo = rotr64_lo;
function shr64_hi(ah, al, num) {
    return ah >>> num;
}
exports.shr64_hi = shr64_hi;
function shr64_lo(ah, al, num) {
    var r = ah << 32 - num | al >>> num;
    return r >>> 0;
}
exports.shr64_lo = shr64_lo;
}),
"[project]/node_modules/hash.js/lib/hash/common.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var utils = __turbopack_context__.r("[project]/node_modules/hash.js/lib/hash/utils.js [app-client] (ecmascript)");
var assert = __turbopack_context__.r("[project]/node_modules/minimalistic-assert/index.js [app-client] (ecmascript)");
function BlockHash() {
    this.pending = null;
    this.pendingTotal = 0;
    this.blockSize = this.constructor.blockSize;
    this.outSize = this.constructor.outSize;
    this.hmacStrength = this.constructor.hmacStrength;
    this.padLength = this.constructor.padLength / 8;
    this.endian = 'big';
    this._delta8 = this.blockSize / 8;
    this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;
BlockHash.prototype.update = function update(msg, enc) {
    // Convert message to array, pad it, and join into 32bit blocks
    msg = utils.toArray(msg, enc);
    if (!this.pending) this.pending = msg;
    else this.pending = this.pending.concat(msg);
    this.pendingTotal += msg.length;
    // Enough data, try updating
    if (this.pending.length >= this._delta8) {
        msg = this.pending;
        // Process pending data in blocks
        var r = msg.length % this._delta8;
        this.pending = msg.slice(msg.length - r, msg.length);
        if (this.pending.length === 0) this.pending = null;
        msg = utils.join32(msg, 0, msg.length - r, this.endian);
        for(var i = 0; i < msg.length; i += this._delta32)this._update(msg, i, i + this._delta32);
    }
    return this;
};
BlockHash.prototype.digest = function digest(enc) {
    this.update(this._pad());
    assert(this.pending === null);
    return this._digest(enc);
};
BlockHash.prototype._pad = function pad() {
    var len = this.pendingTotal;
    var bytes = this._delta8;
    var k = bytes - (len + this.padLength) % bytes;
    var res = new Array(k + this.padLength);
    res[0] = 0x80;
    for(var i = 1; i < k; i++)res[i] = 0;
    // Append length
    len <<= 3;
    if (this.endian === 'big') {
        for(var t = 8; t < this.padLength; t++)res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = len >>> 24 & 0xff;
        res[i++] = len >>> 16 & 0xff;
        res[i++] = len >>> 8 & 0xff;
        res[i++] = len & 0xff;
    } else {
        res[i++] = len & 0xff;
        res[i++] = len >>> 8 & 0xff;
        res[i++] = len >>> 16 & 0xff;
        res[i++] = len >>> 24 & 0xff;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        for(t = 8; t < this.padLength; t++)res[i++] = 0;
    }
    return res;
};
}),
"[project]/node_modules/hash.js/lib/hash/sha/common.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var utils = __turbopack_context__.r("[project]/node_modules/hash.js/lib/hash/utils.js [app-client] (ecmascript)");
var rotr32 = utils.rotr32;
function ft_1(s, x, y, z) {
    if (s === 0) return ch32(x, y, z);
    if (s === 1 || s === 3) return p32(x, y, z);
    if (s === 2) return maj32(x, y, z);
}
exports.ft_1 = ft_1;
function ch32(x, y, z) {
    return x & y ^ ~x & z;
}
exports.ch32 = ch32;
function maj32(x, y, z) {
    return x & y ^ x & z ^ y & z;
}
exports.maj32 = maj32;
function p32(x, y, z) {
    return x ^ y ^ z;
}
exports.p32 = p32;
function s0_256(x) {
    return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
exports.s0_256 = s0_256;
function s1_256(x) {
    return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
exports.s1_256 = s1_256;
function g0_256(x) {
    return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
}
exports.g0_256 = g0_256;
function g1_256(x) {
    return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
}
exports.g1_256 = g1_256;
}),
"[project]/node_modules/hash.js/lib/hash/sha/1.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var utils = __turbopack_context__.r("[project]/node_modules/hash.js/lib/hash/utils.js [app-client] (ecmascript)");
var common = __turbopack_context__.r("[project]/node_modules/hash.js/lib/hash/common.js [app-client] (ecmascript)");
var shaCommon = __turbopack_context__.r("[project]/node_modules/hash.js/lib/hash/sha/common.js [app-client] (ecmascript)");
var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;
var sha1_K = [
    0x5A827999,
    0x6ED9EBA1,
    0x8F1BBCDC,
    0xCA62C1D6
];
function SHA1() {
    if (!(this instanceof SHA1)) return new SHA1();
    BlockHash.call(this);
    this.h = [
        0x67452301,
        0xefcdab89,
        0x98badcfe,
        0x10325476,
        0xc3d2e1f0
    ];
    this.W = new Array(80);
}
utils.inherits(SHA1, BlockHash);
module.exports = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function _update(msg, start) {
    var W = this.W;
    for(var i = 0; i < 16; i++)W[i] = msg[start + i];
    for(; i < W.length; i++)W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    for(i = 0; i < W.length; i++){
        var s = ~~(i / 20);
        var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
        e = d;
        d = c;
        c = rotl32(b, 30);
        b = a;
        a = t;
    }
    this.h[0] = sum32(this.h[0], a);
    this.h[1] = sum32(this.h[1], b);
    this.h[2] = sum32(this.h[2], c);
    this.h[3] = sum32(this.h[3], d);
    this.h[4] = sum32(this.h[4], e);
};
SHA1.prototype._digest = function digest(enc) {
    if (enc === 'hex') return utils.toHex32(this.h, 'big');
    else return utils.split32(this.h, 'big');
};
}),
"[project]/node_modules/hash.js/lib/hash/sha/256.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var utils = __turbopack_context__.r("[project]/node_modules/hash.js/lib/hash/utils.js [app-client] (ecmascript)");
var common = __turbopack_context__.r("[project]/node_modules/hash.js/lib/hash/common.js [app-client] (ecmascript)");
var shaCommon = __turbopack_context__.r("[project]/node_modules/hash.js/lib/hash/sha/common.js [app-client] (ecmascript)");
var assert = __turbopack_context__.r("[project]/node_modules/minimalistic-assert/index.js [app-client] (ecmascript)");
var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;
var BlockHash = common.BlockHash;
var sha256_K = [
    0x428a2f98,
    0x71374491,
    0xb5c0fbcf,
    0xe9b5dba5,
    0x3956c25b,
    0x59f111f1,
    0x923f82a4,
    0xab1c5ed5,
    0xd807aa98,
    0x12835b01,
    0x243185be,
    0x550c7dc3,
    0x72be5d74,
    0x80deb1fe,
    0x9bdc06a7,
    0xc19bf174,
    0xe49b69c1,
    0xefbe4786,
    0x0fc19dc6,
    0x240ca1cc,
    0x2de92c6f,
    0x4a7484aa,
    0x5cb0a9dc,
    0x76f988da,
    0x983e5152,
    0xa831c66d,
    0xb00327c8,
    0xbf597fc7,
    0xc6e00bf3,
    0xd5a79147,
    0x06ca6351,
    0x14292967,
    0x27b70a85,
    0x2e1b2138,
    0x4d2c6dfc,
    0x53380d13,
    0x650a7354,
    0x766a0abb,
    0x81c2c92e,
    0x92722c85,
    0xa2bfe8a1,
    0xa81a664b,
    0xc24b8b70,
    0xc76c51a3,
    0xd192e819,
    0xd6990624,
    0xf40e3585,
    0x106aa070,
    0x19a4c116,
    0x1e376c08,
    0x2748774c,
    0x34b0bcb5,
    0x391c0cb3,
    0x4ed8aa4a,
    0x5b9cca4f,
    0x682e6ff3,
    0x748f82ee,
    0x78a5636f,
    0x84c87814,
    0x8cc70208,
    0x90befffa,
    0xa4506ceb,
    0xbef9a3f7,
    0xc67178f2
];
function SHA256() {
    if (!(this instanceof SHA256)) return new SHA256();
    BlockHash.call(this);
    this.h = [
        0x6a09e667,
        0xbb67ae85,
        0x3c6ef372,
        0xa54ff53a,
        0x510e527f,
        0x9b05688c,
        0x1f83d9ab,
        0x5be0cd19
    ];
    this.k = sha256_K;
    this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
module.exports = SHA256;
SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;
SHA256.prototype._update = function _update(msg, start) {
    var W = this.W;
    for(var i = 0; i < 16; i++)W[i] = msg[start + i];
    for(; i < W.length; i++)W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    var f = this.h[5];
    var g = this.h[6];
    var h = this.h[7];
    assert(this.k.length === W.length);
    for(i = 0; i < W.length; i++){
        var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
        var T2 = sum32(s0_256(a), maj32(a, b, c));
        h = g;
        g = f;
        f = e;
        e = sum32(d, T1);
        d = c;
        c = b;
        b = a;
        a = sum32(T1, T2);
    }
    this.h[0] = sum32(this.h[0], a);
    this.h[1] = sum32(this.h[1], b);
    this.h[2] = sum32(this.h[2], c);
    this.h[3] = sum32(this.h[3], d);
    this.h[4] = sum32(this.h[4], e);
    this.h[5] = sum32(this.h[5], f);
    this.h[6] = sum32(this.h[6], g);
    this.h[7] = sum32(this.h[7], h);
};
SHA256.prototype._digest = function digest(enc) {
    if (enc === 'hex') return utils.toHex32(this.h, 'big');
    else return utils.split32(this.h, 'big');
};
}),
"[project]/node_modules/hash.js/lib/hash/sha/224.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var utils = __turbopack_context__.r("[project]/node_modules/hash.js/lib/hash/utils.js [app-client] (ecmascript)");
var SHA256 = __turbopack_context__.r("[project]/node_modules/hash.js/lib/hash/sha/256.js [app-client] (ecmascript)");
function SHA224() {
    if (!(this instanceof SHA224)) return new SHA224();
    SHA256.call(this);
    this.h = [
        0xc1059ed8,
        0x367cd507,
        0x3070dd17,
        0xf70e5939,
        0xffc00b31,
        0x68581511,
        0x64f98fa7,
        0xbefa4fa4
    ];
}
utils.inherits(SHA224, SHA256);
module.exports = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function digest(enc) {
    // Just truncate output
    if (enc === 'hex') return utils.toHex32(this.h.slice(0, 7), 'big');
    else return utils.split32(this.h.slice(0, 7), 'big');
};
}),
"[project]/node_modules/hash.js/lib/hash/sha/512.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var utils = __turbopack_context__.r("[project]/node_modules/hash.js/lib/hash/utils.js [app-client] (ecmascript)");
var common = __turbopack_context__.r("[project]/node_modules/hash.js/lib/hash/common.js [app-client] (ecmascript)");
var assert = __turbopack_context__.r("[project]/node_modules/minimalistic-assert/index.js [app-client] (ecmascript)");
var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;
var BlockHash = common.BlockHash;
var sha512_K = [
    0x428a2f98,
    0xd728ae22,
    0x71374491,
    0x23ef65cd,
    0xb5c0fbcf,
    0xec4d3b2f,
    0xe9b5dba5,
    0x8189dbbc,
    0x3956c25b,
    0xf348b538,
    0x59f111f1,
    0xb605d019,
    0x923f82a4,
    0xaf194f9b,
    0xab1c5ed5,
    0xda6d8118,
    0xd807aa98,
    0xa3030242,
    0x12835b01,
    0x45706fbe,
    0x243185be,
    0x4ee4b28c,
    0x550c7dc3,
    0xd5ffb4e2,
    0x72be5d74,
    0xf27b896f,
    0x80deb1fe,
    0x3b1696b1,
    0x9bdc06a7,
    0x25c71235,
    0xc19bf174,
    0xcf692694,
    0xe49b69c1,
    0x9ef14ad2,
    0xefbe4786,
    0x384f25e3,
    0x0fc19dc6,
    0x8b8cd5b5,
    0x240ca1cc,
    0x77ac9c65,
    0x2de92c6f,
    0x592b0275,
    0x4a7484aa,
    0x6ea6e483,
    0x5cb0a9dc,
    0xbd41fbd4,
    0x76f988da,
    0x831153b5,
    0x983e5152,
    0xee66dfab,
    0xa831c66d,
    0x2db43210,
    0xb00327c8,
    0x98fb213f,
    0xbf597fc7,
    0xbeef0ee4,
    0xc6e00bf3,
    0x3da88fc2,
    0xd5a79147,
    0x930aa725,
    0x06ca6351,
    0xe003826f,
    0x14292967,
    0x0a0e6e70,
    0x27b70a85,
    0x46d22ffc,
    0x2e1b2138,
    0x5c26c926,
    0x4d2c6dfc,
    0x5ac42aed,
    0x53380d13,
    0x9d95b3df,
    0x650a7354,
    0x8baf63de,
    0x766a0abb,
    0x3c77b2a8,
    0x81c2c92e,
    0x47edaee6,
    0x92722c85,
    0x1482353b,
    0xa2bfe8a1,
    0x4cf10364,
    0xa81a664b,
    0xbc423001,
    0xc24b8b70,
    0xd0f89791,
    0xc76c51a3,
    0x0654be30,
    0xd192e819,
    0xd6ef5218,
    0xd6990624,
    0x5565a910,
    0xf40e3585,
    0x5771202a,
    0x106aa070,
    0x32bbd1b8,
    0x19a4c116,
    0xb8d2d0c8,
    0x1e376c08,
    0x5141ab53,
    0x2748774c,
    0xdf8eeb99,
    0x34b0bcb5,
    0xe19b48a8,
    0x391c0cb3,
    0xc5c95a63,
    0x4ed8aa4a,
    0xe3418acb,
    0x5b9cca4f,
    0x7763e373,
    0x682e6ff3,
    0xd6b2b8a3,
    0x748f82ee,
    0x5defb2fc,
    0x78a5636f,
    0x43172f60,
    0x84c87814,
    0xa1f0ab72,
    0x8cc70208,
    0x1a6439ec,
    0x90befffa,
    0x23631e28,
    0xa4506ceb,
    0xde82bde9,
    0xbef9a3f7,
    0xb2c67915,
    0xc67178f2,
    0xe372532b,
    0xca273ece,
    0xea26619c,
    0xd186b8c7,
    0x21c0c207,
    0xeada7dd6,
    0xcde0eb1e,
    0xf57d4f7f,
    0xee6ed178,
    0x06f067aa,
    0x72176fba,
    0x0a637dc5,
    0xa2c898a6,
    0x113f9804,
    0xbef90dae,
    0x1b710b35,
    0x131c471b,
    0x28db77f5,
    0x23047d84,
    0x32caab7b,
    0x40c72493,
    0x3c9ebe0a,
    0x15c9bebc,
    0x431d67c4,
    0x9c100d4c,
    0x4cc5d4be,
    0xcb3e42b6,
    0x597f299c,
    0xfc657e2a,
    0x5fcb6fab,
    0x3ad6faec,
    0x6c44198c,
    0x4a475817
];
function SHA512() {
    if (!(this instanceof SHA512)) return new SHA512();
    BlockHash.call(this);
    this.h = [
        0x6a09e667,
        0xf3bcc908,
        0xbb67ae85,
        0x84caa73b,
        0x3c6ef372,
        0xfe94f82b,
        0xa54ff53a,
        0x5f1d36f1,
        0x510e527f,
        0xade682d1,
        0x9b05688c,
        0x2b3e6c1f,
        0x1f83d9ab,
        0xfb41bd6b,
        0x5be0cd19,
        0x137e2179
    ];
    this.k = sha512_K;
    this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
module.exports = SHA512;
SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;
SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
    var W = this.W;
    // 32 x 32bit words
    for(var i = 0; i < 32; i++)W[i] = msg[start + i];
    for(; i < W.length; i += 2){
        var c0_hi = g1_512_hi(W[i - 4], W[i - 3]); // i - 2
        var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
        var c1_hi = W[i - 14]; // i - 7
        var c1_lo = W[i - 13];
        var c2_hi = g0_512_hi(W[i - 30], W[i - 29]); // i - 15
        var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
        var c3_hi = W[i - 32]; // i - 16
        var c3_lo = W[i - 31];
        W[i] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
        W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
    }
};
SHA512.prototype._update = function _update(msg, start) {
    this._prepareBlock(msg, start);
    var W = this.W;
    var ah = this.h[0];
    var al = this.h[1];
    var bh = this.h[2];
    var bl = this.h[3];
    var ch = this.h[4];
    var cl = this.h[5];
    var dh = this.h[6];
    var dl = this.h[7];
    var eh = this.h[8];
    var el = this.h[9];
    var fh = this.h[10];
    var fl = this.h[11];
    var gh = this.h[12];
    var gl = this.h[13];
    var hh = this.h[14];
    var hl = this.h[15];
    assert(this.k.length === W.length);
    for(var i = 0; i < W.length; i += 2){
        var c0_hi = hh;
        var c0_lo = hl;
        var c1_hi = s1_512_hi(eh, el);
        var c1_lo = s1_512_lo(eh, el);
        var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
        var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
        var c3_hi = this.k[i];
        var c3_lo = this.k[i + 1];
        var c4_hi = W[i];
        var c4_lo = W[i + 1];
        var T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
        var T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
        c0_hi = s0_512_hi(ah, al);
        c0_lo = s0_512_lo(ah, al);
        c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
        c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
        var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        eh = sum64_hi(dh, dl, T1_hi, T1_lo);
        el = sum64_lo(dl, dl, T1_hi, T1_lo);
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
        al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
    }
    sum64(this.h, 0, ah, al);
    sum64(this.h, 2, bh, bl);
    sum64(this.h, 4, ch, cl);
    sum64(this.h, 6, dh, dl);
    sum64(this.h, 8, eh, el);
    sum64(this.h, 10, fh, fl);
    sum64(this.h, 12, gh, gl);
    sum64(this.h, 14, hh, hl);
};
SHA512.prototype._digest = function digest(enc) {
    if (enc === 'hex') return utils.toHex32(this.h, 'big');
    else return utils.split32(this.h, 'big');
};
function ch64_hi(xh, xl, yh, yl, zh) {
    var r = xh & yh ^ ~xh & zh;
    if (r < 0) r += 0x100000000;
    return r;
}
function ch64_lo(xh, xl, yh, yl, zh, zl) {
    var r = xl & yl ^ ~xl & zl;
    if (r < 0) r += 0x100000000;
    return r;
}
function maj64_hi(xh, xl, yh, yl, zh) {
    var r = xh & yh ^ xh & zh ^ yh & zh;
    if (r < 0) r += 0x100000000;
    return r;
}
function maj64_lo(xh, xl, yh, yl, zh, zl) {
    var r = xl & yl ^ xl & zl ^ yl & zl;
    if (r < 0) r += 0x100000000;
    return r;
}
function s0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 28);
    var c1_hi = rotr64_hi(xl, xh, 2); // 34
    var c2_hi = rotr64_hi(xl, xh, 7); // 39
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0) r += 0x100000000;
    return r;
}
function s0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 28);
    var c1_lo = rotr64_lo(xl, xh, 2); // 34
    var c2_lo = rotr64_lo(xl, xh, 7); // 39
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0) r += 0x100000000;
    return r;
}
function s1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 14);
    var c1_hi = rotr64_hi(xh, xl, 18);
    var c2_hi = rotr64_hi(xl, xh, 9); // 41
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0) r += 0x100000000;
    return r;
}
function s1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 14);
    var c1_lo = rotr64_lo(xh, xl, 18);
    var c2_lo = rotr64_lo(xl, xh, 9); // 41
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0) r += 0x100000000;
    return r;
}
function g0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 1);
    var c1_hi = rotr64_hi(xh, xl, 8);
    var c2_hi = shr64_hi(xh, xl, 7);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0) r += 0x100000000;
    return r;
}
function g0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 1);
    var c1_lo = rotr64_lo(xh, xl, 8);
    var c2_lo = shr64_lo(xh, xl, 7);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0) r += 0x100000000;
    return r;
}
function g1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 19);
    var c1_hi = rotr64_hi(xl, xh, 29); // 61
    var c2_hi = shr64_hi(xh, xl, 6);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0) r += 0x100000000;
    return r;
}
function g1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 19);
    var c1_lo = rotr64_lo(xl, xh, 29); // 61
    var c2_lo = shr64_lo(xh, xl, 6);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0) r += 0x100000000;
    return r;
}
}),
"[project]/node_modules/hash.js/lib/hash/sha/384.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var utils = __turbopack_context__.r("[project]/node_modules/hash.js/lib/hash/utils.js [app-client] (ecmascript)");
var SHA512 = __turbopack_context__.r("[project]/node_modules/hash.js/lib/hash/sha/512.js [app-client] (ecmascript)");
function SHA384() {
    if (!(this instanceof SHA384)) return new SHA384();
    SHA512.call(this);
    this.h = [
        0xcbbb9d5d,
        0xc1059ed8,
        0x629a292a,
        0x367cd507,
        0x9159015a,
        0x3070dd17,
        0x152fecd8,
        0xf70e5939,
        0x67332667,
        0xffc00b31,
        0x8eb44a87,
        0x68581511,
        0xdb0c2e0d,
        0x64f98fa7,
        0x47b5481d,
        0xbefa4fa4
    ];
}
utils.inherits(SHA384, SHA512);
module.exports = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function digest(enc) {
    if (enc === 'hex') return utils.toHex32(this.h.slice(0, 12), 'big');
    else return utils.split32(this.h.slice(0, 12), 'big');
};
}),
"[project]/node_modules/hash.js/lib/hash/sha.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

exports.sha1 = __turbopack_context__.r("[project]/node_modules/hash.js/lib/hash/sha/1.js [app-client] (ecmascript)");
exports.sha224 = __turbopack_context__.r("[project]/node_modules/hash.js/lib/hash/sha/224.js [app-client] (ecmascript)");
exports.sha256 = __turbopack_context__.r("[project]/node_modules/hash.js/lib/hash/sha/256.js [app-client] (ecmascript)");
exports.sha384 = __turbopack_context__.r("[project]/node_modules/hash.js/lib/hash/sha/384.js [app-client] (ecmascript)");
exports.sha512 = __turbopack_context__.r("[project]/node_modules/hash.js/lib/hash/sha/512.js [app-client] (ecmascript)");
}),
"[project]/node_modules/hash.js/lib/hash/ripemd.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var utils = __turbopack_context__.r("[project]/node_modules/hash.js/lib/hash/utils.js [app-client] (ecmascript)");
var common = __turbopack_context__.r("[project]/node_modules/hash.js/lib/hash/common.js [app-client] (ecmascript)");
var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = common.BlockHash;
function RIPEMD160() {
    if (!(this instanceof RIPEMD160)) return new RIPEMD160();
    BlockHash.call(this);
    this.h = [
        0x67452301,
        0xefcdab89,
        0x98badcfe,
        0x10325476,
        0xc3d2e1f0
    ];
    this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;
RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;
RIPEMD160.prototype._update = function update(msg, start) {
    var A = this.h[0];
    var B = this.h[1];
    var C = this.h[2];
    var D = this.h[3];
    var E = this.h[4];
    var Ah = A;
    var Bh = B;
    var Ch = C;
    var Dh = D;
    var Eh = E;
    for(var j = 0; j < 80; j++){
        var T = sum32(rotl32(sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)), s[j]), E);
        A = E;
        E = D;
        D = rotl32(C, 10);
        C = B;
        B = T;
        T = sum32(rotl32(sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh);
        Ah = Eh;
        Eh = Dh;
        Dh = rotl32(Ch, 10);
        Ch = Bh;
        Bh = T;
    }
    T = sum32_3(this.h[1], C, Dh);
    this.h[1] = sum32_3(this.h[2], D, Eh);
    this.h[2] = sum32_3(this.h[3], E, Ah);
    this.h[3] = sum32_3(this.h[4], A, Bh);
    this.h[4] = sum32_3(this.h[0], B, Ch);
    this.h[0] = T;
};
RIPEMD160.prototype._digest = function digest(enc) {
    if (enc === 'hex') return utils.toHex32(this.h, 'little');
    else return utils.split32(this.h, 'little');
};
function f(j, x, y, z) {
    if (j <= 15) return x ^ y ^ z;
    else if (j <= 31) return x & y | ~x & z;
    else if (j <= 47) return (x | ~y) ^ z;
    else if (j <= 63) return x & z | y & ~z;
    else return x ^ (y | ~z);
}
function K(j) {
    if (j <= 15) return 0x00000000;
    else if (j <= 31) return 0x5a827999;
    else if (j <= 47) return 0x6ed9eba1;
    else if (j <= 63) return 0x8f1bbcdc;
    else return 0xa953fd4e;
}
function Kh(j) {
    if (j <= 15) return 0x50a28be6;
    else if (j <= 31) return 0x5c4dd124;
    else if (j <= 47) return 0x6d703ef3;
    else if (j <= 63) return 0x7a6d76e9;
    else return 0x00000000;
}
var r = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
];
var rh = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
];
var s = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
];
var sh = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
];
}),
"[project]/node_modules/hash.js/lib/hash/hmac.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var utils = __turbopack_context__.r("[project]/node_modules/hash.js/lib/hash/utils.js [app-client] (ecmascript)");
var assert = __turbopack_context__.r("[project]/node_modules/minimalistic-assert/index.js [app-client] (ecmascript)");
function Hmac(hash, key, enc) {
    if (!(this instanceof Hmac)) return new Hmac(hash, key, enc);
    this.Hash = hash;
    this.blockSize = hash.blockSize / 8;
    this.outSize = hash.outSize / 8;
    this.inner = null;
    this.outer = null;
    this._init(utils.toArray(key, enc));
}
module.exports = Hmac;
Hmac.prototype._init = function init(key) {
    // Shorten key, if needed
    if (key.length > this.blockSize) key = new this.Hash().update(key).digest();
    assert(key.length <= this.blockSize);
    // Add padding to key
    for(var i = key.length; i < this.blockSize; i++)key.push(0);
    for(i = 0; i < key.length; i++)key[i] ^= 0x36;
    this.inner = new this.Hash().update(key);
    // 0x36 ^ 0x5c = 0x6a
    for(i = 0; i < key.length; i++)key[i] ^= 0x6a;
    this.outer = new this.Hash().update(key);
};
Hmac.prototype.update = function update(msg, enc) {
    this.inner.update(msg, enc);
    return this;
};
Hmac.prototype.digest = function digest(enc) {
    this.outer.update(this.inner.digest());
    return this.outer.digest(enc);
};
}),
"[project]/node_modules/hash.js/lib/hash.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

var hash = exports;
hash.utils = __turbopack_context__.r("[project]/node_modules/hash.js/lib/hash/utils.js [app-client] (ecmascript)");
hash.common = __turbopack_context__.r("[project]/node_modules/hash.js/lib/hash/common.js [app-client] (ecmascript)");
hash.sha = __turbopack_context__.r("[project]/node_modules/hash.js/lib/hash/sha.js [app-client] (ecmascript)");
hash.ripemd = __turbopack_context__.r("[project]/node_modules/hash.js/lib/hash/ripemd.js [app-client] (ecmascript)");
hash.hmac = __turbopack_context__.r("[project]/node_modules/hash.js/lib/hash/hmac.js [app-client] (ecmascript)");
// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;
}),
"[project]/node_modules/aes-js/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

(function(root) {
    function checkInt(value) {
        return parseInt(value) === value;
    }
    function checkInts(arrayish) {
        if (!checkInt(arrayish.length)) {
            return false;
        }
        for(var i = 0; i < arrayish.length; i++){
            if (!checkInt(arrayish[i]) || arrayish[i] < 0 || arrayish[i] > 255) {
                return false;
            }
        }
        return true;
    }
    function coerceArray(arg, copy) {
        // ArrayBuffer view
        if (arg.buffer && ArrayBuffer.isView(arg) && arg.name === 'Uint8Array') {
            if (copy) {
                if (arg.slice) {
                    arg = arg.slice();
                } else {
                    arg = Array.prototype.slice.call(arg);
                }
            }
            return arg;
        }
        // It's an array; check it is a valid representation of a byte
        if (Array.isArray(arg)) {
            if (!checkInts(arg)) {
                throw new Error('Array contains invalid value: ' + arg);
            }
            return new Uint8Array(arg);
        }
        // Something else, but behaves like an array (maybe a Buffer? Arguments?)
        if (checkInt(arg.length) && checkInts(arg)) {
            return new Uint8Array(arg);
        }
        throw new Error('unsupported array-like object');
    }
    function createArray(length) {
        return new Uint8Array(length);
    }
    function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {
        if (sourceStart != null || sourceEnd != null) {
            if (sourceArray.slice) {
                sourceArray = sourceArray.slice(sourceStart, sourceEnd);
            } else {
                sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);
            }
        }
        targetArray.set(sourceArray, targetStart);
    }
    var convertUtf8 = function() {
        function toBytes(text) {
            var result = [], i = 0;
            text = encodeURI(text);
            while(i < text.length){
                var c = text.charCodeAt(i++);
                // if it is a % sign, encode the following 2 bytes as a hex value
                if (c === 37) {
                    result.push(parseInt(text.substr(i, 2), 16));
                    i += 2;
                // otherwise, just the actual byte
                } else {
                    result.push(c);
                }
            }
            return coerceArray(result);
        }
        function fromBytes(bytes) {
            var result = [], i = 0;
            while(i < bytes.length){
                var c = bytes[i];
                if (c < 128) {
                    result.push(String.fromCharCode(c));
                    i++;
                } else if (c > 191 && c < 224) {
                    result.push(String.fromCharCode((c & 0x1f) << 6 | bytes[i + 1] & 0x3f));
                    i += 2;
                } else {
                    result.push(String.fromCharCode((c & 0x0f) << 12 | (bytes[i + 1] & 0x3f) << 6 | bytes[i + 2] & 0x3f));
                    i += 3;
                }
            }
            return result.join('');
        }
        return {
            toBytes: toBytes,
            fromBytes: fromBytes
        };
    }();
    var convertHex = function() {
        function toBytes(text) {
            var result = [];
            for(var i = 0; i < text.length; i += 2){
                result.push(parseInt(text.substr(i, 2), 16));
            }
            return result;
        }
        // http://ixti.net/development/javascript/2011/11/11/base64-encodedecode-of-utf8-in-browser-with-js.html
        var Hex = '0123456789abcdef';
        function fromBytes(bytes) {
            var result = [];
            for(var i = 0; i < bytes.length; i++){
                var v = bytes[i];
                result.push(Hex[(v & 0xf0) >> 4] + Hex[v & 0x0f]);
            }
            return result.join('');
        }
        return {
            toBytes: toBytes,
            fromBytes: fromBytes
        };
    }();
    // Number of rounds by keysize
    var numberOfRounds = {
        16: 10,
        24: 12,
        32: 14
    };
    // Round constant words
    var rcon = [
        0x01,
        0x02,
        0x04,
        0x08,
        0x10,
        0x20,
        0x40,
        0x80,
        0x1b,
        0x36,
        0x6c,
        0xd8,
        0xab,
        0x4d,
        0x9a,
        0x2f,
        0x5e,
        0xbc,
        0x63,
        0xc6,
        0x97,
        0x35,
        0x6a,
        0xd4,
        0xb3,
        0x7d,
        0xfa,
        0xef,
        0xc5,
        0x91
    ];
    // S-box and Inverse S-box (S is for Substitution)
    var S = [
        0x63,
        0x7c,
        0x77,
        0x7b,
        0xf2,
        0x6b,
        0x6f,
        0xc5,
        0x30,
        0x01,
        0x67,
        0x2b,
        0xfe,
        0xd7,
        0xab,
        0x76,
        0xca,
        0x82,
        0xc9,
        0x7d,
        0xfa,
        0x59,
        0x47,
        0xf0,
        0xad,
        0xd4,
        0xa2,
        0xaf,
        0x9c,
        0xa4,
        0x72,
        0xc0,
        0xb7,
        0xfd,
        0x93,
        0x26,
        0x36,
        0x3f,
        0xf7,
        0xcc,
        0x34,
        0xa5,
        0xe5,
        0xf1,
        0x71,
        0xd8,
        0x31,
        0x15,
        0x04,
        0xc7,
        0x23,
        0xc3,
        0x18,
        0x96,
        0x05,
        0x9a,
        0x07,
        0x12,
        0x80,
        0xe2,
        0xeb,
        0x27,
        0xb2,
        0x75,
        0x09,
        0x83,
        0x2c,
        0x1a,
        0x1b,
        0x6e,
        0x5a,
        0xa0,
        0x52,
        0x3b,
        0xd6,
        0xb3,
        0x29,
        0xe3,
        0x2f,
        0x84,
        0x53,
        0xd1,
        0x00,
        0xed,
        0x20,
        0xfc,
        0xb1,
        0x5b,
        0x6a,
        0xcb,
        0xbe,
        0x39,
        0x4a,
        0x4c,
        0x58,
        0xcf,
        0xd0,
        0xef,
        0xaa,
        0xfb,
        0x43,
        0x4d,
        0x33,
        0x85,
        0x45,
        0xf9,
        0x02,
        0x7f,
        0x50,
        0x3c,
        0x9f,
        0xa8,
        0x51,
        0xa3,
        0x40,
        0x8f,
        0x92,
        0x9d,
        0x38,
        0xf5,
        0xbc,
        0xb6,
        0xda,
        0x21,
        0x10,
        0xff,
        0xf3,
        0xd2,
        0xcd,
        0x0c,
        0x13,
        0xec,
        0x5f,
        0x97,
        0x44,
        0x17,
        0xc4,
        0xa7,
        0x7e,
        0x3d,
        0x64,
        0x5d,
        0x19,
        0x73,
        0x60,
        0x81,
        0x4f,
        0xdc,
        0x22,
        0x2a,
        0x90,
        0x88,
        0x46,
        0xee,
        0xb8,
        0x14,
        0xde,
        0x5e,
        0x0b,
        0xdb,
        0xe0,
        0x32,
        0x3a,
        0x0a,
        0x49,
        0x06,
        0x24,
        0x5c,
        0xc2,
        0xd3,
        0xac,
        0x62,
        0x91,
        0x95,
        0xe4,
        0x79,
        0xe7,
        0xc8,
        0x37,
        0x6d,
        0x8d,
        0xd5,
        0x4e,
        0xa9,
        0x6c,
        0x56,
        0xf4,
        0xea,
        0x65,
        0x7a,
        0xae,
        0x08,
        0xba,
        0x78,
        0x25,
        0x2e,
        0x1c,
        0xa6,
        0xb4,
        0xc6,
        0xe8,
        0xdd,
        0x74,
        0x1f,
        0x4b,
        0xbd,
        0x8b,
        0x8a,
        0x70,
        0x3e,
        0xb5,
        0x66,
        0x48,
        0x03,
        0xf6,
        0x0e,
        0x61,
        0x35,
        0x57,
        0xb9,
        0x86,
        0xc1,
        0x1d,
        0x9e,
        0xe1,
        0xf8,
        0x98,
        0x11,
        0x69,
        0xd9,
        0x8e,
        0x94,
        0x9b,
        0x1e,
        0x87,
        0xe9,
        0xce,
        0x55,
        0x28,
        0xdf,
        0x8c,
        0xa1,
        0x89,
        0x0d,
        0xbf,
        0xe6,
        0x42,
        0x68,
        0x41,
        0x99,
        0x2d,
        0x0f,
        0xb0,
        0x54,
        0xbb,
        0x16
    ];
    var Si = [
        0x52,
        0x09,
        0x6a,
        0xd5,
        0x30,
        0x36,
        0xa5,
        0x38,
        0xbf,
        0x40,
        0xa3,
        0x9e,
        0x81,
        0xf3,
        0xd7,
        0xfb,
        0x7c,
        0xe3,
        0x39,
        0x82,
        0x9b,
        0x2f,
        0xff,
        0x87,
        0x34,
        0x8e,
        0x43,
        0x44,
        0xc4,
        0xde,
        0xe9,
        0xcb,
        0x54,
        0x7b,
        0x94,
        0x32,
        0xa6,
        0xc2,
        0x23,
        0x3d,
        0xee,
        0x4c,
        0x95,
        0x0b,
        0x42,
        0xfa,
        0xc3,
        0x4e,
        0x08,
        0x2e,
        0xa1,
        0x66,
        0x28,
        0xd9,
        0x24,
        0xb2,
        0x76,
        0x5b,
        0xa2,
        0x49,
        0x6d,
        0x8b,
        0xd1,
        0x25,
        0x72,
        0xf8,
        0xf6,
        0x64,
        0x86,
        0x68,
        0x98,
        0x16,
        0xd4,
        0xa4,
        0x5c,
        0xcc,
        0x5d,
        0x65,
        0xb6,
        0x92,
        0x6c,
        0x70,
        0x48,
        0x50,
        0xfd,
        0xed,
        0xb9,
        0xda,
        0x5e,
        0x15,
        0x46,
        0x57,
        0xa7,
        0x8d,
        0x9d,
        0x84,
        0x90,
        0xd8,
        0xab,
        0x00,
        0x8c,
        0xbc,
        0xd3,
        0x0a,
        0xf7,
        0xe4,
        0x58,
        0x05,
        0xb8,
        0xb3,
        0x45,
        0x06,
        0xd0,
        0x2c,
        0x1e,
        0x8f,
        0xca,
        0x3f,
        0x0f,
        0x02,
        0xc1,
        0xaf,
        0xbd,
        0x03,
        0x01,
        0x13,
        0x8a,
        0x6b,
        0x3a,
        0x91,
        0x11,
        0x41,
        0x4f,
        0x67,
        0xdc,
        0xea,
        0x97,
        0xf2,
        0xcf,
        0xce,
        0xf0,
        0xb4,
        0xe6,
        0x73,
        0x96,
        0xac,
        0x74,
        0x22,
        0xe7,
        0xad,
        0x35,
        0x85,
        0xe2,
        0xf9,
        0x37,
        0xe8,
        0x1c,
        0x75,
        0xdf,
        0x6e,
        0x47,
        0xf1,
        0x1a,
        0x71,
        0x1d,
        0x29,
        0xc5,
        0x89,
        0x6f,
        0xb7,
        0x62,
        0x0e,
        0xaa,
        0x18,
        0xbe,
        0x1b,
        0xfc,
        0x56,
        0x3e,
        0x4b,
        0xc6,
        0xd2,
        0x79,
        0x20,
        0x9a,
        0xdb,
        0xc0,
        0xfe,
        0x78,
        0xcd,
        0x5a,
        0xf4,
        0x1f,
        0xdd,
        0xa8,
        0x33,
        0x88,
        0x07,
        0xc7,
        0x31,
        0xb1,
        0x12,
        0x10,
        0x59,
        0x27,
        0x80,
        0xec,
        0x5f,
        0x60,
        0x51,
        0x7f,
        0xa9,
        0x19,
        0xb5,
        0x4a,
        0x0d,
        0x2d,
        0xe5,
        0x7a,
        0x9f,
        0x93,
        0xc9,
        0x9c,
        0xef,
        0xa0,
        0xe0,
        0x3b,
        0x4d,
        0xae,
        0x2a,
        0xf5,
        0xb0,
        0xc8,
        0xeb,
        0xbb,
        0x3c,
        0x83,
        0x53,
        0x99,
        0x61,
        0x17,
        0x2b,
        0x04,
        0x7e,
        0xba,
        0x77,
        0xd6,
        0x26,
        0xe1,
        0x69,
        0x14,
        0x63,
        0x55,
        0x21,
        0x0c,
        0x7d
    ];
    // Transformations for encryption
    var T1 = [
        0xc66363a5,
        0xf87c7c84,
        0xee777799,
        0xf67b7b8d,
        0xfff2f20d,
        0xd66b6bbd,
        0xde6f6fb1,
        0x91c5c554,
        0x60303050,
        0x02010103,
        0xce6767a9,
        0x562b2b7d,
        0xe7fefe19,
        0xb5d7d762,
        0x4dababe6,
        0xec76769a,
        0x8fcaca45,
        0x1f82829d,
        0x89c9c940,
        0xfa7d7d87,
        0xeffafa15,
        0xb25959eb,
        0x8e4747c9,
        0xfbf0f00b,
        0x41adadec,
        0xb3d4d467,
        0x5fa2a2fd,
        0x45afafea,
        0x239c9cbf,
        0x53a4a4f7,
        0xe4727296,
        0x9bc0c05b,
        0x75b7b7c2,
        0xe1fdfd1c,
        0x3d9393ae,
        0x4c26266a,
        0x6c36365a,
        0x7e3f3f41,
        0xf5f7f702,
        0x83cccc4f,
        0x6834345c,
        0x51a5a5f4,
        0xd1e5e534,
        0xf9f1f108,
        0xe2717193,
        0xabd8d873,
        0x62313153,
        0x2a15153f,
        0x0804040c,
        0x95c7c752,
        0x46232365,
        0x9dc3c35e,
        0x30181828,
        0x379696a1,
        0x0a05050f,
        0x2f9a9ab5,
        0x0e070709,
        0x24121236,
        0x1b80809b,
        0xdfe2e23d,
        0xcdebeb26,
        0x4e272769,
        0x7fb2b2cd,
        0xea75759f,
        0x1209091b,
        0x1d83839e,
        0x582c2c74,
        0x341a1a2e,
        0x361b1b2d,
        0xdc6e6eb2,
        0xb45a5aee,
        0x5ba0a0fb,
        0xa45252f6,
        0x763b3b4d,
        0xb7d6d661,
        0x7db3b3ce,
        0x5229297b,
        0xdde3e33e,
        0x5e2f2f71,
        0x13848497,
        0xa65353f5,
        0xb9d1d168,
        0x00000000,
        0xc1eded2c,
        0x40202060,
        0xe3fcfc1f,
        0x79b1b1c8,
        0xb65b5bed,
        0xd46a6abe,
        0x8dcbcb46,
        0x67bebed9,
        0x7239394b,
        0x944a4ade,
        0x984c4cd4,
        0xb05858e8,
        0x85cfcf4a,
        0xbbd0d06b,
        0xc5efef2a,
        0x4faaaae5,
        0xedfbfb16,
        0x864343c5,
        0x9a4d4dd7,
        0x66333355,
        0x11858594,
        0x8a4545cf,
        0xe9f9f910,
        0x04020206,
        0xfe7f7f81,
        0xa05050f0,
        0x783c3c44,
        0x259f9fba,
        0x4ba8a8e3,
        0xa25151f3,
        0x5da3a3fe,
        0x804040c0,
        0x058f8f8a,
        0x3f9292ad,
        0x219d9dbc,
        0x70383848,
        0xf1f5f504,
        0x63bcbcdf,
        0x77b6b6c1,
        0xafdada75,
        0x42212163,
        0x20101030,
        0xe5ffff1a,
        0xfdf3f30e,
        0xbfd2d26d,
        0x81cdcd4c,
        0x180c0c14,
        0x26131335,
        0xc3ecec2f,
        0xbe5f5fe1,
        0x359797a2,
        0x884444cc,
        0x2e171739,
        0x93c4c457,
        0x55a7a7f2,
        0xfc7e7e82,
        0x7a3d3d47,
        0xc86464ac,
        0xba5d5de7,
        0x3219192b,
        0xe6737395,
        0xc06060a0,
        0x19818198,
        0x9e4f4fd1,
        0xa3dcdc7f,
        0x44222266,
        0x542a2a7e,
        0x3b9090ab,
        0x0b888883,
        0x8c4646ca,
        0xc7eeee29,
        0x6bb8b8d3,
        0x2814143c,
        0xa7dede79,
        0xbc5e5ee2,
        0x160b0b1d,
        0xaddbdb76,
        0xdbe0e03b,
        0x64323256,
        0x743a3a4e,
        0x140a0a1e,
        0x924949db,
        0x0c06060a,
        0x4824246c,
        0xb85c5ce4,
        0x9fc2c25d,
        0xbdd3d36e,
        0x43acacef,
        0xc46262a6,
        0x399191a8,
        0x319595a4,
        0xd3e4e437,
        0xf279798b,
        0xd5e7e732,
        0x8bc8c843,
        0x6e373759,
        0xda6d6db7,
        0x018d8d8c,
        0xb1d5d564,
        0x9c4e4ed2,
        0x49a9a9e0,
        0xd86c6cb4,
        0xac5656fa,
        0xf3f4f407,
        0xcfeaea25,
        0xca6565af,
        0xf47a7a8e,
        0x47aeaee9,
        0x10080818,
        0x6fbabad5,
        0xf0787888,
        0x4a25256f,
        0x5c2e2e72,
        0x381c1c24,
        0x57a6a6f1,
        0x73b4b4c7,
        0x97c6c651,
        0xcbe8e823,
        0xa1dddd7c,
        0xe874749c,
        0x3e1f1f21,
        0x964b4bdd,
        0x61bdbddc,
        0x0d8b8b86,
        0x0f8a8a85,
        0xe0707090,
        0x7c3e3e42,
        0x71b5b5c4,
        0xcc6666aa,
        0x904848d8,
        0x06030305,
        0xf7f6f601,
        0x1c0e0e12,
        0xc26161a3,
        0x6a35355f,
        0xae5757f9,
        0x69b9b9d0,
        0x17868691,
        0x99c1c158,
        0x3a1d1d27,
        0x279e9eb9,
        0xd9e1e138,
        0xebf8f813,
        0x2b9898b3,
        0x22111133,
        0xd26969bb,
        0xa9d9d970,
        0x078e8e89,
        0x339494a7,
        0x2d9b9bb6,
        0x3c1e1e22,
        0x15878792,
        0xc9e9e920,
        0x87cece49,
        0xaa5555ff,
        0x50282878,
        0xa5dfdf7a,
        0x038c8c8f,
        0x59a1a1f8,
        0x09898980,
        0x1a0d0d17,
        0x65bfbfda,
        0xd7e6e631,
        0x844242c6,
        0xd06868b8,
        0x824141c3,
        0x299999b0,
        0x5a2d2d77,
        0x1e0f0f11,
        0x7bb0b0cb,
        0xa85454fc,
        0x6dbbbbd6,
        0x2c16163a
    ];
    var T2 = [
        0xa5c66363,
        0x84f87c7c,
        0x99ee7777,
        0x8df67b7b,
        0x0dfff2f2,
        0xbdd66b6b,
        0xb1de6f6f,
        0x5491c5c5,
        0x50603030,
        0x03020101,
        0xa9ce6767,
        0x7d562b2b,
        0x19e7fefe,
        0x62b5d7d7,
        0xe64dabab,
        0x9aec7676,
        0x458fcaca,
        0x9d1f8282,
        0x4089c9c9,
        0x87fa7d7d,
        0x15effafa,
        0xebb25959,
        0xc98e4747,
        0x0bfbf0f0,
        0xec41adad,
        0x67b3d4d4,
        0xfd5fa2a2,
        0xea45afaf,
        0xbf239c9c,
        0xf753a4a4,
        0x96e47272,
        0x5b9bc0c0,
        0xc275b7b7,
        0x1ce1fdfd,
        0xae3d9393,
        0x6a4c2626,
        0x5a6c3636,
        0x417e3f3f,
        0x02f5f7f7,
        0x4f83cccc,
        0x5c683434,
        0xf451a5a5,
        0x34d1e5e5,
        0x08f9f1f1,
        0x93e27171,
        0x73abd8d8,
        0x53623131,
        0x3f2a1515,
        0x0c080404,
        0x5295c7c7,
        0x65462323,
        0x5e9dc3c3,
        0x28301818,
        0xa1379696,
        0x0f0a0505,
        0xb52f9a9a,
        0x090e0707,
        0x36241212,
        0x9b1b8080,
        0x3ddfe2e2,
        0x26cdebeb,
        0x694e2727,
        0xcd7fb2b2,
        0x9fea7575,
        0x1b120909,
        0x9e1d8383,
        0x74582c2c,
        0x2e341a1a,
        0x2d361b1b,
        0xb2dc6e6e,
        0xeeb45a5a,
        0xfb5ba0a0,
        0xf6a45252,
        0x4d763b3b,
        0x61b7d6d6,
        0xce7db3b3,
        0x7b522929,
        0x3edde3e3,
        0x715e2f2f,
        0x97138484,
        0xf5a65353,
        0x68b9d1d1,
        0x00000000,
        0x2cc1eded,
        0x60402020,
        0x1fe3fcfc,
        0xc879b1b1,
        0xedb65b5b,
        0xbed46a6a,
        0x468dcbcb,
        0xd967bebe,
        0x4b723939,
        0xde944a4a,
        0xd4984c4c,
        0xe8b05858,
        0x4a85cfcf,
        0x6bbbd0d0,
        0x2ac5efef,
        0xe54faaaa,
        0x16edfbfb,
        0xc5864343,
        0xd79a4d4d,
        0x55663333,
        0x94118585,
        0xcf8a4545,
        0x10e9f9f9,
        0x06040202,
        0x81fe7f7f,
        0xf0a05050,
        0x44783c3c,
        0xba259f9f,
        0xe34ba8a8,
        0xf3a25151,
        0xfe5da3a3,
        0xc0804040,
        0x8a058f8f,
        0xad3f9292,
        0xbc219d9d,
        0x48703838,
        0x04f1f5f5,
        0xdf63bcbc,
        0xc177b6b6,
        0x75afdada,
        0x63422121,
        0x30201010,
        0x1ae5ffff,
        0x0efdf3f3,
        0x6dbfd2d2,
        0x4c81cdcd,
        0x14180c0c,
        0x35261313,
        0x2fc3ecec,
        0xe1be5f5f,
        0xa2359797,
        0xcc884444,
        0x392e1717,
        0x5793c4c4,
        0xf255a7a7,
        0x82fc7e7e,
        0x477a3d3d,
        0xacc86464,
        0xe7ba5d5d,
        0x2b321919,
        0x95e67373,
        0xa0c06060,
        0x98198181,
        0xd19e4f4f,
        0x7fa3dcdc,
        0x66442222,
        0x7e542a2a,
        0xab3b9090,
        0x830b8888,
        0xca8c4646,
        0x29c7eeee,
        0xd36bb8b8,
        0x3c281414,
        0x79a7dede,
        0xe2bc5e5e,
        0x1d160b0b,
        0x76addbdb,
        0x3bdbe0e0,
        0x56643232,
        0x4e743a3a,
        0x1e140a0a,
        0xdb924949,
        0x0a0c0606,
        0x6c482424,
        0xe4b85c5c,
        0x5d9fc2c2,
        0x6ebdd3d3,
        0xef43acac,
        0xa6c46262,
        0xa8399191,
        0xa4319595,
        0x37d3e4e4,
        0x8bf27979,
        0x32d5e7e7,
        0x438bc8c8,
        0x596e3737,
        0xb7da6d6d,
        0x8c018d8d,
        0x64b1d5d5,
        0xd29c4e4e,
        0xe049a9a9,
        0xb4d86c6c,
        0xfaac5656,
        0x07f3f4f4,
        0x25cfeaea,
        0xafca6565,
        0x8ef47a7a,
        0xe947aeae,
        0x18100808,
        0xd56fbaba,
        0x88f07878,
        0x6f4a2525,
        0x725c2e2e,
        0x24381c1c,
        0xf157a6a6,
        0xc773b4b4,
        0x5197c6c6,
        0x23cbe8e8,
        0x7ca1dddd,
        0x9ce87474,
        0x213e1f1f,
        0xdd964b4b,
        0xdc61bdbd,
        0x860d8b8b,
        0x850f8a8a,
        0x90e07070,
        0x427c3e3e,
        0xc471b5b5,
        0xaacc6666,
        0xd8904848,
        0x05060303,
        0x01f7f6f6,
        0x121c0e0e,
        0xa3c26161,
        0x5f6a3535,
        0xf9ae5757,
        0xd069b9b9,
        0x91178686,
        0x5899c1c1,
        0x273a1d1d,
        0xb9279e9e,
        0x38d9e1e1,
        0x13ebf8f8,
        0xb32b9898,
        0x33221111,
        0xbbd26969,
        0x70a9d9d9,
        0x89078e8e,
        0xa7339494,
        0xb62d9b9b,
        0x223c1e1e,
        0x92158787,
        0x20c9e9e9,
        0x4987cece,
        0xffaa5555,
        0x78502828,
        0x7aa5dfdf,
        0x8f038c8c,
        0xf859a1a1,
        0x80098989,
        0x171a0d0d,
        0xda65bfbf,
        0x31d7e6e6,
        0xc6844242,
        0xb8d06868,
        0xc3824141,
        0xb0299999,
        0x775a2d2d,
        0x111e0f0f,
        0xcb7bb0b0,
        0xfca85454,
        0xd66dbbbb,
        0x3a2c1616
    ];
    var T3 = [
        0x63a5c663,
        0x7c84f87c,
        0x7799ee77,
        0x7b8df67b,
        0xf20dfff2,
        0x6bbdd66b,
        0x6fb1de6f,
        0xc55491c5,
        0x30506030,
        0x01030201,
        0x67a9ce67,
        0x2b7d562b,
        0xfe19e7fe,
        0xd762b5d7,
        0xabe64dab,
        0x769aec76,
        0xca458fca,
        0x829d1f82,
        0xc94089c9,
        0x7d87fa7d,
        0xfa15effa,
        0x59ebb259,
        0x47c98e47,
        0xf00bfbf0,
        0xadec41ad,
        0xd467b3d4,
        0xa2fd5fa2,
        0xafea45af,
        0x9cbf239c,
        0xa4f753a4,
        0x7296e472,
        0xc05b9bc0,
        0xb7c275b7,
        0xfd1ce1fd,
        0x93ae3d93,
        0x266a4c26,
        0x365a6c36,
        0x3f417e3f,
        0xf702f5f7,
        0xcc4f83cc,
        0x345c6834,
        0xa5f451a5,
        0xe534d1e5,
        0xf108f9f1,
        0x7193e271,
        0xd873abd8,
        0x31536231,
        0x153f2a15,
        0x040c0804,
        0xc75295c7,
        0x23654623,
        0xc35e9dc3,
        0x18283018,
        0x96a13796,
        0x050f0a05,
        0x9ab52f9a,
        0x07090e07,
        0x12362412,
        0x809b1b80,
        0xe23ddfe2,
        0xeb26cdeb,
        0x27694e27,
        0xb2cd7fb2,
        0x759fea75,
        0x091b1209,
        0x839e1d83,
        0x2c74582c,
        0x1a2e341a,
        0x1b2d361b,
        0x6eb2dc6e,
        0x5aeeb45a,
        0xa0fb5ba0,
        0x52f6a452,
        0x3b4d763b,
        0xd661b7d6,
        0xb3ce7db3,
        0x297b5229,
        0xe33edde3,
        0x2f715e2f,
        0x84971384,
        0x53f5a653,
        0xd168b9d1,
        0x00000000,
        0xed2cc1ed,
        0x20604020,
        0xfc1fe3fc,
        0xb1c879b1,
        0x5bedb65b,
        0x6abed46a,
        0xcb468dcb,
        0xbed967be,
        0x394b7239,
        0x4ade944a,
        0x4cd4984c,
        0x58e8b058,
        0xcf4a85cf,
        0xd06bbbd0,
        0xef2ac5ef,
        0xaae54faa,
        0xfb16edfb,
        0x43c58643,
        0x4dd79a4d,
        0x33556633,
        0x85941185,
        0x45cf8a45,
        0xf910e9f9,
        0x02060402,
        0x7f81fe7f,
        0x50f0a050,
        0x3c44783c,
        0x9fba259f,
        0xa8e34ba8,
        0x51f3a251,
        0xa3fe5da3,
        0x40c08040,
        0x8f8a058f,
        0x92ad3f92,
        0x9dbc219d,
        0x38487038,
        0xf504f1f5,
        0xbcdf63bc,
        0xb6c177b6,
        0xda75afda,
        0x21634221,
        0x10302010,
        0xff1ae5ff,
        0xf30efdf3,
        0xd26dbfd2,
        0xcd4c81cd,
        0x0c14180c,
        0x13352613,
        0xec2fc3ec,
        0x5fe1be5f,
        0x97a23597,
        0x44cc8844,
        0x17392e17,
        0xc45793c4,
        0xa7f255a7,
        0x7e82fc7e,
        0x3d477a3d,
        0x64acc864,
        0x5de7ba5d,
        0x192b3219,
        0x7395e673,
        0x60a0c060,
        0x81981981,
        0x4fd19e4f,
        0xdc7fa3dc,
        0x22664422,
        0x2a7e542a,
        0x90ab3b90,
        0x88830b88,
        0x46ca8c46,
        0xee29c7ee,
        0xb8d36bb8,
        0x143c2814,
        0xde79a7de,
        0x5ee2bc5e,
        0x0b1d160b,
        0xdb76addb,
        0xe03bdbe0,
        0x32566432,
        0x3a4e743a,
        0x0a1e140a,
        0x49db9249,
        0x060a0c06,
        0x246c4824,
        0x5ce4b85c,
        0xc25d9fc2,
        0xd36ebdd3,
        0xacef43ac,
        0x62a6c462,
        0x91a83991,
        0x95a43195,
        0xe437d3e4,
        0x798bf279,
        0xe732d5e7,
        0xc8438bc8,
        0x37596e37,
        0x6db7da6d,
        0x8d8c018d,
        0xd564b1d5,
        0x4ed29c4e,
        0xa9e049a9,
        0x6cb4d86c,
        0x56faac56,
        0xf407f3f4,
        0xea25cfea,
        0x65afca65,
        0x7a8ef47a,
        0xaee947ae,
        0x08181008,
        0xbad56fba,
        0x7888f078,
        0x256f4a25,
        0x2e725c2e,
        0x1c24381c,
        0xa6f157a6,
        0xb4c773b4,
        0xc65197c6,
        0xe823cbe8,
        0xdd7ca1dd,
        0x749ce874,
        0x1f213e1f,
        0x4bdd964b,
        0xbddc61bd,
        0x8b860d8b,
        0x8a850f8a,
        0x7090e070,
        0x3e427c3e,
        0xb5c471b5,
        0x66aacc66,
        0x48d89048,
        0x03050603,
        0xf601f7f6,
        0x0e121c0e,
        0x61a3c261,
        0x355f6a35,
        0x57f9ae57,
        0xb9d069b9,
        0x86911786,
        0xc15899c1,
        0x1d273a1d,
        0x9eb9279e,
        0xe138d9e1,
        0xf813ebf8,
        0x98b32b98,
        0x11332211,
        0x69bbd269,
        0xd970a9d9,
        0x8e89078e,
        0x94a73394,
        0x9bb62d9b,
        0x1e223c1e,
        0x87921587,
        0xe920c9e9,
        0xce4987ce,
        0x55ffaa55,
        0x28785028,
        0xdf7aa5df,
        0x8c8f038c,
        0xa1f859a1,
        0x89800989,
        0x0d171a0d,
        0xbfda65bf,
        0xe631d7e6,
        0x42c68442,
        0x68b8d068,
        0x41c38241,
        0x99b02999,
        0x2d775a2d,
        0x0f111e0f,
        0xb0cb7bb0,
        0x54fca854,
        0xbbd66dbb,
        0x163a2c16
    ];
    var T4 = [
        0x6363a5c6,
        0x7c7c84f8,
        0x777799ee,
        0x7b7b8df6,
        0xf2f20dff,
        0x6b6bbdd6,
        0x6f6fb1de,
        0xc5c55491,
        0x30305060,
        0x01010302,
        0x6767a9ce,
        0x2b2b7d56,
        0xfefe19e7,
        0xd7d762b5,
        0xababe64d,
        0x76769aec,
        0xcaca458f,
        0x82829d1f,
        0xc9c94089,
        0x7d7d87fa,
        0xfafa15ef,
        0x5959ebb2,
        0x4747c98e,
        0xf0f00bfb,
        0xadadec41,
        0xd4d467b3,
        0xa2a2fd5f,
        0xafafea45,
        0x9c9cbf23,
        0xa4a4f753,
        0x727296e4,
        0xc0c05b9b,
        0xb7b7c275,
        0xfdfd1ce1,
        0x9393ae3d,
        0x26266a4c,
        0x36365a6c,
        0x3f3f417e,
        0xf7f702f5,
        0xcccc4f83,
        0x34345c68,
        0xa5a5f451,
        0xe5e534d1,
        0xf1f108f9,
        0x717193e2,
        0xd8d873ab,
        0x31315362,
        0x15153f2a,
        0x04040c08,
        0xc7c75295,
        0x23236546,
        0xc3c35e9d,
        0x18182830,
        0x9696a137,
        0x05050f0a,
        0x9a9ab52f,
        0x0707090e,
        0x12123624,
        0x80809b1b,
        0xe2e23ddf,
        0xebeb26cd,
        0x2727694e,
        0xb2b2cd7f,
        0x75759fea,
        0x09091b12,
        0x83839e1d,
        0x2c2c7458,
        0x1a1a2e34,
        0x1b1b2d36,
        0x6e6eb2dc,
        0x5a5aeeb4,
        0xa0a0fb5b,
        0x5252f6a4,
        0x3b3b4d76,
        0xd6d661b7,
        0xb3b3ce7d,
        0x29297b52,
        0xe3e33edd,
        0x2f2f715e,
        0x84849713,
        0x5353f5a6,
        0xd1d168b9,
        0x00000000,
        0xeded2cc1,
        0x20206040,
        0xfcfc1fe3,
        0xb1b1c879,
        0x5b5bedb6,
        0x6a6abed4,
        0xcbcb468d,
        0xbebed967,
        0x39394b72,
        0x4a4ade94,
        0x4c4cd498,
        0x5858e8b0,
        0xcfcf4a85,
        0xd0d06bbb,
        0xefef2ac5,
        0xaaaae54f,
        0xfbfb16ed,
        0x4343c586,
        0x4d4dd79a,
        0x33335566,
        0x85859411,
        0x4545cf8a,
        0xf9f910e9,
        0x02020604,
        0x7f7f81fe,
        0x5050f0a0,
        0x3c3c4478,
        0x9f9fba25,
        0xa8a8e34b,
        0x5151f3a2,
        0xa3a3fe5d,
        0x4040c080,
        0x8f8f8a05,
        0x9292ad3f,
        0x9d9dbc21,
        0x38384870,
        0xf5f504f1,
        0xbcbcdf63,
        0xb6b6c177,
        0xdada75af,
        0x21216342,
        0x10103020,
        0xffff1ae5,
        0xf3f30efd,
        0xd2d26dbf,
        0xcdcd4c81,
        0x0c0c1418,
        0x13133526,
        0xecec2fc3,
        0x5f5fe1be,
        0x9797a235,
        0x4444cc88,
        0x1717392e,
        0xc4c45793,
        0xa7a7f255,
        0x7e7e82fc,
        0x3d3d477a,
        0x6464acc8,
        0x5d5de7ba,
        0x19192b32,
        0x737395e6,
        0x6060a0c0,
        0x81819819,
        0x4f4fd19e,
        0xdcdc7fa3,
        0x22226644,
        0x2a2a7e54,
        0x9090ab3b,
        0x8888830b,
        0x4646ca8c,
        0xeeee29c7,
        0xb8b8d36b,
        0x14143c28,
        0xdede79a7,
        0x5e5ee2bc,
        0x0b0b1d16,
        0xdbdb76ad,
        0xe0e03bdb,
        0x32325664,
        0x3a3a4e74,
        0x0a0a1e14,
        0x4949db92,
        0x06060a0c,
        0x24246c48,
        0x5c5ce4b8,
        0xc2c25d9f,
        0xd3d36ebd,
        0xacacef43,
        0x6262a6c4,
        0x9191a839,
        0x9595a431,
        0xe4e437d3,
        0x79798bf2,
        0xe7e732d5,
        0xc8c8438b,
        0x3737596e,
        0x6d6db7da,
        0x8d8d8c01,
        0xd5d564b1,
        0x4e4ed29c,
        0xa9a9e049,
        0x6c6cb4d8,
        0x5656faac,
        0xf4f407f3,
        0xeaea25cf,
        0x6565afca,
        0x7a7a8ef4,
        0xaeaee947,
        0x08081810,
        0xbabad56f,
        0x787888f0,
        0x25256f4a,
        0x2e2e725c,
        0x1c1c2438,
        0xa6a6f157,
        0xb4b4c773,
        0xc6c65197,
        0xe8e823cb,
        0xdddd7ca1,
        0x74749ce8,
        0x1f1f213e,
        0x4b4bdd96,
        0xbdbddc61,
        0x8b8b860d,
        0x8a8a850f,
        0x707090e0,
        0x3e3e427c,
        0xb5b5c471,
        0x6666aacc,
        0x4848d890,
        0x03030506,
        0xf6f601f7,
        0x0e0e121c,
        0x6161a3c2,
        0x35355f6a,
        0x5757f9ae,
        0xb9b9d069,
        0x86869117,
        0xc1c15899,
        0x1d1d273a,
        0x9e9eb927,
        0xe1e138d9,
        0xf8f813eb,
        0x9898b32b,
        0x11113322,
        0x6969bbd2,
        0xd9d970a9,
        0x8e8e8907,
        0x9494a733,
        0x9b9bb62d,
        0x1e1e223c,
        0x87879215,
        0xe9e920c9,
        0xcece4987,
        0x5555ffaa,
        0x28287850,
        0xdfdf7aa5,
        0x8c8c8f03,
        0xa1a1f859,
        0x89898009,
        0x0d0d171a,
        0xbfbfda65,
        0xe6e631d7,
        0x4242c684,
        0x6868b8d0,
        0x4141c382,
        0x9999b029,
        0x2d2d775a,
        0x0f0f111e,
        0xb0b0cb7b,
        0x5454fca8,
        0xbbbbd66d,
        0x16163a2c
    ];
    // Transformations for decryption
    var T5 = [
        0x51f4a750,
        0x7e416553,
        0x1a17a4c3,
        0x3a275e96,
        0x3bab6bcb,
        0x1f9d45f1,
        0xacfa58ab,
        0x4be30393,
        0x2030fa55,
        0xad766df6,
        0x88cc7691,
        0xf5024c25,
        0x4fe5d7fc,
        0xc52acbd7,
        0x26354480,
        0xb562a38f,
        0xdeb15a49,
        0x25ba1b67,
        0x45ea0e98,
        0x5dfec0e1,
        0xc32f7502,
        0x814cf012,
        0x8d4697a3,
        0x6bd3f9c6,
        0x038f5fe7,
        0x15929c95,
        0xbf6d7aeb,
        0x955259da,
        0xd4be832d,
        0x587421d3,
        0x49e06929,
        0x8ec9c844,
        0x75c2896a,
        0xf48e7978,
        0x99583e6b,
        0x27b971dd,
        0xbee14fb6,
        0xf088ad17,
        0xc920ac66,
        0x7dce3ab4,
        0x63df4a18,
        0xe51a3182,
        0x97513360,
        0x62537f45,
        0xb16477e0,
        0xbb6bae84,
        0xfe81a01c,
        0xf9082b94,
        0x70486858,
        0x8f45fd19,
        0x94de6c87,
        0x527bf8b7,
        0xab73d323,
        0x724b02e2,
        0xe31f8f57,
        0x6655ab2a,
        0xb2eb2807,
        0x2fb5c203,
        0x86c57b9a,
        0xd33708a5,
        0x302887f2,
        0x23bfa5b2,
        0x02036aba,
        0xed16825c,
        0x8acf1c2b,
        0xa779b492,
        0xf307f2f0,
        0x4e69e2a1,
        0x65daf4cd,
        0x0605bed5,
        0xd134621f,
        0xc4a6fe8a,
        0x342e539d,
        0xa2f355a0,
        0x058ae132,
        0xa4f6eb75,
        0x0b83ec39,
        0x4060efaa,
        0x5e719f06,
        0xbd6e1051,
        0x3e218af9,
        0x96dd063d,
        0xdd3e05ae,
        0x4de6bd46,
        0x91548db5,
        0x71c45d05,
        0x0406d46f,
        0x605015ff,
        0x1998fb24,
        0xd6bde997,
        0x894043cc,
        0x67d99e77,
        0xb0e842bd,
        0x07898b88,
        0xe7195b38,
        0x79c8eedb,
        0xa17c0a47,
        0x7c420fe9,
        0xf8841ec9,
        0x00000000,
        0x09808683,
        0x322bed48,
        0x1e1170ac,
        0x6c5a724e,
        0xfd0efffb,
        0x0f853856,
        0x3daed51e,
        0x362d3927,
        0x0a0fd964,
        0x685ca621,
        0x9b5b54d1,
        0x24362e3a,
        0x0c0a67b1,
        0x9357e70f,
        0xb4ee96d2,
        0x1b9b919e,
        0x80c0c54f,
        0x61dc20a2,
        0x5a774b69,
        0x1c121a16,
        0xe293ba0a,
        0xc0a02ae5,
        0x3c22e043,
        0x121b171d,
        0x0e090d0b,
        0xf28bc7ad,
        0x2db6a8b9,
        0x141ea9c8,
        0x57f11985,
        0xaf75074c,
        0xee99ddbb,
        0xa37f60fd,
        0xf701269f,
        0x5c72f5bc,
        0x44663bc5,
        0x5bfb7e34,
        0x8b432976,
        0xcb23c6dc,
        0xb6edfc68,
        0xb8e4f163,
        0xd731dcca,
        0x42638510,
        0x13972240,
        0x84c61120,
        0x854a247d,
        0xd2bb3df8,
        0xaef93211,
        0xc729a16d,
        0x1d9e2f4b,
        0xdcb230f3,
        0x0d8652ec,
        0x77c1e3d0,
        0x2bb3166c,
        0xa970b999,
        0x119448fa,
        0x47e96422,
        0xa8fc8cc4,
        0xa0f03f1a,
        0x567d2cd8,
        0x223390ef,
        0x87494ec7,
        0xd938d1c1,
        0x8ccaa2fe,
        0x98d40b36,
        0xa6f581cf,
        0xa57ade28,
        0xdab78e26,
        0x3fadbfa4,
        0x2c3a9de4,
        0x5078920d,
        0x6a5fcc9b,
        0x547e4662,
        0xf68d13c2,
        0x90d8b8e8,
        0x2e39f75e,
        0x82c3aff5,
        0x9f5d80be,
        0x69d0937c,
        0x6fd52da9,
        0xcf2512b3,
        0xc8ac993b,
        0x10187da7,
        0xe89c636e,
        0xdb3bbb7b,
        0xcd267809,
        0x6e5918f4,
        0xec9ab701,
        0x834f9aa8,
        0xe6956e65,
        0xaaffe67e,
        0x21bccf08,
        0xef15e8e6,
        0xbae79bd9,
        0x4a6f36ce,
        0xea9f09d4,
        0x29b07cd6,
        0x31a4b2af,
        0x2a3f2331,
        0xc6a59430,
        0x35a266c0,
        0x744ebc37,
        0xfc82caa6,
        0xe090d0b0,
        0x33a7d815,
        0xf104984a,
        0x41ecdaf7,
        0x7fcd500e,
        0x1791f62f,
        0x764dd68d,
        0x43efb04d,
        0xccaa4d54,
        0xe49604df,
        0x9ed1b5e3,
        0x4c6a881b,
        0xc12c1fb8,
        0x4665517f,
        0x9d5eea04,
        0x018c355d,
        0xfa877473,
        0xfb0b412e,
        0xb3671d5a,
        0x92dbd252,
        0xe9105633,
        0x6dd64713,
        0x9ad7618c,
        0x37a10c7a,
        0x59f8148e,
        0xeb133c89,
        0xcea927ee,
        0xb761c935,
        0xe11ce5ed,
        0x7a47b13c,
        0x9cd2df59,
        0x55f2733f,
        0x1814ce79,
        0x73c737bf,
        0x53f7cdea,
        0x5ffdaa5b,
        0xdf3d6f14,
        0x7844db86,
        0xcaaff381,
        0xb968c43e,
        0x3824342c,
        0xc2a3405f,
        0x161dc372,
        0xbce2250c,
        0x283c498b,
        0xff0d9541,
        0x39a80171,
        0x080cb3de,
        0xd8b4e49c,
        0x6456c190,
        0x7bcb8461,
        0xd532b670,
        0x486c5c74,
        0xd0b85742
    ];
    var T6 = [
        0x5051f4a7,
        0x537e4165,
        0xc31a17a4,
        0x963a275e,
        0xcb3bab6b,
        0xf11f9d45,
        0xabacfa58,
        0x934be303,
        0x552030fa,
        0xf6ad766d,
        0x9188cc76,
        0x25f5024c,
        0xfc4fe5d7,
        0xd7c52acb,
        0x80263544,
        0x8fb562a3,
        0x49deb15a,
        0x6725ba1b,
        0x9845ea0e,
        0xe15dfec0,
        0x02c32f75,
        0x12814cf0,
        0xa38d4697,
        0xc66bd3f9,
        0xe7038f5f,
        0x9515929c,
        0xebbf6d7a,
        0xda955259,
        0x2dd4be83,
        0xd3587421,
        0x2949e069,
        0x448ec9c8,
        0x6a75c289,
        0x78f48e79,
        0x6b99583e,
        0xdd27b971,
        0xb6bee14f,
        0x17f088ad,
        0x66c920ac,
        0xb47dce3a,
        0x1863df4a,
        0x82e51a31,
        0x60975133,
        0x4562537f,
        0xe0b16477,
        0x84bb6bae,
        0x1cfe81a0,
        0x94f9082b,
        0x58704868,
        0x198f45fd,
        0x8794de6c,
        0xb7527bf8,
        0x23ab73d3,
        0xe2724b02,
        0x57e31f8f,
        0x2a6655ab,
        0x07b2eb28,
        0x032fb5c2,
        0x9a86c57b,
        0xa5d33708,
        0xf2302887,
        0xb223bfa5,
        0xba02036a,
        0x5ced1682,
        0x2b8acf1c,
        0x92a779b4,
        0xf0f307f2,
        0xa14e69e2,
        0xcd65daf4,
        0xd50605be,
        0x1fd13462,
        0x8ac4a6fe,
        0x9d342e53,
        0xa0a2f355,
        0x32058ae1,
        0x75a4f6eb,
        0x390b83ec,
        0xaa4060ef,
        0x065e719f,
        0x51bd6e10,
        0xf93e218a,
        0x3d96dd06,
        0xaedd3e05,
        0x464de6bd,
        0xb591548d,
        0x0571c45d,
        0x6f0406d4,
        0xff605015,
        0x241998fb,
        0x97d6bde9,
        0xcc894043,
        0x7767d99e,
        0xbdb0e842,
        0x8807898b,
        0x38e7195b,
        0xdb79c8ee,
        0x47a17c0a,
        0xe97c420f,
        0xc9f8841e,
        0x00000000,
        0x83098086,
        0x48322bed,
        0xac1e1170,
        0x4e6c5a72,
        0xfbfd0eff,
        0x560f8538,
        0x1e3daed5,
        0x27362d39,
        0x640a0fd9,
        0x21685ca6,
        0xd19b5b54,
        0x3a24362e,
        0xb10c0a67,
        0x0f9357e7,
        0xd2b4ee96,
        0x9e1b9b91,
        0x4f80c0c5,
        0xa261dc20,
        0x695a774b,
        0x161c121a,
        0x0ae293ba,
        0xe5c0a02a,
        0x433c22e0,
        0x1d121b17,
        0x0b0e090d,
        0xadf28bc7,
        0xb92db6a8,
        0xc8141ea9,
        0x8557f119,
        0x4caf7507,
        0xbbee99dd,
        0xfda37f60,
        0x9ff70126,
        0xbc5c72f5,
        0xc544663b,
        0x345bfb7e,
        0x768b4329,
        0xdccb23c6,
        0x68b6edfc,
        0x63b8e4f1,
        0xcad731dc,
        0x10426385,
        0x40139722,
        0x2084c611,
        0x7d854a24,
        0xf8d2bb3d,
        0x11aef932,
        0x6dc729a1,
        0x4b1d9e2f,
        0xf3dcb230,
        0xec0d8652,
        0xd077c1e3,
        0x6c2bb316,
        0x99a970b9,
        0xfa119448,
        0x2247e964,
        0xc4a8fc8c,
        0x1aa0f03f,
        0xd8567d2c,
        0xef223390,
        0xc787494e,
        0xc1d938d1,
        0xfe8ccaa2,
        0x3698d40b,
        0xcfa6f581,
        0x28a57ade,
        0x26dab78e,
        0xa43fadbf,
        0xe42c3a9d,
        0x0d507892,
        0x9b6a5fcc,
        0x62547e46,
        0xc2f68d13,
        0xe890d8b8,
        0x5e2e39f7,
        0xf582c3af,
        0xbe9f5d80,
        0x7c69d093,
        0xa96fd52d,
        0xb3cf2512,
        0x3bc8ac99,
        0xa710187d,
        0x6ee89c63,
        0x7bdb3bbb,
        0x09cd2678,
        0xf46e5918,
        0x01ec9ab7,
        0xa8834f9a,
        0x65e6956e,
        0x7eaaffe6,
        0x0821bccf,
        0xe6ef15e8,
        0xd9bae79b,
        0xce4a6f36,
        0xd4ea9f09,
        0xd629b07c,
        0xaf31a4b2,
        0x312a3f23,
        0x30c6a594,
        0xc035a266,
        0x37744ebc,
        0xa6fc82ca,
        0xb0e090d0,
        0x1533a7d8,
        0x4af10498,
        0xf741ecda,
        0x0e7fcd50,
        0x2f1791f6,
        0x8d764dd6,
        0x4d43efb0,
        0x54ccaa4d,
        0xdfe49604,
        0xe39ed1b5,
        0x1b4c6a88,
        0xb8c12c1f,
        0x7f466551,
        0x049d5eea,
        0x5d018c35,
        0x73fa8774,
        0x2efb0b41,
        0x5ab3671d,
        0x5292dbd2,
        0x33e91056,
        0x136dd647,
        0x8c9ad761,
        0x7a37a10c,
        0x8e59f814,
        0x89eb133c,
        0xeecea927,
        0x35b761c9,
        0xede11ce5,
        0x3c7a47b1,
        0x599cd2df,
        0x3f55f273,
        0x791814ce,
        0xbf73c737,
        0xea53f7cd,
        0x5b5ffdaa,
        0x14df3d6f,
        0x867844db,
        0x81caaff3,
        0x3eb968c4,
        0x2c382434,
        0x5fc2a340,
        0x72161dc3,
        0x0cbce225,
        0x8b283c49,
        0x41ff0d95,
        0x7139a801,
        0xde080cb3,
        0x9cd8b4e4,
        0x906456c1,
        0x617bcb84,
        0x70d532b6,
        0x74486c5c,
        0x42d0b857
    ];
    var T7 = [
        0xa75051f4,
        0x65537e41,
        0xa4c31a17,
        0x5e963a27,
        0x6bcb3bab,
        0x45f11f9d,
        0x58abacfa,
        0x03934be3,
        0xfa552030,
        0x6df6ad76,
        0x769188cc,
        0x4c25f502,
        0xd7fc4fe5,
        0xcbd7c52a,
        0x44802635,
        0xa38fb562,
        0x5a49deb1,
        0x1b6725ba,
        0x0e9845ea,
        0xc0e15dfe,
        0x7502c32f,
        0xf012814c,
        0x97a38d46,
        0xf9c66bd3,
        0x5fe7038f,
        0x9c951592,
        0x7aebbf6d,
        0x59da9552,
        0x832dd4be,
        0x21d35874,
        0x692949e0,
        0xc8448ec9,
        0x896a75c2,
        0x7978f48e,
        0x3e6b9958,
        0x71dd27b9,
        0x4fb6bee1,
        0xad17f088,
        0xac66c920,
        0x3ab47dce,
        0x4a1863df,
        0x3182e51a,
        0x33609751,
        0x7f456253,
        0x77e0b164,
        0xae84bb6b,
        0xa01cfe81,
        0x2b94f908,
        0x68587048,
        0xfd198f45,
        0x6c8794de,
        0xf8b7527b,
        0xd323ab73,
        0x02e2724b,
        0x8f57e31f,
        0xab2a6655,
        0x2807b2eb,
        0xc2032fb5,
        0x7b9a86c5,
        0x08a5d337,
        0x87f23028,
        0xa5b223bf,
        0x6aba0203,
        0x825ced16,
        0x1c2b8acf,
        0xb492a779,
        0xf2f0f307,
        0xe2a14e69,
        0xf4cd65da,
        0xbed50605,
        0x621fd134,
        0xfe8ac4a6,
        0x539d342e,
        0x55a0a2f3,
        0xe132058a,
        0xeb75a4f6,
        0xec390b83,
        0xefaa4060,
        0x9f065e71,
        0x1051bd6e,
        0x8af93e21,
        0x063d96dd,
        0x05aedd3e,
        0xbd464de6,
        0x8db59154,
        0x5d0571c4,
        0xd46f0406,
        0x15ff6050,
        0xfb241998,
        0xe997d6bd,
        0x43cc8940,
        0x9e7767d9,
        0x42bdb0e8,
        0x8b880789,
        0x5b38e719,
        0xeedb79c8,
        0x0a47a17c,
        0x0fe97c42,
        0x1ec9f884,
        0x00000000,
        0x86830980,
        0xed48322b,
        0x70ac1e11,
        0x724e6c5a,
        0xfffbfd0e,
        0x38560f85,
        0xd51e3dae,
        0x3927362d,
        0xd9640a0f,
        0xa621685c,
        0x54d19b5b,
        0x2e3a2436,
        0x67b10c0a,
        0xe70f9357,
        0x96d2b4ee,
        0x919e1b9b,
        0xc54f80c0,
        0x20a261dc,
        0x4b695a77,
        0x1a161c12,
        0xba0ae293,
        0x2ae5c0a0,
        0xe0433c22,
        0x171d121b,
        0x0d0b0e09,
        0xc7adf28b,
        0xa8b92db6,
        0xa9c8141e,
        0x198557f1,
        0x074caf75,
        0xddbbee99,
        0x60fda37f,
        0x269ff701,
        0xf5bc5c72,
        0x3bc54466,
        0x7e345bfb,
        0x29768b43,
        0xc6dccb23,
        0xfc68b6ed,
        0xf163b8e4,
        0xdccad731,
        0x85104263,
        0x22401397,
        0x112084c6,
        0x247d854a,
        0x3df8d2bb,
        0x3211aef9,
        0xa16dc729,
        0x2f4b1d9e,
        0x30f3dcb2,
        0x52ec0d86,
        0xe3d077c1,
        0x166c2bb3,
        0xb999a970,
        0x48fa1194,
        0x642247e9,
        0x8cc4a8fc,
        0x3f1aa0f0,
        0x2cd8567d,
        0x90ef2233,
        0x4ec78749,
        0xd1c1d938,
        0xa2fe8cca,
        0x0b3698d4,
        0x81cfa6f5,
        0xde28a57a,
        0x8e26dab7,
        0xbfa43fad,
        0x9de42c3a,
        0x920d5078,
        0xcc9b6a5f,
        0x4662547e,
        0x13c2f68d,
        0xb8e890d8,
        0xf75e2e39,
        0xaff582c3,
        0x80be9f5d,
        0x937c69d0,
        0x2da96fd5,
        0x12b3cf25,
        0x993bc8ac,
        0x7da71018,
        0x636ee89c,
        0xbb7bdb3b,
        0x7809cd26,
        0x18f46e59,
        0xb701ec9a,
        0x9aa8834f,
        0x6e65e695,
        0xe67eaaff,
        0xcf0821bc,
        0xe8e6ef15,
        0x9bd9bae7,
        0x36ce4a6f,
        0x09d4ea9f,
        0x7cd629b0,
        0xb2af31a4,
        0x23312a3f,
        0x9430c6a5,
        0x66c035a2,
        0xbc37744e,
        0xcaa6fc82,
        0xd0b0e090,
        0xd81533a7,
        0x984af104,
        0xdaf741ec,
        0x500e7fcd,
        0xf62f1791,
        0xd68d764d,
        0xb04d43ef,
        0x4d54ccaa,
        0x04dfe496,
        0xb5e39ed1,
        0x881b4c6a,
        0x1fb8c12c,
        0x517f4665,
        0xea049d5e,
        0x355d018c,
        0x7473fa87,
        0x412efb0b,
        0x1d5ab367,
        0xd25292db,
        0x5633e910,
        0x47136dd6,
        0x618c9ad7,
        0x0c7a37a1,
        0x148e59f8,
        0x3c89eb13,
        0x27eecea9,
        0xc935b761,
        0xe5ede11c,
        0xb13c7a47,
        0xdf599cd2,
        0x733f55f2,
        0xce791814,
        0x37bf73c7,
        0xcdea53f7,
        0xaa5b5ffd,
        0x6f14df3d,
        0xdb867844,
        0xf381caaf,
        0xc43eb968,
        0x342c3824,
        0x405fc2a3,
        0xc372161d,
        0x250cbce2,
        0x498b283c,
        0x9541ff0d,
        0x017139a8,
        0xb3de080c,
        0xe49cd8b4,
        0xc1906456,
        0x84617bcb,
        0xb670d532,
        0x5c74486c,
        0x5742d0b8
    ];
    var T8 = [
        0xf4a75051,
        0x4165537e,
        0x17a4c31a,
        0x275e963a,
        0xab6bcb3b,
        0x9d45f11f,
        0xfa58abac,
        0xe303934b,
        0x30fa5520,
        0x766df6ad,
        0xcc769188,
        0x024c25f5,
        0xe5d7fc4f,
        0x2acbd7c5,
        0x35448026,
        0x62a38fb5,
        0xb15a49de,
        0xba1b6725,
        0xea0e9845,
        0xfec0e15d,
        0x2f7502c3,
        0x4cf01281,
        0x4697a38d,
        0xd3f9c66b,
        0x8f5fe703,
        0x929c9515,
        0x6d7aebbf,
        0x5259da95,
        0xbe832dd4,
        0x7421d358,
        0xe0692949,
        0xc9c8448e,
        0xc2896a75,
        0x8e7978f4,
        0x583e6b99,
        0xb971dd27,
        0xe14fb6be,
        0x88ad17f0,
        0x20ac66c9,
        0xce3ab47d,
        0xdf4a1863,
        0x1a3182e5,
        0x51336097,
        0x537f4562,
        0x6477e0b1,
        0x6bae84bb,
        0x81a01cfe,
        0x082b94f9,
        0x48685870,
        0x45fd198f,
        0xde6c8794,
        0x7bf8b752,
        0x73d323ab,
        0x4b02e272,
        0x1f8f57e3,
        0x55ab2a66,
        0xeb2807b2,
        0xb5c2032f,
        0xc57b9a86,
        0x3708a5d3,
        0x2887f230,
        0xbfa5b223,
        0x036aba02,
        0x16825ced,
        0xcf1c2b8a,
        0x79b492a7,
        0x07f2f0f3,
        0x69e2a14e,
        0xdaf4cd65,
        0x05bed506,
        0x34621fd1,
        0xa6fe8ac4,
        0x2e539d34,
        0xf355a0a2,
        0x8ae13205,
        0xf6eb75a4,
        0x83ec390b,
        0x60efaa40,
        0x719f065e,
        0x6e1051bd,
        0x218af93e,
        0xdd063d96,
        0x3e05aedd,
        0xe6bd464d,
        0x548db591,
        0xc45d0571,
        0x06d46f04,
        0x5015ff60,
        0x98fb2419,
        0xbde997d6,
        0x4043cc89,
        0xd99e7767,
        0xe842bdb0,
        0x898b8807,
        0x195b38e7,
        0xc8eedb79,
        0x7c0a47a1,
        0x420fe97c,
        0x841ec9f8,
        0x00000000,
        0x80868309,
        0x2bed4832,
        0x1170ac1e,
        0x5a724e6c,
        0x0efffbfd,
        0x8538560f,
        0xaed51e3d,
        0x2d392736,
        0x0fd9640a,
        0x5ca62168,
        0x5b54d19b,
        0x362e3a24,
        0x0a67b10c,
        0x57e70f93,
        0xee96d2b4,
        0x9b919e1b,
        0xc0c54f80,
        0xdc20a261,
        0x774b695a,
        0x121a161c,
        0x93ba0ae2,
        0xa02ae5c0,
        0x22e0433c,
        0x1b171d12,
        0x090d0b0e,
        0x8bc7adf2,
        0xb6a8b92d,
        0x1ea9c814,
        0xf1198557,
        0x75074caf,
        0x99ddbbee,
        0x7f60fda3,
        0x01269ff7,
        0x72f5bc5c,
        0x663bc544,
        0xfb7e345b,
        0x4329768b,
        0x23c6dccb,
        0xedfc68b6,
        0xe4f163b8,
        0x31dccad7,
        0x63851042,
        0x97224013,
        0xc6112084,
        0x4a247d85,
        0xbb3df8d2,
        0xf93211ae,
        0x29a16dc7,
        0x9e2f4b1d,
        0xb230f3dc,
        0x8652ec0d,
        0xc1e3d077,
        0xb3166c2b,
        0x70b999a9,
        0x9448fa11,
        0xe9642247,
        0xfc8cc4a8,
        0xf03f1aa0,
        0x7d2cd856,
        0x3390ef22,
        0x494ec787,
        0x38d1c1d9,
        0xcaa2fe8c,
        0xd40b3698,
        0xf581cfa6,
        0x7ade28a5,
        0xb78e26da,
        0xadbfa43f,
        0x3a9de42c,
        0x78920d50,
        0x5fcc9b6a,
        0x7e466254,
        0x8d13c2f6,
        0xd8b8e890,
        0x39f75e2e,
        0xc3aff582,
        0x5d80be9f,
        0xd0937c69,
        0xd52da96f,
        0x2512b3cf,
        0xac993bc8,
        0x187da710,
        0x9c636ee8,
        0x3bbb7bdb,
        0x267809cd,
        0x5918f46e,
        0x9ab701ec,
        0x4f9aa883,
        0x956e65e6,
        0xffe67eaa,
        0xbccf0821,
        0x15e8e6ef,
        0xe79bd9ba,
        0x6f36ce4a,
        0x9f09d4ea,
        0xb07cd629,
        0xa4b2af31,
        0x3f23312a,
        0xa59430c6,
        0xa266c035,
        0x4ebc3774,
        0x82caa6fc,
        0x90d0b0e0,
        0xa7d81533,
        0x04984af1,
        0xecdaf741,
        0xcd500e7f,
        0x91f62f17,
        0x4dd68d76,
        0xefb04d43,
        0xaa4d54cc,
        0x9604dfe4,
        0xd1b5e39e,
        0x6a881b4c,
        0x2c1fb8c1,
        0x65517f46,
        0x5eea049d,
        0x8c355d01,
        0x877473fa,
        0x0b412efb,
        0x671d5ab3,
        0xdbd25292,
        0x105633e9,
        0xd647136d,
        0xd7618c9a,
        0xa10c7a37,
        0xf8148e59,
        0x133c89eb,
        0xa927eece,
        0x61c935b7,
        0x1ce5ede1,
        0x47b13c7a,
        0xd2df599c,
        0xf2733f55,
        0x14ce7918,
        0xc737bf73,
        0xf7cdea53,
        0xfdaa5b5f,
        0x3d6f14df,
        0x44db8678,
        0xaff381ca,
        0x68c43eb9,
        0x24342c38,
        0xa3405fc2,
        0x1dc37216,
        0xe2250cbc,
        0x3c498b28,
        0x0d9541ff,
        0xa8017139,
        0x0cb3de08,
        0xb4e49cd8,
        0x56c19064,
        0xcb84617b,
        0x32b670d5,
        0x6c5c7448,
        0xb85742d0
    ];
    // Transformations for decryption key expansion
    var U1 = [
        0x00000000,
        0x0e090d0b,
        0x1c121a16,
        0x121b171d,
        0x3824342c,
        0x362d3927,
        0x24362e3a,
        0x2a3f2331,
        0x70486858,
        0x7e416553,
        0x6c5a724e,
        0x62537f45,
        0x486c5c74,
        0x4665517f,
        0x547e4662,
        0x5a774b69,
        0xe090d0b0,
        0xee99ddbb,
        0xfc82caa6,
        0xf28bc7ad,
        0xd8b4e49c,
        0xd6bde997,
        0xc4a6fe8a,
        0xcaaff381,
        0x90d8b8e8,
        0x9ed1b5e3,
        0x8ccaa2fe,
        0x82c3aff5,
        0xa8fc8cc4,
        0xa6f581cf,
        0xb4ee96d2,
        0xbae79bd9,
        0xdb3bbb7b,
        0xd532b670,
        0xc729a16d,
        0xc920ac66,
        0xe31f8f57,
        0xed16825c,
        0xff0d9541,
        0xf104984a,
        0xab73d323,
        0xa57ade28,
        0xb761c935,
        0xb968c43e,
        0x9357e70f,
        0x9d5eea04,
        0x8f45fd19,
        0x814cf012,
        0x3bab6bcb,
        0x35a266c0,
        0x27b971dd,
        0x29b07cd6,
        0x038f5fe7,
        0x0d8652ec,
        0x1f9d45f1,
        0x119448fa,
        0x4be30393,
        0x45ea0e98,
        0x57f11985,
        0x59f8148e,
        0x73c737bf,
        0x7dce3ab4,
        0x6fd52da9,
        0x61dc20a2,
        0xad766df6,
        0xa37f60fd,
        0xb16477e0,
        0xbf6d7aeb,
        0x955259da,
        0x9b5b54d1,
        0x894043cc,
        0x87494ec7,
        0xdd3e05ae,
        0xd33708a5,
        0xc12c1fb8,
        0xcf2512b3,
        0xe51a3182,
        0xeb133c89,
        0xf9082b94,
        0xf701269f,
        0x4de6bd46,
        0x43efb04d,
        0x51f4a750,
        0x5ffdaa5b,
        0x75c2896a,
        0x7bcb8461,
        0x69d0937c,
        0x67d99e77,
        0x3daed51e,
        0x33a7d815,
        0x21bccf08,
        0x2fb5c203,
        0x058ae132,
        0x0b83ec39,
        0x1998fb24,
        0x1791f62f,
        0x764dd68d,
        0x7844db86,
        0x6a5fcc9b,
        0x6456c190,
        0x4e69e2a1,
        0x4060efaa,
        0x527bf8b7,
        0x5c72f5bc,
        0x0605bed5,
        0x080cb3de,
        0x1a17a4c3,
        0x141ea9c8,
        0x3e218af9,
        0x302887f2,
        0x223390ef,
        0x2c3a9de4,
        0x96dd063d,
        0x98d40b36,
        0x8acf1c2b,
        0x84c61120,
        0xaef93211,
        0xa0f03f1a,
        0xb2eb2807,
        0xbce2250c,
        0xe6956e65,
        0xe89c636e,
        0xfa877473,
        0xf48e7978,
        0xdeb15a49,
        0xd0b85742,
        0xc2a3405f,
        0xccaa4d54,
        0x41ecdaf7,
        0x4fe5d7fc,
        0x5dfec0e1,
        0x53f7cdea,
        0x79c8eedb,
        0x77c1e3d0,
        0x65daf4cd,
        0x6bd3f9c6,
        0x31a4b2af,
        0x3fadbfa4,
        0x2db6a8b9,
        0x23bfa5b2,
        0x09808683,
        0x07898b88,
        0x15929c95,
        0x1b9b919e,
        0xa17c0a47,
        0xaf75074c,
        0xbd6e1051,
        0xb3671d5a,
        0x99583e6b,
        0x97513360,
        0x854a247d,
        0x8b432976,
        0xd134621f,
        0xdf3d6f14,
        0xcd267809,
        0xc32f7502,
        0xe9105633,
        0xe7195b38,
        0xf5024c25,
        0xfb0b412e,
        0x9ad7618c,
        0x94de6c87,
        0x86c57b9a,
        0x88cc7691,
        0xa2f355a0,
        0xacfa58ab,
        0xbee14fb6,
        0xb0e842bd,
        0xea9f09d4,
        0xe49604df,
        0xf68d13c2,
        0xf8841ec9,
        0xd2bb3df8,
        0xdcb230f3,
        0xcea927ee,
        0xc0a02ae5,
        0x7a47b13c,
        0x744ebc37,
        0x6655ab2a,
        0x685ca621,
        0x42638510,
        0x4c6a881b,
        0x5e719f06,
        0x5078920d,
        0x0a0fd964,
        0x0406d46f,
        0x161dc372,
        0x1814ce79,
        0x322bed48,
        0x3c22e043,
        0x2e39f75e,
        0x2030fa55,
        0xec9ab701,
        0xe293ba0a,
        0xf088ad17,
        0xfe81a01c,
        0xd4be832d,
        0xdab78e26,
        0xc8ac993b,
        0xc6a59430,
        0x9cd2df59,
        0x92dbd252,
        0x80c0c54f,
        0x8ec9c844,
        0xa4f6eb75,
        0xaaffe67e,
        0xb8e4f163,
        0xb6edfc68,
        0x0c0a67b1,
        0x02036aba,
        0x10187da7,
        0x1e1170ac,
        0x342e539d,
        0x3a275e96,
        0x283c498b,
        0x26354480,
        0x7c420fe9,
        0x724b02e2,
        0x605015ff,
        0x6e5918f4,
        0x44663bc5,
        0x4a6f36ce,
        0x587421d3,
        0x567d2cd8,
        0x37a10c7a,
        0x39a80171,
        0x2bb3166c,
        0x25ba1b67,
        0x0f853856,
        0x018c355d,
        0x13972240,
        0x1d9e2f4b,
        0x47e96422,
        0x49e06929,
        0x5bfb7e34,
        0x55f2733f,
        0x7fcd500e,
        0x71c45d05,
        0x63df4a18,
        0x6dd64713,
        0xd731dcca,
        0xd938d1c1,
        0xcb23c6dc,
        0xc52acbd7,
        0xef15e8e6,
        0xe11ce5ed,
        0xf307f2f0,
        0xfd0efffb,
        0xa779b492,
        0xa970b999,
        0xbb6bae84,
        0xb562a38f,
        0x9f5d80be,
        0x91548db5,
        0x834f9aa8,
        0x8d4697a3
    ];
    var U2 = [
        0x00000000,
        0x0b0e090d,
        0x161c121a,
        0x1d121b17,
        0x2c382434,
        0x27362d39,
        0x3a24362e,
        0x312a3f23,
        0x58704868,
        0x537e4165,
        0x4e6c5a72,
        0x4562537f,
        0x74486c5c,
        0x7f466551,
        0x62547e46,
        0x695a774b,
        0xb0e090d0,
        0xbbee99dd,
        0xa6fc82ca,
        0xadf28bc7,
        0x9cd8b4e4,
        0x97d6bde9,
        0x8ac4a6fe,
        0x81caaff3,
        0xe890d8b8,
        0xe39ed1b5,
        0xfe8ccaa2,
        0xf582c3af,
        0xc4a8fc8c,
        0xcfa6f581,
        0xd2b4ee96,
        0xd9bae79b,
        0x7bdb3bbb,
        0x70d532b6,
        0x6dc729a1,
        0x66c920ac,
        0x57e31f8f,
        0x5ced1682,
        0x41ff0d95,
        0x4af10498,
        0x23ab73d3,
        0x28a57ade,
        0x35b761c9,
        0x3eb968c4,
        0x0f9357e7,
        0x049d5eea,
        0x198f45fd,
        0x12814cf0,
        0xcb3bab6b,
        0xc035a266,
        0xdd27b971,
        0xd629b07c,
        0xe7038f5f,
        0xec0d8652,
        0xf11f9d45,
        0xfa119448,
        0x934be303,
        0x9845ea0e,
        0x8557f119,
        0x8e59f814,
        0xbf73c737,
        0xb47dce3a,
        0xa96fd52d,
        0xa261dc20,
        0xf6ad766d,
        0xfda37f60,
        0xe0b16477,
        0xebbf6d7a,
        0xda955259,
        0xd19b5b54,
        0xcc894043,
        0xc787494e,
        0xaedd3e05,
        0xa5d33708,
        0xb8c12c1f,
        0xb3cf2512,
        0x82e51a31,
        0x89eb133c,
        0x94f9082b,
        0x9ff70126,
        0x464de6bd,
        0x4d43efb0,
        0x5051f4a7,
        0x5b5ffdaa,
        0x6a75c289,
        0x617bcb84,
        0x7c69d093,
        0x7767d99e,
        0x1e3daed5,
        0x1533a7d8,
        0x0821bccf,
        0x032fb5c2,
        0x32058ae1,
        0x390b83ec,
        0x241998fb,
        0x2f1791f6,
        0x8d764dd6,
        0x867844db,
        0x9b6a5fcc,
        0x906456c1,
        0xa14e69e2,
        0xaa4060ef,
        0xb7527bf8,
        0xbc5c72f5,
        0xd50605be,
        0xde080cb3,
        0xc31a17a4,
        0xc8141ea9,
        0xf93e218a,
        0xf2302887,
        0xef223390,
        0xe42c3a9d,
        0x3d96dd06,
        0x3698d40b,
        0x2b8acf1c,
        0x2084c611,
        0x11aef932,
        0x1aa0f03f,
        0x07b2eb28,
        0x0cbce225,
        0x65e6956e,
        0x6ee89c63,
        0x73fa8774,
        0x78f48e79,
        0x49deb15a,
        0x42d0b857,
        0x5fc2a340,
        0x54ccaa4d,
        0xf741ecda,
        0xfc4fe5d7,
        0xe15dfec0,
        0xea53f7cd,
        0xdb79c8ee,
        0xd077c1e3,
        0xcd65daf4,
        0xc66bd3f9,
        0xaf31a4b2,
        0xa43fadbf,
        0xb92db6a8,
        0xb223bfa5,
        0x83098086,
        0x8807898b,
        0x9515929c,
        0x9e1b9b91,
        0x47a17c0a,
        0x4caf7507,
        0x51bd6e10,
        0x5ab3671d,
        0x6b99583e,
        0x60975133,
        0x7d854a24,
        0x768b4329,
        0x1fd13462,
        0x14df3d6f,
        0x09cd2678,
        0x02c32f75,
        0x33e91056,
        0x38e7195b,
        0x25f5024c,
        0x2efb0b41,
        0x8c9ad761,
        0x8794de6c,
        0x9a86c57b,
        0x9188cc76,
        0xa0a2f355,
        0xabacfa58,
        0xb6bee14f,
        0xbdb0e842,
        0xd4ea9f09,
        0xdfe49604,
        0xc2f68d13,
        0xc9f8841e,
        0xf8d2bb3d,
        0xf3dcb230,
        0xeecea927,
        0xe5c0a02a,
        0x3c7a47b1,
        0x37744ebc,
        0x2a6655ab,
        0x21685ca6,
        0x10426385,
        0x1b4c6a88,
        0x065e719f,
        0x0d507892,
        0x640a0fd9,
        0x6f0406d4,
        0x72161dc3,
        0x791814ce,
        0x48322bed,
        0x433c22e0,
        0x5e2e39f7,
        0x552030fa,
        0x01ec9ab7,
        0x0ae293ba,
        0x17f088ad,
        0x1cfe81a0,
        0x2dd4be83,
        0x26dab78e,
        0x3bc8ac99,
        0x30c6a594,
        0x599cd2df,
        0x5292dbd2,
        0x4f80c0c5,
        0x448ec9c8,
        0x75a4f6eb,
        0x7eaaffe6,
        0x63b8e4f1,
        0x68b6edfc,
        0xb10c0a67,
        0xba02036a,
        0xa710187d,
        0xac1e1170,
        0x9d342e53,
        0x963a275e,
        0x8b283c49,
        0x80263544,
        0xe97c420f,
        0xe2724b02,
        0xff605015,
        0xf46e5918,
        0xc544663b,
        0xce4a6f36,
        0xd3587421,
        0xd8567d2c,
        0x7a37a10c,
        0x7139a801,
        0x6c2bb316,
        0x6725ba1b,
        0x560f8538,
        0x5d018c35,
        0x40139722,
        0x4b1d9e2f,
        0x2247e964,
        0x2949e069,
        0x345bfb7e,
        0x3f55f273,
        0x0e7fcd50,
        0x0571c45d,
        0x1863df4a,
        0x136dd647,
        0xcad731dc,
        0xc1d938d1,
        0xdccb23c6,
        0xd7c52acb,
        0xe6ef15e8,
        0xede11ce5,
        0xf0f307f2,
        0xfbfd0eff,
        0x92a779b4,
        0x99a970b9,
        0x84bb6bae,
        0x8fb562a3,
        0xbe9f5d80,
        0xb591548d,
        0xa8834f9a,
        0xa38d4697
    ];
    var U3 = [
        0x00000000,
        0x0d0b0e09,
        0x1a161c12,
        0x171d121b,
        0x342c3824,
        0x3927362d,
        0x2e3a2436,
        0x23312a3f,
        0x68587048,
        0x65537e41,
        0x724e6c5a,
        0x7f456253,
        0x5c74486c,
        0x517f4665,
        0x4662547e,
        0x4b695a77,
        0xd0b0e090,
        0xddbbee99,
        0xcaa6fc82,
        0xc7adf28b,
        0xe49cd8b4,
        0xe997d6bd,
        0xfe8ac4a6,
        0xf381caaf,
        0xb8e890d8,
        0xb5e39ed1,
        0xa2fe8cca,
        0xaff582c3,
        0x8cc4a8fc,
        0x81cfa6f5,
        0x96d2b4ee,
        0x9bd9bae7,
        0xbb7bdb3b,
        0xb670d532,
        0xa16dc729,
        0xac66c920,
        0x8f57e31f,
        0x825ced16,
        0x9541ff0d,
        0x984af104,
        0xd323ab73,
        0xde28a57a,
        0xc935b761,
        0xc43eb968,
        0xe70f9357,
        0xea049d5e,
        0xfd198f45,
        0xf012814c,
        0x6bcb3bab,
        0x66c035a2,
        0x71dd27b9,
        0x7cd629b0,
        0x5fe7038f,
        0x52ec0d86,
        0x45f11f9d,
        0x48fa1194,
        0x03934be3,
        0x0e9845ea,
        0x198557f1,
        0x148e59f8,
        0x37bf73c7,
        0x3ab47dce,
        0x2da96fd5,
        0x20a261dc,
        0x6df6ad76,
        0x60fda37f,
        0x77e0b164,
        0x7aebbf6d,
        0x59da9552,
        0x54d19b5b,
        0x43cc8940,
        0x4ec78749,
        0x05aedd3e,
        0x08a5d337,
        0x1fb8c12c,
        0x12b3cf25,
        0x3182e51a,
        0x3c89eb13,
        0x2b94f908,
        0x269ff701,
        0xbd464de6,
        0xb04d43ef,
        0xa75051f4,
        0xaa5b5ffd,
        0x896a75c2,
        0x84617bcb,
        0x937c69d0,
        0x9e7767d9,
        0xd51e3dae,
        0xd81533a7,
        0xcf0821bc,
        0xc2032fb5,
        0xe132058a,
        0xec390b83,
        0xfb241998,
        0xf62f1791,
        0xd68d764d,
        0xdb867844,
        0xcc9b6a5f,
        0xc1906456,
        0xe2a14e69,
        0xefaa4060,
        0xf8b7527b,
        0xf5bc5c72,
        0xbed50605,
        0xb3de080c,
        0xa4c31a17,
        0xa9c8141e,
        0x8af93e21,
        0x87f23028,
        0x90ef2233,
        0x9de42c3a,
        0x063d96dd,
        0x0b3698d4,
        0x1c2b8acf,
        0x112084c6,
        0x3211aef9,
        0x3f1aa0f0,
        0x2807b2eb,
        0x250cbce2,
        0x6e65e695,
        0x636ee89c,
        0x7473fa87,
        0x7978f48e,
        0x5a49deb1,
        0x5742d0b8,
        0x405fc2a3,
        0x4d54ccaa,
        0xdaf741ec,
        0xd7fc4fe5,
        0xc0e15dfe,
        0xcdea53f7,
        0xeedb79c8,
        0xe3d077c1,
        0xf4cd65da,
        0xf9c66bd3,
        0xb2af31a4,
        0xbfa43fad,
        0xa8b92db6,
        0xa5b223bf,
        0x86830980,
        0x8b880789,
        0x9c951592,
        0x919e1b9b,
        0x0a47a17c,
        0x074caf75,
        0x1051bd6e,
        0x1d5ab367,
        0x3e6b9958,
        0x33609751,
        0x247d854a,
        0x29768b43,
        0x621fd134,
        0x6f14df3d,
        0x7809cd26,
        0x7502c32f,
        0x5633e910,
        0x5b38e719,
        0x4c25f502,
        0x412efb0b,
        0x618c9ad7,
        0x6c8794de,
        0x7b9a86c5,
        0x769188cc,
        0x55a0a2f3,
        0x58abacfa,
        0x4fb6bee1,
        0x42bdb0e8,
        0x09d4ea9f,
        0x04dfe496,
        0x13c2f68d,
        0x1ec9f884,
        0x3df8d2bb,
        0x30f3dcb2,
        0x27eecea9,
        0x2ae5c0a0,
        0xb13c7a47,
        0xbc37744e,
        0xab2a6655,
        0xa621685c,
        0x85104263,
        0x881b4c6a,
        0x9f065e71,
        0x920d5078,
        0xd9640a0f,
        0xd46f0406,
        0xc372161d,
        0xce791814,
        0xed48322b,
        0xe0433c22,
        0xf75e2e39,
        0xfa552030,
        0xb701ec9a,
        0xba0ae293,
        0xad17f088,
        0xa01cfe81,
        0x832dd4be,
        0x8e26dab7,
        0x993bc8ac,
        0x9430c6a5,
        0xdf599cd2,
        0xd25292db,
        0xc54f80c0,
        0xc8448ec9,
        0xeb75a4f6,
        0xe67eaaff,
        0xf163b8e4,
        0xfc68b6ed,
        0x67b10c0a,
        0x6aba0203,
        0x7da71018,
        0x70ac1e11,
        0x539d342e,
        0x5e963a27,
        0x498b283c,
        0x44802635,
        0x0fe97c42,
        0x02e2724b,
        0x15ff6050,
        0x18f46e59,
        0x3bc54466,
        0x36ce4a6f,
        0x21d35874,
        0x2cd8567d,
        0x0c7a37a1,
        0x017139a8,
        0x166c2bb3,
        0x1b6725ba,
        0x38560f85,
        0x355d018c,
        0x22401397,
        0x2f4b1d9e,
        0x642247e9,
        0x692949e0,
        0x7e345bfb,
        0x733f55f2,
        0x500e7fcd,
        0x5d0571c4,
        0x4a1863df,
        0x47136dd6,
        0xdccad731,
        0xd1c1d938,
        0xc6dccb23,
        0xcbd7c52a,
        0xe8e6ef15,
        0xe5ede11c,
        0xf2f0f307,
        0xfffbfd0e,
        0xb492a779,
        0xb999a970,
        0xae84bb6b,
        0xa38fb562,
        0x80be9f5d,
        0x8db59154,
        0x9aa8834f,
        0x97a38d46
    ];
    var U4 = [
        0x00000000,
        0x090d0b0e,
        0x121a161c,
        0x1b171d12,
        0x24342c38,
        0x2d392736,
        0x362e3a24,
        0x3f23312a,
        0x48685870,
        0x4165537e,
        0x5a724e6c,
        0x537f4562,
        0x6c5c7448,
        0x65517f46,
        0x7e466254,
        0x774b695a,
        0x90d0b0e0,
        0x99ddbbee,
        0x82caa6fc,
        0x8bc7adf2,
        0xb4e49cd8,
        0xbde997d6,
        0xa6fe8ac4,
        0xaff381ca,
        0xd8b8e890,
        0xd1b5e39e,
        0xcaa2fe8c,
        0xc3aff582,
        0xfc8cc4a8,
        0xf581cfa6,
        0xee96d2b4,
        0xe79bd9ba,
        0x3bbb7bdb,
        0x32b670d5,
        0x29a16dc7,
        0x20ac66c9,
        0x1f8f57e3,
        0x16825ced,
        0x0d9541ff,
        0x04984af1,
        0x73d323ab,
        0x7ade28a5,
        0x61c935b7,
        0x68c43eb9,
        0x57e70f93,
        0x5eea049d,
        0x45fd198f,
        0x4cf01281,
        0xab6bcb3b,
        0xa266c035,
        0xb971dd27,
        0xb07cd629,
        0x8f5fe703,
        0x8652ec0d,
        0x9d45f11f,
        0x9448fa11,
        0xe303934b,
        0xea0e9845,
        0xf1198557,
        0xf8148e59,
        0xc737bf73,
        0xce3ab47d,
        0xd52da96f,
        0xdc20a261,
        0x766df6ad,
        0x7f60fda3,
        0x6477e0b1,
        0x6d7aebbf,
        0x5259da95,
        0x5b54d19b,
        0x4043cc89,
        0x494ec787,
        0x3e05aedd,
        0x3708a5d3,
        0x2c1fb8c1,
        0x2512b3cf,
        0x1a3182e5,
        0x133c89eb,
        0x082b94f9,
        0x01269ff7,
        0xe6bd464d,
        0xefb04d43,
        0xf4a75051,
        0xfdaa5b5f,
        0xc2896a75,
        0xcb84617b,
        0xd0937c69,
        0xd99e7767,
        0xaed51e3d,
        0xa7d81533,
        0xbccf0821,
        0xb5c2032f,
        0x8ae13205,
        0x83ec390b,
        0x98fb2419,
        0x91f62f17,
        0x4dd68d76,
        0x44db8678,
        0x5fcc9b6a,
        0x56c19064,
        0x69e2a14e,
        0x60efaa40,
        0x7bf8b752,
        0x72f5bc5c,
        0x05bed506,
        0x0cb3de08,
        0x17a4c31a,
        0x1ea9c814,
        0x218af93e,
        0x2887f230,
        0x3390ef22,
        0x3a9de42c,
        0xdd063d96,
        0xd40b3698,
        0xcf1c2b8a,
        0xc6112084,
        0xf93211ae,
        0xf03f1aa0,
        0xeb2807b2,
        0xe2250cbc,
        0x956e65e6,
        0x9c636ee8,
        0x877473fa,
        0x8e7978f4,
        0xb15a49de,
        0xb85742d0,
        0xa3405fc2,
        0xaa4d54cc,
        0xecdaf741,
        0xe5d7fc4f,
        0xfec0e15d,
        0xf7cdea53,
        0xc8eedb79,
        0xc1e3d077,
        0xdaf4cd65,
        0xd3f9c66b,
        0xa4b2af31,
        0xadbfa43f,
        0xb6a8b92d,
        0xbfa5b223,
        0x80868309,
        0x898b8807,
        0x929c9515,
        0x9b919e1b,
        0x7c0a47a1,
        0x75074caf,
        0x6e1051bd,
        0x671d5ab3,
        0x583e6b99,
        0x51336097,
        0x4a247d85,
        0x4329768b,
        0x34621fd1,
        0x3d6f14df,
        0x267809cd,
        0x2f7502c3,
        0x105633e9,
        0x195b38e7,
        0x024c25f5,
        0x0b412efb,
        0xd7618c9a,
        0xde6c8794,
        0xc57b9a86,
        0xcc769188,
        0xf355a0a2,
        0xfa58abac,
        0xe14fb6be,
        0xe842bdb0,
        0x9f09d4ea,
        0x9604dfe4,
        0x8d13c2f6,
        0x841ec9f8,
        0xbb3df8d2,
        0xb230f3dc,
        0xa927eece,
        0xa02ae5c0,
        0x47b13c7a,
        0x4ebc3774,
        0x55ab2a66,
        0x5ca62168,
        0x63851042,
        0x6a881b4c,
        0x719f065e,
        0x78920d50,
        0x0fd9640a,
        0x06d46f04,
        0x1dc37216,
        0x14ce7918,
        0x2bed4832,
        0x22e0433c,
        0x39f75e2e,
        0x30fa5520,
        0x9ab701ec,
        0x93ba0ae2,
        0x88ad17f0,
        0x81a01cfe,
        0xbe832dd4,
        0xb78e26da,
        0xac993bc8,
        0xa59430c6,
        0xd2df599c,
        0xdbd25292,
        0xc0c54f80,
        0xc9c8448e,
        0xf6eb75a4,
        0xffe67eaa,
        0xe4f163b8,
        0xedfc68b6,
        0x0a67b10c,
        0x036aba02,
        0x187da710,
        0x1170ac1e,
        0x2e539d34,
        0x275e963a,
        0x3c498b28,
        0x35448026,
        0x420fe97c,
        0x4b02e272,
        0x5015ff60,
        0x5918f46e,
        0x663bc544,
        0x6f36ce4a,
        0x7421d358,
        0x7d2cd856,
        0xa10c7a37,
        0xa8017139,
        0xb3166c2b,
        0xba1b6725,
        0x8538560f,
        0x8c355d01,
        0x97224013,
        0x9e2f4b1d,
        0xe9642247,
        0xe0692949,
        0xfb7e345b,
        0xf2733f55,
        0xcd500e7f,
        0xc45d0571,
        0xdf4a1863,
        0xd647136d,
        0x31dccad7,
        0x38d1c1d9,
        0x23c6dccb,
        0x2acbd7c5,
        0x15e8e6ef,
        0x1ce5ede1,
        0x07f2f0f3,
        0x0efffbfd,
        0x79b492a7,
        0x70b999a9,
        0x6bae84bb,
        0x62a38fb5,
        0x5d80be9f,
        0x548db591,
        0x4f9aa883,
        0x4697a38d
    ];
    function convertToInt32(bytes) {
        var result = [];
        for(var i = 0; i < bytes.length; i += 4){
            result.push(bytes[i] << 24 | bytes[i + 1] << 16 | bytes[i + 2] << 8 | bytes[i + 3]);
        }
        return result;
    }
    var AES = function(key) {
        if (!(this instanceof AES)) {
            throw Error('AES must be instanitated with `new`');
        }
        Object.defineProperty(this, 'key', {
            value: coerceArray(key, true)
        });
        this._prepare();
    };
    AES.prototype._prepare = function() {
        var rounds = numberOfRounds[this.key.length];
        if (rounds == null) {
            throw new Error('invalid key size (must be 16, 24 or 32 bytes)');
        }
        // encryption round keys
        this._Ke = [];
        // decryption round keys
        this._Kd = [];
        for(var i = 0; i <= rounds; i++){
            this._Ke.push([
                0,
                0,
                0,
                0
            ]);
            this._Kd.push([
                0,
                0,
                0,
                0
            ]);
        }
        var roundKeyCount = (rounds + 1) * 4;
        var KC = this.key.length / 4;
        // convert the key into ints
        var tk = convertToInt32(this.key);
        // copy values into round key arrays
        var index;
        for(var i = 0; i < KC; i++){
            index = i >> 2;
            this._Ke[index][i % 4] = tk[i];
            this._Kd[rounds - index][i % 4] = tk[i];
        }
        // key expansion (fips-197 section 5.2)
        var rconpointer = 0;
        var t = KC, tt;
        while(t < roundKeyCount){
            tt = tk[KC - 1];
            tk[0] ^= S[tt >> 16 & 0xFF] << 24 ^ S[tt >> 8 & 0xFF] << 16 ^ S[tt & 0xFF] << 8 ^ S[tt >> 24 & 0xFF] ^ rcon[rconpointer] << 24;
            rconpointer += 1;
            // key expansion (for non-256 bit)
            if (KC != 8) {
                for(var i = 1; i < KC; i++){
                    tk[i] ^= tk[i - 1];
                }
            // key expansion for 256-bit keys is "slightly different" (fips-197)
            } else {
                for(var i = 1; i < KC / 2; i++){
                    tk[i] ^= tk[i - 1];
                }
                tt = tk[KC / 2 - 1];
                tk[KC / 2] ^= S[tt & 0xFF] ^ S[tt >> 8 & 0xFF] << 8 ^ S[tt >> 16 & 0xFF] << 16 ^ S[tt >> 24 & 0xFF] << 24;
                for(var i = KC / 2 + 1; i < KC; i++){
                    tk[i] ^= tk[i - 1];
                }
            }
            // copy values into round key arrays
            var i = 0, r, c;
            while(i < KC && t < roundKeyCount){
                r = t >> 2;
                c = t % 4;
                this._Ke[r][c] = tk[i];
                this._Kd[rounds - r][c] = tk[i++];
                t++;
            }
        }
        // inverse-cipher-ify the decryption round key (fips-197 section 5.3)
        for(var r = 1; r < rounds; r++){
            for(var c = 0; c < 4; c++){
                tt = this._Kd[r][c];
                this._Kd[r][c] = U1[tt >> 24 & 0xFF] ^ U2[tt >> 16 & 0xFF] ^ U3[tt >> 8 & 0xFF] ^ U4[tt & 0xFF];
            }
        }
    };
    AES.prototype.encrypt = function(plaintext) {
        if (plaintext.length != 16) {
            throw new Error('invalid plaintext size (must be 16 bytes)');
        }
        var rounds = this._Ke.length - 1;
        var a = [
            0,
            0,
            0,
            0
        ];
        // convert plaintext to (ints ^ key)
        var t = convertToInt32(plaintext);
        for(var i = 0; i < 4; i++){
            t[i] ^= this._Ke[0][i];
        }
        // apply round transforms
        for(var r = 1; r < rounds; r++){
            for(var i = 0; i < 4; i++){
                a[i] = T1[t[i] >> 24 & 0xff] ^ T2[t[(i + 1) % 4] >> 16 & 0xff] ^ T3[t[(i + 2) % 4] >> 8 & 0xff] ^ T4[t[(i + 3) % 4] & 0xff] ^ this._Ke[r][i];
            }
            t = a.slice();
        }
        // the last round is special
        var result = createArray(16), tt;
        for(var i = 0; i < 4; i++){
            tt = this._Ke[rounds][i];
            result[4 * i] = (S[t[i] >> 24 & 0xff] ^ tt >> 24) & 0xff;
            result[4 * i + 1] = (S[t[(i + 1) % 4] >> 16 & 0xff] ^ tt >> 16) & 0xff;
            result[4 * i + 2] = (S[t[(i + 2) % 4] >> 8 & 0xff] ^ tt >> 8) & 0xff;
            result[4 * i + 3] = (S[t[(i + 3) % 4] & 0xff] ^ tt) & 0xff;
        }
        return result;
    };
    AES.prototype.decrypt = function(ciphertext) {
        if (ciphertext.length != 16) {
            throw new Error('invalid ciphertext size (must be 16 bytes)');
        }
        var rounds = this._Kd.length - 1;
        var a = [
            0,
            0,
            0,
            0
        ];
        // convert plaintext to (ints ^ key)
        var t = convertToInt32(ciphertext);
        for(var i = 0; i < 4; i++){
            t[i] ^= this._Kd[0][i];
        }
        // apply round transforms
        for(var r = 1; r < rounds; r++){
            for(var i = 0; i < 4; i++){
                a[i] = T5[t[i] >> 24 & 0xff] ^ T6[t[(i + 3) % 4] >> 16 & 0xff] ^ T7[t[(i + 2) % 4] >> 8 & 0xff] ^ T8[t[(i + 1) % 4] & 0xff] ^ this._Kd[r][i];
            }
            t = a.slice();
        }
        // the last round is special
        var result = createArray(16), tt;
        for(var i = 0; i < 4; i++){
            tt = this._Kd[rounds][i];
            result[4 * i] = (Si[t[i] >> 24 & 0xff] ^ tt >> 24) & 0xff;
            result[4 * i + 1] = (Si[t[(i + 3) % 4] >> 16 & 0xff] ^ tt >> 16) & 0xff;
            result[4 * i + 2] = (Si[t[(i + 2) % 4] >> 8 & 0xff] ^ tt >> 8) & 0xff;
            result[4 * i + 3] = (Si[t[(i + 1) % 4] & 0xff] ^ tt) & 0xff;
        }
        return result;
    };
    /**
     *  Mode Of Operation - Electonic Codebook (ECB)
     */ var ModeOfOperationECB = function(key) {
        if (!(this instanceof ModeOfOperationECB)) {
            throw Error('AES must be instanitated with `new`');
        }
        this.description = "Electronic Code Block";
        this.name = "ecb";
        this._aes = new AES(key);
    };
    ModeOfOperationECB.prototype.encrypt = function(plaintext) {
        plaintext = coerceArray(plaintext);
        if (plaintext.length % 16 !== 0) {
            throw new Error('invalid plaintext size (must be multiple of 16 bytes)');
        }
        var ciphertext = createArray(plaintext.length);
        var block = createArray(16);
        for(var i = 0; i < plaintext.length; i += 16){
            copyArray(plaintext, block, 0, i, i + 16);
            block = this._aes.encrypt(block);
            copyArray(block, ciphertext, i);
        }
        return ciphertext;
    };
    ModeOfOperationECB.prototype.decrypt = function(ciphertext) {
        ciphertext = coerceArray(ciphertext);
        if (ciphertext.length % 16 !== 0) {
            throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');
        }
        var plaintext = createArray(ciphertext.length);
        var block = createArray(16);
        for(var i = 0; i < ciphertext.length; i += 16){
            copyArray(ciphertext, block, 0, i, i + 16);
            block = this._aes.decrypt(block);
            copyArray(block, plaintext, i);
        }
        return plaintext;
    };
    /**
     *  Mode Of Operation - Cipher Block Chaining (CBC)
     */ var ModeOfOperationCBC = function(key, iv) {
        if (!(this instanceof ModeOfOperationCBC)) {
            throw Error('AES must be instanitated with `new`');
        }
        this.description = "Cipher Block Chaining";
        this.name = "cbc";
        if (!iv) {
            iv = createArray(16);
        } else if (iv.length != 16) {
            throw new Error('invalid initialation vector size (must be 16 bytes)');
        }
        this._lastCipherblock = coerceArray(iv, true);
        this._aes = new AES(key);
    };
    ModeOfOperationCBC.prototype.encrypt = function(plaintext) {
        plaintext = coerceArray(plaintext);
        if (plaintext.length % 16 !== 0) {
            throw new Error('invalid plaintext size (must be multiple of 16 bytes)');
        }
        var ciphertext = createArray(plaintext.length);
        var block = createArray(16);
        for(var i = 0; i < plaintext.length; i += 16){
            copyArray(plaintext, block, 0, i, i + 16);
            for(var j = 0; j < 16; j++){
                block[j] ^= this._lastCipherblock[j];
            }
            this._lastCipherblock = this._aes.encrypt(block);
            copyArray(this._lastCipherblock, ciphertext, i);
        }
        return ciphertext;
    };
    ModeOfOperationCBC.prototype.decrypt = function(ciphertext) {
        ciphertext = coerceArray(ciphertext);
        if (ciphertext.length % 16 !== 0) {
            throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');
        }
        var plaintext = createArray(ciphertext.length);
        var block = createArray(16);
        for(var i = 0; i < ciphertext.length; i += 16){
            copyArray(ciphertext, block, 0, i, i + 16);
            block = this._aes.decrypt(block);
            for(var j = 0; j < 16; j++){
                plaintext[i + j] = block[j] ^ this._lastCipherblock[j];
            }
            copyArray(ciphertext, this._lastCipherblock, 0, i, i + 16);
        }
        return plaintext;
    };
    /**
     *  Mode Of Operation - Cipher Feedback (CFB)
     */ var ModeOfOperationCFB = function(key, iv, segmentSize) {
        if (!(this instanceof ModeOfOperationCFB)) {
            throw Error('AES must be instanitated with `new`');
        }
        this.description = "Cipher Feedback";
        this.name = "cfb";
        if (!iv) {
            iv = createArray(16);
        } else if (iv.length != 16) {
            throw new Error('invalid initialation vector size (must be 16 size)');
        }
        if (!segmentSize) {
            segmentSize = 1;
        }
        this.segmentSize = segmentSize;
        this._shiftRegister = coerceArray(iv, true);
        this._aes = new AES(key);
    };
    ModeOfOperationCFB.prototype.encrypt = function(plaintext) {
        if (plaintext.length % this.segmentSize != 0) {
            throw new Error('invalid plaintext size (must be segmentSize bytes)');
        }
        var encrypted = coerceArray(plaintext, true);
        var xorSegment;
        for(var i = 0; i < encrypted.length; i += this.segmentSize){
            xorSegment = this._aes.encrypt(this._shiftRegister);
            for(var j = 0; j < this.segmentSize; j++){
                encrypted[i + j] ^= xorSegment[j];
            }
            // Shift the register
            copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
            copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
        }
        return encrypted;
    };
    ModeOfOperationCFB.prototype.decrypt = function(ciphertext) {
        if (ciphertext.length % this.segmentSize != 0) {
            throw new Error('invalid ciphertext size (must be segmentSize bytes)');
        }
        var plaintext = coerceArray(ciphertext, true);
        var xorSegment;
        for(var i = 0; i < plaintext.length; i += this.segmentSize){
            xorSegment = this._aes.encrypt(this._shiftRegister);
            for(var j = 0; j < this.segmentSize; j++){
                plaintext[i + j] ^= xorSegment[j];
            }
            // Shift the register
            copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
            copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
        }
        return plaintext;
    };
    /**
     *  Mode Of Operation - Output Feedback (OFB)
     */ var ModeOfOperationOFB = function(key, iv) {
        if (!(this instanceof ModeOfOperationOFB)) {
            throw Error('AES must be instanitated with `new`');
        }
        this.description = "Output Feedback";
        this.name = "ofb";
        if (!iv) {
            iv = createArray(16);
        } else if (iv.length != 16) {
            throw new Error('invalid initialation vector size (must be 16 bytes)');
        }
        this._lastPrecipher = coerceArray(iv, true);
        this._lastPrecipherIndex = 16;
        this._aes = new AES(key);
    };
    ModeOfOperationOFB.prototype.encrypt = function(plaintext) {
        var encrypted = coerceArray(plaintext, true);
        for(var i = 0; i < encrypted.length; i++){
            if (this._lastPrecipherIndex === 16) {
                this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);
                this._lastPrecipherIndex = 0;
            }
            encrypted[i] ^= this._lastPrecipher[this._lastPrecipherIndex++];
        }
        return encrypted;
    };
    // Decryption is symetric
    ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;
    /**
     *  Counter object for CTR common mode of operation
     */ var Counter = function(initialValue) {
        if (!(this instanceof Counter)) {
            throw Error('Counter must be instanitated with `new`');
        }
        // We allow 0, but anything false-ish uses the default 1
        if (initialValue !== 0 && !initialValue) {
            initialValue = 1;
        }
        if (typeof initialValue === 'number') {
            this._counter = createArray(16);
            this.setValue(initialValue);
        } else {
            this.setBytes(initialValue);
        }
    };
    Counter.prototype.setValue = function(value) {
        if (typeof value !== 'number' || parseInt(value) != value) {
            throw new Error('invalid counter value (must be an integer)');
        }
        for(var index = 15; index >= 0; --index){
            this._counter[index] = value % 256;
            value = value >> 8;
        }
    };
    Counter.prototype.setBytes = function(bytes) {
        bytes = coerceArray(bytes, true);
        if (bytes.length != 16) {
            throw new Error('invalid counter bytes size (must be 16 bytes)');
        }
        this._counter = bytes;
    };
    Counter.prototype.increment = function() {
        for(var i = 15; i >= 0; i--){
            if (this._counter[i] === 255) {
                this._counter[i] = 0;
            } else {
                this._counter[i]++;
                break;
            }
        }
    };
    /**
     *  Mode Of Operation - Counter (CTR)
     */ var ModeOfOperationCTR = function(key, counter) {
        if (!(this instanceof ModeOfOperationCTR)) {
            throw Error('AES must be instanitated with `new`');
        }
        this.description = "Counter";
        this.name = "ctr";
        if (!(counter instanceof Counter)) {
            counter = new Counter(counter);
        }
        this._counter = counter;
        this._remainingCounter = null;
        this._remainingCounterIndex = 16;
        this._aes = new AES(key);
    };
    ModeOfOperationCTR.prototype.encrypt = function(plaintext) {
        var encrypted = coerceArray(plaintext, true);
        for(var i = 0; i < encrypted.length; i++){
            if (this._remainingCounterIndex === 16) {
                this._remainingCounter = this._aes.encrypt(this._counter._counter);
                this._remainingCounterIndex = 0;
                this._counter.increment();
            }
            encrypted[i] ^= this._remainingCounter[this._remainingCounterIndex++];
        }
        return encrypted;
    };
    // Decryption is symetric
    ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt;
    ///////////////////////
    // Padding
    // See:https://tools.ietf.org/html/rfc2315
    function pkcs7pad(data) {
        data = coerceArray(data, true);
        var padder = 16 - data.length % 16;
        var result = createArray(data.length + padder);
        copyArray(data, result);
        for(var i = data.length; i < result.length; i++){
            result[i] = padder;
        }
        return result;
    }
    function pkcs7strip(data) {
        data = coerceArray(data, true);
        if (data.length < 16) {
            throw new Error('PKCS#7 invalid length');
        }
        var padder = data[data.length - 1];
        if (padder > 16) {
            throw new Error('PKCS#7 padding byte out of range');
        }
        var length = data.length - padder;
        for(var i = 0; i < padder; i++){
            if (data[length + i] !== padder) {
                throw new Error('PKCS#7 invalid padding byte');
            }
        }
        var result = createArray(length);
        copyArray(data, result, 0, 0, length);
        return result;
    }
    ///////////////////////
    // Exporting
    // The block cipher
    var aesjs = {
        AES: AES,
        Counter: Counter,
        ModeOfOperation: {
            ecb: ModeOfOperationECB,
            cbc: ModeOfOperationCBC,
            cfb: ModeOfOperationCFB,
            ofb: ModeOfOperationOFB,
            ctr: ModeOfOperationCTR
        },
        utils: {
            hex: convertHex,
            utf8: convertUtf8
        },
        padding: {
            pkcs7: {
                pad: pkcs7pad,
                strip: pkcs7strip
            }
        },
        _arrayTest: {
            coerceArray: coerceArray,
            createArray: createArray,
            copyArray: copyArray
        }
    };
    // node.js
    if ("TURBOPACK compile-time truthy", 1) {
        module.exports = aesjs;
    // RequireJS/AMD
    // http://www.requirejs.org/docs/api.html
    // https://github.com/amdjs/amdjs-api/wiki/AMD
    } else //TURBOPACK unreachable
    ;
})(/*TURBOPACK member replacement*/ __turbopack_context__.e);
}),
"[project]/node_modules/scrypt-js/scrypt.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

(function(root) {
    const MAX_VALUE = 0x7fffffff;
    // The SHA256 and PBKDF2 implementation are from scrypt-async-js:
    // See: https://github.com/dchest/scrypt-async-js
    function SHA256(m) {
        const K = new Uint32Array([
            0x428a2f98,
            0x71374491,
            0xb5c0fbcf,
            0xe9b5dba5,
            0x3956c25b,
            0x59f111f1,
            0x923f82a4,
            0xab1c5ed5,
            0xd807aa98,
            0x12835b01,
            0x243185be,
            0x550c7dc3,
            0x72be5d74,
            0x80deb1fe,
            0x9bdc06a7,
            0xc19bf174,
            0xe49b69c1,
            0xefbe4786,
            0x0fc19dc6,
            0x240ca1cc,
            0x2de92c6f,
            0x4a7484aa,
            0x5cb0a9dc,
            0x76f988da,
            0x983e5152,
            0xa831c66d,
            0xb00327c8,
            0xbf597fc7,
            0xc6e00bf3,
            0xd5a79147,
            0x06ca6351,
            0x14292967,
            0x27b70a85,
            0x2e1b2138,
            0x4d2c6dfc,
            0x53380d13,
            0x650a7354,
            0x766a0abb,
            0x81c2c92e,
            0x92722c85,
            0xa2bfe8a1,
            0xa81a664b,
            0xc24b8b70,
            0xc76c51a3,
            0xd192e819,
            0xd6990624,
            0xf40e3585,
            0x106aa070,
            0x19a4c116,
            0x1e376c08,
            0x2748774c,
            0x34b0bcb5,
            0x391c0cb3,
            0x4ed8aa4a,
            0x5b9cca4f,
            0x682e6ff3,
            0x748f82ee,
            0x78a5636f,
            0x84c87814,
            0x8cc70208,
            0x90befffa,
            0xa4506ceb,
            0xbef9a3f7,
            0xc67178f2
        ]);
        let h0 = 0x6a09e667, h1 = 0xbb67ae85, h2 = 0x3c6ef372, h3 = 0xa54ff53a;
        let h4 = 0x510e527f, h5 = 0x9b05688c, h6 = 0x1f83d9ab, h7 = 0x5be0cd19;
        const w = new Uint32Array(64);
        function blocks(p) {
            let off = 0, len = p.length;
            while(len >= 64){
                let a = h0, b = h1, c = h2, d = h3, e = h4, f = h5, g = h6, h = h7, u, i, j, t1, t2;
                for(i = 0; i < 16; i++){
                    j = off + i * 4;
                    w[i] = (p[j] & 0xff) << 24 | (p[j + 1] & 0xff) << 16 | (p[j + 2] & 0xff) << 8 | p[j + 3] & 0xff;
                }
                for(i = 16; i < 64; i++){
                    u = w[i - 2];
                    t1 = (u >>> 17 | u << 32 - 17) ^ (u >>> 19 | u << 32 - 19) ^ u >>> 10;
                    u = w[i - 15];
                    t2 = (u >>> 7 | u << 32 - 7) ^ (u >>> 18 | u << 32 - 18) ^ u >>> 3;
                    w[i] = (t1 + w[i - 7] | 0) + (t2 + w[i - 16] | 0) | 0;
                }
                for(i = 0; i < 64; i++){
                    t1 = (((e >>> 6 | e << 32 - 6) ^ (e >>> 11 | e << 32 - 11) ^ (e >>> 25 | e << 32 - 25)) + (e & f ^ ~e & g) | 0) + (h + (K[i] + w[i] | 0) | 0) | 0;
                    t2 = ((a >>> 2 | a << 32 - 2) ^ (a >>> 13 | a << 32 - 13) ^ (a >>> 22 | a << 32 - 22)) + (a & b ^ a & c ^ b & c) | 0;
                    h = g;
                    g = f;
                    f = e;
                    e = d + t1 | 0;
                    d = c;
                    c = b;
                    b = a;
                    a = t1 + t2 | 0;
                }
                h0 = h0 + a | 0;
                h1 = h1 + b | 0;
                h2 = h2 + c | 0;
                h3 = h3 + d | 0;
                h4 = h4 + e | 0;
                h5 = h5 + f | 0;
                h6 = h6 + g | 0;
                h7 = h7 + h | 0;
                off += 64;
                len -= 64;
            }
        }
        blocks(m);
        let i, bytesLeft = m.length % 64, bitLenHi = m.length / 0x20000000 | 0, bitLenLo = m.length << 3, numZeros = bytesLeft < 56 ? 56 : 120, p = m.slice(m.length - bytesLeft, m.length);
        p.push(0x80);
        for(i = bytesLeft + 1; i < numZeros; i++){
            p.push(0);
        }
        p.push(bitLenHi >>> 24 & 0xff);
        p.push(bitLenHi >>> 16 & 0xff);
        p.push(bitLenHi >>> 8 & 0xff);
        p.push(bitLenHi >>> 0 & 0xff);
        p.push(bitLenLo >>> 24 & 0xff);
        p.push(bitLenLo >>> 16 & 0xff);
        p.push(bitLenLo >>> 8 & 0xff);
        p.push(bitLenLo >>> 0 & 0xff);
        blocks(p);
        return [
            h0 >>> 24 & 0xff,
            h0 >>> 16 & 0xff,
            h0 >>> 8 & 0xff,
            h0 >>> 0 & 0xff,
            h1 >>> 24 & 0xff,
            h1 >>> 16 & 0xff,
            h1 >>> 8 & 0xff,
            h1 >>> 0 & 0xff,
            h2 >>> 24 & 0xff,
            h2 >>> 16 & 0xff,
            h2 >>> 8 & 0xff,
            h2 >>> 0 & 0xff,
            h3 >>> 24 & 0xff,
            h3 >>> 16 & 0xff,
            h3 >>> 8 & 0xff,
            h3 >>> 0 & 0xff,
            h4 >>> 24 & 0xff,
            h4 >>> 16 & 0xff,
            h4 >>> 8 & 0xff,
            h4 >>> 0 & 0xff,
            h5 >>> 24 & 0xff,
            h5 >>> 16 & 0xff,
            h5 >>> 8 & 0xff,
            h5 >>> 0 & 0xff,
            h6 >>> 24 & 0xff,
            h6 >>> 16 & 0xff,
            h6 >>> 8 & 0xff,
            h6 >>> 0 & 0xff,
            h7 >>> 24 & 0xff,
            h7 >>> 16 & 0xff,
            h7 >>> 8 & 0xff,
            h7 >>> 0 & 0xff
        ];
    }
    function PBKDF2_HMAC_SHA256_OneIter(password, salt, dkLen) {
        // compress password if it's longer than hash block length
        password = password.length <= 64 ? password : SHA256(password);
        const innerLen = 64 + salt.length + 4;
        const inner = new Array(innerLen);
        const outerKey = new Array(64);
        let i;
        let dk = [];
        // inner = (password ^ ipad) || salt || counter
        for(i = 0; i < 64; i++){
            inner[i] = 0x36;
        }
        for(i = 0; i < password.length; i++){
            inner[i] ^= password[i];
        }
        for(i = 0; i < salt.length; i++){
            inner[64 + i] = salt[i];
        }
        for(i = innerLen - 4; i < innerLen; i++){
            inner[i] = 0;
        }
        // outerKey = password ^ opad
        for(i = 0; i < 64; i++)outerKey[i] = 0x5c;
        for(i = 0; i < password.length; i++)outerKey[i] ^= password[i];
        // increments counter inside inner
        function incrementCounter() {
            for(let i = innerLen - 1; i >= innerLen - 4; i--){
                inner[i]++;
                if (inner[i] <= 0xff) return;
                inner[i] = 0;
            }
        }
        // output blocks = SHA256(outerKey || SHA256(inner)) ...
        while(dkLen >= 32){
            incrementCounter();
            dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))));
            dkLen -= 32;
        }
        if (dkLen > 0) {
            incrementCounter();
            dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))).slice(0, dkLen));
        }
        return dk;
    }
    // The following is an adaptation of scryptsy
    // See: https://www.npmjs.com/package/scryptsy
    function blockmix_salsa8(BY, Yi, r, x, _X) {
        let i;
        arraycopy(BY, (2 * r - 1) * 16, _X, 0, 16);
        for(i = 0; i < 2 * r; i++){
            blockxor(BY, i * 16, _X, 16);
            salsa20_8(_X, x);
            arraycopy(_X, 0, BY, Yi + i * 16, 16);
        }
        for(i = 0; i < r; i++){
            arraycopy(BY, Yi + i * 2 * 16, BY, i * 16, 16);
        }
        for(i = 0; i < r; i++){
            arraycopy(BY, Yi + (i * 2 + 1) * 16, BY, (i + r) * 16, 16);
        }
    }
    function R(a, b) {
        return a << b | a >>> 32 - b;
    }
    function salsa20_8(B, x) {
        arraycopy(B, 0, x, 0, 16);
        for(let i = 8; i > 0; i -= 2){
            x[4] ^= R(x[0] + x[12], 7);
            x[8] ^= R(x[4] + x[0], 9);
            x[12] ^= R(x[8] + x[4], 13);
            x[0] ^= R(x[12] + x[8], 18);
            x[9] ^= R(x[5] + x[1], 7);
            x[13] ^= R(x[9] + x[5], 9);
            x[1] ^= R(x[13] + x[9], 13);
            x[5] ^= R(x[1] + x[13], 18);
            x[14] ^= R(x[10] + x[6], 7);
            x[2] ^= R(x[14] + x[10], 9);
            x[6] ^= R(x[2] + x[14], 13);
            x[10] ^= R(x[6] + x[2], 18);
            x[3] ^= R(x[15] + x[11], 7);
            x[7] ^= R(x[3] + x[15], 9);
            x[11] ^= R(x[7] + x[3], 13);
            x[15] ^= R(x[11] + x[7], 18);
            x[1] ^= R(x[0] + x[3], 7);
            x[2] ^= R(x[1] + x[0], 9);
            x[3] ^= R(x[2] + x[1], 13);
            x[0] ^= R(x[3] + x[2], 18);
            x[6] ^= R(x[5] + x[4], 7);
            x[7] ^= R(x[6] + x[5], 9);
            x[4] ^= R(x[7] + x[6], 13);
            x[5] ^= R(x[4] + x[7], 18);
            x[11] ^= R(x[10] + x[9], 7);
            x[8] ^= R(x[11] + x[10], 9);
            x[9] ^= R(x[8] + x[11], 13);
            x[10] ^= R(x[9] + x[8], 18);
            x[12] ^= R(x[15] + x[14], 7);
            x[13] ^= R(x[12] + x[15], 9);
            x[14] ^= R(x[13] + x[12], 13);
            x[15] ^= R(x[14] + x[13], 18);
        }
        for(let i = 0; i < 16; ++i){
            B[i] += x[i];
        }
    }
    // naive approach... going back to loop unrolling may yield additional performance
    function blockxor(S, Si, D, len) {
        for(let i = 0; i < len; i++){
            D[i] ^= S[Si + i];
        }
    }
    function arraycopy(src, srcPos, dest, destPos, length) {
        while(length--){
            dest[destPos++] = src[srcPos++];
        }
    }
    function checkBufferish(o) {
        if (!o || typeof o.length !== 'number') {
            return false;
        }
        for(let i = 0; i < o.length; i++){
            const v = o[i];
            if (typeof v !== 'number' || v % 1 || v < 0 || v >= 256) {
                return false;
            }
        }
        return true;
    }
    function ensureInteger(value, name) {
        if (typeof value !== "number" || value % 1) {
            throw new Error('invalid ' + name);
        }
        return value;
    }
    // N = Cpu cost, r = Memory cost, p = parallelization cost
    // callback(error, progress, key)
    function _scrypt(password, salt, N, r, p, dkLen, callback) {
        N = ensureInteger(N, 'N');
        r = ensureInteger(r, 'r');
        p = ensureInteger(p, 'p');
        dkLen = ensureInteger(dkLen, 'dkLen');
        if (N === 0 || (N & N - 1) !== 0) {
            throw new Error('N must be power of 2');
        }
        if (N > MAX_VALUE / 128 / r) {
            throw new Error('N too large');
        }
        if (r > MAX_VALUE / 128 / p) {
            throw new Error('r too large');
        }
        if (!checkBufferish(password)) {
            throw new Error('password must be an array or buffer');
        }
        password = Array.prototype.slice.call(password);
        if (!checkBufferish(salt)) {
            throw new Error('salt must be an array or buffer');
        }
        salt = Array.prototype.slice.call(salt);
        let b = PBKDF2_HMAC_SHA256_OneIter(password, salt, p * 128 * r);
        const B = new Uint32Array(p * 32 * r);
        for(let i = 0; i < B.length; i++){
            const j = i * 4;
            B[i] = (b[j + 3] & 0xff) << 24 | (b[j + 2] & 0xff) << 16 | (b[j + 1] & 0xff) << 8 | (b[j + 0] & 0xff) << 0;
        }
        const XY = new Uint32Array(64 * r);
        const V = new Uint32Array(32 * r * N);
        const Yi = 32 * r;
        // scratch space
        const x = new Uint32Array(16); // salsa20_8
        const _X = new Uint32Array(16); // blockmix_salsa8
        const totalOps = p * N * 2;
        let currentOp = 0;
        let lastPercent10 = null;
        // Set this to true to abandon the scrypt on the next step
        let stop = false;
        // State information
        let state = 0;
        let i0 = 0, i1;
        let Bi;
        // How many blockmix_salsa8 can we do per step?
        const limit = callback ? parseInt(1000 / r) : 0xffffffff;
        // Trick from scrypt-async; if there is a setImmediate shim in place, use it
        const nextTick = typeof setImmediate !== 'undefined' ? setImmediate : setTimeout;
        // This is really all I changed; making scryptsy a state machine so we occasionally
        // stop and give other evnts on the evnt loop a chance to run. ~RicMoo
        const incrementalSMix = function() {
            if (stop) {
                return callback(new Error('cancelled'), currentOp / totalOps);
            }
            let steps;
            switch(state){
                case 0:
                    // for (var i = 0; i < p; i++)...
                    Bi = i0 * 32 * r;
                    arraycopy(B, Bi, XY, 0, Yi); // ROMix - 1
                    state = 1; // Move to ROMix 2
                    i1 = 0;
                // Fall through
                case 1:
                    // Run up to 1000 steps of the first inner smix loop
                    steps = N - i1;
                    if (steps > limit) {
                        steps = limit;
                    }
                    for(let i = 0; i < steps; i++){
                        arraycopy(XY, 0, V, (i1 + i) * Yi, Yi); // ROMix - 3
                        blockmix_salsa8(XY, Yi, r, x, _X); // ROMix - 4
                    }
                    // for (var i = 0; i < N; i++)
                    i1 += steps;
                    currentOp += steps;
                    if (callback) {
                        // Call the callback with the progress (optionally stopping us)
                        const percent10 = parseInt(1000 * currentOp / totalOps);
                        if (percent10 !== lastPercent10) {
                            stop = callback(null, currentOp / totalOps);
                            if (stop) {
                                break;
                            }
                            lastPercent10 = percent10;
                        }
                    }
                    if (i1 < N) {
                        break;
                    }
                    i1 = 0; // Move to ROMix 6
                    state = 2;
                // Fall through
                case 2:
                    // Run up to 1000 steps of the second inner smix loop
                    steps = N - i1;
                    if (steps > limit) {
                        steps = limit;
                    }
                    for(let i = 0; i < steps; i++){
                        const offset = (2 * r - 1) * 16; // ROMix - 7
                        const j = XY[offset] & N - 1;
                        blockxor(V, j * Yi, XY, Yi); // ROMix - 8 (inner)
                        blockmix_salsa8(XY, Yi, r, x, _X); // ROMix - 9 (outer)
                    }
                    // for (var i = 0; i < N; i++)...
                    i1 += steps;
                    currentOp += steps;
                    // Call the callback with the progress (optionally stopping us)
                    if (callback) {
                        const percent10 = parseInt(1000 * currentOp / totalOps);
                        if (percent10 !== lastPercent10) {
                            stop = callback(null, currentOp / totalOps);
                            if (stop) {
                                break;
                            }
                            lastPercent10 = percent10;
                        }
                    }
                    if (i1 < N) {
                        break;
                    }
                    arraycopy(XY, 0, B, Bi, Yi); // ROMix - 10
                    // for (var i = 0; i < p; i++)...
                    i0++;
                    if (i0 < p) {
                        state = 0;
                        break;
                    }
                    b = [];
                    for(let i = 0; i < B.length; i++){
                        b.push(B[i] >> 0 & 0xff);
                        b.push(B[i] >> 8 & 0xff);
                        b.push(B[i] >> 16 & 0xff);
                        b.push(B[i] >> 24 & 0xff);
                    }
                    const derivedKey = PBKDF2_HMAC_SHA256_OneIter(password, b, dkLen);
                    // Send the result to the callback
                    if (callback) {
                        callback(null, 1.0, derivedKey);
                    }
                    // Done; don't break (which would reschedule)
                    return derivedKey;
            }
            // Schedule the next steps
            if (callback) {
                nextTick(incrementalSMix);
            }
        };
        // Run the smix state machine until completion
        if (!callback) {
            while(true){
                const derivedKey = incrementalSMix();
                if (derivedKey != undefined) {
                    return derivedKey;
                }
            }
        }
        // Bootstrap the async incremental smix
        incrementalSMix();
    }
    const lib = {
        scrypt: function(password, salt, N, r, p, dkLen, progressCallback) {
            return new Promise(function(resolve, reject) {
                let lastProgress = 0;
                if (progressCallback) {
                    progressCallback(0);
                }
                _scrypt(password, salt, N, r, p, dkLen, function(error, progress, key) {
                    if (error) {
                        reject(error);
                    } else if (key) {
                        if (progressCallback && lastProgress !== 1) {
                            progressCallback(1);
                        }
                        resolve(new Uint8Array(key));
                    } else if (progressCallback && progress !== lastProgress) {
                        lastProgress = progress;
                        return progressCallback(progress);
                    }
                });
            });
        },
        syncScrypt: function(password, salt, N, r, p, dkLen) {
            return new Uint8Array(_scrypt(password, salt, N, r, p, dkLen));
        }
    };
    // node.js
    if ("TURBOPACK compile-time truthy", 1) {
        module.exports = lib;
    // RequireJS/AMD
    // http://www.requirejs.org/docs/api.html
    // https://github.com/amdjs/amdjs-api/wiki/AMD
    } else //TURBOPACK unreachable
    ;
})(/*TURBOPACK member replacement*/ __turbopack_context__.e);
}),
"[project]/node_modules/fast-deep-equal/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// do not edit .js files directly - edit src/index.jst
module.exports = function equal(a, b) {
    if (a === b) return true;
    if (a && b && typeof a == 'object' && typeof b == 'object') {
        if (a.constructor !== b.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a)) {
            length = a.length;
            if (length != b.length) return false;
            for(i = length; i-- !== 0;)if (!equal(a[i], b[i])) return false;
            return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for(i = length; i-- !== 0;)if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        for(i = length; i-- !== 0;){
            var key = keys[i];
            if (!equal(a[key], b[key])) return false;
        }
        return true;
    }
    // true if both NaN, false otherwise
    return a !== a && b !== b;
};
}),
"[project]/node_modules/conf/node_modules/json-schema-traverse/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var traverse = module.exports = function(schema, opts, cb) {
    // Legacy support for v0.3.1 and earlier.
    if (typeof opts == 'function') {
        cb = opts;
        opts = {};
    }
    cb = opts.cb || cb;
    var pre = typeof cb == 'function' ? cb : cb.pre || function() {};
    var post = cb.post || function() {};
    _traverse(opts, pre, post, schema, '', schema);
};
traverse.keywords = {
    additionalItems: true,
    items: true,
    contains: true,
    additionalProperties: true,
    propertyNames: true,
    not: true,
    if: true,
    then: true,
    else: true
};
traverse.arrayKeywords = {
    items: true,
    allOf: true,
    anyOf: true,
    oneOf: true
};
traverse.propsKeywords = {
    $defs: true,
    definitions: true,
    properties: true,
    patternProperties: true,
    dependencies: true
};
traverse.skipKeywords = {
    default: true,
    enum: true,
    const: true,
    required: true,
    maximum: true,
    minimum: true,
    exclusiveMaximum: true,
    exclusiveMinimum: true,
    multipleOf: true,
    maxLength: true,
    minLength: true,
    pattern: true,
    format: true,
    maxItems: true,
    minItems: true,
    uniqueItems: true,
    maxProperties: true,
    minProperties: true
};
function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for(var key in schema){
            var sch = schema[key];
            if (Array.isArray(sch)) {
                if (key in traverse.arrayKeywords) {
                    for(var i = 0; i < sch.length; i++)_traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
                }
            } else if (key in traverse.propsKeywords) {
                if (sch && typeof sch == 'object') {
                    for(var prop in sch)_traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
                }
            } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
                _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
            }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    }
}
function escapeJsonPtr(str) {
    return str.replace(/~/g, '~0').replace(/\//g, '~1');
}
}),
"[project]/node_modules/conf/node_modules/semver/internal/constants.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const SEMVER_SPEC_VERSION = '2.0.0';
const MAX_LENGTH = 256;
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */ 9007199254740991;
// Max safe segment length for coercion.
const MAX_SAFE_COMPONENT_LENGTH = 16;
// Max safe length for a build identifier. The max length minus 6 characters for
// the shortest version with a build 0.0.0+BUILD.
const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
const RELEASE_TYPES = [
    'major',
    'premajor',
    'minor',
    'preminor',
    'patch',
    'prepatch',
    'prerelease'
];
module.exports = {
    MAX_LENGTH,
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER,
    RELEASE_TYPES,
    SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 0b001,
    FLAG_LOOSE: 0b010
};
}),
"[project]/node_modules/conf/node_modules/semver/internal/debug.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
const debug = typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] === 'object' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.NODE_DEBUG && /\bsemver\b/i.test(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env.NODE_DEBUG) ? (...args)=>console.error('SEMVER', ...args) : ()=>{};
module.exports = debug;
}),
"[project]/node_modules/conf/node_modules/semver/internal/re.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { MAX_SAFE_COMPONENT_LENGTH, MAX_SAFE_BUILD_LENGTH, MAX_LENGTH } = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/internal/constants.js [app-client] (ecmascript)");
const debug = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/internal/debug.js [app-client] (ecmascript)");
exports = module.exports = {};
// The actual regexps go on exports.re
const re = exports.re = [];
const safeRe = exports.safeRe = [];
const src = exports.src = [];
const safeSrc = exports.safeSrc = [];
const t = exports.t = {};
let R = 0;
const LETTERDASHNUMBER = '[a-zA-Z0-9-]';
// Replace some greedy regex tokens to prevent regex dos issues. These regex are
// used internally via the safeRe object since all inputs in this library get
// normalized first to trim and collapse all extra whitespace. The original
// regexes are exported for userland consumption and lower level usage. A
// future breaking change could export the safer regex only with a note that
// all input should have extra whitespace removed.
const safeRegexReplacements = [
    [
        '\\s',
        1
    ],
    [
        '\\d',
        MAX_LENGTH
    ],
    [
        LETTERDASHNUMBER,
        MAX_SAFE_BUILD_LENGTH
    ]
];
const makeSafeRegex = (value)=>{
    for (const [token, max] of safeRegexReplacements){
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
    }
    return value;
};
const createToken = (name, value, isGlobal)=>{
    const safe = makeSafeRegex(value);
    const index = R++;
    debug(name, index, value);
    t[name] = index;
    src[index] = value;
    safeSrc[index] = safe;
    re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
    safeRe[index] = new RegExp(safe, isGlobal ? 'g' : undefined);
};
// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.
// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.
createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
createToken('NUMERICIDENTIFIERLOOSE', '\\d+');
// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.
createToken('NONNUMERICIDENTIFIER', `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
// ## Main Version
// Three dot-separated numeric identifiers.
createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})`);
createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})`);
// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.
// Non-numberic identifiers include numberic identifiers but can be longer.
// Therefore non-numberic identifiers must go first.
createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIER]})`);
createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NONNUMERICIDENTIFIER]}|${src[t.NUMERICIDENTIFIERLOOSE]})`);
// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.
createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.
createToken('BUILDIDENTIFIER', `${LETTERDASHNUMBER}+`);
// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.
createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.
// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.
createToken('FULLPLAIN', `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
createToken('FULL', `^${src[t.FULLPLAIN]}$`);
// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`);
createToken('GTLT', '((?:<|>)?=?)');
// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?` + `)?)?`);
createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?` + `)?)?`);
createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
// Coercion.
// Extract anything that could conceivably be a part of a valid semver
createToken('COERCEPLAIN', `${'(^|[^\\d])' + '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
createToken('COERCE', `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
createToken('COERCEFULL', src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?` + `(?:${src[t.BUILD]})?` + `(?:$|[^\\d])`);
createToken('COERCERTL', src[t.COERCE], true);
createToken('COERCERTLFULL', src[t.COERCEFULL], true);
// Tilde ranges.
// Meaning is "reasonably at or greater than"
createToken('LONETILDE', '(?:~>?)');
createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true);
exports.tildeTrimReplace = '$1~';
createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
// Caret ranges.
// Meaning is "at least and backwards compatible with"
createToken('LONECARET', '(?:\\^)');
createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true);
exports.caretTrimReplace = '$1^';
createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
// A simple gt/lt/eq thing, or just "" to indicate "any version"
createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
exports.comparatorTrimReplace = '$1$2$3';
// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAIN]})` + `\\s*$`);
createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAINLOOSE]})` + `\\s*$`);
// Star ranges basically just allow anything at all.
createToken('STAR', '(<|>)?=?\\s*\\*');
// >=0.0.0 is like a star
createToken('GTE0', '^\\s*>=\\s*0\\.0\\.0\\s*$');
createToken('GTE0PRE', '^\\s*>=\\s*0\\.0\\.0-0\\s*$');
}),
"[project]/node_modules/conf/node_modules/semver/internal/parse-options.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// parse out just the options we care about
const looseOption = Object.freeze({
    loose: true
});
const emptyOpts = Object.freeze({});
const parseOptions = (options)=>{
    if (!options) {
        return emptyOpts;
    }
    if (typeof options !== 'object') {
        return looseOption;
    }
    return options;
};
module.exports = parseOptions;
}),
"[project]/node_modules/conf/node_modules/semver/internal/identifiers.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const numeric = /^[0-9]+$/;
const compareIdentifiers = (a, b)=>{
    if (typeof a === 'number' && typeof b === 'number') {
        return a === b ? 0 : a < b ? -1 : 1;
    }
    const anum = numeric.test(a);
    const bnum = numeric.test(b);
    if (anum && bnum) {
        a = +a;
        b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
};
const rcompareIdentifiers = (a, b)=>compareIdentifiers(b, a);
module.exports = {
    compareIdentifiers,
    rcompareIdentifiers
};
}),
"[project]/node_modules/conf/node_modules/semver/classes/semver.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const debug = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/internal/debug.js [app-client] (ecmascript)");
const { MAX_LENGTH, MAX_SAFE_INTEGER } = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/internal/constants.js [app-client] (ecmascript)");
const { safeRe: re, t } = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/internal/re.js [app-client] (ecmascript)");
const parseOptions = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/internal/parse-options.js [app-client] (ecmascript)");
const { compareIdentifiers } = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/internal/identifiers.js [app-client] (ecmascript)");
class SemVer {
    constructor(version, options){
        options = parseOptions(options);
        if (version instanceof SemVer) {
            if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
                return version;
            } else {
                version = version.version;
            }
        } else if (typeof version !== 'string') {
            throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        }
        if (version.length > MAX_LENGTH) {
            throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
        }
        debug('SemVer', version, options);
        this.options = options;
        this.loose = !!options.loose;
        // this isn't actually relevant for versions, but keep it so that we
        // don't run into trouble passing this.options around.
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
            throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        // these are actually numbers
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
            throw new TypeError('Invalid major version');
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
            throw new TypeError('Invalid minor version');
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
            throw new TypeError('Invalid patch version');
        }
        // numberify any prerelease numeric ids
        if (!m[4]) {
            this.prerelease = [];
        } else {
            this.prerelease = m[4].split('.').map((id)=>{
                if (/^[0-9]+$/.test(id)) {
                    const num = +id;
                    if (num >= 0 && num < MAX_SAFE_INTEGER) {
                        return num;
                    }
                }
                return id;
            });
        }
        this.build = m[5] ? m[5].split('.') : [];
        this.format();
    }
    format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
            this.version += `-${this.prerelease.join('.')}`;
        }
        return this.version;
    }
    toString() {
        return this.version;
    }
    compare(other) {
        debug('SemVer.compare', this.version, this.options, other);
        if (!(other instanceof SemVer)) {
            if (typeof other === 'string' && other === this.version) {
                return 0;
            }
            other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
            return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
        if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
        }
        if (this.major < other.major) {
            return -1;
        }
        if (this.major > other.major) {
            return 1;
        }
        if (this.minor < other.minor) {
            return -1;
        }
        if (this.minor > other.minor) {
            return 1;
        }
        if (this.patch < other.patch) {
            return -1;
        }
        if (this.patch > other.patch) {
            return 1;
        }
        return 0;
    }
    comparePre(other) {
        if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
        }
        // NOT having a prerelease is > having one
        if (this.prerelease.length && !other.prerelease.length) {
            return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
            return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
            return 0;
        }
        let i = 0;
        do {
            const a = this.prerelease[i];
            const b = other.prerelease[i];
            debug('prerelease compare', i, a, b);
            if (a === undefined && b === undefined) {
                return 0;
            } else if (b === undefined) {
                return 1;
            } else if (a === undefined) {
                return -1;
            } else if (a === b) {
                continue;
            } else {
                return compareIdentifiers(a, b);
            }
        }while (++i)
    }
    compareBuild(other) {
        if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
        }
        let i = 0;
        do {
            const a = this.build[i];
            const b = other.build[i];
            debug('build compare', i, a, b);
            if (a === undefined && b === undefined) {
                return 0;
            } else if (b === undefined) {
                return 1;
            } else if (a === undefined) {
                return -1;
            } else if (a === b) {
                continue;
            } else {
                return compareIdentifiers(a, b);
            }
        }while (++i)
    }
    // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.
    inc(release, identifier, identifierBase) {
        if (release.startsWith('pre')) {
            if (!identifier && identifierBase === false) {
                throw new Error('invalid increment argument: identifier is empty');
            }
            // Avoid an invalid semver results
            if (identifier) {
                const match = `-${identifier}`.match(this.options.loose ? re[t.PRERELEASELOOSE] : re[t.PRERELEASE]);
                if (!match || match[1] !== identifier) {
                    throw new Error(`invalid identifier: ${identifier}`);
                }
            }
        }
        switch(release){
            case 'premajor':
                this.prerelease.length = 0;
                this.patch = 0;
                this.minor = 0;
                this.major++;
                this.inc('pre', identifier, identifierBase);
                break;
            case 'preminor':
                this.prerelease.length = 0;
                this.patch = 0;
                this.minor++;
                this.inc('pre', identifier, identifierBase);
                break;
            case 'prepatch':
                // If this is already a prerelease, it will bump to the next version
                // drop any prereleases that might already exist, since they are not
                // relevant at this point.
                this.prerelease.length = 0;
                this.inc('patch', identifier, identifierBase);
                this.inc('pre', identifier, identifierBase);
                break;
            // If the input is a non-prerelease version, this acts the same as
            // prepatch.
            case 'prerelease':
                if (this.prerelease.length === 0) {
                    this.inc('patch', identifier, identifierBase);
                }
                this.inc('pre', identifier, identifierBase);
                break;
            case 'release':
                if (this.prerelease.length === 0) {
                    throw new Error(`version ${this.raw} is not a prerelease`);
                }
                this.prerelease.length = 0;
                break;
            case 'major':
                // If this is a pre-major version, bump up to the same major version.
                // Otherwise increment major.
                // 1.0.0-5 bumps to 1.0.0
                // 1.1.0 bumps to 2.0.0
                if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
                    this.major++;
                }
                this.minor = 0;
                this.patch = 0;
                this.prerelease = [];
                break;
            case 'minor':
                // If this is a pre-minor version, bump up to the same minor version.
                // Otherwise increment minor.
                // 1.2.0-5 bumps to 1.2.0
                // 1.2.1 bumps to 1.3.0
                if (this.patch !== 0 || this.prerelease.length === 0) {
                    this.minor++;
                }
                this.patch = 0;
                this.prerelease = [];
                break;
            case 'patch':
                // If this is not a pre-release version, it will increment the patch.
                // If it is a pre-release it will bump up to the same patch version.
                // 1.2.0-5 patches to 1.2.0
                // 1.2.0 patches to 1.2.1
                if (this.prerelease.length === 0) {
                    this.patch++;
                }
                this.prerelease = [];
                break;
            // This probably shouldn't be used publicly.
            // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
            case 'pre':
                {
                    const base = Number(identifierBase) ? 1 : 0;
                    if (this.prerelease.length === 0) {
                        this.prerelease = [
                            base
                        ];
                    } else {
                        let i = this.prerelease.length;
                        while(--i >= 0){
                            if (typeof this.prerelease[i] === 'number') {
                                this.prerelease[i]++;
                                i = -2;
                            }
                        }
                        if (i === -1) {
                            // didn't increment anything
                            if (identifier === this.prerelease.join('.') && identifierBase === false) {
                                throw new Error('invalid increment argument: identifier already exists');
                            }
                            this.prerelease.push(base);
                        }
                    }
                    if (identifier) {
                        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
                        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
                        let prerelease = [
                            identifier,
                            base
                        ];
                        if (identifierBase === false) {
                            prerelease = [
                                identifier
                            ];
                        }
                        if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                            if (isNaN(this.prerelease[1])) {
                                this.prerelease = prerelease;
                            }
                        } else {
                            this.prerelease = prerelease;
                        }
                    }
                    break;
                }
            default:
                throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
            this.raw += `+${this.build.join('.')}`;
        }
        return this;
    }
}
module.exports = SemVer;
}),
"[project]/node_modules/conf/node_modules/semver/functions/parse.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/classes/semver.js [app-client] (ecmascript)");
const parse = (version, options, throwErrors = false)=>{
    if (version instanceof SemVer) {
        return version;
    }
    try {
        return new SemVer(version, options);
    } catch (er) {
        if (!throwErrors) {
            return null;
        }
        throw er;
    }
};
module.exports = parse;
}),
"[project]/node_modules/conf/node_modules/semver/functions/valid.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const parse = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/parse.js [app-client] (ecmascript)");
const valid = (version, options)=>{
    const v = parse(version, options);
    return v ? v.version : null;
};
module.exports = valid;
}),
"[project]/node_modules/conf/node_modules/semver/functions/clean.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const parse = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/parse.js [app-client] (ecmascript)");
const clean = (version, options)=>{
    const s = parse(version.trim().replace(/^[=v]+/, ''), options);
    return s ? s.version : null;
};
module.exports = clean;
}),
"[project]/node_modules/conf/node_modules/semver/functions/inc.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/classes/semver.js [app-client] (ecmascript)");
const inc = (version, release, options, identifier, identifierBase)=>{
    if (typeof options === 'string') {
        identifierBase = identifier;
        identifier = options;
        options = undefined;
    }
    try {
        return new SemVer(version instanceof SemVer ? version.version : version, options).inc(release, identifier, identifierBase).version;
    } catch (er) {
        return null;
    }
};
module.exports = inc;
}),
"[project]/node_modules/conf/node_modules/semver/functions/diff.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const parse = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/parse.js [app-client] (ecmascript)");
const diff = (version1, version2)=>{
    const v1 = parse(version1, null, true);
    const v2 = parse(version2, null, true);
    const comparison = v1.compare(v2);
    if (comparison === 0) {
        return null;
    }
    const v1Higher = comparison > 0;
    const highVersion = v1Higher ? v1 : v2;
    const lowVersion = v1Higher ? v2 : v1;
    const highHasPre = !!highVersion.prerelease.length;
    const lowHasPre = !!lowVersion.prerelease.length;
    if (lowHasPre && !highHasPre) {
        // Going from prerelease -> no prerelease requires some special casing
        // If the low version has only a major, then it will always be a major
        // Some examples:
        // 1.0.0-1 -> 1.0.0
        // 1.0.0-1 -> 1.1.1
        // 1.0.0-1 -> 2.0.0
        if (!lowVersion.patch && !lowVersion.minor) {
            return 'major';
        }
        // If the main part has no difference
        if (lowVersion.compareMain(highVersion) === 0) {
            if (lowVersion.minor && !lowVersion.patch) {
                return 'minor';
            }
            return 'patch';
        }
    }
    // add the `pre` prefix if we are going to a prerelease version
    const prefix = highHasPre ? 'pre' : '';
    if (v1.major !== v2.major) {
        return prefix + 'major';
    }
    if (v1.minor !== v2.minor) {
        return prefix + 'minor';
    }
    if (v1.patch !== v2.patch) {
        return prefix + 'patch';
    }
    // high and low are preleases
    return 'prerelease';
};
module.exports = diff;
}),
"[project]/node_modules/conf/node_modules/semver/functions/major.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/classes/semver.js [app-client] (ecmascript)");
const major = (a, loose)=>new SemVer(a, loose).major;
module.exports = major;
}),
"[project]/node_modules/conf/node_modules/semver/functions/minor.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/classes/semver.js [app-client] (ecmascript)");
const minor = (a, loose)=>new SemVer(a, loose).minor;
module.exports = minor;
}),
"[project]/node_modules/conf/node_modules/semver/functions/patch.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/classes/semver.js [app-client] (ecmascript)");
const patch = (a, loose)=>new SemVer(a, loose).patch;
module.exports = patch;
}),
"[project]/node_modules/conf/node_modules/semver/functions/prerelease.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const parse = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/parse.js [app-client] (ecmascript)");
const prerelease = (version, options)=>{
    const parsed = parse(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
};
module.exports = prerelease;
}),
"[project]/node_modules/conf/node_modules/semver/functions/compare.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/classes/semver.js [app-client] (ecmascript)");
const compare = (a, b, loose)=>new SemVer(a, loose).compare(new SemVer(b, loose));
module.exports = compare;
}),
"[project]/node_modules/conf/node_modules/semver/functions/rcompare.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const compare = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/compare.js [app-client] (ecmascript)");
const rcompare = (a, b, loose)=>compare(b, a, loose);
module.exports = rcompare;
}),
"[project]/node_modules/conf/node_modules/semver/functions/compare-loose.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const compare = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/compare.js [app-client] (ecmascript)");
const compareLoose = (a, b)=>compare(a, b, true);
module.exports = compareLoose;
}),
"[project]/node_modules/conf/node_modules/semver/functions/compare-build.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/classes/semver.js [app-client] (ecmascript)");
const compareBuild = (a, b, loose)=>{
    const versionA = new SemVer(a, loose);
    const versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
};
module.exports = compareBuild;
}),
"[project]/node_modules/conf/node_modules/semver/functions/sort.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const compareBuild = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/compare-build.js [app-client] (ecmascript)");
const sort = (list, loose)=>list.sort((a, b)=>compareBuild(a, b, loose));
module.exports = sort;
}),
"[project]/node_modules/conf/node_modules/semver/functions/rsort.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const compareBuild = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/compare-build.js [app-client] (ecmascript)");
const rsort = (list, loose)=>list.sort((a, b)=>compareBuild(b, a, loose));
module.exports = rsort;
}),
"[project]/node_modules/conf/node_modules/semver/functions/gt.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const compare = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/compare.js [app-client] (ecmascript)");
const gt = (a, b, loose)=>compare(a, b, loose) > 0;
module.exports = gt;
}),
"[project]/node_modules/conf/node_modules/semver/functions/lt.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const compare = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/compare.js [app-client] (ecmascript)");
const lt = (a, b, loose)=>compare(a, b, loose) < 0;
module.exports = lt;
}),
"[project]/node_modules/conf/node_modules/semver/functions/eq.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const compare = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/compare.js [app-client] (ecmascript)");
const eq = (a, b, loose)=>compare(a, b, loose) === 0;
module.exports = eq;
}),
"[project]/node_modules/conf/node_modules/semver/functions/neq.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const compare = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/compare.js [app-client] (ecmascript)");
const neq = (a, b, loose)=>compare(a, b, loose) !== 0;
module.exports = neq;
}),
"[project]/node_modules/conf/node_modules/semver/functions/gte.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const compare = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/compare.js [app-client] (ecmascript)");
const gte = (a, b, loose)=>compare(a, b, loose) >= 0;
module.exports = gte;
}),
"[project]/node_modules/conf/node_modules/semver/functions/lte.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const compare = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/compare.js [app-client] (ecmascript)");
const lte = (a, b, loose)=>compare(a, b, loose) <= 0;
module.exports = lte;
}),
"[project]/node_modules/conf/node_modules/semver/functions/cmp.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const eq = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/eq.js [app-client] (ecmascript)");
const neq = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/neq.js [app-client] (ecmascript)");
const gt = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/gt.js [app-client] (ecmascript)");
const gte = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/gte.js [app-client] (ecmascript)");
const lt = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/lt.js [app-client] (ecmascript)");
const lte = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/lte.js [app-client] (ecmascript)");
const cmp = (a, op, b, loose)=>{
    switch(op){
        case '===':
            if (typeof a === 'object') {
                a = a.version;
            }
            if (typeof b === 'object') {
                b = b.version;
            }
            return a === b;
        case '!==':
            if (typeof a === 'object') {
                a = a.version;
            }
            if (typeof b === 'object') {
                b = b.version;
            }
            return a !== b;
        case '':
        case '=':
        case '==':
            return eq(a, b, loose);
        case '!=':
            return neq(a, b, loose);
        case '>':
            return gt(a, b, loose);
        case '>=':
            return gte(a, b, loose);
        case '<':
            return lt(a, b, loose);
        case '<=':
            return lte(a, b, loose);
        default:
            throw new TypeError(`Invalid operator: ${op}`);
    }
};
module.exports = cmp;
}),
"[project]/node_modules/conf/node_modules/semver/functions/coerce.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/classes/semver.js [app-client] (ecmascript)");
const parse = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/parse.js [app-client] (ecmascript)");
const { safeRe: re, t } = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/internal/re.js [app-client] (ecmascript)");
const coerce = (version, options)=>{
    if (version instanceof SemVer) {
        return version;
    }
    if (typeof version === 'number') {
        version = String(version);
    }
    if (typeof version !== 'string') {
        return null;
    }
    options = options || {};
    let match = null;
    if (!options.rtl) {
        match = version.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
    } else {
        // Find the right-most coercible string that does not share
        // a terminus with a more left-ward coercible string.
        // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
        // With includePrerelease option set, '1.2.3.4-rc' wants to coerce '2.3.4-rc', not '2.3.4'
        //
        // Walk through the string checking with a /g regexp
        // Manually set the index so as to pick up overlapping matches.
        // Stop when we get a match that ends at the string end, since no
        // coercible string can be more right-ward without the same terminus.
        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next;
        while((next = coerceRtlRegex.exec(version)) && (!match || match.index + match[0].length !== version.length)){
            if (!match || next.index + next[0].length !== match.index + match[0].length) {
                match = next;
            }
            coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        // leave it in a clean state
        coerceRtlRegex.lastIndex = -1;
    }
    if (match === null) {
        return null;
    }
    const major = match[2];
    const minor = match[3] || '0';
    const patch = match[4] || '0';
    const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : '';
    const build = options.includePrerelease && match[6] ? `+${match[6]}` : '';
    return parse(`${major}.${minor}.${patch}${prerelease}${build}`, options);
};
module.exports = coerce;
}),
"[project]/node_modules/conf/node_modules/semver/internal/lrucache.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

class LRUCache {
    constructor(){
        this.max = 1000;
        this.map = new Map();
    }
    get(key) {
        const value = this.map.get(key);
        if (value === undefined) {
            return undefined;
        } else {
            // Remove the key from the map and add it to the end
            this.map.delete(key);
            this.map.set(key, value);
            return value;
        }
    }
    delete(key) {
        return this.map.delete(key);
    }
    set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== undefined) {
            // If cache is full, delete the least recently used item
            if (this.map.size >= this.max) {
                const firstKey = this.map.keys().next().value;
                this.delete(firstKey);
            }
            this.map.set(key, value);
        }
        return this;
    }
}
module.exports = LRUCache;
}),
"[project]/node_modules/conf/node_modules/semver/classes/range.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SPACE_CHARACTERS = /\s+/g;
// hoisted class for cyclic dependency
class Range {
    constructor(range, options){
        options = parseOptions(options);
        if (range instanceof Range) {
            if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
                return range;
            } else {
                return new Range(range.raw, options);
            }
        }
        if (range instanceof Comparator) {
            // just put it in the set and return
            this.raw = range.value;
            this.set = [
                [
                    range
                ]
            ];
            this.formatted = undefined;
            return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        // First reduce all whitespace as much as possible so we do not have to rely
        // on potentially slow regexes like \s*. This is then stored and used for
        // future error messages as well.
        this.raw = range.trim().replace(SPACE_CHARACTERS, ' ');
        // First, split on ||
        this.set = this.raw.split('||')// map the range to a 2d array of comparators
        .map((r)=>this.parseRange(r.trim()))// throw out any comparator lists that are empty
        // this generally means that it was not a valid range, which is allowed
        // in loose mode, but will still throw if the WHOLE range is invalid.
        .filter((c)=>c.length);
        if (!this.set.length) {
            throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        // if we have any that are not the null set, throw out null sets.
        if (this.set.length > 1) {
            // keep the first one, in case they're all null sets
            const first = this.set[0];
            this.set = this.set.filter((c)=>!isNullSet(c[0]));
            if (this.set.length === 0) {
                this.set = [
                    first
                ];
            } else if (this.set.length > 1) {
                // if we have any that are *, then the range is just *
                for (const c of this.set){
                    if (c.length === 1 && isAny(c[0])) {
                        this.set = [
                            c
                        ];
                        break;
                    }
                }
            }
        }
        this.formatted = undefined;
    }
    get range() {
        if (this.formatted === undefined) {
            this.formatted = '';
            for(let i = 0; i < this.set.length; i++){
                if (i > 0) {
                    this.formatted += '||';
                }
                const comps = this.set[i];
                for(let k = 0; k < comps.length; k++){
                    if (k > 0) {
                        this.formatted += ' ';
                    }
                    this.formatted += comps[k].toString().trim();
                }
            }
        }
        return this.formatted;
    }
    format() {
        return this.range;
    }
    toString() {
        return this.range;
    }
    parseRange(range) {
        // memoize range parsing for performance.
        // this is a very hot path, and fully deterministic.
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ':' + range;
        const cached = cache.get(memoKey);
        if (cached) {
            return cached;
        }
        const loose = this.options.loose;
        // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug('hyphen replace', range);
        // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug('comparator trim', range);
        // `~ 1.2.3` => `~1.2.3`
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug('tilde trim', range);
        // `^ 1.2.3` => `^1.2.3`
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug('caret trim', range);
        // At this point, the range is completely trimmed and
        // ready to be split into comparators.
        let rangeList = range.split(' ').map((comp)=>parseComparator(comp, this.options)).join(' ').split(/\s+/)// >=0.0.0 is equivalent to *
        .map((comp)=>replaceGTE0(comp, this.options));
        if (loose) {
            // in loose mode, throw out any that are not valid comparators
            rangeList = rangeList.filter((comp)=>{
                debug('loose invalid filter', comp, this.options);
                return !!comp.match(re[t.COMPARATORLOOSE]);
            });
        }
        debug('range list', rangeList);
        // if any comparators are the null set, then replace with JUST null set
        // if more than one comparator, remove any * comparators
        // also, don't include the same comparator more than once
        const rangeMap = new Map();
        const comparators = rangeList.map((comp)=>new Comparator(comp, this.options));
        for (const comp of comparators){
            if (isNullSet(comp)) {
                return [
                    comp
                ];
            }
            rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has('')) {
            rangeMap.delete('');
        }
        const result = [
            ...rangeMap.values()
        ];
        cache.set(memoKey, result);
        return result;
    }
    intersects(range, options) {
        if (!(range instanceof Range)) {
            throw new TypeError('a Range is required');
        }
        return this.set.some((thisComparators)=>{
            return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators)=>{
                return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator)=>{
                    return rangeComparators.every((rangeComparator)=>{
                        return thisComparator.intersects(rangeComparator, options);
                    });
                });
            });
        });
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(version) {
        if (!version) {
            return false;
        }
        if (typeof version === 'string') {
            try {
                version = new SemVer(version, this.options);
            } catch (er) {
                return false;
            }
        }
        for(let i = 0; i < this.set.length; i++){
            if (testSet(this.set[i], version, this.options)) {
                return true;
            }
        }
        return false;
    }
}
module.exports = Range;
const LRU = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/internal/lrucache.js [app-client] (ecmascript)");
const cache = new LRU();
const parseOptions = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/internal/parse-options.js [app-client] (ecmascript)");
const Comparator = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/classes/comparator.js [app-client] (ecmascript)");
const debug = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/internal/debug.js [app-client] (ecmascript)");
const SemVer = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/classes/semver.js [app-client] (ecmascript)");
const { safeRe: re, t, comparatorTrimReplace, tildeTrimReplace, caretTrimReplace } = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/internal/re.js [app-client] (ecmascript)");
const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/internal/constants.js [app-client] (ecmascript)");
const isNullSet = (c)=>c.value === '<0.0.0-0';
const isAny = (c)=>c.value === '';
// take a set of comparators and determine whether there
// exists a version which can satisfy it
const isSatisfiable = (comparators, options)=>{
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while(result && remainingComparators.length){
        result = remainingComparators.every((otherComparator)=>{
            return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
    }
    return result;
};
// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
const parseComparator = (comp, options)=>{
    comp = comp.replace(re[t.BUILD], '');
    debug('comp', comp, options);
    comp = replaceCarets(comp, options);
    debug('caret', comp);
    comp = replaceTildes(comp, options);
    debug('tildes', comp);
    comp = replaceXRanges(comp, options);
    debug('xrange', comp);
    comp = replaceStars(comp, options);
    debug('stars', comp);
    return comp;
};
const isX = (id)=>!id || id.toLowerCase() === 'x' || id === '*';
// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
// ~0.0.1 --> >=0.0.1 <0.1.0-0
const replaceTildes = (comp, options)=>{
    return comp.trim().split(/\s+/).map((c)=>replaceTilde(c, options)).join(' ');
};
const replaceTilde = (comp, options)=>{
    const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
    return comp.replace(r, (_, M, m, p, pr)=>{
        debug('tilde', comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
            ret = '';
        } else if (isX(m)) {
            ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
            // ~1.2 == >=1.2.0 <1.3.0-0
            ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
            debug('replaceTilde pr', pr);
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
            // ~1.2.3 == >=1.2.3 <1.3.0-0
            ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug('tilde return', ret);
        return ret;
    });
};
// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
// ^1.2.3 --> >=1.2.3 <2.0.0-0
// ^1.2.0 --> >=1.2.0 <2.0.0-0
// ^0.0.1 --> >=0.0.1 <0.0.2-0
// ^0.1.0 --> >=0.1.0 <0.2.0-0
const replaceCarets = (comp, options)=>{
    return comp.trim().split(/\s+/).map((c)=>replaceCaret(c, options)).join(' ');
};
const replaceCaret = (comp, options)=>{
    debug('caret', comp, options);
    const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
    const z = options.includePrerelease ? '-0' : '';
    return comp.replace(r, (_, M, m, p, pr)=>{
        debug('caret', comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
            ret = '';
        } else if (isX(m)) {
            ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
            if (M === '0') {
                ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
            } else {
                ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
            }
        } else if (pr) {
            debug('replaceCaret pr', pr);
            if (M === '0') {
                if (m === '0') {
                    ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
                } else {
                    ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
                }
            } else {
                ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
            }
        } else {
            debug('no pr');
            if (M === '0') {
                if (m === '0') {
                    ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
                } else {
                    ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
                }
            } else {
                ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
            }
        }
        debug('caret return', ret);
        return ret;
    });
};
const replaceXRanges = (comp, options)=>{
    debug('replaceXRanges', comp, options);
    return comp.split(/\s+/).map((c)=>replaceXRange(c, options)).join(' ');
};
const replaceXRange = (comp, options)=>{
    comp = comp.trim();
    const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr)=>{
        debug('xRange', comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === '=' && anyX) {
            gtlt = '';
        }
        // if we're including prereleases in the match, then we need
        // to fix this to -0, the lowest possible prerelease value
        pr = options.includePrerelease ? '-0' : '';
        if (xM) {
            if (gtlt === '>' || gtlt === '<') {
                // nothing is allowed
                ret = '<0.0.0-0';
            } else {
                // nothing is forbidden
                ret = '*';
            }
        } else if (gtlt && anyX) {
            // we know patch is an x, because we have any x at all.
            // replace X with 0
            if (xm) {
                m = 0;
            }
            p = 0;
            if (gtlt === '>') {
                // >1 => >=2.0.0
                // >1.2 => >=1.3.0
                gtlt = '>=';
                if (xm) {
                    M = +M + 1;
                    m = 0;
                    p = 0;
                } else {
                    m = +m + 1;
                    p = 0;
                }
            } else if (gtlt === '<=') {
                // <=0.7.x is actually <0.8.0, since any 0.7.x should
                // pass.  Similarly, <=7.x is actually <8.0.0, etc.
                gtlt = '<';
                if (xm) {
                    M = +M + 1;
                } else {
                    m = +m + 1;
                }
            }
            if (gtlt === '<') {
                pr = '-0';
            }
            ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
            ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
            ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug('xRange return', ret);
        return ret;
    });
};
// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
const replaceStars = (comp, options)=>{
    debug('replaceStars', comp, options);
    // Looseness is ignored here.  star is always as loose as it gets!
    return comp.trim().replace(re[t.STAR], '');
};
const replaceGTE0 = (comp, options)=>{
    debug('replaceGTE0', comp, options);
    return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], '');
};
// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
// TODO build?
const hyphenReplace = (incPr)=>($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr)=>{
        if (isX(fM)) {
            from = '';
        } else if (isX(fm)) {
            from = `>=${fM}.0.0${incPr ? '-0' : ''}`;
        } else if (isX(fp)) {
            from = `>=${fM}.${fm}.0${incPr ? '-0' : ''}`;
        } else if (fpr) {
            from = `>=${from}`;
        } else {
            from = `>=${from}${incPr ? '-0' : ''}`;
        }
        if (isX(tM)) {
            to = '';
        } else if (isX(tm)) {
            to = `<${+tM + 1}.0.0-0`;
        } else if (isX(tp)) {
            to = `<${tM}.${+tm + 1}.0-0`;
        } else if (tpr) {
            to = `<=${tM}.${tm}.${tp}-${tpr}`;
        } else if (incPr) {
            to = `<${tM}.${tm}.${+tp + 1}-0`;
        } else {
            to = `<=${to}`;
        }
        return `${from} ${to}`.trim();
    };
const testSet = (set, version, options)=>{
    for(let i = 0; i < set.length; i++){
        if (!set[i].test(version)) {
            return false;
        }
    }
    if (version.prerelease.length && !options.includePrerelease) {
        // Find the set of versions that are allowed to have prereleases
        // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
        // That should allow `1.2.3-pr.2` to pass.
        // However, `1.2.4-alpha.notready` should NOT be allowed,
        // even though it's within the range set by the comparators.
        for(let i = 0; i < set.length; i++){
            debug(set[i].semver);
            if (set[i].semver === Comparator.ANY) {
                continue;
            }
            if (set[i].semver.prerelease.length > 0) {
                const allowed = set[i].semver;
                if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
                    return true;
                }
            }
        }
        // Version has a -pre, but it's not one of the ones we like.
        return false;
    }
    return true;
};
}),
"[project]/node_modules/conf/node_modules/semver/classes/comparator.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const ANY = Symbol('SemVer ANY');
// hoisted class for cyclic dependency
class Comparator {
    static get ANY() {
        return ANY;
    }
    constructor(comp, options){
        options = parseOptions(options);
        if (comp instanceof Comparator) {
            if (comp.loose === !!options.loose) {
                return comp;
            } else {
                comp = comp.value;
            }
        }
        comp = comp.trim().split(/\s+/).join(' ');
        debug('comparator', comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
            this.value = '';
        } else {
            this.value = this.operator + this.semver.version;
        }
        debug('comp', this);
    }
    parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
            throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== undefined ? m[1] : '';
        if (this.operator === '=') {
            this.operator = '';
        }
        // if it literally is just '>' or '' then allow anything.
        if (!m[2]) {
            this.semver = ANY;
        } else {
            this.semver = new SemVer(m[2], this.options.loose);
        }
    }
    toString() {
        return this.value;
    }
    test(version) {
        debug('Comparator.test', version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
            return true;
        }
        if (typeof version === 'string') {
            try {
                version = new SemVer(version, this.options);
            } catch (er) {
                return false;
            }
        }
        return cmp(version, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
        if (!(comp instanceof Comparator)) {
            throw new TypeError('a Comparator is required');
        }
        if (this.operator === '') {
            if (this.value === '') {
                return true;
            }
            return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === '') {
            if (comp.value === '') {
                return true;
            }
            return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        // Special cases where nothing can possibly be lower
        if (options.includePrerelease && (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {
            return false;
        }
        if (!options.includePrerelease && (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {
            return false;
        }
        // Same direction increasing (> or >=)
        if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {
            return true;
        }
        // Same direction decreasing (< or <=)
        if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {
            return true;
        }
        // same SemVer and both sides are inclusive (<= or >=)
        if (this.semver.version === comp.semver.version && this.operator.includes('=') && comp.operator.includes('=')) {
            return true;
        }
        // opposite directions less than
        if (cmp(this.semver, '<', comp.semver, options) && this.operator.startsWith('>') && comp.operator.startsWith('<')) {
            return true;
        }
        // opposite directions greater than
        if (cmp(this.semver, '>', comp.semver, options) && this.operator.startsWith('<') && comp.operator.startsWith('>')) {
            return true;
        }
        return false;
    }
}
module.exports = Comparator;
const parseOptions = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/internal/parse-options.js [app-client] (ecmascript)");
const { safeRe: re, t } = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/internal/re.js [app-client] (ecmascript)");
const cmp = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/cmp.js [app-client] (ecmascript)");
const debug = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/internal/debug.js [app-client] (ecmascript)");
const SemVer = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/classes/semver.js [app-client] (ecmascript)");
const Range = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/classes/range.js [app-client] (ecmascript)");
}),
"[project]/node_modules/conf/node_modules/semver/functions/satisfies.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const Range = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/classes/range.js [app-client] (ecmascript)");
const satisfies = (version, range, options)=>{
    try {
        range = new Range(range, options);
    } catch (er) {
        return false;
    }
    return range.test(version);
};
module.exports = satisfies;
}),
"[project]/node_modules/conf/node_modules/semver/ranges/to-comparators.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const Range = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/classes/range.js [app-client] (ecmascript)");
// Mostly just for testing and legacy API reasons
const toComparators = (range, options)=>new Range(range, options).set.map((comp)=>comp.map((c)=>c.value).join(' ').trim().split(' '));
module.exports = toComparators;
}),
"[project]/node_modules/conf/node_modules/semver/ranges/max-satisfying.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/classes/semver.js [app-client] (ecmascript)");
const Range = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/classes/range.js [app-client] (ecmascript)");
const maxSatisfying = (versions, range, options)=>{
    let max = null;
    let maxSV = null;
    let rangeObj = null;
    try {
        rangeObj = new Range(range, options);
    } catch (er) {
        return null;
    }
    versions.forEach((v)=>{
        if (rangeObj.test(v)) {
            // satisfies(v, range, options)
            if (!max || maxSV.compare(v) === -1) {
                // compare(max, v, true)
                max = v;
                maxSV = new SemVer(max, options);
            }
        }
    });
    return max;
};
module.exports = maxSatisfying;
}),
"[project]/node_modules/conf/node_modules/semver/ranges/min-satisfying.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/classes/semver.js [app-client] (ecmascript)");
const Range = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/classes/range.js [app-client] (ecmascript)");
const minSatisfying = (versions, range, options)=>{
    let min = null;
    let minSV = null;
    let rangeObj = null;
    try {
        rangeObj = new Range(range, options);
    } catch (er) {
        return null;
    }
    versions.forEach((v)=>{
        if (rangeObj.test(v)) {
            // satisfies(v, range, options)
            if (!min || minSV.compare(v) === 1) {
                // compare(min, v, true)
                min = v;
                minSV = new SemVer(min, options);
            }
        }
    });
    return min;
};
module.exports = minSatisfying;
}),
"[project]/node_modules/conf/node_modules/semver/ranges/min-version.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/classes/semver.js [app-client] (ecmascript)");
const Range = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/classes/range.js [app-client] (ecmascript)");
const gt = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/gt.js [app-client] (ecmascript)");
const minVersion = (range, loose)=>{
    range = new Range(range, loose);
    let minver = new SemVer('0.0.0');
    if (range.test(minver)) {
        return minver;
    }
    minver = new SemVer('0.0.0-0');
    if (range.test(minver)) {
        return minver;
    }
    minver = null;
    for(let i = 0; i < range.set.length; ++i){
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator)=>{
            // Clone to avoid manipulating the comparator's semver object.
            const compver = new SemVer(comparator.semver.version);
            switch(comparator.operator){
                case '>':
                    if (compver.prerelease.length === 0) {
                        compver.patch++;
                    } else {
                        compver.prerelease.push(0);
                    }
                    compver.raw = compver.format();
                /* fallthrough */ case '':
                case '>=':
                    if (!setMin || gt(compver, setMin)) {
                        setMin = compver;
                    }
                    break;
                case '<':
                case '<=':
                    break;
                /* istanbul ignore next */ default:
                    throw new Error(`Unexpected operation: ${comparator.operator}`);
            }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
            minver = setMin;
        }
    }
    if (minver && range.test(minver)) {
        return minver;
    }
    return null;
};
module.exports = minVersion;
}),
"[project]/node_modules/conf/node_modules/semver/ranges/valid.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const Range = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/classes/range.js [app-client] (ecmascript)");
const validRange = (range, options)=>{
    try {
        // Return '*' instead of '' so that truthiness works.
        // This will throw if it's invalid anyway
        return new Range(range, options).range || '*';
    } catch (er) {
        return null;
    }
};
module.exports = validRange;
}),
"[project]/node_modules/conf/node_modules/semver/ranges/outside.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const SemVer = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/classes/semver.js [app-client] (ecmascript)");
const Comparator = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/classes/comparator.js [app-client] (ecmascript)");
const { ANY } = Comparator;
const Range = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/classes/range.js [app-client] (ecmascript)");
const satisfies = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/satisfies.js [app-client] (ecmascript)");
const gt = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/gt.js [app-client] (ecmascript)");
const lt = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/lt.js [app-client] (ecmascript)");
const lte = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/lte.js [app-client] (ecmascript)");
const gte = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/gte.js [app-client] (ecmascript)");
const outside = (version, range, hilo, options)=>{
    version = new SemVer(version, options);
    range = new Range(range, options);
    let gtfn, ltefn, ltfn, comp, ecomp;
    switch(hilo){
        case '>':
            gtfn = gt;
            ltefn = lte;
            ltfn = lt;
            comp = '>';
            ecomp = '>=';
            break;
        case '<':
            gtfn = lt;
            ltefn = gte;
            ltfn = gt;
            comp = '<';
            ecomp = '<=';
            break;
        default:
            throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    // If it satisfies the range it is not outside
    if (satisfies(version, range, options)) {
        return false;
    }
    // From now on, variable terms are as if we're in "gtr" mode.
    // but note that everything is flipped for the "ltr" function.
    for(let i = 0; i < range.set.length; ++i){
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator)=>{
            if (comparator.semver === ANY) {
                comparator = new Comparator('>=0.0.0');
            }
            high = high || comparator;
            low = low || comparator;
            if (gtfn(comparator.semver, high.semver, options)) {
                high = comparator;
            } else if (ltfn(comparator.semver, low.semver, options)) {
                low = comparator;
            }
        });
        // If the edge version comparator has a operator then our version
        // isn't outside it
        if (high.operator === comp || high.operator === ecomp) {
            return false;
        }
        // If the lowest version comparator has an operator and our version
        // is less than it then it isn't higher than the range
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
            return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
            return false;
        }
    }
    return true;
};
module.exports = outside;
}),
"[project]/node_modules/conf/node_modules/semver/ranges/gtr.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Determine if version is greater than all the versions possible in the range.
const outside = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/ranges/outside.js [app-client] (ecmascript)");
const gtr = (version, range, options)=>outside(version, range, '>', options);
module.exports = gtr;
}),
"[project]/node_modules/conf/node_modules/semver/ranges/ltr.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const outside = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/ranges/outside.js [app-client] (ecmascript)");
// Determine if version is less than all the versions possible in the range
const ltr = (version, range, options)=>outside(version, range, '<', options);
module.exports = ltr;
}),
"[project]/node_modules/conf/node_modules/semver/ranges/intersects.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const Range = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/classes/range.js [app-client] (ecmascript)");
const intersects = (r1, r2, options)=>{
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2, options);
};
module.exports = intersects;
}),
"[project]/node_modules/conf/node_modules/semver/ranges/simplify.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// given a set of versions and a range, create a "simplified" range
// that includes the same versions that the original range does
// If the original range is shorter than the simplified one, return that.
const satisfies = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/satisfies.js [app-client] (ecmascript)");
const compare = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/compare.js [app-client] (ecmascript)");
module.exports = (versions, range, options)=>{
    const set = [];
    let first = null;
    let prev = null;
    const v = versions.sort((a, b)=>compare(a, b, options));
    for (const version of v){
        const included = satisfies(version, range, options);
        if (included) {
            prev = version;
            if (!first) {
                first = version;
            }
        } else {
            if (prev) {
                set.push([
                    first,
                    prev
                ]);
            }
            prev = null;
            first = null;
        }
    }
    if (first) {
        set.push([
            first,
            null
        ]);
    }
    const ranges = [];
    for (const [min, max] of set){
        if (min === max) {
            ranges.push(min);
        } else if (!max && min === v[0]) {
            ranges.push('*');
        } else if (!max) {
            ranges.push(`>=${min}`);
        } else if (min === v[0]) {
            ranges.push(`<=${max}`);
        } else {
            ranges.push(`${min} - ${max}`);
        }
    }
    const simplified = ranges.join(' || ');
    const original = typeof range.raw === 'string' ? range.raw : String(range);
    return simplified.length < original.length ? simplified : range;
};
}),
"[project]/node_modules/conf/node_modules/semver/ranges/subset.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const Range = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/classes/range.js [app-client] (ecmascript)");
const Comparator = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/classes/comparator.js [app-client] (ecmascript)");
const { ANY } = Comparator;
const satisfies = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/satisfies.js [app-client] (ecmascript)");
const compare = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/compare.js [app-client] (ecmascript)");
// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
// - Every simple range `r1, r2, ...` is a null set, OR
// - Every simple range `r1, r2, ...` which is not a null set is a subset of
//   some `R1, R2, ...`
//
// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
// - If c is only the ANY comparator
//   - If C is only the ANY comparator, return true
//   - Else if in prerelease mode, return false
//   - else replace c with `[>=0.0.0]`
// - If C is only the ANY comparator
//   - if in prerelease mode, return true
//   - else replace C with `[>=0.0.0]`
// - Let EQ be the set of = comparators in c
// - If EQ is more than one, return true (null set)
// - Let GT be the highest > or >= comparator in c
// - Let LT be the lowest < or <= comparator in c
// - If GT and LT, and GT.semver > LT.semver, return true (null set)
// - If any C is a = range, and GT or LT are set, return false
// - If EQ
//   - If GT, and EQ does not satisfy GT, return true (null set)
//   - If LT, and EQ does not satisfy LT, return true (null set)
//   - If EQ satisfies every C, return true
//   - Else return false
// - If GT
//   - If GT.semver is lower than any > or >= comp in C, return false
//   - If GT is >=, and GT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the GT.semver tuple, return false
// - If LT
//   - If LT.semver is greater than any < or <= comp in C, return false
//   - If LT is <=, and LT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the LT.semver tuple, return false
// - Else return true
const subset = (sub, dom, options = {})=>{
    if (sub === dom) {
        return true;
    }
    sub = new Range(sub, options);
    dom = new Range(dom, options);
    let sawNonNull = false;
    OUTER: for (const simpleSub of sub.set){
        for (const simpleDom of dom.set){
            const isSub = simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub) {
                continue OUTER;
            }
        }
        // the null set is a subset of everything, but null simple ranges in
        // a complex range should be ignored.  so if we saw a non-null range,
        // then we know this isn't a subset, but if EVERY simple range was null,
        // then it is a subset.
        if (sawNonNull) {
            return false;
        }
    }
    return true;
};
const minimumVersionWithPreRelease = [
    new Comparator('>=0.0.0-0')
];
const minimumVersion = [
    new Comparator('>=0.0.0')
];
const simpleSubset = (sub, dom, options)=>{
    if (sub === dom) {
        return true;
    }
    if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
            return true;
        } else if (options.includePrerelease) {
            sub = minimumVersionWithPreRelease;
        } else {
            sub = minimumVersion;
        }
    }
    if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
            return true;
        } else {
            dom = minimumVersion;
        }
    }
    const eqSet = new Set();
    let gt, lt;
    for (const c of sub){
        if (c.operator === '>' || c.operator === '>=') {
            gt = higherGT(gt, c, options);
        } else if (c.operator === '<' || c.operator === '<=') {
            lt = lowerLT(lt, c, options);
        } else {
            eqSet.add(c.semver);
        }
    }
    if (eqSet.size > 1) {
        return null;
    }
    let gtltComp;
    if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
            return null;
        } else if (gtltComp === 0 && (gt.operator !== '>=' || lt.operator !== '<=')) {
            return null;
        }
    }
    // will iterate one or zero times
    for (const eq of eqSet){
        if (gt && !satisfies(eq, String(gt), options)) {
            return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
            return null;
        }
        for (const c of dom){
            if (!satisfies(eq, String(c), options)) {
                return false;
            }
        }
        return true;
    }
    let higher, lower;
    let hasDomLT, hasDomGT;
    // if the subset has a prerelease, we need a comparator in the superset
    // with the same tuple and a prerelease, or it's not a subset
    let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
    let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
    // exception: <1.2.3-0 is the same as <1.2.3
    if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === '<' && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
    }
    for (const c of dom){
        hasDomGT = hasDomGT || c.operator === '>' || c.operator === '>=';
        hasDomLT = hasDomLT || c.operator === '<' || c.operator === '<=';
        if (gt) {
            if (needDomGTPre) {
                if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
                    needDomGTPre = false;
                }
            }
            if (c.operator === '>' || c.operator === '>=') {
                higher = higherGT(gt, c, options);
                if (higher === c && higher !== gt) {
                    return false;
                }
            } else if (gt.operator === '>=' && !satisfies(gt.semver, String(c), options)) {
                return false;
            }
        }
        if (lt) {
            if (needDomLTPre) {
                if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
                    needDomLTPre = false;
                }
            }
            if (c.operator === '<' || c.operator === '<=') {
                lower = lowerLT(lt, c, options);
                if (lower === c && lower !== lt) {
                    return false;
                }
            } else if (lt.operator === '<=' && !satisfies(lt.semver, String(c), options)) {
                return false;
            }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
            return false;
        }
    }
    // if there was a < or >, and nothing in the dom, then must be false
    // UNLESS it was limited by another range in the other direction.
    // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
    if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
    }
    if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
    }
    // we needed a prerelease range in a specific tuple, but didn't get one
    // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
    // because it includes prereleases in the 1.2.3 tuple
    if (needDomGTPre || needDomLTPre) {
        return false;
    }
    return true;
};
// >=1.2.3 is lower than >1.2.3
const higherGT = (a, b, options)=>{
    if (!a) {
        return b;
    }
    const comp = compare(a.semver, b.semver, options);
    return comp > 0 ? a : comp < 0 ? b : b.operator === '>' && a.operator === '>=' ? b : a;
};
// <=1.2.3 is higher than <1.2.3
const lowerLT = (a, b, options)=>{
    if (!a) {
        return b;
    }
    const comp = compare(a.semver, b.semver, options);
    return comp < 0 ? a : comp > 0 ? b : b.operator === '<' && a.operator === '<=' ? b : a;
};
module.exports = subset;
}),
"[project]/node_modules/conf/node_modules/semver/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// just pre-load all the stuff that index.js lazily exports
const internalRe = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/internal/re.js [app-client] (ecmascript)");
const constants = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/internal/constants.js [app-client] (ecmascript)");
const SemVer = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/classes/semver.js [app-client] (ecmascript)");
const identifiers = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/internal/identifiers.js [app-client] (ecmascript)");
const parse = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/parse.js [app-client] (ecmascript)");
const valid = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/valid.js [app-client] (ecmascript)");
const clean = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/clean.js [app-client] (ecmascript)");
const inc = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/inc.js [app-client] (ecmascript)");
const diff = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/diff.js [app-client] (ecmascript)");
const major = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/major.js [app-client] (ecmascript)");
const minor = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/minor.js [app-client] (ecmascript)");
const patch = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/patch.js [app-client] (ecmascript)");
const prerelease = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/prerelease.js [app-client] (ecmascript)");
const compare = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/compare.js [app-client] (ecmascript)");
const rcompare = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/rcompare.js [app-client] (ecmascript)");
const compareLoose = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/compare-loose.js [app-client] (ecmascript)");
const compareBuild = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/compare-build.js [app-client] (ecmascript)");
const sort = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/sort.js [app-client] (ecmascript)");
const rsort = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/rsort.js [app-client] (ecmascript)");
const gt = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/gt.js [app-client] (ecmascript)");
const lt = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/lt.js [app-client] (ecmascript)");
const eq = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/eq.js [app-client] (ecmascript)");
const neq = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/neq.js [app-client] (ecmascript)");
const gte = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/gte.js [app-client] (ecmascript)");
const lte = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/lte.js [app-client] (ecmascript)");
const cmp = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/cmp.js [app-client] (ecmascript)");
const coerce = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/coerce.js [app-client] (ecmascript)");
const Comparator = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/classes/comparator.js [app-client] (ecmascript)");
const Range = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/classes/range.js [app-client] (ecmascript)");
const satisfies = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/functions/satisfies.js [app-client] (ecmascript)");
const toComparators = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/ranges/to-comparators.js [app-client] (ecmascript)");
const maxSatisfying = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/ranges/max-satisfying.js [app-client] (ecmascript)");
const minSatisfying = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/ranges/min-satisfying.js [app-client] (ecmascript)");
const minVersion = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/ranges/min-version.js [app-client] (ecmascript)");
const validRange = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/ranges/valid.js [app-client] (ecmascript)");
const outside = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/ranges/outside.js [app-client] (ecmascript)");
const gtr = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/ranges/gtr.js [app-client] (ecmascript)");
const ltr = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/ranges/ltr.js [app-client] (ecmascript)");
const intersects = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/ranges/intersects.js [app-client] (ecmascript)");
const simplifyRange = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/ranges/simplify.js [app-client] (ecmascript)");
const subset = __turbopack_context__.r("[project]/node_modules/conf/node_modules/semver/ranges/subset.js [app-client] (ecmascript)");
module.exports = {
    parse,
    valid,
    clean,
    inc,
    diff,
    major,
    minor,
    patch,
    prerelease,
    compare,
    rcompare,
    compareLoose,
    compareBuild,
    sort,
    rsort,
    gt,
    lt,
    eq,
    neq,
    gte,
    lte,
    cmp,
    coerce,
    Comparator,
    Range,
    satisfies,
    toComparators,
    maxSatisfying,
    minSatisfying,
    minVersion,
    validRange,
    outside,
    gtr,
    ltr,
    intersects,
    simplifyRange,
    subset,
    SemVer,
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: constants.RELEASE_TYPES,
    compareIdentifiers: identifiers.compareIdentifiers,
    rcompareIdentifiers: identifiers.rcompareIdentifiers
};
}),
"[project]/node_modules/conf/dist/source/index.js [app-client] (ecmascript)", (() => {{

throw new Error("An error occurred while generating the chunk item [project]/node_modules/conf/dist/source/index.js [app-client] (ecmascript)\n\nCaused by:\n- the chunking context (unknown) does not support external modules (request: node:fs)\n\nDebug info:\n- An error occurred while generating the chunk item [project]/node_modules/conf/dist/source/index.js [app-client] (ecmascript)\n- Execution of <ModuleChunkItem as EcmascriptChunkItem>::content_with_async_module_info failed\n- Execution of *EcmascriptChunkItemContent::new failed\n- Execution of EcmascriptModuleContent::new failed\n- the chunking context (unknown) does not support external modules (request: node:fs)");

}}),
"[project]/node_modules/ajv-formats/node_modules/json-schema-traverse/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var traverse = module.exports = function(schema, opts, cb) {
    // Legacy support for v0.3.1 and earlier.
    if (typeof opts == 'function') {
        cb = opts;
        opts = {};
    }
    cb = opts.cb || cb;
    var pre = typeof cb == 'function' ? cb : cb.pre || function() {};
    var post = cb.post || function() {};
    _traverse(opts, pre, post, schema, '', schema);
};
traverse.keywords = {
    additionalItems: true,
    items: true,
    contains: true,
    additionalProperties: true,
    propertyNames: true,
    not: true,
    if: true,
    then: true,
    else: true
};
traverse.arrayKeywords = {
    items: true,
    allOf: true,
    anyOf: true,
    oneOf: true
};
traverse.propsKeywords = {
    $defs: true,
    definitions: true,
    properties: true,
    patternProperties: true,
    dependencies: true
};
traverse.skipKeywords = {
    default: true,
    enum: true,
    const: true,
    required: true,
    maximum: true,
    minimum: true,
    exclusiveMaximum: true,
    exclusiveMinimum: true,
    multipleOf: true,
    maxLength: true,
    minLength: true,
    pattern: true,
    format: true,
    maxItems: true,
    minItems: true,
    uniqueItems: true,
    maxProperties: true,
    minProperties: true
};
function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for(var key in schema){
            var sch = schema[key];
            if (Array.isArray(sch)) {
                if (key in traverse.arrayKeywords) {
                    for(var i = 0; i < sch.length; i++)_traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
                }
            } else if (key in traverse.propsKeywords) {
                if (sch && typeof sch == 'object') {
                    for(var prop in sch)_traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
                }
            } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
                _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
            }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    }
}
function escapeJsonPtr(str) {
    return str.replace(/~/g, '~0').replace(/\//g, '~1');
}
}),
"[project]/node_modules/ajv-formats/dist/formats.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.formatNames = exports.fastFormats = exports.fullFormats = void 0;
function fmtDef(validate, compare) {
    return {
        validate,
        compare
    };
}
exports.fullFormats = {
    // date: http://tools.ietf.org/html/rfc3339#section-5.6
    date: fmtDef(date, compareDate),
    // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
    time: fmtDef(time, compareTime),
    "date-time": fmtDef(date_time, compareDateTime),
    // duration: https://tools.ietf.org/html/rfc3339#appendix-A
    duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
    uri,
    "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
    // uri-template: https://tools.ietf.org/html/rfc6570
    "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
    // For the source: https://gist.github.com/dperini/729294
    // For test cases: https://mathiasbynens.be/demo/url-regex
    url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
    // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
    regex,
    // uuid: http://tools.ietf.org/html/rfc4122
    uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
    // JSON-pointer: https://tools.ietf.org/html/rfc6901
    // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
    "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
    "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
    // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
    "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
    // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
    // byte: https://github.com/miguelmota/is-base64
    byte,
    // signed 32 bit integer
    int32: {
        type: "number",
        validate: validateInt32
    },
    // signed 64 bit integer
    int64: {
        type: "number",
        validate: validateInt64
    },
    // C-type float
    float: {
        type: "number",
        validate: validateNumber
    },
    // C-type double
    double: {
        type: "number",
        validate: validateNumber
    },
    // hint to the UI to hide input strings
    password: true,
    // unchecked string payload
    binary: true
};
exports.fastFormats = {
    ...exports.fullFormats,
    date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
    time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareTime),
    "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
    // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    // email (sources from jsen validator):
    // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
    // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
};
exports.formatNames = Object.keys(exports.fullFormats);
function isLeapYear(year) {
    // https://tools.ietf.org/html/rfc3339#appendix-C
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
const DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
const DAYS = [
    0,
    31,
    28,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
];
function date(str) {
    // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
    const matches = DATE.exec(str);
    if (!matches) return false;
    const year = +matches[1];
    const month = +matches[2];
    const day = +matches[3];
    return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
}
function compareDate(d1, d2) {
    if (!(d1 && d2)) return undefined;
    if (d1 > d2) return 1;
    if (d1 < d2) return -1;
    return 0;
}
const TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
function time(str, withTimeZone) {
    const matches = TIME.exec(str);
    if (!matches) return false;
    const hour = +matches[1];
    const minute = +matches[2];
    const second = +matches[3];
    const timeZone = matches[5];
    return (hour <= 23 && minute <= 59 && second <= 59 || hour === 23 && minute === 59 && second === 60) && (!withTimeZone || timeZone !== "");
}
function compareTime(t1, t2) {
    if (!(t1 && t2)) return undefined;
    const a1 = TIME.exec(t1);
    const a2 = TIME.exec(t2);
    if (!(a1 && a2)) return undefined;
    t1 = a1[1] + a1[2] + a1[3] + (a1[4] || "");
    t2 = a2[1] + a2[2] + a2[3] + (a2[4] || "");
    if (t1 > t2) return 1;
    if (t1 < t2) return -1;
    return 0;
}
const DATE_TIME_SEPARATOR = /t|\s/i;
function date_time(str) {
    // http://tools.ietf.org/html/rfc3339#section-5.6
    const dateTime = str.split(DATE_TIME_SEPARATOR);
    return dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1], true);
}
function compareDateTime(dt1, dt2) {
    if (!(dt1 && dt2)) return undefined;
    const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
    const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
    const res = compareDate(d1, d2);
    if (res === undefined) return undefined;
    return res || compareTime(t1, t2);
}
const NOT_URI_FRAGMENT = /\/|:/;
const URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
function uri(str) {
    // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required "."
    return NOT_URI_FRAGMENT.test(str) && URI.test(str);
}
const BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
function byte(str) {
    BYTE.lastIndex = 0;
    return BYTE.test(str);
}
const MIN_INT32 = -(2 ** 31);
const MAX_INT32 = 2 ** 31 - 1;
function validateInt32(value) {
    return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
}
function validateInt64(value) {
    // JSON and javascript max Int is 2**53, so any int that passes isInteger is valid for Int64
    return Number.isInteger(value);
}
function validateNumber() {
    return true;
}
const Z_ANCHOR = /[^\\]\\Z/;
function regex(str) {
    if (Z_ANCHOR.test(str)) return false;
    try {
        new RegExp(str);
        return true;
    } catch (e) {
        return false;
    }
} //# sourceMappingURL=formats.js.map
}),
"[project]/node_modules/ajv-formats/dist/limit.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.formatLimitDefinition = void 0;
const ajv_1 = __turbopack_context__.r("[project]/node_modules/ajv-formats/node_modules/ajv/dist/ajv.js [app-client] (ecmascript)");
const codegen_1 = __turbopack_context__.r("[project]/node_modules/ajv-formats/node_modules/ajv/dist/compile/codegen/index.js [app-client] (ecmascript)");
const ops = codegen_1.operators;
const KWDs = {
    formatMaximum: {
        okStr: "<=",
        ok: ops.LTE,
        fail: ops.GT
    },
    formatMinimum: {
        okStr: ">=",
        ok: ops.GTE,
        fail: ops.LT
    },
    formatExclusiveMaximum: {
        okStr: "<",
        ok: ops.LT,
        fail: ops.GTE
    },
    formatExclusiveMinimum: {
        okStr: ">",
        ok: ops.GT,
        fail: ops.LTE
    }
};
const error = {
    message: ({ keyword, schemaCode })=>codegen_1.str`should be ${KWDs[keyword].okStr} ${schemaCode}`,
    params: ({ keyword, schemaCode })=>codegen_1._`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
};
exports.formatLimitDefinition = {
    keyword: Object.keys(KWDs),
    type: "string",
    schemaType: "string",
    $data: true,
    error,
    code (cxt) {
        const { gen, data, schemaCode, keyword, it } = cxt;
        const { opts, self } = it;
        if (!opts.validateFormats) return;
        const fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, "format");
        if (fCxt.$data) validate$DataFormat();
        else validateFormat();
        function validate$DataFormat() {
            const fmts = gen.scopeValue("formats", {
                ref: self.formats,
                code: opts.code.formats
            });
            const fmt = gen.const("fmt", codegen_1._`${fmts}[${fCxt.schemaCode}]`);
            cxt.fail$data(codegen_1.or(codegen_1._`typeof ${fmt} != "object"`, codegen_1._`${fmt} instanceof RegExp`, codegen_1._`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
        }
        function validateFormat() {
            const format = fCxt.schema;
            const fmtDef = self.formats[format];
            if (!fmtDef || fmtDef === true) return;
            if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
                throw new Error(`"${keyword}": format "${format}" does not define "compare" function`);
            }
            const fmt = gen.scopeValue("formats", {
                key: format,
                ref: fmtDef,
                code: opts.code.formats ? codegen_1._`${opts.code.formats}${codegen_1.getProperty(format)}` : undefined
            });
            cxt.fail$data(compareCode(fmt));
        }
        function compareCode(fmt) {
            return codegen_1._`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
        }
    },
    dependencies: [
        "format"
    ]
};
const formatLimitPlugin = (ajv)=>{
    ajv.addKeyword(exports.formatLimitDefinition);
    return ajv;
};
exports.default = formatLimitPlugin; //# sourceMappingURL=limit.js.map
}),
"[project]/node_modules/ajv-formats/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
const formats_1 = __turbopack_context__.r("[project]/node_modules/ajv-formats/dist/formats.js [app-client] (ecmascript)");
const limit_1 = __turbopack_context__.r("[project]/node_modules/ajv-formats/dist/limit.js [app-client] (ecmascript)");
const codegen_1 = __turbopack_context__.r("[project]/node_modules/ajv-formats/node_modules/ajv/dist/compile/codegen/index.js [app-client] (ecmascript)");
const fullName = new codegen_1.Name("fullFormats");
const fastName = new codegen_1.Name("fastFormats");
const formatsPlugin = (ajv, opts = {
    keywords: true
})=>{
    if (Array.isArray(opts)) {
        addFormats(ajv, opts, formats_1.fullFormats, fullName);
        return ajv;
    }
    const [formats, exportName] = opts.mode === "fast" ? [
        formats_1.fastFormats,
        fastName
    ] : [
        formats_1.fullFormats,
        fullName
    ];
    const list = opts.formats || formats_1.formatNames;
    addFormats(ajv, list, formats, exportName);
    if (opts.keywords) limit_1.default(ajv);
    return ajv;
};
formatsPlugin.get = (name, mode = "full")=>{
    const formats = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
    const f = formats[name];
    if (!f) throw new Error(`Unknown format "${name}"`);
    return f;
};
function addFormats(ajv, list, fs, exportName) {
    var _a;
    var _b;
    (_a = (_b = ajv.opts.code).formats) !== null && _a !== void 0 ? _a : _b.formats = codegen_1._`require("ajv-formats/dist/formats").${exportName}`;
    for (const f of list)ajv.addFormat(f, fs[f]);
}
module.exports = exports = formatsPlugin;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = formatsPlugin; //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/fast-uri/lib/utils.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @type {(value: string) => boolean} */ const isUUID = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu);
/** @type {(value: string) => boolean} */ const isIPv4 = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
/**
 * @param {Array<string>} input
 * @returns {string}
 */ function stringArrayToHexStripped(input) {
    let acc = '';
    let code = 0;
    let i = 0;
    for(i = 0; i < input.length; i++){
        code = input[i].charCodeAt(0);
        if (code === 48) {
            continue;
        }
        if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {
            return '';
        }
        acc += input[i];
        break;
    }
    for(i += 1; i < input.length; i++){
        code = input[i].charCodeAt(0);
        if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {
            return '';
        }
        acc += input[i];
    }
    return acc;
}
/**
 * @typedef {Object} GetIPV6Result
 * @property {boolean} error - Indicates if there was an error parsing the IPv6 address.
 * @property {string} address - The parsed IPv6 address.
 * @property {string} [zone] - The zone identifier, if present.
 */ /**
 * @param {string} value
 * @returns {boolean}
 */ const nonSimpleDomain = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
/**
 * @param {Array<string>} buffer
 * @returns {boolean}
 */ function consumeIsZone(buffer) {
    buffer.length = 0;
    return true;
}
/**
 * @param {Array<string>} buffer
 * @param {Array<string>} address
 * @param {GetIPV6Result} output
 * @returns {boolean}
 */ function consumeHextets(buffer, address, output) {
    if (buffer.length) {
        const hex = stringArrayToHexStripped(buffer);
        if (hex !== '') {
            address.push(hex);
        } else {
            output.error = true;
            return false;
        }
        buffer.length = 0;
    }
    return true;
}
/**
 * @param {string} input
 * @returns {GetIPV6Result}
 */ function getIPV6(input) {
    let tokenCount = 0;
    const output = {
        error: false,
        address: '',
        zone: ''
    };
    /** @type {Array<string>} */ const address = [];
    /** @type {Array<string>} */ const buffer = [];
    let endipv6Encountered = false;
    let endIpv6 = false;
    let consume = consumeHextets;
    for(let i = 0; i < input.length; i++){
        const cursor = input[i];
        if (cursor === '[' || cursor === ']') {
            continue;
        }
        if (cursor === ':') {
            if (endipv6Encountered === true) {
                endIpv6 = true;
            }
            if (!consume(buffer, address, output)) {
                break;
            }
            if (++tokenCount > 7) {
                // not valid
                output.error = true;
                break;
            }
            if (i > 0 && input[i - 1] === ':') {
                endipv6Encountered = true;
            }
            address.push(':');
            continue;
        } else if (cursor === '%') {
            if (!consume(buffer, address, output)) {
                break;
            }
            // switch to zone detection
            consume = consumeIsZone;
        } else {
            buffer.push(cursor);
            continue;
        }
    }
    if (buffer.length) {
        if (consume === consumeIsZone) {
            output.zone = buffer.join('');
        } else if (endIpv6) {
            address.push(buffer.join(''));
        } else {
            address.push(stringArrayToHexStripped(buffer));
        }
    }
    output.address = address.join('');
    return output;
}
/**
 * @typedef {Object} NormalizeIPv6Result
 * @property {string} host - The normalized host.
 * @property {string} [escapedHost] - The escaped host.
 * @property {boolean} isIPV6 - Indicates if the host is an IPv6 address.
 */ /**
 * @param {string} host
 * @returns {NormalizeIPv6Result}
 */ function normalizeIPv6(host) {
    if (findToken(host, ':') < 2) {
        return {
            host,
            isIPV6: false
        };
    }
    const ipv6 = getIPV6(host);
    if (!ipv6.error) {
        let newHost = ipv6.address;
        let escapedHost = ipv6.address;
        if (ipv6.zone) {
            newHost += '%' + ipv6.zone;
            escapedHost += '%25' + ipv6.zone;
        }
        return {
            host: newHost,
            isIPV6: true,
            escapedHost
        };
    } else {
        return {
            host,
            isIPV6: false
        };
    }
}
/**
 * @param {string} str
 * @param {string} token
 * @returns {number}
 */ function findToken(str, token) {
    let ind = 0;
    for(let i = 0; i < str.length; i++){
        if (str[i] === token) ind++;
    }
    return ind;
}
/**
 * @param {string} path
 * @returns {string}
 *
 * @see https://datatracker.ietf.org/doc/html/rfc3986#section-5.2.4
 */ function removeDotSegments(path) {
    let input = path;
    const output = [];
    let nextSlash = -1;
    let len = 0;
    // eslint-disable-next-line no-cond-assign
    while(len = input.length){
        if (len === 1) {
            if (input === '.') {
                break;
            } else if (input === '/') {
                output.push('/');
                break;
            } else {
                output.push(input);
                break;
            }
        } else if (len === 2) {
            if (input[0] === '.') {
                if (input[1] === '.') {
                    break;
                } else if (input[1] === '/') {
                    input = input.slice(2);
                    continue;
                }
            } else if (input[0] === '/') {
                if (input[1] === '.' || input[1] === '/') {
                    output.push('/');
                    break;
                }
            }
        } else if (len === 3) {
            if (input === '/..') {
                if (output.length !== 0) {
                    output.pop();
                }
                output.push('/');
                break;
            }
        }
        if (input[0] === '.') {
            if (input[1] === '.') {
                if (input[2] === '/') {
                    input = input.slice(3);
                    continue;
                }
            } else if (input[1] === '/') {
                input = input.slice(2);
                continue;
            }
        } else if (input[0] === '/') {
            if (input[1] === '.') {
                if (input[2] === '/') {
                    input = input.slice(2);
                    continue;
                } else if (input[2] === '.') {
                    if (input[3] === '/') {
                        input = input.slice(3);
                        if (output.length !== 0) {
                            output.pop();
                        }
                        continue;
                    }
                }
            }
        }
        // Rule 2E: Move normal path segment to output
        if ((nextSlash = input.indexOf('/', 1)) === -1) {
            output.push(input);
            break;
        } else {
            output.push(input.slice(0, nextSlash));
            input = input.slice(nextSlash);
        }
    }
    return output.join('');
}
/**
 * @param {import('../types/index').URIComponent} component
 * @param {boolean} esc
 * @returns {import('../types/index').URIComponent}
 */ function normalizeComponentEncoding(component, esc) {
    const func = esc !== true ? escape : unescape;
    if (component.scheme !== undefined) {
        component.scheme = func(component.scheme);
    }
    if (component.userinfo !== undefined) {
        component.userinfo = func(component.userinfo);
    }
    if (component.host !== undefined) {
        component.host = func(component.host);
    }
    if (component.path !== undefined) {
        component.path = func(component.path);
    }
    if (component.query !== undefined) {
        component.query = func(component.query);
    }
    if (component.fragment !== undefined) {
        component.fragment = func(component.fragment);
    }
    return component;
}
/**
 * @param {import('../types/index').URIComponent} component
 * @returns {string|undefined}
 */ function recomposeAuthority(component) {
    const uriTokens = [];
    if (component.userinfo !== undefined) {
        uriTokens.push(component.userinfo);
        uriTokens.push('@');
    }
    if (component.host !== undefined) {
        let host = unescape(component.host);
        if (!isIPv4(host)) {
            const ipV6res = normalizeIPv6(host);
            if (ipV6res.isIPV6 === true) {
                host = `[${ipV6res.escapedHost}]`;
            } else {
                host = component.host;
            }
        }
        uriTokens.push(host);
    }
    if (typeof component.port === 'number' || typeof component.port === 'string') {
        uriTokens.push(':');
        uriTokens.push(String(component.port));
    }
    return uriTokens.length ? uriTokens.join('') : undefined;
}
;
module.exports = {
    nonSimpleDomain,
    recomposeAuthority,
    normalizeComponentEncoding,
    removeDotSegments,
    isIPv4,
    isUUID,
    normalizeIPv6,
    stringArrayToHexStripped
};
}),
"[project]/node_modules/fast-uri/lib/schemes.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { isUUID } = __turbopack_context__.r("[project]/node_modules/fast-uri/lib/utils.js [app-client] (ecmascript)");
const URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
const supportedSchemeNames = [
    'http',
    'https',
    'ws',
    'wss',
    'urn',
    'urn:uuid'
];
/** @typedef {supportedSchemeNames[number]} SchemeName */ /**
 * @param {string} name
 * @returns {name is SchemeName}
 */ function isValidSchemeName(name) {
    return supportedSchemeNames.indexOf(name) !== -1;
}
/**
 * @callback SchemeFn
 * @param {import('../types/index').URIComponent} component
 * @param {import('../types/index').Options} options
 * @returns {import('../types/index').URIComponent}
 */ /**
 * @typedef {Object} SchemeHandler
 * @property {SchemeName} scheme - The scheme name.
 * @property {boolean} [domainHost] - Indicates if the scheme supports domain hosts.
 * @property {SchemeFn} parse - Function to parse the URI component for this scheme.
 * @property {SchemeFn} serialize - Function to serialize the URI component for this scheme.
 * @property {boolean} [skipNormalize] - Indicates if normalization should be skipped for this scheme.
 * @property {boolean} [absolutePath] - Indicates if the scheme uses absolute paths.
 * @property {boolean} [unicodeSupport] - Indicates if the scheme supports Unicode.
 */ /**
 * @param {import('../types/index').URIComponent} wsComponent
 * @returns {boolean}
 */ function wsIsSecure(wsComponent) {
    if (wsComponent.secure === true) {
        return true;
    } else if (wsComponent.secure === false) {
        return false;
    } else if (wsComponent.scheme) {
        return wsComponent.scheme.length === 3 && (wsComponent.scheme[0] === 'w' || wsComponent.scheme[0] === 'W') && (wsComponent.scheme[1] === 's' || wsComponent.scheme[1] === 'S') && (wsComponent.scheme[2] === 's' || wsComponent.scheme[2] === 'S');
    } else {
        return false;
    }
}
/** @type {SchemeFn} */ function httpParse(component) {
    if (!component.host) {
        component.error = component.error || 'HTTP URIs must have a host.';
    }
    return component;
}
/** @type {SchemeFn} */ function httpSerialize(component) {
    const secure = String(component.scheme).toLowerCase() === 'https';
    // normalize the default port
    if (component.port === (secure ? 443 : 80) || component.port === '') {
        component.port = undefined;
    }
    // normalize the empty path
    if (!component.path) {
        component.path = '/';
    }
    // NOTE: We do not parse query strings for HTTP URIs
    // as WWW Form Url Encoded query strings are part of the HTML4+ spec,
    // and not the HTTP spec.
    return component;
}
/** @type {SchemeFn} */ function wsParse(wsComponent) {
    // indicate if the secure flag is set
    wsComponent.secure = wsIsSecure(wsComponent);
    // construct resouce name
    wsComponent.resourceName = (wsComponent.path || '/') + (wsComponent.query ? '?' + wsComponent.query : '');
    wsComponent.path = undefined;
    wsComponent.query = undefined;
    return wsComponent;
}
/** @type {SchemeFn} */ function wsSerialize(wsComponent) {
    // normalize the default port
    if (wsComponent.port === (wsIsSecure(wsComponent) ? 443 : 80) || wsComponent.port === '') {
        wsComponent.port = undefined;
    }
    // ensure scheme matches secure flag
    if (typeof wsComponent.secure === 'boolean') {
        wsComponent.scheme = wsComponent.secure ? 'wss' : 'ws';
        wsComponent.secure = undefined;
    }
    // reconstruct path from resource name
    if (wsComponent.resourceName) {
        const [path, query] = wsComponent.resourceName.split('?');
        wsComponent.path = path && path !== '/' ? path : undefined;
        wsComponent.query = query;
        wsComponent.resourceName = undefined;
    }
    // forbid fragment component
    wsComponent.fragment = undefined;
    return wsComponent;
}
/** @type {SchemeFn} */ function urnParse(urnComponent, options) {
    if (!urnComponent.path) {
        urnComponent.error = 'URN can not be parsed';
        return urnComponent;
    }
    const matches = urnComponent.path.match(URN_REG);
    if (matches) {
        const scheme = options.scheme || urnComponent.scheme || 'urn';
        urnComponent.nid = matches[1].toLowerCase();
        urnComponent.nss = matches[2];
        const urnScheme = `${scheme}:${options.nid || urnComponent.nid}`;
        const schemeHandler = getSchemeHandler(urnScheme);
        urnComponent.path = undefined;
        if (schemeHandler) {
            urnComponent = schemeHandler.parse(urnComponent, options);
        }
    } else {
        urnComponent.error = urnComponent.error || 'URN can not be parsed.';
    }
    return urnComponent;
}
/** @type {SchemeFn} */ function urnSerialize(urnComponent, options) {
    if (urnComponent.nid === undefined) {
        throw new Error('URN without nid cannot be serialized');
    }
    const scheme = options.scheme || urnComponent.scheme || 'urn';
    const nid = urnComponent.nid.toLowerCase();
    const urnScheme = `${scheme}:${options.nid || nid}`;
    const schemeHandler = getSchemeHandler(urnScheme);
    if (schemeHandler) {
        urnComponent = schemeHandler.serialize(urnComponent, options);
    }
    const uriComponent = urnComponent;
    const nss = urnComponent.nss;
    uriComponent.path = `${nid || options.nid}:${nss}`;
    options.skipEscape = true;
    return uriComponent;
}
/** @type {SchemeFn} */ function urnuuidParse(urnComponent, options) {
    const uuidComponent = urnComponent;
    uuidComponent.uuid = uuidComponent.nss;
    uuidComponent.nss = undefined;
    if (!options.tolerant && (!uuidComponent.uuid || !isUUID(uuidComponent.uuid))) {
        uuidComponent.error = uuidComponent.error || 'UUID is not valid.';
    }
    return uuidComponent;
}
/** @type {SchemeFn} */ function urnuuidSerialize(uuidComponent) {
    const urnComponent = uuidComponent;
    // normalize UUID
    urnComponent.nss = (uuidComponent.uuid || '').toLowerCase();
    return urnComponent;
}
const http = {
    scheme: 'http',
    domainHost: true,
    parse: httpParse,
    serialize: httpSerialize
};
const https = {
    scheme: 'https',
    domainHost: http.domainHost,
    parse: httpParse,
    serialize: httpSerialize
};
const ws = {
    scheme: 'ws',
    domainHost: true,
    parse: wsParse,
    serialize: wsSerialize
};
const wss = {
    scheme: 'wss',
    domainHost: ws.domainHost,
    parse: ws.parse,
    serialize: ws.serialize
};
const urn = {
    scheme: 'urn',
    parse: urnParse,
    serialize: urnSerialize,
    skipNormalize: true
};
const urnuuid = {
    scheme: 'urn:uuid',
    parse: urnuuidParse,
    serialize: urnuuidSerialize,
    skipNormalize: true
};
const SCHEMES = {
    http,
    https,
    ws,
    wss,
    urn,
    'urn:uuid': urnuuid
};
Object.setPrototypeOf(SCHEMES, null);
/**
 * @param {string|undefined} scheme
 * @returns {SchemeHandler|undefined}
 */ function getSchemeHandler(scheme) {
    return scheme && (SCHEMES[scheme] || SCHEMES[scheme.toLowerCase()]) || undefined;
}
module.exports = {
    wsIsSecure,
    SCHEMES,
    isValidSchemeName,
    getSchemeHandler
};
}),
"[project]/node_modules/fast-uri/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { normalizeIPv6, removeDotSegments, recomposeAuthority, normalizeComponentEncoding, isIPv4, nonSimpleDomain } = __turbopack_context__.r("[project]/node_modules/fast-uri/lib/utils.js [app-client] (ecmascript)");
const { SCHEMES, getSchemeHandler } = __turbopack_context__.r("[project]/node_modules/fast-uri/lib/schemes.js [app-client] (ecmascript)");
/**
 * @template {import('./types/index').URIComponent|string} T
 * @param {T} uri
 * @param {import('./types/index').Options} [options]
 * @returns {T}
 */ function normalize(uri, options) {
    if (typeof uri === 'string') {
        uri = serialize(parse(uri, options), options);
    } else if (typeof uri === 'object') {
        uri = parse(serialize(uri, options), options);
    }
    return uri;
}
/**
 * @param {string} baseURI
 * @param {string} relativeURI
 * @param {import('./types/index').Options} [options]
 * @returns {string}
 */ function resolve(baseURI, relativeURI, options) {
    const schemelessOptions = options ? Object.assign({
        scheme: 'null'
    }, options) : {
        scheme: 'null'
    };
    const resolved = resolveComponent(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true);
    schemelessOptions.skipEscape = true;
    return serialize(resolved, schemelessOptions);
}
/**
 * @param {import ('./types/index').URIComponent} base
 * @param {import ('./types/index').URIComponent} relative
 * @param {import('./types/index').Options} [options]
 * @param {boolean} [skipNormalization=false]
 * @returns {import ('./types/index').URIComponent}
 */ function resolveComponent(base, relative, options, skipNormalization) {
    /** @type {import('./types/index').URIComponent} */ const target = {};
    if (!skipNormalization) {
        base = parse(serialize(base, options), options); // normalize base component
        relative = parse(serialize(relative, options), options); // normalize relative component
    }
    options = options || {};
    if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        // target.authority = relative.authority;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || '');
        target.query = relative.query;
    } else {
        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
            // target.authority = relative.authority;
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || '');
            target.query = relative.query;
        } else {
            if (!relative.path) {
                target.path = base.path;
                if (relative.query !== undefined) {
                    target.query = relative.query;
                } else {
                    target.query = base.query;
                }
            } else {
                if (relative.path[0] === '/') {
                    target.path = removeDotSegments(relative.path);
                } else {
                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
                        target.path = '/' + relative.path;
                    } else if (!base.path) {
                        target.path = relative.path;
                    } else {
                        target.path = base.path.slice(0, base.path.lastIndexOf('/') + 1) + relative.path;
                    }
                    target.path = removeDotSegments(target.path);
                }
                target.query = relative.query;
            }
            // target.authority = base.authority;
            target.userinfo = base.userinfo;
            target.host = base.host;
            target.port = base.port;
        }
        target.scheme = base.scheme;
    }
    target.fragment = relative.fragment;
    return target;
}
/**
 * @param {import ('./types/index').URIComponent|string} uriA
 * @param {import ('./types/index').URIComponent|string} uriB
 * @param {import ('./types/index').Options} options
 * @returns {boolean}
 */ function equal(uriA, uriB, options) {
    if (typeof uriA === 'string') {
        uriA = unescape(uriA);
        uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), {
            ...options,
            skipEscape: true
        });
    } else if (typeof uriA === 'object') {
        uriA = serialize(normalizeComponentEncoding(uriA, true), {
            ...options,
            skipEscape: true
        });
    }
    if (typeof uriB === 'string') {
        uriB = unescape(uriB);
        uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), {
            ...options,
            skipEscape: true
        });
    } else if (typeof uriB === 'object') {
        uriB = serialize(normalizeComponentEncoding(uriB, true), {
            ...options,
            skipEscape: true
        });
    }
    return uriA.toLowerCase() === uriB.toLowerCase();
}
/**
 * @param {Readonly<import('./types/index').URIComponent>} cmpts
 * @param {import('./types/index').Options} [opts]
 * @returns {string}
 */ function serialize(cmpts, opts) {
    const component = {
        host: cmpts.host,
        scheme: cmpts.scheme,
        userinfo: cmpts.userinfo,
        port: cmpts.port,
        path: cmpts.path,
        query: cmpts.query,
        nid: cmpts.nid,
        nss: cmpts.nss,
        uuid: cmpts.uuid,
        fragment: cmpts.fragment,
        reference: cmpts.reference,
        resourceName: cmpts.resourceName,
        secure: cmpts.secure,
        error: ''
    };
    const options = Object.assign({}, opts);
    const uriTokens = [];
    // find scheme handler
    const schemeHandler = getSchemeHandler(options.scheme || component.scheme);
    // perform scheme specific serialization
    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(component, options);
    if (component.path !== undefined) {
        if (!options.skipEscape) {
            component.path = escape(component.path);
            if (component.scheme !== undefined) {
                component.path = component.path.split('%3A').join(':');
            }
        } else {
            component.path = unescape(component.path);
        }
    }
    if (options.reference !== 'suffix' && component.scheme) {
        uriTokens.push(component.scheme, ':');
    }
    const authority = recomposeAuthority(component);
    if (authority !== undefined) {
        if (options.reference !== 'suffix') {
            uriTokens.push('//');
        }
        uriTokens.push(authority);
        if (component.path && component.path[0] !== '/') {
            uriTokens.push('/');
        }
    }
    if (component.path !== undefined) {
        let s = component.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s = removeDotSegments(s);
        }
        if (authority === undefined && s[0] === '/' && s[1] === '/') {
            // don't allow the path to start with "//"
            s = '/%2F' + s.slice(2);
        }
        uriTokens.push(s);
    }
    if (component.query !== undefined) {
        uriTokens.push('?', component.query);
    }
    if (component.fragment !== undefined) {
        uriTokens.push('#', component.fragment);
    }
    return uriTokens.join('');
}
const URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
/**
 * @param {string} uri
 * @param {import('./types/index').Options} [opts]
 * @returns
 */ function parse(uri, opts) {
    const options = Object.assign({}, opts);
    /** @type {import('./types/index').URIComponent} */ const parsed = {
        scheme: undefined,
        userinfo: undefined,
        host: '',
        port: undefined,
        path: '',
        query: undefined,
        fragment: undefined
    };
    let isIP = false;
    if (options.reference === 'suffix') {
        if (options.scheme) {
            uri = options.scheme + ':' + uri;
        } else {
            uri = '//' + uri;
        }
    }
    const matches = uri.match(URI_PARSE);
    if (matches) {
        // store each component
        parsed.scheme = matches[1];
        parsed.userinfo = matches[3];
        parsed.host = matches[4];
        parsed.port = parseInt(matches[5], 10);
        parsed.path = matches[6] || '';
        parsed.query = matches[7];
        parsed.fragment = matches[8];
        // fix port number
        if (isNaN(parsed.port)) {
            parsed.port = matches[5];
        }
        if (parsed.host) {
            const ipv4result = isIPv4(parsed.host);
            if (ipv4result === false) {
                const ipv6result = normalizeIPv6(parsed.host);
                parsed.host = ipv6result.host.toLowerCase();
                isIP = ipv6result.isIPV6;
            } else {
                isIP = true;
            }
        }
        if (parsed.scheme === undefined && parsed.userinfo === undefined && parsed.host === undefined && parsed.port === undefined && parsed.query === undefined && !parsed.path) {
            parsed.reference = 'same-document';
        } else if (parsed.scheme === undefined) {
            parsed.reference = 'relative';
        } else if (parsed.fragment === undefined) {
            parsed.reference = 'absolute';
        } else {
            parsed.reference = 'uri';
        }
        // check for reference errors
        if (options.reference && options.reference !== 'suffix' && options.reference !== parsed.reference) {
            parsed.error = parsed.error || 'URI is not a ' + options.reference + ' reference.';
        }
        // find scheme handler
        const schemeHandler = getSchemeHandler(options.scheme || parsed.scheme);
        // check if scheme can't handle IRIs
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            // if host component is a domain name
            if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
                // convert Unicode IDN -> ASCII IDN
                try {
                    parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
                } catch (e) {
                    parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
                }
            }
        // convert IRI -> URI
        }
        if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
            if (uri.indexOf('%') !== -1) {
                if (parsed.scheme !== undefined) {
                    parsed.scheme = unescape(parsed.scheme);
                }
                if (parsed.host !== undefined) {
                    parsed.host = unescape(parsed.host);
                }
            }
            if (parsed.path) {
                parsed.path = escape(unescape(parsed.path));
            }
            if (parsed.fragment) {
                parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
            }
        }
        // perform scheme specific parsing
        if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(parsed, options);
        }
    } else {
        parsed.error = parsed.error || 'URI can not be parsed.';
    }
    return parsed;
}
const fastUri = {
    SCHEMES,
    normalize,
    resolve,
    resolveComponent,
    equal,
    serialize,
    parse
};
module.exports = fastUri;
module.exports.default = fastUri;
module.exports.fastUri = fastUri;
}),
"[project]/node_modules/@stablelib/int/lib/int.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 * Package int provides helper functions for integerss.
 */ // Shim using 16-bit pieces.
function imulShim(a, b) {
    var ah = a >>> 16 & 0xffff, al = a & 0xffff;
    var bh = b >>> 16 & 0xffff, bl = b & 0xffff;
    return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
}
/** 32-bit integer multiplication.  */ // Use system Math.imul if available, otherwise use our shim.
exports.mul = Math.imul || imulShim;
/** 32-bit integer addition.  */ function add(a, b) {
    return a + b | 0;
}
exports.add = add;
/**  32-bit integer subtraction.  */ function sub(a, b) {
    return a - b | 0;
}
exports.sub = sub;
/** 32-bit integer left rotation */ function rotl(x, n) {
    return x << n | x >>> 32 - n;
}
exports.rotl = rotl;
/** 32-bit integer left rotation */ function rotr(x, n) {
    return x << 32 - n | x >>> n;
}
exports.rotr = rotr;
function isIntegerShim(n) {
    return typeof n === "number" && isFinite(n) && Math.floor(n) === n;
}
/**
 * Returns true if the argument is an integer number.
 *
 * In ES2015, Number.isInteger.
 */ exports.isInteger = Number.isInteger || isIntegerShim;
/**
 *  Math.pow(2, 53) - 1
 *
 *  In ES2015 Number.MAX_SAFE_INTEGER.
 */ exports.MAX_SAFE_INTEGER = 9007199254740991;
/**
 * Returns true if the argument is a safe integer number
 * (-MIN_SAFE_INTEGER < number <= MAX_SAFE_INTEGER)
 *
 * In ES2015, Number.isSafeInteger.
 */ exports.isSafeInteger = function(n) {
    return exports.isInteger(n) && n >= -exports.MAX_SAFE_INTEGER && n <= exports.MAX_SAFE_INTEGER;
}; //# sourceMappingURL=int.js.map
}),
"[project]/node_modules/@stablelib/binary/lib/binary.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 * Package binary provides functions for encoding and decoding numbers in byte arrays.
 */ var int_1 = __turbopack_context__.r("[project]/node_modules/@stablelib/int/lib/int.js [app-client] (ecmascript)");
// TODO(dchest): add asserts for correct value ranges and array offsets.
/**
 * Reads 2 bytes from array starting at offset as big-endian
 * signed 16-bit integer and returns it.
 */ function readInt16BE(array, offset) {
    if (offset === void 0) {
        offset = 0;
    }
    return (array[offset + 0] << 8 | array[offset + 1]) << 16 >> 16;
}
exports.readInt16BE = readInt16BE;
/**
 * Reads 2 bytes from array starting at offset as big-endian
 * unsigned 16-bit integer and returns it.
 */ function readUint16BE(array, offset) {
    if (offset === void 0) {
        offset = 0;
    }
    return (array[offset + 0] << 8 | array[offset + 1]) >>> 0;
}
exports.readUint16BE = readUint16BE;
/**
 * Reads 2 bytes from array starting at offset as little-endian
 * signed 16-bit integer and returns it.
 */ function readInt16LE(array, offset) {
    if (offset === void 0) {
        offset = 0;
    }
    return (array[offset + 1] << 8 | array[offset]) << 16 >> 16;
}
exports.readInt16LE = readInt16LE;
/**
 * Reads 2 bytes from array starting at offset as little-endian
 * unsigned 16-bit integer and returns it.
 */ function readUint16LE(array, offset) {
    if (offset === void 0) {
        offset = 0;
    }
    return (array[offset + 1] << 8 | array[offset]) >>> 0;
}
exports.readUint16LE = readUint16LE;
/**
 * Writes 2-byte big-endian representation of 16-bit unsigned
 * value to byte array starting at offset.
 *
 * If byte array is not given, creates a new 2-byte one.
 *
 * Returns the output byte array.
 */ function writeUint16BE(value, out, offset) {
    if (out === void 0) {
        out = new Uint8Array(2);
    }
    if (offset === void 0) {
        offset = 0;
    }
    out[offset + 0] = value >>> 8;
    out[offset + 1] = value >>> 0;
    return out;
}
exports.writeUint16BE = writeUint16BE;
exports.writeInt16BE = writeUint16BE;
/**
 * Writes 2-byte little-endian representation of 16-bit unsigned
 * value to array starting at offset.
 *
 * If byte array is not given, creates a new 2-byte one.
 *
 * Returns the output byte array.
 */ function writeUint16LE(value, out, offset) {
    if (out === void 0) {
        out = new Uint8Array(2);
    }
    if (offset === void 0) {
        offset = 0;
    }
    out[offset + 0] = value >>> 0;
    out[offset + 1] = value >>> 8;
    return out;
}
exports.writeUint16LE = writeUint16LE;
exports.writeInt16LE = writeUint16LE;
/**
 * Reads 4 bytes from array starting at offset as big-endian
 * signed 32-bit integer and returns it.
 */ function readInt32BE(array, offset) {
    if (offset === void 0) {
        offset = 0;
    }
    return array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3];
}
exports.readInt32BE = readInt32BE;
/**
 * Reads 4 bytes from array starting at offset as big-endian
 * unsigned 32-bit integer and returns it.
 */ function readUint32BE(array, offset) {
    if (offset === void 0) {
        offset = 0;
    }
    return (array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3]) >>> 0;
}
exports.readUint32BE = readUint32BE;
/**
 * Reads 4 bytes from array starting at offset as little-endian
 * signed 32-bit integer and returns it.
 */ function readInt32LE(array, offset) {
    if (offset === void 0) {
        offset = 0;
    }
    return array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset];
}
exports.readInt32LE = readInt32LE;
/**
 * Reads 4 bytes from array starting at offset as little-endian
 * unsigned 32-bit integer and returns it.
 */ function readUint32LE(array, offset) {
    if (offset === void 0) {
        offset = 0;
    }
    return (array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset]) >>> 0;
}
exports.readUint32LE = readUint32LE;
/**
 * Writes 4-byte big-endian representation of 32-bit unsigned
 * value to byte array starting at offset.
 *
 * If byte array is not given, creates a new 4-byte one.
 *
 * Returns the output byte array.
 */ function writeUint32BE(value, out, offset) {
    if (out === void 0) {
        out = new Uint8Array(4);
    }
    if (offset === void 0) {
        offset = 0;
    }
    out[offset + 0] = value >>> 24;
    out[offset + 1] = value >>> 16;
    out[offset + 2] = value >>> 8;
    out[offset + 3] = value >>> 0;
    return out;
}
exports.writeUint32BE = writeUint32BE;
exports.writeInt32BE = writeUint32BE;
/**
 * Writes 4-byte little-endian representation of 32-bit unsigned
 * value to array starting at offset.
 *
 * If byte array is not given, creates a new 4-byte one.
 *
 * Returns the output byte array.
 */ function writeUint32LE(value, out, offset) {
    if (out === void 0) {
        out = new Uint8Array(4);
    }
    if (offset === void 0) {
        offset = 0;
    }
    out[offset + 0] = value >>> 0;
    out[offset + 1] = value >>> 8;
    out[offset + 2] = value >>> 16;
    out[offset + 3] = value >>> 24;
    return out;
}
exports.writeUint32LE = writeUint32LE;
exports.writeInt32LE = writeUint32LE;
/**
 * Reads 8 bytes from array starting at offset as big-endian
 * signed 64-bit integer and returns it.
 *
 * IMPORTANT: due to JavaScript limitation, supports exact
 * numbers in range -9007199254740991 to 9007199254740991.
 * If the number stored in the byte array is outside this range,
 * the result is not exact.
 */ function readInt64BE(array, offset) {
    if (offset === void 0) {
        offset = 0;
    }
    var hi = readInt32BE(array, offset);
    var lo = readInt32BE(array, offset + 4);
    return hi * 0x100000000 + lo - (lo >> 31) * 0x100000000;
}
exports.readInt64BE = readInt64BE;
/**
 * Reads 8 bytes from array starting at offset as big-endian
 * unsigned 64-bit integer and returns it.
 *
 * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.
 */ function readUint64BE(array, offset) {
    if (offset === void 0) {
        offset = 0;
    }
    var hi = readUint32BE(array, offset);
    var lo = readUint32BE(array, offset + 4);
    return hi * 0x100000000 + lo;
}
exports.readUint64BE = readUint64BE;
/**
 * Reads 8 bytes from array starting at offset as little-endian
 * signed 64-bit integer and returns it.
 *
 * IMPORTANT: due to JavaScript limitation, supports exact
 * numbers in range -9007199254740991 to 9007199254740991.
 * If the number stored in the byte array is outside this range,
 * the result is not exact.
 */ function readInt64LE(array, offset) {
    if (offset === void 0) {
        offset = 0;
    }
    var lo = readInt32LE(array, offset);
    var hi = readInt32LE(array, offset + 4);
    return hi * 0x100000000 + lo - (lo >> 31) * 0x100000000;
}
exports.readInt64LE = readInt64LE;
/**
 * Reads 8 bytes from array starting at offset as little-endian
 * unsigned 64-bit integer and returns it.
 *
 * IMPORTANT: due to JavaScript limitation, supports values up to 2^53-1.
 */ function readUint64LE(array, offset) {
    if (offset === void 0) {
        offset = 0;
    }
    var lo = readUint32LE(array, offset);
    var hi = readUint32LE(array, offset + 4);
    return hi * 0x100000000 + lo;
}
exports.readUint64LE = readUint64LE;
/**
 * Writes 8-byte big-endian representation of 64-bit unsigned
 * value to byte array starting at offset.
 *
 * Due to JavaScript limitation, supports values up to 2^53-1.
 *
 * If byte array is not given, creates a new 8-byte one.
 *
 * Returns the output byte array.
 */ function writeUint64BE(value, out, offset) {
    if (out === void 0) {
        out = new Uint8Array(8);
    }
    if (offset === void 0) {
        offset = 0;
    }
    writeUint32BE(value / 0x100000000 >>> 0, out, offset);
    writeUint32BE(value >>> 0, out, offset + 4);
    return out;
}
exports.writeUint64BE = writeUint64BE;
exports.writeInt64BE = writeUint64BE;
/**
 * Writes 8-byte little-endian representation of 64-bit unsigned
 * value to byte array starting at offset.
 *
 * Due to JavaScript limitation, supports values up to 2^53-1.
 *
 * If byte array is not given, creates a new 8-byte one.
 *
 * Returns the output byte array.
 */ function writeUint64LE(value, out, offset) {
    if (out === void 0) {
        out = new Uint8Array(8);
    }
    if (offset === void 0) {
        offset = 0;
    }
    writeUint32LE(value >>> 0, out, offset);
    writeUint32LE(value / 0x100000000 >>> 0, out, offset + 4);
    return out;
}
exports.writeUint64LE = writeUint64LE;
exports.writeInt64LE = writeUint64LE;
/**
 * Reads bytes from array starting at offset as big-endian
 * unsigned bitLen-bit integer and returns it.
 *
 * Supports bit lengths divisible by 8, up to 48.
 */ function readUintBE(bitLength, array, offset) {
    if (offset === void 0) {
        offset = 0;
    }
    // TODO(dchest): implement support for bitLengths non-divisible by 8
    if (bitLength % 8 !== 0) {
        throw new Error("readUintBE supports only bitLengths divisible by 8");
    }
    if (bitLength / 8 > array.length - offset) {
        throw new Error("readUintBE: array is too short for the given bitLength");
    }
    var result = 0;
    var mul = 1;
    for(var i = bitLength / 8 + offset - 1; i >= offset; i--){
        result += array[i] * mul;
        mul *= 256;
    }
    return result;
}
exports.readUintBE = readUintBE;
/**
 * Reads bytes from array starting at offset as little-endian
 * unsigned bitLen-bit integer and returns it.
 *
 * Supports bit lengths divisible by 8, up to 48.
 */ function readUintLE(bitLength, array, offset) {
    if (offset === void 0) {
        offset = 0;
    }
    // TODO(dchest): implement support for bitLengths non-divisible by 8
    if (bitLength % 8 !== 0) {
        throw new Error("readUintLE supports only bitLengths divisible by 8");
    }
    if (bitLength / 8 > array.length - offset) {
        throw new Error("readUintLE: array is too short for the given bitLength");
    }
    var result = 0;
    var mul = 1;
    for(var i = offset; i < offset + bitLength / 8; i++){
        result += array[i] * mul;
        mul *= 256;
    }
    return result;
}
exports.readUintLE = readUintLE;
/**
 * Writes a big-endian representation of bitLen-bit unsigned
 * value to array starting at offset.
 *
 * Supports bit lengths divisible by 8, up to 48.
 *
 * If byte array is not given, creates a new one.
 *
 * Returns the output byte array.
 */ function writeUintBE(bitLength, value, out, offset) {
    if (out === void 0) {
        out = new Uint8Array(bitLength / 8);
    }
    if (offset === void 0) {
        offset = 0;
    }
    // TODO(dchest): implement support for bitLengths non-divisible by 8
    if (bitLength % 8 !== 0) {
        throw new Error("writeUintBE supports only bitLengths divisible by 8");
    }
    if (!int_1.isSafeInteger(value)) {
        throw new Error("writeUintBE value must be an integer");
    }
    var div = 1;
    for(var i = bitLength / 8 + offset - 1; i >= offset; i--){
        out[i] = value / div & 0xff;
        div *= 256;
    }
    return out;
}
exports.writeUintBE = writeUintBE;
/**
 * Writes a little-endian representation of bitLen-bit unsigned
 * value to array starting at offset.
 *
 * Supports bit lengths divisible by 8, up to 48.
 *
 * If byte array is not given, creates a new one.
 *
 * Returns the output byte array.
 */ function writeUintLE(bitLength, value, out, offset) {
    if (out === void 0) {
        out = new Uint8Array(bitLength / 8);
    }
    if (offset === void 0) {
        offset = 0;
    }
    // TODO(dchest): implement support for bitLengths non-divisible by 8
    if (bitLength % 8 !== 0) {
        throw new Error("writeUintLE supports only bitLengths divisible by 8");
    }
    if (!int_1.isSafeInteger(value)) {
        throw new Error("writeUintLE value must be an integer");
    }
    var div = 1;
    for(var i = offset; i < offset + bitLength / 8; i++){
        out[i] = value / div & 0xff;
        div *= 256;
    }
    return out;
}
exports.writeUintLE = writeUintLE;
/**
 * Reads 4 bytes from array starting at offset as big-endian
 * 32-bit floating-point number and returns it.
 */ function readFloat32BE(array, offset) {
    if (offset === void 0) {
        offset = 0;
    }
    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    return view.getFloat32(offset);
}
exports.readFloat32BE = readFloat32BE;
/**
 * Reads 4 bytes from array starting at offset as little-endian
 * 32-bit floating-point number and returns it.
 */ function readFloat32LE(array, offset) {
    if (offset === void 0) {
        offset = 0;
    }
    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    return view.getFloat32(offset, true);
}
exports.readFloat32LE = readFloat32LE;
/**
 * Reads 8 bytes from array starting at offset as big-endian
 * 64-bit floating-point number ("double") and returns it.
 */ function readFloat64BE(array, offset) {
    if (offset === void 0) {
        offset = 0;
    }
    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    return view.getFloat64(offset);
}
exports.readFloat64BE = readFloat64BE;
/**
 * Reads 8 bytes from array starting at offset as little-endian
 * 64-bit floating-point number ("double") and returns it.
 */ function readFloat64LE(array, offset) {
    if (offset === void 0) {
        offset = 0;
    }
    var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
    return view.getFloat64(offset, true);
}
exports.readFloat64LE = readFloat64LE;
/**
 * Writes 4-byte big-endian floating-point representation of value
 * to byte array starting at offset.
 *
 * If byte array is not given, creates a new 4-byte one.
 *
 * Returns the output byte array.
 */ function writeFloat32BE(value, out, offset) {
    if (out === void 0) {
        out = new Uint8Array(4);
    }
    if (offset === void 0) {
        offset = 0;
    }
    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
    view.setFloat32(offset, value);
    return out;
}
exports.writeFloat32BE = writeFloat32BE;
/**
 * Writes 4-byte little-endian floating-point representation of value
 * to byte array starting at offset.
 *
 * If byte array is not given, creates a new 4-byte one.
 *
 * Returns the output byte array.
 */ function writeFloat32LE(value, out, offset) {
    if (out === void 0) {
        out = new Uint8Array(4);
    }
    if (offset === void 0) {
        offset = 0;
    }
    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
    view.setFloat32(offset, value, true);
    return out;
}
exports.writeFloat32LE = writeFloat32LE;
/**
 * Writes 8-byte big-endian floating-point representation of value
 * to byte array starting at offset.
 *
 * If byte array is not given, creates a new 8-byte one.
 *
 * Returns the output byte array.
 */ function writeFloat64BE(value, out, offset) {
    if (out === void 0) {
        out = new Uint8Array(8);
    }
    if (offset === void 0) {
        offset = 0;
    }
    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
    view.setFloat64(offset, value);
    return out;
}
exports.writeFloat64BE = writeFloat64BE;
/**
 * Writes 8-byte little-endian floating-point representation of value
 * to byte array starting at offset.
 *
 * If byte array is not given, creates a new 8-byte one.
 *
 * Returns the output byte array.
 */ function writeFloat64LE(value, out, offset) {
    if (out === void 0) {
        out = new Uint8Array(8);
    }
    if (offset === void 0) {
        offset = 0;
    }
    var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
    view.setFloat64(offset, value, true);
    return out;
}
exports.writeFloat64LE = writeFloat64LE; //# sourceMappingURL=binary.js.map
}),
"[project]/node_modules/@stablelib/wipe/lib/wipe.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 * Sets all values in the given array to zero and returns it.
 *
 * The fact that it sets bytes to zero can be relied on.
 *
 * There is no guarantee that this function makes data disappear from memory,
 * as runtime implementation can, for example, have copying garbage collector
 * that will make copies of sensitive data before we wipe it. Or that an
 * operating system will write our data to swap or sleep image. Another thing
 * is that an optimizing compiler can remove calls to this function or make it
 * no-op. There's nothing we can do with it, so we just do our best and hope
 * that everything will be okay and good will triumph over evil.
 */ function wipe(array) {
    // Right now it's similar to array.fill(0). If it turns
    // out that runtimes optimize this call away, maybe
    // we can try something else.
    for(var i = 0; i < array.length; i++){
        array[i] = 0;
    }
    return array;
}
exports.wipe = wipe; //# sourceMappingURL=wipe.js.map
}),
"[project]/node_modules/@stablelib/chacha/lib/chacha.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 * Package chacha implements ChaCha stream cipher.
 */ var binary_1 = __turbopack_context__.r("[project]/node_modules/@stablelib/binary/lib/binary.js [app-client] (ecmascript)");
var wipe_1 = __turbopack_context__.r("[project]/node_modules/@stablelib/wipe/lib/wipe.js [app-client] (ecmascript)");
// Number of ChaCha rounds (ChaCha20).
var ROUNDS = 20;
// Applies the ChaCha core function to 16-byte input,
// 32-byte key key, and puts the result into 64-byte array out.
function core(out, input, key) {
    var j0 = 0x61707865; // "expa"  -- ChaCha's "sigma" constant
    var j1 = 0x3320646E; // "nd 3"     for 32-byte keys
    var j2 = 0x79622D32; // "2-by"
    var j3 = 0x6B206574; // "te k"
    var j4 = key[3] << 24 | key[2] << 16 | key[1] << 8 | key[0];
    var j5 = key[7] << 24 | key[6] << 16 | key[5] << 8 | key[4];
    var j6 = key[11] << 24 | key[10] << 16 | key[9] << 8 | key[8];
    var j7 = key[15] << 24 | key[14] << 16 | key[13] << 8 | key[12];
    var j8 = key[19] << 24 | key[18] << 16 | key[17] << 8 | key[16];
    var j9 = key[23] << 24 | key[22] << 16 | key[21] << 8 | key[20];
    var j10 = key[27] << 24 | key[26] << 16 | key[25] << 8 | key[24];
    var j11 = key[31] << 24 | key[30] << 16 | key[29] << 8 | key[28];
    var j12 = input[3] << 24 | input[2] << 16 | input[1] << 8 | input[0];
    var j13 = input[7] << 24 | input[6] << 16 | input[5] << 8 | input[4];
    var j14 = input[11] << 24 | input[10] << 16 | input[9] << 8 | input[8];
    var j15 = input[15] << 24 | input[14] << 16 | input[13] << 8 | input[12];
    var x0 = j0;
    var x1 = j1;
    var x2 = j2;
    var x3 = j3;
    var x4 = j4;
    var x5 = j5;
    var x6 = j6;
    var x7 = j7;
    var x8 = j8;
    var x9 = j9;
    var x10 = j10;
    var x11 = j11;
    var x12 = j12;
    var x13 = j13;
    var x14 = j14;
    var x15 = j15;
    for(var i = 0; i < ROUNDS; i += 2){
        x0 = x0 + x4 | 0;
        x12 ^= x0;
        x12 = x12 >>> 32 - 16 | x12 << 16;
        x8 = x8 + x12 | 0;
        x4 ^= x8;
        x4 = x4 >>> 32 - 12 | x4 << 12;
        x1 = x1 + x5 | 0;
        x13 ^= x1;
        x13 = x13 >>> 32 - 16 | x13 << 16;
        x9 = x9 + x13 | 0;
        x5 ^= x9;
        x5 = x5 >>> 32 - 12 | x5 << 12;
        x2 = x2 + x6 | 0;
        x14 ^= x2;
        x14 = x14 >>> 32 - 16 | x14 << 16;
        x10 = x10 + x14 | 0;
        x6 ^= x10;
        x6 = x6 >>> 32 - 12 | x6 << 12;
        x3 = x3 + x7 | 0;
        x15 ^= x3;
        x15 = x15 >>> 32 - 16 | x15 << 16;
        x11 = x11 + x15 | 0;
        x7 ^= x11;
        x7 = x7 >>> 32 - 12 | x7 << 12;
        x2 = x2 + x6 | 0;
        x14 ^= x2;
        x14 = x14 >>> 32 - 8 | x14 << 8;
        x10 = x10 + x14 | 0;
        x6 ^= x10;
        x6 = x6 >>> 32 - 7 | x6 << 7;
        x3 = x3 + x7 | 0;
        x15 ^= x3;
        x15 = x15 >>> 32 - 8 | x15 << 8;
        x11 = x11 + x15 | 0;
        x7 ^= x11;
        x7 = x7 >>> 32 - 7 | x7 << 7;
        x1 = x1 + x5 | 0;
        x13 ^= x1;
        x13 = x13 >>> 32 - 8 | x13 << 8;
        x9 = x9 + x13 | 0;
        x5 ^= x9;
        x5 = x5 >>> 32 - 7 | x5 << 7;
        x0 = x0 + x4 | 0;
        x12 ^= x0;
        x12 = x12 >>> 32 - 8 | x12 << 8;
        x8 = x8 + x12 | 0;
        x4 ^= x8;
        x4 = x4 >>> 32 - 7 | x4 << 7;
        x0 = x0 + x5 | 0;
        x15 ^= x0;
        x15 = x15 >>> 32 - 16 | x15 << 16;
        x10 = x10 + x15 | 0;
        x5 ^= x10;
        x5 = x5 >>> 32 - 12 | x5 << 12;
        x1 = x1 + x6 | 0;
        x12 ^= x1;
        x12 = x12 >>> 32 - 16 | x12 << 16;
        x11 = x11 + x12 | 0;
        x6 ^= x11;
        x6 = x6 >>> 32 - 12 | x6 << 12;
        x2 = x2 + x7 | 0;
        x13 ^= x2;
        x13 = x13 >>> 32 - 16 | x13 << 16;
        x8 = x8 + x13 | 0;
        x7 ^= x8;
        x7 = x7 >>> 32 - 12 | x7 << 12;
        x3 = x3 + x4 | 0;
        x14 ^= x3;
        x14 = x14 >>> 32 - 16 | x14 << 16;
        x9 = x9 + x14 | 0;
        x4 ^= x9;
        x4 = x4 >>> 32 - 12 | x4 << 12;
        x2 = x2 + x7 | 0;
        x13 ^= x2;
        x13 = x13 >>> 32 - 8 | x13 << 8;
        x8 = x8 + x13 | 0;
        x7 ^= x8;
        x7 = x7 >>> 32 - 7 | x7 << 7;
        x3 = x3 + x4 | 0;
        x14 ^= x3;
        x14 = x14 >>> 32 - 8 | x14 << 8;
        x9 = x9 + x14 | 0;
        x4 ^= x9;
        x4 = x4 >>> 32 - 7 | x4 << 7;
        x1 = x1 + x6 | 0;
        x12 ^= x1;
        x12 = x12 >>> 32 - 8 | x12 << 8;
        x11 = x11 + x12 | 0;
        x6 ^= x11;
        x6 = x6 >>> 32 - 7 | x6 << 7;
        x0 = x0 + x5 | 0;
        x15 ^= x0;
        x15 = x15 >>> 32 - 8 | x15 << 8;
        x10 = x10 + x15 | 0;
        x5 ^= x10;
        x5 = x5 >>> 32 - 7 | x5 << 7;
    }
    binary_1.writeUint32LE(x0 + j0 | 0, out, 0);
    binary_1.writeUint32LE(x1 + j1 | 0, out, 4);
    binary_1.writeUint32LE(x2 + j2 | 0, out, 8);
    binary_1.writeUint32LE(x3 + j3 | 0, out, 12);
    binary_1.writeUint32LE(x4 + j4 | 0, out, 16);
    binary_1.writeUint32LE(x5 + j5 | 0, out, 20);
    binary_1.writeUint32LE(x6 + j6 | 0, out, 24);
    binary_1.writeUint32LE(x7 + j7 | 0, out, 28);
    binary_1.writeUint32LE(x8 + j8 | 0, out, 32);
    binary_1.writeUint32LE(x9 + j9 | 0, out, 36);
    binary_1.writeUint32LE(x10 + j10 | 0, out, 40);
    binary_1.writeUint32LE(x11 + j11 | 0, out, 44);
    binary_1.writeUint32LE(x12 + j12 | 0, out, 48);
    binary_1.writeUint32LE(x13 + j13 | 0, out, 52);
    binary_1.writeUint32LE(x14 + j14 | 0, out, 56);
    binary_1.writeUint32LE(x15 + j15 | 0, out, 60);
}
/**
 * Encrypt src with ChaCha20 stream generated for the given 32-byte key and
 * 8-byte (as in original implementation) or 12-byte (as in RFC7539) nonce and
 * write the result into dst and return it.
 *
 * dst and src may be the same, but otherwise must not overlap.
 *
 * If nonce is 12 bytes, users should not encrypt more than 256 GiB with the
 * same key and nonce, otherwise the stream will repeat. The function will
 * throw error if counter overflows to prevent this.
 *
 * If nonce is 8 bytes, the output is practically unlimited (2^70 bytes, which
 * is more than a million petabytes). However, it is not recommended to
 * generate 8-byte nonces randomly, as the chance of collision is high.
 *
 * Never use the same key and nonce to encrypt more than one message.
 *
 * If nonceInplaceCounterLength is not 0, the nonce is assumed to be a 16-byte
 * array with stream counter in first nonceInplaceCounterLength bytes and nonce
 * in the last remaining bytes. The counter will be incremented inplace for
 * each ChaCha block. This is useful if you need to encrypt one stream of data
 * in chunks.
 */ function streamXOR(key, nonce, src, dst, nonceInplaceCounterLength) {
    if (nonceInplaceCounterLength === void 0) {
        nonceInplaceCounterLength = 0;
    }
    // We only support 256-bit keys.
    if (key.length !== 32) {
        throw new Error("ChaCha: key size must be 32 bytes");
    }
    if (dst.length < src.length) {
        throw new Error("ChaCha: destination is shorter than source");
    }
    var nc;
    var counterLength;
    if (nonceInplaceCounterLength === 0) {
        if (nonce.length !== 8 && nonce.length !== 12) {
            throw new Error("ChaCha nonce must be 8 or 12 bytes");
        }
        nc = new Uint8Array(16);
        // First counterLength bytes of nc are counter, starting with zero.
        counterLength = nc.length - nonce.length;
        // Last bytes of nc after counterLength are nonce, set them.
        nc.set(nonce, counterLength);
    } else {
        if (nonce.length !== 16) {
            throw new Error("ChaCha nonce with counter must be 16 bytes");
        }
        // This will update passed nonce with counter inplace.
        nc = nonce;
        counterLength = nonceInplaceCounterLength;
    }
    // Allocate temporary space for ChaCha block.
    var block = new Uint8Array(64);
    for(var i = 0; i < src.length; i += 64){
        // Generate a block.
        core(block, nc, key);
        // XOR block bytes with src into dst.
        for(var j = i; j < i + 64 && j < src.length; j++){
            dst[j] = src[j] ^ block[j - i];
        }
        // Increment counter.
        incrementCounter(nc, 0, counterLength);
    }
    // Cleanup temporary space.
    wipe_1.wipe(block);
    if (nonceInplaceCounterLength === 0) {
        // Cleanup counter.
        wipe_1.wipe(nc);
    }
    return dst;
}
exports.streamXOR = streamXOR;
/**
 * Generate ChaCha20 stream for the given 32-byte key and 8-byte or 12-byte
 * nonce and write it into dst and return it.
 *
 * Never use the same key and nonce to generate more than one stream.
 *
 * If nonceInplaceCounterLength is not 0, it behaves the same with respect to
 * the nonce as described in the streamXOR documentation.
 *
 * stream is like streamXOR with all-zero src.
 */ function stream(key, nonce, dst, nonceInplaceCounterLength) {
    if (nonceInplaceCounterLength === void 0) {
        nonceInplaceCounterLength = 0;
    }
    wipe_1.wipe(dst);
    return streamXOR(key, nonce, dst, dst, nonceInplaceCounterLength);
}
exports.stream = stream;
function incrementCounter(counter, pos, len) {
    var carry = 1;
    while(len--){
        carry = carry + (counter[pos] & 0xff) | 0;
        counter[pos] = carry & 0xff;
        carry >>>= 8;
        pos++;
    }
    if (carry > 0) {
        throw new Error("ChaCha: counter overflow");
    }
} //# sourceMappingURL=chacha.js.map
}),
"[project]/node_modules/@stablelib/constant-time/lib/constant-time.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 * Package constant-time provides functions for performing algorithmically constant-time operations.
 */ /**
 * NOTE! Due to the inability to guarantee real constant time evaluation of
 * anything in JavaScript VM, this is module is the best effort.
 */ /**
 * Returns resultIfOne if subject is 1, or resultIfZero if subject is 0.
 *
 * Supports only 32-bit integers, so resultIfOne or resultIfZero are not
 * integers, they'll be converted to them with bitwise operations.
 */ function select(subject, resultIfOne, resultIfZero) {
    return ~(subject - 1) & resultIfOne | subject - 1 & resultIfZero;
}
exports.select = select;
/**
 * Returns 1 if a <= b, or 0 if not.
 * Arguments must be positive 32-bit integers less than or equal to 2^31 - 1.
 */ function lessOrEqual(a, b) {
    return (a | 0) - (b | 0) - 1 >>> 31 & 1;
}
exports.lessOrEqual = lessOrEqual;
/**
 * Returns 1 if a and b are of equal length and their contents
 * are equal, or 0 otherwise.
 *
 * Note that unlike in equal(), zero-length inputs are considered
 * the same, so this function will return 1.
 */ function compare(a, b) {
    if (a.length !== b.length) {
        return 0;
    }
    var result = 0;
    for(var i = 0; i < a.length; i++){
        result |= a[i] ^ b[i];
    }
    return 1 & result - 1 >>> 8;
}
exports.compare = compare;
/**
 * Returns true if a and b are of equal non-zero length,
 * and their contents are equal, or false otherwise.
 *
 * Note that unlike in compare() zero-length inputs are considered
 * _not_ equal, so this function will return false.
 */ function equal(a, b) {
    if (a.length === 0 || b.length === 0) {
        return false;
    }
    return compare(a, b) !== 0;
}
exports.equal = equal; //# sourceMappingURL=constant-time.js.map
}),
"[project]/node_modules/@stablelib/poly1305/lib/poly1305.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 * Package poly1305 implements Poly1305 one-time message authentication algorithm.
 */ var constant_time_1 = __turbopack_context__.r("[project]/node_modules/@stablelib/constant-time/lib/constant-time.js [app-client] (ecmascript)");
var wipe_1 = __turbopack_context__.r("[project]/node_modules/@stablelib/wipe/lib/wipe.js [app-client] (ecmascript)");
exports.DIGEST_LENGTH = 16;
// Port of Andrew Moon's Poly1305-donna-16. Public domain.
// https://github.com/floodyberry/poly1305-donna
/**
 * Poly1305 computes 16-byte authenticator of message using
 * a one-time 32-byte key.
 *
 * Important: key should be used for only one message,
 * it should never repeat.
 */ var Poly1305 = function() {
    function Poly1305(key) {
        this.digestLength = exports.DIGEST_LENGTH;
        this._buffer = new Uint8Array(16);
        this._r = new Uint16Array(10);
        this._h = new Uint16Array(10);
        this._pad = new Uint16Array(8);
        this._leftover = 0;
        this._fin = 0;
        this._finished = false;
        var t0 = key[0] | key[1] << 8;
        this._r[0] = t0 & 0x1fff;
        var t1 = key[2] | key[3] << 8;
        this._r[1] = (t0 >>> 13 | t1 << 3) & 0x1fff;
        var t2 = key[4] | key[5] << 8;
        this._r[2] = (t1 >>> 10 | t2 << 6) & 0x1f03;
        var t3 = key[6] | key[7] << 8;
        this._r[3] = (t2 >>> 7 | t3 << 9) & 0x1fff;
        var t4 = key[8] | key[9] << 8;
        this._r[4] = (t3 >>> 4 | t4 << 12) & 0x00ff;
        this._r[5] = t4 >>> 1 & 0x1ffe;
        var t5 = key[10] | key[11] << 8;
        this._r[6] = (t4 >>> 14 | t5 << 2) & 0x1fff;
        var t6 = key[12] | key[13] << 8;
        this._r[7] = (t5 >>> 11 | t6 << 5) & 0x1f81;
        var t7 = key[14] | key[15] << 8;
        this._r[8] = (t6 >>> 8 | t7 << 8) & 0x1fff;
        this._r[9] = t7 >>> 5 & 0x007f;
        this._pad[0] = key[16] | key[17] << 8;
        this._pad[1] = key[18] | key[19] << 8;
        this._pad[2] = key[20] | key[21] << 8;
        this._pad[3] = key[22] | key[23] << 8;
        this._pad[4] = key[24] | key[25] << 8;
        this._pad[5] = key[26] | key[27] << 8;
        this._pad[6] = key[28] | key[29] << 8;
        this._pad[7] = key[30] | key[31] << 8;
    }
    Poly1305.prototype._blocks = function(m, mpos, bytes) {
        var hibit = this._fin ? 0 : 1 << 11;
        var h0 = this._h[0], h1 = this._h[1], h2 = this._h[2], h3 = this._h[3], h4 = this._h[4], h5 = this._h[5], h6 = this._h[6], h7 = this._h[7], h8 = this._h[8], h9 = this._h[9];
        var r0 = this._r[0], r1 = this._r[1], r2 = this._r[2], r3 = this._r[3], r4 = this._r[4], r5 = this._r[5], r6 = this._r[6], r7 = this._r[7], r8 = this._r[8], r9 = this._r[9];
        while(bytes >= 16){
            var t0 = m[mpos + 0] | m[mpos + 1] << 8;
            h0 += t0 & 0x1fff;
            var t1 = m[mpos + 2] | m[mpos + 3] << 8;
            h1 += (t0 >>> 13 | t1 << 3) & 0x1fff;
            var t2 = m[mpos + 4] | m[mpos + 5] << 8;
            h2 += (t1 >>> 10 | t2 << 6) & 0x1fff;
            var t3 = m[mpos + 6] | m[mpos + 7] << 8;
            h3 += (t2 >>> 7 | t3 << 9) & 0x1fff;
            var t4 = m[mpos + 8] | m[mpos + 9] << 8;
            h4 += (t3 >>> 4 | t4 << 12) & 0x1fff;
            h5 += t4 >>> 1 & 0x1fff;
            var t5 = m[mpos + 10] | m[mpos + 11] << 8;
            h6 += (t4 >>> 14 | t5 << 2) & 0x1fff;
            var t6 = m[mpos + 12] | m[mpos + 13] << 8;
            h7 += (t5 >>> 11 | t6 << 5) & 0x1fff;
            var t7 = m[mpos + 14] | m[mpos + 15] << 8;
            h8 += (t6 >>> 8 | t7 << 8) & 0x1fff;
            h9 += t7 >>> 5 | hibit;
            var c = 0;
            var d0 = c;
            d0 += h0 * r0;
            d0 += h1 * (5 * r9);
            d0 += h2 * (5 * r8);
            d0 += h3 * (5 * r7);
            d0 += h4 * (5 * r6);
            c = d0 >>> 13;
            d0 &= 0x1fff;
            d0 += h5 * (5 * r5);
            d0 += h6 * (5 * r4);
            d0 += h7 * (5 * r3);
            d0 += h8 * (5 * r2);
            d0 += h9 * (5 * r1);
            c += d0 >>> 13;
            d0 &= 0x1fff;
            var d1 = c;
            d1 += h0 * r1;
            d1 += h1 * r0;
            d1 += h2 * (5 * r9);
            d1 += h3 * (5 * r8);
            d1 += h4 * (5 * r7);
            c = d1 >>> 13;
            d1 &= 0x1fff;
            d1 += h5 * (5 * r6);
            d1 += h6 * (5 * r5);
            d1 += h7 * (5 * r4);
            d1 += h8 * (5 * r3);
            d1 += h9 * (5 * r2);
            c += d1 >>> 13;
            d1 &= 0x1fff;
            var d2 = c;
            d2 += h0 * r2;
            d2 += h1 * r1;
            d2 += h2 * r0;
            d2 += h3 * (5 * r9);
            d2 += h4 * (5 * r8);
            c = d2 >>> 13;
            d2 &= 0x1fff;
            d2 += h5 * (5 * r7);
            d2 += h6 * (5 * r6);
            d2 += h7 * (5 * r5);
            d2 += h8 * (5 * r4);
            d2 += h9 * (5 * r3);
            c += d2 >>> 13;
            d2 &= 0x1fff;
            var d3 = c;
            d3 += h0 * r3;
            d3 += h1 * r2;
            d3 += h2 * r1;
            d3 += h3 * r0;
            d3 += h4 * (5 * r9);
            c = d3 >>> 13;
            d3 &= 0x1fff;
            d3 += h5 * (5 * r8);
            d3 += h6 * (5 * r7);
            d3 += h7 * (5 * r6);
            d3 += h8 * (5 * r5);
            d3 += h9 * (5 * r4);
            c += d3 >>> 13;
            d3 &= 0x1fff;
            var d4 = c;
            d4 += h0 * r4;
            d4 += h1 * r3;
            d4 += h2 * r2;
            d4 += h3 * r1;
            d4 += h4 * r0;
            c = d4 >>> 13;
            d4 &= 0x1fff;
            d4 += h5 * (5 * r9);
            d4 += h6 * (5 * r8);
            d4 += h7 * (5 * r7);
            d4 += h8 * (5 * r6);
            d4 += h9 * (5 * r5);
            c += d4 >>> 13;
            d4 &= 0x1fff;
            var d5 = c;
            d5 += h0 * r5;
            d5 += h1 * r4;
            d5 += h2 * r3;
            d5 += h3 * r2;
            d5 += h4 * r1;
            c = d5 >>> 13;
            d5 &= 0x1fff;
            d5 += h5 * r0;
            d5 += h6 * (5 * r9);
            d5 += h7 * (5 * r8);
            d5 += h8 * (5 * r7);
            d5 += h9 * (5 * r6);
            c += d5 >>> 13;
            d5 &= 0x1fff;
            var d6 = c;
            d6 += h0 * r6;
            d6 += h1 * r5;
            d6 += h2 * r4;
            d6 += h3 * r3;
            d6 += h4 * r2;
            c = d6 >>> 13;
            d6 &= 0x1fff;
            d6 += h5 * r1;
            d6 += h6 * r0;
            d6 += h7 * (5 * r9);
            d6 += h8 * (5 * r8);
            d6 += h9 * (5 * r7);
            c += d6 >>> 13;
            d6 &= 0x1fff;
            var d7 = c;
            d7 += h0 * r7;
            d7 += h1 * r6;
            d7 += h2 * r5;
            d7 += h3 * r4;
            d7 += h4 * r3;
            c = d7 >>> 13;
            d7 &= 0x1fff;
            d7 += h5 * r2;
            d7 += h6 * r1;
            d7 += h7 * r0;
            d7 += h8 * (5 * r9);
            d7 += h9 * (5 * r8);
            c += d7 >>> 13;
            d7 &= 0x1fff;
            var d8 = c;
            d8 += h0 * r8;
            d8 += h1 * r7;
            d8 += h2 * r6;
            d8 += h3 * r5;
            d8 += h4 * r4;
            c = d8 >>> 13;
            d8 &= 0x1fff;
            d8 += h5 * r3;
            d8 += h6 * r2;
            d8 += h7 * r1;
            d8 += h8 * r0;
            d8 += h9 * (5 * r9);
            c += d8 >>> 13;
            d8 &= 0x1fff;
            var d9 = c;
            d9 += h0 * r9;
            d9 += h1 * r8;
            d9 += h2 * r7;
            d9 += h3 * r6;
            d9 += h4 * r5;
            c = d9 >>> 13;
            d9 &= 0x1fff;
            d9 += h5 * r4;
            d9 += h6 * r3;
            d9 += h7 * r2;
            d9 += h8 * r1;
            d9 += h9 * r0;
            c += d9 >>> 13;
            d9 &= 0x1fff;
            c = (c << 2) + c | 0;
            c = c + d0 | 0;
            d0 = c & 0x1fff;
            c = c >>> 13;
            d1 += c;
            h0 = d0;
            h1 = d1;
            h2 = d2;
            h3 = d3;
            h4 = d4;
            h5 = d5;
            h6 = d6;
            h7 = d7;
            h8 = d8;
            h9 = d9;
            mpos += 16;
            bytes -= 16;
        }
        this._h[0] = h0;
        this._h[1] = h1;
        this._h[2] = h2;
        this._h[3] = h3;
        this._h[4] = h4;
        this._h[5] = h5;
        this._h[6] = h6;
        this._h[7] = h7;
        this._h[8] = h8;
        this._h[9] = h9;
    };
    Poly1305.prototype.finish = function(mac, macpos) {
        if (macpos === void 0) {
            macpos = 0;
        }
        var g = new Uint16Array(10);
        var c;
        var mask;
        var f;
        var i;
        if (this._leftover) {
            i = this._leftover;
            this._buffer[i++] = 1;
            for(; i < 16; i++){
                this._buffer[i] = 0;
            }
            this._fin = 1;
            this._blocks(this._buffer, 0, 16);
        }
        c = this._h[1] >>> 13;
        this._h[1] &= 0x1fff;
        for(i = 2; i < 10; i++){
            this._h[i] += c;
            c = this._h[i] >>> 13;
            this._h[i] &= 0x1fff;
        }
        this._h[0] += c * 5;
        c = this._h[0] >>> 13;
        this._h[0] &= 0x1fff;
        this._h[1] += c;
        c = this._h[1] >>> 13;
        this._h[1] &= 0x1fff;
        this._h[2] += c;
        g[0] = this._h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 0x1fff;
        for(i = 1; i < 10; i++){
            g[i] = this._h[i] + c;
            c = g[i] >>> 13;
            g[i] &= 0x1fff;
        }
        g[9] -= 1 << 13;
        mask = (c ^ 1) - 1;
        for(i = 0; i < 10; i++){
            g[i] &= mask;
        }
        mask = ~mask;
        for(i = 0; i < 10; i++){
            this._h[i] = this._h[i] & mask | g[i];
        }
        this._h[0] = (this._h[0] | this._h[1] << 13) & 0xffff;
        this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 0xffff;
        this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 0xffff;
        this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 0xffff;
        this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 0xffff;
        this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 0xffff;
        this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 0xffff;
        this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 0xffff;
        f = this._h[0] + this._pad[0];
        this._h[0] = f & 0xffff;
        for(i = 1; i < 8; i++){
            f = (this._h[i] + this._pad[i] | 0) + (f >>> 16) | 0;
            this._h[i] = f & 0xffff;
        }
        mac[macpos + 0] = this._h[0] >>> 0;
        mac[macpos + 1] = this._h[0] >>> 8;
        mac[macpos + 2] = this._h[1] >>> 0;
        mac[macpos + 3] = this._h[1] >>> 8;
        mac[macpos + 4] = this._h[2] >>> 0;
        mac[macpos + 5] = this._h[2] >>> 8;
        mac[macpos + 6] = this._h[3] >>> 0;
        mac[macpos + 7] = this._h[3] >>> 8;
        mac[macpos + 8] = this._h[4] >>> 0;
        mac[macpos + 9] = this._h[4] >>> 8;
        mac[macpos + 10] = this._h[5] >>> 0;
        mac[macpos + 11] = this._h[5] >>> 8;
        mac[macpos + 12] = this._h[6] >>> 0;
        mac[macpos + 13] = this._h[6] >>> 8;
        mac[macpos + 14] = this._h[7] >>> 0;
        mac[macpos + 15] = this._h[7] >>> 8;
        this._finished = true;
        return this;
    };
    Poly1305.prototype.update = function(m) {
        var mpos = 0;
        var bytes = m.length;
        var want;
        if (this._leftover) {
            want = 16 - this._leftover;
            if (want > bytes) {
                want = bytes;
            }
            for(var i = 0; i < want; i++){
                this._buffer[this._leftover + i] = m[mpos + i];
            }
            bytes -= want;
            mpos += want;
            this._leftover += want;
            if (this._leftover < 16) {
                return this;
            }
            this._blocks(this._buffer, 0, 16);
            this._leftover = 0;
        }
        if (bytes >= 16) {
            want = bytes - bytes % 16;
            this._blocks(m, mpos, want);
            mpos += want;
            bytes -= want;
        }
        if (bytes) {
            for(var i = 0; i < bytes; i++){
                this._buffer[this._leftover + i] = m[mpos + i];
            }
            this._leftover += bytes;
        }
        return this;
    };
    Poly1305.prototype.digest = function() {
        // TODO(dchest): it behaves differently than other hashes/HMAC,
        // because it throws when finished  others just return saved result.
        if (this._finished) {
            throw new Error("Poly1305 was finished");
        }
        var mac = new Uint8Array(16);
        this.finish(mac);
        return mac;
    };
    Poly1305.prototype.clean = function() {
        wipe_1.wipe(this._buffer);
        wipe_1.wipe(this._r);
        wipe_1.wipe(this._h);
        wipe_1.wipe(this._pad);
        this._leftover = 0;
        this._fin = 0;
        this._finished = true; // mark as finished even if not
        return this;
    };
    return Poly1305;
}();
exports.Poly1305 = Poly1305;
/**
 * Returns 16-byte authenticator of data using a one-time 32-byte key.
 *
 * Important: key should be used for only one message, it should never repeat.
 */ function oneTimeAuth(key, data) {
    var h = new Poly1305(key);
    h.update(data);
    var digest = h.digest();
    h.clean();
    return digest;
}
exports.oneTimeAuth = oneTimeAuth;
/**
 * Returns true if two authenticators are 16-byte long and equal.
 * Uses contant-time comparison to avoid leaking timing information.
 */ function equal(a, b) {
    if (a.length !== exports.DIGEST_LENGTH || b.length !== exports.DIGEST_LENGTH) {
        return false;
    }
    return constant_time_1.equal(a, b);
}
exports.equal = equal; //# sourceMappingURL=poly1305.js.map
}),
"[project]/node_modules/@stablelib/chacha20poly1305/lib/chacha20poly1305.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
var chacha_1 = __turbopack_context__.r("[project]/node_modules/@stablelib/chacha/lib/chacha.js [app-client] (ecmascript)");
var poly1305_1 = __turbopack_context__.r("[project]/node_modules/@stablelib/poly1305/lib/poly1305.js [app-client] (ecmascript)");
var wipe_1 = __turbopack_context__.r("[project]/node_modules/@stablelib/wipe/lib/wipe.js [app-client] (ecmascript)");
var binary_1 = __turbopack_context__.r("[project]/node_modules/@stablelib/binary/lib/binary.js [app-client] (ecmascript)");
var constant_time_1 = __turbopack_context__.r("[project]/node_modules/@stablelib/constant-time/lib/constant-time.js [app-client] (ecmascript)");
exports.KEY_LENGTH = 32;
exports.NONCE_LENGTH = 12;
exports.TAG_LENGTH = 16;
var ZEROS = new Uint8Array(16);
/**
 * ChaCha20-Poly1305 Authenticated Encryption with Associated Data.
 *
 * Defined in RFC7539.
 */ var ChaCha20Poly1305 = function() {
    /**
     * Creates a new instance with the given 32-byte key.
     */ function ChaCha20Poly1305(key) {
        this.nonceLength = exports.NONCE_LENGTH;
        this.tagLength = exports.TAG_LENGTH;
        if (key.length !== exports.KEY_LENGTH) {
            throw new Error("ChaCha20Poly1305 needs 32-byte key");
        }
        // Copy key.
        this._key = new Uint8Array(key);
    }
    /**
     * Encrypts and authenticates plaintext, authenticates associated data,
     * and returns sealed ciphertext, which includes authentication tag.
     *
     * RFC7539 specifies 12 bytes for nonce. It may be this 12-byte nonce
     * ("IV"), or full 16-byte counter (called "32-bit fixed-common part")
     * and nonce.
     *
     * If dst is given (it must be the size of plaintext + the size of tag
     * length) the result will be put into it. Dst and plaintext must not
     * overlap.
     */ ChaCha20Poly1305.prototype.seal = function(nonce, plaintext, associatedData, dst) {
        if (nonce.length > 16) {
            throw new Error("ChaCha20Poly1305: incorrect nonce length");
        }
        // Allocate space for counter, and set nonce as last bytes of it.
        var counter = new Uint8Array(16);
        counter.set(nonce, counter.length - nonce.length);
        // Generate authentication key by taking first 32-bytes of stream.
        // We pass full counter, which has 12-byte nonce and 4-byte block counter,
        // and it will get incremented after generating the block, which is
        // exactly what we need: we only use the first 32 bytes of 64-byte
        // ChaCha block and discard the next 32 bytes.
        var authKey = new Uint8Array(32);
        chacha_1.stream(this._key, counter, authKey, 4);
        // Allocate space for sealed ciphertext.
        var resultLength = plaintext.length + this.tagLength;
        var result;
        if (dst) {
            if (dst.length !== resultLength) {
                throw new Error("ChaCha20Poly1305: incorrect destination length");
            }
            result = dst;
        } else {
            result = new Uint8Array(resultLength);
        }
        // Encrypt plaintext.
        chacha_1.streamXOR(this._key, counter, plaintext, result, 4);
        // Authenticate.
        // XXX: can "simplify" here: pass full result (which is already padded
        // due to zeroes prepared for tag), and ciphertext length instead of
        // subarray of result.
        this._authenticate(result.subarray(result.length - this.tagLength, result.length), authKey, result.subarray(0, result.length - this.tagLength), associatedData);
        // Cleanup.
        wipe_1.wipe(counter);
        return result;
    };
    /**
     * Authenticates sealed ciphertext (which includes authentication tag) and
     * associated data, decrypts ciphertext and returns decrypted plaintext.
     *
     * RFC7539 specifies 12 bytes for nonce. It may be this 12-byte nonce
     * ("IV"), or full 16-byte counter (called "32-bit fixed-common part")
     * and nonce.
     *
     * If authentication fails, it returns null.
     *
     * If dst is given (it must be of ciphertext length minus tag length),
     * the result will be put into it. Dst and plaintext must not overlap.
     */ ChaCha20Poly1305.prototype.open = function(nonce, sealed, associatedData, dst) {
        if (nonce.length > 16) {
            throw new Error("ChaCha20Poly1305: incorrect nonce length");
        }
        // Sealed ciphertext should at least contain tag.
        if (sealed.length < this.tagLength) {
            // TODO(dchest): should we throw here instead?
            return null;
        }
        // Allocate space for counter, and set nonce as last bytes of it.
        var counter = new Uint8Array(16);
        counter.set(nonce, counter.length - nonce.length);
        // Generate authentication key by taking first 32-bytes of stream.
        var authKey = new Uint8Array(32);
        chacha_1.stream(this._key, counter, authKey, 4);
        // Authenticate.
        // XXX: can simplify and avoid allocation: since authenticate()
        // already allocates tag (from Poly1305.digest(), it can return)
        // it instead of copying to calculatedTag. But then in seal()
        // we'll need to copy it.
        var calculatedTag = new Uint8Array(this.tagLength);
        this._authenticate(calculatedTag, authKey, sealed.subarray(0, sealed.length - this.tagLength), associatedData);
        // Constant-time compare tags and return null if they differ.
        if (!constant_time_1.equal(calculatedTag, sealed.subarray(sealed.length - this.tagLength, sealed.length))) {
            return null;
        }
        // Allocate space for decrypted plaintext.
        var resultLength = sealed.length - this.tagLength;
        var result;
        if (dst) {
            if (dst.length !== resultLength) {
                throw new Error("ChaCha20Poly1305: incorrect destination length");
            }
            result = dst;
        } else {
            result = new Uint8Array(resultLength);
        }
        // Decrypt.
        chacha_1.streamXOR(this._key, counter, sealed.subarray(0, sealed.length - this.tagLength), result, 4);
        // Cleanup.
        wipe_1.wipe(counter);
        return result;
    };
    ChaCha20Poly1305.prototype.clean = function() {
        wipe_1.wipe(this._key);
        return this;
    };
    ChaCha20Poly1305.prototype._authenticate = function(tagOut, authKey, ciphertext, associatedData) {
        // Initialize Poly1305 with authKey.
        var h = new poly1305_1.Poly1305(authKey);
        // Authenticate padded associated data.
        if (associatedData) {
            h.update(associatedData);
            if (associatedData.length % 16 > 0) {
                h.update(ZEROS.subarray(associatedData.length % 16));
            }
        }
        // Authenticate padded ciphertext.
        h.update(ciphertext);
        if (ciphertext.length % 16 > 0) {
            h.update(ZEROS.subarray(ciphertext.length % 16));
        }
        // Authenticate length of associated data.
        // XXX: can avoid allocation here?
        var length = new Uint8Array(8);
        if (associatedData) {
            binary_1.writeUint64LE(associatedData.length, length);
        }
        h.update(length);
        // Authenticate length of ciphertext.
        binary_1.writeUint64LE(ciphertext.length, length);
        h.update(length);
        // Get tag and copy it into tagOut.
        var tag = h.digest();
        for(var i = 0; i < tag.length; i++){
            tagOut[i] = tag[i];
        }
        // Cleanup.
        h.clean();
        wipe_1.wipe(tag);
        wipe_1.wipe(length);
    };
    return ChaCha20Poly1305;
}();
exports.ChaCha20Poly1305 = ChaCha20Poly1305; //# sourceMappingURL=chacha20poly1305.js.map
}),
"[project]/node_modules/@stablelib/hash/lib/hash.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
function isSerializableHash(h) {
    return typeof h.saveState !== "undefined" && typeof h.restoreState !== "undefined" && typeof h.cleanSavedState !== "undefined";
}
exports.isSerializableHash = isSerializableHash; // TODO(dchest): figure out the standardized interface for XOF such as
 // SHAKE and BLAKE2X.
 //# sourceMappingURL=hash.js.map
}),
"[project]/node_modules/@stablelib/hmac/lib/hmac.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
/**
 * Package hmac implements HMAC algorithm.
 */ var hash_1 = __turbopack_context__.r("[project]/node_modules/@stablelib/hash/lib/hash.js [app-client] (ecmascript)");
var constant_time_1 = __turbopack_context__.r("[project]/node_modules/@stablelib/constant-time/lib/constant-time.js [app-client] (ecmascript)");
var wipe_1 = __turbopack_context__.r("[project]/node_modules/@stablelib/wipe/lib/wipe.js [app-client] (ecmascript)");
/**
 *  HMAC implements hash-based message authentication algorithm.
 */ var HMAC = function() {
    /**
     * Constructs a new HMAC with the given Hash and secret key.
     */ function HMAC(hash, key) {
        this._finished = false; // true if HMAC was finalized
        // Initialize inner and outer hashes.
        this._inner = new hash();
        this._outer = new hash();
        // Set block and digest sizes for this HMAC
        // instance to values from the hash.
        this.blockSize = this._outer.blockSize;
        this.digestLength = this._outer.digestLength;
        // Pad temporary stores a key (or its hash) padded with zeroes.
        var pad = new Uint8Array(this.blockSize);
        if (key.length > this.blockSize) {
            // If key is bigger than hash block size, it must be
            // hashed and this hash is used as a key instead.
            this._inner.update(key).finish(pad).clean();
        } else {
            // Otherwise, copy the key into pad.
            pad.set(key);
        }
        // Now two different keys are derived from padded key
        // by xoring a different byte value to each.
        // To make inner hash key, xor byte 0x36 into pad.
        for(var i = 0; i < pad.length; i++){
            pad[i] ^= 0x36;
        }
        // Update inner hash with the result.
        this._inner.update(pad);
        // To make outer hash key, xor byte 0x5c into pad.
        // But since we already xored 0x36 there, we must
        // first undo this by xoring it again.
        for(var i = 0; i < pad.length; i++){
            pad[i] ^= 0x36 ^ 0x5c;
        }
        // Update outer hash with the result.
        this._outer.update(pad);
        // Save states of both hashes, so that we can quickly restore
        // them later in reset() without the need to remember the actual
        // key and perform this initialization again.
        if (hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer)) {
            this._innerKeyedState = this._inner.saveState();
            this._outerKeyedState = this._outer.saveState();
        }
        // Clean pad.
        wipe_1.wipe(pad);
    }
    /**
     * Returns HMAC state to the state initialized with key
     * to make it possible to run HMAC over the other data with the same
     * key without creating a new instance.
     */ HMAC.prototype.reset = function() {
        if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
            throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
        }
        // Restore keyed states of inner and outer hashes.
        this._inner.restoreState(this._innerKeyedState);
        this._outer.restoreState(this._outerKeyedState);
        this._finished = false;
        return this;
    };
    /**
     * Cleans HMAC state.
     */ HMAC.prototype.clean = function() {
        if (hash_1.isSerializableHash(this._inner)) {
            this._inner.cleanSavedState(this._innerKeyedState);
        }
        if (hash_1.isSerializableHash(this._outer)) {
            this._outer.cleanSavedState(this._outerKeyedState);
        }
        this._inner.clean();
        this._outer.clean();
    };
    /**
     * Updates state with provided data.
     */ HMAC.prototype.update = function(data) {
        this._inner.update(data);
        return this;
    };
    /**
     * Finalizes HMAC and puts the result in out.
     */ HMAC.prototype.finish = function(out) {
        if (this._finished) {
            // If HMAC was finalized, outer hash is also finalized,
            // so it produces the same digest it produced when it
            // was finalized.
            this._outer.finish(out);
            return this;
        }
        // Finalize inner hash and store the result temporarily.
        this._inner.finish(out);
        // Update outer hash with digest of inner hash and and finalize it.
        this._outer.update(out.subarray(0, this.digestLength)).finish(out);
        this._finished = true;
        return this;
    };
    /**
     * Returns the computed message authentication code.
     */ HMAC.prototype.digest = function() {
        var out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
    };
    /**
     * Saves HMAC state.
     * This function is needed for PBKDF2 optimization.
     */ HMAC.prototype.saveState = function() {
        if (!hash_1.isSerializableHash(this._inner)) {
            throw new Error("hmac: can't saveState() because hash doesn't implement it");
        }
        return this._inner.saveState();
    };
    HMAC.prototype.restoreState = function(savedState) {
        if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
            throw new Error("hmac: can't restoreState() because hash doesn't implement it");
        }
        this._inner.restoreState(savedState);
        this._outer.restoreState(this._outerKeyedState);
        this._finished = false;
        return this;
    };
    HMAC.prototype.cleanSavedState = function(savedState) {
        if (!hash_1.isSerializableHash(this._inner)) {
            throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
        }
        this._inner.cleanSavedState(savedState);
    };
    return HMAC;
}();
exports.HMAC = HMAC;
/**
 * Returns HMAC using the given hash constructor for the key over data.
 */ function hmac(hash, key, data) {
    var h = new HMAC(hash, key);
    h.update(data);
    var digest = h.digest();
    h.clean();
    return digest;
}
exports.hmac = hmac;
/**
 * Returns true if two HMAC digests are equal.
 * Uses constant-time comparison to avoid leaking timing information.
 *
 * Example:
 *
 *    const receivedDigest = ...
 *    const realDigest = hmac(SHA256, key, data);
 *    if (!equal(receivedDigest, realDigest)) {
 *        throw new Error("Authentication error");
 *    }
 */ exports.equal = constant_time_1.equal; //# sourceMappingURL=hmac.js.map
}),
"[project]/node_modules/@stablelib/hkdf/lib/hkdf.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
var hmac_1 = __turbopack_context__.r("[project]/node_modules/@stablelib/hmac/lib/hmac.js [app-client] (ecmascript)");
var wipe_1 = __turbopack_context__.r("[project]/node_modules/@stablelib/wipe/lib/wipe.js [app-client] (ecmascript)");
/**
 * HMAC-based Extract-and-Expand Key Derivation Function.
 *
 * Implements HKDF from RFC5869.
 *
 * Expands the given master key with salt and info into
 * a limited stream of key material.
 */ var HKDF = function() {
    /**
     * Create a new HKDF instance for the given hash function
     * with the master key, optional salt, and info.
     *
     * - Master key is a high-entropy secret key (not a password).
     * - Salt is a non-secret random value.
     * - Info is application- and/or context-specific information.
     */ function HKDF(hash, key, salt, info) {
        if (salt === void 0) {
            salt = new Uint8Array(0);
        }
        this._counter = new Uint8Array(1); // starts with zero
        this._hash = hash;
        this._info = info;
        // HKDF-Extract uses salt as HMAC key, and key as data.
        var okm = hmac_1.hmac(this._hash, salt, key);
        // Initialize HMAC for expanding with extracted key.
        this._hmac = new hmac_1.HMAC(hash, okm);
        // Allocate buffer.
        this._buffer = new Uint8Array(this._hmac.digestLength);
        this._bufpos = this._buffer.length;
    }
    // Fill buffer with new block of HKDF-Extract output.
    HKDF.prototype._fillBuffer = function() {
        // Increment counter.
        this._counter[0]++;
        var ctr = this._counter[0];
        // Check if counter overflowed.
        if (ctr === 0) {
            throw new Error("hkdf: cannot expand more");
        }
        // Prepare HMAC instance for new data with old key.
        this._hmac.reset();
        // Hash in previous output if it was generated
        // (i.e. counter is greater than 1).
        if (ctr > 1) {
            this._hmac.update(this._buffer);
        }
        // Hash in info if it exists.
        if (this._info) {
            this._hmac.update(this._info);
        }
        // Hash in the counter.
        this._hmac.update(this._counter);
        // Output result to buffer and clean HMAC instance.
        this._hmac.finish(this._buffer);
        // Reset buffer position.
        this._bufpos = 0;
    };
    /**
     * Expand returns next key material of the given length.
     *
     * It throws if expansion limit is reached (which is
     * 254 digests of the underlying HMAC function).
     */ HKDF.prototype.expand = function(length) {
        var out = new Uint8Array(length);
        for(var i = 0; i < out.length; i++){
            if (this._bufpos === this._buffer.length) {
                this._fillBuffer();
            }
            out[i] = this._buffer[this._bufpos++];
        }
        return out;
    };
    HKDF.prototype.clean = function() {
        this._hmac.clean();
        wipe_1.wipe(this._buffer);
        wipe_1.wipe(this._counter);
        this._bufpos = 0;
    };
    return HKDF;
}();
exports.HKDF = HKDF; // TODO(dchest): maybe implement deriveKey?
 //# sourceMappingURL=hkdf.js.map
}),
"[project]/node_modules/@stablelib/random/lib/source/browser.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BrowserRandomSource = void 0;
const QUOTA = 65536;
class BrowserRandomSource {
    constructor(){
        this.isAvailable = false;
        this.isInstantiated = false;
        const browserCrypto = typeof self !== 'undefined' ? self.crypto || self.msCrypto : null;
        if (browserCrypto && browserCrypto.getRandomValues !== undefined) {
            this._crypto = browserCrypto;
            this.isAvailable = true;
            this.isInstantiated = true;
        }
    }
    randomBytes(length) {
        if (!this.isAvailable || !this._crypto) {
            throw new Error("Browser random byte generator is not available.");
        }
        const out = new Uint8Array(length);
        for(let i = 0; i < out.length; i += QUOTA){
            this._crypto.getRandomValues(out.subarray(i, i + Math.min(out.length - i, QUOTA)));
        }
        return out;
    }
}
exports.BrowserRandomSource = BrowserRandomSource; //# sourceMappingURL=browser.js.map
}),
"[project]/node_modules/@stablelib/random/lib/source/node.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NodeRandomSource = void 0;
const wipe_1 = __turbopack_context__.r("[project]/node_modules/@stablelib/wipe/lib/wipe.js [app-client] (ecmascript)");
class NodeRandomSource {
    constructor(){
        this.isAvailable = false;
        this.isInstantiated = false;
        if ("TURBOPACK compile-time truthy", 1) {
            const nodeCrypto = {};
            if (nodeCrypto && nodeCrypto.randomBytes) {
                this._crypto = nodeCrypto;
                this.isAvailable = true;
                this.isInstantiated = true;
            }
        }
    }
    randomBytes(length) {
        if (!this.isAvailable || !this._crypto) {
            throw new Error("Node.js random byte generator is not available.");
        }
        // Get random bytes (result is Buffer).
        let buffer = this._crypto.randomBytes(length);
        // Make sure we got the length that we requested.
        if (buffer.length !== length) {
            throw new Error("NodeRandomSource: got fewer bytes than requested");
        }
        // Allocate output array.
        const out = new Uint8Array(length);
        // Copy bytes from buffer to output.
        for(let i = 0; i < out.length; i++){
            out[i] = buffer[i];
        }
        // Cleanup.
        (0, wipe_1.wipe)(buffer);
        return out;
    }
}
exports.NodeRandomSource = NodeRandomSource; //# sourceMappingURL=node.js.map
}),
"[project]/node_modules/@stablelib/random/lib/source/system.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SystemRandomSource = void 0;
const browser_1 = __turbopack_context__.r("[project]/node_modules/@stablelib/random/lib/source/browser.js [app-client] (ecmascript)");
const node_1 = __turbopack_context__.r("[project]/node_modules/@stablelib/random/lib/source/node.js [app-client] (ecmascript)");
class SystemRandomSource {
    constructor(){
        this.isAvailable = false;
        this.name = "";
        // Try browser.
        this._source = new browser_1.BrowserRandomSource();
        if (this._source.isAvailable) {
            this.isAvailable = true;
            this.name = "Browser";
            return;
        }
        // If no browser source, try Node.
        this._source = new node_1.NodeRandomSource();
        if (this._source.isAvailable) {
            this.isAvailable = true;
            this.name = "Node";
            return;
        }
    // No sources, we're out of options.
    }
    randomBytes(length) {
        if (!this.isAvailable) {
            throw new Error("System random byte generator is not available.");
        }
        return this._source.randomBytes(length);
    }
}
exports.SystemRandomSource = SystemRandomSource; //# sourceMappingURL=system.js.map
}),
"[project]/node_modules/@stablelib/random/lib/random.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.randomStringForEntropy = exports.randomString = exports.randomUint32 = exports.randomBytes = exports.defaultRandomSource = void 0;
const system_1 = __turbopack_context__.r("[project]/node_modules/@stablelib/random/lib/source/system.js [app-client] (ecmascript)");
const binary_1 = __turbopack_context__.r("[project]/node_modules/@stablelib/binary/lib/binary.js [app-client] (ecmascript)");
const wipe_1 = __turbopack_context__.r("[project]/node_modules/@stablelib/wipe/lib/wipe.js [app-client] (ecmascript)");
exports.defaultRandomSource = new system_1.SystemRandomSource();
function randomBytes(length, prng = exports.defaultRandomSource) {
    return prng.randomBytes(length);
}
exports.randomBytes = randomBytes;
/**
 * Returns a uniformly random unsigned 32-bit integer.
 */ function randomUint32(prng = exports.defaultRandomSource) {
    // Generate 4-byte random buffer.
    const buf = randomBytes(4, prng);
    // Convert bytes from buffer into a 32-bit integer.
    // It's not important which byte order to use, since
    // the result is random.
    const result = (0, binary_1.readUint32LE)(buf);
    // Clean the buffer.
    (0, wipe_1.wipe)(buf);
    return result;
}
exports.randomUint32 = randomUint32;
/** 62 alphanumeric characters for default charset of randomString() */ const ALPHANUMERIC = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
/**
 * Returns a uniform random string of the given length
 * with characters from the given charset.
 *
 * Charset must not have more than 256 characters.
 *
 * Default charset generates case-sensitive alphanumeric
 * strings (0-9, A-Z, a-z).
 */ function randomString(length, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
    if (charset.length < 2) {
        throw new Error("randomString charset is too short");
    }
    if (charset.length > 256) {
        throw new Error("randomString charset is too long");
    }
    let out = '';
    const charsLen = charset.length;
    const maxByte = 256 - 256 % charsLen;
    while(length > 0){
        const buf = randomBytes(Math.ceil(length * 256 / maxByte), prng);
        for(let i = 0; i < buf.length && length > 0; i++){
            const randomByte = buf[i];
            if (randomByte < maxByte) {
                out += charset.charAt(randomByte % charsLen);
                length--;
            }
        }
        (0, wipe_1.wipe)(buf);
    }
    return out;
}
exports.randomString = randomString;
/**
 * Returns uniform random string containing at least the given
 * number of bits of entropy.
 *
 * For example, randomStringForEntropy(128) will return a 22-character
 * alphanumeric string, while randomStringForEntropy(128, "0123456789")
 * will return a 39-character numeric string, both will contain at
 * least 128 bits of entropy.
 *
 * Default charset generates case-sensitive alphanumeric
 * strings (0-9, A-Z, a-z).
 */ function randomStringForEntropy(bits, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
    const length = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));
    return randomString(length, charset, prng);
}
exports.randomStringForEntropy = randomStringForEntropy; //# sourceMappingURL=random.js.map
}),
"[project]/node_modules/@stablelib/sha256/lib/sha256.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
var binary_1 = __turbopack_context__.r("[project]/node_modules/@stablelib/binary/lib/binary.js [app-client] (ecmascript)");
var wipe_1 = __turbopack_context__.r("[project]/node_modules/@stablelib/wipe/lib/wipe.js [app-client] (ecmascript)");
exports.DIGEST_LENGTH = 32;
exports.BLOCK_SIZE = 64;
/**
 * SHA2-256 cryptographic hash algorithm.
 */ var SHA256 = function() {
    function SHA256() {
        /** Length of hash output */ this.digestLength = exports.DIGEST_LENGTH;
        /** Block size */ this.blockSize = exports.BLOCK_SIZE;
        // Note: Int32Array is used instead of Uint32Array for performance reasons.
        this._state = new Int32Array(8); // hash state
        this._temp = new Int32Array(64); // temporary state
        this._buffer = new Uint8Array(128); // buffer for data to hash
        this._bufferLength = 0; // number of bytes in buffer
        this._bytesHashed = 0; // number of total bytes hashed
        this._finished = false; // indicates whether the hash was finalized
        this.reset();
    }
    SHA256.prototype._initState = function() {
        this._state[0] = 0x6a09e667;
        this._state[1] = 0xbb67ae85;
        this._state[2] = 0x3c6ef372;
        this._state[3] = 0xa54ff53a;
        this._state[4] = 0x510e527f;
        this._state[5] = 0x9b05688c;
        this._state[6] = 0x1f83d9ab;
        this._state[7] = 0x5be0cd19;
    };
    /**
     * Resets hash state making it possible
     * to re-use this instance to hash other data.
     */ SHA256.prototype.reset = function() {
        this._initState();
        this._bufferLength = 0;
        this._bytesHashed = 0;
        this._finished = false;
        return this;
    };
    /**
     * Cleans internal buffers and resets hash state.
     */ SHA256.prototype.clean = function() {
        wipe_1.wipe(this._buffer);
        wipe_1.wipe(this._temp);
        this.reset();
    };
    /**
     * Updates hash state with the given data.
     *
     * Throws error when trying to update already finalized hash:
     * instance must be reset to update it again.
     */ SHA256.prototype.update = function(data, dataLength) {
        if (dataLength === void 0) {
            dataLength = data.length;
        }
        if (this._finished) {
            throw new Error("SHA256: can't update because hash was finished.");
        }
        var dataPos = 0;
        this._bytesHashed += dataLength;
        if (this._bufferLength > 0) {
            while(this._bufferLength < this.blockSize && dataLength > 0){
                this._buffer[this._bufferLength++] = data[dataPos++];
                dataLength--;
            }
            if (this._bufferLength === this.blockSize) {
                hashBlocks(this._temp, this._state, this._buffer, 0, this.blockSize);
                this._bufferLength = 0;
            }
        }
        if (dataLength >= this.blockSize) {
            dataPos = hashBlocks(this._temp, this._state, data, dataPos, dataLength);
            dataLength %= this.blockSize;
        }
        while(dataLength > 0){
            this._buffer[this._bufferLength++] = data[dataPos++];
            dataLength--;
        }
        return this;
    };
    /**
     * Finalizes hash state and puts hash into out.
     * If hash was already finalized, puts the same value.
     */ SHA256.prototype.finish = function(out) {
        if (!this._finished) {
            var bytesHashed = this._bytesHashed;
            var left = this._bufferLength;
            var bitLenHi = bytesHashed / 0x20000000 | 0;
            var bitLenLo = bytesHashed << 3;
            var padLength = bytesHashed % 64 < 56 ? 64 : 128;
            this._buffer[left] = 0x80;
            for(var i = left + 1; i < padLength - 8; i++){
                this._buffer[i] = 0;
            }
            binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
            binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
            hashBlocks(this._temp, this._state, this._buffer, 0, padLength);
            this._finished = true;
        }
        for(var i = 0; i < this.digestLength / 4; i++){
            binary_1.writeUint32BE(this._state[i], out, i * 4);
        }
        return this;
    };
    /**
     * Returns the final hash digest.
     */ SHA256.prototype.digest = function() {
        var out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
    };
    /**
     * Function useful for HMAC/PBKDF2 optimization.
     * Returns hash state to be used with restoreState().
     * Only chain value is saved, not buffers or other
     * state variables.
     */ SHA256.prototype.saveState = function() {
        if (this._finished) {
            throw new Error("SHA256: cannot save finished state");
        }
        return {
            state: new Int32Array(this._state),
            buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : undefined,
            bufferLength: this._bufferLength,
            bytesHashed: this._bytesHashed
        };
    };
    /**
     * Function useful for HMAC/PBKDF2 optimization.
     * Restores state saved by saveState() and sets bytesHashed
     * to the given value.
     */ SHA256.prototype.restoreState = function(savedState) {
        this._state.set(savedState.state);
        this._bufferLength = savedState.bufferLength;
        if (savedState.buffer) {
            this._buffer.set(savedState.buffer);
        }
        this._bytesHashed = savedState.bytesHashed;
        this._finished = false;
        return this;
    };
    /**
     * Cleans state returned by saveState().
     */ SHA256.prototype.cleanSavedState = function(savedState) {
        wipe_1.wipe(savedState.state);
        if (savedState.buffer) {
            wipe_1.wipe(savedState.buffer);
        }
        savedState.bufferLength = 0;
        savedState.bytesHashed = 0;
    };
    return SHA256;
}();
exports.SHA256 = SHA256;
// Constants
var K = new Int32Array([
    0x428a2f98,
    0x71374491,
    0xb5c0fbcf,
    0xe9b5dba5,
    0x3956c25b,
    0x59f111f1,
    0x923f82a4,
    0xab1c5ed5,
    0xd807aa98,
    0x12835b01,
    0x243185be,
    0x550c7dc3,
    0x72be5d74,
    0x80deb1fe,
    0x9bdc06a7,
    0xc19bf174,
    0xe49b69c1,
    0xefbe4786,
    0x0fc19dc6,
    0x240ca1cc,
    0x2de92c6f,
    0x4a7484aa,
    0x5cb0a9dc,
    0x76f988da,
    0x983e5152,
    0xa831c66d,
    0xb00327c8,
    0xbf597fc7,
    0xc6e00bf3,
    0xd5a79147,
    0x06ca6351,
    0x14292967,
    0x27b70a85,
    0x2e1b2138,
    0x4d2c6dfc,
    0x53380d13,
    0x650a7354,
    0x766a0abb,
    0x81c2c92e,
    0x92722c85,
    0xa2bfe8a1,
    0xa81a664b,
    0xc24b8b70,
    0xc76c51a3,
    0xd192e819,
    0xd6990624,
    0xf40e3585,
    0x106aa070,
    0x19a4c116,
    0x1e376c08,
    0x2748774c,
    0x34b0bcb5,
    0x391c0cb3,
    0x4ed8aa4a,
    0x5b9cca4f,
    0x682e6ff3,
    0x748f82ee,
    0x78a5636f,
    0x84c87814,
    0x8cc70208,
    0x90befffa,
    0xa4506ceb,
    0xbef9a3f7,
    0xc67178f2
]);
function hashBlocks(w, v, p, pos, len) {
    while(len >= 64){
        var a = v[0];
        var b = v[1];
        var c = v[2];
        var d = v[3];
        var e = v[4];
        var f = v[5];
        var g = v[6];
        var h = v[7];
        for(var i = 0; i < 16; i++){
            var j = pos + i * 4;
            w[i] = binary_1.readUint32BE(p, j);
        }
        for(var i = 16; i < 64; i++){
            var u = w[i - 2];
            var t1 = (u >>> 17 | u << 32 - 17) ^ (u >>> 19 | u << 32 - 19) ^ u >>> 10;
            u = w[i - 15];
            var t2 = (u >>> 7 | u << 32 - 7) ^ (u >>> 18 | u << 32 - 18) ^ u >>> 3;
            w[i] = (t1 + w[i - 7] | 0) + (t2 + w[i - 16] | 0);
        }
        for(var i = 0; i < 64; i++){
            var t1 = (((e >>> 6 | e << 32 - 6) ^ (e >>> 11 | e << 32 - 11) ^ (e >>> 25 | e << 32 - 25)) + (e & f ^ ~e & g) | 0) + (h + (K[i] + w[i] | 0) | 0) | 0;
            var t2 = ((a >>> 2 | a << 32 - 2) ^ (a >>> 13 | a << 32 - 13) ^ (a >>> 22 | a << 32 - 22)) + (a & b ^ a & c ^ b & c) | 0;
            h = g;
            g = f;
            f = e;
            e = d + t1 | 0;
            d = c;
            c = b;
            b = a;
            a = t1 + t2 | 0;
        }
        v[0] += a;
        v[1] += b;
        v[2] += c;
        v[3] += d;
        v[4] += e;
        v[5] += f;
        v[6] += g;
        v[7] += h;
        pos += 64;
        len -= 64;
    }
    return pos;
}
function hash(data) {
    var h = new SHA256();
    h.update(data);
    var digest = h.digest();
    h.clean();
    return digest;
}
exports.hash = hash; //# sourceMappingURL=sha256.js.map
}),
"[project]/node_modules/@stablelib/x25519/lib/x25519.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.sharedKey = exports.generateKeyPair = exports.generateKeyPairFromSeed = exports.scalarMultBase = exports.scalarMult = exports.SHARED_KEY_LENGTH = exports.SECRET_KEY_LENGTH = exports.PUBLIC_KEY_LENGTH = void 0;
/**
 * Package x25519 implements X25519 key agreement.
 */ const random_1 = __turbopack_context__.r("[project]/node_modules/@stablelib/random/lib/random.js [app-client] (ecmascript)");
const wipe_1 = __turbopack_context__.r("[project]/node_modules/@stablelib/wipe/lib/wipe.js [app-client] (ecmascript)");
exports.PUBLIC_KEY_LENGTH = 32;
exports.SECRET_KEY_LENGTH = 32;
exports.SHARED_KEY_LENGTH = 32;
// Returns new zero-filled 16-element GF (Float64Array).
// If passed an array of numbers, prefills the returned
// array with them.
//
// We use Float64Array, because we need 48-bit numbers
// for this implementation.
function gf(init) {
    const r = new Float64Array(16);
    if (init) {
        for(let i = 0; i < init.length; i++){
            r[i] = init[i];
        }
    }
    return r;
}
// Base point.
const _9 = new Uint8Array(32);
_9[0] = 9;
const _121665 = gf([
    0xdb41,
    1
]);
function car25519(o) {
    let c = 1;
    for(let i = 0; i < 16; i++){
        let v = o[i] + c + 65535;
        c = Math.floor(v / 65536);
        o[i] = v - c * 65536;
    }
    o[0] += c - 1 + 37 * (c - 1);
}
function sel25519(p, q, b) {
    const c = ~(b - 1);
    for(let i = 0; i < 16; i++){
        const t = c & (p[i] ^ q[i]);
        p[i] ^= t;
        q[i] ^= t;
    }
}
function pack25519(o, n) {
    const m = gf();
    const t = gf();
    for(let i = 0; i < 16; i++){
        t[i] = n[i];
    }
    car25519(t);
    car25519(t);
    car25519(t);
    for(let j = 0; j < 2; j++){
        m[0] = t[0] - 0xffed;
        for(let i = 1; i < 15; i++){
            m[i] = t[i] - 0xffff - (m[i - 1] >> 16 & 1);
            m[i - 1] &= 0xffff;
        }
        m[15] = t[15] - 0x7fff - (m[14] >> 16 & 1);
        const b = m[15] >> 16 & 1;
        m[14] &= 0xffff;
        sel25519(t, m, 1 - b);
    }
    for(let i = 0; i < 16; i++){
        o[2 * i] = t[i] & 0xff;
        o[2 * i + 1] = t[i] >> 8;
    }
}
function unpack25519(o, n) {
    for(let i = 0; i < 16; i++){
        o[i] = n[2 * i] + (n[2 * i + 1] << 8);
    }
    o[15] &= 0x7fff;
}
function add(o, a, b) {
    for(let i = 0; i < 16; i++){
        o[i] = a[i] + b[i];
    }
}
function sub(o, a, b) {
    for(let i = 0; i < 16; i++){
        o[i] = a[i] - b[i];
    }
}
function mul(o, a, b) {
    let v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
    v = a[0];
    t0 += v * b0;
    t1 += v * b1;
    t2 += v * b2;
    t3 += v * b3;
    t4 += v * b4;
    t5 += v * b5;
    t6 += v * b6;
    t7 += v * b7;
    t8 += v * b8;
    t9 += v * b9;
    t10 += v * b10;
    t11 += v * b11;
    t12 += v * b12;
    t13 += v * b13;
    t14 += v * b14;
    t15 += v * b15;
    v = a[1];
    t1 += v * b0;
    t2 += v * b1;
    t3 += v * b2;
    t4 += v * b3;
    t5 += v * b4;
    t6 += v * b5;
    t7 += v * b6;
    t8 += v * b7;
    t9 += v * b8;
    t10 += v * b9;
    t11 += v * b10;
    t12 += v * b11;
    t13 += v * b12;
    t14 += v * b13;
    t15 += v * b14;
    t16 += v * b15;
    v = a[2];
    t2 += v * b0;
    t3 += v * b1;
    t4 += v * b2;
    t5 += v * b3;
    t6 += v * b4;
    t7 += v * b5;
    t8 += v * b6;
    t9 += v * b7;
    t10 += v * b8;
    t11 += v * b9;
    t12 += v * b10;
    t13 += v * b11;
    t14 += v * b12;
    t15 += v * b13;
    t16 += v * b14;
    t17 += v * b15;
    v = a[3];
    t3 += v * b0;
    t4 += v * b1;
    t5 += v * b2;
    t6 += v * b3;
    t7 += v * b4;
    t8 += v * b5;
    t9 += v * b6;
    t10 += v * b7;
    t11 += v * b8;
    t12 += v * b9;
    t13 += v * b10;
    t14 += v * b11;
    t15 += v * b12;
    t16 += v * b13;
    t17 += v * b14;
    t18 += v * b15;
    v = a[4];
    t4 += v * b0;
    t5 += v * b1;
    t6 += v * b2;
    t7 += v * b3;
    t8 += v * b4;
    t9 += v * b5;
    t10 += v * b6;
    t11 += v * b7;
    t12 += v * b8;
    t13 += v * b9;
    t14 += v * b10;
    t15 += v * b11;
    t16 += v * b12;
    t17 += v * b13;
    t18 += v * b14;
    t19 += v * b15;
    v = a[5];
    t5 += v * b0;
    t6 += v * b1;
    t7 += v * b2;
    t8 += v * b3;
    t9 += v * b4;
    t10 += v * b5;
    t11 += v * b6;
    t12 += v * b7;
    t13 += v * b8;
    t14 += v * b9;
    t15 += v * b10;
    t16 += v * b11;
    t17 += v * b12;
    t18 += v * b13;
    t19 += v * b14;
    t20 += v * b15;
    v = a[6];
    t6 += v * b0;
    t7 += v * b1;
    t8 += v * b2;
    t9 += v * b3;
    t10 += v * b4;
    t11 += v * b5;
    t12 += v * b6;
    t13 += v * b7;
    t14 += v * b8;
    t15 += v * b9;
    t16 += v * b10;
    t17 += v * b11;
    t18 += v * b12;
    t19 += v * b13;
    t20 += v * b14;
    t21 += v * b15;
    v = a[7];
    t7 += v * b0;
    t8 += v * b1;
    t9 += v * b2;
    t10 += v * b3;
    t11 += v * b4;
    t12 += v * b5;
    t13 += v * b6;
    t14 += v * b7;
    t15 += v * b8;
    t16 += v * b9;
    t17 += v * b10;
    t18 += v * b11;
    t19 += v * b12;
    t20 += v * b13;
    t21 += v * b14;
    t22 += v * b15;
    v = a[8];
    t8 += v * b0;
    t9 += v * b1;
    t10 += v * b2;
    t11 += v * b3;
    t12 += v * b4;
    t13 += v * b5;
    t14 += v * b6;
    t15 += v * b7;
    t16 += v * b8;
    t17 += v * b9;
    t18 += v * b10;
    t19 += v * b11;
    t20 += v * b12;
    t21 += v * b13;
    t22 += v * b14;
    t23 += v * b15;
    v = a[9];
    t9 += v * b0;
    t10 += v * b1;
    t11 += v * b2;
    t12 += v * b3;
    t13 += v * b4;
    t14 += v * b5;
    t15 += v * b6;
    t16 += v * b7;
    t17 += v * b8;
    t18 += v * b9;
    t19 += v * b10;
    t20 += v * b11;
    t21 += v * b12;
    t22 += v * b13;
    t23 += v * b14;
    t24 += v * b15;
    v = a[10];
    t10 += v * b0;
    t11 += v * b1;
    t12 += v * b2;
    t13 += v * b3;
    t14 += v * b4;
    t15 += v * b5;
    t16 += v * b6;
    t17 += v * b7;
    t18 += v * b8;
    t19 += v * b9;
    t20 += v * b10;
    t21 += v * b11;
    t22 += v * b12;
    t23 += v * b13;
    t24 += v * b14;
    t25 += v * b15;
    v = a[11];
    t11 += v * b0;
    t12 += v * b1;
    t13 += v * b2;
    t14 += v * b3;
    t15 += v * b4;
    t16 += v * b5;
    t17 += v * b6;
    t18 += v * b7;
    t19 += v * b8;
    t20 += v * b9;
    t21 += v * b10;
    t22 += v * b11;
    t23 += v * b12;
    t24 += v * b13;
    t25 += v * b14;
    t26 += v * b15;
    v = a[12];
    t12 += v * b0;
    t13 += v * b1;
    t14 += v * b2;
    t15 += v * b3;
    t16 += v * b4;
    t17 += v * b5;
    t18 += v * b6;
    t19 += v * b7;
    t20 += v * b8;
    t21 += v * b9;
    t22 += v * b10;
    t23 += v * b11;
    t24 += v * b12;
    t25 += v * b13;
    t26 += v * b14;
    t27 += v * b15;
    v = a[13];
    t13 += v * b0;
    t14 += v * b1;
    t15 += v * b2;
    t16 += v * b3;
    t17 += v * b4;
    t18 += v * b5;
    t19 += v * b6;
    t20 += v * b7;
    t21 += v * b8;
    t22 += v * b9;
    t23 += v * b10;
    t24 += v * b11;
    t25 += v * b12;
    t26 += v * b13;
    t27 += v * b14;
    t28 += v * b15;
    v = a[14];
    t14 += v * b0;
    t15 += v * b1;
    t16 += v * b2;
    t17 += v * b3;
    t18 += v * b4;
    t19 += v * b5;
    t20 += v * b6;
    t21 += v * b7;
    t22 += v * b8;
    t23 += v * b9;
    t24 += v * b10;
    t25 += v * b11;
    t26 += v * b12;
    t27 += v * b13;
    t28 += v * b14;
    t29 += v * b15;
    v = a[15];
    t15 += v * b0;
    t16 += v * b1;
    t17 += v * b2;
    t18 += v * b3;
    t19 += v * b4;
    t20 += v * b5;
    t21 += v * b6;
    t22 += v * b7;
    t23 += v * b8;
    t24 += v * b9;
    t25 += v * b10;
    t26 += v * b11;
    t27 += v * b12;
    t28 += v * b13;
    t29 += v * b14;
    t30 += v * b15;
    t0 += 38 * t16;
    t1 += 38 * t17;
    t2 += 38 * t18;
    t3 += 38 * t19;
    t4 += 38 * t20;
    t5 += 38 * t21;
    t6 += 38 * t22;
    t7 += 38 * t23;
    t8 += 38 * t24;
    t9 += 38 * t25;
    t10 += 38 * t26;
    t11 += 38 * t27;
    t12 += 38 * t28;
    t13 += 38 * t29;
    t14 += 38 * t30;
    // t15 left as is
    // first car
    c = 1;
    v = t0 + c + 65535;
    c = Math.floor(v / 65536);
    t0 = v - c * 65536;
    v = t1 + c + 65535;
    c = Math.floor(v / 65536);
    t1 = v - c * 65536;
    v = t2 + c + 65535;
    c = Math.floor(v / 65536);
    t2 = v - c * 65536;
    v = t3 + c + 65535;
    c = Math.floor(v / 65536);
    t3 = v - c * 65536;
    v = t4 + c + 65535;
    c = Math.floor(v / 65536);
    t4 = v - c * 65536;
    v = t5 + c + 65535;
    c = Math.floor(v / 65536);
    t5 = v - c * 65536;
    v = t6 + c + 65535;
    c = Math.floor(v / 65536);
    t6 = v - c * 65536;
    v = t7 + c + 65535;
    c = Math.floor(v / 65536);
    t7 = v - c * 65536;
    v = t8 + c + 65535;
    c = Math.floor(v / 65536);
    t8 = v - c * 65536;
    v = t9 + c + 65535;
    c = Math.floor(v / 65536);
    t9 = v - c * 65536;
    v = t10 + c + 65535;
    c = Math.floor(v / 65536);
    t10 = v - c * 65536;
    v = t11 + c + 65535;
    c = Math.floor(v / 65536);
    t11 = v - c * 65536;
    v = t12 + c + 65535;
    c = Math.floor(v / 65536);
    t12 = v - c * 65536;
    v = t13 + c + 65535;
    c = Math.floor(v / 65536);
    t13 = v - c * 65536;
    v = t14 + c + 65535;
    c = Math.floor(v / 65536);
    t14 = v - c * 65536;
    v = t15 + c + 65535;
    c = Math.floor(v / 65536);
    t15 = v - c * 65536;
    t0 += c - 1 + 37 * (c - 1);
    // second car
    c = 1;
    v = t0 + c + 65535;
    c = Math.floor(v / 65536);
    t0 = v - c * 65536;
    v = t1 + c + 65535;
    c = Math.floor(v / 65536);
    t1 = v - c * 65536;
    v = t2 + c + 65535;
    c = Math.floor(v / 65536);
    t2 = v - c * 65536;
    v = t3 + c + 65535;
    c = Math.floor(v / 65536);
    t3 = v - c * 65536;
    v = t4 + c + 65535;
    c = Math.floor(v / 65536);
    t4 = v - c * 65536;
    v = t5 + c + 65535;
    c = Math.floor(v / 65536);
    t5 = v - c * 65536;
    v = t6 + c + 65535;
    c = Math.floor(v / 65536);
    t6 = v - c * 65536;
    v = t7 + c + 65535;
    c = Math.floor(v / 65536);
    t7 = v - c * 65536;
    v = t8 + c + 65535;
    c = Math.floor(v / 65536);
    t8 = v - c * 65536;
    v = t9 + c + 65535;
    c = Math.floor(v / 65536);
    t9 = v - c * 65536;
    v = t10 + c + 65535;
    c = Math.floor(v / 65536);
    t10 = v - c * 65536;
    v = t11 + c + 65535;
    c = Math.floor(v / 65536);
    t11 = v - c * 65536;
    v = t12 + c + 65535;
    c = Math.floor(v / 65536);
    t12 = v - c * 65536;
    v = t13 + c + 65535;
    c = Math.floor(v / 65536);
    t13 = v - c * 65536;
    v = t14 + c + 65535;
    c = Math.floor(v / 65536);
    t14 = v - c * 65536;
    v = t15 + c + 65535;
    c = Math.floor(v / 65536);
    t15 = v - c * 65536;
    t0 += c - 1 + 37 * (c - 1);
    o[0] = t0;
    o[1] = t1;
    o[2] = t2;
    o[3] = t3;
    o[4] = t4;
    o[5] = t5;
    o[6] = t6;
    o[7] = t7;
    o[8] = t8;
    o[9] = t9;
    o[10] = t10;
    o[11] = t11;
    o[12] = t12;
    o[13] = t13;
    o[14] = t14;
    o[15] = t15;
}
function square(o, a) {
    mul(o, a, a);
}
function inv25519(o, inp) {
    const c = gf();
    for(let i = 0; i < 16; i++){
        c[i] = inp[i];
    }
    for(let i = 253; i >= 0; i--){
        square(c, c);
        if (i !== 2 && i !== 4) {
            mul(c, c, inp);
        }
    }
    for(let i = 0; i < 16; i++){
        o[i] = c[i];
    }
}
function scalarMult(n, p) {
    const z = new Uint8Array(32);
    const x = new Float64Array(80);
    const a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
    for(let i = 0; i < 31; i++){
        z[i] = n[i];
    }
    z[31] = n[31] & 127 | 64;
    z[0] &= 248;
    unpack25519(x, p);
    for(let i = 0; i < 16; i++){
        b[i] = x[i];
    }
    a[0] = d[0] = 1;
    for(let i = 254; i >= 0; --i){
        const r = z[i >>> 3] >>> (i & 7) & 1;
        sel25519(a, b, r);
        sel25519(c, d, r);
        add(e, a, c);
        sub(a, a, c);
        add(c, b, d);
        sub(b, b, d);
        square(d, e);
        square(f, a);
        mul(a, c, a);
        mul(c, b, e);
        add(e, a, c);
        sub(a, a, c);
        square(b, a);
        sub(c, d, f);
        mul(a, c, _121665);
        add(a, a, d);
        mul(c, c, a);
        mul(a, d, f);
        mul(d, b, x);
        square(b, e);
        sel25519(a, b, r);
        sel25519(c, d, r);
    }
    for(let i = 0; i < 16; i++){
        x[i + 16] = a[i];
        x[i + 32] = c[i];
        x[i + 48] = b[i];
        x[i + 64] = d[i];
    }
    const x32 = x.subarray(32);
    const x16 = x.subarray(16);
    inv25519(x32, x32);
    mul(x16, x16, x32);
    const q = new Uint8Array(32);
    pack25519(q, x16);
    return q;
}
exports.scalarMult = scalarMult;
function scalarMultBase(n) {
    return scalarMult(n, _9);
}
exports.scalarMultBase = scalarMultBase;
function generateKeyPairFromSeed(seed) {
    if (seed.length !== exports.SECRET_KEY_LENGTH) {
        throw new Error(`x25519: seed must be ${exports.SECRET_KEY_LENGTH} bytes`);
    }
    const secretKey = new Uint8Array(seed);
    const publicKey = scalarMultBase(secretKey);
    return {
        publicKey,
        secretKey
    };
}
exports.generateKeyPairFromSeed = generateKeyPairFromSeed;
function generateKeyPair(prng) {
    const seed = (0, random_1.randomBytes)(32, prng);
    const result = generateKeyPairFromSeed(seed);
    (0, wipe_1.wipe)(seed);
    return result;
}
exports.generateKeyPair = generateKeyPair;
/**
 * Returns a shared key between our secret key and a peer's public key.
 *
 * Throws an error if the given keys are of wrong length.
 *
 * If rejectZero is true throws if the calculated shared key is all-zero.
 * From RFC 7748:
 *
 * > Protocol designers using Diffie-Hellman over the curves defined in
 * > this document must not assume "contributory behavior".  Specially,
 * > contributory behavior means that both parties' private keys
 * > contribute to the resulting shared key.  Since curve25519 and
 * > curve448 have cofactors of 8 and 4 (respectively), an input point of
 * > small order will eliminate any contribution from the other party's
 * > private key.  This situation can be detected by checking for the all-
 * > zero output, which implementations MAY do, as specified in Section 6.
 * > However, a large number of existing implementations do not do this.
 *
 * IMPORTANT: the returned key is a raw result of scalar multiplication.
 * To use it as a key material, hash it with a cryptographic hash function.
 */ function sharedKey(mySecretKey, theirPublicKey, rejectZero = false) {
    if (mySecretKey.length !== exports.PUBLIC_KEY_LENGTH) {
        throw new Error("X25519: incorrect secret key length");
    }
    if (theirPublicKey.length !== exports.PUBLIC_KEY_LENGTH) {
        throw new Error("X25519: incorrect public key length");
    }
    const result = scalarMult(mySecretKey, theirPublicKey);
    if (rejectZero) {
        let zeros = 0;
        for(let i = 0; i < result.length; i++){
            zeros |= result[i];
        }
        if (zeros === 0) {
            throw new Error("X25519: invalid shared key");
        }
    }
    return result;
}
exports.sharedKey = sharedKey; //# sourceMappingURL=x25519.js.map
}),
"[project]/node_modules/uint8arrays/esm/src/compare.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "compare",
    ()=>compare
]);
function compare(a, b) {
    for(let i = 0; i < a.byteLength; i++){
        if (a[i] < b[i]) {
            return -1;
        }
        if (a[i] > b[i]) {
            return 1;
        }
    }
    if (a.byteLength > b.byteLength) {
        return 1;
    }
    if (a.byteLength < b.byteLength) {
        return -1;
    }
    return 0;
}
}),
"[project]/node_modules/uint8arrays/esm/src/util/as-uint8array.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "asUint8Array",
    ()=>asUint8Array
]);
function asUint8Array(buf) {
    if (globalThis.Buffer != null) {
        return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
    }
    return buf;
}
}),
"[project]/node_modules/uint8arrays/esm/src/alloc.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "alloc",
    ()=>alloc,
    "allocUnsafe",
    ()=>allocUnsafe
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arrays/esm/src/util/as-uint8array.js [app-client] (ecmascript)");
;
function alloc(size = 0) {
    if (globalThis.Buffer != null && globalThis.Buffer.alloc != null) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asUint8Array"])(globalThis.Buffer.alloc(size));
    }
    return new Uint8Array(size);
}
function allocUnsafe(size = 0) {
    if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asUint8Array"])(globalThis.Buffer.allocUnsafe(size));
    }
    return new Uint8Array(size);
}
}),
"[project]/node_modules/uint8arrays/esm/src/concat.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "concat",
    ()=>concat
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arrays/esm/src/alloc.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arrays/esm/src/util/as-uint8array.js [app-client] (ecmascript)");
;
;
function concat(arrays, length) {
    if (!length) {
        length = arrays.reduce((acc, curr)=>acc + curr.length, 0);
    }
    const output = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["allocUnsafe"])(length);
    let offset = 0;
    for (const arr of arrays){
        output.set(arr, offset);
        offset += arr.length;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asUint8Array"])(output);
}
}),
"[project]/node_modules/uint8arrays/esm/src/equals.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "equals",
    ()=>equals
]);
function equals(a, b) {
    if (a === b) {
        return true;
    }
    if (a.byteLength !== b.byteLength) {
        return false;
    }
    for(let i = 0; i < a.byteLength; i++){
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
}
}),
"[project]/node_modules/uint8arrays/esm/src/util/bases.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$basics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/esm/src/basics.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arrays/esm/src/alloc.js [app-client] (ecmascript)");
;
;
function createCodec(name, prefix, encode, decode) {
    return {
        name,
        prefix,
        encoder: {
            name,
            prefix,
            encode
        },
        decoder: {
            decode
        }
    };
}
const string = createCodec('utf8', 'u', (buf)=>{
    const decoder = new TextDecoder('utf8');
    return 'u' + decoder.decode(buf);
}, (str)=>{
    const encoder = new TextEncoder();
    return encoder.encode(str.substring(1));
});
const ascii = createCodec('ascii', 'a', (buf)=>{
    let string = 'a';
    for(let i = 0; i < buf.length; i++){
        string += String.fromCharCode(buf[i]);
    }
    return string;
}, (str)=>{
    str = str.substring(1);
    const buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["allocUnsafe"])(str.length);
    for(let i = 0; i < str.length; i++){
        buf[i] = str.charCodeAt(i);
    }
    return buf;
});
const BASES = {
    utf8: string,
    'utf-8': string,
    hex: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$basics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bases"].base16,
    latin1: ascii,
    ascii: ascii,
    binary: ascii,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$esm$2f$src$2f$basics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bases"]
};
const __TURBOPACK__default__export__ = BASES;
}),
"[project]/node_modules/uint8arrays/esm/src/from-string.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "fromString",
    ()=>fromString
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$util$2f$bases$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arrays/esm/src/util/bases.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arrays/esm/src/util/as-uint8array.js [app-client] (ecmascript)");
;
;
function fromString(string, encoding = 'utf8') {
    const base = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$util$2f$bases$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"][encoding];
    if (!base) {
        throw new Error(`Unsupported encoding "${encoding}"`);
    }
    if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asUint8Array"])(globalThis.Buffer.from(string, 'utf-8'));
    }
    return base.decoder.decode(`${base.prefix}${string}`);
}
}),
"[project]/node_modules/uint8arrays/esm/src/to-string.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "toString",
    ()=>toString
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$util$2f$bases$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arrays/esm/src/util/bases.js [app-client] (ecmascript)");
;
function toString(array, encoding = 'utf8') {
    const base = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$util$2f$bases$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"][encoding];
    if (!base) {
        throw new Error(`Unsupported encoding "${encoding}"`);
    }
    if ((encoding === 'utf8' || encoding === 'utf-8') && globalThis.Buffer != null && globalThis.Buffer.from != null) {
        return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString('utf8');
    }
    return base.encoder.encode(array).substring(1);
}
}),
"[project]/node_modules/uint8arrays/esm/src/xor.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "xor",
    ()=>xor
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arrays/esm/src/alloc.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arrays/esm/src/util/as-uint8array.js [app-client] (ecmascript)");
;
;
function xor(a, b) {
    if (a.length !== b.length) {
        throw new Error('Inputs should have the same length');
    }
    const result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["allocUnsafe"])(a.length);
    for(let i = 0; i < a.length; i++){
        result[i] = a[i] ^ b[i];
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asUint8Array"])(result);
}
}),
"[project]/node_modules/uint8arrays/esm/src/index.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$compare$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arrays/esm/src/compare.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$concat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arrays/esm/src/concat.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$equals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arrays/esm/src/equals.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$from$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arrays/esm/src/from-string.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arrays/esm/src/to-string.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arrays$2f$esm$2f$src$2f$xor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arrays/esm/src/xor.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
}),
"[project]/node_modules/ipld-dag-pb/node_modules/uint8arrays/util/bases.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { bases } = __turbopack_context__.r("[project]/node_modules/multiformats/esm/src/basics.js [app-client] (ecmascript)");
/**
 * @typedef {import('multiformats/bases/interface').MultibaseCodec<any>} MultibaseCodec
 */ /**
 * @param {string} name
 * @param {string} prefix
 * @param {(buf: Uint8Array) => string} encode
 * @param {(str: string) => Uint8Array} decode
 * @returns {MultibaseCodec}
 */ function createCodec(name, prefix, encode, decode) {
    return {
        name,
        prefix,
        encoder: {
            name,
            prefix,
            encode
        },
        decoder: {
            decode
        }
    };
}
const string = createCodec('utf8', 'u', (buf)=>{
    const decoder = new TextDecoder('utf8');
    return 'u' + decoder.decode(buf);
}, (str)=>{
    const encoder = new TextEncoder();
    return encoder.encode(str.substring(1));
});
const ascii = createCodec('ascii', 'a', (buf)=>{
    let string = 'a';
    for(let i = 0; i < buf.length; i++){
        string += String.fromCharCode(buf[i]);
    }
    return string;
}, (str)=>{
    str = str.substring(1);
    const buf = new Uint8Array(str.length);
    for(let i = 0; i < str.length; i++){
        buf[i] = str.charCodeAt(i);
    }
    return buf;
});
/**
 * @typedef {'utf8' | 'utf-8' | 'hex' | 'latin1' | 'ascii' | 'binary' | keyof bases } SupportedEncodings
 */ /**
 * @type {Record<SupportedEncodings, MultibaseCodec>}
 */ const BASES = {
    'utf8': string,
    'utf-8': string,
    'hex': bases.base16,
    'latin1': ascii,
    'ascii': ascii,
    'binary': ascii,
    ...bases
};
module.exports = BASES;
}),
"[project]/node_modules/ipld-dag-pb/node_modules/uint8arrays/from-string.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const bases = __turbopack_context__.r("[project]/node_modules/ipld-dag-pb/node_modules/uint8arrays/util/bases.js [app-client] (ecmascript)");
/**
 * @typedef {import('./util/bases').SupportedEncodings} SupportedEncodings
 */ /**
 * Create a `Uint8Array` from the passed string
 *
 * Supports `utf8`, `utf-8`, `hex`, and any encoding supported by the multiformats module.
 *
 * Also `ascii` which is similar to node's 'binary' encoding.
 *
 * @param {string} string
 * @param {SupportedEncodings} [encoding=utf8] - utf8, base16, base64, base64urlpad, etc
 * @returns {Uint8Array}
 */ function fromString(string, encoding = 'utf8') {
    const base = bases[encoding];
    if (!base) {
        throw new Error(`Unsupported encoding "${encoding}"`);
    }
    // add multibase prefix
    return base.decoder.decode(`${base.prefix}${string}`);
}
module.exports = fromString;
}),
"[project]/node_modules/ipld-dag-pb/node_modules/uint8arrays/compare.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Can be used with Array.sort to sort and array with Uint8Array entries
 *
 * @param {Uint8Array} a
 * @param {Uint8Array} b
 */ function compare(a, b) {
    for(let i = 0; i < a.byteLength; i++){
        if (a[i] < b[i]) {
            return -1;
        }
        if (a[i] > b[i]) {
            return 1;
        }
    }
    if (a.byteLength > b.byteLength) {
        return 1;
    }
    if (a.byteLength < b.byteLength) {
        return -1;
    }
    return 0;
}
module.exports = compare;
}),
"[project]/node_modules/ipld-dag-pb/node_modules/uint8arrays/equals.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Returns true if the two passed Uint8Arrays have the same content
 *
 * @param {Uint8Array} a
 * @param {Uint8Array} b
 */ function equals(a, b) {
    if (a === b) {
        return true;
    }
    if (a.byteLength !== b.byteLength) {
        return false;
    }
    for(let i = 0; i < a.byteLength; i++){
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
}
module.exports = equals;
}),
"[project]/node_modules/ipld-dag-pb/node_modules/uint8arrays/to-string.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const bases = __turbopack_context__.r("[project]/node_modules/ipld-dag-pb/node_modules/uint8arrays/util/bases.js [app-client] (ecmascript)");
/**
 * @typedef {import('./util/bases').SupportedEncodings} SupportedEncodings
 */ /**
 * Turns a `Uint8Array` into a string.
 *
 * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.
 *
 * Also `ascii` which is similar to node's 'binary' encoding.
 *
 * @param {Uint8Array} array - The array to turn into a string
 * @param {SupportedEncodings} [encoding=utf8] - The encoding to use
 * @returns {string}
 */ function toString(array, encoding = 'utf8') {
    const base = bases[encoding];
    if (!base) {
        throw new Error(`Unsupported encoding "${encoding}"`);
    }
    // strip multibase prefix
    return base.encoder.encode(array).substring(1);
}
module.exports = toString;
}),
"[project]/node_modules/ipld-dag-pb/src/dag.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*eslint-disable*/ var $protobuf = __turbopack_context__.r("[project]/node_modules/protobufjs/minimal.js [app-client] (ecmascript)");
// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
$root.PBLink = function() {
    /**
     * Properties of a PBLink.
     * @exports IPBLink
     * @interface IPBLink
     * @property {Uint8Array|null} [Hash] PBLink Hash
     * @property {string|null} [Name] PBLink Name
     * @property {number|null} [Tsize] PBLink Tsize
     */ /**
     * Constructs a new PBLink.
     * @exports PBLink
     * @classdesc Represents a PBLink.
     * @implements IPBLink
     * @constructor
     * @param {IPBLink=} [p] Properties to set
     */ function PBLink(p) {
        if (p) {
            for(var ks = Object.keys(p), i = 0; i < ks.length; ++i)if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }
    }
    /**
     * PBLink Hash.
     * @member {Uint8Array} Hash
     * @memberof PBLink
     * @instance
     */ PBLink.prototype.Hash = $util.newBuffer([]);
    /**
     * PBLink Name.
     * @member {string} Name
     * @memberof PBLink
     * @instance
     */ PBLink.prototype.Name = "";
    /**
     * PBLink Tsize.
     * @member {number} Tsize
     * @memberof PBLink
     * @instance
     */ PBLink.prototype.Tsize = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * Encodes the specified PBLink message. Does not implicitly {@link PBLink.verify|verify} messages.
     * @function encode
     * @memberof PBLink
     * @static
     * @param {IPBLink} m PBLink message or plain object to encode
     * @param {$protobuf.Writer} [w] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */ PBLink.encode = function encode(m, w) {
        if (!w) w = $Writer.create();
        if (m.Hash != null && Object.hasOwnProperty.call(m, "Hash")) w.uint32(10).bytes(m.Hash);
        if (m.Name != null && Object.hasOwnProperty.call(m, "Name")) w.uint32(18).string(m.Name);
        if (m.Tsize != null && Object.hasOwnProperty.call(m, "Tsize")) w.uint32(24).uint64(m.Tsize);
        return w;
    };
    /**
     * Decodes a PBLink message from the specified reader or buffer.
     * @function decode
     * @memberof PBLink
     * @static
     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
     * @param {number} [l] Message length if known beforehand
     * @returns {PBLink} PBLink
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */ PBLink.decode = function decode(r, l) {
        if (!(r instanceof $Reader)) r = $Reader.create(r);
        var c = l === undefined ? r.len : r.pos + l, m = new $root.PBLink();
        while(r.pos < c){
            var t = r.uint32();
            switch(t >>> 3){
                case 1:
                    m.Hash = r.bytes();
                    break;
                case 2:
                    m.Name = r.string();
                    break;
                case 3:
                    m.Tsize = r.uint64();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
            }
        }
        return m;
    };
    /**
     * Creates a PBLink message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PBLink
     * @static
     * @param {Object.<string,*>} d Plain object
     * @returns {PBLink} PBLink
     */ PBLink.fromObject = function fromObject(d) {
        if (d instanceof $root.PBLink) return d;
        var m = new $root.PBLink();
        if (d.Hash != null) {
            if (typeof d.Hash === "string") $util.base64.decode(d.Hash, m.Hash = $util.newBuffer($util.base64.length(d.Hash)), 0);
            else if (d.Hash.length) m.Hash = d.Hash;
        }
        if (d.Name != null) {
            m.Name = String(d.Name);
        }
        if (d.Tsize != null) {
            if ($util.Long) (m.Tsize = $util.Long.fromValue(d.Tsize)).unsigned = true;
            else if (typeof d.Tsize === "string") m.Tsize = parseInt(d.Tsize, 10);
            else if (typeof d.Tsize === "number") m.Tsize = d.Tsize;
            else if (typeof d.Tsize === "object") m.Tsize = new $util.LongBits(d.Tsize.low >>> 0, d.Tsize.high >>> 0).toNumber(true);
        }
        return m;
    };
    /**
     * Creates a plain object from a PBLink message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PBLink
     * @static
     * @param {PBLink} m PBLink
     * @param {$protobuf.IConversionOptions} [o] Conversion options
     * @returns {Object.<string,*>} Plain object
     */ PBLink.toObject = function toObject(m, o) {
        if (!o) o = {};
        var d = {};
        if (o.defaults) {
            if (o.bytes === String) d.Hash = "";
            else {
                d.Hash = [];
                if (o.bytes !== Array) d.Hash = $util.newBuffer(d.Hash);
            }
            d.Name = "";
            if ($util.Long) {
                var n = new $util.Long(0, 0, true);
                d.Tsize = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
            } else d.Tsize = o.longs === String ? "0" : 0;
        }
        if (m.Hash != null && m.hasOwnProperty("Hash")) {
            d.Hash = o.bytes === String ? $util.base64.encode(m.Hash, 0, m.Hash.length) : o.bytes === Array ? Array.prototype.slice.call(m.Hash) : m.Hash;
        }
        if (m.Name != null && m.hasOwnProperty("Name")) {
            d.Name = m.Name;
        }
        if (m.Tsize != null && m.hasOwnProperty("Tsize")) {
            if (typeof m.Tsize === "number") d.Tsize = o.longs === String ? String(m.Tsize) : m.Tsize;
            else d.Tsize = o.longs === String ? $util.Long.prototype.toString.call(m.Tsize) : o.longs === Number ? new $util.LongBits(m.Tsize.low >>> 0, m.Tsize.high >>> 0).toNumber(true) : m.Tsize;
        }
        return d;
    };
    /**
     * Converts this PBLink to JSON.
     * @function toJSON
     * @memberof PBLink
     * @instance
     * @returns {Object.<string,*>} JSON object
     */ PBLink.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return PBLink;
}();
$root.PBNode = function() {
    /**
     * Properties of a PBNode.
     * @exports IPBNode
     * @interface IPBNode
     * @property {Array.<IPBLink>|null} [Links] PBNode Links
     * @property {Uint8Array|null} [Data] PBNode Data
     */ /**
     * Constructs a new PBNode.
     * @exports PBNode
     * @classdesc Represents a PBNode.
     * @implements IPBNode
     * @constructor
     * @param {IPBNode=} [p] Properties to set
     */ function PBNode(p) {
        this.Links = [];
        if (p) {
            for(var ks = Object.keys(p), i = 0; i < ks.length; ++i)if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }
    }
    /**
     * PBNode Links.
     * @member {Array.<IPBLink>} Links
     * @memberof PBNode
     * @instance
     */ PBNode.prototype.Links = $util.emptyArray;
    /**
     * PBNode Data.
     * @member {Uint8Array} Data
     * @memberof PBNode
     * @instance
     */ PBNode.prototype.Data = $util.newBuffer([]);
    /**
     * Encodes the specified PBNode message. Does not implicitly {@link PBNode.verify|verify} messages.
     * @function encode
     * @memberof PBNode
     * @static
     * @param {IPBNode} m PBNode message or plain object to encode
     * @param {$protobuf.Writer} [w] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */ PBNode.encode = function encode(m, w) {
        if (!w) w = $Writer.create();
        if (m.Data != null && Object.hasOwnProperty.call(m, "Data")) w.uint32(10).bytes(m.Data);
        if (m.Links != null && m.Links.length) {
            for(var i = 0; i < m.Links.length; ++i)$root.PBLink.encode(m.Links[i], w.uint32(18).fork()).ldelim();
        }
        return w;
    };
    /**
     * Decodes a PBNode message from the specified reader or buffer.
     * @function decode
     * @memberof PBNode
     * @static
     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
     * @param {number} [l] Message length if known beforehand
     * @returns {PBNode} PBNode
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */ PBNode.decode = function decode(r, l) {
        if (!(r instanceof $Reader)) r = $Reader.create(r);
        var c = l === undefined ? r.len : r.pos + l, m = new $root.PBNode();
        while(r.pos < c){
            var t = r.uint32();
            switch(t >>> 3){
                case 2:
                    if (!(m.Links && m.Links.length)) m.Links = [];
                    m.Links.push($root.PBLink.decode(r, r.uint32()));
                    break;
                case 1:
                    m.Data = r.bytes();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
            }
        }
        return m;
    };
    /**
     * Creates a PBNode message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof PBNode
     * @static
     * @param {Object.<string,*>} d Plain object
     * @returns {PBNode} PBNode
     */ PBNode.fromObject = function fromObject(d) {
        if (d instanceof $root.PBNode) return d;
        var m = new $root.PBNode();
        if (d.Links) {
            if (!Array.isArray(d.Links)) throw TypeError(".PBNode.Links: array expected");
            m.Links = [];
            for(var i = 0; i < d.Links.length; ++i){
                if (typeof d.Links[i] !== "object") throw TypeError(".PBNode.Links: object expected");
                m.Links[i] = $root.PBLink.fromObject(d.Links[i]);
            }
        }
        if (d.Data != null) {
            if (typeof d.Data === "string") $util.base64.decode(d.Data, m.Data = $util.newBuffer($util.base64.length(d.Data)), 0);
            else if (d.Data.length) m.Data = d.Data;
        }
        return m;
    };
    /**
     * Creates a plain object from a PBNode message. Also converts values to other types if specified.
     * @function toObject
     * @memberof PBNode
     * @static
     * @param {PBNode} m PBNode
     * @param {$protobuf.IConversionOptions} [o] Conversion options
     * @returns {Object.<string,*>} Plain object
     */ PBNode.toObject = function toObject(m, o) {
        if (!o) o = {};
        var d = {};
        if (o.arrays || o.defaults) {
            d.Links = [];
        }
        if (o.defaults) {
            if (o.bytes === String) d.Data = "";
            else {
                d.Data = [];
                if (o.bytes !== Array) d.Data = $util.newBuffer(d.Data);
            }
        }
        if (m.Data != null && m.hasOwnProperty("Data")) {
            d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;
        }
        if (m.Links && m.Links.length) {
            d.Links = [];
            for(var j = 0; j < m.Links.length; ++j){
                d.Links[j] = $root.PBLink.toObject(m.Links[j], o);
            }
        }
        return d;
    };
    /**
     * Converts this PBNode to JSON.
     * @function toJSON
     * @memberof PBNode
     * @instance
     * @returns {Object.<string,*>} JSON object
     */ PBNode.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return PBNode;
}();
module.exports = $root;
}),
"[project]/node_modules/ipld-dag-pb/src/dag-link/dagLink.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const CID = __turbopack_context__.r("[project]/node_modules/cids/src/index.js [app-client] (ecmascript)");
const uint8ArrayFromString = __turbopack_context__.r("[project]/node_modules/ipld-dag-pb/node_modules/uint8arrays/from-string.js [app-client] (ecmascript)");
/**
 * Link represents an IPFS Merkle DAG Link between Nodes.
 */ class DAGLink {
    /**
   * @param {string | undefined | null} name
   * @param {number} size
   * @param {CID | string | Uint8Array} cid
   */ constructor(name, size, cid){
        if (!cid) {
            throw new Error('A link requires a cid to point to');
        }
        // assert(size, 'A link requires a size')
        //  note - links should include size, but this assert is disabled
        //  for now to maintain consistency with go-ipfs pinset
        this.Name = name || '';
        this.Tsize = size;
        this.Hash = new CID(cid);
        Object.defineProperties(this, {
            _nameBuf: {
                value: null,
                writable: true,
                enumerable: false
            }
        });
    }
    toString() {
        return `DAGLink <${this.Hash.toBaseEncodedString()} - name: "${this.Name}", size: ${this.Tsize}>`;
    }
    toJSON() {
        if (!this._json) {
            this._json = Object.freeze({
                name: this.Name,
                size: this.Tsize,
                cid: this.Hash.toBaseEncodedString()
            });
        }
        return Object.assign({}, this._json);
    }
    // Memoize the Uint8Array representation of name
    // We need this to sort the links, otherwise
    // we will reallocate new Uint8Arrays every time
    get nameAsBuffer() {
        if (this._nameBuf != null) {
            return this._nameBuf;
        }
        this._nameBuf = uint8ArrayFromString(this.Name);
        return this._nameBuf;
    }
}
module.exports = DAGLink;
}),
"[project]/node_modules/ipld-dag-pb/src/dag-node/sortLinks.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const sort = __turbopack_context__.r("[project]/node_modules/stable/stable.js [app-client] (ecmascript)");
const uint8ArrayCompare = __turbopack_context__.r("[project]/node_modules/ipld-dag-pb/node_modules/uint8arrays/compare.js [app-client] (ecmascript)");
/**
 * @typedef {import('../dag-link/dagLink')} DAGLink
 */ /**
 *
 * @param {DAGLink} a
 * @param {DAGLink} b
 */ const linkSort = (a, b)=>{
    const buf1 = a.nameAsBuffer;
    const buf2 = b.nameAsBuffer;
    return uint8ArrayCompare(buf1, buf2);
};
/**
 * Sorts links in place (mutating given array)
 *
 * @param {DAGLink[]} links
 * @returns {void}
 */ const sortLinks = (links)=>{
    sort.inplace(links, linkSort);
};
module.exports = sortLinks;
}),
"[project]/node_modules/ipld-dag-pb/src/dag-link/util.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const DAGLink = __turbopack_context__.r("[project]/node_modules/ipld-dag-pb/src/dag-link/dagLink.js [app-client] (ecmascript)");
/**
 * @param {*} link
 */ function createDagLinkFromB58EncodedHash(link) {
    return new DAGLink(link.Name || link.name || '', link.Tsize || link.Size || link.size || 0, link.Hash || link.hash || link.multihash || link.cid);
}
module.exports = {
    createDagLinkFromB58EncodedHash
};
}),
"[project]/node_modules/ipld-dag-pb/src/serialize.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const protobuf = __turbopack_context__.r("[project]/node_modules/protobufjs/minimal.js [app-client] (ecmascript)");
const { PBLink } = __turbopack_context__.r("[project]/node_modules/ipld-dag-pb/src/dag.js [app-client] (ecmascript)");
const { createDagLinkFromB58EncodedHash } = __turbopack_context__.r("[project]/node_modules/ipld-dag-pb/src/dag-link/util.js [app-client] (ecmascript)");
/**
 * @typedef {import('./dag-link/dagLink')} DAGLink
 * @typedef {import('./types').DAGLinkLike} DAGLinkLike
 * @typedef {import('./types').SerializableDAGNode} SerializableDAGNode
 * @typedef {import('cids')} CID
 */ /**
 * @param { { Data?: Uint8Array, Links: (DAGLink | DAGLinkLike)[] }} node
 * @returns {SerializableDAGNode}
 */ const toProtoBuf = (node)=>{
    const pbn = {};
    if (node.Data && node.Data.byteLength > 0) {
        pbn.Data = node.Data;
    } else {
        // NOTE: this has to be null in order to match go-ipfs serialization
        // `null !== new Uint8Array(0)`
        pbn.Data = null;
    }
    if (node.Links && node.Links.length > 0) {
        pbn.Links = node.Links.map((link)=>({
                Hash: link.Hash.bytes,
                Name: link.Name,
                Tsize: link.Tsize
            }));
    } else {
        pbn.Links = null;
    }
    return pbn;
};
/**
 * Serialize internal representation into a binary PB block.
 *
 * @param {import('./dag-node/dagNode')} node - Internal representation of a PB block
 */ const serializeDAGNode = (node)=>{
    return encode(toProtoBuf(node));
};
/**
 * Serialize an object where the `Links` might not be a `DAGLink` instance yet
 *
 * @param {Uint8Array} [data]
 * @param {(DAGLink | string | DAGLinkLike)[]} [links]
 */ const serializeDAGNodeLike = (data, links = [])=>{
    const node = {
        Data: data,
        Links: links.map((link)=>{
            return createDagLinkFromB58EncodedHash(link);
        })
    };
    return encode(toProtoBuf(node));
};
module.exports = {
    serializeDAGNode,
    serializeDAGNodeLike
};
/**
 * The fields in PBNode are the wrong way round - `id: 2` comes before
 * `id: 1`. protobufjs writes them out in id order but go-IPFS does not so
 * we have to use the protobuf.Writer interface directly to get the same
 * serialized form as go-IPFS
 *
 * @param {SerializableDAGNode} pbf
 */ function encode(pbf) {
    const writer = protobuf.Writer.create();
    if (pbf.Links != null) {
        for(let i = 0; i < pbf.Links.length; i++){
            PBLink.encode(pbf.Links[i], writer.uint32(18).fork()).ldelim();
        }
    }
    if (pbf.Data != null) {
        writer.uint32(10).bytes(pbf.Data);
    }
    return writer.finish();
}
}),
"[project]/node_modules/ipld-dag-pb/src/genCid.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const CID = __turbopack_context__.r("[project]/node_modules/cids/src/index.js [app-client] (ecmascript)");
const multicodec = __turbopack_context__.r("[project]/node_modules/multicodec/src/index.js [app-client] (ecmascript)");
const multihashing = __turbopack_context__.r("[project]/node_modules/multihashing-async/src/index.js [app-client] (ecmascript)");
const { multihash } = multihashing;
const codec = multicodec.DAG_PB;
const defaultHashAlg = multihash.names['sha2-256'];
/**
 * @typedef {object} GenCIDOptions - Options to create the CID
 * @property {CID.CIDVersion} [cidVersion=1] - CID version number
 * @property {multihashing.multihash.HashCode} [hashAlg=multihash.names['sha2-256']] - Defaults to the defaultHashAlg of the format
 */ /**
 * Calculate the CID of the binary blob.
 *
 * @param {Uint8Array} binaryBlob - Encoded IPLD Node
 * @param {GenCIDOptions} [userOptions] - Options to create the CID
 */ const cid = async (binaryBlob, userOptions = {})=>{
    const options = {
        cidVersion: userOptions.cidVersion == null ? 1 : userOptions.cidVersion,
        hashAlg: userOptions.hashAlg == null ? defaultHashAlg : userOptions.hashAlg
    };
    const hashName = multihash.codes[options.hashAlg];
    const hash = await multihashing(binaryBlob, hashName);
    const codecName = multicodec.getNameFromCode(codec);
    const cid = new CID(options.cidVersion, codecName, hash);
    return cid;
};
module.exports = {
    codec,
    defaultHashAlg,
    cid
};
}),
"[project]/node_modules/ipld-dag-pb/src/dag-node/toDagLink.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const DAGLink = __turbopack_context__.r("[project]/node_modules/ipld-dag-pb/src/dag-link/dagLink.js [app-client] (ecmascript)");
const genCid = __turbopack_context__.r("[project]/node_modules/ipld-dag-pb/src/genCid.js [app-client] (ecmascript)");
/**
 * toDAGLink converts a DAGNode to a DAGLink
 *
 * @typedef {import('../genCid').GenCIDOptions} GenCIDOptions
 *
 * @typedef {object} ToDagLinkExtraOptions
 * @property {string} [name]
 *
 * @typedef {GenCIDOptions & ToDagLinkExtraOptions} ToDagLinkOptions
 *
 * @param {import('./dagNode')} node
 * @param {ToDagLinkOptions} options
 */ const toDAGLink = async (node, options = {})=>{
    const buf = node.serialize();
    const nodeCid = await genCid.cid(buf, options);
    return new DAGLink(options.name || '', node.size, nodeCid);
};
module.exports = toDAGLink;
}),
"[project]/node_modules/ipld-dag-pb/src/dag-node/addLink.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const sortLinks = __turbopack_context__.r("[project]/node_modules/ipld-dag-pb/src/dag-node/sortLinks.js [app-client] (ecmascript)");
const DAGLink = __turbopack_context__.r("[project]/node_modules/ipld-dag-pb/src/dag-link/dagLink.js [app-client] (ecmascript)");
/**
 * @typedef {import('./dagNode')} DAGNode
 * @typedef {import('../types')} DAGLinkLike
 */ /**
 * @param {*} link
 * @returns {DAGLink}
 */ const asDAGLink = (link)=>{
    if (link instanceof DAGLink) {
        // It's a DAGLink instance
        // no need to do anything
        return link;
    }
    // DAGNode.isDagNode() would be more appropriate here, but it can't be used
    // as it would lead to circular dependencies as `addLink` is called from
    // within the DAGNode object.
    if (!('cid' in link || 'hash' in link || 'Hash' in link || 'multihash' in link)) {
        throw new Error('Link must be a DAGLink or DAGLink-like. Convert the DAGNode into a DAGLink via `node.toDAGLink()`.');
    }
    // It's a Object with name, multihash/hash/cid and size
    // @ts-ignore
    return new DAGLink(link.Name || link.name, link.Tsize || link.size, link.Hash || link.multihash || link.hash || link.cid);
};
/**
 * @param {DAGNode} node
 * @param {DAGLink | DAGLinkLike} link
 */ const addLink = (node, link)=>{
    const dagLink = asDAGLink(link);
    node.Links.push(dagLink);
    sortLinks(node.Links);
};
module.exports = addLink;
}),
"[project]/node_modules/ipld-dag-pb/src/dag-node/rmLink.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const CID = __turbopack_context__.r("[project]/node_modules/cids/src/index.js [app-client] (ecmascript)");
const uint8ArrayEquals = __turbopack_context__.r("[project]/node_modules/ipld-dag-pb/node_modules/uint8arrays/equals.js [app-client] (ecmascript)");
/**
 * @typedef {import('../dag-link/dagLink')} DAGLink
 */ /**
 *
 * @param {import('./dagNode')} dagNode
 * @param {string | CID | Uint8Array | DAGLink} nameOrCid
 */ const rmLink = (dagNode, nameOrCid)=>{
    let predicate = null;
    // It's a name
    if (typeof nameOrCid === 'string') {
        predicate = (/** @type {DAGLink} */ link)=>link.Name === nameOrCid;
    } else if (nameOrCid instanceof Uint8Array) {
        predicate = (/** @type {DAGLink} */ link)=>uint8ArrayEquals(link.Hash.bytes, nameOrCid);
    } else if (CID.isCID(nameOrCid)) {
        predicate = (/** @type {DAGLink} */ link)=>uint8ArrayEquals(link.Hash.bytes, nameOrCid.bytes);
    }
    if (predicate) {
        const links = dagNode.Links;
        let index = 0;
        while(index < links.length){
            const link = links[index];
            if (predicate(link)) {
                links.splice(index, 1);
            } else {
                index++;
            }
        }
    } else {
        throw new Error('second arg needs to be a name or CID');
    }
};
module.exports = rmLink;
}),
"[project]/node_modules/ipld-dag-pb/src/dag-node/dagNode.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const sortLinks = __turbopack_context__.r("[project]/node_modules/ipld-dag-pb/src/dag-node/sortLinks.js [app-client] (ecmascript)");
const DAGLink = __turbopack_context__.r("[project]/node_modules/ipld-dag-pb/src/dag-link/dagLink.js [app-client] (ecmascript)");
const { createDagLinkFromB58EncodedHash } = __turbopack_context__.r("[project]/node_modules/ipld-dag-pb/src/dag-link/util.js [app-client] (ecmascript)");
const { serializeDAGNode } = __turbopack_context__.r("[project]/node_modules/ipld-dag-pb/src/serialize.js [app-client] (ecmascript)");
const toDAGLink = __turbopack_context__.r("[project]/node_modules/ipld-dag-pb/src/dag-node/toDagLink.js [app-client] (ecmascript)");
const addLink = __turbopack_context__.r("[project]/node_modules/ipld-dag-pb/src/dag-node/addLink.js [app-client] (ecmascript)");
const rmLink = __turbopack_context__.r("[project]/node_modules/ipld-dag-pb/src/dag-node/rmLink.js [app-client] (ecmascript)");
const uint8ArrayFromString = __turbopack_context__.r("[project]/node_modules/ipld-dag-pb/node_modules/uint8arrays/from-string.js [app-client] (ecmascript)");
const uint8ArrayToString = __turbopack_context__.r("[project]/node_modules/ipld-dag-pb/node_modules/uint8arrays/to-string.js [app-client] (ecmascript)");
/**
 * @typedef {import('cids')} CID
 * @typedef {import('../types').DAGLinkLike} DAGLinkLike
 */ class DAGNode {
    /**
   *@param {Uint8Array | string} [data]
   * @param {(DAGLink | DAGLinkLike)[]} links
   * @param {number | null} [serializedSize]
   */ constructor(data, links = [], serializedSize = null){
        if (!data) {
            data = new Uint8Array(0);
        }
        if (typeof data === 'string') {
            data = uint8ArrayFromString(data);
        }
        if (!(data instanceof Uint8Array)) {
            throw new Error('Passed \'data\' is not a Uint8Array or a String!');
        }
        if (serializedSize !== null && typeof serializedSize !== 'number') {
            throw new Error('Passed \'serializedSize\' must be a number!');
        }
        const sortedLinks = links.map((link)=>{
            return link instanceof DAGLink ? link : createDagLinkFromB58EncodedHash(link);
        });
        sortLinks(sortedLinks);
        this.Data = data;
        this.Links = sortedLinks;
        Object.defineProperties(this, {
            _serializedSize: {
                value: serializedSize,
                writable: true,
                enumerable: false
            },
            _size: {
                value: null,
                writable: true,
                enumerable: false
            }
        });
    }
    toJSON() {
        if (!this._json) {
            this._json = Object.freeze({
                data: this.Data,
                links: this.Links.map((l)=>l.toJSON()),
                size: this.size
            });
        }
        return Object.assign({}, this._json);
    }
    toString() {
        return `DAGNode <data: "${uint8ArrayToString(this.Data, 'base64urlpad')}", links: ${this.Links.length}, size: ${this.size}>`;
    }
    _invalidateCached() {
        this._serializedSize = null;
        this._size = null;
    }
    /**
   * @param {DAGLink | import('../types').DAGLinkLike} link
   */ addLink(link) {
        this._invalidateCached();
        return addLink(this, link);
    }
    /**
   * @param {DAGLink | string | CID} link
   */ rmLink(link) {
        this._invalidateCached();
        return rmLink(this, link);
    }
    /**
   * @param {import('./toDagLink').ToDagLinkOptions} [options]
   */ toDAGLink(options) {
        return toDAGLink(this, options);
    }
    serialize() {
        const buf = serializeDAGNode(this);
        this._serializedSize = buf.length;
        return buf;
    }
    get size() {
        if (this._size == null) {
            let serializedSize;
            if (serializedSize == null) {
                this._serializedSize = this.serialize().length;
                serializedSize = this._serializedSize;
            }
            this._size = this.Links.reduce((sum, l)=>sum + l.Tsize, serializedSize);
        }
        return this._size;
    }
    set size(size) {
        throw new Error("Can't set property: 'size' is immutable");
    }
}
module.exports = DAGNode;
}),
"[project]/node_modules/ipld-dag-pb/src/util.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { PBNode } = __turbopack_context__.r("[project]/node_modules/ipld-dag-pb/src/dag.js [app-client] (ecmascript)");
const DAGLink = __turbopack_context__.r("[project]/node_modules/ipld-dag-pb/src/dag-link/dagLink.js [app-client] (ecmascript)");
const DAGNode = __turbopack_context__.r("[project]/node_modules/ipld-dag-pb/src/dag-node/dagNode.js [app-client] (ecmascript)");
const { serializeDAGNode, serializeDAGNodeLike } = __turbopack_context__.r("[project]/node_modules/ipld-dag-pb/src/serialize.js [app-client] (ecmascript)");
const genCid = __turbopack_context__.r("[project]/node_modules/ipld-dag-pb/src/genCid.js [app-client] (ecmascript)");
/**
 * @typedef {import('./types').DAGLinkLike} DAGLinkLike
 */ /**
 * Calculate the CID of the binary blob
 *
 * @param {Uint8Array} binaryBlob - Encoded IPLD Node
 * @param {import('./genCid').GenCIDOptions} [userOptions] - Options to create the CID
 */ const cid = (binaryBlob, userOptions)=>{
    return genCid.cid(binaryBlob, userOptions);
};
/**
 * Serialize internal representation into a binary PB block
 *
 * @param {DAGNode | { Data?: Uint8Array, Links?: (DAGLink | DAGLinkLike)[]}} node
 */ const serialize = (node)=>{
    if (node instanceof DAGNode) {
        return serializeDAGNode(node);
    } else {
        return serializeDAGNodeLike(node.Data, node.Links);
    }
};
/**
 * Deserialize PB block into the internal representation.
 *
 * @param {Uint8Array} buffer - Binary representation of a PB block
 */ const deserialize = (buffer)=>{
    const message = PBNode.decode(buffer);
    const pbn = PBNode.toObject(message, {
        defaults: false,
        arrays: true,
        longs: Number,
        objects: false
    });
    /** @type {DAGLink[]} */ const links = pbn.Links.map((/** @type {DAGLinkLike} */ link)=>{
        // @ts-ignore
        return new DAGLink(link.Name, link.Tsize, link.Hash);
    });
    const data = pbn.Data == null ? new Uint8Array(0) : pbn.Data;
    return new DAGNode(data, links, buffer.byteLength);
};
module.exports = {
    codec: genCid.codec,
    defaultHashAlg: genCid.defaultHashAlg,
    serialize,
    deserialize,
    cid
};
}),
"[project]/node_modules/ipld-dag-pb/src/resolver.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const CID = __turbopack_context__.r("[project]/node_modules/cids/src/index.js [app-client] (ecmascript)");
const util = __turbopack_context__.r("[project]/node_modules/ipld-dag-pb/src/util.js [app-client] (ecmascript)");
/**
 * Resolves a path within a PB block.
 *
 * If the path resolves half-way to a link, then the `remainderPath` is the part
 * after the link that can be used for further resolving
 *
 * Returns the value or a link and the partial missing path. This way the
 * IPLD Resolver can fetch the link and continue to resolve.
 *
 * @param {Uint8Array} binaryBlob - Binary representation of a PB block
 * @param {string} [path='/'] - Path that should be resolved
 */ exports.resolve = (binaryBlob, path = '/')=>{
    let node = util.deserialize(binaryBlob);
    const parts = path.split('/').filter(Boolean);
    while(parts.length){
        const key = parts.shift();
        // @ts-ignore
        if (node[key] === undefined) {
            // There might be a matching named link
            for (const link of node.Links){
                if (link.Name === key) {
                    return {
                        value: link.Hash,
                        remainderPath: parts.join('/')
                    };
                }
            }
            // There wasn't even a matching named link
            throw new Error(`Object has no property '${key}'`);
        }
        // @ts-ignore
        node = node[key];
        if (CID.isCID(node)) {
            return {
                value: node,
                remainderPath: parts.join('/')
            };
        }
    }
    return {
        value: node,
        remainderPath: ''
    };
};
/**
 * Return all available paths of a block.
 *
 * @generator
 * @param {Uint8Array} binaryBlob - Binary representation of a PB block
 * @yields {string} - A single path
 */ exports.tree = function*(binaryBlob) {
    const node = util.deserialize(binaryBlob);
    // There is always a `Data` and `Links` property
    yield 'Data';
    yield 'Links';
    for(let ii = 0; ii < node.Links.length; ii++){
        yield `Links/${ii}`;
        yield `Links/${ii}/Name`;
        yield `Links/${ii}/Tsize`;
        yield `Links/${ii}/Hash`;
    }
};
}),
"[project]/node_modules/ipld-dag-pb/src/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const resolver = __turbopack_context__.r("[project]/node_modules/ipld-dag-pb/src/resolver.js [app-client] (ecmascript)");
const util = __turbopack_context__.r("[project]/node_modules/ipld-dag-pb/src/util.js [app-client] (ecmascript)");
const DAGNodeClass = __turbopack_context__.r("[project]/node_modules/ipld-dag-pb/src/dag-node/dagNode.js [app-client] (ecmascript)");
const DAGLinkClass = __turbopack_context__.r("[project]/node_modules/ipld-dag-pb/src/dag-link/dagLink.js [app-client] (ecmascript)");
/**
 * @typedef {import('./types').DAGLinkLike} DAGLinkLike
 * @typedef {import('./types').DAGNodeLike} DAGNodeLike
 * @typedef {import('./dag-node/dagNode')} DAGNode
 * @typedef {import('./dag-link/dagLink')} DAGLink
 */ /**
 * @type {import('./types').DAGNodeFormat}
 */ const format = {
    DAGNode: DAGNodeClass,
    DAGLink: DAGLinkClass,
    /**
   * Functions to fulfil IPLD Format interface
   * https://github.com/ipld/interface-ipld-format
   */ resolver,
    util,
    codec: util.codec,
    defaultHashAlg: util.defaultHashAlg
};
module.exports = format;
}),
"[project]/node_modules/ipfs-unixfs-importer/node_modules/uint8arrays/util/bases.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { bases } = __turbopack_context__.r("[project]/node_modules/multiformats/esm/src/basics.js [app-client] (ecmascript)");
/**
 * @typedef {import('multiformats/bases/interface').MultibaseCodec<any>} MultibaseCodec
 */ /**
 * @param {string} name
 * @param {string} prefix
 * @param {(buf: Uint8Array) => string} encode
 * @param {(str: string) => Uint8Array} decode
 * @returns {MultibaseCodec}
 */ function createCodec(name, prefix, encode, decode) {
    return {
        name,
        prefix,
        encoder: {
            name,
            prefix,
            encode
        },
        decoder: {
            decode
        }
    };
}
const string = createCodec('utf8', 'u', (buf)=>{
    const decoder = new TextDecoder('utf8');
    return 'u' + decoder.decode(buf);
}, (str)=>{
    const encoder = new TextEncoder();
    return encoder.encode(str.substring(1));
});
const ascii = createCodec('ascii', 'a', (buf)=>{
    let string = 'a';
    for(let i = 0; i < buf.length; i++){
        string += String.fromCharCode(buf[i]);
    }
    return string;
}, (str)=>{
    str = str.substring(1);
    const buf = new Uint8Array(str.length);
    for(let i = 0; i < str.length; i++){
        buf[i] = str.charCodeAt(i);
    }
    return buf;
});
/**
 * @typedef {'utf8' | 'utf-8' | 'hex' | 'latin1' | 'ascii' | 'binary' | keyof bases } SupportedEncodings
 */ /**
 * @type {Record<SupportedEncodings, MultibaseCodec>}
 */ const BASES = {
    'utf8': string,
    'utf-8': string,
    'hex': bases.base16,
    'latin1': ascii,
    'ascii': ascii,
    'binary': ascii,
    ...bases
};
module.exports = BASES;
}),
"[project]/node_modules/ipfs-unixfs-importer/node_modules/uint8arrays/from-string.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const bases = __turbopack_context__.r("[project]/node_modules/ipfs-unixfs-importer/node_modules/uint8arrays/util/bases.js [app-client] (ecmascript)");
/**
 * @typedef {import('./util/bases').SupportedEncodings} SupportedEncodings
 */ /**
 * Create a `Uint8Array` from the passed string
 *
 * Supports `utf8`, `utf-8`, `hex`, and any encoding supported by the multiformats module.
 *
 * Also `ascii` which is similar to node's 'binary' encoding.
 *
 * @param {string} string
 * @param {SupportedEncodings} [encoding=utf8] - utf8, base16, base64, base64urlpad, etc
 * @returns {Uint8Array}
 */ function fromString(string, encoding = 'utf8') {
    const base = bases[encoding];
    if (!base) {
        throw new Error(`Unsupported encoding "${encoding}"`);
    }
    // add multibase prefix
    return base.decoder.decode(`${base.prefix}${string}`);
}
module.exports = fromString;
}),
"[project]/node_modules/ipfs-unixfs-importer/src/options.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const mergeOptions = __turbopack_context__.r("[project]/node_modules/merge-options/index.js [app-client] (ecmascript)").bind({
    ignoreUndefined: true
});
const multihashing = __turbopack_context__.r("[project]/node_modules/multihashing-async/src/index.js [app-client] (ecmascript)");
/**
 * @param {Uint8Array} buf
 */ async function hamtHashFn(buf) {
    const hash = await multihashing(buf, 'murmur3-128');
    // Multihashing inserts preamble of 2 bytes. Remove it.
    // Also, murmur3 outputs 128 bit but, accidentally, IPFS Go's
    // implementation only uses the first 64, so we must do the same
    // for parity..
    const justHash = hash.slice(2, 10);
    const length = justHash.length;
    const result = new Uint8Array(length);
    // TODO: invert buffer because that's how Go impl does it
    for(let i = 0; i < length; i++){
        result[length - i - 1] = justHash[i];
    }
    return result;
}
/**
 * @typedef {import('./types').UserImporterOptions} UserImporterOptions
 * @typedef {import('./types').ImporterOptions} ImporterOptions
 */ /**
 * @type {ImporterOptions}
 */ const defaultOptions = {
    chunker: 'fixed',
    strategy: 'balanced',
    rawLeaves: false,
    onlyHash: false,
    reduceSingleLeafToSelf: true,
    hashAlg: 'sha2-256',
    leafType: 'file',
    cidVersion: 0,
    progress: ()=>()=>{},
    shardSplitThreshold: 1000,
    fileImportConcurrency: 50,
    blockWriteConcurrency: 10,
    minChunkSize: 262144,
    maxChunkSize: 262144,
    avgChunkSize: 262144,
    window: 16,
    // FIXME: This number is too big for JavaScript
    // https://github.com/ipfs/go-ipfs-chunker/blob/d0125832512163708c0804a3cda060e21acddae4/rabin.go#L11
    polynomial: 17437180132763653,
    maxChildrenPerNode: 174,
    layerRepeat: 4,
    wrapWithDirectory: false,
    pin: false,
    recursive: false,
    hidden: false,
    preload: false,
    timeout: undefined,
    hamtHashFn,
    hamtHashCode: 0x22,
    hamtBucketBits: 8
};
/**
 * @param {UserImporterOptions} options
 * @returns {ImporterOptions}
 */ module.exports = function(options = {}) {
    return mergeOptions(defaultOptions, options);
};
}),
"[project]/node_modules/ipfs-unixfs-importer/src/utils/persist.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const mh = __turbopack_context__.r("[project]/node_modules/multihashing-async/src/index.js [app-client] (ecmascript)");
const CID = __turbopack_context__.r("[project]/node_modules/cids/src/index.js [app-client] (ecmascript)");
/**
 * @param {Uint8Array} buffer
 * @param {import('../types').BlockAPI} block
 * @param {import('../types').PersistOptions} options
 */ const persist = async (buffer, block, options)=>{
    if (!options.codec) {
        options.codec = 'dag-pb';
    }
    if (!options.cidVersion) {
        options.cidVersion = 0;
    }
    if (!options.hashAlg) {
        options.hashAlg = 'sha2-256';
    }
    if (options.hashAlg !== 'sha2-256') {
        options.cidVersion = 1;
    }
    const multihash = await mh(buffer, options.hashAlg);
    const cid = new CID(options.cidVersion, options.codec, multihash);
    if (!options.onlyHash) {
        // @ts-ignore block api takes uint8arrays or blocks but is missing from typedefs
        await block.put(buffer, {
            // @ts-ignore pin option is missing from block api typedefs
            pin: options.pin,
            preload: options.preload,
            timeout: options.timeout,
            cid
        });
    }
    return cid;
};
module.exports = persist;
}),
"[project]/node_modules/ipfs-unixfs-importer/src/dag-builder/dir.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { UnixFS } = __turbopack_context__.r("[project]/node_modules/ipfs-unixfs/src/index.js [app-client] (ecmascript)");
const persist = __turbopack_context__.r("[project]/node_modules/ipfs-unixfs-importer/src/utils/persist.js [app-client] (ecmascript)");
const { DAGNode } = __turbopack_context__.r("[project]/node_modules/ipld-dag-pb/src/index.js [app-client] (ecmascript)");
/**
 * @typedef {import('../types').Directory} Directory
 */ /**
 * @type {import('../types').UnixFSV1DagBuilder<Directory>}
 */ const dirBuilder = async (item, block, options)=>{
    const unixfs = new UnixFS({
        type: 'directory',
        mtime: item.mtime,
        mode: item.mode
    });
    const buffer = new DAGNode(unixfs.marshal()).serialize();
    const cid = await persist(buffer, block, options);
    const path = item.path;
    return {
        cid,
        path,
        unixfs,
        size: buffer.length
    };
};
module.exports = dirBuilder;
}),
"[project]/node_modules/ipfs-unixfs-importer/src/dag-builder/file/flat.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const all = __turbopack_context__.r("[project]/node_modules/it-all/index.js [app-client] (ecmascript)");
/**
 * @type {import('../../types').FileDAGBuilder}
 */ module.exports = async function(source, reduce) {
    return reduce(await all(source));
};
}),
"[project]/node_modules/ipfs-unixfs-importer/src/dag-builder/file/balanced.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const batch = __turbopack_context__.r("[project]/node_modules/it-batch/index.js [app-client] (ecmascript)");
/**
 * @typedef {import('../../types').FileDAGBuilder} FileDAGBuilder
 */ /**
 * @type {FileDAGBuilder}
 */ function balanced(source, reduce, options) {
    return reduceToParents(source, reduce, options);
}
/**
 * @type {FileDAGBuilder}
 */ async function reduceToParents(source, reduce, options) {
    const roots = [];
    for await (const chunked of batch(source, options.maxChildrenPerNode)){
        roots.push(await reduce(chunked));
    }
    if (roots.length > 1) {
        return reduceToParents(roots, reduce, options);
    }
    return roots[0];
}
module.exports = balanced;
}),
"[project]/node_modules/ipfs-unixfs-importer/src/dag-builder/file/trickle.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const batch = __turbopack_context__.r("[project]/node_modules/it-batch/index.js [app-client] (ecmascript)");
/**
 * @typedef {import('cids')} CID
 * @typedef {import('ipfs-unixfs').UnixFS} UnixFS
 * @typedef {import('../../types').ImporterOptions} ImporterOptions
 * @typedef {import('../../types').InProgressImportResult} InProgressImportResult
 * @typedef {import('../../types').TrickleDagNode} TrickleDagNode
 * @typedef {import('../../types').Reducer} Reducer
 * @typedef {import('../../types').FileDAGBuilder} FileDAGBuilder
 */ /**
 * @type {FileDAGBuilder}
 */ module.exports = async function trickleStream(source, reduce, options) {
    const root = new Root(options.layerRepeat);
    let iteration = 0;
    let maxDepth = 1;
    /** @type {SubTree} */ let subTree = root;
    for await (const layer of batch(source, options.maxChildrenPerNode)){
        if (subTree.isFull()) {
            if (subTree !== root) {
                root.addChild(await subTree.reduce(reduce));
            }
            if (iteration && iteration % options.layerRepeat === 0) {
                maxDepth++;
            }
            subTree = new SubTree(maxDepth, options.layerRepeat, iteration);
            iteration++;
        }
        subTree.append(layer);
    }
    if (subTree && subTree !== root) {
        root.addChild(await subTree.reduce(reduce));
    }
    return root.reduce(reduce);
};
class SubTree {
    /**
   * @param {number} maxDepth
   * @param {number} layerRepeat
   * @param {number} [iteration=0]
   */ constructor(maxDepth, layerRepeat, iteration = 0){
        this.maxDepth = maxDepth;
        this.layerRepeat = layerRepeat;
        this.currentDepth = 1;
        this.iteration = iteration;
        /** @type {TrickleDagNode} */ this.root = this.node = this.parent = {
            children: [],
            depth: this.currentDepth,
            maxDepth,
            maxChildren: (this.maxDepth - this.currentDepth) * this.layerRepeat
        };
    }
    isFull() {
        if (!this.root.data) {
            return false;
        }
        if (this.currentDepth < this.maxDepth && this.node.maxChildren) {
            // can descend
            this._addNextNodeToParent(this.node);
            return false;
        }
        // try to find new node from node.parent
        const distantRelative = this._findParent(this.node, this.currentDepth);
        if (distantRelative) {
            this._addNextNodeToParent(distantRelative);
            return false;
        }
        return true;
    }
    /**
   * @param {TrickleDagNode} parent
   */ _addNextNodeToParent(parent) {
        this.parent = parent;
        // find site for new node
        const nextNode = {
            children: [],
            depth: parent.depth + 1,
            parent,
            maxDepth: this.maxDepth,
            maxChildren: Math.floor(parent.children.length / this.layerRepeat) * this.layerRepeat
        };
        // @ts-ignore
        parent.children.push(nextNode);
        this.currentDepth = nextNode.depth;
        this.node = nextNode;
    }
    /**
   *
   * @param {InProgressImportResult[]} layer
   */ append(layer) {
        this.node.data = layer;
    }
    /**
   * @param {Reducer} reduce
   */ reduce(reduce) {
        return this._reduce(this.root, reduce);
    }
    /**
   * @param {TrickleDagNode} node
   * @param {Reducer} reduce
   * @returns {Promise<InProgressImportResult>}
   */ async _reduce(node, reduce) {
        /** @type {InProgressImportResult[]} */ let children = [];
        if (node.children.length) {
            children = await Promise.all(node.children// @ts-ignore
            .filter((child)=>child.data)// @ts-ignore
            .map((child)=>this._reduce(child, reduce)));
        }
        return reduce((node.data || []).concat(children));
    }
    /**
   * @param {TrickleDagNode} node
   * @param {number} depth
   * @returns {TrickleDagNode | undefined}
   */ _findParent(node, depth) {
        const parent = node.parent;
        if (!parent || parent.depth === 0) {
            return;
        }
        if (parent.children.length === parent.maxChildren || !parent.maxChildren) {
            // this layer is full, may be able to traverse to a different branch
            return this._findParent(parent, depth);
        }
        return parent;
    }
}
class Root extends SubTree {
    /**
   * @param {number} layerRepeat
   */ constructor(layerRepeat){
        super(0, layerRepeat);
        this.root.depth = 0;
        this.currentDepth = 1;
    }
    /**
   * @param {InProgressImportResult} child
   */ addChild(child) {
        this.root.children.push(child);
    }
    /**
   * @param {Reducer} reduce
   */ reduce(reduce) {
        return reduce((this.root.data || []).concat(this.root.children));
    }
}
}),
"[project]/node_modules/ipfs-unixfs-importer/src/dag-builder/file/buffer-importer.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { UnixFS } = __turbopack_context__.r("[project]/node_modules/ipfs-unixfs/src/index.js [app-client] (ecmascript)");
const persist = __turbopack_context__.r("[project]/node_modules/ipfs-unixfs-importer/src/utils/persist.js [app-client] (ecmascript)");
const { DAGNode } = __turbopack_context__.r("[project]/node_modules/ipld-dag-pb/src/index.js [app-client] (ecmascript)");
/**
 * @typedef {import('../../types').BufferImporter} BufferImporter
 */ /**
 * @type {BufferImporter}
 */ async function* bufferImporter(file, block, options) {
    for await (let buffer of file.content){
        yield async ()=>{
            options.progress(buffer.length, file.path);
            let unixfs;
            /** @type {import('../../types').PersistOptions} */ const opts = {
                codec: 'dag-pb',
                cidVersion: options.cidVersion,
                hashAlg: options.hashAlg,
                onlyHash: options.onlyHash
            };
            if (options.rawLeaves) {
                opts.codec = 'raw';
                opts.cidVersion = 1;
            } else {
                unixfs = new UnixFS({
                    type: options.leafType,
                    data: buffer,
                    mtime: file.mtime,
                    mode: file.mode
                });
                buffer = new DAGNode(unixfs.marshal()).serialize();
            }
            return {
                cid: await persist(buffer, block, opts),
                unixfs,
                size: buffer.length
            };
        };
    }
}
module.exports = bufferImporter;
}),
"[project]/node_modules/ipfs-unixfs-importer/src/dag-builder/file/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const errCode = __turbopack_context__.r("[project]/node_modules/err-code/index.js [app-client] (ecmascript)");
const { UnixFS } = __turbopack_context__.r("[project]/node_modules/ipfs-unixfs/src/index.js [app-client] (ecmascript)");
const persist = __turbopack_context__.r("[project]/node_modules/ipfs-unixfs-importer/src/utils/persist.js [app-client] (ecmascript)");
const { DAGNode, DAGLink } = __turbopack_context__.r("[project]/node_modules/ipld-dag-pb/src/index.js [app-client] (ecmascript)");
const parallelBatch = __turbopack_context__.r("[project]/node_modules/it-parallel-batch/index.js [app-client] (ecmascript)");
const mh = __turbopack_context__.r("[project]/node_modules/multihashing-async/src/index.js [app-client] (ecmascript)").multihash;
/**
 * @typedef {import('../../types').BlockAPI} BlockAPI
 * @typedef {import('../../types').File} File
 * @typedef {import('../../types').ImporterOptions} ImporterOptions
 * @typedef {import('../../types').Reducer} Reducer
 * @typedef {import('../../types').DAGBuilder} DAGBuilder
 * @typedef {import('../../types').FileDAGBuilder} FileDAGBuilder
 */ /**
 * @type {{ [key: string]: FileDAGBuilder}}
 */ const dagBuilders = {
    flat: __turbopack_context__.r("[project]/node_modules/ipfs-unixfs-importer/src/dag-builder/file/flat.js [app-client] (ecmascript)"),
    balanced: __turbopack_context__.r("[project]/node_modules/ipfs-unixfs-importer/src/dag-builder/file/balanced.js [app-client] (ecmascript)"),
    trickle: __turbopack_context__.r("[project]/node_modules/ipfs-unixfs-importer/src/dag-builder/file/trickle.js [app-client] (ecmascript)")
};
/**
 * @param {File} file
 * @param {BlockAPI} block
 * @param {ImporterOptions} options
 */ async function* buildFileBatch(file, block, options) {
    let count = -1;
    let previous;
    let bufferImporter;
    if (typeof options.bufferImporter === 'function') {
        bufferImporter = options.bufferImporter;
    } else {
        bufferImporter = __turbopack_context__.r("[project]/node_modules/ipfs-unixfs-importer/src/dag-builder/file/buffer-importer.js [app-client] (ecmascript)");
    }
    for await (const entry of parallelBatch(bufferImporter(file, block, options), options.blockWriteConcurrency)){
        count++;
        if (count === 0) {
            previous = entry;
            continue;
        } else if (count === 1 && previous) {
            yield previous;
            previous = null;
        }
        yield entry;
    }
    if (previous) {
        previous.single = true;
        yield previous;
    }
}
/**
 * @param {File} file
 * @param {BlockAPI} block
 * @param {ImporterOptions} options
 */ const reduce = (file, block, options)=>{
    /**
   * @type {Reducer}
   */ async function reducer(leaves) {
        if (leaves.length === 1 && leaves[0].single && options.reduceSingleLeafToSelf) {
            const leaf = leaves[0];
            if (leaf.cid.codec === 'raw' && (file.mtime !== undefined || file.mode !== undefined)) {
                // only one leaf node which is a buffer - we have metadata so convert it into a
                // UnixFS entry otherwise we'll have nowhere to store the metadata
                let { data: buffer } = await block.get(leaf.cid, options);
                leaf.unixfs = new UnixFS({
                    type: 'file',
                    mtime: file.mtime,
                    mode: file.mode,
                    data: buffer
                });
                const multihash = mh.decode(leaf.cid.multihash);
                buffer = new DAGNode(leaf.unixfs.marshal()).serialize();
                leaf.cid = await persist(buffer, block, {
                    ...options,
                    codec: 'dag-pb',
                    hashAlg: multihash.name,
                    cidVersion: options.cidVersion
                });
                leaf.size = buffer.length;
            }
            return {
                cid: leaf.cid,
                path: file.path,
                unixfs: leaf.unixfs,
                size: leaf.size
            };
        }
        // create a parent node and add all the leaves
        const f = new UnixFS({
            type: 'file',
            mtime: file.mtime,
            mode: file.mode
        });
        const links = leaves.filter((leaf)=>{
            if (leaf.cid.codec === 'raw' && leaf.size) {
                return true;
            }
            if (leaf.unixfs && !leaf.unixfs.data && leaf.unixfs.fileSize()) {
                return true;
            }
            return Boolean(leaf.unixfs && leaf.unixfs.data && leaf.unixfs.data.length);
        }).map((leaf)=>{
            if (leaf.cid.codec === 'raw') {
                // node is a leaf buffer
                f.addBlockSize(leaf.size);
                return new DAGLink('', leaf.size, leaf.cid);
            }
            if (!leaf.unixfs || !leaf.unixfs.data) {
                // node is an intermediate node
                f.addBlockSize(leaf.unixfs && leaf.unixfs.fileSize() || 0);
            } else {
                // node is a unixfs 'file' leaf node
                f.addBlockSize(leaf.unixfs.data.length);
            }
            return new DAGLink('', leaf.size, leaf.cid);
        });
        const node = new DAGNode(f.marshal(), links);
        const buffer = node.serialize();
        const cid = await persist(buffer, block, options);
        return {
            cid,
            path: file.path,
            unixfs: f,
            size: buffer.length + node.Links.reduce((acc, curr)=>acc + curr.Tsize, 0)
        };
    }
    return reducer;
};
/**
 * @type {import('../../types').UnixFSV1DagBuilder<File>}
 */ function fileBuilder(file, block, options) {
    const dagBuilder = dagBuilders[options.strategy];
    if (!dagBuilder) {
        throw errCode(new Error(`Unknown importer build strategy name: ${options.strategy}`), 'ERR_BAD_STRATEGY');
    }
    return dagBuilder(buildFileBatch(file, block, options), reduce(file, block, options), options);
}
module.exports = fileBuilder;
}),
"[project]/node_modules/ipfs-unixfs-importer/src/chunker/fixed-size.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// @ts-ignore
const BufferList = __turbopack_context__.r("[project]/node_modules/bl/BufferList.js [app-client] (ecmascript)");
/**
 * @type {import('../types').Chunker}
 */ module.exports = async function* fixedSizeChunker(source, options) {
    let bl = new BufferList();
    let currentLength = 0;
    let emitted = false;
    const maxChunkSize = options.maxChunkSize;
    for await (const buffer of source){
        bl.append(buffer);
        currentLength += buffer.length;
        while(currentLength >= maxChunkSize){
            yield bl.slice(0, maxChunkSize);
            emitted = true;
            // throw away consumed bytes
            if (maxChunkSize === bl.length) {
                bl = new BufferList();
                currentLength = 0;
            } else {
                const newBl = new BufferList();
                newBl.append(bl.shallowSlice(maxChunkSize));
                bl = newBl;
                // update our offset
                currentLength -= maxChunkSize;
            }
        }
    }
    if (!emitted || currentLength) {
        // return any remaining bytes or an empty buffer
        yield bl.slice(0, currentLength);
    }
};
}),
"[project]/node_modules/ipfs-unixfs-importer/src/chunker/rabin.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// @ts-ignore
const BufferList = __turbopack_context__.r("[project]/node_modules/bl/BufferList.js [app-client] (ecmascript)");
// @ts-ignore
const { create } = __turbopack_context__.r("[project]/node_modules/rabin-wasm/src/index.js [app-client] (ecmascript)");
const errcode = __turbopack_context__.r("[project]/node_modules/err-code/index.js [app-client] (ecmascript)");
/**
 * @typedef {object} RabinOptions
 * @property {number} min
 * @property {number} max
 * @property {number} bits
 * @property {number} window
 * @property {number} polynomial
 */ /**
 * @type {import('../types').Chunker}
 */ module.exports = async function* rabinChunker(source, options) {
    let min, max, avg;
    if (options.minChunkSize && options.maxChunkSize && options.avgChunkSize) {
        avg = options.avgChunkSize;
        min = options.minChunkSize;
        max = options.maxChunkSize;
    } else if (!options.avgChunkSize) {
        throw errcode(new Error('please specify an average chunk size'), 'ERR_INVALID_AVG_CHUNK_SIZE');
    } else {
        avg = options.avgChunkSize;
        min = avg / 3;
        max = avg + avg / 2;
    }
    // validate min/max/avg in the same way as go
    if (min < 16) {
        throw errcode(new Error('rabin min must be greater than 16'), 'ERR_INVALID_MIN_CHUNK_SIZE');
    }
    if (max < min) {
        max = min;
    }
    if (avg < min) {
        avg = min;
    }
    const sizepow = Math.floor(Math.log2(avg));
    for await (const chunk of rabin(source, {
        min: min,
        max: max,
        bits: sizepow,
        window: options.window,
        polynomial: options.polynomial
    })){
        yield chunk;
    }
};
/**
 * @param {AsyncIterable<Uint8Array>} source
 * @param {RabinOptions} options
 */ async function* rabin(source, options) {
    const r = await create(options.bits, options.min, options.max, options.window);
    const buffers = new BufferList();
    for await (const chunk of source){
        buffers.append(chunk);
        const sizes = r.fingerprint(chunk);
        for(let i = 0; i < sizes.length; i++){
            const size = sizes[i];
            const buf = buffers.slice(0, size);
            buffers.consume(size);
            yield buf;
        }
    }
    if (buffers.length) {
        yield buffers.slice(0);
    }
}
}),
"[project]/node_modules/ipfs-unixfs-importer/src/dag-builder/validate-chunks.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const errCode = __turbopack_context__.r("[project]/node_modules/err-code/index.js [app-client] (ecmascript)");
const uint8ArrayFromString = __turbopack_context__.r("[project]/node_modules/ipfs-unixfs-importer/node_modules/uint8arrays/from-string.js [app-client] (ecmascript)");
/**
 * @typedef {import('../types').ChunkValidator} ChunkValidator
 */ /**
 * @type {ChunkValidator}
 */ async function* validateChunks(source) {
    for await (const content of source){
        if (content.length === undefined) {
            throw errCode(new Error('Content was invalid'), 'ERR_INVALID_CONTENT');
        }
        if (typeof content === 'string' || content instanceof String) {
            yield uint8ArrayFromString(content.toString());
        } else if (Array.isArray(content)) {
            yield Uint8Array.from(content);
        } else if (content instanceof Uint8Array) {
            yield content;
        } else {
            throw errCode(new Error('Content was invalid'), 'ERR_INVALID_CONTENT');
        }
    }
}
module.exports = validateChunks;
}),
"[project]/node_modules/ipfs-unixfs-importer/src/dag-builder/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const dirBuilder = __turbopack_context__.r("[project]/node_modules/ipfs-unixfs-importer/src/dag-builder/dir.js [app-client] (ecmascript)");
const fileBuilder = __turbopack_context__.r("[project]/node_modules/ipfs-unixfs-importer/src/dag-builder/file/index.js [app-client] (ecmascript)");
const errCode = __turbopack_context__.r("[project]/node_modules/err-code/index.js [app-client] (ecmascript)");
/**
 * @typedef {import('../types').File} File
 * @typedef {import('../types').Directory} Directory
 * @typedef {import('../types').DAGBuilder} DAGBuilder
 * @typedef {import('../types').Chunker} Chunker
 * @typedef {import('../types').ChunkValidator} ChunkValidator
 */ /**
 * @param {any} thing
 * @returns {thing is Iterable<any>}
 */ function isIterable(thing) {
    return Symbol.iterator in thing;
}
/**
 * @param {any} thing
 * @returns {thing is AsyncIterable<any>}
 */ function isAsyncIterable(thing) {
    return Symbol.asyncIterator in thing;
}
/**
 * @param {Uint8Array | AsyncIterable<Uint8Array> | Iterable<Uint8Array>} content
 * @returns {AsyncIterable<Uint8Array>}
 */ function contentAsAsyncIterable(content) {
    try {
        if (content instanceof Uint8Array) {
            return async function*() {
                yield content;
            }();
        } else if (isIterable(content)) {
            return async function*() {
                yield* content;
            }();
        } else if (isAsyncIterable(content)) {
            return content;
        }
    } catch  {
        throw errCode(new Error('Content was invalid'), 'ERR_INVALID_CONTENT');
    }
    throw errCode(new Error('Content was invalid'), 'ERR_INVALID_CONTENT');
}
/**
 * @type {DAGBuilder}
 */ async function* dagBuilder(source, block, options) {
    for await (const entry of source){
        if (entry.path) {
            if (entry.path.substring(0, 2) === './') {
                options.wrapWithDirectory = true;
            }
            entry.path = entry.path.split('/').filter((path)=>path && path !== '.').join('/');
        }
        if (entry.content) {
            /**
       * @type {Chunker}
       */ let chunker;
            if (typeof options.chunker === 'function') {
                chunker = options.chunker;
            } else if (options.chunker === 'rabin') {
                chunker = __turbopack_context__.r("[project]/node_modules/ipfs-unixfs-importer/src/chunker/rabin.js [app-client] (ecmascript)");
            } else {
                chunker = __turbopack_context__.r("[project]/node_modules/ipfs-unixfs-importer/src/chunker/fixed-size.js [app-client] (ecmascript)");
            }
            /**
       * @type {ChunkValidator}
       */ let chunkValidator;
            if (typeof options.chunkValidator === 'function') {
                chunkValidator = options.chunkValidator;
            } else {
                chunkValidator = __turbopack_context__.r("[project]/node_modules/ipfs-unixfs-importer/src/dag-builder/validate-chunks.js [app-client] (ecmascript)");
            }
            /** @type {File} */ const file = {
                path: entry.path,
                mtime: entry.mtime,
                mode: entry.mode,
                content: chunker(chunkValidator(contentAsAsyncIterable(entry.content), options), options)
            };
            yield ()=>fileBuilder(file, block, options);
        } else if (entry.path) {
            /** @type {Directory} */ const dir = {
                path: entry.path,
                mtime: entry.mtime,
                mode: entry.mode
            };
            yield ()=>dirBuilder(dir, block, options);
        } else {
            throw new Error('Import candidate must have content or path or both');
        }
    }
}
module.exports = dagBuilder;
}),
"[project]/node_modules/ipfs-unixfs-importer/src/dir.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * @typedef {import('./types').ImporterOptions} ImporterOptions
 * @typedef {import('./types').ImportResult} ImportResult
 * @typedef {import('./types').InProgressImportResult} InProgressImportResult
 * @typedef {import('./types').BlockAPI} BlockAPI
 * @typedef {import('cids')} CID
 * @typedef {object} DirProps
 * @property {boolean} root
 * @property {boolean} dir
 * @property {string} path
 * @property {boolean} dirty
 * @property {boolean} flat
 * @property {Dir} [parent]
 * @property {string} [parentKey]
 * @property {import('ipfs-unixfs').UnixFS} [unixfs]
 * @property {number} [mode]
 * @property {import('ipfs-unixfs').Mtime} [mtime]
 */ class Dir {
    /**
   *
   * @param {DirProps} props
   * @param {ImporterOptions} options
   */ constructor(props, options){
        this.options = options || {};
        this.root = props.root;
        this.dir = props.dir;
        this.path = props.path;
        this.dirty = props.dirty;
        this.flat = props.flat;
        this.parent = props.parent;
        this.parentKey = props.parentKey;
        this.unixfs = props.unixfs;
        this.mode = props.mode;
        this.mtime = props.mtime;
        /** @type {CID | undefined} */ this.cid = undefined;
        /** @type {number | undefined} */ this.size = undefined;
    }
    /**
   * @param {string} name
   * @param {InProgressImportResult | Dir} value
   */ async put(name, value) {}
    /**
   * @param {string} name
   * @returns {Promise<InProgressImportResult | Dir | undefined>}
   */ get(name) {
        return Promise.resolve(this);
    }
    /**
   * @returns {AsyncIterable<{ key: string, child: InProgressImportResult | Dir}>}
   */ async *eachChildSeries() {}
    /**
   * @param {BlockAPI} block
   * @returns {AsyncIterable<ImportResult>}
   */ async *flush(block) {}
}
module.exports = Dir;
}),
"[project]/node_modules/ipfs-unixfs-importer/src/dir-flat.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { DAGLink, DAGNode } = __turbopack_context__.r("[project]/node_modules/ipld-dag-pb/src/index.js [app-client] (ecmascript)");
const { UnixFS } = __turbopack_context__.r("[project]/node_modules/ipfs-unixfs/src/index.js [app-client] (ecmascript)");
const Dir = __turbopack_context__.r("[project]/node_modules/ipfs-unixfs-importer/src/dir.js [app-client] (ecmascript)");
const persist = __turbopack_context__.r("[project]/node_modules/ipfs-unixfs-importer/src/utils/persist.js [app-client] (ecmascript)");
/**
 * @typedef {import('./types').ImporterOptions} ImporterOptions
 * @typedef {import('./types').ImportResult} ImportResult
 * @typedef {import('./types').InProgressImportResult} InProgressImportResult
 * @typedef {import('./types').BlockAPI} BlockAPI
 * @typedef {import('./dir').DirProps} DirProps
 * @typedef {import('cids')} CID
 */ class DirFlat extends Dir {
    /**
   * @param {DirProps} props
   * @param {ImporterOptions} options
   */ constructor(props, options){
        super(props, options);
        /** @type {{ [key: string]: InProgressImportResult | Dir }} */ this._children = {};
    }
    /**
   * @param {string} name
   * @param {InProgressImportResult | Dir} value
   */ async put(name, value) {
        this.cid = undefined;
        this.size = undefined;
        this._children[name] = value;
    }
    /**
   * @param {string} name
   */ get(name) {
        return Promise.resolve(this._children[name]);
    }
    childCount() {
        return Object.keys(this._children).length;
    }
    directChildrenCount() {
        return this.childCount();
    }
    onlyChild() {
        return this._children[Object.keys(this._children)[0]];
    }
    async *eachChildSeries() {
        const keys = Object.keys(this._children);
        for(let i = 0; i < keys.length; i++){
            const key = keys[i];
            yield {
                key: key,
                child: this._children[key]
            };
        }
    }
    /**
   * @param {BlockAPI} block
   * @returns {AsyncIterable<ImportResult>}
   */ async *flush(block) {
        const children = Object.keys(this._children);
        const links = [];
        for(let i = 0; i < children.length; i++){
            let child = this._children[children[i]];
            if (child instanceof Dir) {
                for await (const entry of child.flush(block)){
                    child = entry;
                    yield child;
                }
            }
            if (child.size != null && child.cid) {
                links.push(new DAGLink(children[i], child.size, child.cid));
            }
        }
        const unixfs = new UnixFS({
            type: 'directory',
            mtime: this.mtime,
            mode: this.mode
        });
        const node = new DAGNode(unixfs.marshal(), links);
        const buffer = node.serialize();
        const cid = await persist(buffer, block, this.options);
        const size = buffer.length + node.Links.reduce(/**
       * @param {number} acc
       * @param {DAGLink} curr
       */ (acc, curr)=>acc + curr.Tsize, 0);
        this.cid = cid;
        this.size = size;
        yield {
            cid,
            unixfs,
            path: this.path,
            size
        };
    }
}
module.exports = DirFlat;
}),
"[project]/node_modules/ipfs-unixfs-importer/src/dir-sharded.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { DAGLink, DAGNode } = __turbopack_context__.r("[project]/node_modules/ipld-dag-pb/src/index.js [app-client] (ecmascript)");
const { UnixFS } = __turbopack_context__.r("[project]/node_modules/ipfs-unixfs/src/index.js [app-client] (ecmascript)");
const Dir = __turbopack_context__.r("[project]/node_modules/ipfs-unixfs-importer/src/dir.js [app-client] (ecmascript)");
const persist = __turbopack_context__.r("[project]/node_modules/ipfs-unixfs-importer/src/utils/persist.js [app-client] (ecmascript)");
const { createHAMT, Bucket } = __turbopack_context__.r("[project]/node_modules/hamt-sharding/src/index.js [app-client] (ecmascript)");
/**
 * @typedef {import('./types').ImporterOptions} ImporterOptions
 * @typedef {import('./types').ImportResult} ImportResult
 * @typedef {import('./types').InProgressImportResult} InProgressImportResult
 * @typedef {import('./types').BlockAPI} BlockAPI
 */ /**
 * @typedef {import('./dir').DirProps} DirProps
 */ class DirSharded extends Dir {
    /**
   * @param {DirProps} props
   * @param {ImporterOptions} options
   */ constructor(props, options){
        super(props, options);
        /** @type {Bucket<InProgressImportResult | Dir>} */ this._bucket = createHAMT({
            hashFn: options.hamtHashFn,
            bits: options.hamtBucketBits
        });
    }
    /**
   * @param {string} name
   * @param {InProgressImportResult | Dir} value
   */ async put(name, value) {
        await this._bucket.put(name, value);
    }
    /**
   * @param {string} name
   */ get(name) {
        return this._bucket.get(name);
    }
    childCount() {
        return this._bucket.leafCount();
    }
    directChildrenCount() {
        return this._bucket.childrenCount();
    }
    onlyChild() {
        return this._bucket.onlyChild();
    }
    async *eachChildSeries() {
        for await (const { key, value } of this._bucket.eachLeafSeries()){
            yield {
                key,
                child: value
            };
        }
    }
    /**
   * @param {BlockAPI} block
   * @returns {AsyncIterable<ImportResult>}
   */ async *flush(block) {
        for await (const entry of flush(this._bucket, block, this, this.options)){
            yield {
                ...entry,
                path: this.path
            };
        }
    }
}
module.exports = DirSharded;
/**
 * @param {Bucket<?>} bucket
 * @param {BlockAPI} block
 * @param {*} shardRoot
 * @param {ImporterOptions} options
 * @returns {AsyncIterable<ImportResult>}
 */ async function* flush(bucket, block, shardRoot, options) {
    const children = bucket._children;
    const links = [];
    let childrenSize = 0;
    for(let i = 0; i < children.length; i++){
        const child = children.get(i);
        if (!child) {
            continue;
        }
        const labelPrefix = i.toString(16).toUpperCase().padStart(2, '0');
        if (child instanceof Bucket) {
            let shard;
            for await (const subShard of (await flush(child, block, null, options))){
                shard = subShard;
            }
            if (!shard) {
                throw new Error('Could not flush sharded directory, no subshard found');
            }
            links.push(new DAGLink(labelPrefix, shard.size, shard.cid));
            childrenSize += shard.size;
        } else if (typeof child.value.flush === 'function') {
            const dir = child.value;
            let flushedDir;
            for await (const entry of dir.flush(block)){
                flushedDir = entry;
                yield flushedDir;
            }
            const label = labelPrefix + child.key;
            links.push(new DAGLink(label, flushedDir.size, flushedDir.cid));
            childrenSize += flushedDir.size;
        } else {
            const value = child.value;
            if (!value.cid) {
                continue;
            }
            const label = labelPrefix + child.key;
            const size = value.size;
            links.push(new DAGLink(label, size, value.cid));
            childrenSize += size;
        }
    }
    // go-ipfs uses little endian, that's why we have to
    // reverse the bit field before storing it
    const data = Uint8Array.from(children.bitField().reverse());
    const dir = new UnixFS({
        type: 'hamt-sharded-directory',
        data,
        fanout: bucket.tableSize(),
        hashType: options.hamtHashCode,
        mtime: shardRoot && shardRoot.mtime,
        mode: shardRoot && shardRoot.mode
    });
    const node = new DAGNode(dir.marshal(), links);
    const buffer = node.serialize();
    const cid = await persist(buffer, block, options);
    const size = buffer.length + childrenSize;
    yield {
        cid,
        unixfs: dir,
        size
    };
}
}),
"[project]/node_modules/ipfs-unixfs-importer/src/flat-to-shard.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const DirSharded = __turbopack_context__.r("[project]/node_modules/ipfs-unixfs-importer/src/dir-sharded.js [app-client] (ecmascript)");
const DirFlat = __turbopack_context__.r("[project]/node_modules/ipfs-unixfs-importer/src/dir-flat.js [app-client] (ecmascript)");
/**
 * @typedef {import('./dir')} Dir
 * @typedef {import('./types').ImporterOptions} ImporterOptions
 */ /**
 * @param {Dir | null} child
 * @param {Dir} dir
 * @param {number} threshold
 * @param {ImporterOptions} options
 * @returns {Promise<DirSharded>}
 */ module.exports = async function flatToShard(child, dir, threshold, options) {
    let newDir = dir;
    if (dir instanceof DirFlat && dir.directChildrenCount() >= threshold) {
        newDir = await convertToShard(dir, options);
    }
    const parent = newDir.parent;
    if (parent) {
        if (newDir !== dir) {
            if (child) {
                child.parent = newDir;
            }
            if (!newDir.parentKey) {
                throw new Error('No parent key found');
            }
            await parent.put(newDir.parentKey, newDir);
        }
        return flatToShard(newDir, parent, threshold, options);
    }
    // @ts-ignore
    return newDir;
};
/**
 * @param {DirFlat} oldDir
 * @param {ImporterOptions} options
 */ async function convertToShard(oldDir, options) {
    const newDir = new DirSharded({
        root: oldDir.root,
        dir: true,
        parent: oldDir.parent,
        parentKey: oldDir.parentKey,
        path: oldDir.path,
        dirty: oldDir.dirty,
        flat: false,
        mtime: oldDir.mtime,
        mode: oldDir.mode
    }, options);
    for await (const { key, child } of oldDir.eachChildSeries()){
        await newDir.put(key, child);
    }
    return newDir;
}
}),
"[project]/node_modules/ipfs-unixfs-importer/src/utils/to-path-components.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const toPathComponents = (path = '')=>{
    // split on / unless escaped with \
    return (path.trim().match(/([^\\^/]|\\\/)+/g) || []).filter(Boolean);
};
module.exports = toPathComponents;
}),
"[project]/node_modules/ipfs-unixfs-importer/src/tree-builder.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const DirFlat = __turbopack_context__.r("[project]/node_modules/ipfs-unixfs-importer/src/dir-flat.js [app-client] (ecmascript)");
const flatToShard = __turbopack_context__.r("[project]/node_modules/ipfs-unixfs-importer/src/flat-to-shard.js [app-client] (ecmascript)");
const Dir = __turbopack_context__.r("[project]/node_modules/ipfs-unixfs-importer/src/dir.js [app-client] (ecmascript)");
const toPathComponents = __turbopack_context__.r("[project]/node_modules/ipfs-unixfs-importer/src/utils/to-path-components.js [app-client] (ecmascript)");
/**
 * @typedef {import('./types').ImportResult} ImportResult
 * @typedef {import('./types').InProgressImportResult} InProgressImportResult
 * @typedef {import('./types').ImporterOptions} ImporterOptions
 * @typedef {import('./types').BlockAPI} BlockAPI
 * @typedef {(source: AsyncIterable<InProgressImportResult>, block: BlockAPI, options: ImporterOptions) => AsyncIterable<ImportResult>} TreeBuilder
 */ /**
 * @param {InProgressImportResult} elem
 * @param {Dir} tree
 * @param {ImporterOptions} options
 */ async function addToTree(elem, tree, options) {
    const pathElems = toPathComponents(elem.path || '');
    const lastIndex = pathElems.length - 1;
    let parent = tree;
    let currentPath = '';
    for(let i = 0; i < pathElems.length; i++){
        const pathElem = pathElems[i];
        currentPath += `${currentPath ? '/' : ''}${pathElem}`;
        const last = i === lastIndex;
        parent.dirty = true;
        parent.cid = undefined;
        parent.size = undefined;
        if (last) {
            await parent.put(pathElem, elem);
            tree = await flatToShard(null, parent, options.shardSplitThreshold, options);
        } else {
            let dir = await parent.get(pathElem);
            if (!dir || !(dir instanceof Dir)) {
                dir = new DirFlat({
                    root: false,
                    dir: true,
                    parent: parent,
                    parentKey: pathElem,
                    path: currentPath,
                    dirty: true,
                    flat: true,
                    mtime: dir && dir.unixfs && dir.unixfs.mtime,
                    mode: dir && dir.unixfs && dir.unixfs.mode
                }, options);
            }
            await parent.put(pathElem, dir);
            parent = dir;
        }
    }
    return tree;
}
/**
 * @param {Dir | InProgressImportResult} tree
 * @param {BlockAPI} block
 */ async function* flushAndYield(tree, block) {
    if (!(tree instanceof Dir)) {
        if (tree && tree.unixfs && tree.unixfs.isDirectory()) {
            yield tree;
        }
        return;
    }
    yield* tree.flush(block);
}
/**
 * @type {TreeBuilder}
 */ async function* treeBuilder(source, block, options) {
    /** @type {Dir} */ let tree = new DirFlat({
        root: true,
        dir: true,
        path: '',
        dirty: true,
        flat: true
    }, options);
    for await (const entry of source){
        if (!entry) {
            continue;
        }
        tree = await addToTree(entry, tree, options);
        if (!entry.unixfs || !entry.unixfs.isDirectory()) {
            yield entry;
        }
    }
    if (options.wrapWithDirectory) {
        yield* flushAndYield(tree, block);
    } else {
        for await (const unwrapped of tree.eachChildSeries()){
            if (!unwrapped) {
                continue;
            }
            yield* flushAndYield(unwrapped.child, block);
        }
    }
}
module.exports = treeBuilder;
}),
"[project]/node_modules/ipfs-unixfs-importer/src/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const parallelBatch = __turbopack_context__.r("[project]/node_modules/it-parallel-batch/index.js [app-client] (ecmascript)");
const defaultOptions = __turbopack_context__.r("[project]/node_modules/ipfs-unixfs-importer/src/options.js [app-client] (ecmascript)");
/**
 * @typedef {import('./types').BlockAPI} BlockAPI
 * @typedef {import('./types').ImportCandidate} ImportCandidate
 * @typedef {import('./types').UserImporterOptions} UserImporterOptions
 * @typedef {import('./types').ImporterOptions} ImporterOptions
 * @typedef {import('./types').Directory} Directory
 * @typedef {import('./types').File} File
 * @typedef {import('./types').ImportResult} ImportResult
 *
 * @typedef {import('./types').Chunker} Chunker
 * @typedef {import('./types').DAGBuilder} DAGBuilder
 * @typedef {import('./types').TreeBuilder} TreeBuilder
 * @typedef {import('./types').BufferImporter} BufferImporter
 * @typedef {import('./types').ChunkValidator} ChunkValidator
 * @typedef {import('./types').Reducer} Reducer
 * @typedef {import('./types').ProgressHandler} ProgressHandler
 */ /**
 * @param {AsyncIterable<ImportCandidate> | Iterable<ImportCandidate> | ImportCandidate} source
 * @param {BlockAPI} block
 * @param {UserImporterOptions} options
 */ async function* importer(source, block, options = {}) {
    const opts = defaultOptions(options);
    let dagBuilder;
    if (typeof options.dagBuilder === 'function') {
        dagBuilder = options.dagBuilder;
    } else {
        dagBuilder = __turbopack_context__.r("[project]/node_modules/ipfs-unixfs-importer/src/dag-builder/index.js [app-client] (ecmascript)");
    }
    let treeBuilder;
    if (typeof options.treeBuilder === 'function') {
        treeBuilder = options.treeBuilder;
    } else {
        treeBuilder = __turbopack_context__.r("[project]/node_modules/ipfs-unixfs-importer/src/tree-builder.js [app-client] (ecmascript)");
    }
    /** @type {AsyncIterable<ImportCandidate> | Iterable<ImportCandidate>} */ let candidates;
    if (Symbol.asyncIterator in source || Symbol.iterator in source) {
        // @ts-ignore
        candidates = source;
    } else {
        // @ts-ignore
        candidates = [
            source
        ];
    }
    for await (const entry of treeBuilder(parallelBatch(dagBuilder(candidates, block, opts), opts.fileImportConcurrency), block, opts)){
        yield {
            cid: entry.cid,
            path: entry.path,
            unixfs: entry.unixfs,
            size: entry.size
        };
    }
}
module.exports = {
    importer
};
}),
"[project]/node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/alloc.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Returns a `Uint8Array` of the requested size. Referenced memory will
 * be initialized to 0.
 */ __turbopack_context__.s([
    "alloc",
    ()=>alloc,
    "allocUnsafe",
    ()=>allocUnsafe
]);
function alloc(size = 0) {
    return new Uint8Array(size);
}
function allocUnsafe(size = 0) {
    return new Uint8Array(size);
} //# sourceMappingURL=alloc.js.map
}),
"[project]/node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/util/as-uint8array.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * To guarantee Uint8Array semantics, convert nodejs Buffers
 * into vanilla Uint8Arrays
 */ __turbopack_context__.s([
    "asUint8Array",
    ()=>asUint8Array
]);
function asUint8Array(buf) {
    return buf;
} //# sourceMappingURL=as-uint8array.js.map
}),
"[project]/node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/concat.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "concat",
    ()=>concat
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/alloc.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/util/as-uint8array.js [app-client] (ecmascript)");
;
;
function concat(arrays, length) {
    if (length == null) {
        length = arrays.reduce((acc, curr)=>acc + curr.length, 0);
    }
    const output = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["allocUnsafe"])(length);
    let offset = 0;
    for (const arr of arrays){
        output.set(arr, offset);
        offset += arr.length;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asUint8Array"])(output);
} //# sourceMappingURL=concat.js.map
}),
"[project]/node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/equals.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Returns true if the two passed Uint8Arrays have the same content
 */ __turbopack_context__.s([
    "equals",
    ()=>equals
]);
function equals(a, b) {
    if (a === b) {
        return true;
    }
    if (a.byteLength !== b.byteLength) {
        return false;
    }
    for(let i = 0; i < a.byteLength; i++){
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
} //# sourceMappingURL=equals.js.map
}),
"[project]/node_modules/uint8arraylist/dist/src/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @packageDocumentation
 *
 * A class that lets you do operations over a list of Uint8Arrays without
 * copying them.
 *
 * ```js
 * import { Uint8ArrayList } from 'uint8arraylist'
 *
 * const list = new Uint8ArrayList()
 * list.append(Uint8Array.from([0, 1, 2]))
 * list.append(Uint8Array.from([3, 4, 5]))
 *
 * list.subarray()
 * // -> Uint8Array([0, 1, 2, 3, 4, 5])
 *
 * list.consume(3)
 * list.subarray()
 * // -> Uint8Array([3, 4, 5])
 *
 * // you can also iterate over the list
 * for (const buf of list) {
 *   // ..do something with `buf`
 * }
 *
 * list.subarray(0, 1)
 * // -> Uint8Array([0])
 * ```
 *
 * ## Converting Uint8ArrayLists to Uint8Arrays
 *
 * There are two ways to turn a `Uint8ArrayList` into a `Uint8Array` - `.slice` and `.subarray` and one way to turn a `Uint8ArrayList` into a `Uint8ArrayList` with different contents - `.sublist`.
 *
 * ### slice
 *
 * Slice follows the same semantics as [Uint8Array.slice](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice) in that it creates a new `Uint8Array` and copies bytes into it using an optional offset & length.
 *
 * ```js
 * const list = new Uint8ArrayList()
 * list.append(Uint8Array.from([0, 1, 2]))
 * list.append(Uint8Array.from([3, 4, 5]))
 *
 * list.slice(0, 1)
 * // -> Uint8Array([0])
 * ```
 *
 * ### subarray
 *
 * Subarray attempts to follow the same semantics as [Uint8Array.subarray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray) with one important different - this is a no-copy operation, unless the requested bytes span two internal buffers in which case it is a copy operation.
 *
 * ```js
 * const list = new Uint8ArrayList()
 * list.append(Uint8Array.from([0, 1, 2]))
 * list.append(Uint8Array.from([3, 4, 5]))
 *
 * list.subarray(0, 1)
 * // -> Uint8Array([0]) - no-copy
 *
 * list.subarray(2, 5)
 * // -> Uint8Array([2, 3, 4]) - copy
 * ```
 *
 * ### sublist
 *
 * Sublist creates and returns a new `Uint8ArrayList` that shares the underlying buffers with the original so is always a no-copy operation.
 *
 * ```js
 * const list = new Uint8ArrayList()
 * list.append(Uint8Array.from([0, 1, 2]))
 * list.append(Uint8Array.from([3, 4, 5]))
 *
 * list.sublist(0, 1)
 * // -> Uint8ArrayList([0]) - no-copy
 *
 * list.sublist(2, 5)
 * // -> Uint8ArrayList([2], [3, 4]) - no-copy
 * ```
 *
 * ## Inspiration
 *
 * Borrows liberally from [bl](https://www.npmjs.com/package/bl) but only uses native JS types.
 */ __turbopack_context__.s([
    "Uint8ArrayList",
    ()=>Uint8ArrayList,
    "isUint8ArrayList",
    ()=>isUint8ArrayList
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/alloc.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$concat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/concat.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$equals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/equals.js [app-client] (ecmascript)");
;
;
;
const symbol = Symbol.for('@achingbrain/uint8arraylist');
function findBufAndOffset(bufs, index) {
    if (index == null || index < 0) {
        throw new RangeError('index is out of bounds');
    }
    let offset = 0;
    for (const buf of bufs){
        const bufEnd = offset + buf.byteLength;
        if (index < bufEnd) {
            return {
                buf,
                index: index - offset
            };
        }
        offset = bufEnd;
    }
    throw new RangeError('index is out of bounds');
}
function isUint8ArrayList(value) {
    return Boolean(value?.[symbol]);
}
class Uint8ArrayList {
    bufs;
    length;
    [symbol] = true;
    constructor(...data){
        this.bufs = [];
        this.length = 0;
        if (data.length > 0) {
            this.appendAll(data);
        }
    }
    *[Symbol.iterator]() {
        yield* this.bufs;
    }
    get byteLength() {
        return this.length;
    }
    /**
     * Add one or more `bufs` to the end of this Uint8ArrayList
     */ append(...bufs) {
        this.appendAll(bufs);
    }
    /**
     * Add all `bufs` to the end of this Uint8ArrayList
     */ appendAll(bufs) {
        let length = 0;
        for (const buf of bufs){
            if (buf instanceof Uint8Array) {
                length += buf.byteLength;
                this.bufs.push(buf);
            } else if (isUint8ArrayList(buf)) {
                length += buf.byteLength;
                this.bufs.push(...buf.bufs);
            } else {
                throw new Error('Could not append value, must be an Uint8Array or a Uint8ArrayList');
            }
        }
        this.length += length;
    }
    /**
     * Add one or more `bufs` to the start of this Uint8ArrayList
     */ prepend(...bufs) {
        this.prependAll(bufs);
    }
    /**
     * Add all `bufs` to the start of this Uint8ArrayList
     */ prependAll(bufs) {
        let length = 0;
        for (const buf of bufs.reverse()){
            if (buf instanceof Uint8Array) {
                length += buf.byteLength;
                this.bufs.unshift(buf);
            } else if (isUint8ArrayList(buf)) {
                length += buf.byteLength;
                this.bufs.unshift(...buf.bufs);
            } else {
                throw new Error('Could not prepend value, must be an Uint8Array or a Uint8ArrayList');
            }
        }
        this.length += length;
    }
    /**
     * Read the value at `index`
     */ get(index) {
        const res = findBufAndOffset(this.bufs, index);
        return res.buf[res.index];
    }
    /**
     * Set the value at `index` to `value`
     */ set(index, value) {
        const res = findBufAndOffset(this.bufs, index);
        res.buf[res.index] = value;
    }
    /**
     * Copy bytes from `buf` to the index specified by `offset`
     */ write(buf, offset = 0) {
        if (buf instanceof Uint8Array) {
            for(let i = 0; i < buf.length; i++){
                this.set(offset + i, buf[i]);
            }
        } else if (isUint8ArrayList(buf)) {
            for(let i = 0; i < buf.length; i++){
                this.set(offset + i, buf.get(i));
            }
        } else {
            throw new Error('Could not write value, must be an Uint8Array or a Uint8ArrayList');
        }
    }
    /**
     * Remove bytes from the front of the pool
     */ consume(bytes) {
        // first, normalize the argument, in accordance with how Buffer does it
        bytes = Math.trunc(bytes);
        // do nothing if not a positive number
        if (Number.isNaN(bytes) || bytes <= 0) {
            return;
        }
        // if consuming all bytes, skip iterating
        if (bytes === this.byteLength) {
            this.bufs = [];
            this.length = 0;
            return;
        }
        while(this.bufs.length > 0){
            if (bytes >= this.bufs[0].byteLength) {
                bytes -= this.bufs[0].byteLength;
                this.length -= this.bufs[0].byteLength;
                this.bufs.shift();
            } else {
                this.bufs[0] = this.bufs[0].subarray(bytes);
                this.length -= bytes;
                break;
            }
        }
    }
    /**
     * Extracts a section of an array and returns a new array.
     *
     * This is a copy operation as it is with Uint8Arrays and Arrays
     * - note this is different to the behaviour of Node Buffers.
     */ slice(beginInclusive, endExclusive) {
        const { bufs, length } = this._subList(beginInclusive, endExclusive);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$concat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["concat"])(bufs, length);
    }
    /**
     * Returns a alloc from the given start and end element index.
     *
     * In the best case where the data extracted comes from a single Uint8Array
     * internally this is a no-copy operation otherwise it is a copy operation.
     */ subarray(beginInclusive, endExclusive) {
        const { bufs, length } = this._subList(beginInclusive, endExclusive);
        if (bufs.length === 1) {
            return bufs[0];
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$concat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["concat"])(bufs, length);
    }
    /**
     * Returns a allocList from the given start and end element index.
     *
     * This is a no-copy operation.
     */ sublist(beginInclusive, endExclusive) {
        const { bufs, length } = this._subList(beginInclusive, endExclusive);
        const list = new Uint8ArrayList();
        list.length = length;
        // don't loop, just set the bufs
        list.bufs = [
            ...bufs
        ];
        return list;
    }
    _subList(beginInclusive, endExclusive) {
        beginInclusive = beginInclusive ?? 0;
        endExclusive = endExclusive ?? this.length;
        if (beginInclusive < 0) {
            beginInclusive = this.length + beginInclusive;
        }
        if (endExclusive < 0) {
            endExclusive = this.length + endExclusive;
        }
        if (beginInclusive < 0 || endExclusive > this.length) {
            throw new RangeError('index is out of bounds');
        }
        if (beginInclusive === endExclusive) {
            return {
                bufs: [],
                length: 0
            };
        }
        if (beginInclusive === 0 && endExclusive === this.length) {
            return {
                bufs: this.bufs,
                length: this.length
            };
        }
        const bufs = [];
        let offset = 0;
        for(let i = 0; i < this.bufs.length; i++){
            const buf = this.bufs[i];
            const bufStart = offset;
            const bufEnd = bufStart + buf.byteLength;
            // for next loop
            offset = bufEnd;
            if (beginInclusive >= bufEnd) {
                continue;
            }
            const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd;
            const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd;
            if (sliceStartInBuf && sliceEndsInBuf) {
                // slice is wholly contained within this buffer
                if (beginInclusive === bufStart && endExclusive === bufEnd) {
                    // requested whole buffer
                    bufs.push(buf);
                    break;
                }
                // requested part of buffer
                const start = beginInclusive - bufStart;
                bufs.push(buf.subarray(start, start + (endExclusive - beginInclusive)));
                break;
            }
            if (sliceStartInBuf) {
                // slice starts in this buffer
                if (beginInclusive === 0) {
                    // requested whole buffer
                    bufs.push(buf);
                    continue;
                }
                // requested part of buffer
                bufs.push(buf.subarray(beginInclusive - bufStart));
                continue;
            }
            if (sliceEndsInBuf) {
                if (endExclusive === bufEnd) {
                    // requested whole buffer
                    bufs.push(buf);
                    break;
                }
                // requested part of buffer
                bufs.push(buf.subarray(0, endExclusive - bufStart));
                break;
            }
            // slice started before this buffer and ends after it
            bufs.push(buf);
        }
        return {
            bufs,
            length: endExclusive - beginInclusive
        };
    }
    indexOf(search, offset = 0) {
        if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {
            throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');
        }
        const needle = search instanceof Uint8Array ? search : search.subarray();
        offset = Number(offset ?? 0);
        if (isNaN(offset)) {
            offset = 0;
        }
        if (offset < 0) {
            offset = this.length + offset;
        }
        if (offset < 0) {
            offset = 0;
        }
        if (search.length === 0) {
            return offset > this.length ? this.length : offset;
        }
        // https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm
        const M = needle.byteLength;
        if (M === 0) {
            throw new TypeError('search must be at least 1 byte long');
        }
        // radix
        const radix = 256;
        const rightmostPositions = new Int32Array(radix);
        // position of the rightmost occurrence of the byte c in the pattern
        for(let c = 0; c < radix; c++){
            // -1 for bytes not in pattern
            rightmostPositions[c] = -1;
        }
        for(let j = 0; j < M; j++){
            // rightmost position for bytes in pattern
            rightmostPositions[needle[j]] = j;
        }
        // Return offset of first match, -1 if no match
        const right = rightmostPositions;
        const lastIndex = this.byteLength - needle.byteLength;
        const lastPatIndex = needle.byteLength - 1;
        let skip;
        for(let i = offset; i <= lastIndex; i += skip){
            skip = 0;
            for(let j = lastPatIndex; j >= 0; j--){
                const char = this.get(i + j);
                if (needle[j] !== char) {
                    skip = Math.max(1, j - right[char]);
                    break;
                }
            }
            if (skip === 0) {
                return i;
            }
        }
        return -1;
    }
    getInt8(byteOffset) {
        const buf = this.subarray(byteOffset, byteOffset + 1);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getInt8(0);
    }
    setInt8(byteOffset, value) {
        const buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["allocUnsafe"])(1);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setInt8(0, value);
        this.write(buf, byteOffset);
    }
    getInt16(byteOffset, littleEndian) {
        const buf = this.subarray(byteOffset, byteOffset + 2);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getInt16(0, littleEndian);
    }
    setInt16(byteOffset, value, littleEndian) {
        const buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["alloc"])(2);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setInt16(0, value, littleEndian);
        this.write(buf, byteOffset);
    }
    getInt32(byteOffset, littleEndian) {
        const buf = this.subarray(byteOffset, byteOffset + 4);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getInt32(0, littleEndian);
    }
    setInt32(byteOffset, value, littleEndian) {
        const buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["alloc"])(4);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setInt32(0, value, littleEndian);
        this.write(buf, byteOffset);
    }
    getBigInt64(byteOffset, littleEndian) {
        const buf = this.subarray(byteOffset, byteOffset + 8);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getBigInt64(0, littleEndian);
    }
    setBigInt64(byteOffset, value, littleEndian) {
        const buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["alloc"])(8);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setBigInt64(0, value, littleEndian);
        this.write(buf, byteOffset);
    }
    getUint8(byteOffset) {
        const buf = this.subarray(byteOffset, byteOffset + 1);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getUint8(0);
    }
    setUint8(byteOffset, value) {
        const buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["allocUnsafe"])(1);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setUint8(0, value);
        this.write(buf, byteOffset);
    }
    getUint16(byteOffset, littleEndian) {
        const buf = this.subarray(byteOffset, byteOffset + 2);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getUint16(0, littleEndian);
    }
    setUint16(byteOffset, value, littleEndian) {
        const buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["alloc"])(2);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setUint16(0, value, littleEndian);
        this.write(buf, byteOffset);
    }
    getUint32(byteOffset, littleEndian) {
        const buf = this.subarray(byteOffset, byteOffset + 4);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getUint32(0, littleEndian);
    }
    setUint32(byteOffset, value, littleEndian) {
        const buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["alloc"])(4);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setUint32(0, value, littleEndian);
        this.write(buf, byteOffset);
    }
    getBigUint64(byteOffset, littleEndian) {
        const buf = this.subarray(byteOffset, byteOffset + 8);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getBigUint64(0, littleEndian);
    }
    setBigUint64(byteOffset, value, littleEndian) {
        const buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["alloc"])(8);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setBigUint64(0, value, littleEndian);
        this.write(buf, byteOffset);
    }
    getFloat32(byteOffset, littleEndian) {
        const buf = this.subarray(byteOffset, byteOffset + 4);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getFloat32(0, littleEndian);
    }
    setFloat32(byteOffset, value, littleEndian) {
        const buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["alloc"])(4);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setFloat32(0, value, littleEndian);
        this.write(buf, byteOffset);
    }
    getFloat64(byteOffset, littleEndian) {
        const buf = this.subarray(byteOffset, byteOffset + 8);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getFloat64(0, littleEndian);
    }
    setFloat64(byteOffset, value, littleEndian) {
        const buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["alloc"])(8);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setFloat64(0, value, littleEndian);
        this.write(buf, byteOffset);
    }
    equals(other) {
        if (other == null) {
            return false;
        }
        if (!(other instanceof Uint8ArrayList)) {
            return false;
        }
        if (other.bufs.length !== this.bufs.length) {
            return false;
        }
        for(let i = 0; i < this.bufs.length; i++){
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$equals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["equals"])(this.bufs[i], other.bufs[i])) {
                return false;
            }
        }
        return true;
    }
    /**
     * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this
     * method if you know the total size of all the Uint8Arrays ahead of time.
     */ static fromUint8Arrays(bufs, length) {
        const list = new Uint8ArrayList();
        list.bufs = bufs;
        if (length == null) {
            length = bufs.reduce((acc, curr)=>acc + curr.byteLength, 0);
        }
        list.length = length;
        return list;
    }
} /*
function indexOf (needle: Uint8Array, haystack: Uint8Array, offset = 0) {
  for (let i = offset; i < haystack.byteLength; i++) {
    for (let j = 0; j < needle.length; j++) {
      if (haystack[i + j] !== needle[j]) {
        break
      }

      if (j === needle.byteLength -1) {
        return i
      }
    }

    if (haystack.byteLength - i < needle.byteLength) {
      break
    }
  }

  return -1
}
*/  //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/detect-browser/es/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BotInfo",
    ()=>BotInfo,
    "BrowserInfo",
    ()=>BrowserInfo,
    "NodeInfo",
    ()=>NodeInfo,
    "ReactNativeInfo",
    ()=>ReactNativeInfo,
    "SearchBotDeviceInfo",
    ()=>SearchBotDeviceInfo,
    "browserName",
    ()=>browserName,
    "detect",
    ()=>detect,
    "detectOS",
    ()=>detectOS,
    "getNodeVersion",
    ()=>getNodeVersion,
    "parseUserAgent",
    ()=>parseUserAgent
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __spreadArray = ("TURBOPACK compile-time value", void 0) && ("TURBOPACK compile-time value", void 0).__spreadArray || function(to, from, pack) {
    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var BrowserInfo = function() {
    function BrowserInfo(name, version, os) {
        this.name = name;
        this.version = version;
        this.os = os;
        this.type = 'browser';
    }
    return BrowserInfo;
}();
;
var NodeInfo = function() {
    function NodeInfo(version) {
        this.version = version;
        this.type = 'node';
        this.name = 'node';
        this.os = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].platform;
    }
    return NodeInfo;
}();
;
var SearchBotDeviceInfo = function() {
    function SearchBotDeviceInfo(name, version, os, bot) {
        this.name = name;
        this.version = version;
        this.os = os;
        this.bot = bot;
        this.type = 'bot-device';
    }
    return SearchBotDeviceInfo;
}();
;
var BotInfo = function() {
    function BotInfo() {
        this.type = 'bot';
        this.bot = true; // NOTE: deprecated test name instead
        this.name = 'bot';
        this.version = null;
        this.os = null;
    }
    return BotInfo;
}();
;
var ReactNativeInfo = function() {
    function ReactNativeInfo() {
        this.type = 'react-native';
        this.name = 'react-native';
        this.version = null;
        this.os = null;
    }
    return ReactNativeInfo;
}();
;
// tslint:disable-next-line:max-line-length
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
    [
        'aol',
        /AOLShield\/([0-9\._]+)/
    ],
    [
        'edge',
        /Edge\/([0-9\._]+)/
    ],
    [
        'edge-ios',
        /EdgiOS\/([0-9\._]+)/
    ],
    [
        'yandexbrowser',
        /YaBrowser\/([0-9\._]+)/
    ],
    [
        'kakaotalk',
        /KAKAOTALK\s([0-9\.]+)/
    ],
    [
        'samsung',
        /SamsungBrowser\/([0-9\.]+)/
    ],
    [
        'silk',
        /\bSilk\/([0-9._-]+)\b/
    ],
    [
        'miui',
        /MiuiBrowser\/([0-9\.]+)$/
    ],
    [
        'beaker',
        /BeakerBrowser\/([0-9\.]+)/
    ],
    [
        'edge-chromium',
        /EdgA?\/([0-9\.]+)/
    ],
    [
        'chromium-webview',
        /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
    ],
    [
        'chrome',
        /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
    ],
    [
        'phantomjs',
        /PhantomJS\/([0-9\.]+)(:?\s|$)/
    ],
    [
        'crios',
        /CriOS\/([0-9\.]+)(:?\s|$)/
    ],
    [
        'firefox',
        /Firefox\/([0-9\.]+)(?:\s|$)/
    ],
    [
        'fxios',
        /FxiOS\/([0-9\.]+)/
    ],
    [
        'opera-mini',
        /Opera Mini.*Version\/([0-9\.]+)/
    ],
    [
        'opera',
        /Opera\/([0-9\.]+)(?:\s|$)/
    ],
    [
        'opera',
        /OPR\/([0-9\.]+)(:?\s|$)/
    ],
    [
        'pie',
        /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/
    ],
    [
        'pie',
        /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/
    ],
    [
        'netfront',
        /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/
    ],
    [
        'ie',
        /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/
    ],
    [
        'ie',
        /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/
    ],
    [
        'ie',
        /MSIE\s(7\.0)/
    ],
    [
        'bb10',
        /BB10;\sTouch.*Version\/([0-9\.]+)/
    ],
    [
        'android',
        /Android\s([0-9\.]+)/
    ],
    [
        'ios',
        /Version\/([0-9\._]+).*Mobile.*Safari.*/
    ],
    [
        'safari',
        /Version\/([0-9\._]+).*Safari/
    ],
    [
        'facebook',
        /FB[AS]V\/([0-9\.]+)/
    ],
    [
        'instagram',
        /Instagram\s([0-9\.]+)/
    ],
    [
        'ios-webview',
        /AppleWebKit\/([0-9\.]+).*Mobile/
    ],
    [
        'ios-webview',
        /AppleWebKit\/([0-9\.]+).*Gecko\)$/
    ],
    [
        'curl',
        /^curl\/([0-9\.]+)$/
    ],
    [
        'searchbot',
        SEARCHBOX_UA_REGEX
    ]
];
var operatingSystemRules = [
    [
        'iOS',
        /iP(hone|od|ad)/
    ],
    [
        'Android OS',
        /Android/
    ],
    [
        'BlackBerry OS',
        /BlackBerry|BB10/
    ],
    [
        'Windows Mobile',
        /IEMobile/
    ],
    [
        'Amazon OS',
        /Kindle/
    ],
    [
        'Windows 3.11',
        /Win16/
    ],
    [
        'Windows 95',
        /(Windows 95)|(Win95)|(Windows_95)/
    ],
    [
        'Windows 98',
        /(Windows 98)|(Win98)/
    ],
    [
        'Windows 2000',
        /(Windows NT 5.0)|(Windows 2000)/
    ],
    [
        'Windows XP',
        /(Windows NT 5.1)|(Windows XP)/
    ],
    [
        'Windows Server 2003',
        /(Windows NT 5.2)/
    ],
    [
        'Windows Vista',
        /(Windows NT 6.0)/
    ],
    [
        'Windows 7',
        /(Windows NT 6.1)/
    ],
    [
        'Windows 8',
        /(Windows NT 6.2)/
    ],
    [
        'Windows 8.1',
        /(Windows NT 6.3)/
    ],
    [
        'Windows 10',
        /(Windows NT 10.0)/
    ],
    [
        'Windows ME',
        /Windows ME/
    ],
    [
        'Windows CE',
        /Windows CE|WinCE|Microsoft Pocket Internet Explorer/
    ],
    [
        'Open BSD',
        /OpenBSD/
    ],
    [
        'Sun OS',
        /SunOS/
    ],
    [
        'Chrome OS',
        /CrOS/
    ],
    [
        'Linux',
        /(Linux)|(X11)/
    ],
    [
        'Mac OS',
        /(Mac_PowerPC)|(Macintosh)/
    ],
    [
        'QNX',
        /QNX/
    ],
    [
        'BeOS',
        /BeOS/
    ],
    [
        'OS/2',
        /OS\/2/
    ]
];
function detect(userAgent) {
    if (!!userAgent) {
        return parseUserAgent(userAgent);
    }
    if (typeof document === 'undefined' && typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
        return new ReactNativeInfo();
    }
    if (typeof navigator !== 'undefined') {
        return parseUserAgent(navigator.userAgent);
    }
    return getNodeVersion();
}
function matchUserAgent(ua) {
    // opted for using reduce here rather than Array#first with a regex.test call
    // this is primarily because using the reduce we only perform the regex
    // execution once rather than once for the test and for the exec again below
    // probably something that needs to be benchmarked though
    return ua !== '' && userAgentRules.reduce(function(matched, _a) {
        var browser = _a[0], regex = _a[1];
        if (matched) {
            return matched;
        }
        var uaMatch = regex.exec(ua);
        return !!uaMatch && [
            browser,
            uaMatch
        ];
    }, false);
}
function browserName(ua) {
    var data = matchUserAgent(ua);
    return data ? data[0] : null;
}
function parseUserAgent(ua) {
    var matchedRule = matchUserAgent(ua);
    if (!matchedRule) {
        return null;
    }
    var name = matchedRule[0], match = matchedRule[1];
    if (name === 'searchbot') {
        return new BotInfo();
    }
    // Do not use RegExp for split operation as some browser do not support it (See: http://blog.stevenlevithan.com/archives/cross-browser-split)
    var versionParts = match[1] && match[1].split('.').join('_').split('_').slice(0, 3);
    if (versionParts) {
        if (versionParts.length < REQUIRED_VERSION_PARTS) {
            versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
        }
    } else {
        versionParts = [];
    }
    var version = versionParts.join('.');
    var os = detectOS(ua);
    var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
    if (searchBotMatch && searchBotMatch[1]) {
        return new SearchBotDeviceInfo(name, version, os, searchBotMatch[1]);
    }
    return new BrowserInfo(name, version, os);
}
function detectOS(ua) {
    for(var ii = 0, count = operatingSystemRules.length; ii < count; ii++){
        var _a = operatingSystemRules[ii], os = _a[0], regex = _a[1];
        var match = regex.exec(ua);
        if (match) {
            return os;
        }
    }
    return null;
}
function getNodeVersion() {
    var isNode = typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] !== 'undefined' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].version;
    return isNode ? new NodeInfo(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].version.slice(1)) : null;
}
function createVersionParts(count) {
    var output = [];
    for(var ii = 0; ii < count; ii++){
        output.push('0');
    }
    return output;
}
}),
"[project]/node_modules/strict-uri-encode/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = (str)=>encodeURIComponent(str).replace(/[!'()*]/g, (x)=>`%${x.charCodeAt(0).toString(16).toUpperCase()}`);
}),
"[project]/node_modules/decode-uri-component/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var token = '%[a-f0-9]{2}';
var singleMatcher = new RegExp('(' + token + ')|([^%]+?)', 'gi');
var multiMatcher = new RegExp('(' + token + ')+', 'gi');
function decodeComponents(components, split) {
    try {
        // Try to decode the entire string first
        return [
            decodeURIComponent(components.join(''))
        ];
    } catch (err) {
    // Do nothing
    }
    if (components.length === 1) {
        return components;
    }
    split = split || 1;
    // Split the array in 2 parts
    var left = components.slice(0, split);
    var right = components.slice(split);
    return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
}
function decode(input) {
    try {
        return decodeURIComponent(input);
    } catch (err) {
        var tokens = input.match(singleMatcher) || [];
        for(var i = 1; i < tokens.length; i++){
            input = decodeComponents(tokens, i).join('');
            tokens = input.match(singleMatcher) || [];
        }
        return input;
    }
}
function customDecodeURIComponent(input) {
    // Keep track of all the replacements and prefill the map with the `BOM`
    var replaceMap = {
        '%FE%FF': '\uFFFD\uFFFD',
        '%FF%FE': '\uFFFD\uFFFD'
    };
    var match = multiMatcher.exec(input);
    while(match){
        try {
            // Decode as big chunks as possible
            replaceMap[match[0]] = decodeURIComponent(match[0]);
        } catch (err) {
            var result = decode(match[0]);
            if (result !== match[0]) {
                replaceMap[match[0]] = result;
            }
        }
        match = multiMatcher.exec(input);
    }
    // Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else
    replaceMap['%C2'] = '\uFFFD';
    var entries = Object.keys(replaceMap);
    for(var i = 0; i < entries.length; i++){
        // Replace all decoded components
        var key = entries[i];
        input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
    }
    return input;
}
module.exports = function(encodedURI) {
    if (typeof encodedURI !== 'string') {
        throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');
    }
    try {
        encodedURI = encodedURI.replace(/\+/g, ' ');
        // Try the built in decoder first
        return decodeURIComponent(encodedURI);
    } catch (err) {
        // Fallback to a more advanced decoder
        return customDecodeURIComponent(encodedURI);
    }
};
}),
"[project]/node_modules/split-on-first/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = (string, separator)=>{
    if (!(typeof string === 'string' && typeof separator === 'string')) {
        throw new TypeError('Expected the arguments to be of type `string`');
    }
    if (separator === '') {
        return [
            string
        ];
    }
    const separatorIndex = string.indexOf(separator);
    if (separatorIndex === -1) {
        return [
            string
        ];
    }
    return [
        string.slice(0, separatorIndex),
        string.slice(separatorIndex + separator.length)
    ];
};
}),
"[project]/node_modules/filter-obj/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = function(obj, predicate) {
    var ret = {};
    var keys = Object.keys(obj);
    var isArr = Array.isArray(predicate);
    for(var i = 0; i < keys.length; i++){
        var key = keys[i];
        var val = obj[key];
        if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
            ret[key] = val;
        }
    }
    return ret;
};
}),
"[project]/node_modules/query-string/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const strictUriEncode = __turbopack_context__.r("[project]/node_modules/strict-uri-encode/index.js [app-client] (ecmascript)");
const decodeComponent = __turbopack_context__.r("[project]/node_modules/decode-uri-component/index.js [app-client] (ecmascript)");
const splitOnFirst = __turbopack_context__.r("[project]/node_modules/split-on-first/index.js [app-client] (ecmascript)");
const filterObject = __turbopack_context__.r("[project]/node_modules/filter-obj/index.js [app-client] (ecmascript)");
const isNullOrUndefined = (value)=>value === null || value === undefined;
const encodeFragmentIdentifier = Symbol('encodeFragmentIdentifier');
function encoderForArrayFormat(options) {
    switch(options.arrayFormat){
        case 'index':
            return (key)=>(result, value)=>{
                    const index = result.length;
                    if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
                        return result;
                    }
                    if (value === null) {
                        return [
                            ...result,
                            [
                                encode(key, options),
                                '[',
                                index,
                                ']'
                            ].join('')
                        ];
                    }
                    return [
                        ...result,
                        [
                            encode(key, options),
                            '[',
                            encode(index, options),
                            ']=',
                            encode(value, options)
                        ].join('')
                    ];
                };
        case 'bracket':
            return (key)=>(result, value)=>{
                    if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
                        return result;
                    }
                    if (value === null) {
                        return [
                            ...result,
                            [
                                encode(key, options),
                                '[]'
                            ].join('')
                        ];
                    }
                    return [
                        ...result,
                        [
                            encode(key, options),
                            '[]=',
                            encode(value, options)
                        ].join('')
                    ];
                };
        case 'colon-list-separator':
            return (key)=>(result, value)=>{
                    if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
                        return result;
                    }
                    if (value === null) {
                        return [
                            ...result,
                            [
                                encode(key, options),
                                ':list='
                            ].join('')
                        ];
                    }
                    return [
                        ...result,
                        [
                            encode(key, options),
                            ':list=',
                            encode(value, options)
                        ].join('')
                    ];
                };
        case 'comma':
        case 'separator':
        case 'bracket-separator':
            {
                const keyValueSep = options.arrayFormat === 'bracket-separator' ? '[]=' : '=';
                return (key)=>(result, value)=>{
                        if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
                            return result;
                        }
                        // Translate null to an empty string so that it doesn't serialize as 'null'
                        value = value === null ? '' : value;
                        if (result.length === 0) {
                            return [
                                [
                                    encode(key, options),
                                    keyValueSep,
                                    encode(value, options)
                                ].join('')
                            ];
                        }
                        return [
                            [
                                result,
                                encode(value, options)
                            ].join(options.arrayFormatSeparator)
                        ];
                    };
            }
        default:
            return (key)=>(result, value)=>{
                    if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
                        return result;
                    }
                    if (value === null) {
                        return [
                            ...result,
                            encode(key, options)
                        ];
                    }
                    return [
                        ...result,
                        [
                            encode(key, options),
                            '=',
                            encode(value, options)
                        ].join('')
                    ];
                };
    }
}
function parserForArrayFormat(options) {
    let result;
    switch(options.arrayFormat){
        case 'index':
            return (key, value, accumulator)=>{
                result = /\[(\d*)\]$/.exec(key);
                key = key.replace(/\[\d*\]$/, '');
                if (!result) {
                    accumulator[key] = value;
                    return;
                }
                if (accumulator[key] === undefined) {
                    accumulator[key] = {};
                }
                accumulator[key][result[1]] = value;
            };
        case 'bracket':
            return (key, value, accumulator)=>{
                result = /(\[\])$/.exec(key);
                key = key.replace(/\[\]$/, '');
                if (!result) {
                    accumulator[key] = value;
                    return;
                }
                if (accumulator[key] === undefined) {
                    accumulator[key] = [
                        value
                    ];
                    return;
                }
                accumulator[key] = [].concat(accumulator[key], value);
            };
        case 'colon-list-separator':
            return (key, value, accumulator)=>{
                result = /(:list)$/.exec(key);
                key = key.replace(/:list$/, '');
                if (!result) {
                    accumulator[key] = value;
                    return;
                }
                if (accumulator[key] === undefined) {
                    accumulator[key] = [
                        value
                    ];
                    return;
                }
                accumulator[key] = [].concat(accumulator[key], value);
            };
        case 'comma':
        case 'separator':
            return (key, value, accumulator)=>{
                const isArray = typeof value === 'string' && value.includes(options.arrayFormatSeparator);
                const isEncodedArray = typeof value === 'string' && !isArray && decode(value, options).includes(options.arrayFormatSeparator);
                value = isEncodedArray ? decode(value, options) : value;
                const newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item)=>decode(item, options)) : value === null ? value : decode(value, options);
                accumulator[key] = newValue;
            };
        case 'bracket-separator':
            return (key, value, accumulator)=>{
                const isArray = /(\[\])$/.test(key);
                key = key.replace(/\[\]$/, '');
                if (!isArray) {
                    accumulator[key] = value ? decode(value, options) : value;
                    return;
                }
                const arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item)=>decode(item, options));
                if (accumulator[key] === undefined) {
                    accumulator[key] = arrayValue;
                    return;
                }
                accumulator[key] = [].concat(accumulator[key], arrayValue);
            };
        default:
            return (key, value, accumulator)=>{
                if (accumulator[key] === undefined) {
                    accumulator[key] = value;
                    return;
                }
                accumulator[key] = [].concat(accumulator[key], value);
            };
    }
}
function validateArrayFormatSeparator(value) {
    if (typeof value !== 'string' || value.length !== 1) {
        throw new TypeError('arrayFormatSeparator must be single character string');
    }
}
function encode(value, options) {
    if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
    }
    return value;
}
function decode(value, options) {
    if (options.decode) {
        return decodeComponent(value);
    }
    return value;
}
function keysSorter(input) {
    if (Array.isArray(input)) {
        return input.sort();
    }
    if (typeof input === 'object') {
        return keysSorter(Object.keys(input)).sort((a, b)=>Number(a) - Number(b)).map((key)=>input[key]);
    }
    return input;
}
function removeHash(input) {
    const hashStart = input.indexOf('#');
    if (hashStart !== -1) {
        input = input.slice(0, hashStart);
    }
    return input;
}
function getHash(url) {
    let hash = '';
    const hashStart = url.indexOf('#');
    if (hashStart !== -1) {
        hash = url.slice(hashStart);
    }
    return hash;
}
function extract(input) {
    input = removeHash(input);
    const queryStart = input.indexOf('?');
    if (queryStart === -1) {
        return '';
    }
    return input.slice(queryStart + 1);
}
function parseValue(value, options) {
    if (options.parseNumbers && !Number.isNaN(Number(value)) && typeof value === 'string' && value.trim() !== '') {
        value = Number(value);
    } else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {
        value = value.toLowerCase() === 'true';
    }
    return value;
}
function parse(query, options) {
    options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: 'none',
        arrayFormatSeparator: ',',
        parseNumbers: false,
        parseBooleans: false
    }, options);
    validateArrayFormatSeparator(options.arrayFormatSeparator);
    const formatter = parserForArrayFormat(options);
    // Create an object with no prototype
    const ret = Object.create(null);
    if (typeof query !== 'string') {
        return ret;
    }
    query = query.trim().replace(/^[?#&]/, '');
    if (!query) {
        return ret;
    }
    for (const param of query.split('&')){
        if (param === '') {
            continue;
        }
        let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, ' ') : param, '=');
        // Missing `=` should be `null`:
        // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
        value = value === undefined ? null : [
            'comma',
            'separator',
            'bracket-separator'
        ].includes(options.arrayFormat) ? value : decode(value, options);
        formatter(decode(key, options), value, ret);
    }
    for (const key of Object.keys(ret)){
        const value = ret[key];
        if (typeof value === 'object' && value !== null) {
            for (const k of Object.keys(value)){
                value[k] = parseValue(value[k], options);
            }
        } else {
            ret[key] = parseValue(value, options);
        }
    }
    if (options.sort === false) {
        return ret;
    }
    return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key)=>{
        const value = ret[key];
        if (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {
            // Sort object keys, not values
            result[key] = keysSorter(value);
        } else {
            result[key] = value;
        }
        return result;
    }, Object.create(null));
}
exports.extract = extract;
exports.parse = parse;
exports.stringify = (object, options)=>{
    if (!object) {
        return '';
    }
    options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: 'none',
        arrayFormatSeparator: ','
    }, options);
    validateArrayFormatSeparator(options.arrayFormatSeparator);
    const shouldFilter = (key)=>options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === '';
    const formatter = encoderForArrayFormat(options);
    const objectCopy = {};
    for (const key of Object.keys(object)){
        if (!shouldFilter(key)) {
            objectCopy[key] = object[key];
        }
    }
    const keys = Object.keys(objectCopy);
    if (options.sort !== false) {
        keys.sort(options.sort);
    }
    return keys.map((key)=>{
        const value = object[key];
        if (value === undefined) {
            return '';
        }
        if (value === null) {
            return encode(key, options);
        }
        if (Array.isArray(value)) {
            if (value.length === 0 && options.arrayFormat === 'bracket-separator') {
                return encode(key, options) + '[]';
            }
            return value.reduce(formatter(key), []).join('&');
        }
        return encode(key, options) + '=' + encode(value, options);
    }).filter((x)=>x.length > 0).join('&');
};
exports.parseUrl = (url, options)=>{
    options = Object.assign({
        decode: true
    }, options);
    const [url_, hash] = splitOnFirst(url, '#');
    return Object.assign({
        url: url_.split('?')[0] || '',
        query: parse(extract(url), options)
    }, options && options.parseFragmentIdentifier && hash ? {
        fragmentIdentifier: decode(hash, options)
    } : {});
};
exports.stringifyUrl = (object, options)=>{
    options = Object.assign({
        encode: true,
        strict: true,
        [encodeFragmentIdentifier]: true
    }, options);
    const url = removeHash(object.url).split('?')[0] || '';
    const queryFromUrl = exports.extract(object.url);
    const parsedQueryFromUrl = exports.parse(queryFromUrl, {
        sort: false
    });
    const query = Object.assign(parsedQueryFromUrl, object.query);
    let queryString = exports.stringify(query, options);
    if (queryString) {
        queryString = `?${queryString}`;
    }
    let hash = getHash(object.url);
    if (object.fragmentIdentifier) {
        hash = `#${options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
    }
    return `${url}${queryString}${hash}`;
};
exports.pick = (input, filter, options)=>{
    options = Object.assign({
        parseFragmentIdentifier: true,
        [encodeFragmentIdentifier]: false
    }, options);
    const { url, query, fragmentIdentifier } = exports.parseUrl(input, options);
    return exports.stringifyUrl({
        url,
        query: filterObject(query, filter),
        fragmentIdentifier
    }, options);
};
exports.exclude = (input, filter, options)=>{
    const exclusionFilter = Array.isArray(filter) ? (key)=>!filter.includes(key) : (key, value)=>!filter(key, value);
    return exports.pick(input, exclusionFilter, options);
};
}),
"[project]/node_modules/destr/dist/index.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>destr,
    "destr",
    ()=>destr,
    "safeDestr",
    ()=>safeDestr
]);
const suspectProtoRx = /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/;
const suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
const JsonSigRx = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
function jsonParseTransform(key, value) {
    if (key === "__proto__" || key === "constructor" && value && typeof value === "object" && "prototype" in value) {
        warnKeyDropped(key);
        return;
    }
    return value;
}
function warnKeyDropped(key) {
    console.warn(`[destr] Dropping "${key}" key to prevent prototype pollution.`);
}
function destr(value, options = {}) {
    if (typeof value !== "string") {
        return value;
    }
    if (value[0] === '"' && value[value.length - 1] === '"' && value.indexOf("\\") === -1) {
        return value.slice(1, -1);
    }
    const _value = value.trim();
    if (_value.length <= 9) {
        switch(_value.toLowerCase()){
            case "true":
                {
                    return true;
                }
            case "false":
                {
                    return false;
                }
            case "undefined":
                {
                    return void 0;
                }
            case "null":
                {
                    return null;
                }
            case "nan":
                {
                    return Number.NaN;
                }
            case "infinity":
                {
                    return Number.POSITIVE_INFINITY;
                }
            case "-infinity":
                {
                    return Number.NEGATIVE_INFINITY;
                }
        }
    }
    if (!JsonSigRx.test(value)) {
        if (options.strict) {
            throw new SyntaxError("[destr] Invalid JSON");
        }
        return value;
    }
    try {
        if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {
            if (options.strict) {
                throw new Error("[destr] Possible prototype pollution");
            }
            return JSON.parse(value, jsonParseTransform);
        }
        return JSON.parse(value);
    } catch (error) {
        if (options.strict) {
            throw error;
        }
        return value;
    }
}
function safeDestr(value, options = {}) {
    return destr(value, {
        ...options,
        strict: true
    });
}
;
}),
"[project]/node_modules/unstorage/dist/shared/unstorage.zVDD2mZo.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "a",
    ()=>normalizeKey,
    "b",
    ()=>asyncCall,
    "c",
    ()=>filterKeyByBase,
    "d",
    ()=>stringify,
    "e",
    ()=>deserializeRaw,
    "f",
    ()=>filterKeyByDepth,
    "j",
    ()=>joinKeys,
    "n",
    ()=>normalizeBaseKey,
    "p",
    ()=>prefixStorage,
    "s",
    ()=>serializeRaw
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
function wrapToPromise(value) {
    if (!value || typeof value.then !== "function") {
        return Promise.resolve(value);
    }
    return value;
}
function asyncCall(function_, ...arguments_) {
    try {
        return wrapToPromise(function_(...arguments_));
    } catch (error) {
        return Promise.reject(error);
    }
}
function isPrimitive(value) {
    const type = typeof value;
    return value === null || type !== "object" && type !== "function";
}
function isPureObject(value) {
    const proto = Object.getPrototypeOf(value);
    return !proto || proto.isPrototypeOf(Object);
}
function stringify(value) {
    if (isPrimitive(value)) {
        return String(value);
    }
    if (isPureObject(value) || Array.isArray(value)) {
        return JSON.stringify(value);
    }
    if (typeof value.toJSON === "function") {
        return stringify(value.toJSON());
    }
    throw new Error("[unstorage] Cannot stringify value!");
}
const BASE64_PREFIX = "base64:";
function serializeRaw(value) {
    if (typeof value === "string") {
        return value;
    }
    return BASE64_PREFIX + base64Encode(value);
}
function deserializeRaw(value) {
    if (typeof value !== "string") {
        return value;
    }
    if (!value.startsWith(BASE64_PREFIX)) {
        return value;
    }
    return base64Decode(value.slice(BASE64_PREFIX.length));
}
function base64Decode(input) {
    if (globalThis.Buffer) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(input, "base64");
    }
    return Uint8Array.from(globalThis.atob(input), (c)=>c.codePointAt(0));
}
function base64Encode(input) {
    if (globalThis.Buffer) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(input).toString("base64");
    }
    return globalThis.btoa(String.fromCodePoint(...input));
}
const storageKeyProperties = [
    "has",
    "hasItem",
    "get",
    "getItem",
    "getItemRaw",
    "set",
    "setItem",
    "setItemRaw",
    "del",
    "remove",
    "removeItem",
    "getMeta",
    "setMeta",
    "removeMeta",
    "getKeys",
    "clear",
    "mount",
    "unmount"
];
function prefixStorage(storage, base) {
    base = normalizeBaseKey(base);
    if (!base) {
        return storage;
    }
    const nsStorage = {
        ...storage
    };
    for (const property of storageKeyProperties){
        nsStorage[property] = (key = "", ...args)=>// @ts-ignore
            storage[property](base + key, ...args);
    }
    nsStorage.getKeys = (key = "", ...arguments_)=>storage.getKeys(base + key, ...arguments_).then((keys)=>keys.map((key2)=>key2.slice(base.length)));
    nsStorage.keys = nsStorage.getKeys;
    nsStorage.getItems = async (items, commonOptions)=>{
        const prefixedItems = items.map((item)=>typeof item === "string" ? base + item : {
                ...item,
                key: base + item.key
            });
        const results = await storage.getItems(prefixedItems, commonOptions);
        return results.map((entry)=>({
                key: entry.key.slice(base.length),
                value: entry.value
            }));
    };
    nsStorage.setItems = async (items, commonOptions)=>{
        const prefixedItems = items.map((item)=>({
                key: base + item.key,
                value: item.value,
                options: item.options
            }));
        return storage.setItems(prefixedItems, commonOptions);
    };
    return nsStorage;
}
function normalizeKey(key) {
    if (!key) {
        return "";
    }
    return key.split("?")[0]?.replace(/[/\\]/g, ":").replace(/:+/g, ":").replace(/^:|:$/g, "") || "";
}
function joinKeys(...keys) {
    return normalizeKey(keys.join(":"));
}
function normalizeBaseKey(base) {
    base = normalizeKey(base);
    return base ? base + ":" : "";
}
function filterKeyByDepth(key, depth) {
    if (depth === void 0) {
        return true;
    }
    let substrCount = 0;
    let index = key.indexOf(":");
    while(index > -1){
        substrCount++;
        index = key.indexOf(":", index + 1);
    }
    return substrCount <= depth;
}
function filterKeyByBase(key, base) {
    if (base) {
        return key.startsWith(base) && key[key.length - 1] !== "$";
    }
    return key[key.length - 1] !== "$";
}
;
}),
"[project]/node_modules/unstorage/dist/index.mjs [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "builtinDrivers",
    ()=>builtinDrivers,
    "createStorage",
    ()=>createStorage,
    "defineDriver",
    ()=>defineDriver,
    "restoreSnapshot",
    ()=>restoreSnapshot,
    "snapshot",
    ()=>snapshot
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$destr$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/destr/dist/index.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/unstorage/dist/shared/unstorage.zVDD2mZo.mjs [app-client] (ecmascript)");
;
;
;
function defineDriver(factory) {
    return factory;
}
const DRIVER_NAME = "memory";
const memory = defineDriver(()=>{
    const data = /* @__PURE__ */ new Map();
    return {
        name: DRIVER_NAME,
        getInstance: ()=>data,
        hasItem (key) {
            return data.has(key);
        },
        getItem (key) {
            return data.get(key) ?? null;
        },
        getItemRaw (key) {
            return data.get(key) ?? null;
        },
        setItem (key, value) {
            data.set(key, value);
        },
        setItemRaw (key, value) {
            data.set(key, value);
        },
        removeItem (key) {
            data.delete(key);
        },
        getKeys () {
            return [
                ...data.keys()
            ];
        },
        clear () {
            data.clear();
        },
        dispose () {
            data.clear();
        }
    };
});
function createStorage(options = {}) {
    const context = {
        mounts: {
            "": options.driver || memory()
        },
        mountpoints: [
            ""
        ],
        watching: false,
        watchListeners: [],
        unwatch: {}
    };
    const getMount = (key)=>{
        for (const base of context.mountpoints){
            if (key.startsWith(base)) {
                return {
                    base,
                    relativeKey: key.slice(base.length),
                    driver: context.mounts[base]
                };
            }
        }
        return {
            base: "",
            relativeKey: key,
            driver: context.mounts[""]
        };
    };
    const getMounts = (base, includeParent)=>{
        return context.mountpoints.filter((mountpoint)=>mountpoint.startsWith(base) || includeParent && base.startsWith(mountpoint)).map((mountpoint)=>({
                relativeBase: base.length > mountpoint.length ? base.slice(mountpoint.length) : void 0,
                mountpoint,
                driver: context.mounts[mountpoint]
            }));
    };
    const onChange = (event, key)=>{
        if (!context.watching) {
            return;
        }
        key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(key);
        for (const listener of context.watchListeners){
            listener(event, key);
        }
    };
    const startWatch = async ()=>{
        if (context.watching) {
            return;
        }
        context.watching = true;
        for(const mountpoint in context.mounts){
            context.unwatch[mountpoint] = await watch(context.mounts[mountpoint], onChange, mountpoint);
        }
    };
    const stopWatch = async ()=>{
        if (!context.watching) {
            return;
        }
        for(const mountpoint in context.unwatch){
            await context.unwatch[mountpoint]();
        }
        context.unwatch = {};
        context.watching = false;
    };
    const runBatch = (items, commonOptions, cb)=>{
        const batches = /* @__PURE__ */ new Map();
        const getBatch = (mount)=>{
            let batch = batches.get(mount.base);
            if (!batch) {
                batch = {
                    driver: mount.driver,
                    base: mount.base,
                    items: []
                };
                batches.set(mount.base, batch);
            }
            return batch;
        };
        for (const item of items){
            const isStringItem = typeof item === "string";
            const key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(isStringItem ? item : item.key);
            const value = isStringItem ? void 0 : item.value;
            const options2 = isStringItem || !item.options ? commonOptions : {
                ...commonOptions,
                ...item.options
            };
            const mount = getMount(key);
            getBatch(mount).items.push({
                key,
                value,
                relativeKey: mount.relativeKey,
                options: options2
            });
        }
        return Promise.all([
            ...batches.values()
        ].map((batch)=>cb(batch))).then((r)=>r.flat());
    };
    const storage = {
        // Item
        hasItem (key, opts = {}) {
            key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(key);
            const { relativeKey, driver } = getMount(key);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b"])(driver.hasItem, relativeKey, opts);
        },
        getItem (key, opts = {}) {
            key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(key);
            const { relativeKey, driver } = getMount(key);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b"])(driver.getItem, relativeKey, opts).then((value)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$destr$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(value));
        },
        getItems (items, commonOptions = {}) {
            return runBatch(items, commonOptions, (batch)=>{
                if (batch.driver.getItems) {
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b"])(batch.driver.getItems, batch.items.map((item)=>({
                            key: item.relativeKey,
                            options: item.options
                        })), commonOptions).then((r)=>r.map((item)=>({
                                key: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["j"])(batch.base, item.key),
                                value: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$destr$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(item.value)
                            })));
                }
                return Promise.all(batch.items.map((item)=>{
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b"])(batch.driver.getItem, item.relativeKey, item.options).then((value)=>({
                            key: item.key,
                            value: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$destr$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(value)
                        }));
                }));
            });
        },
        getItemRaw (key, opts = {}) {
            key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(key);
            const { relativeKey, driver } = getMount(key);
            if (driver.getItemRaw) {
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b"])(driver.getItemRaw, relativeKey, opts);
            }
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b"])(driver.getItem, relativeKey, opts).then((value)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["e"])(value));
        },
        async setItem (key, value, opts = {}) {
            if (value === void 0) {
                return storage.removeItem(key);
            }
            key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(key);
            const { relativeKey, driver } = getMount(key);
            if (!driver.setItem) {
                return;
            }
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b"])(driver.setItem, relativeKey, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(value), opts);
            if (!driver.watch) {
                onChange("update", key);
            }
        },
        async setItems (items, commonOptions) {
            await runBatch(items, commonOptions, async (batch)=>{
                if (batch.driver.setItems) {
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b"])(batch.driver.setItems, batch.items.map((item)=>({
                            key: item.relativeKey,
                            value: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(item.value),
                            options: item.options
                        })), commonOptions);
                }
                if (!batch.driver.setItem) {
                    return;
                }
                await Promise.all(batch.items.map((item)=>{
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b"])(batch.driver.setItem, item.relativeKey, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["d"])(item.value), item.options);
                }));
            });
        },
        async setItemRaw (key, value, opts = {}) {
            if (value === void 0) {
                return storage.removeItem(key, opts);
            }
            key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(key);
            const { relativeKey, driver } = getMount(key);
            if (driver.setItemRaw) {
                await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b"])(driver.setItemRaw, relativeKey, value, opts);
            } else if (driver.setItem) {
                await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b"])(driver.setItem, relativeKey, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["s"])(value), opts);
            } else {
                return;
            }
            if (!driver.watch) {
                onChange("update", key);
            }
        },
        async removeItem (key, opts = {}) {
            if (typeof opts === "boolean") {
                opts = {
                    removeMeta: opts
                };
            }
            key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(key);
            const { relativeKey, driver } = getMount(key);
            if (!driver.removeItem) {
                return;
            }
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b"])(driver.removeItem, relativeKey, opts);
            if (opts.removeMeta || opts.removeMata) {
                await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b"])(driver.removeItem, relativeKey + "$", opts);
            }
            if (!driver.watch) {
                onChange("remove", key);
            }
        },
        // Meta
        async getMeta (key, opts = {}) {
            if (typeof opts === "boolean") {
                opts = {
                    nativeOnly: opts
                };
            }
            key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(key);
            const { relativeKey, driver } = getMount(key);
            const meta = /* @__PURE__ */ Object.create(null);
            if (driver.getMeta) {
                Object.assign(meta, await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b"])(driver.getMeta, relativeKey, opts));
            }
            if (!opts.nativeOnly) {
                const value = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b"])(driver.getItem, relativeKey + "$", opts).then((value_)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$destr$2f$dist$2f$index$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(value_));
                if (value && typeof value === "object") {
                    if (typeof value.atime === "string") {
                        value.atime = new Date(value.atime);
                    }
                    if (typeof value.mtime === "string") {
                        value.mtime = new Date(value.mtime);
                    }
                    Object.assign(meta, value);
                }
            }
            return meta;
        },
        setMeta (key, value, opts = {}) {
            return this.setItem(key + "$", value, opts);
        },
        removeMeta (key, opts = {}) {
            return this.removeItem(key + "$", opts);
        },
        // Keys
        async getKeys (base, opts = {}) {
            base = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["n"])(base);
            const mounts = getMounts(base, true);
            let maskedMounts = [];
            const allKeys = [];
            let allMountsSupportMaxDepth = true;
            for (const mount of mounts){
                if (!mount.driver.flags?.maxDepth) {
                    allMountsSupportMaxDepth = false;
                }
                const rawKeys = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b"])(mount.driver.getKeys, mount.relativeBase, opts);
                for (const key of rawKeys){
                    const fullKey = mount.mountpoint + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(key);
                    if (!maskedMounts.some((p)=>fullKey.startsWith(p))) {
                        allKeys.push(fullKey);
                    }
                }
                maskedMounts = [
                    mount.mountpoint,
                    ...maskedMounts.filter((p)=>!p.startsWith(mount.mountpoint))
                ];
            }
            const shouldFilterByDepth = opts.maxDepth !== void 0 && !allMountsSupportMaxDepth;
            return allKeys.filter((key)=>(!shouldFilterByDepth || (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["f"])(key, opts.maxDepth)) && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["c"])(key, base));
        },
        // Utils
        async clear (base, opts = {}) {
            base = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["n"])(base);
            await Promise.all(getMounts(base, false).map(async (m)=>{
                if (m.driver.clear) {
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b"])(m.driver.clear, m.relativeBase, opts);
                }
                if (m.driver.removeItem) {
                    const keys = await m.driver.getKeys(m.relativeBase || "", opts);
                    return Promise.all(keys.map((key)=>m.driver.removeItem(key, opts)));
                }
            }));
        },
        async dispose () {
            await Promise.all(Object.values(context.mounts).map((driver)=>dispose(driver)));
        },
        async watch (callback) {
            await startWatch();
            context.watchListeners.push(callback);
            return async ()=>{
                context.watchListeners = context.watchListeners.filter((listener)=>listener !== callback);
                if (context.watchListeners.length === 0) {
                    await stopWatch();
                }
            };
        },
        async unwatch () {
            context.watchListeners = [];
            await stopWatch();
        },
        // Mount
        mount (base, driver) {
            base = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["n"])(base);
            if (base && context.mounts[base]) {
                throw new Error(`already mounted at ${base}`);
            }
            if (base) {
                context.mountpoints.push(base);
                context.mountpoints.sort((a, b)=>b.length - a.length);
            }
            context.mounts[base] = driver;
            if (context.watching) {
                Promise.resolve(watch(driver, onChange, base)).then((unwatcher)=>{
                    context.unwatch[base] = unwatcher;
                }).catch(console.error);
            }
            return storage;
        },
        async unmount (base, _dispose = true) {
            base = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["n"])(base);
            if (!base || !context.mounts[base]) {
                return;
            }
            if (context.watching && base in context.unwatch) {
                context.unwatch[base]?.();
                delete context.unwatch[base];
            }
            if (_dispose) {
                await dispose(context.mounts[base]);
            }
            context.mountpoints = context.mountpoints.filter((key)=>key !== base);
            delete context.mounts[base];
        },
        getMount (key = "") {
            key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(key) + ":";
            const m = getMount(key);
            return {
                driver: m.driver,
                base: m.base
            };
        },
        getMounts (base = "", opts = {}) {
            base = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["a"])(base);
            const mounts = getMounts(base, opts.parents);
            return mounts.map((m)=>({
                    driver: m.driver,
                    base: m.mountpoint
                }));
        },
        // Aliases
        keys: (base, opts = {})=>storage.getKeys(base, opts),
        get: (key, opts = {})=>storage.getItem(key, opts),
        set: (key, value, opts = {})=>storage.setItem(key, value, opts),
        has: (key, opts = {})=>storage.hasItem(key, opts),
        del: (key, opts = {})=>storage.removeItem(key, opts),
        remove: (key, opts = {})=>storage.removeItem(key, opts)
    };
    return storage;
}
async function snapshot(storage, base) {
    base = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["n"])(base);
    const keys = await storage.getKeys(base);
    const snapshot2 = {};
    await Promise.all(keys.map(async (key)=>{
        snapshot2[key.slice(base.length)] = await storage.getItem(key);
    }));
    return snapshot2;
}
async function restoreSnapshot(driver, snapshot2, base = "") {
    base = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["n"])(base);
    await Promise.all(Object.entries(snapshot2).map((e)=>driver.setItem(base + e[0], e[1])));
}
function watch(driver, onChange, base) {
    return driver.watch ? driver.watch((event, key)=>onChange(event, base + key)) : ()=>{};
}
async function dispose(driver) {
    if (typeof driver.dispose === "function") {
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$unstorage$2f$dist$2f$shared$2f$unstorage$2e$zVDD2mZo$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["b"])(driver.dispose);
    }
}
const builtinDrivers = {
    "azure-app-configuration": "unstorage/drivers/azure-app-configuration",
    "azureAppConfiguration": "unstorage/drivers/azure-app-configuration",
    "azure-cosmos": "unstorage/drivers/azure-cosmos",
    "azureCosmos": "unstorage/drivers/azure-cosmos",
    "azure-key-vault": "unstorage/drivers/azure-key-vault",
    "azureKeyVault": "unstorage/drivers/azure-key-vault",
    "azure-storage-blob": "unstorage/drivers/azure-storage-blob",
    "azureStorageBlob": "unstorage/drivers/azure-storage-blob",
    "azure-storage-table": "unstorage/drivers/azure-storage-table",
    "azureStorageTable": "unstorage/drivers/azure-storage-table",
    "capacitor-preferences": "unstorage/drivers/capacitor-preferences",
    "capacitorPreferences": "unstorage/drivers/capacitor-preferences",
    "cloudflare-kv-binding": "unstorage/drivers/cloudflare-kv-binding",
    "cloudflareKVBinding": "unstorage/drivers/cloudflare-kv-binding",
    "cloudflare-kv-http": "unstorage/drivers/cloudflare-kv-http",
    "cloudflareKVHttp": "unstorage/drivers/cloudflare-kv-http",
    "cloudflare-r2-binding": "unstorage/drivers/cloudflare-r2-binding",
    "cloudflareR2Binding": "unstorage/drivers/cloudflare-r2-binding",
    "db0": "unstorage/drivers/db0",
    "deno-kv-node": "unstorage/drivers/deno-kv-node",
    "denoKVNode": "unstorage/drivers/deno-kv-node",
    "deno-kv": "unstorage/drivers/deno-kv",
    "denoKV": "unstorage/drivers/deno-kv",
    "fs-lite": "unstorage/drivers/fs-lite",
    "fsLite": "unstorage/drivers/fs-lite",
    "fs": "unstorage/drivers/fs",
    "github": "unstorage/drivers/github",
    "http": "unstorage/drivers/http",
    "indexedb": "unstorage/drivers/indexedb",
    "localstorage": "unstorage/drivers/localstorage",
    "lru-cache": "unstorage/drivers/lru-cache",
    "lruCache": "unstorage/drivers/lru-cache",
    "memory": "unstorage/drivers/memory",
    "mongodb": "unstorage/drivers/mongodb",
    "netlify-blobs": "unstorage/drivers/netlify-blobs",
    "netlifyBlobs": "unstorage/drivers/netlify-blobs",
    "null": "unstorage/drivers/null",
    "overlay": "unstorage/drivers/overlay",
    "planetscale": "unstorage/drivers/planetscale",
    "redis": "unstorage/drivers/redis",
    "s3": "unstorage/drivers/s3",
    "session-storage": "unstorage/drivers/session-storage",
    "sessionStorage": "unstorage/drivers/session-storage",
    "uploadthing": "unstorage/drivers/uploadthing",
    "upstash": "unstorage/drivers/upstash",
    "vercel-blob": "unstorage/drivers/vercel-blob",
    "vercelBlob": "unstorage/drivers/vercel-blob",
    "vercel-kv": "unstorage/drivers/vercel-kv",
    "vercelKV": "unstorage/drivers/vercel-kv",
    "vercel-runtime-cache": "unstorage/drivers/vercel-runtime-cache",
    "vercelRuntimeCache": "unstorage/drivers/vercel-runtime-cache"
};
;
}),
"[project]/node_modules/idb-keyval/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "clear",
    ()=>clear,
    "createStore",
    ()=>createStore,
    "del",
    ()=>del,
    "delMany",
    ()=>delMany,
    "entries",
    ()=>entries,
    "get",
    ()=>get,
    "getMany",
    ()=>getMany,
    "keys",
    ()=>keys,
    "promisifyRequest",
    ()=>promisifyRequest,
    "set",
    ()=>set,
    "setMany",
    ()=>setMany,
    "update",
    ()=>update,
    "values",
    ()=>values
]);
function promisifyRequest(request) {
    return new Promise((resolve, reject)=>{
        // @ts-ignore - file size hacks
        request.oncomplete = request.onsuccess = ()=>resolve(request.result);
        // @ts-ignore - file size hacks
        request.onabort = request.onerror = ()=>reject(request.error);
    });
}
function createStore(dbName, storeName) {
    let dbp;
    const getDB = ()=>{
        if (dbp) return dbp;
        const request = indexedDB.open(dbName);
        request.onupgradeneeded = ()=>request.result.createObjectStore(storeName);
        dbp = promisifyRequest(request);
        dbp.then((db)=>{
            // It seems like Safari sometimes likes to just close the connection.
            // It's supposed to fire this event when that happens. Let's hope it does!
            db.onclose = ()=>dbp = undefined;
        }, ()=>{});
        return dbp;
    };
    return (txMode, callback)=>getDB().then((db)=>callback(db.transaction(storeName, txMode).objectStore(storeName)));
}
let defaultGetStoreFunc;
function defaultGetStore() {
    if (!defaultGetStoreFunc) {
        defaultGetStoreFunc = createStore('keyval-store', 'keyval');
    }
    return defaultGetStoreFunc;
}
/**
 * Get a value by its key.
 *
 * @param key
 * @param customStore Method to get a custom store. Use with caution (see the docs).
 */ function get(key, customStore = defaultGetStore()) {
    return customStore('readonly', (store)=>promisifyRequest(store.get(key)));
}
/**
 * Set a value with a key.
 *
 * @param key
 * @param value
 * @param customStore Method to get a custom store. Use with caution (see the docs).
 */ function set(key, value, customStore = defaultGetStore()) {
    return customStore('readwrite', (store)=>{
        store.put(value, key);
        return promisifyRequest(store.transaction);
    });
}
/**
 * Set multiple values at once. This is faster than calling set() multiple times.
 * It's also atomic  if one of the pairs can't be added, none will be added.
 *
 * @param entries Array of entries, where each entry is an array of `[key, value]`.
 * @param customStore Method to get a custom store. Use with caution (see the docs).
 */ function setMany(entries, customStore = defaultGetStore()) {
    return customStore('readwrite', (store)=>{
        entries.forEach((entry)=>store.put(entry[1], entry[0]));
        return promisifyRequest(store.transaction);
    });
}
/**
 * Get multiple values by their keys
 *
 * @param keys
 * @param customStore Method to get a custom store. Use with caution (see the docs).
 */ function getMany(keys, customStore = defaultGetStore()) {
    return customStore('readonly', (store)=>Promise.all(keys.map((key)=>promisifyRequest(store.get(key)))));
}
/**
 * Update a value. This lets you see the old value and update it as an atomic operation.
 *
 * @param key
 * @param updater A callback that takes the old value and returns a new value.
 * @param customStore Method to get a custom store. Use with caution (see the docs).
 */ function update(key, updater, customStore = defaultGetStore()) {
    return customStore('readwrite', (store)=>// Need to create the promise manually.
        // If I try to chain promises, the transaction closes in browsers
        // that use a promise polyfill (IE10/11).
        new Promise((resolve, reject)=>{
            store.get(key).onsuccess = function() {
                try {
                    store.put(updater(this.result), key);
                    resolve(promisifyRequest(store.transaction));
                } catch (err) {
                    reject(err);
                }
            };
        }));
}
/**
 * Delete a particular key from the store.
 *
 * @param key
 * @param customStore Method to get a custom store. Use with caution (see the docs).
 */ function del(key, customStore = defaultGetStore()) {
    return customStore('readwrite', (store)=>{
        store.delete(key);
        return promisifyRequest(store.transaction);
    });
}
/**
 * Delete multiple keys at once.
 *
 * @param keys List of keys to delete.
 * @param customStore Method to get a custom store. Use with caution (see the docs).
 */ function delMany(keys, customStore = defaultGetStore()) {
    return customStore('readwrite', (store)=>{
        keys.forEach((key)=>store.delete(key));
        return promisifyRequest(store.transaction);
    });
}
/**
 * Clear all values in the store.
 *
 * @param customStore Method to get a custom store. Use with caution (see the docs).
 */ function clear(customStore = defaultGetStore()) {
    return customStore('readwrite', (store)=>{
        store.clear();
        return promisifyRequest(store.transaction);
    });
}
function eachCursor(store, callback) {
    store.openCursor().onsuccess = function() {
        if (!this.result) return;
        callback(this.result);
        this.result.continue();
    };
    return promisifyRequest(store.transaction);
}
/**
 * Get all keys in the store.
 *
 * @param customStore Method to get a custom store. Use with caution (see the docs).
 */ function keys(customStore = defaultGetStore()) {
    return customStore('readonly', (store)=>{
        // Fast path for modern browsers
        if (store.getAllKeys) {
            return promisifyRequest(store.getAllKeys());
        }
        const items = [];
        return eachCursor(store, (cursor)=>items.push(cursor.key)).then(()=>items);
    });
}
/**
 * Get all values in the store.
 *
 * @param customStore Method to get a custom store. Use with caution (see the docs).
 */ function values(customStore = defaultGetStore()) {
    return customStore('readonly', (store)=>{
        // Fast path for modern browsers
        if (store.getAll) {
            return promisifyRequest(store.getAll());
        }
        const items = [];
        return eachCursor(store, (cursor)=>items.push(cursor.value)).then(()=>items);
    });
}
/**
 * Get all entries in the store. Each entry is an array of `[key, value]`.
 *
 * @param customStore Method to get a custom store. Use with caution (see the docs).
 */ function entries(customStore = defaultGetStore()) {
    return customStore('readonly', (store)=>{
        // Fast path for modern browsers
        // (although, hopefully we'll get a simpler path some day)
        if (store.getAll && store.getAllKeys) {
            return Promise.all([
                promisifyRequest(store.getAllKeys()),
                promisifyRequest(store.getAll())
            ]).then(([keys, values])=>keys.map((key, i)=>[
                        key,
                        values[i]
                    ]));
        }
        const items = [];
        return customStore('readonly', (store)=>eachCursor(store, (cursor)=>items.push([
                    cursor.key,
                    cursor.value
                ])).then(()=>items));
    });
}
;
}),
"[project]/node_modules/quick-format-unescaped/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

function tryStringify(o) {
    try {
        return JSON.stringify(o);
    } catch (e) {
        return '"[Circular]"';
    }
}
module.exports = format;
function format(f, args, opts) {
    var ss = opts && opts.stringify || tryStringify;
    var offset = 1;
    if (typeof f === 'object' && f !== null) {
        var len = args.length + offset;
        if (len === 1) return f;
        var objects = new Array(len);
        objects[0] = ss(f);
        for(var index = 1; index < len; index++){
            objects[index] = ss(args[index]);
        }
        return objects.join(' ');
    }
    if (typeof f !== 'string') {
        return f;
    }
    var argLen = args.length;
    if (argLen === 0) return f;
    var str = '';
    var a = 1 - offset;
    var lastPos = -1;
    var flen = f && f.length || 0;
    for(var i = 0; i < flen;){
        if (f.charCodeAt(i) === 37 && i + 1 < flen) {
            lastPos = lastPos > -1 ? lastPos : 0;
            switch(f.charCodeAt(i + 1)){
                case 100:
                case 102:
                    if (a >= argLen) break;
                    if (args[a] == null) break;
                    if (lastPos < i) str += f.slice(lastPos, i);
                    str += Number(args[a]);
                    lastPos = i + 2;
                    i++;
                    break;
                case 105:
                    if (a >= argLen) break;
                    if (args[a] == null) break;
                    if (lastPos < i) str += f.slice(lastPos, i);
                    str += Math.floor(Number(args[a]));
                    lastPos = i + 2;
                    i++;
                    break;
                case 79:
                case 111:
                case 106:
                    if (a >= argLen) break;
                    if (args[a] === undefined) break;
                    if (lastPos < i) str += f.slice(lastPos, i);
                    var type = typeof args[a];
                    if (type === 'string') {
                        str += '\'' + args[a] + '\'';
                        lastPos = i + 2;
                        i++;
                        break;
                    }
                    if (type === 'function') {
                        str += args[a].name || '<anonymous>';
                        lastPos = i + 2;
                        i++;
                        break;
                    }
                    str += ss(args[a]);
                    lastPos = i + 2;
                    i++;
                    break;
                case 115:
                    if (a >= argLen) break;
                    if (lastPos < i) str += f.slice(lastPos, i);
                    str += String(args[a]);
                    lastPos = i + 2;
                    i++;
                    break;
                case 37:
                    if (lastPos < i) str += f.slice(lastPos, i);
                    str += '%';
                    lastPos = i + 2;
                    i++;
                    a--;
                    break;
            }
            ++a;
        }
        ++i;
    }
    if (lastPos === -1) return f;
    else if (lastPos < flen) {
        str += f.slice(lastPos);
    }
    return str;
}
}),
"[project]/node_modules/pino/browser.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const format = __turbopack_context__.r("[project]/node_modules/quick-format-unescaped/index.js [app-client] (ecmascript)");
module.exports = pino;
const _console = pfGlobalThisOrFallback().console || {};
const stdSerializers = {
    mapHttpRequest: mock,
    mapHttpResponse: mock,
    wrapRequestSerializer: passthrough,
    wrapResponseSerializer: passthrough,
    wrapErrorSerializer: passthrough,
    req: mock,
    res: mock,
    err: asErrValue
};
function shouldSerialize(serialize, serializers) {
    if (Array.isArray(serialize)) {
        const hasToFilter = serialize.filter(function(k) {
            return k !== '!stdSerializers.err';
        });
        return hasToFilter;
    } else if (serialize === true) {
        return Object.keys(serializers);
    }
    return false;
}
function pino(opts) {
    opts = opts || {};
    opts.browser = opts.browser || {};
    const transmit = opts.browser.transmit;
    if (transmit && typeof transmit.send !== 'function') {
        throw Error('pino: transmit option must have a send function');
    }
    const proto = opts.browser.write || _console;
    if (opts.browser.write) opts.browser.asObject = true;
    const serializers = opts.serializers || {};
    const serialize = shouldSerialize(opts.browser.serialize, serializers);
    let stdErrSerialize = opts.browser.serialize;
    if (Array.isArray(opts.browser.serialize) && opts.browser.serialize.indexOf('!stdSerializers.err') > -1) stdErrSerialize = false;
    const levels = [
        'error',
        'fatal',
        'warn',
        'info',
        'debug',
        'trace'
    ];
    if (typeof proto === 'function') {
        proto.error = proto.fatal = proto.warn = proto.info = proto.debug = proto.trace = proto;
    }
    if (opts.enabled === false) opts.level = 'silent';
    const level = opts.level || 'info';
    const logger = Object.create(proto);
    if (!logger.log) logger.log = noop;
    Object.defineProperty(logger, 'levelVal', {
        get: getLevelVal
    });
    Object.defineProperty(logger, 'level', {
        get: getLevel,
        set: setLevel
    });
    const setOpts = {
        transmit,
        serialize,
        asObject: opts.browser.asObject,
        levels,
        timestamp: getTimeFunction(opts)
    };
    logger.levels = pino.levels;
    logger.level = level;
    logger.setMaxListeners = logger.getMaxListeners = logger.emit = logger.addListener = logger.on = logger.prependListener = logger.once = logger.prependOnceListener = logger.removeListener = logger.removeAllListeners = logger.listeners = logger.listenerCount = logger.eventNames = logger.write = logger.flush = noop;
    logger.serializers = serializers;
    logger._serialize = serialize;
    logger._stdErrSerialize = stdErrSerialize;
    logger.child = child;
    if (transmit) logger._logEvent = createLogEventShape();
    function getLevelVal() {
        return this.level === 'silent' ? Infinity : this.levels.values[this.level];
    }
    function getLevel() {
        return this._level;
    }
    function setLevel(level) {
        if (level !== 'silent' && !this.levels.values[level]) {
            throw Error('unknown level ' + level);
        }
        this._level = level;
        set(setOpts, logger, 'error', 'log'); // <-- must stay first
        set(setOpts, logger, 'fatal', 'error');
        set(setOpts, logger, 'warn', 'error');
        set(setOpts, logger, 'info', 'log');
        set(setOpts, logger, 'debug', 'log');
        set(setOpts, logger, 'trace', 'log');
    }
    function child(bindings, childOptions) {
        if (!bindings) {
            throw new Error('missing bindings for child Pino');
        }
        childOptions = childOptions || {};
        if (serialize && bindings.serializers) {
            childOptions.serializers = bindings.serializers;
        }
        const childOptionsSerializers = childOptions.serializers;
        if (serialize && childOptionsSerializers) {
            var childSerializers = Object.assign({}, serializers, childOptionsSerializers);
            var childSerialize = opts.browser.serialize === true ? Object.keys(childSerializers) : serialize;
            delete bindings.serializers;
            applySerializers([
                bindings
            ], childSerialize, childSerializers, this._stdErrSerialize);
        }
        function Child(parent) {
            this._childLevel = (parent._childLevel | 0) + 1;
            this.error = bind(parent, bindings, 'error');
            this.fatal = bind(parent, bindings, 'fatal');
            this.warn = bind(parent, bindings, 'warn');
            this.info = bind(parent, bindings, 'info');
            this.debug = bind(parent, bindings, 'debug');
            this.trace = bind(parent, bindings, 'trace');
            if (childSerializers) {
                this.serializers = childSerializers;
                this._serialize = childSerialize;
            }
            if (transmit) {
                this._logEvent = createLogEventShape([].concat(parent._logEvent.bindings, bindings));
            }
        }
        Child.prototype = this;
        return new Child(this);
    }
    return logger;
}
pino.levels = {
    values: {
        fatal: 60,
        error: 50,
        warn: 40,
        info: 30,
        debug: 20,
        trace: 10
    },
    labels: {
        10: 'trace',
        20: 'debug',
        30: 'info',
        40: 'warn',
        50: 'error',
        60: 'fatal'
    }
};
pino.stdSerializers = stdSerializers;
pino.stdTimeFunctions = Object.assign({}, {
    nullTime,
    epochTime,
    unixTime,
    isoTime
});
function set(opts, logger, level, fallback) {
    const proto = Object.getPrototypeOf(logger);
    logger[level] = logger.levelVal > logger.levels.values[level] ? noop : proto[level] ? proto[level] : _console[level] || _console[fallback] || noop;
    wrap(opts, logger, level);
}
function wrap(opts, logger, level) {
    if (!opts.transmit && logger[level] === noop) return;
    logger[level] = function(write) {
        return function LOG() {
            const ts = opts.timestamp();
            const args = new Array(arguments.length);
            const proto = Object.getPrototypeOf && Object.getPrototypeOf(this) === _console ? _console : this;
            for(var i = 0; i < args.length; i++)args[i] = arguments[i];
            if (opts.serialize && !opts.asObject) {
                applySerializers(args, this._serialize, this.serializers, this._stdErrSerialize);
            }
            if (opts.asObject) write.call(proto, asObject(this, level, args, ts));
            else write.apply(proto, args);
            if (opts.transmit) {
                const transmitLevel = opts.transmit.level || logger.level;
                const transmitValue = pino.levels.values[transmitLevel];
                const methodValue = pino.levels.values[level];
                if (methodValue < transmitValue) return;
                transmit(this, {
                    ts,
                    methodLevel: level,
                    methodValue,
                    transmitLevel,
                    transmitValue: pino.levels.values[opts.transmit.level || logger.level],
                    send: opts.transmit.send,
                    val: logger.levelVal
                }, args);
            }
        };
    }(logger[level]);
}
function asObject(logger, level, args, ts) {
    if (logger._serialize) applySerializers(args, logger._serialize, logger.serializers, logger._stdErrSerialize);
    const argsCloned = args.slice();
    let msg = argsCloned[0];
    const o = {};
    if (ts) {
        o.time = ts;
    }
    o.level = pino.levels.values[level];
    let lvl = (logger._childLevel | 0) + 1;
    if (lvl < 1) lvl = 1;
    // deliberate, catching objects, arrays
    if (msg !== null && typeof msg === 'object') {
        while(lvl-- && typeof argsCloned[0] === 'object'){
            Object.assign(o, argsCloned.shift());
        }
        msg = argsCloned.length ? format(argsCloned.shift(), argsCloned) : undefined;
    } else if (typeof msg === 'string') msg = format(argsCloned.shift(), argsCloned);
    if (msg !== undefined) o.msg = msg;
    return o;
}
function applySerializers(args, serialize, serializers, stdErrSerialize) {
    for(const i in args){
        if (stdErrSerialize && args[i] instanceof Error) {
            args[i] = pino.stdSerializers.err(args[i]);
        } else if (typeof args[i] === 'object' && !Array.isArray(args[i])) {
            for(const k in args[i]){
                if (serialize && serialize.indexOf(k) > -1 && k in serializers) {
                    args[i][k] = serializers[k](args[i][k]);
                }
            }
        }
    }
}
function bind(parent, bindings, level) {
    return function() {
        const args = new Array(1 + arguments.length);
        args[0] = bindings;
        for(var i = 1; i < args.length; i++){
            args[i] = arguments[i - 1];
        }
        return parent[level].apply(this, args);
    };
}
function transmit(logger, opts, args) {
    const send = opts.send;
    const ts = opts.ts;
    const methodLevel = opts.methodLevel;
    const methodValue = opts.methodValue;
    const val = opts.val;
    const bindings = logger._logEvent.bindings;
    applySerializers(args, logger._serialize || Object.keys(logger.serializers), logger.serializers, logger._stdErrSerialize === undefined ? true : logger._stdErrSerialize);
    logger._logEvent.ts = ts;
    logger._logEvent.messages = args.filter(function(arg) {
        // bindings can only be objects, so reference equality check via indexOf is fine
        return bindings.indexOf(arg) === -1;
    });
    logger._logEvent.level.label = methodLevel;
    logger._logEvent.level.value = methodValue;
    send(methodLevel, logger._logEvent, val);
    logger._logEvent = createLogEventShape(bindings);
}
function createLogEventShape(bindings) {
    return {
        ts: 0,
        messages: [],
        bindings: bindings || [],
        level: {
            label: '',
            value: 0
        }
    };
}
function asErrValue(err) {
    const obj = {
        type: err.constructor.name,
        msg: err.message,
        stack: err.stack
    };
    for(const key in err){
        if (obj[key] === undefined) {
            obj[key] = err[key];
        }
    }
    return obj;
}
function getTimeFunction(opts) {
    if (typeof opts.timestamp === 'function') {
        return opts.timestamp;
    }
    if (opts.timestamp === false) {
        return nullTime;
    }
    return epochTime;
}
function mock() {
    return {};
}
function passthrough(a) {
    return a;
}
function noop() {}
function nullTime() {
    return false;
}
function epochTime() {
    return Date.now();
}
function unixTime() {
    return Math.round(Date.now() / 1000.0);
}
function isoTime() {
    return new Date(Date.now()).toISOString();
} // using Date.now() for testability
/* eslint-disable */ /* istanbul ignore next */ function pfGlobalThisOrFallback() {
    function defd(o) {
        return typeof o !== 'undefined' && o;
    }
    try {
        if (typeof globalThis !== 'undefined') return globalThis;
        Object.defineProperty(Object.prototype, 'globalThis', {
            get: function() {
                delete Object.prototype.globalThis;
                return this.globalThis = this;
            },
            configurable: true
        });
        return globalThis;
    } catch (e) {
        return defd(self) || defd(window) || defd(this) || {};
    }
} /* eslint-enable */ 
}),
"[project]/node_modules/lodash.isequal/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as the size to enable large array optimizations. */ var LARGE_ARRAY_SIZE = 200;
/** Used to stand-in for `undefined` hash values. */ var HASH_UNDEFINED = '__lodash_hash_undefined__';
/** Used to compose bitmasks for value comparisons. */ var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
/** Used as references for various `Number` constants. */ var MAX_SAFE_INTEGER = 9007199254740991;
/** `Object#toString` result references. */ var argsTag = '[object Arguments]', arrayTag = '[object Array]', asyncTag = '[object AsyncFunction]', boolTag = '[object Boolean]', dateTag = '[object Date]', errorTag = '[object Error]', funcTag = '[object Function]', genTag = '[object GeneratorFunction]', mapTag = '[object Map]', numberTag = '[object Number]', nullTag = '[object Null]', objectTag = '[object Object]', promiseTag = '[object Promise]', proxyTag = '[object Proxy]', regexpTag = '[object RegExp]', setTag = '[object Set]', stringTag = '[object String]', symbolTag = '[object Symbol]', undefinedTag = '[object Undefined]', weakMapTag = '[object WeakMap]';
var arrayBufferTag = '[object ArrayBuffer]', dataViewTag = '[object DataView]', float32Tag = '[object Float32Array]', float64Tag = '[object Float64Array]', int8Tag = '[object Int8Array]', int16Tag = '[object Int16Array]', int32Tag = '[object Int32Array]', uint8Tag = '[object Uint8Array]', uint8ClampedTag = '[object Uint8ClampedArray]', uint16Tag = '[object Uint16Array]', uint32Tag = '[object Uint32Array]';
/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */ var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
/** Used to detect host constructors (Safari). */ var reIsHostCtor = /^\[object .+?Constructor\]$/;
/** Used to detect unsigned integer values. */ var reIsUint = /^(?:0|[1-9]\d*)$/;
/** Used to identify `toStringTag` values of typed arrays. */ var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
/** Detect free variable `global` from Node.js. */ var freeGlobal = ("TURBOPACK compile-time value", "object") == 'object' && /*TURBOPACK member replacement*/ __turbopack_context__.g && /*TURBOPACK member replacement*/ __turbopack_context__.g.Object === Object && /*TURBOPACK member replacement*/ __turbopack_context__.g;
/** Detect free variable `self`. */ var freeSelf = typeof self == 'object' && self && self.Object === Object && self;
/** Used as a reference to the global object. */ var root = freeGlobal || freeSelf || Function('return this')();
/** Detect free variable `exports`. */ var freeExports = ("TURBOPACK compile-time value", "object") == 'object' && exports && !exports.nodeType && exports;
/** Detect free variable `module`. */ var freeModule = freeExports && ("TURBOPACK compile-time value", "object") == 'object' && module && !module.nodeType && module;
/** Detect the popular CommonJS extension `module.exports`. */ var moduleExports = freeModule && freeModule.exports === freeExports;
/** Detect free variable `process` from Node.js. */ var freeProcess = moduleExports && freeGlobal.process;
/** Used to access faster Node.js helpers. */ var nodeUtil = function() {
    try {
        return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
}();
/* Node.js helper references. */ var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */ function arrayFilter(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
    while(++index < length){
        var value = array[index];
        if (predicate(value, index, array)) {
            result[resIndex++] = value;
        }
    }
    return result;
}
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */ function arrayPush(array, values) {
    var index = -1, length = values.length, offset = array.length;
    while(++index < length){
        array[offset + index] = values[index];
    }
    return array;
}
/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */ function arraySome(array, predicate) {
    var index = -1, length = array == null ? 0 : array.length;
    while(++index < length){
        if (predicate(array[index], index, array)) {
            return true;
        }
    }
    return false;
}
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */ function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while(++index < n){
        result[index] = iteratee(index);
    }
    return result;
}
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */ function baseUnary(func) {
    return function(value) {
        return func(value);
    };
}
/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function cacheHas(cache, key) {
    return cache.has(key);
}
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */ function getValue(object, key) {
    return object == null ? undefined : object[key];
}
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */ function mapToArray(map) {
    var index = -1, result = Array(map.size);
    map.forEach(function(value, key) {
        result[++index] = [
            key,
            value
        ];
    });
    return result;
}
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */ function overArg(func, transform) {
    return function(arg) {
        return func(transform(arg));
    };
}
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */ function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function(value) {
        result[++index] = value;
    });
    return result;
}
/** Used for built-in method references. */ var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
/** Used to detect overreaching core-js shims. */ var coreJsData = root['__core-js_shared__'];
/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to detect methods masquerading as native. */ var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
}();
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var nativeObjectToString = objectProto.toString;
/** Used to detect if a method is native. */ var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
/** Built-in value references. */ var Buffer = moduleExports ? root.Buffer : undefined, Symbol = root.Symbol, Uint8Array = root.Uint8Array, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, symToStringTag = Symbol ? Symbol.toStringTag : undefined;
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined, nativeKeys = overArg(Object.keys, Object);
/* Built-in method references that are verified to be native. */ var DataView = getNative(root, 'DataView'), Map = getNative(root, 'Map'), Promise = getNative(root, 'Promise'), Set = getNative(root, 'Set'), WeakMap = getNative(root, 'WeakMap'), nativeCreate = getNative(Object, 'create');
/** Used to detect maps, sets, and weakmaps. */ var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
/** Used to convert symbols to primitives and strings. */ var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;
/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Hash(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */ function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
}
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
}
/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
}
/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
}
/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */ function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
    return this;
}
// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function ListCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */ function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
}
/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
        return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
        data.pop();
    } else {
        splice.call(data, index, 1);
    }
    --this.size;
    return true;
}
/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? undefined : data[index][1];
}
/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
}
/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */ function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
        ++this.size;
        data.push([
            key,
            value
        ]);
    } else {
        data[index][1] = value;
    }
    return this;
}
// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function MapCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */ function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
    };
}
/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function mapCacheDelete(key) {
    var result = getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
}
/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function mapCacheGet(key) {
    return getMapData(this, key).get(key);
}
/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function mapCacheHas(key) {
    return getMapData(this, key).has(key);
}
/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */ function mapCacheSet(key, value) {
    var data = getMapData(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
}
// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */ function SetCache(values) {
    var index = -1, length = values == null ? 0 : values.length;
    this.__data__ = new MapCache;
    while(++index < length){
        this.add(values[index]);
    }
}
/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */ function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
}
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */ function setCacheHas(value) {
    return this.__data__.has(value);
}
// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;
/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */ function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
}
/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */ function stackClear() {
    this.__data__ = new ListCache;
    this.size = 0;
}
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */ function stackDelete(key) {
    var data = this.__data__, result = data['delete'](key);
    this.size = data.size;
    return result;
}
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */ function stackGet(key) {
    return this.__data__.get(key);
}
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */ function stackHas(key) {
    return this.__data__.has(key);
}
/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */ function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([
                key,
                value
            ]);
            this.size = ++data.size;
            return this;
        }
        data = this.__data__ = new MapCache(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
}
// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */ function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for(var key in value){
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (// Safari 9 has enumerable `arguments.length` in strict mode.
        key == 'length' || isBuff && (key == 'offset' || key == 'parent') || isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') || // Skip index properties.
        isIndex(key, length)))) {
            result.push(key);
        }
    }
    return result;
}
/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function assocIndexOf(array, key) {
    var length = array.length;
    while(length--){
        if (eq(array[length][0], key)) {
            return length;
        }
    }
    return -1;
}
/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */ function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}
/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */ function baseGetTag(value) {
    if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */ function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag;
}
/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */ function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
        return true;
    }
    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}
/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */ function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
            return false;
        }
        objIsArr = true;
        objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
        stack || (stack = new Stack);
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'), othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
        if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack);
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
    }
    if (!isSameTag) {
        return false;
    }
    stack || (stack = new Stack);
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}
/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */ function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
        return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
}
/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */ function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */ function baseKeys(object) {
    if (!isPrototype(object)) {
        return nativeKeys(object);
    }
    var result = [];
    for(var key in Object(object)){
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
            result.push(key);
        }
    }
    return result;
}
/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */ function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
    }
    // Assume cyclic values are equal.
    var stacked = stack.get(array);
    if (stacked && stack.get(other)) {
        return stacked == other;
    }
    var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache : undefined;
    stack.set(array, other);
    stack.set(other, array);
    // Ignore non-index properties.
    while(++index < arrLength){
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
            if (compared) {
                continue;
            }
            result = false;
            break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
            if (!arraySome(other, function(othValue, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                    return seen.push(othIndex);
                }
            })) {
                result = false;
                break;
            }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result = false;
            break;
        }
    }
    stack['delete'](array);
    stack['delete'](other);
    return result;
}
/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */ function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch(tag){
        case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
            }
            object = object.buffer;
            other = other.buffer;
        case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                return false;
            }
            return true;
        case boolTag:
        case dateTag:
        case numberTag:
            // Coerce booleans to `1` or `0` and dates to milliseconds.
            // Invalid dates are coerced to `NaN`.
            return eq(+object, +other);
        case errorTag:
            return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
            // Coerce regexes to strings and treat strings, primitives and objects,
            // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
            // for more details.
            return object == other + '';
        case mapTag:
            var convert = mapToArray;
        case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
                return false;
            }
            // Assume cyclic values are equal.
            var stacked = stack.get(object);
            if (stacked) {
                return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            // Recursively compare objects (susceptible to call stack limits).
            stack.set(object, other);
            var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack['delete'](object);
            return result;
        case symbolTag:
            if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
    }
    return false;
}
/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */ function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
        return false;
    }
    var index = objLength;
    while(index--){
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
            return false;
        }
    }
    // Assume cyclic values are equal.
    var stacked = stack.get(object);
    if (stacked && stack.get(other)) {
        return stacked == other;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while(++index < objLength){
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result = false;
            break;
        }
        skipCtor || (skipCtor = key == 'constructor');
    }
    if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
            result = false;
        }
    }
    stack['delete'](object);
    stack['delete'](other);
    return result;
}
/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */ function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols);
}
/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */ function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
}
/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */ function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
}
/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */ function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
        value[symToStringTag] = undefined;
        var unmasked = true;
    } catch (e) {}
    var result = nativeObjectToString.call(value);
    if (unmasked) {
        if (isOwn) {
            value[symToStringTag] = tag;
        } else {
            delete value[symToStringTag];
        }
    }
    return result;
}
/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */ var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
    if (object == null) {
        return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
    });
};
/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */ var getTag = baseGetTag;
// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set) != setTag || WeakMap && getTag(new WeakMap) != weakMapTag) {
    getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : '';
        if (ctorString) {
            switch(ctorString){
                case dataViewCtorString:
                    return dataViewTag;
                case mapCtorString:
                    return mapTag;
                case promiseCtorString:
                    return promiseTag;
                case setCtorString:
                    return setTag;
                case weakMapCtorString:
                    return weakMapTag;
            }
        }
        return result;
    };
}
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */ function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */ function isKeyable(value) {
    var type = typeof value;
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
}
/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */ function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
}
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */ function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
    return value === proto;
}
/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */ function objectToString(value) {
    return nativeObjectToString.call(value);
}
/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */ function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        } catch (e) {}
        try {
            return func + '';
        } catch (e) {}
    }
    return '';
}
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */ function eq(value, other) {
    return value === other || value !== value && other !== other;
}
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */ var isArguments = baseIsArguments(function() {
    return arguments;
}()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
};
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */ var isArray = Array.isArray;
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */ function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
}
/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */ var isBuffer = nativeIsBuffer || stubFalse;
/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */ function isEqual(value, other) {
    return baseIsEqual(value, other);
}
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */ function isFunction(value) {
    if (!isObject(value)) {
        return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */ function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return value != null && typeof value == 'object';
}
/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */ var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */ function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */ function stubArray() {
    return [];
}
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */ function stubFalse() {
    return false;
}
module.exports = isEqual;
}),
"[project]/node_modules/cross-fetch/dist/browser-ponyfill.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

var global = typeof self !== 'undefined' ? self : /*TURBOPACK member replacement*/ __turbopack_context__.e;
var __self__ = function() {
    function F() {
        this.fetch = false;
        this.DOMException = global.DOMException;
    }
    F.prototype = global;
    return new F();
}();
(function(self1) {
    var irrelevant = function(exports1) {
        var support = {
            searchParams: 'URLSearchParams' in self1,
            iterable: 'Symbol' in self1 && 'iterator' in Symbol,
            blob: 'FileReader' in self1 && 'Blob' in self1 && function() {
                try {
                    new Blob();
                    return true;
                } catch (e) {
                    return false;
                }
            }(),
            formData: 'FormData' in self1,
            arrayBuffer: 'ArrayBuffer' in self1
        };
        function isDataView(obj) {
            return obj && DataView.prototype.isPrototypeOf(obj);
        }
        if (support.arrayBuffer) {
            var viewClasses = [
                '[object Int8Array]',
                '[object Uint8Array]',
                '[object Uint8ClampedArray]',
                '[object Int16Array]',
                '[object Uint16Array]',
                '[object Int32Array]',
                '[object Uint32Array]',
                '[object Float32Array]',
                '[object Float64Array]'
            ];
            var isArrayBufferView = ArrayBuffer.isView || function(obj) {
                return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
            };
        }
        function normalizeName(name) {
            if (typeof name !== 'string') {
                name = String(name);
            }
            if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
                throw new TypeError('Invalid character in header field name');
            }
            return name.toLowerCase();
        }
        function normalizeValue(value) {
            if (typeof value !== 'string') {
                value = String(value);
            }
            return value;
        }
        // Build a destructive iterator for the value list
        function iteratorFor(items) {
            var iterator = {
                next: function() {
                    var value = items.shift();
                    return {
                        done: value === undefined,
                        value: value
                    };
                }
            };
            if (support.iterable) {
                iterator[Symbol.iterator] = function() {
                    return iterator;
                };
            }
            return iterator;
        }
        function Headers(headers) {
            this.map = {};
            if (headers instanceof Headers) {
                headers.forEach(function(value, name) {
                    this.append(name, value);
                }, this);
            } else if (Array.isArray(headers)) {
                headers.forEach(function(header) {
                    this.append(header[0], header[1]);
                }, this);
            } else if (headers) {
                Object.getOwnPropertyNames(headers).forEach(function(name) {
                    this.append(name, headers[name]);
                }, this);
            }
        }
        Headers.prototype.append = function(name, value) {
            name = normalizeName(name);
            value = normalizeValue(value);
            var oldValue = this.map[name];
            this.map[name] = oldValue ? oldValue + ', ' + value : value;
        };
        Headers.prototype['delete'] = function(name) {
            delete this.map[normalizeName(name)];
        };
        Headers.prototype.get = function(name) {
            name = normalizeName(name);
            return this.has(name) ? this.map[name] : null;
        };
        Headers.prototype.has = function(name) {
            return this.map.hasOwnProperty(normalizeName(name));
        };
        Headers.prototype.set = function(name, value) {
            this.map[normalizeName(name)] = normalizeValue(value);
        };
        Headers.prototype.forEach = function(callback, thisArg) {
            for(var name in this.map){
                if (this.map.hasOwnProperty(name)) {
                    callback.call(thisArg, this.map[name], name, this);
                }
            }
        };
        Headers.prototype.keys = function() {
            var items = [];
            this.forEach(function(value, name) {
                items.push(name);
            });
            return iteratorFor(items);
        };
        Headers.prototype.values = function() {
            var items = [];
            this.forEach(function(value) {
                items.push(value);
            });
            return iteratorFor(items);
        };
        Headers.prototype.entries = function() {
            var items = [];
            this.forEach(function(value, name) {
                items.push([
                    name,
                    value
                ]);
            });
            return iteratorFor(items);
        };
        if (support.iterable) {
            Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
        }
        function consumed(body) {
            if (body.bodyUsed) {
                return Promise.reject(new TypeError('Already read'));
            }
            body.bodyUsed = true;
        }
        function fileReaderReady(reader) {
            return new Promise(function(resolve, reject) {
                reader.onload = function() {
                    resolve(reader.result);
                };
                reader.onerror = function() {
                    reject(reader.error);
                };
            });
        }
        function readBlobAsArrayBuffer(blob) {
            var reader = new FileReader();
            var promise = fileReaderReady(reader);
            reader.readAsArrayBuffer(blob);
            return promise;
        }
        function readBlobAsText(blob) {
            var reader = new FileReader();
            var promise = fileReaderReady(reader);
            reader.readAsText(blob);
            return promise;
        }
        function readArrayBufferAsText(buf) {
            var view = new Uint8Array(buf);
            var chars = new Array(view.length);
            for(var i = 0; i < view.length; i++){
                chars[i] = String.fromCharCode(view[i]);
            }
            return chars.join('');
        }
        function bufferClone(buf) {
            if (buf.slice) {
                return buf.slice(0);
            } else {
                var view = new Uint8Array(buf.byteLength);
                view.set(new Uint8Array(buf));
                return view.buffer;
            }
        }
        function Body() {
            this.bodyUsed = false;
            this._initBody = function(body) {
                this._bodyInit = body;
                if (!body) {
                    this._bodyText = '';
                } else if (typeof body === 'string') {
                    this._bodyText = body;
                } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
                    this._bodyBlob = body;
                } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
                    this._bodyFormData = body;
                } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                    this._bodyText = body.toString();
                } else if (support.arrayBuffer && support.blob && isDataView(body)) {
                    this._bodyArrayBuffer = bufferClone(body.buffer);
                    // IE 10-11 can't handle a DataView body.
                    this._bodyInit = new Blob([
                        this._bodyArrayBuffer
                    ]);
                } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
                    this._bodyArrayBuffer = bufferClone(body);
                } else {
                    this._bodyText = body = Object.prototype.toString.call(body);
                }
                if (!this.headers.get('content-type')) {
                    if (typeof body === 'string') {
                        this.headers.set('content-type', 'text/plain;charset=UTF-8');
                    } else if (this._bodyBlob && this._bodyBlob.type) {
                        this.headers.set('content-type', this._bodyBlob.type);
                    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
                    }
                }
            };
            if (support.blob) {
                this.blob = function() {
                    var rejected = consumed(this);
                    if (rejected) {
                        return rejected;
                    }
                    if (this._bodyBlob) {
                        return Promise.resolve(this._bodyBlob);
                    } else if (this._bodyArrayBuffer) {
                        return Promise.resolve(new Blob([
                            this._bodyArrayBuffer
                        ]));
                    } else if (this._bodyFormData) {
                        throw new Error('could not read FormData body as blob');
                    } else {
                        return Promise.resolve(new Blob([
                            this._bodyText
                        ]));
                    }
                };
                this.arrayBuffer = function() {
                    if (this._bodyArrayBuffer) {
                        return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
                    } else {
                        return this.blob().then(readBlobAsArrayBuffer);
                    }
                };
            }
            this.text = function() {
                var rejected = consumed(this);
                if (rejected) {
                    return rejected;
                }
                if (this._bodyBlob) {
                    return readBlobAsText(this._bodyBlob);
                } else if (this._bodyArrayBuffer) {
                    return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
                } else if (this._bodyFormData) {
                    throw new Error('could not read FormData body as text');
                } else {
                    return Promise.resolve(this._bodyText);
                }
            };
            if (support.formData) {
                this.formData = function() {
                    return this.text().then(decode);
                };
            }
            this.json = function() {
                return this.text().then(JSON.parse);
            };
            return this;
        }
        // HTTP methods whose capitalization should be normalized
        var methods = [
            'DELETE',
            'GET',
            'HEAD',
            'OPTIONS',
            'POST',
            'PUT'
        ];
        function normalizeMethod(method) {
            var upcased = method.toUpperCase();
            return methods.indexOf(upcased) > -1 ? upcased : method;
        }
        function Request(input, options) {
            options = options || {};
            var body = options.body;
            if (input instanceof Request) {
                if (input.bodyUsed) {
                    throw new TypeError('Already read');
                }
                this.url = input.url;
                this.credentials = input.credentials;
                if (!options.headers) {
                    this.headers = new Headers(input.headers);
                }
                this.method = input.method;
                this.mode = input.mode;
                this.signal = input.signal;
                if (!body && input._bodyInit != null) {
                    body = input._bodyInit;
                    input.bodyUsed = true;
                }
            } else {
                this.url = String(input);
            }
            this.credentials = options.credentials || this.credentials || 'same-origin';
            if (options.headers || !this.headers) {
                this.headers = new Headers(options.headers);
            }
            this.method = normalizeMethod(options.method || this.method || 'GET');
            this.mode = options.mode || this.mode || null;
            this.signal = options.signal || this.signal;
            this.referrer = null;
            if ((this.method === 'GET' || this.method === 'HEAD') && body) {
                throw new TypeError('Body not allowed for GET or HEAD requests');
            }
            this._initBody(body);
        }
        Request.prototype.clone = function() {
            return new Request(this, {
                body: this._bodyInit
            });
        };
        function decode(body) {
            var form = new FormData();
            body.trim().split('&').forEach(function(bytes) {
                if (bytes) {
                    var split = bytes.split('=');
                    var name = split.shift().replace(/\+/g, ' ');
                    var value = split.join('=').replace(/\+/g, ' ');
                    form.append(decodeURIComponent(name), decodeURIComponent(value));
                }
            });
            return form;
        }
        function parseHeaders(rawHeaders) {
            var headers = new Headers();
            // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
            // https://tools.ietf.org/html/rfc7230#section-3.2
            var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
            preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
                var parts = line.split(':');
                var key = parts.shift().trim();
                if (key) {
                    var value = parts.join(':').trim();
                    headers.append(key, value);
                }
            });
            return headers;
        }
        Body.call(Request.prototype);
        function Response(bodyInit, options) {
            if (!options) {
                options = {};
            }
            this.type = 'default';
            this.status = options.status === undefined ? 200 : options.status;
            this.ok = this.status >= 200 && this.status < 300;
            this.statusText = 'statusText' in options ? options.statusText : 'OK';
            this.headers = new Headers(options.headers);
            this.url = options.url || '';
            this._initBody(bodyInit);
        }
        Body.call(Response.prototype);
        Response.prototype.clone = function() {
            return new Response(this._bodyInit, {
                status: this.status,
                statusText: this.statusText,
                headers: new Headers(this.headers),
                url: this.url
            });
        };
        Response.error = function() {
            var response = new Response(null, {
                status: 0,
                statusText: ''
            });
            response.type = 'error';
            return response;
        };
        var redirectStatuses = [
            301,
            302,
            303,
            307,
            308
        ];
        Response.redirect = function(url, status) {
            if (redirectStatuses.indexOf(status) === -1) {
                throw new RangeError('Invalid status code');
            }
            return new Response(null, {
                status: status,
                headers: {
                    location: url
                }
            });
        };
        exports1.DOMException = self1.DOMException;
        try {
            new exports1.DOMException();
        } catch (err) {
            exports1.DOMException = function(message, name) {
                this.message = message;
                this.name = name;
                var error = Error(message);
                this.stack = error.stack;
            };
            exports1.DOMException.prototype = Object.create(Error.prototype);
            exports1.DOMException.prototype.constructor = exports1.DOMException;
        }
        function fetch(input, init) {
            return new Promise(function(resolve, reject) {
                var request = new Request(input, init);
                if (request.signal && request.signal.aborted) {
                    return reject(new exports1.DOMException('Aborted', 'AbortError'));
                }
                var xhr = new XMLHttpRequest();
                function abortXhr() {
                    xhr.abort();
                }
                xhr.onload = function() {
                    var options = {
                        status: xhr.status,
                        statusText: xhr.statusText,
                        headers: parseHeaders(xhr.getAllResponseHeaders() || '')
                    };
                    options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
                    var body = 'response' in xhr ? xhr.response : xhr.responseText;
                    resolve(new Response(body, options));
                };
                xhr.onerror = function() {
                    reject(new TypeError('Network request failed'));
                };
                xhr.ontimeout = function() {
                    reject(new TypeError('Network request failed'));
                };
                xhr.onabort = function() {
                    reject(new exports1.DOMException('Aborted', 'AbortError'));
                };
                xhr.open(request.method, request.url, true);
                if (request.credentials === 'include') {
                    xhr.withCredentials = true;
                } else if (request.credentials === 'omit') {
                    xhr.withCredentials = false;
                }
                if ('responseType' in xhr && support.blob) {
                    xhr.responseType = 'blob';
                }
                request.headers.forEach(function(value, name) {
                    xhr.setRequestHeader(name, value);
                });
                if (request.signal) {
                    request.signal.addEventListener('abort', abortXhr);
                    xhr.onreadystatechange = function() {
                        // DONE (success or failure)
                        if (xhr.readyState === 4) {
                            request.signal.removeEventListener('abort', abortXhr);
                        }
                    };
                }
                xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
            });
        }
        fetch.polyfill = true;
        if (!self1.fetch) {
            self1.fetch = fetch;
            self1.Headers = Headers;
            self1.Request = Request;
            self1.Response = Response;
        }
        exports1.Headers = Headers;
        exports1.Request = Request;
        exports1.Response = Response;
        exports1.fetch = fetch;
        Object.defineProperty(exports1, '__esModule', {
            value: true
        });
        return exports1;
    }({});
})(__self__);
__self__.fetch.ponyfill = true;
// Remove "polyfill" property added by whatwg-fetch
delete __self__.fetch.polyfill;
// Choose between native implementation (global) or custom implementation (__self__)
// var ctx = global.fetch ? global : __self__;
var ctx = __self__; // this line disable service worker support temporarily
exports = ctx.fetch; // To enable: import fetch from 'cross-fetch'
exports.default = ctx.fetch; // For TypeScript consumers without esModuleInterop.
exports.fetch = ctx.fetch; // To enable: import {fetch} from 'cross-fetch'
exports.Headers = ctx.Headers;
exports.Request = ctx.Request;
exports.Response = ctx.Response;
module.exports = exports;
}),
"[project]/node_modules/cross-fetch/dist/node-ponyfill.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

const nodeFetch = __turbopack_context__.r("[project]/node_modules/node-fetch/browser.js [app-client] (ecmascript)");
const realFetch = nodeFetch.default || nodeFetch;
const fetch = function(url, options) {
    // Support schemaless URIs on the server for parity with the browser.
    // Ex: //github.com/ -> https://github.com/
    if (/^\/\//.test(url)) {
        url = 'https:' + url;
    }
    return realFetch.call(this, url, options);
};
fetch.ponyfill = true;
module.exports = exports = fetch;
exports.fetch = fetch;
exports.Headers = nodeFetch.Headers;
exports.Request = nodeFetch.Request;
exports.Response = nodeFetch.Response;
// Needed for TypeScript consumers without esModuleInterop.
exports.default = fetch;
}),
"[project]/node_modules/cross-fetch/dist/node-polyfill.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

const fetchNode = __turbopack_context__.r("[project]/node_modules/cross-fetch/dist/node-ponyfill.js [app-client] (ecmascript)");
const fetch = fetchNode.fetch.bind({});
fetch.polyfill = true;
if (!/*TURBOPACK member replacement*/ __turbopack_context__.g.fetch) {
    /*TURBOPACK member replacement*/ __turbopack_context__.g.fetch = fetch;
    /*TURBOPACK member replacement*/ __turbopack_context__.g.Response = fetchNode.Response;
    /*TURBOPACK member replacement*/ __turbopack_context__.g.Headers = fetchNode.Headers;
    /*TURBOPACK member replacement*/ __turbopack_context__.g.Request = fetchNode.Request;
}
}),
"[project]/node_modules/@spruceid/siwe-parser/dist/utils.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parseIntegerNumber = exports.isEIP55Address = void 0;
const sha3_1 = __turbopack_context__.r("[project]/node_modules/@noble/hashes/sha3.js [app-client] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@noble/hashes/utils.js [app-client] (ecmascript)");
/**
 * This method is supposed to check if an address is conforming to EIP-55.
 * @param address Address to be checked if conforms with EIP-55.
 * @returns Either the return is or not in the EIP-55 format.
 */ const isEIP55Address = (address)=>{
    if (address.length != 42) {
        return false;
    }
    const lowerAddress = `${address}`.toLowerCase().replace('0x', '');
    const hash = (0, utils_1.bytesToHex)((0, sha3_1.keccak_256)(lowerAddress));
    let ret = '0x';
    for(let i = 0; i < lowerAddress.length; i++){
        if (parseInt(hash[i], 16) >= 8) {
            ret += lowerAddress[i].toUpperCase();
        } else {
            ret += lowerAddress[i];
        }
    }
    return address === ret;
};
exports.isEIP55Address = isEIP55Address;
const parseIntegerNumber = (number)=>{
    const parsed = parseInt(number);
    if (isNaN(parsed)) throw new Error("Invalid number.");
    if (parsed === Infinity) throw new Error("Invalid number.");
    return parsed;
};
exports.parseIntegerNumber = parseIntegerNumber;
}),
"[project]/node_modules/@spruceid/siwe-parser/dist/abnf.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __importDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
var _a;
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ParsedMessage = void 0;
const api_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/apg-js/src/apg-api/api.js [app-client] (ecmascript)"));
const node_exports_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/apg-js/src/apg-lib/node-exports.js [app-client] (ecmascript)"));
const utils_1 = __turbopack_context__.r("[project]/node_modules/@spruceid/siwe-parser/dist/utils.js [app-client] (ecmascript)");
const GRAMMAR = `
sign-in-with-ethereum =
    [ scheme "://" ] domain %s" wants you to sign in with your Ethereum account:" LF
    address LF
    LF
    [ statement LF ]
    LF
    %s"URI: " URI LF
    %s"Version: " version LF
    %s"Chain ID: " chain-id LF
    %s"Nonce: " nonce LF
    %s"Issued At: " issued-at
    [ LF %s"Expiration Time: " expiration-time ]
    [ LF %s"Not Before: " not-before ]
    [ LF %s"Request ID: " request-id ]
    [ LF %s"Resources:"
    resources ]

domain = authority

address = "0x" 40*40HEXDIG
    ; Must also conform to captilization
    ; checksum encoding specified in EIP-55
    ; where applicable (EOAs).

statement = 1*( reserved / unreserved / " " )
    ; The purpose is to exclude LF (line breaks).

version = "1"

nonce = 8*( ALPHA / DIGIT )

issued-at = date-time
expiration-time = date-time
not-before = date-time

request-id = *pchar

chain-id = 1*DIGIT
    ; See EIP-155 for valid CHAIN_IDs.

resources = *( LF resource )

resource = "- " URI

; ------------------------------------------------------------------------------
; RFC 3986

URI           = scheme ":" hier-part [ "?" query ] [ "#" fragment ]

hier-part     = "//" authority path-abempty
              / path-absolute
              / path-rootless
              / path-empty

scheme        = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )

authority     = [ userinfo "@" ] host [ ":" port ]
userinfo      = *( unreserved / pct-encoded / sub-delims / ":" )
host          = IP-literal / IPv4address / reg-name
port          = *DIGIT

IP-literal    = "[" ( IPv6address / IPvFuture  ) "]"

IPvFuture     = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )

IPv6address   =                            6( h16 ":" ) ls32
              /                       "::" 5( h16 ":" ) ls32
              / [               h16 ] "::" 4( h16 ":" ) ls32
              / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
              / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
              / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
              / [ *4( h16 ":" ) h16 ] "::"              ls32
              / [ *5( h16 ":" ) h16 ] "::"              h16
              / [ *6( h16 ":" ) h16 ] "::"

h16           = 1*4HEXDIG
ls32          = ( h16 ":" h16 ) / IPv4address
IPv4address   = dec-octet "." dec-octet "." dec-octet "." dec-octet
dec-octet     = DIGIT                 ; 0-9
                 / %x31-39 DIGIT         ; 10-99
                 / "1" 2DIGIT            ; 100-199
                 / "2" %x30-34 DIGIT     ; 200-249
                 / "25" %x30-35          ; 250-255

reg-name      = *( unreserved / pct-encoded / sub-delims )

path-abempty  = *( "/" segment )
path-absolute = "/" [ segment-nz *( "/" segment ) ]
path-rootless = segment-nz *( "/" segment )
path-empty    = 0pchar

segment       = *pchar
segment-nz    = 1*pchar

pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"

query         = *( pchar / "/" / "?" )

fragment      = *( pchar / "/" / "?" )

pct-encoded   = "%" HEXDIG HEXDIG

unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
reserved      = gen-delims / sub-delims
gen-delims    = ":" / "/" / "?" / "#" / "[" / "]" / "@"
sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
              / "*" / "+" / "," / ";" / "="

; ------------------------------------------------------------------------------
; RFC 3339

date-fullyear   = 4DIGIT
date-month      = 2DIGIT  ; 01-12
date-mday       = 2DIGIT  ; 01-28, 01-29, 01-30, 01-31 based on
                          ; month/year
time-hour       = 2DIGIT  ; 00-23
time-minute     = 2DIGIT  ; 00-59
time-second     = 2DIGIT  ; 00-58, 00-59, 00-60 based on leap second
                          ; rules
time-secfrac    = "." 1*DIGIT
time-numoffset  = ("+" / "-") time-hour ":" time-minute
time-offset     = "Z" / time-numoffset

partial-time    = time-hour ":" time-minute ":" time-second
                  [time-secfrac]
full-date       = date-fullyear "-" date-month "-" date-mday
full-time       = partial-time time-offset

date-time       = full-date "T" full-time

; ------------------------------------------------------------------------------
; RFC 5234

ALPHA          =  %x41-5A / %x61-7A   ; A-Z / a-z
LF             =  %x0A
                  ; linefeed
DIGIT          =  %x30-39
                  ; 0-9
HEXDIG         =  DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
`;
class GrammarApi {
    static generateApi() {
        const api = new api_1.default(GRAMMAR);
        api.generate();
        if (api.errors.length) {
            console.error(api.errorsToAscii());
            console.error(api.linesToAscii());
            console.log(api.displayAttributeErrors());
            throw new Error(`ABNF grammar has errors`);
        }
        return api.toObject();
    }
}
_a = GrammarApi;
GrammarApi.grammarObj = _a.generateApi();
class ParsedMessage {
    constructor(msg){
        const parser = new node_exports_1.default.parser();
        parser.ast = new node_exports_1.default.ast();
        const id = node_exports_1.default.ids;
        const scheme = function(state, chars, phraseIndex, phraseLength, data) {
            const ret = id.SEM_OK;
            if (state === id.SEM_PRE && phraseIndex === 0) {
                data.scheme = node_exports_1.default.utils.charsToString(chars, phraseIndex, phraseLength);
            }
            return ret;
        };
        parser.ast.callbacks.scheme = scheme;
        const domain = function(state, chars, phraseIndex, phraseLength, data) {
            const ret = id.SEM_OK;
            if (state === id.SEM_PRE) {
                data.domain = node_exports_1.default.utils.charsToString(chars, phraseIndex, phraseLength);
            }
            return ret;
        };
        parser.ast.callbacks.domain = domain;
        const address = function(state, chars, phraseIndex, phraseLength, data) {
            const ret = id.SEM_OK;
            if (state === id.SEM_PRE) {
                data.address = node_exports_1.default.utils.charsToString(chars, phraseIndex, phraseLength);
            }
            return ret;
        };
        parser.ast.callbacks.address = address;
        const statement = function(state, chars, phraseIndex, phraseLength, data) {
            const ret = id.SEM_OK;
            if (state === id.SEM_PRE) {
                data.statement = node_exports_1.default.utils.charsToString(chars, phraseIndex, phraseLength);
            }
            return ret;
        };
        parser.ast.callbacks.statement = statement;
        const uri = function(state, chars, phraseIndex, phraseLength, data) {
            const ret = id.SEM_OK;
            if (state === id.SEM_PRE) {
                if (!data.uri) {
                    data.uri = node_exports_1.default.utils.charsToString(chars, phraseIndex, phraseLength);
                }
            }
            return ret;
        };
        parser.ast.callbacks.uri = uri;
        const version = function(state, chars, phraseIndex, phraseLength, data) {
            const ret = id.SEM_OK;
            if (state === id.SEM_PRE) {
                data.version = node_exports_1.default.utils.charsToString(chars, phraseIndex, phraseLength);
            }
            return ret;
        };
        parser.ast.callbacks.version = version;
        const chainId = function(state, chars, phraseIndex, phraseLength, data) {
            const ret = id.SEM_OK;
            if (state === id.SEM_PRE) {
                data.chainId = (0, utils_1.parseIntegerNumber)(node_exports_1.default.utils.charsToString(chars, phraseIndex, phraseLength));
            }
            return ret;
        };
        parser.ast.callbacks["chain-id"] = chainId;
        const nonce = function(state, chars, phraseIndex, phraseLength, data) {
            const ret = id.SEM_OK;
            if (state === id.SEM_PRE) {
                data.nonce = node_exports_1.default.utils.charsToString(chars, phraseIndex, phraseLength);
            }
            return ret;
        };
        parser.ast.callbacks.nonce = nonce;
        const issuedAt = function(state, chars, phraseIndex, phraseLength, data) {
            const ret = id.SEM_OK;
            if (state === id.SEM_PRE) {
                data.issuedAt = node_exports_1.default.utils.charsToString(chars, phraseIndex, phraseLength);
            }
            return ret;
        };
        parser.ast.callbacks["issued-at"] = issuedAt;
        const expirationTime = function(state, chars, phraseIndex, phraseLength, data) {
            const ret = id.SEM_OK;
            if (state === id.SEM_PRE) {
                data.expirationTime = node_exports_1.default.utils.charsToString(chars, phraseIndex, phraseLength);
            }
            return ret;
        };
        parser.ast.callbacks["expiration-time"] = expirationTime;
        const notBefore = function(state, chars, phraseIndex, phraseLength, data) {
            const ret = id.SEM_OK;
            if (state === id.SEM_PRE) {
                data.notBefore = node_exports_1.default.utils.charsToString(chars, phraseIndex, phraseLength);
            }
            return ret;
        };
        parser.ast.callbacks["not-before"] = notBefore;
        const requestId = function(state, chars, phraseIndex, phraseLength, data) {
            const ret = id.SEM_OK;
            if (state === id.SEM_PRE) {
                data.requestId = node_exports_1.default.utils.charsToString(chars, phraseIndex, phraseLength);
            }
            return ret;
        };
        parser.ast.callbacks["request-id"] = requestId;
        const resources = function(state, chars, phraseIndex, phraseLength, data) {
            const ret = id.SEM_OK;
            if (state === id.SEM_PRE) {
                data.resources = node_exports_1.default.utils.charsToString(chars, phraseIndex, phraseLength).slice(3).split("\n- ");
            }
            return ret;
        };
        parser.ast.callbacks.resources = resources;
        const result = parser.parse(GrammarApi.grammarObj, "sign-in-with-ethereum", msg);
        if (!result.success) {
            throw new Error(`Invalid message: ${JSON.stringify(result)}`);
        }
        const elements = {};
        parser.ast.translate(elements);
        for (const [key, value] of Object.entries(elements)){
            this[key] = value;
        }
        if (this.domain.length === 0) {
            throw new Error("Domain cannot be empty.");
        }
        if (!(0, utils_1.isEIP55Address)(this.address)) {
            throw new Error("Address not conformant to EIP-55.");
        }
    }
}
exports.ParsedMessage = ParsedMessage;
}),
"[project]/node_modules/@spruceid/siwe-parser/dist/parsers.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ParsedMessage = void 0;
const abnf_1 = __turbopack_context__.r("[project]/node_modules/@spruceid/siwe-parser/dist/abnf.js [app-client] (ecmascript)");
Object.defineProperty(exports, "ParsedMessage", {
    enumerable: true,
    get: function() {
        return abnf_1.ParsedMessage;
    }
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@spruceid/siwe-parser/dist/utils.js [app-client] (ecmascript)"), exports);
}),
"[project]/node_modules/valid-url/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

(function(module1) {
    'use strict';
    module1.exports.is_uri = is_iri;
    module1.exports.is_http_uri = is_http_iri;
    module1.exports.is_https_uri = is_https_iri;
    module1.exports.is_web_uri = is_web_iri;
    // Create aliases
    module1.exports.isUri = is_iri;
    module1.exports.isHttpUri = is_http_iri;
    module1.exports.isHttpsUri = is_https_iri;
    module1.exports.isWebUri = is_web_iri;
    // private function
    // internal URI spitter method - direct from RFC 3986
    var splitUri = function(uri) {
        var splitted = uri.match(/(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/);
        return splitted;
    };
    function is_iri(value) {
        if (!value) {
            return;
        }
        // check for illegal characters
        if (/[^a-z0-9\:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=\.\-\_\~\%]/i.test(value)) return;
        // check for hex escapes that aren't complete
        if (/%[^0-9a-f]/i.test(value)) return;
        if (/%[0-9a-f](:?[^0-9a-f]|$)/i.test(value)) return;
        var splitted = [];
        var scheme = '';
        var authority = '';
        var path = '';
        var query = '';
        var fragment = '';
        var out = '';
        // from RFC 3986
        splitted = splitUri(value);
        scheme = splitted[1];
        authority = splitted[2];
        path = splitted[3];
        query = splitted[4];
        fragment = splitted[5];
        // scheme and path are required, though the path can be empty
        if (!(scheme && scheme.length && path.length >= 0)) return;
        // if authority is present, the path must be empty or begin with a /
        if (authority && authority.length) {
            if (!(path.length === 0 || /^\//.test(path))) return;
        } else {
            // if authority is not present, the path must not start with //
            if (/^\/\//.test(path)) return;
        }
        // scheme must begin with a letter, then consist of letters, digits, +, ., or -
        if (!/^[a-z][a-z0-9\+\-\.]*$/.test(scheme.toLowerCase())) return;
        // re-assemble the URL per section 5.3 in RFC 3986
        out += scheme + ':';
        if (authority && authority.length) {
            out += '//' + authority;
        }
        out += path;
        if (query && query.length) {
            out += '?' + query;
        }
        if (fragment && fragment.length) {
            out += '#' + fragment;
        }
        return out;
    }
    function is_http_iri(value, allowHttps) {
        if (!is_iri(value)) {
            return;
        }
        var splitted = [];
        var scheme = '';
        var authority = '';
        var path = '';
        var port = '';
        var query = '';
        var fragment = '';
        var out = '';
        // from RFC 3986
        splitted = splitUri(value);
        scheme = splitted[1];
        authority = splitted[2];
        path = splitted[3];
        query = splitted[4];
        fragment = splitted[5];
        if (!scheme) return;
        if (allowHttps) {
            if (scheme.toLowerCase() != 'https') return;
        } else {
            if (scheme.toLowerCase() != 'http') return;
        }
        // fully-qualified URIs must have an authority section that is
        // a valid host
        if (!authority) {
            return;
        }
        // enable port component
        if (/:(\d+)$/.test(authority)) {
            port = authority.match(/:(\d+)$/)[0];
            authority = authority.replace(/:\d+$/, '');
        }
        out += scheme + ':';
        out += '//' + authority;
        if (port) {
            out += port;
        }
        out += path;
        if (query && query.length) {
            out += '?' + query;
        }
        if (fragment && fragment.length) {
            out += '#' + fragment;
        }
        return out;
    }
    function is_https_iri(value) {
        return is_http_iri(value, true);
    }
    function is_web_iri(value) {
        return is_http_iri(value) || is_https_iri(value);
    }
})(module);
}),
"[project]/node_modules/siwe/dist/ethersCompat.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getAddress = exports.hashMessage = exports.verifyMessage = void 0;
const ethers_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-client] (ecmascript)");
let ethersVerifyMessage = null;
let ethersHashMessage = null;
let ethersGetAddress = null;
try {
    // @ts-expect-error -- v6 compatibility hack
    ethersVerifyMessage = ethers_1.ethers.utils.verifyMessage;
    // @ts-expect-error -- v6 compatibility hack
    ethersHashMessage = ethers_1.ethers.utils.hashMessage;
    // @ts-expect-error -- v6 compatibility hack
    ethersGetAddress = ethers_1.ethers.utils.getAddress;
} catch (_a) {
    ethersVerifyMessage = ethers_1.ethers.verifyMessage;
    ethersHashMessage = ethers_1.ethers.hashMessage;
    ethersGetAddress = ethers_1.ethers.getAddress;
}
exports.verifyMessage = ethersVerifyMessage;
exports.hashMessage = ethersHashMessage;
exports.getAddress = ethersGetAddress;
}),
"[project]/node_modules/siwe/dist/types.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SiweErrorType = exports.SiweError = exports.VerifyOptsKeys = exports.VerifyParamsKeys = void 0;
exports.VerifyParamsKeys = [
    'signature',
    'scheme',
    'domain',
    'nonce',
    'time'
];
exports.VerifyOptsKeys = [
    'provider',
    'suppressExceptions',
    'verificationFallback'
];
/**
 * Interface used to return errors in SiweResponses.
 */ class SiweError {
    constructor(type, expected, received){
        this.type = type;
        this.expected = expected;
        this.received = received;
    }
}
exports.SiweError = SiweError;
/**
 * Possible message error types.
 */ var SiweErrorType;
(function(SiweErrorType) {
    /** `expirationTime` is present and in the past. */ SiweErrorType["EXPIRED_MESSAGE"] = "Expired message.";
    /** `domain` is not a valid authority or is empty. */ SiweErrorType["INVALID_DOMAIN"] = "Invalid domain.";
    /** `scheme` don't match the scheme provided for verification. */ SiweErrorType["SCHEME_MISMATCH"] = "Scheme does not match provided scheme for verification.";
    /** `domain` don't match the domain provided for verification. */ SiweErrorType["DOMAIN_MISMATCH"] = "Domain does not match provided domain for verification.";
    /** `nonce` don't match the nonce provided for verification. */ SiweErrorType["NONCE_MISMATCH"] = "Nonce does not match provided nonce for verification.";
    /** `address` does not conform to EIP-55 or is not a valid address. */ SiweErrorType["INVALID_ADDRESS"] = "Invalid address.";
    /** `uri` does not conform to RFC 3986. */ SiweErrorType["INVALID_URI"] = "URI does not conform to RFC 3986.";
    /** `nonce` is smaller then 8 characters or is not alphanumeric */ SiweErrorType["INVALID_NONCE"] = "Nonce size smaller then 8 characters or is not alphanumeric.";
    /** `notBefore` is present and in the future. */ SiweErrorType["NOT_YET_VALID_MESSAGE"] = "Message is not valid yet.";
    /** Signature doesn't match the address of the message. */ SiweErrorType["INVALID_SIGNATURE"] = "Signature does not match address of the message.";
    /** `expirationTime`, `notBefore` or `issuedAt` not complient to ISO-8601. */ SiweErrorType["INVALID_TIME_FORMAT"] = "Invalid time format.";
    /** `version` is not 1. */ SiweErrorType["INVALID_MESSAGE_VERSION"] = "Invalid message version.";
    /** Thrown when some required field is missing. */ SiweErrorType["UNABLE_TO_PARSE"] = "Unable to parse the message.";
})(SiweErrorType = exports.SiweErrorType || (exports.SiweErrorType = {}));
}),
"[project]/node_modules/siwe/dist/utils.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.checkInvalidKeys = exports.isValidISO8601Date = exports.generateNonce = exports.checkContractWalletSignature = void 0;
const random_1 = __turbopack_context__.r("[project]/node_modules/@stablelib/random/lib/random.js [app-client] (ecmascript)");
// @ts-expect-error -- ethers v6 compatibility hack
const ethers_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-client] (ecmascript)");
const ethersCompat_1 = __turbopack_context__.r("[project]/node_modules/siwe/dist/ethersCompat.js [app-client] (ecmascript)");
const EIP1271_ABI = [
    'function isValidSignature(bytes32 _message, bytes _signature) public view returns (bytes4)'
];
const EIP1271_MAGICVALUE = '0x1626ba7e';
const ISO8601 = /^(?<date>[0-9]{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01]))[Tt]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(.[0-9]+)?(([Zz])|([+|-]([01][0-9]|2[0-3]):[0-5][0-9]))$/;
/**
 * This method calls the EIP-1271 method for Smart Contract wallets
 * @param message The EIP-4361 parsed message
 * @param provider Web3 provider able to perform a contract check (Web3/EthersJS).
 * @returns {Promise<boolean>} Checks for the smart contract (if it exists) if
 * the signature is valid for given address.
 */ const checkContractWalletSignature = (message, signature, provider)=>__awaiter(void 0, void 0, void 0, function*() {
        if (!provider) {
            return false;
        }
        const walletContract = new ethers_1.Contract(message.address, EIP1271_ABI, provider);
        const hashedMessage = (0, ethersCompat_1.hashMessage)(message.prepareMessage());
        const res = yield walletContract.isValidSignature(hashedMessage, signature);
        return res === EIP1271_MAGICVALUE;
    });
exports.checkContractWalletSignature = checkContractWalletSignature;
/**
 * This method leverages a native CSPRNG with support for both browser and Node.js
 * environments in order generate a cryptographically secure nonce for use in the
 * SiweMessage in order to prevent replay attacks.
 *
 * 96 bits has been chosen as a number to sufficiently balance size and security considerations
 * relative to the lifespan of it's usage.
 *
 * @returns cryptographically generated random nonce with 96 bits of entropy encoded with
 * an alphanumeric character set.
 */ const generateNonce = ()=>{
    const nonce = (0, random_1.randomStringForEntropy)(96);
    if (!nonce || nonce.length < 8) {
        throw new Error('Error during nonce creation.');
    }
    return nonce;
};
exports.generateNonce = generateNonce;
/**
 * This method matches the given date string against the ISO-8601 regex and also
 * performs checks if it's a valid date.
 * @param inputDate any string to be validated against ISO-8601
 * @returns boolean indicating if the providade date is valid and conformant to ISO-8601
 */ const isValidISO8601Date = (inputDate)=>{
    /* Split groups and make sure inputDate is in ISO8601 format */ const inputMatch = ISO8601.exec(inputDate);
    /* if inputMatch is null the date is not ISO-8601 */ if (!inputDate) {
        return false;
    }
    /* Creates a date object with input date to parse for invalid days e.g. Feb, 30 -> Mar, 01 */ const inputDateParsed = new Date(inputMatch.groups.date).toISOString();
    /* Get groups from new parsed date to compare with the original input */ const parsedInputMatch = ISO8601.exec(inputDateParsed);
    /* Compare remaining fields */ return inputMatch.groups.date === parsedInputMatch.groups.date;
};
exports.isValidISO8601Date = isValidISO8601Date;
const checkInvalidKeys = (obj, keys)=>{
    const invalidKeys = [];
    Object.keys(obj).forEach((key)=>{
        if (!keys.includes(key)) {
            invalidKeys.push(key);
        }
    });
    return invalidKeys;
};
exports.checkInvalidKeys = checkInvalidKeys;
}),
"[project]/node_modules/siwe/dist/client.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SiweMessage = void 0;
// TODO: Figure out how to get types from this lib:
const siwe_parser_1 = __turbopack_context__.r("[project]/node_modules/@spruceid/siwe-parser/dist/parsers.js [app-client] (ecmascript)");
const uri = __importStar(__turbopack_context__.r("[project]/node_modules/valid-url/index.js [app-client] (ecmascript)"));
const ethersCompat_1 = __turbopack_context__.r("[project]/node_modules/siwe/dist/ethersCompat.js [app-client] (ecmascript)");
const types_1 = __turbopack_context__.r("[project]/node_modules/siwe/dist/types.js [app-client] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/siwe/dist/utils.js [app-client] (ecmascript)");
class SiweMessage {
    /**
     * Creates a parsed Sign-In with Ethereum Message (EIP-4361) object from a
     * string or an object. If a string is used an ABNF parser is called to
     * validate the parameter, otherwise the fields are attributed.
     * @param param {string | SiweMessage} Sign message as a string or an object.
     */ constructor(param){
        if (typeof param === 'string') {
            const parsedMessage = new siwe_parser_1.ParsedMessage(param);
            this.scheme = parsedMessage.scheme;
            this.domain = parsedMessage.domain;
            this.address = parsedMessage.address;
            this.statement = parsedMessage.statement;
            this.uri = parsedMessage.uri;
            this.version = parsedMessage.version;
            this.nonce = parsedMessage.nonce;
            this.issuedAt = parsedMessage.issuedAt;
            this.expirationTime = parsedMessage.expirationTime;
            this.notBefore = parsedMessage.notBefore;
            this.requestId = parsedMessage.requestId;
            this.chainId = parsedMessage.chainId;
            this.resources = parsedMessage.resources;
        } else {
            this.scheme = param === null || param === void 0 ? void 0 : param.scheme;
            this.domain = param.domain;
            this.address = param.address;
            this.statement = param === null || param === void 0 ? void 0 : param.statement;
            this.uri = param.uri;
            this.version = param.version;
            this.chainId = param.chainId;
            this.nonce = param.nonce;
            this.issuedAt = param === null || param === void 0 ? void 0 : param.issuedAt;
            this.expirationTime = param === null || param === void 0 ? void 0 : param.expirationTime;
            this.notBefore = param === null || param === void 0 ? void 0 : param.notBefore;
            this.requestId = param === null || param === void 0 ? void 0 : param.requestId;
            this.resources = param === null || param === void 0 ? void 0 : param.resources;
            if (typeof this.chainId === 'string') {
                this.chainId = (0, siwe_parser_1.parseIntegerNumber)(this.chainId);
            }
        }
        this.nonce = this.nonce || (0, utils_1.generateNonce)();
        this.validateMessage();
    }
    /**
     * This function can be used to retrieve an EIP-4361 formated message for
     * signature, although you can call it directly it's advised to use
     * [prepareMessage()] instead which will resolve to the correct method based
     * on the [type] attribute of this object, in case of other formats being
     * implemented.
     * @returns {string} EIP-4361 formated message, ready for EIP-191 signing.
     */ toMessage() {
        /** Validates all fields of the object */ this.validateMessage();
        const headerPrefx = this.scheme ? `${this.scheme}://${this.domain}` : this.domain;
        const header = `${headerPrefx} wants you to sign in with your Ethereum account:`;
        const uriField = `URI: ${this.uri}`;
        let prefix = [
            header,
            this.address
        ].join('\n');
        const versionField = `Version: ${this.version}`;
        if (!this.nonce) {
            this.nonce = (0, utils_1.generateNonce)();
        }
        const chainField = `Chain ID: ` + this.chainId || '1';
        const nonceField = `Nonce: ${this.nonce}`;
        const suffixArray = [
            uriField,
            versionField,
            chainField,
            nonceField
        ];
        this.issuedAt = this.issuedAt || new Date().toISOString();
        suffixArray.push(`Issued At: ${this.issuedAt}`);
        if (this.expirationTime) {
            const expiryField = `Expiration Time: ${this.expirationTime}`;
            suffixArray.push(expiryField);
        }
        if (this.notBefore) {
            suffixArray.push(`Not Before: ${this.notBefore}`);
        }
        if (this.requestId) {
            suffixArray.push(`Request ID: ${this.requestId}`);
        }
        if (this.resources) {
            suffixArray.push([
                `Resources:`,
                ...this.resources.map((x)=>`- ${x}`)
            ].join('\n'));
        }
        const suffix = suffixArray.join('\n');
        prefix = [
            prefix,
            this.statement
        ].join('\n\n');
        if (this.statement) {
            prefix += '\n';
        }
        return [
            prefix,
            suffix
        ].join('\n');
    }
    /**
     * This method parses all the fields in the object and creates a messaging for signing
     * message according with the type defined.
     * @returns {string} Returns a message ready to be signed according with the
     * type defined in the object.
     */ prepareMessage() {
        let message;
        switch(this.version){
            case '1':
                {
                    message = this.toMessage();
                    break;
                }
            default:
                {
                    message = this.toMessage();
                    break;
                }
        }
        return message;
    }
    /**
     * @deprecated
     * Verifies the integrity of the object by matching its signature.
     * @param signature Signature to match the address in the message.
     * @param provider Ethers provider to be used for EIP-1271 validation
     */ validate(signature, provider) {
        return __awaiter(this, void 0, void 0, function*() {
            console.warn('validate() has been deprecated, please update your code to use verify(). validate() may be removed in future versions.');
            return this.verify({
                signature
            }, {
                provider,
                suppressExceptions: false
            }).then(({ data })=>data).catch(({ error })=>{
                throw error;
            });
        });
    }
    /**
     * Verifies the integrity of the object by matching its signature.
     * @param params Parameters to verify the integrity of the message, signature is required.
     * @returns {Promise<SiweMessage>} This object if valid.
     */ verify(params, opts = {
        suppressExceptions: false
    }) {
        return __awaiter(this, void 0, void 0, function*() {
            return new Promise((resolve, reject)=>{
                var _a, _b, _c;
                const fail = (result)=>{
                    if (opts.suppressExceptions) {
                        return resolve(result);
                    } else {
                        return reject(result);
                    }
                };
                const invalidParams = (0, utils_1.checkInvalidKeys)(params, types_1.VerifyParamsKeys);
                if (invalidParams.length > 0) {
                    fail({
                        success: false,
                        data: this,
                        error: new Error(`${invalidParams.join(', ')} is/are not valid key(s) for VerifyParams.`)
                    });
                }
                const invalidOpts = (0, utils_1.checkInvalidKeys)(opts, types_1.VerifyOptsKeys);
                if (invalidParams.length > 0) {
                    fail({
                        success: false,
                        data: this,
                        error: new Error(`${invalidOpts.join(', ')} is/are not valid key(s) for VerifyOpts.`)
                    });
                }
                const { signature, scheme, domain, nonce, time } = params;
                /** Scheme for domain binding */ if (scheme && scheme !== this.scheme) {
                    fail({
                        success: false,
                        data: this,
                        error: new types_1.SiweError(types_1.SiweErrorType.SCHEME_MISMATCH, scheme, this.scheme)
                    });
                }
                /** Domain binding */ if (domain && domain !== this.domain) {
                    fail({
                        success: false,
                        data: this,
                        error: new types_1.SiweError(types_1.SiweErrorType.DOMAIN_MISMATCH, domain, this.domain)
                    });
                }
                /** Nonce binding */ if (nonce && nonce !== this.nonce) {
                    fail({
                        success: false,
                        data: this,
                        error: new types_1.SiweError(types_1.SiweErrorType.NONCE_MISMATCH, nonce, this.nonce)
                    });
                }
                /** Check time or now */ const checkTime = new Date(time || new Date());
                /** Message not expired */ if (this.expirationTime) {
                    const expirationDate = new Date(this.expirationTime);
                    if (checkTime.getTime() >= expirationDate.getTime()) {
                        fail({
                            success: false,
                            data: this,
                            error: new types_1.SiweError(types_1.SiweErrorType.EXPIRED_MESSAGE, `${checkTime.toISOString()} < ${expirationDate.toISOString()}`, `${checkTime.toISOString()} >= ${expirationDate.toISOString()}`)
                        });
                    }
                }
                /** Message is valid already */ if (this.notBefore) {
                    const notBefore = new Date(this.notBefore);
                    if (checkTime.getTime() < notBefore.getTime()) {
                        fail({
                            success: false,
                            data: this,
                            error: new types_1.SiweError(types_1.SiweErrorType.NOT_YET_VALID_MESSAGE, `${checkTime.toISOString()} >= ${notBefore.toISOString()}`, `${checkTime.toISOString()} < ${notBefore.toISOString()}`)
                        });
                    }
                }
                let EIP4361Message;
                try {
                    EIP4361Message = this.prepareMessage();
                } catch (e) {
                    fail({
                        success: false,
                        data: this,
                        error: e
                    });
                }
                /** Recover address from signature */ let addr;
                try {
                    addr = (0, ethersCompat_1.verifyMessage)(EIP4361Message, signature);
                } catch (e) {
                    console.error(e);
                }
                /** Match signature with message's address */ if (addr === this.address) {
                    return resolve({
                        success: true,
                        data: this
                    });
                } else {
                    const EIP1271Promise = (0, utils_1.checkContractWalletSignature)(this, signature, opts.provider).then((isValid)=>{
                        if (!isValid) {
                            return {
                                success: false,
                                data: this,
                                error: new types_1.SiweError(types_1.SiweErrorType.INVALID_SIGNATURE, addr, `Resolved address to be ${this.address}`)
                            };
                        }
                        return {
                            success: true,
                            data: this
                        };
                    }).catch((error)=>{
                        return {
                            success: false,
                            data: this,
                            error
                        };
                    });
                    Promise.all([
                        EIP1271Promise,
                        (_c = (_b = (_a = opts === null || opts === void 0 ? void 0 : opts.verificationFallback) === null || _a === void 0 ? void 0 : _a.call(opts, params, opts, this, EIP1271Promise)) === null || _b === void 0 ? void 0 : _b.then((res)=>res)) === null || _c === void 0 ? void 0 : _c.catch((res)=>res)
                    ]).then(([EIP1271Response, fallbackResponse])=>{
                        if (fallbackResponse) {
                            if (fallbackResponse.success) {
                                return resolve(fallbackResponse);
                            } else {
                                fail(fallbackResponse);
                            }
                        } else {
                            if (EIP1271Response.success) {
                                return resolve(EIP1271Response);
                            } else {
                                fail(EIP1271Response);
                            }
                        }
                    });
                }
            });
        });
    }
    /**
     * Validates the values of this object fields.
     * @throws Throws an {ErrorType} if a field is invalid.
     */ validateMessage(...args) {
        var _a;
        /** Checks if the user might be using the function to verify instead of validate. */ if (args.length > 0) {
            throw new types_1.SiweError(types_1.SiweErrorType.UNABLE_TO_PARSE, `Unexpected argument in the validateMessage function.`);
        }
        /** `domain` check. */ if (!this.domain || this.domain.length === 0 || !/[^#?]*/.test(this.domain)) {
            throw new types_1.SiweError(types_1.SiweErrorType.INVALID_DOMAIN, `${this.domain} to be a valid domain.`);
        }
        /** EIP-55 `address` check. */ if (!(0, siwe_parser_1.isEIP55Address)(this.address)) {
            throw new types_1.SiweError(types_1.SiweErrorType.INVALID_ADDRESS, (0, ethersCompat_1.getAddress)(this.address), this.address);
        }
        /** Check if the URI is valid. */ if (!uri.isUri(this.uri)) {
            throw new types_1.SiweError(types_1.SiweErrorType.INVALID_URI, `${this.uri} to be a valid uri.`);
        }
        /** Check if the version is 1. */ if (this.version !== '1') {
            throw new types_1.SiweError(types_1.SiweErrorType.INVALID_MESSAGE_VERSION, '1', this.version);
        }
        /** Check if the nonce is alphanumeric and bigger then 8 characters */ const nonce = (_a = this === null || this === void 0 ? void 0 : this.nonce) === null || _a === void 0 ? void 0 : _a.match(/[a-zA-Z0-9]{8,}/);
        if (!nonce || this.nonce.length < 8 || nonce[0] !== this.nonce) {
            throw new types_1.SiweError(types_1.SiweErrorType.INVALID_NONCE, `Length > 8 (${nonce.length}). Alphanumeric.`, this.nonce);
        }
        /** `issuedAt` conforms to ISO-8601 and is a valid date. */ if (this.issuedAt) {
            if (!(0, utils_1.isValidISO8601Date)(this.issuedAt)) {
                throw new Error(types_1.SiweErrorType.INVALID_TIME_FORMAT);
            }
        }
        /** `expirationTime` conforms to ISO-8601 and is a valid date. */ if (this.expirationTime) {
            if (!(0, utils_1.isValidISO8601Date)(this.expirationTime)) {
                throw new Error(types_1.SiweErrorType.INVALID_TIME_FORMAT);
            }
        }
        /** `notBefore` conforms to ISO-8601 and is a valid date. */ if (this.notBefore) {
            if (!(0, utils_1.isValidISO8601Date)(this.notBefore)) {
                throw new Error(types_1.SiweErrorType.INVALID_TIME_FORMAT);
            }
        }
    }
}
exports.SiweMessage = SiweMessage;
}),
"[project]/node_modules/siwe/dist/siwe.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/siwe/dist/client.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/siwe/dist/types.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/siwe/dist/utils.js [app-client] (ecmascript)"), exports);
}),
"[project]/node_modules/tweetnacl/nacl-fast.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

(function(nacl) {
    'use strict';
    // Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
    // Public domain.
    //
    // Implementation derived from TweetNaCl version 20140427.
    // See for details: http://tweetnacl.cr.yp.to/
    var gf = function(init) {
        var i, r = new Float64Array(16);
        if (init) for(i = 0; i < init.length; i++)r[i] = init[i];
        return r;
    };
    //  Pluggable, initialized in high-level API below.
    var randombytes = function() {
        throw new Error('no PRNG');
    };
    var _0 = new Uint8Array(16);
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var gf0 = gf(), gf1 = gf([
        1
    ]), _121665 = gf([
        0xdb41,
        1
    ]), D = gf([
        0x78a3,
        0x1359,
        0x4dca,
        0x75eb,
        0xd8ab,
        0x4141,
        0x0a4d,
        0x0070,
        0xe898,
        0x7779,
        0x4079,
        0x8cc7,
        0xfe73,
        0x2b6f,
        0x6cee,
        0x5203
    ]), D2 = gf([
        0xf159,
        0x26b2,
        0x9b94,
        0xebd6,
        0xb156,
        0x8283,
        0x149a,
        0x00e0,
        0xd130,
        0xeef3,
        0x80f2,
        0x198e,
        0xfce7,
        0x56df,
        0xd9dc,
        0x2406
    ]), X = gf([
        0xd51a,
        0x8f25,
        0x2d60,
        0xc956,
        0xa7b2,
        0x9525,
        0xc760,
        0x692c,
        0xdc5c,
        0xfdd6,
        0xe231,
        0xc0a4,
        0x53fe,
        0xcd6e,
        0x36d3,
        0x2169
    ]), Y = gf([
        0x6658,
        0x6666,
        0x6666,
        0x6666,
        0x6666,
        0x6666,
        0x6666,
        0x6666,
        0x6666,
        0x6666,
        0x6666,
        0x6666,
        0x6666,
        0x6666,
        0x6666,
        0x6666
    ]), I = gf([
        0xa0b0,
        0x4a0e,
        0x1b27,
        0xc4ee,
        0xe478,
        0xad2f,
        0x1806,
        0x2f43,
        0xd7a7,
        0x3dfb,
        0x0099,
        0x2b4d,
        0xdf0b,
        0x4fc1,
        0x2480,
        0x2b83
    ]);
    function ts64(x, i, h, l) {
        x[i] = h >> 24 & 0xff;
        x[i + 1] = h >> 16 & 0xff;
        x[i + 2] = h >> 8 & 0xff;
        x[i + 3] = h & 0xff;
        x[i + 4] = l >> 24 & 0xff;
        x[i + 5] = l >> 16 & 0xff;
        x[i + 6] = l >> 8 & 0xff;
        x[i + 7] = l & 0xff;
    }
    function vn(x, xi, y, yi, n) {
        var i, d = 0;
        for(i = 0; i < n; i++)d |= x[xi + i] ^ y[yi + i];
        return (1 & d - 1 >>> 8) - 1;
    }
    function crypto_verify_16(x, xi, y, yi) {
        return vn(x, xi, y, yi, 16);
    }
    function crypto_verify_32(x, xi, y, yi) {
        return vn(x, xi, y, yi, 32);
    }
    function core_salsa20(o, p, k, c) {
        var j0 = c[0] & 0xff | (c[1] & 0xff) << 8 | (c[2] & 0xff) << 16 | (c[3] & 0xff) << 24, j1 = k[0] & 0xff | (k[1] & 0xff) << 8 | (k[2] & 0xff) << 16 | (k[3] & 0xff) << 24, j2 = k[4] & 0xff | (k[5] & 0xff) << 8 | (k[6] & 0xff) << 16 | (k[7] & 0xff) << 24, j3 = k[8] & 0xff | (k[9] & 0xff) << 8 | (k[10] & 0xff) << 16 | (k[11] & 0xff) << 24, j4 = k[12] & 0xff | (k[13] & 0xff) << 8 | (k[14] & 0xff) << 16 | (k[15] & 0xff) << 24, j5 = c[4] & 0xff | (c[5] & 0xff) << 8 | (c[6] & 0xff) << 16 | (c[7] & 0xff) << 24, j6 = p[0] & 0xff | (p[1] & 0xff) << 8 | (p[2] & 0xff) << 16 | (p[3] & 0xff) << 24, j7 = p[4] & 0xff | (p[5] & 0xff) << 8 | (p[6] & 0xff) << 16 | (p[7] & 0xff) << 24, j8 = p[8] & 0xff | (p[9] & 0xff) << 8 | (p[10] & 0xff) << 16 | (p[11] & 0xff) << 24, j9 = p[12] & 0xff | (p[13] & 0xff) << 8 | (p[14] & 0xff) << 16 | (p[15] & 0xff) << 24, j10 = c[8] & 0xff | (c[9] & 0xff) << 8 | (c[10] & 0xff) << 16 | (c[11] & 0xff) << 24, j11 = k[16] & 0xff | (k[17] & 0xff) << 8 | (k[18] & 0xff) << 16 | (k[19] & 0xff) << 24, j12 = k[20] & 0xff | (k[21] & 0xff) << 8 | (k[22] & 0xff) << 16 | (k[23] & 0xff) << 24, j13 = k[24] & 0xff | (k[25] & 0xff) << 8 | (k[26] & 0xff) << 16 | (k[27] & 0xff) << 24, j14 = k[28] & 0xff | (k[29] & 0xff) << 8 | (k[30] & 0xff) << 16 | (k[31] & 0xff) << 24, j15 = c[12] & 0xff | (c[13] & 0xff) << 8 | (c[14] & 0xff) << 16 | (c[15] & 0xff) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for(var i = 0; i < 20; i += 2){
            u = x0 + x12 | 0;
            x4 ^= u << 7 | u >>> 32 - 7;
            u = x4 + x0 | 0;
            x8 ^= u << 9 | u >>> 32 - 9;
            u = x8 + x4 | 0;
            x12 ^= u << 13 | u >>> 32 - 13;
            u = x12 + x8 | 0;
            x0 ^= u << 18 | u >>> 32 - 18;
            u = x5 + x1 | 0;
            x9 ^= u << 7 | u >>> 32 - 7;
            u = x9 + x5 | 0;
            x13 ^= u << 9 | u >>> 32 - 9;
            u = x13 + x9 | 0;
            x1 ^= u << 13 | u >>> 32 - 13;
            u = x1 + x13 | 0;
            x5 ^= u << 18 | u >>> 32 - 18;
            u = x10 + x6 | 0;
            x14 ^= u << 7 | u >>> 32 - 7;
            u = x14 + x10 | 0;
            x2 ^= u << 9 | u >>> 32 - 9;
            u = x2 + x14 | 0;
            x6 ^= u << 13 | u >>> 32 - 13;
            u = x6 + x2 | 0;
            x10 ^= u << 18 | u >>> 32 - 18;
            u = x15 + x11 | 0;
            x3 ^= u << 7 | u >>> 32 - 7;
            u = x3 + x15 | 0;
            x7 ^= u << 9 | u >>> 32 - 9;
            u = x7 + x3 | 0;
            x11 ^= u << 13 | u >>> 32 - 13;
            u = x11 + x7 | 0;
            x15 ^= u << 18 | u >>> 32 - 18;
            u = x0 + x3 | 0;
            x1 ^= u << 7 | u >>> 32 - 7;
            u = x1 + x0 | 0;
            x2 ^= u << 9 | u >>> 32 - 9;
            u = x2 + x1 | 0;
            x3 ^= u << 13 | u >>> 32 - 13;
            u = x3 + x2 | 0;
            x0 ^= u << 18 | u >>> 32 - 18;
            u = x5 + x4 | 0;
            x6 ^= u << 7 | u >>> 32 - 7;
            u = x6 + x5 | 0;
            x7 ^= u << 9 | u >>> 32 - 9;
            u = x7 + x6 | 0;
            x4 ^= u << 13 | u >>> 32 - 13;
            u = x4 + x7 | 0;
            x5 ^= u << 18 | u >>> 32 - 18;
            u = x10 + x9 | 0;
            x11 ^= u << 7 | u >>> 32 - 7;
            u = x11 + x10 | 0;
            x8 ^= u << 9 | u >>> 32 - 9;
            u = x8 + x11 | 0;
            x9 ^= u << 13 | u >>> 32 - 13;
            u = x9 + x8 | 0;
            x10 ^= u << 18 | u >>> 32 - 18;
            u = x15 + x14 | 0;
            x12 ^= u << 7 | u >>> 32 - 7;
            u = x12 + x15 | 0;
            x13 ^= u << 9 | u >>> 32 - 9;
            u = x13 + x12 | 0;
            x14 ^= u << 13 | u >>> 32 - 13;
            u = x14 + x13 | 0;
            x15 ^= u << 18 | u >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x2 = x2 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o[0] = x0 >>> 0 & 0xff;
        o[1] = x0 >>> 8 & 0xff;
        o[2] = x0 >>> 16 & 0xff;
        o[3] = x0 >>> 24 & 0xff;
        o[4] = x1 >>> 0 & 0xff;
        o[5] = x1 >>> 8 & 0xff;
        o[6] = x1 >>> 16 & 0xff;
        o[7] = x1 >>> 24 & 0xff;
        o[8] = x2 >>> 0 & 0xff;
        o[9] = x2 >>> 8 & 0xff;
        o[10] = x2 >>> 16 & 0xff;
        o[11] = x2 >>> 24 & 0xff;
        o[12] = x3 >>> 0 & 0xff;
        o[13] = x3 >>> 8 & 0xff;
        o[14] = x3 >>> 16 & 0xff;
        o[15] = x3 >>> 24 & 0xff;
        o[16] = x4 >>> 0 & 0xff;
        o[17] = x4 >>> 8 & 0xff;
        o[18] = x4 >>> 16 & 0xff;
        o[19] = x4 >>> 24 & 0xff;
        o[20] = x5 >>> 0 & 0xff;
        o[21] = x5 >>> 8 & 0xff;
        o[22] = x5 >>> 16 & 0xff;
        o[23] = x5 >>> 24 & 0xff;
        o[24] = x6 >>> 0 & 0xff;
        o[25] = x6 >>> 8 & 0xff;
        o[26] = x6 >>> 16 & 0xff;
        o[27] = x6 >>> 24 & 0xff;
        o[28] = x7 >>> 0 & 0xff;
        o[29] = x7 >>> 8 & 0xff;
        o[30] = x7 >>> 16 & 0xff;
        o[31] = x7 >>> 24 & 0xff;
        o[32] = x8 >>> 0 & 0xff;
        o[33] = x8 >>> 8 & 0xff;
        o[34] = x8 >>> 16 & 0xff;
        o[35] = x8 >>> 24 & 0xff;
        o[36] = x9 >>> 0 & 0xff;
        o[37] = x9 >>> 8 & 0xff;
        o[38] = x9 >>> 16 & 0xff;
        o[39] = x9 >>> 24 & 0xff;
        o[40] = x10 >>> 0 & 0xff;
        o[41] = x10 >>> 8 & 0xff;
        o[42] = x10 >>> 16 & 0xff;
        o[43] = x10 >>> 24 & 0xff;
        o[44] = x11 >>> 0 & 0xff;
        o[45] = x11 >>> 8 & 0xff;
        o[46] = x11 >>> 16 & 0xff;
        o[47] = x11 >>> 24 & 0xff;
        o[48] = x12 >>> 0 & 0xff;
        o[49] = x12 >>> 8 & 0xff;
        o[50] = x12 >>> 16 & 0xff;
        o[51] = x12 >>> 24 & 0xff;
        o[52] = x13 >>> 0 & 0xff;
        o[53] = x13 >>> 8 & 0xff;
        o[54] = x13 >>> 16 & 0xff;
        o[55] = x13 >>> 24 & 0xff;
        o[56] = x14 >>> 0 & 0xff;
        o[57] = x14 >>> 8 & 0xff;
        o[58] = x14 >>> 16 & 0xff;
        o[59] = x14 >>> 24 & 0xff;
        o[60] = x15 >>> 0 & 0xff;
        o[61] = x15 >>> 8 & 0xff;
        o[62] = x15 >>> 16 & 0xff;
        o[63] = x15 >>> 24 & 0xff;
    }
    function core_hsalsa20(o, p, k, c) {
        var j0 = c[0] & 0xff | (c[1] & 0xff) << 8 | (c[2] & 0xff) << 16 | (c[3] & 0xff) << 24, j1 = k[0] & 0xff | (k[1] & 0xff) << 8 | (k[2] & 0xff) << 16 | (k[3] & 0xff) << 24, j2 = k[4] & 0xff | (k[5] & 0xff) << 8 | (k[6] & 0xff) << 16 | (k[7] & 0xff) << 24, j3 = k[8] & 0xff | (k[9] & 0xff) << 8 | (k[10] & 0xff) << 16 | (k[11] & 0xff) << 24, j4 = k[12] & 0xff | (k[13] & 0xff) << 8 | (k[14] & 0xff) << 16 | (k[15] & 0xff) << 24, j5 = c[4] & 0xff | (c[5] & 0xff) << 8 | (c[6] & 0xff) << 16 | (c[7] & 0xff) << 24, j6 = p[0] & 0xff | (p[1] & 0xff) << 8 | (p[2] & 0xff) << 16 | (p[3] & 0xff) << 24, j7 = p[4] & 0xff | (p[5] & 0xff) << 8 | (p[6] & 0xff) << 16 | (p[7] & 0xff) << 24, j8 = p[8] & 0xff | (p[9] & 0xff) << 8 | (p[10] & 0xff) << 16 | (p[11] & 0xff) << 24, j9 = p[12] & 0xff | (p[13] & 0xff) << 8 | (p[14] & 0xff) << 16 | (p[15] & 0xff) << 24, j10 = c[8] & 0xff | (c[9] & 0xff) << 8 | (c[10] & 0xff) << 16 | (c[11] & 0xff) << 24, j11 = k[16] & 0xff | (k[17] & 0xff) << 8 | (k[18] & 0xff) << 16 | (k[19] & 0xff) << 24, j12 = k[20] & 0xff | (k[21] & 0xff) << 8 | (k[22] & 0xff) << 16 | (k[23] & 0xff) << 24, j13 = k[24] & 0xff | (k[25] & 0xff) << 8 | (k[26] & 0xff) << 16 | (k[27] & 0xff) << 24, j14 = k[28] & 0xff | (k[29] & 0xff) << 8 | (k[30] & 0xff) << 16 | (k[31] & 0xff) << 24, j15 = c[12] & 0xff | (c[13] & 0xff) << 8 | (c[14] & 0xff) << 16 | (c[15] & 0xff) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for(var i = 0; i < 20; i += 2){
            u = x0 + x12 | 0;
            x4 ^= u << 7 | u >>> 32 - 7;
            u = x4 + x0 | 0;
            x8 ^= u << 9 | u >>> 32 - 9;
            u = x8 + x4 | 0;
            x12 ^= u << 13 | u >>> 32 - 13;
            u = x12 + x8 | 0;
            x0 ^= u << 18 | u >>> 32 - 18;
            u = x5 + x1 | 0;
            x9 ^= u << 7 | u >>> 32 - 7;
            u = x9 + x5 | 0;
            x13 ^= u << 9 | u >>> 32 - 9;
            u = x13 + x9 | 0;
            x1 ^= u << 13 | u >>> 32 - 13;
            u = x1 + x13 | 0;
            x5 ^= u << 18 | u >>> 32 - 18;
            u = x10 + x6 | 0;
            x14 ^= u << 7 | u >>> 32 - 7;
            u = x14 + x10 | 0;
            x2 ^= u << 9 | u >>> 32 - 9;
            u = x2 + x14 | 0;
            x6 ^= u << 13 | u >>> 32 - 13;
            u = x6 + x2 | 0;
            x10 ^= u << 18 | u >>> 32 - 18;
            u = x15 + x11 | 0;
            x3 ^= u << 7 | u >>> 32 - 7;
            u = x3 + x15 | 0;
            x7 ^= u << 9 | u >>> 32 - 9;
            u = x7 + x3 | 0;
            x11 ^= u << 13 | u >>> 32 - 13;
            u = x11 + x7 | 0;
            x15 ^= u << 18 | u >>> 32 - 18;
            u = x0 + x3 | 0;
            x1 ^= u << 7 | u >>> 32 - 7;
            u = x1 + x0 | 0;
            x2 ^= u << 9 | u >>> 32 - 9;
            u = x2 + x1 | 0;
            x3 ^= u << 13 | u >>> 32 - 13;
            u = x3 + x2 | 0;
            x0 ^= u << 18 | u >>> 32 - 18;
            u = x5 + x4 | 0;
            x6 ^= u << 7 | u >>> 32 - 7;
            u = x6 + x5 | 0;
            x7 ^= u << 9 | u >>> 32 - 9;
            u = x7 + x6 | 0;
            x4 ^= u << 13 | u >>> 32 - 13;
            u = x4 + x7 | 0;
            x5 ^= u << 18 | u >>> 32 - 18;
            u = x10 + x9 | 0;
            x11 ^= u << 7 | u >>> 32 - 7;
            u = x11 + x10 | 0;
            x8 ^= u << 9 | u >>> 32 - 9;
            u = x8 + x11 | 0;
            x9 ^= u << 13 | u >>> 32 - 13;
            u = x9 + x8 | 0;
            x10 ^= u << 18 | u >>> 32 - 18;
            u = x15 + x14 | 0;
            x12 ^= u << 7 | u >>> 32 - 7;
            u = x12 + x15 | 0;
            x13 ^= u << 9 | u >>> 32 - 9;
            u = x13 + x12 | 0;
            x14 ^= u << 13 | u >>> 32 - 13;
            u = x14 + x13 | 0;
            x15 ^= u << 18 | u >>> 32 - 18;
        }
        o[0] = x0 >>> 0 & 0xff;
        o[1] = x0 >>> 8 & 0xff;
        o[2] = x0 >>> 16 & 0xff;
        o[3] = x0 >>> 24 & 0xff;
        o[4] = x5 >>> 0 & 0xff;
        o[5] = x5 >>> 8 & 0xff;
        o[6] = x5 >>> 16 & 0xff;
        o[7] = x5 >>> 24 & 0xff;
        o[8] = x10 >>> 0 & 0xff;
        o[9] = x10 >>> 8 & 0xff;
        o[10] = x10 >>> 16 & 0xff;
        o[11] = x10 >>> 24 & 0xff;
        o[12] = x15 >>> 0 & 0xff;
        o[13] = x15 >>> 8 & 0xff;
        o[14] = x15 >>> 16 & 0xff;
        o[15] = x15 >>> 24 & 0xff;
        o[16] = x6 >>> 0 & 0xff;
        o[17] = x6 >>> 8 & 0xff;
        o[18] = x6 >>> 16 & 0xff;
        o[19] = x6 >>> 24 & 0xff;
        o[20] = x7 >>> 0 & 0xff;
        o[21] = x7 >>> 8 & 0xff;
        o[22] = x7 >>> 16 & 0xff;
        o[23] = x7 >>> 24 & 0xff;
        o[24] = x8 >>> 0 & 0xff;
        o[25] = x8 >>> 8 & 0xff;
        o[26] = x8 >>> 16 & 0xff;
        o[27] = x8 >>> 24 & 0xff;
        o[28] = x9 >>> 0 & 0xff;
        o[29] = x9 >>> 8 & 0xff;
        o[30] = x9 >>> 16 & 0xff;
        o[31] = x9 >>> 24 & 0xff;
    }
    function crypto_core_salsa20(out, inp, k, c) {
        core_salsa20(out, inp, k, c);
    }
    function crypto_core_hsalsa20(out, inp, k, c) {
        core_hsalsa20(out, inp, k, c);
    }
    var sigma = new Uint8Array([
        101,
        120,
        112,
        97,
        110,
        100,
        32,
        51,
        50,
        45,
        98,
        121,
        116,
        101,
        32,
        107
    ]);
    // "expand 32-byte k"
    function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for(i = 0; i < 16; i++)z[i] = 0;
        for(i = 0; i < 8; i++)z[i] = n[i];
        while(b >= 64){
            crypto_core_salsa20(x, z, k, sigma);
            for(i = 0; i < 64; i++)c[cpos + i] = m[mpos + i] ^ x[i];
            u = 1;
            for(i = 8; i < 16; i++){
                u = u + (z[i] & 0xff) | 0;
                z[i] = u & 0xff;
                u >>>= 8;
            }
            b -= 64;
            cpos += 64;
            mpos += 64;
        }
        if (b > 0) {
            crypto_core_salsa20(x, z, k, sigma);
            for(i = 0; i < b; i++)c[cpos + i] = m[mpos + i] ^ x[i];
        }
        return 0;
    }
    function crypto_stream_salsa20(c, cpos, b, n, k) {
        var z = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for(i = 0; i < 16; i++)z[i] = 0;
        for(i = 0; i < 8; i++)z[i] = n[i];
        while(b >= 64){
            crypto_core_salsa20(x, z, k, sigma);
            for(i = 0; i < 64; i++)c[cpos + i] = x[i];
            u = 1;
            for(i = 8; i < 16; i++){
                u = u + (z[i] & 0xff) | 0;
                z[i] = u & 0xff;
                u >>>= 8;
            }
            b -= 64;
            cpos += 64;
        }
        if (b > 0) {
            crypto_core_salsa20(x, z, k, sigma);
            for(i = 0; i < b; i++)c[cpos + i] = x[i];
        }
        return 0;
    }
    function crypto_stream(c, cpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for(var i = 0; i < 8; i++)sn[i] = n[i + 16];
        return crypto_stream_salsa20(c, cpos, d, sn, s);
    }
    function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for(var i = 0; i < 8; i++)sn[i] = n[i + 16];
        return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
    }
    /*
* Port of Andrew Moon's Poly1305-donna-16. Public domain.
* https://github.com/floodyberry/poly1305-donna
*/ var poly1305 = function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t2, t3, t4, t5, t6, t7;
        t0 = key[0] & 0xff | (key[1] & 0xff) << 8;
        this.r[0] = t0 & 0x1fff;
        t1 = key[2] & 0xff | (key[3] & 0xff) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 0x1fff;
        t2 = key[4] & 0xff | (key[5] & 0xff) << 8;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 0x1f03;
        t3 = key[6] & 0xff | (key[7] & 0xff) << 8;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 0x1fff;
        t4 = key[8] & 0xff | (key[9] & 0xff) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 0x00ff;
        this.r[5] = t4 >>> 1 & 0x1ffe;
        t5 = key[10] & 0xff | (key[11] & 0xff) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 0x1fff;
        t6 = key[12] & 0xff | (key[13] & 0xff) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 0x1f81;
        t7 = key[14] & 0xff | (key[15] & 0xff) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 0x1fff;
        this.r[9] = t7 >>> 5 & 0x007f;
        this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;
        this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;
        this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;
        this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;
        this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;
        this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;
        this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;
        this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;
    };
    poly1305.prototype.blocks = function(m, mpos, bytes) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t2, t3, t4, t5, t6, t7, c;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while(bytes >= 16){
            t0 = m[mpos + 0] & 0xff | (m[mpos + 1] & 0xff) << 8;
            h0 += t0 & 0x1fff;
            t1 = m[mpos + 2] & 0xff | (m[mpos + 3] & 0xff) << 8;
            h1 += (t0 >>> 13 | t1 << 3) & 0x1fff;
            t2 = m[mpos + 4] & 0xff | (m[mpos + 5] & 0xff) << 8;
            h2 += (t1 >>> 10 | t2 << 6) & 0x1fff;
            t3 = m[mpos + 6] & 0xff | (m[mpos + 7] & 0xff) << 8;
            h3 += (t2 >>> 7 | t3 << 9) & 0x1fff;
            t4 = m[mpos + 8] & 0xff | (m[mpos + 9] & 0xff) << 8;
            h4 += (t3 >>> 4 | t4 << 12) & 0x1fff;
            h5 += t4 >>> 1 & 0x1fff;
            t5 = m[mpos + 10] & 0xff | (m[mpos + 11] & 0xff) << 8;
            h6 += (t4 >>> 14 | t5 << 2) & 0x1fff;
            t6 = m[mpos + 12] & 0xff | (m[mpos + 13] & 0xff) << 8;
            h7 += (t5 >>> 11 | t6 << 5) & 0x1fff;
            t7 = m[mpos + 14] & 0xff | (m[mpos + 15] & 0xff) << 8;
            h8 += (t6 >>> 8 | t7 << 8) & 0x1fff;
            h9 += t7 >>> 5 | hibit;
            c = 0;
            d0 = c;
            d0 += h0 * r0;
            d0 += h1 * (5 * r9);
            d0 += h2 * (5 * r8);
            d0 += h3 * (5 * r7);
            d0 += h4 * (5 * r6);
            c = d0 >>> 13;
            d0 &= 0x1fff;
            d0 += h5 * (5 * r5);
            d0 += h6 * (5 * r4);
            d0 += h7 * (5 * r3);
            d0 += h8 * (5 * r2);
            d0 += h9 * (5 * r1);
            c += d0 >>> 13;
            d0 &= 0x1fff;
            d1 = c;
            d1 += h0 * r1;
            d1 += h1 * r0;
            d1 += h2 * (5 * r9);
            d1 += h3 * (5 * r8);
            d1 += h4 * (5 * r7);
            c = d1 >>> 13;
            d1 &= 0x1fff;
            d1 += h5 * (5 * r6);
            d1 += h6 * (5 * r5);
            d1 += h7 * (5 * r4);
            d1 += h8 * (5 * r3);
            d1 += h9 * (5 * r2);
            c += d1 >>> 13;
            d1 &= 0x1fff;
            d2 = c;
            d2 += h0 * r2;
            d2 += h1 * r1;
            d2 += h2 * r0;
            d2 += h3 * (5 * r9);
            d2 += h4 * (5 * r8);
            c = d2 >>> 13;
            d2 &= 0x1fff;
            d2 += h5 * (5 * r7);
            d2 += h6 * (5 * r6);
            d2 += h7 * (5 * r5);
            d2 += h8 * (5 * r4);
            d2 += h9 * (5 * r3);
            c += d2 >>> 13;
            d2 &= 0x1fff;
            d3 = c;
            d3 += h0 * r3;
            d3 += h1 * r2;
            d3 += h2 * r1;
            d3 += h3 * r0;
            d3 += h4 * (5 * r9);
            c = d3 >>> 13;
            d3 &= 0x1fff;
            d3 += h5 * (5 * r8);
            d3 += h6 * (5 * r7);
            d3 += h7 * (5 * r6);
            d3 += h8 * (5 * r5);
            d3 += h9 * (5 * r4);
            c += d3 >>> 13;
            d3 &= 0x1fff;
            d4 = c;
            d4 += h0 * r4;
            d4 += h1 * r3;
            d4 += h2 * r2;
            d4 += h3 * r1;
            d4 += h4 * r0;
            c = d4 >>> 13;
            d4 &= 0x1fff;
            d4 += h5 * (5 * r9);
            d4 += h6 * (5 * r8);
            d4 += h7 * (5 * r7);
            d4 += h8 * (5 * r6);
            d4 += h9 * (5 * r5);
            c += d4 >>> 13;
            d4 &= 0x1fff;
            d5 = c;
            d5 += h0 * r5;
            d5 += h1 * r4;
            d5 += h2 * r3;
            d5 += h3 * r2;
            d5 += h4 * r1;
            c = d5 >>> 13;
            d5 &= 0x1fff;
            d5 += h5 * r0;
            d5 += h6 * (5 * r9);
            d5 += h7 * (5 * r8);
            d5 += h8 * (5 * r7);
            d5 += h9 * (5 * r6);
            c += d5 >>> 13;
            d5 &= 0x1fff;
            d6 = c;
            d6 += h0 * r6;
            d6 += h1 * r5;
            d6 += h2 * r4;
            d6 += h3 * r3;
            d6 += h4 * r2;
            c = d6 >>> 13;
            d6 &= 0x1fff;
            d6 += h5 * r1;
            d6 += h6 * r0;
            d6 += h7 * (5 * r9);
            d6 += h8 * (5 * r8);
            d6 += h9 * (5 * r7);
            c += d6 >>> 13;
            d6 &= 0x1fff;
            d7 = c;
            d7 += h0 * r7;
            d7 += h1 * r6;
            d7 += h2 * r5;
            d7 += h3 * r4;
            d7 += h4 * r3;
            c = d7 >>> 13;
            d7 &= 0x1fff;
            d7 += h5 * r2;
            d7 += h6 * r1;
            d7 += h7 * r0;
            d7 += h8 * (5 * r9);
            d7 += h9 * (5 * r8);
            c += d7 >>> 13;
            d7 &= 0x1fff;
            d8 = c;
            d8 += h0 * r8;
            d8 += h1 * r7;
            d8 += h2 * r6;
            d8 += h3 * r5;
            d8 += h4 * r4;
            c = d8 >>> 13;
            d8 &= 0x1fff;
            d8 += h5 * r3;
            d8 += h6 * r2;
            d8 += h7 * r1;
            d8 += h8 * r0;
            d8 += h9 * (5 * r9);
            c += d8 >>> 13;
            d8 &= 0x1fff;
            d9 = c;
            d9 += h0 * r9;
            d9 += h1 * r8;
            d9 += h2 * r7;
            d9 += h3 * r6;
            d9 += h4 * r5;
            c = d9 >>> 13;
            d9 &= 0x1fff;
            d9 += h5 * r4;
            d9 += h6 * r3;
            d9 += h7 * r2;
            d9 += h8 * r1;
            d9 += h9 * r0;
            c += d9 >>> 13;
            d9 &= 0x1fff;
            c = (c << 2) + c | 0;
            c = c + d0 | 0;
            d0 = c & 0x1fff;
            c = c >>> 13;
            d1 += c;
            h0 = d0;
            h1 = d1;
            h2 = d2;
            h3 = d3;
            h4 = d4;
            h5 = d5;
            h6 = d6;
            h7 = d7;
            h8 = d8;
            h9 = d9;
            mpos += 16;
            bytes -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
    };
    poly1305.prototype.finish = function(mac, macpos) {
        var g = new Uint16Array(10);
        var c, mask, f, i;
        if (this.leftover) {
            i = this.leftover;
            this.buffer[i++] = 1;
            for(; i < 16; i++)this.buffer[i] = 0;
            this.fin = 1;
            this.blocks(this.buffer, 0, 16);
        }
        c = this.h[1] >>> 13;
        this.h[1] &= 0x1fff;
        for(i = 2; i < 10; i++){
            this.h[i] += c;
            c = this.h[i] >>> 13;
            this.h[i] &= 0x1fff;
        }
        this.h[0] += c * 5;
        c = this.h[0] >>> 13;
        this.h[0] &= 0x1fff;
        this.h[1] += c;
        c = this.h[1] >>> 13;
        this.h[1] &= 0x1fff;
        this.h[2] += c;
        g[0] = this.h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 0x1fff;
        for(i = 1; i < 10; i++){
            g[i] = this.h[i] + c;
            c = g[i] >>> 13;
            g[i] &= 0x1fff;
        }
        g[9] -= 1 << 13;
        mask = (c ^ 1) - 1;
        for(i = 0; i < 10; i++)g[i] &= mask;
        mask = ~mask;
        for(i = 0; i < 10; i++)this.h[i] = this.h[i] & mask | g[i];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 0xffff;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 0xffff;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 0xffff;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 0xffff;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 0xffff;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 0xffff;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 0xffff;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 0xffff;
        f = this.h[0] + this.pad[0];
        this.h[0] = f & 0xffff;
        for(i = 1; i < 8; i++){
            f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
            this.h[i] = f & 0xffff;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 0xff;
        mac[macpos + 1] = this.h[0] >>> 8 & 0xff;
        mac[macpos + 2] = this.h[1] >>> 0 & 0xff;
        mac[macpos + 3] = this.h[1] >>> 8 & 0xff;
        mac[macpos + 4] = this.h[2] >>> 0 & 0xff;
        mac[macpos + 5] = this.h[2] >>> 8 & 0xff;
        mac[macpos + 6] = this.h[3] >>> 0 & 0xff;
        mac[macpos + 7] = this.h[3] >>> 8 & 0xff;
        mac[macpos + 8] = this.h[4] >>> 0 & 0xff;
        mac[macpos + 9] = this.h[4] >>> 8 & 0xff;
        mac[macpos + 10] = this.h[5] >>> 0 & 0xff;
        mac[macpos + 11] = this.h[5] >>> 8 & 0xff;
        mac[macpos + 12] = this.h[6] >>> 0 & 0xff;
        mac[macpos + 13] = this.h[6] >>> 8 & 0xff;
        mac[macpos + 14] = this.h[7] >>> 0 & 0xff;
        mac[macpos + 15] = this.h[7] >>> 8 & 0xff;
    };
    poly1305.prototype.update = function(m, mpos, bytes) {
        var i, want;
        if (this.leftover) {
            want = 16 - this.leftover;
            if (want > bytes) want = bytes;
            for(i = 0; i < want; i++)this.buffer[this.leftover + i] = m[mpos + i];
            bytes -= want;
            mpos += want;
            this.leftover += want;
            if (this.leftover < 16) return;
            this.blocks(this.buffer, 0, 16);
            this.leftover = 0;
        }
        if (bytes >= 16) {
            want = bytes - bytes % 16;
            this.blocks(m, mpos, want);
            mpos += want;
            bytes -= want;
        }
        if (bytes) {
            for(i = 0; i < bytes; i++)this.buffer[this.leftover + i] = m[mpos + i];
            this.leftover += bytes;
        }
    };
    function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
        var s = new poly1305(k);
        s.update(m, mpos, n);
        s.finish(out, outpos);
        return 0;
    }
    function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
        var x = new Uint8Array(16);
        crypto_onetimeauth(x, 0, m, mpos, n, k);
        return crypto_verify_16(h, hpos, x, 0);
    }
    function crypto_secretbox(c, m, d, n, k) {
        var i;
        if (d < 32) return -1;
        crypto_stream_xor(c, 0, m, 0, d, n, k);
        crypto_onetimeauth(c, 16, c, 32, d - 32, c);
        for(i = 0; i < 16; i++)c[i] = 0;
        return 0;
    }
    function crypto_secretbox_open(m, c, d, n, k) {
        var i;
        var x = new Uint8Array(32);
        if (d < 32) return -1;
        crypto_stream(x, 0, 32, n, k);
        if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0) return -1;
        crypto_stream_xor(m, 0, c, 0, d, n, k);
        for(i = 0; i < 32; i++)m[i] = 0;
        return 0;
    }
    function set25519(r, a) {
        var i;
        for(i = 0; i < 16; i++)r[i] = a[i] | 0;
    }
    function car25519(o) {
        var i, v, c = 1;
        for(i = 0; i < 16; i++){
            v = o[i] + c + 65535;
            c = Math.floor(v / 65536);
            o[i] = v - c * 65536;
        }
        o[0] += c - 1 + 37 * (c - 1);
    }
    function sel25519(p, q, b) {
        var t, c = ~(b - 1);
        for(var i = 0; i < 16; i++){
            t = c & (p[i] ^ q[i]);
            p[i] ^= t;
            q[i] ^= t;
        }
    }
    function pack25519(o, n) {
        var i, j, b;
        var m = gf(), t = gf();
        for(i = 0; i < 16; i++)t[i] = n[i];
        car25519(t);
        car25519(t);
        car25519(t);
        for(j = 0; j < 2; j++){
            m[0] = t[0] - 0xffed;
            for(i = 1; i < 15; i++){
                m[i] = t[i] - 0xffff - (m[i - 1] >> 16 & 1);
                m[i - 1] &= 0xffff;
            }
            m[15] = t[15] - 0x7fff - (m[14] >> 16 & 1);
            b = m[15] >> 16 & 1;
            m[14] &= 0xffff;
            sel25519(t, m, 1 - b);
        }
        for(i = 0; i < 16; i++){
            o[2 * i] = t[i] & 0xff;
            o[2 * i + 1] = t[i] >> 8;
        }
    }
    function neq25519(a, b) {
        var c = new Uint8Array(32), d = new Uint8Array(32);
        pack25519(c, a);
        pack25519(d, b);
        return crypto_verify_32(c, 0, d, 0);
    }
    function par25519(a) {
        var d = new Uint8Array(32);
        pack25519(d, a);
        return d[0] & 1;
    }
    function unpack25519(o, n) {
        var i;
        for(i = 0; i < 16; i++)o[i] = n[2 * i] + (n[2 * i + 1] << 8);
        o[15] &= 0x7fff;
    }
    function A(o, a, b) {
        for(var i = 0; i < 16; i++)o[i] = a[i] + b[i];
    }
    function Z(o, a, b) {
        for(var i = 0; i < 16; i++)o[i] = a[i] - b[i];
    }
    function M(o, a, b) {
        var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
        v = a[0];
        t0 += v * b0;
        t1 += v * b1;
        t2 += v * b2;
        t3 += v * b3;
        t4 += v * b4;
        t5 += v * b5;
        t6 += v * b6;
        t7 += v * b7;
        t8 += v * b8;
        t9 += v * b9;
        t10 += v * b10;
        t11 += v * b11;
        t12 += v * b12;
        t13 += v * b13;
        t14 += v * b14;
        t15 += v * b15;
        v = a[1];
        t1 += v * b0;
        t2 += v * b1;
        t3 += v * b2;
        t4 += v * b3;
        t5 += v * b4;
        t6 += v * b5;
        t7 += v * b6;
        t8 += v * b7;
        t9 += v * b8;
        t10 += v * b9;
        t11 += v * b10;
        t12 += v * b11;
        t13 += v * b12;
        t14 += v * b13;
        t15 += v * b14;
        t16 += v * b15;
        v = a[2];
        t2 += v * b0;
        t3 += v * b1;
        t4 += v * b2;
        t5 += v * b3;
        t6 += v * b4;
        t7 += v * b5;
        t8 += v * b6;
        t9 += v * b7;
        t10 += v * b8;
        t11 += v * b9;
        t12 += v * b10;
        t13 += v * b11;
        t14 += v * b12;
        t15 += v * b13;
        t16 += v * b14;
        t17 += v * b15;
        v = a[3];
        t3 += v * b0;
        t4 += v * b1;
        t5 += v * b2;
        t6 += v * b3;
        t7 += v * b4;
        t8 += v * b5;
        t9 += v * b6;
        t10 += v * b7;
        t11 += v * b8;
        t12 += v * b9;
        t13 += v * b10;
        t14 += v * b11;
        t15 += v * b12;
        t16 += v * b13;
        t17 += v * b14;
        t18 += v * b15;
        v = a[4];
        t4 += v * b0;
        t5 += v * b1;
        t6 += v * b2;
        t7 += v * b3;
        t8 += v * b4;
        t9 += v * b5;
        t10 += v * b6;
        t11 += v * b7;
        t12 += v * b8;
        t13 += v * b9;
        t14 += v * b10;
        t15 += v * b11;
        t16 += v * b12;
        t17 += v * b13;
        t18 += v * b14;
        t19 += v * b15;
        v = a[5];
        t5 += v * b0;
        t6 += v * b1;
        t7 += v * b2;
        t8 += v * b3;
        t9 += v * b4;
        t10 += v * b5;
        t11 += v * b6;
        t12 += v * b7;
        t13 += v * b8;
        t14 += v * b9;
        t15 += v * b10;
        t16 += v * b11;
        t17 += v * b12;
        t18 += v * b13;
        t19 += v * b14;
        t20 += v * b15;
        v = a[6];
        t6 += v * b0;
        t7 += v * b1;
        t8 += v * b2;
        t9 += v * b3;
        t10 += v * b4;
        t11 += v * b5;
        t12 += v * b6;
        t13 += v * b7;
        t14 += v * b8;
        t15 += v * b9;
        t16 += v * b10;
        t17 += v * b11;
        t18 += v * b12;
        t19 += v * b13;
        t20 += v * b14;
        t21 += v * b15;
        v = a[7];
        t7 += v * b0;
        t8 += v * b1;
        t9 += v * b2;
        t10 += v * b3;
        t11 += v * b4;
        t12 += v * b5;
        t13 += v * b6;
        t14 += v * b7;
        t15 += v * b8;
        t16 += v * b9;
        t17 += v * b10;
        t18 += v * b11;
        t19 += v * b12;
        t20 += v * b13;
        t21 += v * b14;
        t22 += v * b15;
        v = a[8];
        t8 += v * b0;
        t9 += v * b1;
        t10 += v * b2;
        t11 += v * b3;
        t12 += v * b4;
        t13 += v * b5;
        t14 += v * b6;
        t15 += v * b7;
        t16 += v * b8;
        t17 += v * b9;
        t18 += v * b10;
        t19 += v * b11;
        t20 += v * b12;
        t21 += v * b13;
        t22 += v * b14;
        t23 += v * b15;
        v = a[9];
        t9 += v * b0;
        t10 += v * b1;
        t11 += v * b2;
        t12 += v * b3;
        t13 += v * b4;
        t14 += v * b5;
        t15 += v * b6;
        t16 += v * b7;
        t17 += v * b8;
        t18 += v * b9;
        t19 += v * b10;
        t20 += v * b11;
        t21 += v * b12;
        t22 += v * b13;
        t23 += v * b14;
        t24 += v * b15;
        v = a[10];
        t10 += v * b0;
        t11 += v * b1;
        t12 += v * b2;
        t13 += v * b3;
        t14 += v * b4;
        t15 += v * b5;
        t16 += v * b6;
        t17 += v * b7;
        t18 += v * b8;
        t19 += v * b9;
        t20 += v * b10;
        t21 += v * b11;
        t22 += v * b12;
        t23 += v * b13;
        t24 += v * b14;
        t25 += v * b15;
        v = a[11];
        t11 += v * b0;
        t12 += v * b1;
        t13 += v * b2;
        t14 += v * b3;
        t15 += v * b4;
        t16 += v * b5;
        t17 += v * b6;
        t18 += v * b7;
        t19 += v * b8;
        t20 += v * b9;
        t21 += v * b10;
        t22 += v * b11;
        t23 += v * b12;
        t24 += v * b13;
        t25 += v * b14;
        t26 += v * b15;
        v = a[12];
        t12 += v * b0;
        t13 += v * b1;
        t14 += v * b2;
        t15 += v * b3;
        t16 += v * b4;
        t17 += v * b5;
        t18 += v * b6;
        t19 += v * b7;
        t20 += v * b8;
        t21 += v * b9;
        t22 += v * b10;
        t23 += v * b11;
        t24 += v * b12;
        t25 += v * b13;
        t26 += v * b14;
        t27 += v * b15;
        v = a[13];
        t13 += v * b0;
        t14 += v * b1;
        t15 += v * b2;
        t16 += v * b3;
        t17 += v * b4;
        t18 += v * b5;
        t19 += v * b6;
        t20 += v * b7;
        t21 += v * b8;
        t22 += v * b9;
        t23 += v * b10;
        t24 += v * b11;
        t25 += v * b12;
        t26 += v * b13;
        t27 += v * b14;
        t28 += v * b15;
        v = a[14];
        t14 += v * b0;
        t15 += v * b1;
        t16 += v * b2;
        t17 += v * b3;
        t18 += v * b4;
        t19 += v * b5;
        t20 += v * b6;
        t21 += v * b7;
        t22 += v * b8;
        t23 += v * b9;
        t24 += v * b10;
        t25 += v * b11;
        t26 += v * b12;
        t27 += v * b13;
        t28 += v * b14;
        t29 += v * b15;
        v = a[15];
        t15 += v * b0;
        t16 += v * b1;
        t17 += v * b2;
        t18 += v * b3;
        t19 += v * b4;
        t20 += v * b5;
        t21 += v * b6;
        t22 += v * b7;
        t23 += v * b8;
        t24 += v * b9;
        t25 += v * b10;
        t26 += v * b11;
        t27 += v * b12;
        t28 += v * b13;
        t29 += v * b14;
        t30 += v * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        // t15 left as is
        // first car
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        // second car
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        o[0] = t0;
        o[1] = t1;
        o[2] = t2;
        o[3] = t3;
        o[4] = t4;
        o[5] = t5;
        o[6] = t6;
        o[7] = t7;
        o[8] = t8;
        o[9] = t9;
        o[10] = t10;
        o[11] = t11;
        o[12] = t12;
        o[13] = t13;
        o[14] = t14;
        o[15] = t15;
    }
    function S(o, a) {
        M(o, a, a);
    }
    function inv25519(o, i) {
        var c = gf();
        var a;
        for(a = 0; a < 16; a++)c[a] = i[a];
        for(a = 253; a >= 0; a--){
            S(c, c);
            if (a !== 2 && a !== 4) M(c, c, i);
        }
        for(a = 0; a < 16; a++)o[a] = c[a];
    }
    function pow2523(o, i) {
        var c = gf();
        var a;
        for(a = 0; a < 16; a++)c[a] = i[a];
        for(a = 250; a >= 0; a--){
            S(c, c);
            if (a !== 1) M(c, c, i);
        }
        for(a = 0; a < 16; a++)o[a] = c[a];
    }
    function crypto_scalarmult(q, n, p) {
        var z = new Uint8Array(32);
        var x = new Float64Array(80), r, i;
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
        for(i = 0; i < 31; i++)z[i] = n[i];
        z[31] = n[31] & 127 | 64;
        z[0] &= 248;
        unpack25519(x, p);
        for(i = 0; i < 16; i++){
            b[i] = x[i];
            d[i] = a[i] = c[i] = 0;
        }
        a[0] = d[0] = 1;
        for(i = 254; i >= 0; --i){
            r = z[i >>> 3] >>> (i & 7) & 1;
            sel25519(a, b, r);
            sel25519(c, d, r);
            A(e, a, c);
            Z(a, a, c);
            A(c, b, d);
            Z(b, b, d);
            S(d, e);
            S(f, a);
            M(a, c, a);
            M(c, b, e);
            A(e, a, c);
            Z(a, a, c);
            S(b, a);
            Z(c, d, f);
            M(a, c, _121665);
            A(a, a, d);
            M(c, c, a);
            M(a, d, f);
            M(d, b, x);
            S(b, e);
            sel25519(a, b, r);
            sel25519(c, d, r);
        }
        for(i = 0; i < 16; i++){
            x[i + 16] = a[i];
            x[i + 32] = c[i];
            x[i + 48] = b[i];
            x[i + 64] = d[i];
        }
        var x32 = x.subarray(32);
        var x16 = x.subarray(16);
        inv25519(x32, x32);
        M(x16, x16, x32);
        pack25519(q, x16);
        return 0;
    }
    function crypto_scalarmult_base(q, n) {
        return crypto_scalarmult(q, n, _9);
    }
    function crypto_box_keypair(y, x) {
        randombytes(x, 32);
        return crypto_scalarmult_base(y, x);
    }
    function crypto_box_beforenm(k, y, x) {
        var s = new Uint8Array(32);
        crypto_scalarmult(s, x, y);
        return crypto_core_hsalsa20(k, _0, s, sigma);
    }
    var crypto_box_afternm = crypto_secretbox;
    var crypto_box_open_afternm = crypto_secretbox_open;
    function crypto_box(c, m, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_afternm(c, m, d, n, k);
    }
    function crypto_box_open(m, c, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_open_afternm(m, c, d, n, k);
    }
    var K = [
        0x428a2f98,
        0xd728ae22,
        0x71374491,
        0x23ef65cd,
        0xb5c0fbcf,
        0xec4d3b2f,
        0xe9b5dba5,
        0x8189dbbc,
        0x3956c25b,
        0xf348b538,
        0x59f111f1,
        0xb605d019,
        0x923f82a4,
        0xaf194f9b,
        0xab1c5ed5,
        0xda6d8118,
        0xd807aa98,
        0xa3030242,
        0x12835b01,
        0x45706fbe,
        0x243185be,
        0x4ee4b28c,
        0x550c7dc3,
        0xd5ffb4e2,
        0x72be5d74,
        0xf27b896f,
        0x80deb1fe,
        0x3b1696b1,
        0x9bdc06a7,
        0x25c71235,
        0xc19bf174,
        0xcf692694,
        0xe49b69c1,
        0x9ef14ad2,
        0xefbe4786,
        0x384f25e3,
        0x0fc19dc6,
        0x8b8cd5b5,
        0x240ca1cc,
        0x77ac9c65,
        0x2de92c6f,
        0x592b0275,
        0x4a7484aa,
        0x6ea6e483,
        0x5cb0a9dc,
        0xbd41fbd4,
        0x76f988da,
        0x831153b5,
        0x983e5152,
        0xee66dfab,
        0xa831c66d,
        0x2db43210,
        0xb00327c8,
        0x98fb213f,
        0xbf597fc7,
        0xbeef0ee4,
        0xc6e00bf3,
        0x3da88fc2,
        0xd5a79147,
        0x930aa725,
        0x06ca6351,
        0xe003826f,
        0x14292967,
        0x0a0e6e70,
        0x27b70a85,
        0x46d22ffc,
        0x2e1b2138,
        0x5c26c926,
        0x4d2c6dfc,
        0x5ac42aed,
        0x53380d13,
        0x9d95b3df,
        0x650a7354,
        0x8baf63de,
        0x766a0abb,
        0x3c77b2a8,
        0x81c2c92e,
        0x47edaee6,
        0x92722c85,
        0x1482353b,
        0xa2bfe8a1,
        0x4cf10364,
        0xa81a664b,
        0xbc423001,
        0xc24b8b70,
        0xd0f89791,
        0xc76c51a3,
        0x0654be30,
        0xd192e819,
        0xd6ef5218,
        0xd6990624,
        0x5565a910,
        0xf40e3585,
        0x5771202a,
        0x106aa070,
        0x32bbd1b8,
        0x19a4c116,
        0xb8d2d0c8,
        0x1e376c08,
        0x5141ab53,
        0x2748774c,
        0xdf8eeb99,
        0x34b0bcb5,
        0xe19b48a8,
        0x391c0cb3,
        0xc5c95a63,
        0x4ed8aa4a,
        0xe3418acb,
        0x5b9cca4f,
        0x7763e373,
        0x682e6ff3,
        0xd6b2b8a3,
        0x748f82ee,
        0x5defb2fc,
        0x78a5636f,
        0x43172f60,
        0x84c87814,
        0xa1f0ab72,
        0x8cc70208,
        0x1a6439ec,
        0x90befffa,
        0x23631e28,
        0xa4506ceb,
        0xde82bde9,
        0xbef9a3f7,
        0xb2c67915,
        0xc67178f2,
        0xe372532b,
        0xca273ece,
        0xea26619c,
        0xd186b8c7,
        0x21c0c207,
        0xeada7dd6,
        0xcde0eb1e,
        0xf57d4f7f,
        0xee6ed178,
        0x06f067aa,
        0x72176fba,
        0x0a637dc5,
        0xa2c898a6,
        0x113f9804,
        0xbef90dae,
        0x1b710b35,
        0x131c471b,
        0x28db77f5,
        0x23047d84,
        0x32caab7b,
        0x40c72493,
        0x3c9ebe0a,
        0x15c9bebc,
        0x431d67c4,
        0x9c100d4c,
        0x4cc5d4be,
        0xcb3e42b6,
        0x597f299c,
        0xfc657e2a,
        0x5fcb6fab,
        0x3ad6faec,
        0x6c44198c,
        0x4a475817
    ];
    function crypto_hashblocks_hl(hh, hl, m, n) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while(n >= 128){
            for(i = 0; i < 16; i++){
                j = 8 * i + pos;
                wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
                wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
            }
            for(i = 0; i < 80; i++){
                bh0 = ah0;
                bh1 = ah1;
                bh2 = ah2;
                bh3 = ah3;
                bh4 = ah4;
                bh5 = ah5;
                bh6 = ah6;
                bh7 = ah7;
                bl0 = al0;
                bl1 = al1;
                bl2 = al2;
                bl3 = al3;
                bl4 = al4;
                bl5 = al5;
                bl6 = al6;
                bl7 = al7;
                // add
                h = ah7;
                l = al7;
                a = l & 0xffff;
                b = l >>> 16;
                c = h & 0xffff;
                d = h >>> 16;
                // Sigma1
                h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
                l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
                a += l & 0xffff;
                b += l >>> 16;
                c += h & 0xffff;
                d += h >>> 16;
                // Ch
                h = ah4 & ah5 ^ ~ah4 & ah6;
                l = al4 & al5 ^ ~al4 & al6;
                a += l & 0xffff;
                b += l >>> 16;
                c += h & 0xffff;
                d += h >>> 16;
                // K
                h = K[i * 2];
                l = K[i * 2 + 1];
                a += l & 0xffff;
                b += l >>> 16;
                c += h & 0xffff;
                d += h >>> 16;
                // w
                h = wh[i % 16];
                l = wl[i % 16];
                a += l & 0xffff;
                b += l >>> 16;
                c += h & 0xffff;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                th = c & 0xffff | d << 16;
                tl = a & 0xffff | b << 16;
                // add
                h = th;
                l = tl;
                a = l & 0xffff;
                b = l >>> 16;
                c = h & 0xffff;
                d = h >>> 16;
                // Sigma0
                h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
                l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
                a += l & 0xffff;
                b += l >>> 16;
                c += h & 0xffff;
                d += h >>> 16;
                // Maj
                h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
                l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
                a += l & 0xffff;
                b += l >>> 16;
                c += h & 0xffff;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                bh7 = c & 0xffff | d << 16;
                bl7 = a & 0xffff | b << 16;
                // add
                h = bh3;
                l = bl3;
                a = l & 0xffff;
                b = l >>> 16;
                c = h & 0xffff;
                d = h >>> 16;
                h = th;
                l = tl;
                a += l & 0xffff;
                b += l >>> 16;
                c += h & 0xffff;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                bh3 = c & 0xffff | d << 16;
                bl3 = a & 0xffff | b << 16;
                ah1 = bh0;
                ah2 = bh1;
                ah3 = bh2;
                ah4 = bh3;
                ah5 = bh4;
                ah6 = bh5;
                ah7 = bh6;
                ah0 = bh7;
                al1 = bl0;
                al2 = bl1;
                al3 = bl2;
                al4 = bl3;
                al5 = bl4;
                al6 = bl5;
                al7 = bl6;
                al0 = bl7;
                if (i % 16 === 15) {
                    for(j = 0; j < 16; j++){
                        // add
                        h = wh[j];
                        l = wl[j];
                        a = l & 0xffff;
                        b = l >>> 16;
                        c = h & 0xffff;
                        d = h >>> 16;
                        h = wh[(j + 9) % 16];
                        l = wl[(j + 9) % 16];
                        a += l & 0xffff;
                        b += l >>> 16;
                        c += h & 0xffff;
                        d += h >>> 16;
                        // sigma0
                        th = wh[(j + 1) % 16];
                        tl = wl[(j + 1) % 16];
                        h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                        l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                        a += l & 0xffff;
                        b += l >>> 16;
                        c += h & 0xffff;
                        d += h >>> 16;
                        // sigma1
                        th = wh[(j + 14) % 16];
                        tl = wl[(j + 14) % 16];
                        h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                        l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                        a += l & 0xffff;
                        b += l >>> 16;
                        c += h & 0xffff;
                        d += h >>> 16;
                        b += a >>> 16;
                        c += b >>> 16;
                        d += c >>> 16;
                        wh[j] = c & 0xffff | d << 16;
                        wl[j] = a & 0xffff | b << 16;
                    }
                }
            }
            // add
            h = ah0;
            l = al0;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            h = hh[0];
            l = hl[0];
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[0] = ah0 = c & 0xffff | d << 16;
            hl[0] = al0 = a & 0xffff | b << 16;
            h = ah1;
            l = al1;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            h = hh[1];
            l = hl[1];
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[1] = ah1 = c & 0xffff | d << 16;
            hl[1] = al1 = a & 0xffff | b << 16;
            h = ah2;
            l = al2;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            h = hh[2];
            l = hl[2];
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[2] = ah2 = c & 0xffff | d << 16;
            hl[2] = al2 = a & 0xffff | b << 16;
            h = ah3;
            l = al3;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            h = hh[3];
            l = hl[3];
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[3] = ah3 = c & 0xffff | d << 16;
            hl[3] = al3 = a & 0xffff | b << 16;
            h = ah4;
            l = al4;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            h = hh[4];
            l = hl[4];
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[4] = ah4 = c & 0xffff | d << 16;
            hl[4] = al4 = a & 0xffff | b << 16;
            h = ah5;
            l = al5;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            h = hh[5];
            l = hl[5];
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[5] = ah5 = c & 0xffff | d << 16;
            hl[5] = al5 = a & 0xffff | b << 16;
            h = ah6;
            l = al6;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            h = hh[6];
            l = hl[6];
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[6] = ah6 = c & 0xffff | d << 16;
            hl[6] = al6 = a & 0xffff | b << 16;
            h = ah7;
            l = al7;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            h = hh[7];
            l = hl[7];
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            hh[7] = ah7 = c & 0xffff | d << 16;
            hl[7] = al7 = a & 0xffff | b << 16;
            pos += 128;
            n -= 128;
        }
        return n;
    }
    function crypto_hash(out, m, n) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;
        hh[0] = 0x6a09e667;
        hh[1] = 0xbb67ae85;
        hh[2] = 0x3c6ef372;
        hh[3] = 0xa54ff53a;
        hh[4] = 0x510e527f;
        hh[5] = 0x9b05688c;
        hh[6] = 0x1f83d9ab;
        hh[7] = 0x5be0cd19;
        hl[0] = 0xf3bcc908;
        hl[1] = 0x84caa73b;
        hl[2] = 0xfe94f82b;
        hl[3] = 0x5f1d36f1;
        hl[4] = 0xade682d1;
        hl[5] = 0x2b3e6c1f;
        hl[6] = 0xfb41bd6b;
        hl[7] = 0x137e2179;
        crypto_hashblocks_hl(hh, hl, m, n);
        n %= 128;
        for(i = 0; i < n; i++)x[i] = m[b - n + i];
        x[n] = 128;
        n = 256 - 128 * (n < 112 ? 1 : 0);
        x[n - 9] = 0;
        ts64(x, n - 8, b / 0x20000000 | 0, b << 3);
        crypto_hashblocks_hl(hh, hl, x, n);
        for(i = 0; i < 8; i++)ts64(out, 8 * i, hh[i], hl[i]);
        return 0;
    }
    function add(p, q) {
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
        Z(a, p[1], p[0]);
        Z(t, q[1], q[0]);
        M(a, a, t);
        A(b, p[0], p[1]);
        A(t, q[0], q[1]);
        M(b, b, t);
        M(c, p[3], q[3]);
        M(c, c, D2);
        M(d, p[2], q[2]);
        A(d, d, d);
        Z(e, b, a);
        Z(f, d, c);
        A(g, d, c);
        A(h, b, a);
        M(p[0], e, f);
        M(p[1], h, g);
        M(p[2], g, f);
        M(p[3], e, h);
    }
    function cswap(p, q, b) {
        var i;
        for(i = 0; i < 4; i++){
            sel25519(p[i], q[i], b);
        }
    }
    function pack(r, p) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p[2]);
        M(tx, p[0], zi);
        M(ty, p[1], zi);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
    }
    function scalarmult(p, q, s) {
        var b, i;
        set25519(p[0], gf0);
        set25519(p[1], gf1);
        set25519(p[2], gf1);
        set25519(p[3], gf0);
        for(i = 255; i >= 0; --i){
            b = s[i / 8 | 0] >> (i & 7) & 1;
            cswap(p, q, b);
            add(q, p);
            add(p, p);
            cswap(p, q, b);
        }
    }
    function scalarbase(p, s) {
        var q = [
            gf(),
            gf(),
            gf(),
            gf()
        ];
        set25519(q[0], X);
        set25519(q[1], Y);
        set25519(q[2], gf1);
        M(q[3], X, Y);
        scalarmult(p, q, s);
    }
    function crypto_sign_keypair(pk, sk, seeded) {
        var d = new Uint8Array(64);
        var p = [
            gf(),
            gf(),
            gf(),
            gf()
        ];
        var i;
        if (!seeded) randombytes(sk, 32);
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p, d);
        pack(pk, p);
        for(i = 0; i < 32; i++)sk[i + 32] = pk[i];
        return 0;
    }
    var L = new Float64Array([
        0xed,
        0xd3,
        0xf5,
        0x5c,
        0x1a,
        0x63,
        0x12,
        0x58,
        0xd6,
        0x9c,
        0xf7,
        0xa2,
        0xde,
        0xf9,
        0xde,
        0x14,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0x10
    ]);
    function modL(r, x) {
        var carry, i, j, k;
        for(i = 63; i >= 32; --i){
            carry = 0;
            for(j = i - 32, k = i - 12; j < k; ++j){
                x[j] += carry - 16 * x[i] * L[j - (i - 32)];
                carry = Math.floor((x[j] + 128) / 256);
                x[j] -= carry * 256;
            }
            x[j] += carry;
            x[i] = 0;
        }
        carry = 0;
        for(j = 0; j < 32; j++){
            x[j] += carry - (x[31] >> 4) * L[j];
            carry = x[j] >> 8;
            x[j] &= 255;
        }
        for(j = 0; j < 32; j++)x[j] -= carry * L[j];
        for(i = 0; i < 32; i++){
            x[i + 1] += x[i] >> 8;
            r[i] = x[i] & 255;
        }
    }
    function reduce(r) {
        var x = new Float64Array(64), i;
        for(i = 0; i < 64; i++)x[i] = r[i];
        for(i = 0; i < 64; i++)r[i] = 0;
        modL(r, x);
    }
    // Note: difference from C - smlen returned, not passed as argument.
    function crypto_sign(sm, m, n, sk) {
        var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
        var i, j, x = new Float64Array(64);
        var p = [
            gf(),
            gf(),
            gf(),
            gf()
        ];
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n + 64;
        for(i = 0; i < n; i++)sm[64 + i] = m[i];
        for(i = 0; i < 32; i++)sm[32 + i] = d[32 + i];
        crypto_hash(r, sm.subarray(32), n + 32);
        reduce(r);
        scalarbase(p, r);
        pack(sm, p);
        for(i = 32; i < 64; i++)sm[i] = sk[i];
        crypto_hash(h, sm, n + 64);
        reduce(h);
        for(i = 0; i < 64; i++)x[i] = 0;
        for(i = 0; i < 32; i++)x[i] = r[i];
        for(i = 0; i < 32; i++){
            for(j = 0; j < 32; j++){
                x[i + j] += h[i] * d[j];
            }
        }
        modL(sm.subarray(32), x);
        return smlen;
    }
    function unpackneg(r, p) {
        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r[2], gf1);
        unpack25519(r[1], p);
        S(num, r[1]);
        M(den, num, D);
        Z(num, num, r[2]);
        A(den, r[2], den);
        S(den2, den);
        S(den4, den2);
        M(den6, den4, den2);
        M(t, den6, num);
        M(t, t, den);
        pow2523(t, t);
        M(t, t, num);
        M(t, t, den);
        M(t, t, den);
        M(r[0], t, den);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num)) M(r[0], r[0], I);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num)) return -1;
        if (par25519(r[0]) === p[31] >> 7) Z(r[0], gf0, r[0]);
        M(r[3], r[0], r[1]);
        return 0;
    }
    function crypto_sign_open(m, sm, n, pk) {
        var i;
        var t = new Uint8Array(32), h = new Uint8Array(64);
        var p = [
            gf(),
            gf(),
            gf(),
            gf()
        ], q = [
            gf(),
            gf(),
            gf(),
            gf()
        ];
        if (n < 64) return -1;
        if (unpackneg(q, pk)) return -1;
        for(i = 0; i < n; i++)m[i] = sm[i];
        for(i = 0; i < 32; i++)m[i + 32] = pk[i];
        crypto_hash(h, m, n);
        reduce(h);
        scalarmult(p, q, h);
        scalarbase(q, sm.subarray(32));
        add(p, q);
        pack(t, p);
        n -= 64;
        if (crypto_verify_32(sm, 0, t, 0)) {
            for(i = 0; i < n; i++)m[i] = 0;
            return -1;
        }
        for(i = 0; i < n; i++)m[i] = sm[i + 64];
        return n;
    }
    var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
    nacl.lowlevel = {
        crypto_core_hsalsa20: crypto_core_hsalsa20,
        crypto_stream_xor: crypto_stream_xor,
        crypto_stream: crypto_stream,
        crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,
        crypto_stream_salsa20: crypto_stream_salsa20,
        crypto_onetimeauth: crypto_onetimeauth,
        crypto_onetimeauth_verify: crypto_onetimeauth_verify,
        crypto_verify_16: crypto_verify_16,
        crypto_verify_32: crypto_verify_32,
        crypto_secretbox: crypto_secretbox,
        crypto_secretbox_open: crypto_secretbox_open,
        crypto_scalarmult: crypto_scalarmult,
        crypto_scalarmult_base: crypto_scalarmult_base,
        crypto_box_beforenm: crypto_box_beforenm,
        crypto_box_afternm: crypto_box_afternm,
        crypto_box: crypto_box,
        crypto_box_open: crypto_box_open,
        crypto_box_keypair: crypto_box_keypair,
        crypto_hash: crypto_hash,
        crypto_sign: crypto_sign,
        crypto_sign_keypair: crypto_sign_keypair,
        crypto_sign_open: crypto_sign_open,
        crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES: crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,
        crypto_hash_BYTES: crypto_hash_BYTES,
        gf: gf,
        D: D,
        L: L,
        pack25519: pack25519,
        unpack25519: unpack25519,
        M: M,
        A: A,
        S: S,
        Z: Z,
        pow2523: pow2523,
        add: add,
        set25519: set25519,
        modL: modL,
        scalarmult: scalarmult,
        scalarbase: scalarbase
    };
    /* High-level API */ function checkLengths(k, n) {
        if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');
        if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');
    }
    function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');
        if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
    }
    function checkArrayTypes() {
        for(var i = 0; i < arguments.length; i++){
            if (!(arguments[i] instanceof Uint8Array)) throw new TypeError('unexpected type, use Uint8Array');
        }
    }
    function cleanup(arr) {
        for(var i = 0; i < arr.length; i++)arr[i] = 0;
    }
    nacl.randomBytes = function(n) {
        var b = new Uint8Array(n);
        randombytes(b, n);
        return b;
    };
    nacl.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c = new Uint8Array(m.length);
        for(var i = 0; i < msg.length; i++)m[i + crypto_secretbox_ZEROBYTES] = msg[i];
        crypto_secretbox(c, m, m.length, nonce, key);
        return c.subarray(crypto_secretbox_BOXZEROBYTES);
    };
    nacl.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m = new Uint8Array(c.length);
        for(var i = 0; i < box.length; i++)c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
        if (c.length < 32) return null;
        if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;
        return m.subarray(crypto_secretbox_ZEROBYTES);
    };
    nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
    nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
    nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
    nacl.scalarMult = function(n, p) {
        checkArrayTypes(n, p);
        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
        if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q, n, p);
        return q;
    };
    nacl.scalarMult.base = function(n) {
        checkArrayTypes(n);
        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q, n);
        return q;
    };
    nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
    nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
    nacl.box = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox(msg, nonce, k);
    };
    nacl.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k, publicKey, secretKey);
        return k;
    };
    nacl.box.after = nacl.secretbox;
    nacl.box.open = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox.open(msg, nonce, k);
    };
    nacl.box.open.after = nacl.secretbox.open;
    nacl.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return {
            publicKey: pk,
            secretKey: sk
        };
    };
    nacl.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return {
            publicKey: pk,
            secretKey: new Uint8Array(secretKey)
        };
    };
    nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
    nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
    nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
    nacl.box.nonceLength = crypto_box_NONCEBYTES;
    nacl.box.overheadLength = nacl.secretbox.overheadLength;
    nacl.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES) throw new Error('bad secret key size');
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
    };
    nacl.sign.open = function(signedMsg, publicKey) {
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES) throw new Error('bad public key size');
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0) return null;
        var m = new Uint8Array(mlen);
        for(var i = 0; i < m.length; i++)m[i] = tmp[i];
        return m;
    };
    nacl.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for(var i = 0; i < sig.length; i++)sig[i] = signedMsg[i];
        return sig;
    };
    nacl.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES) throw new Error('bad signature size');
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES) throw new Error('bad public key size');
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i;
        for(i = 0; i < crypto_sign_BYTES; i++)sm[i] = sig[i];
        for(i = 0; i < msg.length; i++)sm[i + crypto_sign_BYTES] = msg[i];
        return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
    };
    nacl.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return {
            publicKey: pk,
            secretKey: sk
        };
    };
    nacl.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES) throw new Error('bad secret key size');
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for(var i = 0; i < pk.length; i++)pk[i] = secretKey[32 + i];
        return {
            publicKey: pk,
            secretKey: new Uint8Array(secretKey)
        };
    };
    nacl.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES) throw new Error('bad seed size');
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for(var i = 0; i < 32; i++)sk[i] = seed[i];
        crypto_sign_keypair(pk, sk, true);
        return {
            publicKey: pk,
            secretKey: sk
        };
    };
    nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
    nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
    nacl.sign.seedLength = crypto_sign_SEEDBYTES;
    nacl.sign.signatureLength = crypto_sign_BYTES;
    nacl.hash = function(msg) {
        checkArrayTypes(msg);
        var h = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h, msg, msg.length);
        return h;
    };
    nacl.hash.hashLength = crypto_hash_BYTES;
    nacl.verify = function(x, y) {
        checkArrayTypes(x, y);
        // Zero length arguments are considered not equal.
        if (x.length === 0 || y.length === 0) return false;
        if (x.length !== y.length) return false;
        return vn(x, 0, y, 0, x.length) === 0 ? true : false;
    };
    nacl.setPRNG = function(fn) {
        randombytes = fn;
    };
    (function() {
        // Initialize PRNG if environment provides CSPRNG.
        // If not, methods calling randombytes will throw.
        var crypto = typeof self !== 'undefined' ? self.crypto || self.msCrypto : null;
        if (crypto && crypto.getRandomValues) {
            // Browsers.
            var QUOTA = 65536;
            nacl.setPRNG(function(x, n) {
                var i, v = new Uint8Array(n);
                for(i = 0; i < n; i += QUOTA){
                    crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
                }
                for(i = 0; i < n; i++)x[i] = v[i];
                cleanup(v);
            });
        } else if ("TURBOPACK compile-time truthy", 1) {
            // Node.js.
            crypto = {};
            if (crypto && crypto.randomBytes) {
                nacl.setPRNG(function(x, n) {
                    var i, v = crypto.randomBytes(n);
                    for(i = 0; i < n; i++)x[i] = v[i];
                    cleanup(v);
                });
            }
        }
    })();
})(("TURBOPACK compile-time value", "object") !== 'undefined' && module.exports ? module.exports : self.nacl = self.nacl || {});
}),
"[project]/node_modules/tweetnacl-util/nacl-util.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

// Written in 2014-2016 by Dmitry Chestnykh and Devi Mandiri.
// Public domain.
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
(function(root, f) {
    'use strict';
    if (("TURBOPACK compile-time value", "object") !== 'undefined' && module.exports) module.exports = f();
    else if (root.nacl) root.nacl.util = f();
    else {
        root.nacl = {};
        root.nacl.util = f();
    }
})(/*TURBOPACK member replacement*/ __turbopack_context__.e, function() {
    'use strict';
    var util = {};
    function validateBase64(s) {
        if (!/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(s)) {
            throw new TypeError('invalid encoding');
        }
    }
    util.decodeUTF8 = function(s) {
        if (typeof s !== 'string') throw new TypeError('expected string');
        var i, d = unescape(encodeURIComponent(s)), b = new Uint8Array(d.length);
        for(i = 0; i < d.length; i++)b[i] = d.charCodeAt(i);
        return b;
    };
    util.encodeUTF8 = function(arr) {
        var i, s = [];
        for(i = 0; i < arr.length; i++)s.push(String.fromCharCode(arr[i]));
        return decodeURIComponent(escape(s.join('')));
    };
    if (typeof atob === 'undefined') {
        // Node.js
        if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from !== 'undefined') {
            // Node v6 and later
            util.encodeBase64 = function(arr) {
                return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(arr).toString('base64');
            };
            util.decodeBase64 = function(s) {
                validateBase64(s);
                return new Uint8Array(Array.prototype.slice.call(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(s, 'base64'), 0));
            };
        } else {
            // Node earlier than v6
            util.encodeBase64 = function(arr) {
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"](arr).toString('base64');
            };
            util.decodeBase64 = function(s) {
                validateBase64(s);
                return new Uint8Array(Array.prototype.slice.call(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"](s, 'base64'), 0));
            };
        }
    } else {
        // Browsers
        util.encodeBase64 = function(arr) {
            var i, s = [], len = arr.length;
            for(i = 0; i < len; i++)s.push(String.fromCharCode(arr[i]));
            return btoa(s.join(''));
        };
        util.decodeBase64 = function(s) {
            validateBase64(s);
            var i, d = atob(s), b = new Uint8Array(d.length);
            for(i = 0; i < d.length; i++)b[i] = d.charCodeAt(i);
            return b;
        };
    }
    return util;
});
}),
"[project]/node_modules/node-fetch/browser.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// ref: https://github.com/tc39/proposal-global
var getGlobal = function() {
    // the only reliable means to get the global object is
    // `Function('return this')()`
    // However, this causes CSP violations in Chrome apps.
    if (typeof self !== 'undefined') {
        return self;
    }
    if (typeof window !== 'undefined') {
        return window;
    }
    if ("TURBOPACK compile-time truthy", 1) {
        return /*TURBOPACK member replacement*/ __turbopack_context__.g;
    }
    //TURBOPACK unreachable
    ;
};
var globalObject = getGlobal();
module.exports = exports = globalObject.fetch;
// Needed for TypeScript and Webpack.
if (globalObject.fetch) {
    exports.default = globalObject.fetch.bind(globalObject);
}
exports.Headers = globalObject.Headers;
exports.Request = globalObject.Request;
exports.Response = globalObject.Response;
}),
"[project]/node_modules/it-batch/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Takes an (async) iterable that emits things and returns an async iterable that
 * emits those things in fixed-sized batches.
 *
 * @template T
 * @param {AsyncIterable<T>|Iterable<T>} source
 * @param {number} [size=1]
 * @returns {AsyncIterable<T[]>}
 */ async function* batch(source, size = 1) {
    /** @type {T[]} */ let things = [];
    if (size < 1) {
        size = 1;
    }
    for await (const thing of source){
        things.push(thing);
        while(things.length >= size){
            yield things.slice(0, size);
            things = things.slice(size);
        }
    }
    while(things.length){
        yield things.slice(0, size);
        things = things.slice(size);
    }
}
module.exports = batch;
}),
"[project]/node_modules/it-parallel-batch/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const batch = __turbopack_context__.r("[project]/node_modules/it-batch/index.js [app-client] (ecmascript)");
/**
 * @template T
 * @typedef {{ok:true, value:T}} Success
 */ /**
 * @typedef {{ok:false, err:Error}} Failure
 */ /**
 * Takes an (async) iterator that emits promise-returning functions,
 * invokes them in parallel and emits the results as they become available but
 * in the same order as the input
 *
 * @template T
 * @param {AsyncIterable<() => Promise<T>>|Iterable<() => Promise<T>>} source
 * @param {number} [size=1]
 * @returns {AsyncIterable<T>}
 */ async function* parallelBatch(source, size = 1) {
    for await (const tasks of batch(source, size)){
        /** @type {Promise<Success<T>|Failure>[]} */ const things = tasks.map(/**
       * @param {() => Promise<T>} p
       */ (p)=>{
            return p().then((value)=>({
                    ok: true,
                    value
                }), (err)=>({
                    ok: false,
                    err
                }));
        });
        for(let i = 0; i < things.length; i++){
            const result = await things[i];
            if (result.ok) {
                yield result.value;
            } else {
                throw result.err;
            }
        }
    }
}
module.exports = parallelBatch;
}),
"[project]/node_modules/is-plain-obj/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = (value)=>{
    if (Object.prototype.toString.call(value) !== '[object Object]') {
        return false;
    }
    const prototype = Object.getPrototypeOf(value);
    return prototype === null || prototype === Object.prototype;
};
}),
"[project]/node_modules/merge-options/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const isOptionObject = __turbopack_context__.r("[project]/node_modules/is-plain-obj/index.js [app-client] (ecmascript)");
const { hasOwnProperty } = Object.prototype;
const { propertyIsEnumerable } = Object;
const defineProperty = (object, name, value)=>Object.defineProperty(object, name, {
        value,
        writable: true,
        enumerable: true,
        configurable: true
    });
const globalThis = /*TURBOPACK member replacement*/ __turbopack_context__.e;
const defaultMergeOptions = {
    concatArrays: false,
    ignoreUndefined: false
};
const getEnumerableOwnPropertyKeys = (value)=>{
    const keys = [];
    for(const key in value){
        if (hasOwnProperty.call(value, key)) {
            keys.push(key);
        }
    }
    /* istanbul ignore else  */ if (Object.getOwnPropertySymbols) {
        const symbols = Object.getOwnPropertySymbols(value);
        for (const symbol of symbols){
            if (propertyIsEnumerable.call(value, symbol)) {
                keys.push(symbol);
            }
        }
    }
    return keys;
};
function clone(value) {
    if (Array.isArray(value)) {
        return cloneArray(value);
    }
    if (isOptionObject(value)) {
        return cloneOptionObject(value);
    }
    return value;
}
function cloneArray(array) {
    const result = array.slice(0, 0);
    getEnumerableOwnPropertyKeys(array).forEach((key)=>{
        defineProperty(result, key, clone(array[key]));
    });
    return result;
}
function cloneOptionObject(object) {
    const result = Object.getPrototypeOf(object) === null ? Object.create(null) : {};
    getEnumerableOwnPropertyKeys(object).forEach((key)=>{
        defineProperty(result, key, clone(object[key]));
    });
    return result;
}
/**
 * @param {*} merged already cloned
 * @param {*} source something to merge
 * @param {string[]} keys keys to merge
 * @param {Object} config Config Object
 * @returns {*} cloned Object
 */ const mergeKeys = (merged, source, keys, config)=>{
    keys.forEach((key)=>{
        if (typeof source[key] === 'undefined' && config.ignoreUndefined) {
            return;
        }
        // Do not recurse into prototype chain of merged
        if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {
            defineProperty(merged, key, merge(merged[key], source[key], config));
        } else {
            defineProperty(merged, key, clone(source[key]));
        }
    });
    return merged;
};
/**
 * @param {*} merged already cloned
 * @param {*} source something to merge
 * @param {Object} config Config Object
 * @returns {*} cloned Object
 *
 * see [Array.prototype.concat ( ...arguments )](http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat)
 */ const concatArrays = (merged, source, config)=>{
    let result = merged.slice(0, 0);
    let resultIndex = 0;
    [
        merged,
        source
    ].forEach((array)=>{
        const indices = [];
        // `result.concat(array)` with cloning
        for(let k = 0; k < array.length; k++){
            if (!hasOwnProperty.call(array, k)) {
                continue;
            }
            indices.push(String(k));
            if (array === merged) {
                // Already cloned
                defineProperty(result, resultIndex++, array[k]);
            } else {
                defineProperty(result, resultIndex++, clone(array[k]));
            }
        }
        // Merge non-index keys
        result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter((key)=>!indices.includes(key)), config);
    });
    return result;
};
/**
 * @param {*} merged already cloned
 * @param {*} source something to merge
 * @param {Object} config Config Object
 * @returns {*} cloned Object
 */ function merge(merged, source, config) {
    if (config.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
        return concatArrays(merged, source, config);
    }
    if (!isOptionObject(source) || !isOptionObject(merged)) {
        return clone(source);
    }
    return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config);
}
module.exports = function(...options) {
    const config = merge(clone(defaultMergeOptions), this !== globalThis && this || {}, defaultMergeOptions);
    let merged = {
        _: {}
    };
    for (const option of options){
        if (option === undefined) {
            continue;
        }
        if (!isOptionObject(option)) {
            throw new TypeError('`' + option + '` is not an Option Object');
        }
        merged = merge(merged, {
            _: option
        }, config);
    }
    return merged._;
};
}),
"[project]/node_modules/err-code/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * @typedef {{ [key: string]: any }} Extensions
 * @typedef {Error} Err
 * @property {string} message
 */ /**
 *
 * @param {Error} obj
 * @param {Extensions} props
 * @returns {Error & Extensions}
 */ function assign(obj, props) {
    for(const key in props){
        Object.defineProperty(obj, key, {
            value: props[key],
            enumerable: true,
            configurable: true
        });
    }
    return obj;
}
/**
 *
 * @param {any} err - An Error
 * @param {string|Extensions} code - A string code or props to set on the error
 * @param {Extensions} [props] - Props to set on the error
 * @returns {Error & Extensions}
 */ function createError(err, code, props) {
    if (!err || typeof err === 'string') {
        throw new TypeError('Please pass an Error to err-code');
    }
    if (!props) {
        props = {};
    }
    if (typeof code === 'object') {
        props = code;
        code = '';
    }
    if (code) {
        props.code = code;
    }
    try {
        return assign(err, props);
    } catch (_) {
        props.message = err.message;
        props.stack = err.stack;
        const ErrClass = function() {};
        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
        // @ts-ignore
        const output = assign(new ErrClass(), props);
        return output;
    }
}
module.exports = createError;
}),
"[project]/node_modules/@multiformats/base-x/src/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// base-x encoding / decoding
// Copyright (c) 2018 base-x contributors
// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
function base(ALPHABET) {
    if (ALPHABET.length >= 255) {
        throw new TypeError('Alphabet too long');
    }
    var BASE_MAP = new Uint8Array(256);
    for(var j = 0; j < BASE_MAP.length; j++){
        BASE_MAP[j] = 255;
    }
    for(var i = 0; i < ALPHABET.length; i++){
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
            throw new TypeError(x + ' is ambiguous');
        }
        BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up
    ;
    var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up
    ;
    function encode(source) {
        if (source instanceof Uint8Array) {} else if (ArrayBuffer.isView(source)) {
            source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
            source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
            throw new TypeError('Expected Uint8Array');
        }
        if (source.length === 0) {
            return '';
        }
        // Skip & count leading zeroes.
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while(pbegin !== pend && source[pbegin] === 0){
            pbegin++;
            zeroes++;
        }
        // Allocate enough space in big-endian base58 representation.
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        // Process the bytes.
        while(pbegin !== pend){
            var carry = source[pbegin];
            // Apply "b58 = b58 * 256 + ch".
            var i = 0;
            for(var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++){
                carry += 256 * b58[it1] >>> 0;
                b58[it1] = carry % BASE >>> 0;
                carry = carry / BASE >>> 0;
            }
            if (carry !== 0) {
                throw new Error('Non-zero carry');
            }
            length = i;
            pbegin++;
        }
        // Skip leading zeroes in base58 result.
        var it2 = size - length;
        while(it2 !== size && b58[it2] === 0){
            it2++;
        }
        // Translate the result into a string.
        var str = LEADER.repeat(zeroes);
        for(; it2 < size; ++it2){
            str += ALPHABET.charAt(b58[it2]);
        }
        return str;
    }
    function decodeUnsafe(source) {
        if (typeof source !== 'string') {
            throw new TypeError('Expected String');
        }
        if (source.length === 0) {
            return new Uint8Array();
        }
        var psz = 0;
        // Skip leading spaces.
        if (source[psz] === ' ') {
            return;
        }
        // Skip and count leading '1's.
        var zeroes = 0;
        var length = 0;
        while(source[psz] === LEADER){
            zeroes++;
            psz++;
        }
        // Allocate enough space in big-endian base256 representation.
        var size = (source.length - psz) * FACTOR + 1 >>> 0 // log(58) / log(256), rounded up.
        ;
        var b256 = new Uint8Array(size);
        // Process the characters.
        while(source[psz]){
            // Decode character
            var carry = BASE_MAP[source.charCodeAt(psz)];
            // Invalid character
            if (carry === 255) {
                return;
            }
            var i = 0;
            for(var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++){
                carry += BASE * b256[it3] >>> 0;
                b256[it3] = carry % 256 >>> 0;
                carry = carry / 256 >>> 0;
            }
            if (carry !== 0) {
                throw new Error('Non-zero carry');
            }
            length = i;
            psz++;
        }
        // Skip trailing spaces.
        if (source[psz] === ' ') {
            return;
        }
        // Skip leading zeroes in b256.
        var it4 = size - length;
        while(it4 !== size && b256[it4] === 0){
            it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j = zeroes;
        while(it4 !== size){
            vch[j++] = b256[it4++];
        }
        return vch;
    }
    function decode(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) {
            return buffer;
        }
        throw new Error('Non-base' + BASE + ' character');
    }
    return {
        encode: encode,
        decodeUnsafe: decodeUnsafe,
        decode: decode
    };
}
module.exports = base;
}),
"[project]/node_modules/@multiformats/murmur3/src/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "murmur3128",
    ()=>murmur3128,
    "murmur332",
    ()=>murmur332,
    "murmur364",
    ()=>murmur364
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$murmur3$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/murmur3/node_modules/multiformats/dist/src/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$murmur3$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__bytes$3e$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/murmur3/node_modules/multiformats/dist/src/bytes.js [app-client] (ecmascript) <export * as bytes>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$murmur3$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$hasher$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/murmur3/node_modules/multiformats/dist/src/hashes/hasher.js [app-client] (ecmascript)");
// @ts-expect-error no types
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$murmurhash3js$2d$revisited$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/murmurhash3js-revisited/index.js [app-client] (ecmascript)");
;
;
;
/**
 * @param {number} number
 * @returns {Uint8Array}
 */ function fromNumberTo32BitBuf(number) {
    const bytes = new Array(4);
    for(let i = 0; i < 4; i++){
        bytes[i] = number & 0xff;
        number = number >> 8;
    }
    return new Uint8Array(bytes);
}
const murmur332 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$murmur3$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$hasher$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"])({
    name: 'murmur3-32',
    code: 0x23,
    encode: (input)=>fromNumberTo32BitBuf(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$murmurhash3js$2d$revisited$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].x86.hash32(input))
});
const murmur3128 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$murmur3$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$hasher$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"])({
    name: 'murmur3-128',
    code: 0x22,
    encode: (input)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$murmur3$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__bytes$3e$__["bytes"].fromHex(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$murmurhash3js$2d$revisited$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].x64.hash128(input))
});
const murmur364 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$murmur3$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$hasher$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"])({
    name: 'murmur3-x64-64',
    code: 0x22,
    encode: (input)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$murmur3$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__bytes$3e$__["bytes"].fromHex(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$murmurhash3js$2d$revisited$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].x64.hash128(input)).subarray(0, 8)
});
}),
"[project]/node_modules/multibase/src/util.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const textDecoder = new TextDecoder();
/**
 * @param {ArrayBufferView|ArrayBuffer} bytes
 * @returns {string}
 */ const decodeText = (bytes)=>textDecoder.decode(bytes);
const textEncoder = new TextEncoder();
/**
 * @param {string} text
 * @returns {Uint8Array}
 */ const encodeText = (text)=>textEncoder.encode(text);
/**
 * Returns a new Uint8Array created by concatenating the passed Arrays
 *
 * @param {Array<ArrayLike<number>>} arrs
 * @param {number} length
 * @returns {Uint8Array}
 */ function concat(arrs, length) {
    const output = new Uint8Array(length);
    let offset = 0;
    for (const arr of arrs){
        output.set(arr, offset);
        offset += arr.length;
    }
    return output;
}
module.exports = {
    decodeText,
    encodeText,
    concat
};
}),
"[project]/node_modules/multibase/src/base.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { encodeText } = __turbopack_context__.r("[project]/node_modules/multibase/src/util.js [app-client] (ecmascript)");
/** @typedef {import('./types').CodecFactory} CodecFactory */ /** @typedef {import("./types").BaseName} BaseName */ /** @typedef {import("./types").BaseCode} BaseCode */ /**
 * Class to encode/decode in the supported Bases
 *
 */ class Base {
    /**
   * @param {BaseName} name
   * @param {BaseCode} code
   * @param {CodecFactory} factory
   * @param {string} alphabet
   */ constructor(name, code, factory, alphabet){
        this.name = name;
        this.code = code;
        this.codeBuf = encodeText(this.code);
        this.alphabet = alphabet;
        this.codec = factory(alphabet);
    }
    /**
   * @param {Uint8Array} buf
   * @returns {string}
   */ encode(buf) {
        return this.codec.encode(buf);
    }
    /**
   * @param {string} string
   * @returns {Uint8Array}
   */ decode(string) {
        for (const char of string){
            if (this.alphabet && this.alphabet.indexOf(char) < 0) {
                throw new Error(`invalid character '${char}' in '${string}'`);
            }
        }
        return this.codec.decode(string);
    }
}
module.exports = Base;
}),
"[project]/node_modules/multibase/src/rfc4648.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @typedef {import('./types').CodecFactory} CodecFactory */ /**
 * @param {string} string
 * @param {string} alphabet
 * @param {number} bitsPerChar
 * @returns {Uint8Array}
 */ const decode = (string, alphabet, bitsPerChar)=>{
    // Build the character lookup table:
    /** @type {Record<string, number>} */ const codes = {};
    for(let i = 0; i < alphabet.length; ++i){
        codes[alphabet[i]] = i;
    }
    // Count the padding bytes:
    let end = string.length;
    while(string[end - 1] === '='){
        --end;
    }
    // Allocate the output:
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    // Parse the data:
    let bits = 0 // Number of bits currently in the buffer
    ;
    let buffer = 0 // Bits waiting to be written out, MSB first
    ;
    let written = 0 // Next byte to write
    ;
    for(let i = 0; i < end; ++i){
        // Read one character from the string:
        const value = codes[string[i]];
        if (value === undefined) {
            throw new SyntaxError('Invalid character ' + string[i]);
        }
        // Append the bits to the buffer:
        buffer = buffer << bitsPerChar | value;
        bits += bitsPerChar;
        // Write out some bits if the buffer has a byte's worth:
        if (bits >= 8) {
            bits -= 8;
            out[written++] = 0xff & buffer >> bits;
        }
    }
    // Verify that we have received just enough bits:
    if (bits >= bitsPerChar || 0xff & buffer << 8 - bits) {
        throw new SyntaxError('Unexpected end of data');
    }
    return out;
};
/**
 * @param {Uint8Array} data
 * @param {string} alphabet
 * @param {number} bitsPerChar
 * @returns {string}
 */ const encode = (data, alphabet, bitsPerChar)=>{
    const pad = alphabet[alphabet.length - 1] === '=';
    const mask = (1 << bitsPerChar) - 1;
    let out = '';
    let bits = 0 // Number of bits currently in the buffer
    ;
    let buffer = 0 // Bits waiting to be written out, MSB first
    ;
    for(let i = 0; i < data.length; ++i){
        // Slurp data into the buffer:
        buffer = buffer << 8 | data[i];
        bits += 8;
        // Write out as much as we can:
        while(bits > bitsPerChar){
            bits -= bitsPerChar;
            out += alphabet[mask & buffer >> bits];
        }
    }
    // Partial character:
    if (bits) {
        out += alphabet[mask & buffer << bitsPerChar - bits];
    }
    // Add padding characters until we hit a byte boundary:
    if (pad) {
        while(out.length * bitsPerChar & 7){
            out += '=';
        }
    }
    return out;
};
/**
 * RFC4648 Factory
 *
 * @param {number} bitsPerChar
 * @returns {CodecFactory}
 */ const rfc4648 = (bitsPerChar)=>(alphabet)=>{
        return {
            /**
     * @param {Uint8Array} input
     * @returns {string}
     */ encode (input) {
                return encode(input, alphabet, bitsPerChar);
            },
            /**
     * @param {string} input
     * @returns {Uint8Array}
     */ decode (input) {
                return decode(input, alphabet, bitsPerChar);
            }
        };
    };
module.exports = {
    rfc4648
};
}),
"[project]/node_modules/multibase/src/constants.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const baseX = __turbopack_context__.r("[project]/node_modules/@multiformats/base-x/src/index.js [app-client] (ecmascript)");
const Base = __turbopack_context__.r("[project]/node_modules/multibase/src/base.js [app-client] (ecmascript)");
const { rfc4648 } = __turbopack_context__.r("[project]/node_modules/multibase/src/rfc4648.js [app-client] (ecmascript)");
const { decodeText, encodeText } = __turbopack_context__.r("[project]/node_modules/multibase/src/util.js [app-client] (ecmascript)");
/** @typedef {import('./types').CodecFactory} CodecFactory */ /** @typedef {import('./types').Codec} Codec */ /** @typedef {import('./types').BaseName} BaseName */ /** @typedef {import('./types').BaseCode} BaseCode */ /** @type {CodecFactory} */ const identity = ()=>{
    return {
        encode: decodeText,
        decode: encodeText
    };
};
/**
 *
 * name, code, implementation, alphabet
 *
 * @type {Array<[BaseName, BaseCode, CodecFactory, string]>}
 */ const constants = [
    [
        'identity',
        '\x00',
        identity,
        ''
    ],
    [
        'base2',
        '0',
        rfc4648(1),
        '01'
    ],
    [
        'base8',
        '7',
        rfc4648(3),
        '01234567'
    ],
    [
        'base10',
        '9',
        baseX,
        '0123456789'
    ],
    [
        'base16',
        'f',
        rfc4648(4),
        '0123456789abcdef'
    ],
    [
        'base16upper',
        'F',
        rfc4648(4),
        '0123456789ABCDEF'
    ],
    [
        'base32hex',
        'v',
        rfc4648(5),
        '0123456789abcdefghijklmnopqrstuv'
    ],
    [
        'base32hexupper',
        'V',
        rfc4648(5),
        '0123456789ABCDEFGHIJKLMNOPQRSTUV'
    ],
    [
        'base32hexpad',
        't',
        rfc4648(5),
        '0123456789abcdefghijklmnopqrstuv='
    ],
    [
        'base32hexpadupper',
        'T',
        rfc4648(5),
        '0123456789ABCDEFGHIJKLMNOPQRSTUV='
    ],
    [
        'base32',
        'b',
        rfc4648(5),
        'abcdefghijklmnopqrstuvwxyz234567'
    ],
    [
        'base32upper',
        'B',
        rfc4648(5),
        'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'
    ],
    [
        'base32pad',
        'c',
        rfc4648(5),
        'abcdefghijklmnopqrstuvwxyz234567='
    ],
    [
        'base32padupper',
        'C',
        rfc4648(5),
        'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567='
    ],
    [
        'base32z',
        'h',
        rfc4648(5),
        'ybndrfg8ejkmcpqxot1uwisza345h769'
    ],
    [
        'base36',
        'k',
        baseX,
        '0123456789abcdefghijklmnopqrstuvwxyz'
    ],
    [
        'base36upper',
        'K',
        baseX,
        '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    ],
    [
        'base58btc',
        'z',
        baseX,
        '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
    ],
    [
        'base58flickr',
        'Z',
        baseX,
        '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'
    ],
    [
        'base64',
        'm',
        rfc4648(6),
        'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    ],
    [
        'base64pad',
        'M',
        rfc4648(6),
        'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
    ],
    [
        'base64url',
        'u',
        rfc4648(6),
        'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'
    ],
    [
        'base64urlpad',
        'U',
        rfc4648(6),
        'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_='
    ]
];
/** @type {Record<BaseName,Base>} */ const names = constants.reduce((prev, tupple)=>{
    prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3]);
    return prev;
}, {});
/** @type {Record<BaseCode,Base>} */ const codes = constants.reduce((prev, tupple)=>{
    prev[tupple[1]] = names[tupple[0]];
    return prev;
}, {});
module.exports = {
    names,
    codes
};
}),
"[project]/node_modules/multibase/src/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Implementation of the [multibase](https://github.com/multiformats/multibase) specification.
 *
 */ const constants = __turbopack_context__.r("[project]/node_modules/multibase/src/constants.js [app-client] (ecmascript)");
const { encodeText, decodeText, concat } = __turbopack_context__.r("[project]/node_modules/multibase/src/util.js [app-client] (ecmascript)");
/** @typedef {import('./base')} Base */ /** @typedef {import("./types").BaseNameOrCode} BaseNameOrCode */ /** @typedef {import("./types").BaseCode} BaseCode */ /** @typedef {import("./types").BaseName} BaseName */ /**
 * Create a new Uint8Array with the multibase varint+code.
 *
 * @param {BaseNameOrCode} nameOrCode - The multibase name or code number.
 * @param {Uint8Array} buf - The data to be prefixed with multibase.
 * @returns {Uint8Array}
 * @throws {Error} Will throw if the encoding is not supported
 */ function multibase(nameOrCode, buf) {
    if (!buf) {
        throw new Error('requires an encoded Uint8Array');
    }
    const { name, codeBuf } = encoding(nameOrCode);
    validEncode(name, buf);
    return concat([
        codeBuf,
        buf
    ], codeBuf.length + buf.length);
}
/**
 * Encode data with the specified base and add the multibase prefix.
 *
 * @param {BaseNameOrCode} nameOrCode - The multibase name or code number.
 * @param {Uint8Array} buf - The data to be encoded.
 * @returns {Uint8Array}
 * @throws {Error} Will throw if the encoding is not supported
 *
 */ function encode(nameOrCode, buf) {
    const enc = encoding(nameOrCode);
    const data = encodeText(enc.encode(buf));
    return concat([
        enc.codeBuf,
        data
    ], enc.codeBuf.length + data.length);
}
/**
 * Takes a Uint8Array or string encoded with multibase header, decodes it and
 * returns the decoded buffer
 *
 * @param {Uint8Array|string} data
 * @returns {Uint8Array}
 * @throws {Error} Will throw if the encoding is not supported
 *
 */ function decode(data) {
    if (data instanceof Uint8Array) {
        data = decodeText(data);
    }
    const prefix = data[0];
    // Make all encodings case-insensitive except the ones that include upper and lower chars in the alphabet
    if ([
        'f',
        'F',
        'v',
        'V',
        't',
        'T',
        'b',
        'B',
        'c',
        'C',
        'h',
        'k',
        'K'
    ].includes(prefix)) {
        data = data.toLowerCase();
    }
    const enc = encoding(data[0]);
    return enc.decode(data.substring(1));
}
/**
 * Is the given data multibase encoded?
 *
 * @param {Uint8Array|string} data
 */ function isEncoded(data) {
    if (data instanceof Uint8Array) {
        data = decodeText(data);
    }
    // Ensure bufOrString is a string
    if (Object.prototype.toString.call(data) !== '[object String]') {
        return false;
    }
    try {
        const enc = encoding(data[0]);
        return enc.name;
    } catch (err) {
        return false;
    }
}
/**
 * Validate encoded data
 *
 * @param {BaseNameOrCode} name
 * @param {Uint8Array} buf
 * @returns {void}
 * @throws {Error} Will throw if the encoding is not supported
 */ function validEncode(name, buf) {
    const enc = encoding(name);
    enc.decode(decodeText(buf));
}
/**
 * Get the encoding by name or code
 *
 * @param {BaseNameOrCode} nameOrCode
 * @returns {Base}
 * @throws {Error} Will throw if the encoding is not supported
 */ function encoding(nameOrCode) {
    if (Object.prototype.hasOwnProperty.call(constants.names, nameOrCode)) {
        return constants.names[nameOrCode];
    } else if (Object.prototype.hasOwnProperty.call(constants.codes, nameOrCode)) {
        return constants.codes[nameOrCode];
    } else {
        throw new Error(`Unsupported encoding: ${nameOrCode}`);
    }
}
/**
 * Get encoding from data
 *
 * @param {string|Uint8Array} data
 * @returns {Base}
 * @throws {Error} Will throw if the encoding is not supported
 */ function encodingFromData(data) {
    if (data instanceof Uint8Array) {
        data = decodeText(data);
    }
    return encoding(data[0]);
}
exports = module.exports = multibase;
exports.encode = encode;
exports.decode = decode;
exports.isEncoded = isEncoded;
exports.encoding = encoding;
exports.encodingFromData = encodingFromData;
const names = Object.freeze(constants.names);
const codes = Object.freeze(constants.codes);
exports.names = names;
exports.codes = codes;
}),
"[project]/node_modules/multihashes/node_modules/varint/encode.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = encode;
var MSB = 0x80, REST = 0x7F, MSBALL = ~REST, INT = Math.pow(2, 31);
function encode(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while(num >= INT){
        out[offset++] = num & 0xFF | MSB;
        num /= 128;
    }
    while(num & MSBALL){
        out[offset++] = num & 0xFF | MSB;
        num >>>= 7;
    }
    out[offset] = num | 0;
    encode.bytes = offset - oldOffset + 1;
    return out;
}
}),
"[project]/node_modules/multihashes/node_modules/varint/decode.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = read;
var MSB = 0x80, REST = 0x7F;
function read(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
        if (counter >= l) {
            read.bytes = 0;
            throw new RangeError('Could not decode varint');
        }
        b = buf[counter++];
        res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
        shift += 7;
    }while (b >= MSB)
    read.bytes = counter - offset;
    return res;
}
}),
"[project]/node_modules/multihashes/node_modules/varint/length.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
module.exports = function(value) {
    return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
}),
"[project]/node_modules/multihashes/node_modules/varint/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = {
    encode: __turbopack_context__.r("[project]/node_modules/multihashes/node_modules/varint/encode.js [app-client] (ecmascript)"),
    decode: __turbopack_context__.r("[project]/node_modules/multihashes/node_modules/varint/decode.js [app-client] (ecmascript)"),
    encodingLength: __turbopack_context__.r("[project]/node_modules/multihashes/node_modules/varint/length.js [app-client] (ecmascript)")
};
}),
"[project]/node_modules/multihashes/src/constants.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* eslint quote-props: off */ /**
 * Names for all available hashes
 *
 * @typedef { "identity" | "sha1" | "sha2-256" | "sha2-512" | "sha3-512" | "sha3-384" | "sha3-256" | "sha3-224" | "shake-128" | "shake-256" | "keccak-224" | "keccak-256" | "keccak-384" | "keccak-512" | "blake3" | "murmur3-128" | "murmur3-32" | "dbl-sha2-256" | "md4" | "md5" | "bmt" | "sha2-256-trunc254-padded" | "ripemd-128" | "ripemd-160" | "ripemd-256" | "ripemd-320" | "x11" | "kangarootwelve" | "sm3-256" | "blake2b-8" | "blake2b-16" | "blake2b-24" | "blake2b-32" | "blake2b-40" | "blake2b-48" | "blake2b-56" | "blake2b-64" | "blake2b-72" | "blake2b-80" | "blake2b-88" | "blake2b-96" | "blake2b-104" | "blake2b-112" | "blake2b-120" | "blake2b-128" | "blake2b-136" | "blake2b-144" | "blake2b-152" | "blake2b-160" | "blake2b-168" | "blake2b-176" | "blake2b-184" | "blake2b-192" | "blake2b-200" | "blake2b-208" | "blake2b-216" | "blake2b-224" | "blake2b-232" | "blake2b-240" | "blake2b-248" | "blake2b-256" | "blake2b-264" | "blake2b-272" | "blake2b-280" | "blake2b-288" | "blake2b-296" | "blake2b-304" | "blake2b-312" | "blake2b-320" | "blake2b-328" | "blake2b-336" | "blake2b-344" | "blake2b-352" | "blake2b-360" | "blake2b-368" | "blake2b-376" | "blake2b-384" | "blake2b-392" | "blake2b-400" | "blake2b-408" | "blake2b-416" | "blake2b-424" | "blake2b-432" | "blake2b-440" | "blake2b-448" | "blake2b-456" | "blake2b-464" | "blake2b-472" | "blake2b-480" | "blake2b-488" | "blake2b-496" | "blake2b-504" | "blake2b-512" | "blake2s-8" | "blake2s-16" | "blake2s-24" | "blake2s-32" | "blake2s-40" | "blake2s-48" | "blake2s-56" | "blake2s-64" | "blake2s-72" | "blake2s-80" | "blake2s-88" | "blake2s-96" | "blake2s-104" | "blake2s-112" | "blake2s-120" | "blake2s-128" | "blake2s-136" | "blake2s-144" | "blake2s-152" | "blake2s-160" | "blake2s-168" | "blake2s-176" | "blake2s-184" | "blake2s-192" | "blake2s-200" | "blake2s-208" | "blake2s-216" | "blake2s-224" | "blake2s-232" | "blake2s-240" | "blake2s-248" | "blake2s-256" | "skein256-8" | "skein256-16" | "skein256-24" | "skein256-32" | "skein256-40" | "skein256-48" | "skein256-56" | "skein256-64" | "skein256-72" | "skein256-80" | "skein256-88" | "skein256-96" | "skein256-104" | "skein256-112" | "skein256-120" | "skein256-128" | "skein256-136" | "skein256-144" | "skein256-152" | "skein256-160" | "skein256-168" | "skein256-176" | "skein256-184" | "skein256-192" | "skein256-200" | "skein256-208" | "skein256-216" | "skein256-224" | "skein256-232" | "skein256-240" | "skein256-248" | "skein256-256" | "skein512-8" | "skein512-16" | "skein512-24" | "skein512-32" | "skein512-40" | "skein512-48" | "skein512-56" | "skein512-64" | "skein512-72" | "skein512-80" | "skein512-88" | "skein512-96" | "skein512-104" | "skein512-112" | "skein512-120" | "skein512-128" | "skein512-136" | "skein512-144" | "skein512-152" | "skein512-160" | "skein512-168" | "skein512-176" | "skein512-184" | "skein512-192" | "skein512-200" | "skein512-208" | "skein512-216" | "skein512-224" | "skein512-232" | "skein512-240" | "skein512-248" | "skein512-256" | "skein512-264" | "skein512-272" | "skein512-280" | "skein512-288" | "skein512-296" | "skein512-304" | "skein512-312" | "skein512-320" | "skein512-328" | "skein512-336" | "skein512-344" | "skein512-352" | "skein512-360" | "skein512-368" | "skein512-376" | "skein512-384" | "skein512-392" | "skein512-400" | "skein512-408" | "skein512-416" | "skein512-424" | "skein512-432" | "skein512-440" | "skein512-448" | "skein512-456" | "skein512-464" | "skein512-472" | "skein512-480" | "skein512-488" | "skein512-496" | "skein512-504" | "skein512-512" | "skein1024-8" | "skein1024-16" | "skein1024-24" | "skein1024-32" | "skein1024-40" | "skein1024-48" | "skein1024-56" | "skein1024-64" | "skein1024-72" | "skein1024-80" | "skein1024-88" | "skein1024-96" | "skein1024-104" | "skein1024-112" | "skein1024-120" | "skein1024-128" | "skein1024-136" | "skein1024-144" | "skein1024-152" | "skein1024-160" | "skein1024-168" | "skein1024-176" | "skein1024-184" | "skein1024-192" | "skein1024-200" | "skein1024-208" | "skein1024-216" | "skein1024-224" | "skein1024-232" | "skein1024-240" | "skein1024-248" | "skein1024-256" | "skein1024-264" | "skein1024-272" | "skein1024-280" | "skein1024-288" | "skein1024-296" | "skein1024-304" | "skein1024-312" | "skein1024-320" | "skein1024-328" | "skein1024-336" | "skein1024-344" | "skein1024-352" | "skein1024-360" | "skein1024-368" | "skein1024-376" | "skein1024-384" | "skein1024-392" | "skein1024-400" | "skein1024-408" | "skein1024-416" | "skein1024-424" | "skein1024-432" | "skein1024-440" | "skein1024-448" | "skein1024-456" | "skein1024-464" | "skein1024-472" | "skein1024-480" | "skein1024-488" | "skein1024-496" | "skein1024-504" | "skein1024-512" | "skein1024-520" | "skein1024-528" | "skein1024-536" | "skein1024-544" | "skein1024-552" | "skein1024-560" | "skein1024-568" | "skein1024-576" | "skein1024-584" | "skein1024-592" | "skein1024-600" | "skein1024-608" | "skein1024-616" | "skein1024-624" | "skein1024-632" | "skein1024-640" | "skein1024-648" | "skein1024-656" | "skein1024-664" | "skein1024-672" | "skein1024-680" | "skein1024-688" | "skein1024-696" | "skein1024-704" | "skein1024-712" | "skein1024-720" | "skein1024-728" | "skein1024-736" | "skein1024-744" | "skein1024-752" | "skein1024-760" | "skein1024-768" | "skein1024-776" | "skein1024-784" | "skein1024-792" | "skein1024-800" | "skein1024-808" | "skein1024-816" | "skein1024-824" | "skein1024-832" | "skein1024-840" | "skein1024-848" | "skein1024-856" | "skein1024-864" | "skein1024-872" | "skein1024-880" | "skein1024-888" | "skein1024-896" | "skein1024-904" | "skein1024-912" | "skein1024-920" | "skein1024-928" | "skein1024-936" | "skein1024-944" | "skein1024-952" | "skein1024-960" | "skein1024-968" | "skein1024-976" | "skein1024-984" | "skein1024-992" | "skein1024-1000" | "skein1024-1008" | "skein1024-1016" | "skein1024-1024" | "poseidon-bls12_381-a2-fc1" | "poseidon-bls12_381-a2-fc1-sc" } HashName
 */ /**
 * Codes for all available hashes
 *
 * @typedef { 0x00 | 0x11 | 0x12 | 0x13 | 0x14 | 0x15 | 0x16 | 0x17 | 0x18 | 0x19 | 0x1a | 0x1b | 0x1c | 0x1d | 0x1e | 0x22 | 0x23 | 0x56 | 0xd4 | 0xd5 | 0xd6 | 0x1012 | 0x1052 | 0x1053 | 0x1054 | 0x1055 | 0x1100 | 0x1d01 | 0x534d | 0xb201 | 0xb202 | 0xb203 | 0xb204 | 0xb205 | 0xb206 | 0xb207 | 0xb208 | 0xb209 | 0xb20a | 0xb20b | 0xb20c | 0xb20d | 0xb20e | 0xb20f | 0xb210 | 0xb211 | 0xb212 | 0xb213 | 0xb214 | 0xb215 | 0xb216 | 0xb217 | 0xb218 | 0xb219 | 0xb21a | 0xb21b | 0xb21c | 0xb21d | 0xb21e | 0xb21f | 0xb220 | 0xb221 | 0xb222 | 0xb223 | 0xb224 | 0xb225 | 0xb226 | 0xb227 | 0xb228 | 0xb229 | 0xb22a | 0xb22b | 0xb22c | 0xb22d | 0xb22e | 0xb22f | 0xb230 | 0xb231 | 0xb232 | 0xb233 | 0xb234 | 0xb235 | 0xb236 | 0xb237 | 0xb238 | 0xb239 | 0xb23a | 0xb23b | 0xb23c | 0xb23d | 0xb23e | 0xb23f | 0xb240 | 0xb241 | 0xb242 | 0xb243 | 0xb244 | 0xb245 | 0xb246 | 0xb247 | 0xb248 | 0xb249 | 0xb24a | 0xb24b | 0xb24c | 0xb24d | 0xb24e | 0xb24f | 0xb250 | 0xb251 | 0xb252 | 0xb253 | 0xb254 | 0xb255 | 0xb256 | 0xb257 | 0xb258 | 0xb259 | 0xb25a | 0xb25b | 0xb25c | 0xb25d | 0xb25e | 0xb25f | 0xb260 | 0xb301 | 0xb302 | 0xb303 | 0xb304 | 0xb305 | 0xb306 | 0xb307 | 0xb308 | 0xb309 | 0xb30a | 0xb30b | 0xb30c | 0xb30d | 0xb30e | 0xb30f | 0xb310 | 0xb311 | 0xb312 | 0xb313 | 0xb314 | 0xb315 | 0xb316 | 0xb317 | 0xb318 | 0xb319 | 0xb31a | 0xb31b | 0xb31c | 0xb31d | 0xb31e | 0xb31f | 0xb320 | 0xb321 | 0xb322 | 0xb323 | 0xb324 | 0xb325 | 0xb326 | 0xb327 | 0xb328 | 0xb329 | 0xb32a | 0xb32b | 0xb32c | 0xb32d | 0xb32e | 0xb32f | 0xb330 | 0xb331 | 0xb332 | 0xb333 | 0xb334 | 0xb335 | 0xb336 | 0xb337 | 0xb338 | 0xb339 | 0xb33a | 0xb33b | 0xb33c | 0xb33d | 0xb33e | 0xb33f | 0xb340 | 0xb341 | 0xb342 | 0xb343 | 0xb344 | 0xb345 | 0xb346 | 0xb347 | 0xb348 | 0xb349 | 0xb34a | 0xb34b | 0xb34c | 0xb34d | 0xb34e | 0xb34f | 0xb350 | 0xb351 | 0xb352 | 0xb353 | 0xb354 | 0xb355 | 0xb356 | 0xb357 | 0xb358 | 0xb359 | 0xb35a | 0xb35b | 0xb35c | 0xb35d | 0xb35e | 0xb35f | 0xb360 | 0xb361 | 0xb362 | 0xb363 | 0xb364 | 0xb365 | 0xb366 | 0xb367 | 0xb368 | 0xb369 | 0xb36a | 0xb36b | 0xb36c | 0xb36d | 0xb36e | 0xb36f | 0xb370 | 0xb371 | 0xb372 | 0xb373 | 0xb374 | 0xb375 | 0xb376 | 0xb377 | 0xb378 | 0xb379 | 0xb37a | 0xb37b | 0xb37c | 0xb37d | 0xb37e | 0xb37f | 0xb380 | 0xb381 | 0xb382 | 0xb383 | 0xb384 | 0xb385 | 0xb386 | 0xb387 | 0xb388 | 0xb389 | 0xb38a | 0xb38b | 0xb38c | 0xb38d | 0xb38e | 0xb38f | 0xb390 | 0xb391 | 0xb392 | 0xb393 | 0xb394 | 0xb395 | 0xb396 | 0xb397 | 0xb398 | 0xb399 | 0xb39a | 0xb39b | 0xb39c | 0xb39d | 0xb39e | 0xb39f | 0xb3a0 | 0xb3a1 | 0xb3a2 | 0xb3a3 | 0xb3a4 | 0xb3a5 | 0xb3a6 | 0xb3a7 | 0xb3a8 | 0xb3a9 | 0xb3aa | 0xb3ab | 0xb3ac | 0xb3ad | 0xb3ae | 0xb3af | 0xb3b0 | 0xb3b1 | 0xb3b2 | 0xb3b3 | 0xb3b4 | 0xb3b5 | 0xb3b6 | 0xb3b7 | 0xb3b8 | 0xb3b9 | 0xb3ba | 0xb3bb | 0xb3bc | 0xb3bd | 0xb3be | 0xb3bf | 0xb3c0 | 0xb3c1 | 0xb3c2 | 0xb3c3 | 0xb3c4 | 0xb3c5 | 0xb3c6 | 0xb3c7 | 0xb3c8 | 0xb3c9 | 0xb3ca | 0xb3cb | 0xb3cc | 0xb3cd | 0xb3ce | 0xb3cf | 0xb3d0 | 0xb3d1 | 0xb3d2 | 0xb3d3 | 0xb3d4 | 0xb3d5 | 0xb3d6 | 0xb3d7 | 0xb3d8 | 0xb3d9 | 0xb3da | 0xb3db | 0xb3dc | 0xb3dd | 0xb3de | 0xb3df | 0xb3e0 | 0xb401 | 0xb402 } HashCode
 */ /**
 * @type { Record<HashName,HashCode> }
 */ const names = Object.freeze({
    'identity': 0x00,
    'sha1': 0x11,
    'sha2-256': 0x12,
    'sha2-512': 0x13,
    'sha3-512': 0x14,
    'sha3-384': 0x15,
    'sha3-256': 0x16,
    'sha3-224': 0x17,
    'shake-128': 0x18,
    'shake-256': 0x19,
    'keccak-224': 0x1a,
    'keccak-256': 0x1b,
    'keccak-384': 0x1c,
    'keccak-512': 0x1d,
    'blake3': 0x1e,
    'murmur3-128': 0x22,
    'murmur3-32': 0x23,
    'dbl-sha2-256': 0x56,
    'md4': 0xd4,
    'md5': 0xd5,
    'bmt': 0xd6,
    'sha2-256-trunc254-padded': 0x1012,
    'ripemd-128': 0x1052,
    'ripemd-160': 0x1053,
    'ripemd-256': 0x1054,
    'ripemd-320': 0x1055,
    'x11': 0x1100,
    'kangarootwelve': 0x1d01,
    'sm3-256': 0x534d,
    'blake2b-8': 0xb201,
    'blake2b-16': 0xb202,
    'blake2b-24': 0xb203,
    'blake2b-32': 0xb204,
    'blake2b-40': 0xb205,
    'blake2b-48': 0xb206,
    'blake2b-56': 0xb207,
    'blake2b-64': 0xb208,
    'blake2b-72': 0xb209,
    'blake2b-80': 0xb20a,
    'blake2b-88': 0xb20b,
    'blake2b-96': 0xb20c,
    'blake2b-104': 0xb20d,
    'blake2b-112': 0xb20e,
    'blake2b-120': 0xb20f,
    'blake2b-128': 0xb210,
    'blake2b-136': 0xb211,
    'blake2b-144': 0xb212,
    'blake2b-152': 0xb213,
    'blake2b-160': 0xb214,
    'blake2b-168': 0xb215,
    'blake2b-176': 0xb216,
    'blake2b-184': 0xb217,
    'blake2b-192': 0xb218,
    'blake2b-200': 0xb219,
    'blake2b-208': 0xb21a,
    'blake2b-216': 0xb21b,
    'blake2b-224': 0xb21c,
    'blake2b-232': 0xb21d,
    'blake2b-240': 0xb21e,
    'blake2b-248': 0xb21f,
    'blake2b-256': 0xb220,
    'blake2b-264': 0xb221,
    'blake2b-272': 0xb222,
    'blake2b-280': 0xb223,
    'blake2b-288': 0xb224,
    'blake2b-296': 0xb225,
    'blake2b-304': 0xb226,
    'blake2b-312': 0xb227,
    'blake2b-320': 0xb228,
    'blake2b-328': 0xb229,
    'blake2b-336': 0xb22a,
    'blake2b-344': 0xb22b,
    'blake2b-352': 0xb22c,
    'blake2b-360': 0xb22d,
    'blake2b-368': 0xb22e,
    'blake2b-376': 0xb22f,
    'blake2b-384': 0xb230,
    'blake2b-392': 0xb231,
    'blake2b-400': 0xb232,
    'blake2b-408': 0xb233,
    'blake2b-416': 0xb234,
    'blake2b-424': 0xb235,
    'blake2b-432': 0xb236,
    'blake2b-440': 0xb237,
    'blake2b-448': 0xb238,
    'blake2b-456': 0xb239,
    'blake2b-464': 0xb23a,
    'blake2b-472': 0xb23b,
    'blake2b-480': 0xb23c,
    'blake2b-488': 0xb23d,
    'blake2b-496': 0xb23e,
    'blake2b-504': 0xb23f,
    'blake2b-512': 0xb240,
    'blake2s-8': 0xb241,
    'blake2s-16': 0xb242,
    'blake2s-24': 0xb243,
    'blake2s-32': 0xb244,
    'blake2s-40': 0xb245,
    'blake2s-48': 0xb246,
    'blake2s-56': 0xb247,
    'blake2s-64': 0xb248,
    'blake2s-72': 0xb249,
    'blake2s-80': 0xb24a,
    'blake2s-88': 0xb24b,
    'blake2s-96': 0xb24c,
    'blake2s-104': 0xb24d,
    'blake2s-112': 0xb24e,
    'blake2s-120': 0xb24f,
    'blake2s-128': 0xb250,
    'blake2s-136': 0xb251,
    'blake2s-144': 0xb252,
    'blake2s-152': 0xb253,
    'blake2s-160': 0xb254,
    'blake2s-168': 0xb255,
    'blake2s-176': 0xb256,
    'blake2s-184': 0xb257,
    'blake2s-192': 0xb258,
    'blake2s-200': 0xb259,
    'blake2s-208': 0xb25a,
    'blake2s-216': 0xb25b,
    'blake2s-224': 0xb25c,
    'blake2s-232': 0xb25d,
    'blake2s-240': 0xb25e,
    'blake2s-248': 0xb25f,
    'blake2s-256': 0xb260,
    'skein256-8': 0xb301,
    'skein256-16': 0xb302,
    'skein256-24': 0xb303,
    'skein256-32': 0xb304,
    'skein256-40': 0xb305,
    'skein256-48': 0xb306,
    'skein256-56': 0xb307,
    'skein256-64': 0xb308,
    'skein256-72': 0xb309,
    'skein256-80': 0xb30a,
    'skein256-88': 0xb30b,
    'skein256-96': 0xb30c,
    'skein256-104': 0xb30d,
    'skein256-112': 0xb30e,
    'skein256-120': 0xb30f,
    'skein256-128': 0xb310,
    'skein256-136': 0xb311,
    'skein256-144': 0xb312,
    'skein256-152': 0xb313,
    'skein256-160': 0xb314,
    'skein256-168': 0xb315,
    'skein256-176': 0xb316,
    'skein256-184': 0xb317,
    'skein256-192': 0xb318,
    'skein256-200': 0xb319,
    'skein256-208': 0xb31a,
    'skein256-216': 0xb31b,
    'skein256-224': 0xb31c,
    'skein256-232': 0xb31d,
    'skein256-240': 0xb31e,
    'skein256-248': 0xb31f,
    'skein256-256': 0xb320,
    'skein512-8': 0xb321,
    'skein512-16': 0xb322,
    'skein512-24': 0xb323,
    'skein512-32': 0xb324,
    'skein512-40': 0xb325,
    'skein512-48': 0xb326,
    'skein512-56': 0xb327,
    'skein512-64': 0xb328,
    'skein512-72': 0xb329,
    'skein512-80': 0xb32a,
    'skein512-88': 0xb32b,
    'skein512-96': 0xb32c,
    'skein512-104': 0xb32d,
    'skein512-112': 0xb32e,
    'skein512-120': 0xb32f,
    'skein512-128': 0xb330,
    'skein512-136': 0xb331,
    'skein512-144': 0xb332,
    'skein512-152': 0xb333,
    'skein512-160': 0xb334,
    'skein512-168': 0xb335,
    'skein512-176': 0xb336,
    'skein512-184': 0xb337,
    'skein512-192': 0xb338,
    'skein512-200': 0xb339,
    'skein512-208': 0xb33a,
    'skein512-216': 0xb33b,
    'skein512-224': 0xb33c,
    'skein512-232': 0xb33d,
    'skein512-240': 0xb33e,
    'skein512-248': 0xb33f,
    'skein512-256': 0xb340,
    'skein512-264': 0xb341,
    'skein512-272': 0xb342,
    'skein512-280': 0xb343,
    'skein512-288': 0xb344,
    'skein512-296': 0xb345,
    'skein512-304': 0xb346,
    'skein512-312': 0xb347,
    'skein512-320': 0xb348,
    'skein512-328': 0xb349,
    'skein512-336': 0xb34a,
    'skein512-344': 0xb34b,
    'skein512-352': 0xb34c,
    'skein512-360': 0xb34d,
    'skein512-368': 0xb34e,
    'skein512-376': 0xb34f,
    'skein512-384': 0xb350,
    'skein512-392': 0xb351,
    'skein512-400': 0xb352,
    'skein512-408': 0xb353,
    'skein512-416': 0xb354,
    'skein512-424': 0xb355,
    'skein512-432': 0xb356,
    'skein512-440': 0xb357,
    'skein512-448': 0xb358,
    'skein512-456': 0xb359,
    'skein512-464': 0xb35a,
    'skein512-472': 0xb35b,
    'skein512-480': 0xb35c,
    'skein512-488': 0xb35d,
    'skein512-496': 0xb35e,
    'skein512-504': 0xb35f,
    'skein512-512': 0xb360,
    'skein1024-8': 0xb361,
    'skein1024-16': 0xb362,
    'skein1024-24': 0xb363,
    'skein1024-32': 0xb364,
    'skein1024-40': 0xb365,
    'skein1024-48': 0xb366,
    'skein1024-56': 0xb367,
    'skein1024-64': 0xb368,
    'skein1024-72': 0xb369,
    'skein1024-80': 0xb36a,
    'skein1024-88': 0xb36b,
    'skein1024-96': 0xb36c,
    'skein1024-104': 0xb36d,
    'skein1024-112': 0xb36e,
    'skein1024-120': 0xb36f,
    'skein1024-128': 0xb370,
    'skein1024-136': 0xb371,
    'skein1024-144': 0xb372,
    'skein1024-152': 0xb373,
    'skein1024-160': 0xb374,
    'skein1024-168': 0xb375,
    'skein1024-176': 0xb376,
    'skein1024-184': 0xb377,
    'skein1024-192': 0xb378,
    'skein1024-200': 0xb379,
    'skein1024-208': 0xb37a,
    'skein1024-216': 0xb37b,
    'skein1024-224': 0xb37c,
    'skein1024-232': 0xb37d,
    'skein1024-240': 0xb37e,
    'skein1024-248': 0xb37f,
    'skein1024-256': 0xb380,
    'skein1024-264': 0xb381,
    'skein1024-272': 0xb382,
    'skein1024-280': 0xb383,
    'skein1024-288': 0xb384,
    'skein1024-296': 0xb385,
    'skein1024-304': 0xb386,
    'skein1024-312': 0xb387,
    'skein1024-320': 0xb388,
    'skein1024-328': 0xb389,
    'skein1024-336': 0xb38a,
    'skein1024-344': 0xb38b,
    'skein1024-352': 0xb38c,
    'skein1024-360': 0xb38d,
    'skein1024-368': 0xb38e,
    'skein1024-376': 0xb38f,
    'skein1024-384': 0xb390,
    'skein1024-392': 0xb391,
    'skein1024-400': 0xb392,
    'skein1024-408': 0xb393,
    'skein1024-416': 0xb394,
    'skein1024-424': 0xb395,
    'skein1024-432': 0xb396,
    'skein1024-440': 0xb397,
    'skein1024-448': 0xb398,
    'skein1024-456': 0xb399,
    'skein1024-464': 0xb39a,
    'skein1024-472': 0xb39b,
    'skein1024-480': 0xb39c,
    'skein1024-488': 0xb39d,
    'skein1024-496': 0xb39e,
    'skein1024-504': 0xb39f,
    'skein1024-512': 0xb3a0,
    'skein1024-520': 0xb3a1,
    'skein1024-528': 0xb3a2,
    'skein1024-536': 0xb3a3,
    'skein1024-544': 0xb3a4,
    'skein1024-552': 0xb3a5,
    'skein1024-560': 0xb3a6,
    'skein1024-568': 0xb3a7,
    'skein1024-576': 0xb3a8,
    'skein1024-584': 0xb3a9,
    'skein1024-592': 0xb3aa,
    'skein1024-600': 0xb3ab,
    'skein1024-608': 0xb3ac,
    'skein1024-616': 0xb3ad,
    'skein1024-624': 0xb3ae,
    'skein1024-632': 0xb3af,
    'skein1024-640': 0xb3b0,
    'skein1024-648': 0xb3b1,
    'skein1024-656': 0xb3b2,
    'skein1024-664': 0xb3b3,
    'skein1024-672': 0xb3b4,
    'skein1024-680': 0xb3b5,
    'skein1024-688': 0xb3b6,
    'skein1024-696': 0xb3b7,
    'skein1024-704': 0xb3b8,
    'skein1024-712': 0xb3b9,
    'skein1024-720': 0xb3ba,
    'skein1024-728': 0xb3bb,
    'skein1024-736': 0xb3bc,
    'skein1024-744': 0xb3bd,
    'skein1024-752': 0xb3be,
    'skein1024-760': 0xb3bf,
    'skein1024-768': 0xb3c0,
    'skein1024-776': 0xb3c1,
    'skein1024-784': 0xb3c2,
    'skein1024-792': 0xb3c3,
    'skein1024-800': 0xb3c4,
    'skein1024-808': 0xb3c5,
    'skein1024-816': 0xb3c6,
    'skein1024-824': 0xb3c7,
    'skein1024-832': 0xb3c8,
    'skein1024-840': 0xb3c9,
    'skein1024-848': 0xb3ca,
    'skein1024-856': 0xb3cb,
    'skein1024-864': 0xb3cc,
    'skein1024-872': 0xb3cd,
    'skein1024-880': 0xb3ce,
    'skein1024-888': 0xb3cf,
    'skein1024-896': 0xb3d0,
    'skein1024-904': 0xb3d1,
    'skein1024-912': 0xb3d2,
    'skein1024-920': 0xb3d3,
    'skein1024-928': 0xb3d4,
    'skein1024-936': 0xb3d5,
    'skein1024-944': 0xb3d6,
    'skein1024-952': 0xb3d7,
    'skein1024-960': 0xb3d8,
    'skein1024-968': 0xb3d9,
    'skein1024-976': 0xb3da,
    'skein1024-984': 0xb3db,
    'skein1024-992': 0xb3dc,
    'skein1024-1000': 0xb3dd,
    'skein1024-1008': 0xb3de,
    'skein1024-1016': 0xb3df,
    'skein1024-1024': 0xb3e0,
    'poseidon-bls12_381-a2-fc1': 0xb401,
    'poseidon-bls12_381-a2-fc1-sc': 0xb402
});
module.exports = {
    names
};
}),
"[project]/node_modules/multihashes/src/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Multihash implementation in JavaScript.
 */ const multibase = __turbopack_context__.r("[project]/node_modules/multibase/src/index.js [app-client] (ecmascript)");
const varint = __turbopack_context__.r("[project]/node_modules/multihashes/node_modules/varint/index.js [app-client] (ecmascript)");
const { names } = __turbopack_context__.r("[project]/node_modules/multihashes/src/constants.js [app-client] (ecmascript)");
const { toString: uint8ArrayToString } = __turbopack_context__.r("[project]/node_modules/uint8arrays/esm/src/to-string.js [app-client] (ecmascript)");
const { fromString: uint8ArrayFromString } = __turbopack_context__.r("[project]/node_modules/uint8arrays/esm/src/from-string.js [app-client] (ecmascript)");
const { concat: uint8ArrayConcat } = __turbopack_context__.r("[project]/node_modules/uint8arrays/esm/src/concat.js [app-client] (ecmascript)");
const codes = {};
// eslint-disable-next-line guard-for-in
for(const key in names){
    const name = key;
    codes[names[name]] = name;
}
Object.freeze(codes);
/**
 * Convert the given multihash to a hex encoded string.
 *
 * @param {Uint8Array} hash
 * @returns {string}
 */ function toHexString(hash) {
    if (!(hash instanceof Uint8Array)) {
        throw new Error('must be passed a Uint8Array');
    }
    return uint8ArrayToString(hash, 'base16');
}
/**
 * Convert the given hex encoded string to a multihash.
 *
 * @param {string} hash
 * @returns {Uint8Array}
 */ function fromHexString(hash) {
    return uint8ArrayFromString(hash, 'base16');
}
/**
 * Convert the given multihash to a base58 encoded string.
 *
 * @param {Uint8Array} hash
 * @returns {string}
 */ function toB58String(hash) {
    if (!(hash instanceof Uint8Array)) {
        throw new Error('must be passed a Uint8Array');
    }
    return uint8ArrayToString(multibase.encode('base58btc', hash)).slice(1);
}
/**
 * Convert the given base58 encoded string to a multihash.
 *
 * @param {string|Uint8Array} hash
 * @returns {Uint8Array}
 */ function fromB58String(hash) {
    const encoded = hash instanceof Uint8Array ? uint8ArrayToString(hash) : hash;
    return multibase.decode('z' + encoded);
}
/**
 * Decode a hash from the given multihash.
 *
 * @param {Uint8Array} bytes
 * @returns {{code: HashCode, name: HashName, length: number, digest: Uint8Array}} result
 */ function decode(bytes) {
    if (!(bytes instanceof Uint8Array)) {
        throw new Error('multihash must be a Uint8Array');
    }
    if (bytes.length < 2) {
        throw new Error('multihash too short. must be > 2 bytes.');
    }
    const code = varint.decode(bytes);
    if (!isValidCode(code)) {
        throw new Error(`multihash unknown function code: 0x${code.toString(16)}`);
    }
    bytes = bytes.slice(varint.decode.bytes);
    const len = varint.decode(bytes);
    if (len < 0) {
        throw new Error(`multihash invalid length: ${len}`);
    }
    bytes = bytes.slice(varint.decode.bytes);
    if (bytes.length !== len) {
        throw new Error(`multihash length inconsistent: 0x${uint8ArrayToString(bytes, 'base16')}`);
    }
    return {
        code,
        name: codes[code],
        length: len,
        digest: bytes
    };
}
/**
 * Encode a hash digest along with the specified function code.
 *
 * > **Note:** the length is derived from the length of the digest itself.
 *
 * @param {Uint8Array} digest
 * @param {HashName | HashCode} code
 * @param {number} [length]
 * @returns {Uint8Array}
 */ function encode(digest, code, length) {
    if (!digest || code === undefined) {
        throw new Error('multihash encode requires at least two args: digest, code');
    }
    // ensure it's a hashfunction code.
    const hashfn = coerceCode(code);
    if (!(digest instanceof Uint8Array)) {
        throw new Error('digest should be a Uint8Array');
    }
    if (length == null) {
        length = digest.length;
    }
    if (length && digest.length !== length) {
        throw new Error('digest length should be equal to specified length.');
    }
    const hash = varint.encode(hashfn);
    const len = varint.encode(length);
    return uint8ArrayConcat([
        hash,
        len,
        digest
    ], hash.length + len.length + digest.length);
}
/**
 * Converts a hash function name into the matching code.
 * If passed a number it will return the number if it's a valid code.
 *
 * @param {HashName | number} name
 * @returns {number}
 */ function coerceCode(name) {
    let code = name;
    if (typeof name === 'string') {
        if (names[name] === undefined) {
            throw new Error(`Unrecognized hash function named: ${name}`);
        }
        code = names[name];
    }
    if (typeof code !== 'number') {
        throw new Error(`Hash function code should be a number. Got: ${code}`);
    }
    // @ts-ignore
    if (codes[code] === undefined && !isAppCode(code)) {
        throw new Error(`Unrecognized function code: ${code}`);
    }
    return code;
}
/**
 * Checks if a code is part of the app range
 *
 * @param {number} code
 * @returns {boolean}
 */ function isAppCode(code) {
    return code > 0 && code < 0x10;
}
/**
 * Checks whether a multihash code is valid.
 *
 * @param {HashCode} code
 * @returns {boolean}
 */ function isValidCode(code) {
    if (isAppCode(code)) {
        return true;
    }
    if (codes[code]) {
        return true;
    }
    return false;
}
/**
 * Check if the given buffer is a valid multihash. Throws an error if it is not valid.
 *
 * @param {Uint8Array} multihash
 * @returns {void}
 * @throws {Error}
 */ function validate(multihash) {
    decode(multihash); // throws if bad.
}
/**
 * Returns a prefix from a valid multihash. Throws an error if it is not valid.
 *
 * @param {Uint8Array} multihash
 * @returns {Uint8Array}
 * @throws {Error}
 */ function prefix(multihash) {
    validate(multihash);
    return multihash.subarray(0, 2);
}
module.exports = {
    names,
    codes,
    toHexString,
    fromHexString,
    toB58String,
    fromB58String,
    decode,
    encode,
    coerceCode,
    isAppCode,
    validate,
    prefix,
    isValidCode
}; /**
 * @typedef { import("./constants").HashCode } HashCode
 * @typedef { import("./constants").HashName } HashName
 */ 
}),
"[project]/node_modules/varint/encode.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = encode;
var MSB = 0x80, REST = 0x7F, MSBALL = ~REST, INT = Math.pow(2, 31);
function encode(num, out, offset) {
    if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
        encode.bytes = 0;
        throw new RangeError('Could not encode varint');
    }
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while(num >= INT){
        out[offset++] = num & 0xFF | MSB;
        num /= 128;
    }
    while(num & MSBALL){
        out[offset++] = num & 0xFF | MSB;
        num >>>= 7;
    }
    out[offset] = num | 0;
    encode.bytes = offset - oldOffset + 1;
    return out;
}
}),
"[project]/node_modules/varint/decode.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = read;
var MSB = 0x80, REST = 0x7F;
function read(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
        if (counter >= l || shift > 49) {
            read.bytes = 0;
            throw new RangeError('Could not decode varint');
        }
        b = buf[counter++];
        res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
        shift += 7;
    }while (b >= MSB)
    read.bytes = counter - offset;
    return res;
}
}),
"[project]/node_modules/varint/length.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
module.exports = function(value) {
    return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
}),
"[project]/node_modules/varint/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = {
    encode: __turbopack_context__.r("[project]/node_modules/varint/encode.js [app-client] (ecmascript)"),
    decode: __turbopack_context__.r("[project]/node_modules/varint/decode.js [app-client] (ecmascript)"),
    encodingLength: __turbopack_context__.r("[project]/node_modules/varint/length.js [app-client] (ecmascript)")
};
}),
"[project]/node_modules/murmurhash3js-revisited/lib/murmurHash3js.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/* jshint -W086: true */ // +----------------------------------------------------------------------+
// | murmurHash3js.js v3.0.1 // https://github.com/pid/murmurHash3js
// | A javascript implementation of MurmurHash3's x86 hashing algorithms. |
// |----------------------------------------------------------------------|
// | Copyright (c) 2012-2015 Karan Lyons                                       |
// | https://github.com/karanlyons/murmurHash3.js/blob/c1778f75792abef7bdd74bc85d2d4e1a3d25cfe9/murmurHash3.js |
// | Freely distributable under the MIT license.                          |
// +----------------------------------------------------------------------+
;
(function(root, undefined) {
    'use strict';
    // Create a local object that'll be exported or referenced globally.
    var library = {
        'version': '3.0.0',
        'x86': {},
        'x64': {},
        'inputValidation': true
    };
    // PRIVATE FUNCTIONS
    // -----------------
    function _validBytes(bytes) {
        // check the input is an array or a typed array
        if (!Array.isArray(bytes) && !ArrayBuffer.isView(bytes)) {
            return false;
        }
        // check all bytes are actually bytes
        for(var i = 0; i < bytes.length; i++){
            if (!Number.isInteger(bytes[i]) || bytes[i] < 0 || bytes[i] > 255) {
                return false;
            }
        }
        return true;
    }
    function _x86Multiply(m, n) {
        //
        // Given two 32bit ints, returns the two multiplied together as a
        // 32bit int.
        //
        return (m & 0xffff) * n + (((m >>> 16) * n & 0xffff) << 16);
    }
    function _x86Rotl(m, n) {
        //
        // Given a 32bit int and an int representing a number of bit positions,
        // returns the 32bit int rotated left by that number of positions.
        //
        return m << n | m >>> 32 - n;
    }
    function _x86Fmix(h) {
        //
        // Given a block, returns murmurHash3's final x86 mix of that block.
        //
        h ^= h >>> 16;
        h = _x86Multiply(h, 0x85ebca6b);
        h ^= h >>> 13;
        h = _x86Multiply(h, 0xc2b2ae35);
        h ^= h >>> 16;
        return h;
    }
    function _x64Add(m, n) {
        //
        // Given two 64bit ints (as an array of two 32bit ints) returns the two
        // added together as a 64bit int (as an array of two 32bit ints).
        //
        m = [
            m[0] >>> 16,
            m[0] & 0xffff,
            m[1] >>> 16,
            m[1] & 0xffff
        ];
        n = [
            n[0] >>> 16,
            n[0] & 0xffff,
            n[1] >>> 16,
            n[1] & 0xffff
        ];
        var o = [
            0,
            0,
            0,
            0
        ];
        o[3] += m[3] + n[3];
        o[2] += o[3] >>> 16;
        o[3] &= 0xffff;
        o[2] += m[2] + n[2];
        o[1] += o[2] >>> 16;
        o[2] &= 0xffff;
        o[1] += m[1] + n[1];
        o[0] += o[1] >>> 16;
        o[1] &= 0xffff;
        o[0] += m[0] + n[0];
        o[0] &= 0xffff;
        return [
            o[0] << 16 | o[1],
            o[2] << 16 | o[3]
        ];
    }
    function _x64Multiply(m, n) {
        //
        // Given two 64bit ints (as an array of two 32bit ints) returns the two
        // multiplied together as a 64bit int (as an array of two 32bit ints).
        //
        m = [
            m[0] >>> 16,
            m[0] & 0xffff,
            m[1] >>> 16,
            m[1] & 0xffff
        ];
        n = [
            n[0] >>> 16,
            n[0] & 0xffff,
            n[1] >>> 16,
            n[1] & 0xffff
        ];
        var o = [
            0,
            0,
            0,
            0
        ];
        o[3] += m[3] * n[3];
        o[2] += o[3] >>> 16;
        o[3] &= 0xffff;
        o[2] += m[2] * n[3];
        o[1] += o[2] >>> 16;
        o[2] &= 0xffff;
        o[2] += m[3] * n[2];
        o[1] += o[2] >>> 16;
        o[2] &= 0xffff;
        o[1] += m[1] * n[3];
        o[0] += o[1] >>> 16;
        o[1] &= 0xffff;
        o[1] += m[2] * n[2];
        o[0] += o[1] >>> 16;
        o[1] &= 0xffff;
        o[1] += m[3] * n[1];
        o[0] += o[1] >>> 16;
        o[1] &= 0xffff;
        o[0] += m[0] * n[3] + m[1] * n[2] + m[2] * n[1] + m[3] * n[0];
        o[0] &= 0xffff;
        return [
            o[0] << 16 | o[1],
            o[2] << 16 | o[3]
        ];
    }
    function _x64Rotl(m, n) {
        //
        // Given a 64bit int (as an array of two 32bit ints) and an int
        // representing a number of bit positions, returns the 64bit int (as an
        // array of two 32bit ints) rotated left by that number of positions.
        //
        n %= 64;
        if (n === 32) {
            return [
                m[1],
                m[0]
            ];
        } else if (n < 32) {
            return [
                m[0] << n | m[1] >>> 32 - n,
                m[1] << n | m[0] >>> 32 - n
            ];
        } else {
            n -= 32;
            return [
                m[1] << n | m[0] >>> 32 - n,
                m[0] << n | m[1] >>> 32 - n
            ];
        }
    }
    function _x64LeftShift(m, n) {
        //
        // Given a 64bit int (as an array of two 32bit ints) and an int
        // representing a number of bit positions, returns the 64bit int (as an
        // array of two 32bit ints) shifted left by that number of positions.
        //
        n %= 64;
        if (n === 0) {
            return m;
        } else if (n < 32) {
            return [
                m[0] << n | m[1] >>> 32 - n,
                m[1] << n
            ];
        } else {
            return [
                m[1] << n - 32,
                0
            ];
        }
    }
    function _x64Xor(m, n) {
        //
        // Given two 64bit ints (as an array of two 32bit ints) returns the two
        // xored together as a 64bit int (as an array of two 32bit ints).
        //
        return [
            m[0] ^ n[0],
            m[1] ^ n[1]
        ];
    }
    function _x64Fmix(h) {
        //
        // Given a block, returns murmurHash3's final x64 mix of that block.
        // (`[0, h[0] >>> 1]` is a 33 bit unsigned right shift. This is the
        // only place where we need to right shift 64bit ints.)
        //
        h = _x64Xor(h, [
            0,
            h[0] >>> 1
        ]);
        h = _x64Multiply(h, [
            0xff51afd7,
            0xed558ccd
        ]);
        h = _x64Xor(h, [
            0,
            h[0] >>> 1
        ]);
        h = _x64Multiply(h, [
            0xc4ceb9fe,
            0x1a85ec53
        ]);
        h = _x64Xor(h, [
            0,
            h[0] >>> 1
        ]);
        return h;
    }
    // PUBLIC FUNCTIONS
    // ----------------
    library.x86.hash32 = function(bytes, seed) {
        //
        // Given a string and an optional seed as an int, returns a 32 bit hash
        // using the x86 flavor of MurmurHash3, as an unsigned int.
        //
        if (library.inputValidation && !_validBytes(bytes)) {
            return undefined;
        }
        seed = seed || 0;
        var remainder = bytes.length % 4;
        var blocks = bytes.length - remainder;
        var h1 = seed;
        var k1 = 0;
        var c1 = 0xcc9e2d51;
        var c2 = 0x1b873593;
        for(var i = 0; i < blocks; i = i + 4){
            k1 = bytes[i] | bytes[i + 1] << 8 | bytes[i + 2] << 16 | bytes[i + 3] << 24;
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c2);
            h1 ^= k1;
            h1 = _x86Rotl(h1, 13);
            h1 = _x86Multiply(h1, 5) + 0xe6546b64;
        }
        k1 = 0;
        switch(remainder){
            case 3:
                k1 ^= bytes[i + 2] << 16;
            case 2:
                k1 ^= bytes[i + 1] << 8;
            case 1:
                k1 ^= bytes[i];
                k1 = _x86Multiply(k1, c1);
                k1 = _x86Rotl(k1, 15);
                k1 = _x86Multiply(k1, c2);
                h1 ^= k1;
        }
        h1 ^= bytes.length;
        h1 = _x86Fmix(h1);
        return h1 >>> 0;
    };
    library.x86.hash128 = function(bytes, seed) {
        //
        // Given a string and an optional seed as an int, returns a 128 bit
        // hash using the x86 flavor of MurmurHash3, as an unsigned hex.
        //
        if (library.inputValidation && !_validBytes(bytes)) {
            return undefined;
        }
        seed = seed || 0;
        var remainder = bytes.length % 16;
        var blocks = bytes.length - remainder;
        var h1 = seed;
        var h2 = seed;
        var h3 = seed;
        var h4 = seed;
        var k1 = 0;
        var k2 = 0;
        var k3 = 0;
        var k4 = 0;
        var c1 = 0x239b961b;
        var c2 = 0xab0e9789;
        var c3 = 0x38b34ae5;
        var c4 = 0xa1e38b93;
        for(var i = 0; i < blocks; i = i + 16){
            k1 = bytes[i] | bytes[i + 1] << 8 | bytes[i + 2] << 16 | bytes[i + 3] << 24;
            k2 = bytes[i + 4] | bytes[i + 5] << 8 | bytes[i + 6] << 16 | bytes[i + 7] << 24;
            k3 = bytes[i + 8] | bytes[i + 9] << 8 | bytes[i + 10] << 16 | bytes[i + 11] << 24;
            k4 = bytes[i + 12] | bytes[i + 13] << 8 | bytes[i + 14] << 16 | bytes[i + 15] << 24;
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c2);
            h1 ^= k1;
            h1 = _x86Rotl(h1, 19);
            h1 += h2;
            h1 = _x86Multiply(h1, 5) + 0x561ccd1b;
            k2 = _x86Multiply(k2, c2);
            k2 = _x86Rotl(k2, 16);
            k2 = _x86Multiply(k2, c3);
            h2 ^= k2;
            h2 = _x86Rotl(h2, 17);
            h2 += h3;
            h2 = _x86Multiply(h2, 5) + 0x0bcaa747;
            k3 = _x86Multiply(k3, c3);
            k3 = _x86Rotl(k3, 17);
            k3 = _x86Multiply(k3, c4);
            h3 ^= k3;
            h3 = _x86Rotl(h3, 15);
            h3 += h4;
            h3 = _x86Multiply(h3, 5) + 0x96cd1c35;
            k4 = _x86Multiply(k4, c4);
            k4 = _x86Rotl(k4, 18);
            k4 = _x86Multiply(k4, c1);
            h4 ^= k4;
            h4 = _x86Rotl(h4, 13);
            h4 += h1;
            h4 = _x86Multiply(h4, 5) + 0x32ac3b17;
        }
        k1 = 0;
        k2 = 0;
        k3 = 0;
        k4 = 0;
        switch(remainder){
            case 15:
                k4 ^= bytes[i + 14] << 16;
            case 14:
                k4 ^= bytes[i + 13] << 8;
            case 13:
                k4 ^= bytes[i + 12];
                k4 = _x86Multiply(k4, c4);
                k4 = _x86Rotl(k4, 18);
                k4 = _x86Multiply(k4, c1);
                h4 ^= k4;
            case 12:
                k3 ^= bytes[i + 11] << 24;
            case 11:
                k3 ^= bytes[i + 10] << 16;
            case 10:
                k3 ^= bytes[i + 9] << 8;
            case 9:
                k3 ^= bytes[i + 8];
                k3 = _x86Multiply(k3, c3);
                k3 = _x86Rotl(k3, 17);
                k3 = _x86Multiply(k3, c4);
                h3 ^= k3;
            case 8:
                k2 ^= bytes[i + 7] << 24;
            case 7:
                k2 ^= bytes[i + 6] << 16;
            case 6:
                k2 ^= bytes[i + 5] << 8;
            case 5:
                k2 ^= bytes[i + 4];
                k2 = _x86Multiply(k2, c2);
                k2 = _x86Rotl(k2, 16);
                k2 = _x86Multiply(k2, c3);
                h2 ^= k2;
            case 4:
                k1 ^= bytes[i + 3] << 24;
            case 3:
                k1 ^= bytes[i + 2] << 16;
            case 2:
                k1 ^= bytes[i + 1] << 8;
            case 1:
                k1 ^= bytes[i];
                k1 = _x86Multiply(k1, c1);
                k1 = _x86Rotl(k1, 15);
                k1 = _x86Multiply(k1, c2);
                h1 ^= k1;
        }
        h1 ^= bytes.length;
        h2 ^= bytes.length;
        h3 ^= bytes.length;
        h4 ^= bytes.length;
        h1 += h2;
        h1 += h3;
        h1 += h4;
        h2 += h1;
        h3 += h1;
        h4 += h1;
        h1 = _x86Fmix(h1);
        h2 = _x86Fmix(h2);
        h3 = _x86Fmix(h3);
        h4 = _x86Fmix(h4);
        h1 += h2;
        h1 += h3;
        h1 += h4;
        h2 += h1;
        h3 += h1;
        h4 += h1;
        return ("00000000" + (h1 >>> 0).toString(16)).slice(-8) + ("00000000" + (h2 >>> 0).toString(16)).slice(-8) + ("00000000" + (h3 >>> 0).toString(16)).slice(-8) + ("00000000" + (h4 >>> 0).toString(16)).slice(-8);
    };
    library.x64.hash128 = function(bytes, seed) {
        //
        // Given a string and an optional seed as an int, returns a 128 bit
        // hash using the x64 flavor of MurmurHash3, as an unsigned hex.
        //
        if (library.inputValidation && !_validBytes(bytes)) {
            return undefined;
        }
        seed = seed || 0;
        var remainder = bytes.length % 16;
        var blocks = bytes.length - remainder;
        var h1 = [
            0,
            seed
        ];
        var h2 = [
            0,
            seed
        ];
        var k1 = [
            0,
            0
        ];
        var k2 = [
            0,
            0
        ];
        var c1 = [
            0x87c37b91,
            0x114253d5
        ];
        var c2 = [
            0x4cf5ad43,
            0x2745937f
        ];
        for(var i = 0; i < blocks; i = i + 16){
            k1 = [
                bytes[i + 4] | bytes[i + 5] << 8 | bytes[i + 6] << 16 | bytes[i + 7] << 24,
                bytes[i] | bytes[i + 1] << 8 | bytes[i + 2] << 16 | bytes[i + 3] << 24
            ];
            k2 = [
                bytes[i + 12] | bytes[i + 13] << 8 | bytes[i + 14] << 16 | bytes[i + 15] << 24,
                bytes[i + 8] | bytes[i + 9] << 8 | bytes[i + 10] << 16 | bytes[i + 11] << 24
            ];
            k1 = _x64Multiply(k1, c1);
            k1 = _x64Rotl(k1, 31);
            k1 = _x64Multiply(k1, c2);
            h1 = _x64Xor(h1, k1);
            h1 = _x64Rotl(h1, 27);
            h1 = _x64Add(h1, h2);
            h1 = _x64Add(_x64Multiply(h1, [
                0,
                5
            ]), [
                0,
                0x52dce729
            ]);
            k2 = _x64Multiply(k2, c2);
            k2 = _x64Rotl(k2, 33);
            k2 = _x64Multiply(k2, c1);
            h2 = _x64Xor(h2, k2);
            h2 = _x64Rotl(h2, 31);
            h2 = _x64Add(h2, h1);
            h2 = _x64Add(_x64Multiply(h2, [
                0,
                5
            ]), [
                0,
                0x38495ab5
            ]);
        }
        k1 = [
            0,
            0
        ];
        k2 = [
            0,
            0
        ];
        switch(remainder){
            case 15:
                k2 = _x64Xor(k2, _x64LeftShift([
                    0,
                    bytes[i + 14]
                ], 48));
            case 14:
                k2 = _x64Xor(k2, _x64LeftShift([
                    0,
                    bytes[i + 13]
                ], 40));
            case 13:
                k2 = _x64Xor(k2, _x64LeftShift([
                    0,
                    bytes[i + 12]
                ], 32));
            case 12:
                k2 = _x64Xor(k2, _x64LeftShift([
                    0,
                    bytes[i + 11]
                ], 24));
            case 11:
                k2 = _x64Xor(k2, _x64LeftShift([
                    0,
                    bytes[i + 10]
                ], 16));
            case 10:
                k2 = _x64Xor(k2, _x64LeftShift([
                    0,
                    bytes[i + 9]
                ], 8));
            case 9:
                k2 = _x64Xor(k2, [
                    0,
                    bytes[i + 8]
                ]);
                k2 = _x64Multiply(k2, c2);
                k2 = _x64Rotl(k2, 33);
                k2 = _x64Multiply(k2, c1);
                h2 = _x64Xor(h2, k2);
            case 8:
                k1 = _x64Xor(k1, _x64LeftShift([
                    0,
                    bytes[i + 7]
                ], 56));
            case 7:
                k1 = _x64Xor(k1, _x64LeftShift([
                    0,
                    bytes[i + 6]
                ], 48));
            case 6:
                k1 = _x64Xor(k1, _x64LeftShift([
                    0,
                    bytes[i + 5]
                ], 40));
            case 5:
                k1 = _x64Xor(k1, _x64LeftShift([
                    0,
                    bytes[i + 4]
                ], 32));
            case 4:
                k1 = _x64Xor(k1, _x64LeftShift([
                    0,
                    bytes[i + 3]
                ], 24));
            case 3:
                k1 = _x64Xor(k1, _x64LeftShift([
                    0,
                    bytes[i + 2]
                ], 16));
            case 2:
                k1 = _x64Xor(k1, _x64LeftShift([
                    0,
                    bytes[i + 1]
                ], 8));
            case 1:
                k1 = _x64Xor(k1, [
                    0,
                    bytes[i]
                ]);
                k1 = _x64Multiply(k1, c1);
                k1 = _x64Rotl(k1, 31);
                k1 = _x64Multiply(k1, c2);
                h1 = _x64Xor(h1, k1);
        }
        h1 = _x64Xor(h1, [
            0,
            bytes.length
        ]);
        h2 = _x64Xor(h2, [
            0,
            bytes.length
        ]);
        h1 = _x64Add(h1, h2);
        h2 = _x64Add(h2, h1);
        h1 = _x64Fmix(h1);
        h2 = _x64Fmix(h2);
        h1 = _x64Add(h1, h2);
        h2 = _x64Add(h2, h1);
        return ("00000000" + (h1[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h1[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[1] >>> 0).toString(16)).slice(-8);
    };
    // INITIALIZATION
    // --------------
    // Export murmurHash3 for CommonJS, either as an AMD module or just as part
    // of the global object.
    if (typeof exports !== 'undefined') {
        if (("TURBOPACK compile-time value", "object") !== 'undefined' && module.exports) {
            exports = module.exports = library;
        }
        exports.murmurHash3 = library;
    } else if (typeof define === 'function' && define.amd) {
        ((r)=>r !== undefined && __turbopack_context__.v(r))(function() {
            return library;
        }());
    } else {
        // Use murmurHash3.noConflict to restore `murmurHash3` back to its
        // original value. Returns a reference to the library object, to allow
        // it to be used under a different name.
        library._murmurHash3 = root.murmurHash3;
        library.noConflict = function() {
            root.murmurHash3 = library._murmurHash3;
            library._murmurHash3 = undefined;
            library.noConflict = undefined;
            return library;
        };
        root.murmurHash3 = library;
    }
})(/*TURBOPACK member replacement*/ __turbopack_context__.e);
}),
"[project]/node_modules/murmurhash3js-revisited/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = __turbopack_context__.r("[project]/node_modules/murmurhash3js-revisited/lib/murmurHash3js.js [app-client] (ecmascript)");
}),
"[project]/node_modules/multihashing-async/src/sha.browser.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* eslint-disable require-await */ const multihash = __turbopack_context__.r("[project]/node_modules/multihashes/src/index.js [app-client] (ecmascript)");
/**
 * @typedef {import('multihashes').HashName} HashName
 * @typedef {import('./types').Digest} Digest
 */ /**
 * @type {Crypto}
 */ const crypto = self.crypto || self.msCrypto;
/**
 *
 * @param {Uint8Array} data
 * @param {HashName} alg
 * @returns {Promise<Uint8Array>}
 */ const digest = async (data, alg)=>{
    if (typeof self === 'undefined' || !crypto) {
        throw new Error('Please use a browser with webcrypto support and ensure the code has been delivered securely via HTTPS/TLS and run within a Secure Context');
    }
    switch(alg){
        case 'sha1':
            return new Uint8Array(await crypto.subtle.digest({
                name: 'SHA-1'
            }, data));
        case 'sha2-256':
            return new Uint8Array(await crypto.subtle.digest({
                name: 'SHA-256'
            }, data));
        case 'sha2-512':
            return new Uint8Array(await crypto.subtle.digest({
                name: 'SHA-512'
            }, data));
        case 'dbl-sha2-256':
            {
                const d = await crypto.subtle.digest({
                    name: 'SHA-256'
                }, data);
                return new Uint8Array(await crypto.subtle.digest({
                    name: 'SHA-256'
                }, d));
            }
        default:
            throw new Error(`${alg} is not a supported algorithm`);
    }
};
module.exports = {
    /**
   * @param {HashName} alg
   * @returns {Digest}
   */ factory: (alg)=>async (data)=>{
            return digest(data, alg);
        },
    digest,
    /**
   * @param {Uint8Array} buf
   * @param {HashName} alg
   * @param {number} [length]
   */ multihashing: async (buf, alg, length)=>{
        const h = await digest(buf, alg);
        return multihash.encode(h, alg, length);
    }
};
}),
"[project]/node_modules/multihashing-async/src/utils.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * @param {number} number
 * @returns {Uint8Array}
 */ const fromNumberTo32BitBuf = (number)=>{
    const bytes = new Uint8Array(4);
    for(let i = 0; i < 4; i++){
        bytes[i] = number & 0xff;
        number = number >> 8;
    }
    return bytes;
};
module.exports = {
    fromNumberTo32BitBuf
};
}),
"[project]/node_modules/multihashing-async/src/blake.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// @ts-ignore - no types available
const blake = __turbopack_context__.r("[project]/node_modules/blakejs/index.js [app-client] (ecmascript)");
const minB = 0xb201;
const minS = 0xb241;
const blake2b = {
    init: blake.blake2bInit,
    update: blake.blake2bUpdate,
    digest: blake.blake2bFinal
};
const blake2s = {
    init: blake.blake2sInit,
    update: blake.blake2sUpdate,
    digest: blake.blake2sFinal
};
// Note that although this function doesn't do any asynchronous work, we mark
// the function as async because it must return a Promise to match the API
// for other functions that do perform asynchronous work (see sha.browser.js)
// eslint-disable-next-line
/**
 * @param {number} size
 * @param {any} hf
 * @returns {import('./types').Digest}
 */ const makeB2Hash = (size, hf)=>async (data)=>{
        const ctx = hf.init(size, null);
        hf.update(ctx, data);
        return hf.digest(ctx);
    };
/**
 * @param {Record<number, import('./types').Digest>} table
 */ module.exports = (table)=>{
    for(let i = 0; i < 64; i++){
        table[minB + i] = makeB2Hash(i + 1, blake2b);
    }
    for(let i = 0; i < 32; i++){
        table[minS + i] = makeB2Hash(i + 1, blake2s);
    }
};
}),
"[project]/node_modules/multihashing-async/src/crypto.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const sha3 = __turbopack_context__.r("[project]/node_modules/js-sha3/src/sha3.js [app-client] (ecmascript)");
// @ts-ignore - no types available
const mur = __turbopack_context__.r("[project]/node_modules/murmurhash3js-revisited/index.js [app-client] (ecmascript)");
const { factory: sha } = __turbopack_context__.r("[project]/node_modules/multihashing-async/src/sha.browser.js [app-client] (ecmascript)");
const { fromNumberTo32BitBuf } = __turbopack_context__.r("[project]/node_modules/multihashing-async/src/utils.js [app-client] (ecmascript)");
const { fromString: uint8ArrayFromString } = __turbopack_context__.r("[project]/node_modules/uint8arrays/esm/src/from-string.js [app-client] (ecmascript)");
// Note that although this function doesn't do any asynchronous work, we mark
// the function as async because it must return a Promise to match the API
// for other functions that do perform asynchronous work (see sha.browser.js)
// eslint-disable-next-line
/**
 * @param {string} algorithm
 * @returns {import('./types').Digest}
 */ const hash = (algorithm)=>async (data)=>{
        switch(algorithm){
            case 'sha3-224':
                return new Uint8Array(sha3.sha3_224.arrayBuffer(data));
            case 'sha3-256':
                return new Uint8Array(sha3.sha3_256.arrayBuffer(data));
            case 'sha3-384':
                return new Uint8Array(sha3.sha3_384.arrayBuffer(data));
            case 'sha3-512':
                return new Uint8Array(sha3.sha3_512.arrayBuffer(data));
            case 'shake-128':
                return new Uint8Array(sha3.shake128.create(128).update(data).arrayBuffer());
            case 'shake-256':
                return new Uint8Array(sha3.shake256.create(256).update(data).arrayBuffer());
            case 'keccak-224':
                return new Uint8Array(sha3.keccak224.arrayBuffer(data));
            case 'keccak-256':
                return new Uint8Array(sha3.keccak256.arrayBuffer(data));
            case 'keccak-384':
                return new Uint8Array(sha3.keccak384.arrayBuffer(data));
            case 'keccak-512':
                return new Uint8Array(sha3.keccak512.arrayBuffer(data));
            case 'murmur3-128':
                return uint8ArrayFromString(mur.x64.hash128(data), 'base16');
            case 'murmur3-32':
                return fromNumberTo32BitBuf(mur.x86.hash32(data));
            default:
                throw new TypeError(`${algorithm} is not a supported algorithm`);
        }
    };
/** @type {import('./types').Digest} */ const identity = (data)=>data;
module.exports = {
    identity,
    sha1: sha('sha1'),
    sha2256: sha('sha2-256'),
    sha2512: sha('sha2-512'),
    dblSha2256: sha('dbl-sha2-256'),
    sha3224: hash('sha3-224'),
    sha3256: hash('sha3-256'),
    sha3384: hash('sha3-384'),
    sha3512: hash('sha3-512'),
    shake128: hash('shake-128'),
    shake256: hash('shake-256'),
    keccak224: hash('keccak-224'),
    keccak256: hash('keccak-256'),
    keccak384: hash('keccak-384'),
    keccak512: hash('keccak-512'),
    murmur3128: hash('murmur3-128'),
    murmur332: hash('murmur3-32'),
    addBlake: __turbopack_context__.r("[project]/node_modules/multihashing-async/src/blake.js [app-client] (ecmascript)")
};
}),
"[project]/node_modules/multihashing-async/src/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const errcode = __turbopack_context__.r("[project]/node_modules/err-code/index.js [app-client] (ecmascript)");
const multihash = __turbopack_context__.r("[project]/node_modules/multihashes/src/index.js [app-client] (ecmascript)");
const crypto = __turbopack_context__.r("[project]/node_modules/multihashing-async/src/crypto.js [app-client] (ecmascript)");
const { equals } = __turbopack_context__.r("[project]/node_modules/uint8arrays/esm/src/equals.js [app-client] (ecmascript)");
/**
 * @typedef {import("./types").Digest} Digest
 * @typedef {import("multihashes").HashName} HashName
 */ /**
 * Hash the given `bytes` using the algorithm specified by `alg`.
 *
 * @param {Uint8Array} bytes - The value to hash.
 * @param {HashName} alg - The algorithm to use eg 'sha1'
 * @param {number} [length] - Optionally trim the result to this length.
 * @returns {Promise<Uint8Array>}
 */ async function Multihashing(bytes, alg, length) {
    const digest = await Multihashing.digest(bytes, alg, length);
    return multihash.encode(digest, alg, length);
}
/**
 * Expose multihash itself, to avoid silly double requires.
 */ Multihashing.multihash = multihash;
/**
 * @param {Uint8Array} bytes - The value to hash.
 * @param {HashName} alg - The algorithm to use eg 'sha1'
 * @param {number} [length] - Optionally trim the result to this length.
 * @returns {Promise<Uint8Array>}
 */ Multihashing.digest = async (bytes, alg, length)=>{
    const hash = Multihashing.createHash(alg);
    const digest = await hash(bytes);
    return length ? digest.slice(0, length) : digest;
};
/**
 * Creates a function that hashes with the given algorithm
 *
 * @param {HashName} alg - The algorithm to use eg 'sha1'
 * @returns {Digest} - The hash function corresponding to `alg`
 */ Multihashing.createHash = function(alg) {
    if (!alg) {
        const e = errcode(new Error('hash algorithm must be specified'), 'ERR_HASH_ALGORITHM_NOT_SPECIFIED');
        throw e;
    }
    const code = multihash.coerceCode(alg);
    if (!Multihashing.functions[code]) {
        throw errcode(new Error(`multihash function '${alg}' not yet supported`), 'ERR_HASH_ALGORITHM_NOT_SUPPORTED');
    }
    return Multihashing.functions[code];
};
/**
 * Mapping of multihash codes to their hashing functions.
 *
 * @type {Record<number, Digest>}
 */ // @ts-ignore - most of those functions aren't typed
Multihashing.functions = {
    // identity
    0x00: crypto.identity,
    // sha1
    0x11: crypto.sha1,
    // sha2-256
    0x12: crypto.sha2256,
    // sha2-512
    0x13: crypto.sha2512,
    // sha3-512
    0x14: crypto.sha3512,
    // sha3-384
    0x15: crypto.sha3384,
    // sha3-256
    0x16: crypto.sha3256,
    // sha3-224
    0x17: crypto.sha3224,
    // shake-128
    0x18: crypto.shake128,
    // shake-256
    0x19: crypto.shake256,
    // keccak-224
    0x1A: crypto.keccak224,
    // keccak-256
    0x1B: crypto.keccak256,
    // keccak-384
    0x1C: crypto.keccak384,
    // keccak-512
    0x1D: crypto.keccak512,
    // murmur3-128
    0x22: crypto.murmur3128,
    // murmur3-32
    0x23: crypto.murmur332,
    // dbl-sha2-256
    0x56: crypto.dblSha2256
};
// add blake functions
crypto.addBlake(Multihashing.functions);
/**
 * @param {Uint8Array} bytes
 * @param {Uint8Array} hash
 * @returns {Promise<boolean>}
 */ Multihashing.validate = async (bytes, hash)=>{
    const newHash = await Multihashing(bytes, multihash.decode(hash).name);
    return equals(hash, newHash);
};
module.exports = Multihashing;
}),
"[project]/node_modules/blakejs/util.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

const ERROR_MSG_INPUT = 'Input must be an string, Buffer or Uint8Array';
// For convenience, let people hash a string, not just a Uint8Array
function normalizeInput(input) {
    let ret;
    if (input instanceof Uint8Array) {
        ret = input;
    } else if (typeof input === 'string') {
        const encoder = new TextEncoder();
        ret = encoder.encode(input);
    } else {
        throw new Error(ERROR_MSG_INPUT);
    }
    return ret;
}
// Converts a Uint8Array to a hexadecimal string
// For example, toHex([255, 0, 255]) returns "ff00ff"
function toHex(bytes) {
    return Array.prototype.map.call(bytes, function(n) {
        return (n < 16 ? '0' : '') + n.toString(16);
    }).join('');
}
// Converts any value in [0...2^32-1] to an 8-character hex string
function uint32ToHex(val) {
    return (0x100000000 + val).toString(16).substring(1);
}
// For debugging: prints out hash state in the same format as the RFC
// sample computation exactly, so that you can diff
function debugPrint(label, arr, size) {
    let msg = '\n' + label + ' = ';
    for(let i = 0; i < arr.length; i += 2){
        if (size === 32) {
            msg += uint32ToHex(arr[i]).toUpperCase();
            msg += ' ';
            msg += uint32ToHex(arr[i + 1]).toUpperCase();
        } else if (size === 64) {
            msg += uint32ToHex(arr[i + 1]).toUpperCase();
            msg += uint32ToHex(arr[i]).toUpperCase();
        } else throw new Error('Invalid size ' + size);
        if (i % 6 === 4) {
            msg += '\n' + new Array(label.length + 4).join(' ');
        } else if (i < arr.length - 2) {
            msg += ' ';
        }
    }
    console.log(msg);
}
// For performance testing: generates N bytes of input, hashes M times
// Measures and prints MB/second hash performance each time
function testSpeed(hashFn, N, M) {
    let startMs = new Date().getTime();
    const input = new Uint8Array(N);
    for(let i = 0; i < N; i++){
        input[i] = i % 256;
    }
    const genMs = new Date().getTime();
    console.log('Generated random input in ' + (genMs - startMs) + 'ms');
    startMs = genMs;
    for(let i = 0; i < M; i++){
        const hashHex = hashFn(input);
        const hashMs = new Date().getTime();
        const ms = hashMs - startMs;
        startMs = hashMs;
        console.log('Hashed in ' + ms + 'ms: ' + hashHex.substring(0, 20) + '...');
        console.log(Math.round(N / (1 << 20) / (ms / 1000) * 100) / 100 + ' MB PER SECOND');
    }
}
module.exports = {
    normalizeInput: normalizeInput,
    toHex: toHex,
    debugPrint: debugPrint,
    testSpeed: testSpeed
};
}),
"[project]/node_modules/blakejs/blake2b.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

// Blake2B in pure Javascript
// Adapted from the reference implementation in RFC7693
// Ported to Javascript by DC - https://github.com/dcposch
const util = __turbopack_context__.r("[project]/node_modules/blakejs/util.js [app-client] (ecmascript)");
// 64-bit unsigned addition
// Sets v[a,a+1] += v[b,b+1]
// v should be a Uint32Array
function ADD64AA(v, a, b) {
    const o0 = v[a] + v[b];
    let o1 = v[a + 1] + v[b + 1];
    if (o0 >= 0x100000000) {
        o1++;
    }
    v[a] = o0;
    v[a + 1] = o1;
}
// 64-bit unsigned addition
// Sets v[a,a+1] += b
// b0 is the low 32 bits of b, b1 represents the high 32 bits
function ADD64AC(v, a, b0, b1) {
    let o0 = v[a] + b0;
    if (b0 < 0) {
        o0 += 0x100000000;
    }
    let o1 = v[a + 1] + b1;
    if (o0 >= 0x100000000) {
        o1++;
    }
    v[a] = o0;
    v[a + 1] = o1;
}
// Little-endian byte access
function B2B_GET32(arr, i) {
    return arr[i] ^ arr[i + 1] << 8 ^ arr[i + 2] << 16 ^ arr[i + 3] << 24;
}
// G Mixing function
// The ROTRs are inlined for speed
function B2B_G(a, b, c, d, ix, iy) {
    const x0 = m[ix];
    const x1 = m[ix + 1];
    const y0 = m[iy];
    const y1 = m[iy + 1];
    ADD64AA(v, a, b); // v[a,a+1] += v[b,b+1] ... in JS we must store a uint64 as two uint32s
    ADD64AC(v, a, x0, x1); // v[a, a+1] += x ... x0 is the low 32 bits of x, x1 is the high 32 bits
    // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated to the right by 32 bits
    let xor0 = v[d] ^ v[a];
    let xor1 = v[d + 1] ^ v[a + 1];
    v[d] = xor1;
    v[d + 1] = xor0;
    ADD64AA(v, c, d);
    // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 24 bits
    xor0 = v[b] ^ v[c];
    xor1 = v[b + 1] ^ v[c + 1];
    v[b] = xor0 >>> 24 ^ xor1 << 8;
    v[b + 1] = xor1 >>> 24 ^ xor0 << 8;
    ADD64AA(v, a, b);
    ADD64AC(v, a, y0, y1);
    // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated right by 16 bits
    xor0 = v[d] ^ v[a];
    xor1 = v[d + 1] ^ v[a + 1];
    v[d] = xor0 >>> 16 ^ xor1 << 16;
    v[d + 1] = xor1 >>> 16 ^ xor0 << 16;
    ADD64AA(v, c, d);
    // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 63 bits
    xor0 = v[b] ^ v[c];
    xor1 = v[b + 1] ^ v[c + 1];
    v[b] = xor1 >>> 31 ^ xor0 << 1;
    v[b + 1] = xor0 >>> 31 ^ xor1 << 1;
}
// Initialization Vector
const BLAKE2B_IV32 = new Uint32Array([
    0xf3bcc908,
    0x6a09e667,
    0x84caa73b,
    0xbb67ae85,
    0xfe94f82b,
    0x3c6ef372,
    0x5f1d36f1,
    0xa54ff53a,
    0xade682d1,
    0x510e527f,
    0x2b3e6c1f,
    0x9b05688c,
    0xfb41bd6b,
    0x1f83d9ab,
    0x137e2179,
    0x5be0cd19
]);
const SIGMA8 = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3,
    11,
    8,
    12,
    0,
    5,
    2,
    15,
    13,
    10,
    14,
    3,
    6,
    7,
    1,
    9,
    4,
    7,
    9,
    3,
    1,
    13,
    12,
    11,
    14,
    2,
    6,
    5,
    10,
    4,
    0,
    15,
    8,
    9,
    0,
    5,
    7,
    2,
    4,
    10,
    15,
    14,
    1,
    11,
    12,
    6,
    8,
    3,
    13,
    2,
    12,
    6,
    10,
    0,
    11,
    8,
    3,
    4,
    13,
    7,
    5,
    15,
    14,
    1,
    9,
    12,
    5,
    1,
    15,
    14,
    13,
    4,
    10,
    0,
    7,
    6,
    3,
    9,
    2,
    8,
    11,
    13,
    11,
    7,
    14,
    12,
    1,
    3,
    9,
    5,
    0,
    15,
    4,
    8,
    6,
    2,
    10,
    6,
    15,
    14,
    9,
    11,
    3,
    0,
    8,
    12,
    2,
    13,
    7,
    1,
    4,
    10,
    5,
    10,
    2,
    8,
    4,
    7,
    6,
    1,
    5,
    15,
    11,
    9,
    14,
    3,
    12,
    13,
    0,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3
];
// These are offsets into a uint64 buffer.
// Multiply them all by 2 to make them offsets into a uint32 buffer,
// because this is Javascript and we don't have uint64s
const SIGMA82 = new Uint8Array(SIGMA8.map(function(x) {
    return x * 2;
}));
// Compression function. 'last' flag indicates last block.
// Note we're representing 16 uint64s as 32 uint32s
const v = new Uint32Array(32);
const m = new Uint32Array(32);
function blake2bCompress(ctx, last) {
    let i = 0;
    // init work variables
    for(i = 0; i < 16; i++){
        v[i] = ctx.h[i];
        v[i + 16] = BLAKE2B_IV32[i];
    }
    // low 64 bits of offset
    v[24] = v[24] ^ ctx.t;
    v[25] = v[25] ^ ctx.t / 0x100000000;
    // high 64 bits not supported, offset may not be higher than 2**53-1
    // last block flag set ?
    if (last) {
        v[28] = ~v[28];
        v[29] = ~v[29];
    }
    // get little-endian words
    for(i = 0; i < 32; i++){
        m[i] = B2B_GET32(ctx.b, 4 * i);
    }
    // twelve rounds of mixing
    // uncomment the DebugPrint calls to log the computation
    // and match the RFC sample documentation
    // util.debugPrint('          m[16]', m, 64)
    for(i = 0; i < 12; i++){
        // util.debugPrint('   (i=' + (i < 10 ? ' ' : '') + i + ') v[16]', v, 64)
        B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1]);
        B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3]);
        B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5]);
        B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7]);
        B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9]);
        B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11]);
        B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13]);
        B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15]);
    }
    // util.debugPrint('   (i=12) v[16]', v, 64)
    for(i = 0; i < 16; i++){
        ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16];
    }
// util.debugPrint('h[8]', ctx.h, 64)
}
// reusable parameterBlock
const parameterBlock = new Uint8Array([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0 // 60: personal
]);
// Creates a BLAKE2b hashing context
// Requires an output length between 1 and 64 bytes
// Takes an optional Uint8Array key
// Takes an optinal Uint8Array salt
// Takes an optinal Uint8Array personal
function blake2bInit(outlen, key, salt, personal) {
    if (outlen === 0 || outlen > 64) {
        throw new Error('Illegal output length, expected 0 < length <= 64');
    }
    if (key && key.length > 64) {
        throw new Error('Illegal key, expected Uint8Array with 0 < length <= 64');
    }
    if (salt && salt.length !== 16) {
        throw new Error('Illegal salt, expected Uint8Array with length is 16');
    }
    if (personal && personal.length !== 16) {
        throw new Error('Illegal personal, expected Uint8Array with length is 16');
    }
    // state, 'param block'
    const ctx = {
        b: new Uint8Array(128),
        h: new Uint32Array(16),
        t: 0,
        c: 0,
        outlen: outlen // output length in bytes
    };
    // initialize parameterBlock before usage
    parameterBlock.fill(0);
    parameterBlock[0] = outlen;
    if (key) parameterBlock[1] = key.length;
    parameterBlock[2] = 1; // fanout
    parameterBlock[3] = 1; // depth
    if (salt) parameterBlock.set(salt, 32);
    if (personal) parameterBlock.set(personal, 48);
    // initialize hash state
    for(let i = 0; i < 16; i++){
        ctx.h[i] = BLAKE2B_IV32[i] ^ B2B_GET32(parameterBlock, i * 4);
    }
    // key the hash, if applicable
    if (key) {
        blake2bUpdate(ctx, key);
        // at the end
        ctx.c = 128;
    }
    return ctx;
}
// Updates a BLAKE2b streaming hash
// Requires hash context and Uint8Array (byte array)
function blake2bUpdate(ctx, input) {
    for(let i = 0; i < input.length; i++){
        if (ctx.c === 128) {
            // buffer full ?
            ctx.t += ctx.c; // add counters
            blake2bCompress(ctx, false); // compress (not last)
            ctx.c = 0; // counter to zero
        }
        ctx.b[ctx.c++] = input[i];
    }
}
// Completes a BLAKE2b streaming hash
// Returns a Uint8Array containing the message digest
function blake2bFinal(ctx) {
    ctx.t += ctx.c; // mark last block offset
    while(ctx.c < 128){
        // fill up with zeros
        ctx.b[ctx.c++] = 0;
    }
    blake2bCompress(ctx, true); // final block flag = 1
    // little endian convert and store
    const out = new Uint8Array(ctx.outlen);
    for(let i = 0; i < ctx.outlen; i++){
        out[i] = ctx.h[i >> 2] >> 8 * (i & 3);
    }
    return out;
}
// Computes the BLAKE2B hash of a string or byte array, and returns a Uint8Array
//
// Returns a n-byte Uint8Array
//
// Parameters:
// - input - the input bytes, as a string, Buffer or Uint8Array
// - key - optional key Uint8Array, up to 64 bytes
// - outlen - optional output length in bytes, default 64
// - salt - optional salt bytes, string, Buffer or Uint8Array
// - personal - optional personal bytes, string, Buffer or Uint8Array
function blake2b(input, key, outlen, salt, personal) {
    // preprocess inputs
    outlen = outlen || 64;
    input = util.normalizeInput(input);
    if (salt) {
        salt = util.normalizeInput(salt);
    }
    if (personal) {
        personal = util.normalizeInput(personal);
    }
    // do the math
    const ctx = blake2bInit(outlen, key, salt, personal);
    blake2bUpdate(ctx, input);
    return blake2bFinal(ctx);
}
// Computes the BLAKE2B hash of a string or byte array
//
// Returns an n-byte hash in hex, all lowercase
//
// Parameters:
// - input - the input bytes, as a string, Buffer, or Uint8Array
// - key - optional key Uint8Array, up to 64 bytes
// - outlen - optional output length in bytes, default 64
// - salt - optional salt bytes, string, Buffer or Uint8Array
// - personal - optional personal bytes, string, Buffer or Uint8Array
function blake2bHex(input, key, outlen, salt, personal) {
    const output = blake2b(input, key, outlen, salt, personal);
    return util.toHex(output);
}
module.exports = {
    blake2b: blake2b,
    blake2bHex: blake2bHex,
    blake2bInit: blake2bInit,
    blake2bUpdate: blake2bUpdate,
    blake2bFinal: blake2bFinal
};
}),
"[project]/node_modules/blakejs/blake2s.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

// BLAKE2s hash function in pure Javascript
// Adapted from the reference implementation in RFC7693
// Ported to Javascript by DC - https://github.com/dcposch
const util = __turbopack_context__.r("[project]/node_modules/blakejs/util.js [app-client] (ecmascript)");
// Little-endian byte access.
// Expects a Uint8Array and an index
// Returns the little-endian uint32 at v[i..i+3]
function B2S_GET32(v, i) {
    return v[i] ^ v[i + 1] << 8 ^ v[i + 2] << 16 ^ v[i + 3] << 24;
}
// Mixing function G.
function B2S_G(a, b, c, d, x, y) {
    v[a] = v[a] + v[b] + x;
    v[d] = ROTR32(v[d] ^ v[a], 16);
    v[c] = v[c] + v[d];
    v[b] = ROTR32(v[b] ^ v[c], 12);
    v[a] = v[a] + v[b] + y;
    v[d] = ROTR32(v[d] ^ v[a], 8);
    v[c] = v[c] + v[d];
    v[b] = ROTR32(v[b] ^ v[c], 7);
}
// 32-bit right rotation
// x should be a uint32
// y must be between 1 and 31, inclusive
function ROTR32(x, y) {
    return x >>> y ^ x << 32 - y;
}
// Initialization Vector.
const BLAKE2S_IV = new Uint32Array([
    0x6a09e667,
    0xbb67ae85,
    0x3c6ef372,
    0xa54ff53a,
    0x510e527f,
    0x9b05688c,
    0x1f83d9ab,
    0x5be0cd19
]);
const SIGMA = new Uint8Array([
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3,
    11,
    8,
    12,
    0,
    5,
    2,
    15,
    13,
    10,
    14,
    3,
    6,
    7,
    1,
    9,
    4,
    7,
    9,
    3,
    1,
    13,
    12,
    11,
    14,
    2,
    6,
    5,
    10,
    4,
    0,
    15,
    8,
    9,
    0,
    5,
    7,
    2,
    4,
    10,
    15,
    14,
    1,
    11,
    12,
    6,
    8,
    3,
    13,
    2,
    12,
    6,
    10,
    0,
    11,
    8,
    3,
    4,
    13,
    7,
    5,
    15,
    14,
    1,
    9,
    12,
    5,
    1,
    15,
    14,
    13,
    4,
    10,
    0,
    7,
    6,
    3,
    9,
    2,
    8,
    11,
    13,
    11,
    7,
    14,
    12,
    1,
    3,
    9,
    5,
    0,
    15,
    4,
    8,
    6,
    2,
    10,
    6,
    15,
    14,
    9,
    11,
    3,
    0,
    8,
    12,
    2,
    13,
    7,
    1,
    4,
    10,
    5,
    10,
    2,
    8,
    4,
    7,
    6,
    1,
    5,
    15,
    11,
    9,
    14,
    3,
    12,
    13,
    0
]);
// Compression function. "last" flag indicates last block
const v = new Uint32Array(16);
const m = new Uint32Array(16);
function blake2sCompress(ctx, last) {
    let i = 0;
    for(i = 0; i < 8; i++){
        // init work variables
        v[i] = ctx.h[i];
        v[i + 8] = BLAKE2S_IV[i];
    }
    v[12] ^= ctx.t; // low 32 bits of offset
    v[13] ^= ctx.t / 0x100000000; // high 32 bits
    if (last) {
        // last block flag set ?
        v[14] = ~v[14];
    }
    for(i = 0; i < 16; i++){
        // get little-endian words
        m[i] = B2S_GET32(ctx.b, 4 * i);
    }
    // ten rounds of mixing
    // uncomment the DebugPrint calls to log the computation
    // and match the RFC sample documentation
    // util.debugPrint('          m[16]', m, 32)
    for(i = 0; i < 10; i++){
        // util.debugPrint('   (i=' + i + ')  v[16]', v, 32)
        B2S_G(0, 4, 8, 12, m[SIGMA[i * 16 + 0]], m[SIGMA[i * 16 + 1]]);
        B2S_G(1, 5, 9, 13, m[SIGMA[i * 16 + 2]], m[SIGMA[i * 16 + 3]]);
        B2S_G(2, 6, 10, 14, m[SIGMA[i * 16 + 4]], m[SIGMA[i * 16 + 5]]);
        B2S_G(3, 7, 11, 15, m[SIGMA[i * 16 + 6]], m[SIGMA[i * 16 + 7]]);
        B2S_G(0, 5, 10, 15, m[SIGMA[i * 16 + 8]], m[SIGMA[i * 16 + 9]]);
        B2S_G(1, 6, 11, 12, m[SIGMA[i * 16 + 10]], m[SIGMA[i * 16 + 11]]);
        B2S_G(2, 7, 8, 13, m[SIGMA[i * 16 + 12]], m[SIGMA[i * 16 + 13]]);
        B2S_G(3, 4, 9, 14, m[SIGMA[i * 16 + 14]], m[SIGMA[i * 16 + 15]]);
    }
    // util.debugPrint('   (i=10) v[16]', v, 32)
    for(i = 0; i < 8; i++){
        ctx.h[i] ^= v[i] ^ v[i + 8];
    }
// util.debugPrint('h[8]', ctx.h, 32)
}
// Creates a BLAKE2s hashing context
// Requires an output length between 1 and 32 bytes
// Takes an optional Uint8Array key
function blake2sInit(outlen, key) {
    if (!(outlen > 0 && outlen <= 32)) {
        throw new Error('Incorrect output length, should be in [1, 32]');
    }
    const keylen = key ? key.length : 0;
    if (key && !(keylen > 0 && keylen <= 32)) {
        throw new Error('Incorrect key length, should be in [1, 32]');
    }
    const ctx = {
        h: new Uint32Array(BLAKE2S_IV),
        b: new Uint8Array(64),
        c: 0,
        t: 0,
        outlen: outlen // output length in bytes
    };
    ctx.h[0] ^= 0x01010000 ^ keylen << 8 ^ outlen;
    if (keylen > 0) {
        blake2sUpdate(ctx, key);
        ctx.c = 64; // at the end
    }
    return ctx;
}
// Updates a BLAKE2s streaming hash
// Requires hash context and Uint8Array (byte array)
function blake2sUpdate(ctx, input) {
    for(let i = 0; i < input.length; i++){
        if (ctx.c === 64) {
            // buffer full ?
            ctx.t += ctx.c; // add counters
            blake2sCompress(ctx, false); // compress (not last)
            ctx.c = 0; // counter to zero
        }
        ctx.b[ctx.c++] = input[i];
    }
}
// Completes a BLAKE2s streaming hash
// Returns a Uint8Array containing the message digest
function blake2sFinal(ctx) {
    ctx.t += ctx.c; // mark last block offset
    while(ctx.c < 64){
        // fill up with zeros
        ctx.b[ctx.c++] = 0;
    }
    blake2sCompress(ctx, true); // final block flag = 1
    // little endian convert and store
    const out = new Uint8Array(ctx.outlen);
    for(let i = 0; i < ctx.outlen; i++){
        out[i] = ctx.h[i >> 2] >> 8 * (i & 3) & 0xff;
    }
    return out;
}
// Computes the BLAKE2S hash of a string or byte array, and returns a Uint8Array
//
// Returns a n-byte Uint8Array
//
// Parameters:
// - input - the input bytes, as a string, Buffer, or Uint8Array
// - key - optional key Uint8Array, up to 32 bytes
// - outlen - optional output length in bytes, default 64
function blake2s(input, key, outlen) {
    // preprocess inputs
    outlen = outlen || 32;
    input = util.normalizeInput(input);
    // do the math
    const ctx = blake2sInit(outlen, key);
    blake2sUpdate(ctx, input);
    return blake2sFinal(ctx);
}
// Computes the BLAKE2S hash of a string or byte array
//
// Returns an n-byte hash in hex, all lowercase
//
// Parameters:
// - input - the input bytes, as a string, Buffer, or Uint8Array
// - key - optional key Uint8Array, up to 32 bytes
// - outlen - optional output length in bytes, default 64
function blake2sHex(input, key, outlen) {
    const output = blake2s(input, key, outlen);
    return util.toHex(output);
}
module.exports = {
    blake2s: blake2s,
    blake2sHex: blake2sHex,
    blake2sInit: blake2sInit,
    blake2sUpdate: blake2sUpdate,
    blake2sFinal: blake2sFinal
};
}),
"[project]/node_modules/blakejs/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

const b2b = __turbopack_context__.r("[project]/node_modules/blakejs/blake2b.js [app-client] (ecmascript)");
const b2s = __turbopack_context__.r("[project]/node_modules/blakejs/blake2s.js [app-client] (ecmascript)");
module.exports = {
    blake2b: b2b.blake2b,
    blake2bHex: b2b.blake2bHex,
    blake2bInit: b2b.blake2bInit,
    blake2bUpdate: b2b.blake2bUpdate,
    blake2bFinal: b2b.blake2bFinal,
    blake2s: b2s.blake2s,
    blake2sHex: b2s.blake2sHex,
    blake2sInit: b2s.blake2sInit,
    blake2sUpdate: b2s.blake2sUpdate,
    blake2sFinal: b2s.blake2sFinal
};
}),
"[project]/node_modules/@protobufjs/aspromise/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = asPromise;
/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */ /**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */ function asPromise(fn, ctx /*, varargs */ ) {
    var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
    while(index < arguments.length)params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err /*, varargs */ ) {
            if (pending) {
                pending = false;
                if (err) reject(err);
                else {
                    var params = new Array(arguments.length - 1), offset = 0;
                    while(offset < params.length)params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}
}),
"[project]/node_modules/@protobufjs/base64/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */ var base64 = exports;
/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */ base64.length = function length(string) {
    var p = string.length;
    if (!p) return 0;
    var n = 0;
    while(--p % 4 > 1 && string.charAt(p) === "=")++n;
    return Math.ceil(string.length * 3) / 4 - n;
};
// Base64 encoding table
var b64 = new Array(64);
// Base64 decoding table
var s64 = new Array(123);
// 65..90, 97..122, 48..57, 43, 47
for(var i = 0; i < 64;)s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */ base64.encode = function encode(buffer, start, end) {
    var parts = null, chunk = [];
    var i = 0, j = 0, t; // temporary
    while(start < end){
        var b = buffer[start++];
        switch(j){
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1) chunk[i++] = 61;
    }
    if (parts) {
        if (i) parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};
var invalidEncoding = "invalid encoding";
/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */ base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, t; // temporary
    for(var i = 0; i < string.length;){
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1) break;
        if ((c = s64[c]) === undefined) throw Error(invalidEncoding);
        switch(j){
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1) throw Error(invalidEncoding);
    return offset - start;
};
/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */ base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};
}),
"[project]/node_modules/@protobufjs/eventemitter/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = EventEmitter;
/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */ function EventEmitter() {
    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */ this._listeners = {};
}
/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */ EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn: fn,
        ctx: ctx || this
    });
    return this;
};
/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */ EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined) this._listeners = {};
    else {
        if (fn === undefined) this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for(var i = 0; i < listeners.length;)if (listeners[i].fn === fn) listeners.splice(i, 1);
            else ++i;
        }
    }
    return this;
};
/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */ EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [], i = 1;
        for(; i < arguments.length;)args.push(arguments[i++]);
        for(i = 0; i < listeners.length;)listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};
}),
"[project]/node_modules/@protobufjs/float/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = factory(factory);
/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */ /**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */ /**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */ /**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */ /**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */ /**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */ /**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */ /**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */ /**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */ // Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {
    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {
        var f32 = new Float32Array([
            -0
        ]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }
        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }
        /* istanbul ignore next */ exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */ exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }
        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }
        /* istanbul ignore next */ exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */ exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
    // float: ieee754
    })();
    else (function() {
        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign) val = -val;
            if (val === 0) writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val)) writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }
        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 // denormal
             ? sign * 1.401298464324817e-45 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }
        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
    })();
    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {
        var f64 = new Float64Array([
            -0
        ]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }
        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }
        /* istanbul ignore next */ exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */ exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }
        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }
        /* istanbul ignore next */ exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */ exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
    // double: ieee754
    })();
    else (function() {
        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign) val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) {
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) {
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024) exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }
        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 // denormal
             ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }
        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
    })();
    return exports;
}
// uint helpers
function writeUintLE(val, buf, pos) {
    buf[pos] = val & 255;
    buf[pos + 1] = val >>> 8 & 255;
    buf[pos + 2] = val >>> 16 & 255;
    buf[pos + 3] = val >>> 24;
}
function writeUintBE(val, buf, pos) {
    buf[pos] = val >>> 24;
    buf[pos + 1] = val >>> 16 & 255;
    buf[pos + 2] = val >>> 8 & 255;
    buf[pos + 3] = val & 255;
}
function readUintLE(buf, pos) {
    return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
}
function readUintBE(buf, pos) {
    return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
}
}),
"[project]/node_modules/@protobufjs/inquire/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = inquire;
/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */ function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length)) return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}
}),
"[project]/node_modules/@protobufjs/utf8/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */ var utf8 = exports;
/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */ utf8.length = function utf8_length(string) {
    var len = 0, c = 0;
    for(var i = 0; i < string.length; ++i){
        c = string.charCodeAt(i);
        if (c < 128) len += 1;
        else if (c < 2048) len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else len += 3;
    }
    return len;
};
/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */ utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1) return "";
    var parts = null, chunk = [], i = 0, t; // temporary
    while(start < end){
        t = buffer[start++];
        if (t < 128) chunk[i++] = t;
        else if (t > 191 && t < 224) chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i) parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};
/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */ utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset, c1, c2; // character 2
    for(var i = 0; i < string.length; ++i){
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6 | 192;
            buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18 | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6 & 63 | 128;
            buffer[offset++] = c1 & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12 | 224;
            buffer[offset++] = c1 >> 6 & 63 | 128;
            buffer[offset++] = c1 & 63 | 128;
        }
    }
    return offset - start;
};
}),
"[project]/node_modules/@protobufjs/pool/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = pool;
/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */ /**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */ /**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */ function pool(alloc, slice, size) {
    var SIZE = size || 8192;
    var MAX = SIZE >>> 1;
    var slab = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX) return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) offset = (offset | 7) + 1;
        return buf;
    };
}
}),
"[project]/node_modules/protobufjs/src/util/longbits.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = LongBits;
var util = __turbopack_context__.r("[project]/node_modules/protobufjs/src/util/minimal.js [app-client] (ecmascript)");
/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */ function LongBits(lo, hi) {
    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.
    /**
     * Low bits.
     * @type {number}
     */ this.lo = lo >>> 0;
    /**
     * High bits.
     * @type {number}
     */ this.hi = hi >>> 0;
}
/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */ var zero = LongBits.zero = new LongBits(0, 0);
zero.toNumber = function() {
    return 0;
};
zero.zzEncode = zero.zzDecode = function() {
    return this;
};
zero.length = function() {
    return 1;
};
/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */ var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */ LongBits.fromNumber = function fromNumber(value) {
    if (value === 0) return zero;
    var sign = value < 0;
    if (sign) value = -value;
    var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295) hi = 0;
        }
    }
    return new LongBits(lo, hi);
};
/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */ LongBits.from = function from(value) {
    if (typeof value === "number") return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */ if (util.Long) value = util.Long.fromString(value);
        else return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};
/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */ LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo) hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};
/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */ LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : {
        low: this.lo | 0,
        high: this.hi | 0,
        unsigned: Boolean(unsigned)
    };
};
var charCodeAt = String.prototype.charCodeAt;
/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */ LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash) return zero;
    return new LongBits((charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0, (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0);
};
/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */ LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
};
/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */ LongBits.prototype.zzEncode = function zzEncode() {
    var mask = this.hi >> 31;
    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo = (this.lo << 1 ^ mask) >>> 0;
    return this;
};
/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */ LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi = (this.hi >>> 1 ^ mask) >>> 0;
    return this;
};
/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */ LongBits.prototype.length = function length() {
    var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
    return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
};
}),
"[project]/node_modules/protobufjs/src/util/minimal.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var util = exports;
// used to return a Promise where callback is omitted
util.asPromise = __turbopack_context__.r("[project]/node_modules/@protobufjs/aspromise/index.js [app-client] (ecmascript)");
// converts to / from base64 encoded strings
util.base64 = __turbopack_context__.r("[project]/node_modules/@protobufjs/base64/index.js [app-client] (ecmascript)");
// base class of rpc.Service
util.EventEmitter = __turbopack_context__.r("[project]/node_modules/@protobufjs/eventemitter/index.js [app-client] (ecmascript)");
// float handling accross browsers
util.float = __turbopack_context__.r("[project]/node_modules/@protobufjs/float/index.js [app-client] (ecmascript)");
// requires modules optionally and hides the call from bundlers
util.inquire = __turbopack_context__.r("[project]/node_modules/@protobufjs/inquire/index.js [app-client] (ecmascript)");
// converts to / from utf8 encoded strings
util.utf8 = __turbopack_context__.r("[project]/node_modules/@protobufjs/utf8/index.js [app-client] (ecmascript)");
// provides a node-like buffer pool in the browser
util.pool = __turbopack_context__.r("[project]/node_modules/@protobufjs/pool/index.js [app-client] (ecmascript)");
// utility to work with the low and high bits of a 64 bit value
util.LongBits = __turbopack_context__.r("[project]/node_modules/protobufjs/src/util/longbits.js [app-client] (ecmascript)");
/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 */ util.isNode = Boolean(("TURBOPACK compile-time value", "object") !== "undefined" && /*TURBOPACK member replacement*/ __turbopack_context__.g && /*TURBOPACK member replacement*/ __turbopack_context__.g.process && /*TURBOPACK member replacement*/ __turbopack_context__.g.process.versions && /*TURBOPACK member replacement*/ __turbopack_context__.g.process.versions.node);
/**
 * Global object reference.
 * @memberof util
 * @type {Object}
 */ util.global = util.isNode && /*TURBOPACK member replacement*/ __turbopack_context__.g || typeof window !== "undefined" && window || typeof self !== "undefined" && self || /*TURBOPACK member replacement*/ __turbopack_context__.e; // eslint-disable-line no-invalid-this
/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */ util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes
/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */ util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes
/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */ util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};
/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */ util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};
/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */ util.isObject = function isObject(value) {
    return value && typeof value === "object";
};
/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */ util.isset = /**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */ util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};
/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */ /**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */ util.Buffer = function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */ return null;
    }
}();
// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;
// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;
/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */ util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */ return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
};
/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */ util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */  : Array;
/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */ /**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */ util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long || /* istanbul ignore next */ util.global.Long || util.inquire("long");
/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */ util.key2Re = /^true|false|0|1$/;
/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */ util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */ util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */ util.longToHash = function longToHash(value) {
    return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
};
/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */ util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long) return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};
/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */ function merge(dst, src, ifNotSet) {
    for(var keys = Object.keys(src), i = 0; i < keys.length; ++i)if (dst[keys[i]] === undefined || !ifNotSet) dst[keys[i]] = src[keys[i]];
    return dst;
}
util.merge = merge;
/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */ util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};
/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */ function newError(name) {
    function CustomError(message, properties) {
        if (!(this instanceof CustomError)) return new CustomError(message, properties);
        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function
        Object.defineProperty(this, "message", {
            get: function() {
                return message;
            }
        });
        /* istanbul ignore next */ if (Error.captureStackTrace) Error.captureStackTrace(this, CustomError);
        else Object.defineProperty(this, "stack", {
            value: new Error().stack || ""
        });
        if (properties) merge(this, properties);
    }
    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
    Object.defineProperty(CustomError.prototype, "name", {
        get: function() {
            return name;
        }
    });
    CustomError.prototype.toString = function toString() {
        return this.name + ": " + this.message;
    };
    return CustomError;
}
util.newError = newError;
/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */ util.ProtocolError = newError("ProtocolError");
/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */ /**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */ /**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */ util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for(var i = 0; i < fieldNames.length; ++i)fieldMap[fieldNames[i]] = 1;
    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */ return function() {
        for(var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null) return keys[i];
    };
};
/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */ /**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */ util.oneOfSetter = function setOneOf(fieldNames) {
    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */ return function(name) {
        for(var i = 0; i < fieldNames.length; ++i)if (fieldNames[i] !== name) delete this[fieldNames[i]];
    };
};
/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */ util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};
// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */ if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from || /* istanbul ignore next */ function Buffer_from(value, encoding) {
        return new Buffer(value, encoding);
    };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe || /* istanbul ignore next */ function Buffer_allocUnsafe(size) {
        return new Buffer(size);
    };
};
}),
"[project]/node_modules/protobufjs/src/writer.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = Writer;
var util = __turbopack_context__.r("[project]/node_modules/protobufjs/src/util/minimal.js [app-client] (ecmascript)");
var BufferWriter; // cyclic
var LongBits = util.LongBits, base64 = util.base64, utf8 = util.utf8;
/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */ function Op(fn, len, val) {
    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */ this.fn = fn;
    /**
     * Value byte length.
     * @type {number}
     */ this.len = len;
    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */ this.next = undefined;
    /**
     * Value to write.
     * @type {*}
     */ this.val = val; // type varies
}
/* istanbul ignore next */ function noop() {} // eslint-disable-line no-empty-function
/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */ function State(writer) {
    /**
     * Current head.
     * @type {Writer.Op}
     */ this.head = writer.head;
    /**
     * Current tail.
     * @type {Writer.Op}
     */ this.tail = writer.tail;
    /**
     * Current buffer length.
     * @type {number}
     */ this.len = writer.len;
    /**
     * Next state.
     * @type {State|null}
     */ this.next = writer.states;
}
/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */ function Writer() {
    /**
     * Current length.
     * @type {number}
     */ this.len = 0;
    /**
     * Operations head.
     * @type {Object}
     */ this.head = new Op(noop, 0, 0);
    /**
     * Operations tail
     * @type {Object}
     */ this.tail = this.head;
    /**
     * Linked forked states.
     * @type {Object|null}
     */ this.states = null;
// When a value is written, the writer calculates its byte length and puts it into a linked
// list of operations to perform when finish() is called. This both allows us to allocate
// buffers of the exact required size and reduces the amount of work we have to do compared
// to first calculating over objects and then encoding over objects. In our case, the encoding
// part is just a linked list walk calling operations with already prepared values.
}
var create = function create() {
    return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
            return new BufferWriter();
        })();
    } : function create_array() {
        return new Writer();
    };
};
/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */ Writer.create = create();
/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */ Writer.alloc = function alloc(size) {
    return new util.Array(size);
};
// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */ if (util.Array !== Array) Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */ Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};
function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}
function writeVarint32(val, buf, pos) {
    while(val > 127){
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}
/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */ function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}
VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;
/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
    return this;
};
/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.int32 = function write_int32(value) {
    return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
     : this.uint32(value);
};
/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};
function writeVarint64(val, buf, pos) {
    while(val.hi){
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while(val.lo > 127){
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}
/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */ Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};
/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */ Writer.prototype.int64 = Writer.prototype.uint64;
/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */ Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};
/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};
function writeFixed32(val, buf, pos) {
    buf[pos] = val & 255;
    buf[pos + 1] = val >>> 8 & 255;
    buf[pos + 2] = val >>> 16 & 255;
    buf[pos + 3] = val >>> 24;
}
/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};
/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.sfixed32 = Writer.prototype.fixed32;
/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */ Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};
/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */ Writer.prototype.sfixed64 = Writer.prototype.fixed64;
/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};
/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};
var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
    buf.set(val, pos); // also works for plain array values
} : function writeBytes_for(val, buf, pos) {
    for(var i = 0; i < val.length; ++i)buf[pos + i] = val[i];
};
/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */ Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len) return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};
/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
};
/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */ Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};
/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */ Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
    }
    return this;
};
/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */ Writer.prototype.ldelim = function ldelim() {
    var head = this.head, tail = this.tail, len = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};
/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */ Writer.prototype.finish = function finish() {
    var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
    while(head){
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};
Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
};
}),
"[project]/node_modules/protobufjs/src/writer_buffer.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = BufferWriter;
// extends Writer
var Writer = __turbopack_context__.r("[project]/node_modules/protobufjs/src/writer.js [app-client] (ecmascript)");
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
var util = __turbopack_context__.r("[project]/node_modules/protobufjs/src/util/minimal.js [app-client] (ecmascript)");
/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */ function BufferWriter() {
    Writer.call(this);
}
BufferWriter._configure = function() {
    /**
     * Allocates a buffer of the specified size.
     * @function
     * @param {number} size Buffer size
     * @returns {Buffer} Buffer
     */ BufferWriter.alloc = util._Buffer_allocUnsafe;
    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
    // also works for plain array values
    } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy) val.copy(buf, pos, 0, val.length);
        else for(var i = 0; i < val.length;)buf[pos++] = val[i++];
    };
};
/**
 * @override
 */ BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value)) value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len) this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
};
function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) util.utf8.write(val, buf, pos);
    else if (buf.utf8Write) buf.utf8Write(val, pos);
    else buf.write(val, pos);
}
/**
 * @override
 */ BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util.Buffer.byteLength(value);
    this.uint32(len);
    if (len) this._push(writeStringBuffer, len, value);
    return this;
};
/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */ BufferWriter._configure();
}),
"[project]/node_modules/protobufjs/src/reader.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = Reader;
var util = __turbopack_context__.r("[project]/node_modules/protobufjs/src/util/minimal.js [app-client] (ecmascript)");
var BufferReader; // cyclic
var LongBits = util.LongBits, utf8 = util.utf8;
/* istanbul ignore next */ function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}
/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */ function Reader(buffer) {
    /**
     * Read buffer.
     * @type {Uint8Array}
     */ this.buf = buffer;
    /**
     * Read buffer position.
     * @type {number}
     */ this.pos = 0;
    /**
     * Read buffer length.
     * @type {number}
     */ this.len = buffer.length;
}
var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
    if (buffer instanceof Uint8Array || Array.isArray(buffer)) return new Reader(buffer);
    throw Error("illegal buffer");
} : function create_array(buffer) {
    if (Array.isArray(buffer)) return new Reader(buffer);
    throw Error("illegal buffer");
};
var create = function create() {
    return util.Buffer ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer) {
            return util.Buffer.isBuffer(buffer) ? new BufferReader(buffer) : create_array(buffer);
        })(buffer);
    } : create_array;
};
/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */ Reader.create = create();
Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;
/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */ Reader.prototype.uint32 = function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        /* istanbul ignore if */ if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
}();
/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */ Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};
/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */ Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};
/* eslint-disable no-invalid-this */ function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) {
        for(; i < 4; ++i){
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128) return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128) return bits;
        i = 0;
    } else {
        for(; i < 3; ++i){
            /* istanbul ignore if */ if (this.pos >= this.len) throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128) return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) {
        for(; i < 5; ++i){
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128) return bits;
        }
    } else {
        for(; i < 5; ++i){
            /* istanbul ignore if */ if (this.pos >= this.len) throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128) return bits;
        }
    }
    /* istanbul ignore next */ throw Error("invalid varint encoding");
}
/* eslint-enable no-invalid-this */ /**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */ /**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */ /**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */ /**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */ Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};
function readFixed32_end(buf, end) {
    return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
}
/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */ Reader.prototype.fixed32 = function read_fixed32() {
    /* istanbul ignore if */ if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
    return readFixed32_end(this.buf, this.pos += 4);
};
/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */ Reader.prototype.sfixed32 = function read_sfixed32() {
    /* istanbul ignore if */ if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
    return readFixed32_end(this.buf, this.pos += 4) | 0;
};
/* eslint-disable no-invalid-this */ function readFixed64() {
    /* istanbul ignore if */ if (this.pos + 8 > this.len) throw indexOutOfRange(this, 8);
    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}
/* eslint-enable no-invalid-this */ /**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */ /**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */ /**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */ Reader.prototype.float = function read_float() {
    /* istanbul ignore if */ if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};
/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */ Reader.prototype.double = function read_double() {
    /* istanbul ignore if */ if (this.pos + 8 > this.len) throw indexOutOfRange(this, 4);
    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};
/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */ Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(), start = this.pos, end = this.pos + length;
    /* istanbul ignore if */ if (end > this.len) throw indexOutOfRange(this, length);
    this.pos += length;
    if (Array.isArray(this.buf)) return this.buf.slice(start, end);
    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1
     ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
};
/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */ Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};
/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */ Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */ if (this.pos + length > this.len) throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */ if (this.pos >= this.len) throw indexOutOfRange(this);
        }while (this.buf[this.pos++] & 128)
    }
    return this;
};
/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */ Reader.prototype.skipType = function(wireType) {
    switch(wireType){
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while((wireType = this.uint32() & 7) !== 4){
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;
        /* istanbul ignore next */ default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};
Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();
    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {
        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }
    });
};
}),
"[project]/node_modules/protobufjs/src/reader_buffer.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = BufferReader;
// extends Reader
var Reader = __turbopack_context__.r("[project]/node_modules/protobufjs/src/reader.js [app-client] (ecmascript)");
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
var util = __turbopack_context__.r("[project]/node_modules/protobufjs/src/util/minimal.js [app-client] (ecmascript)");
/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */ function BufferReader(buffer) {
    Reader.call(this, buffer);
/**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */ }
BufferReader._configure = function() {
    /* istanbul ignore else */ if (util.Buffer) BufferReader.prototype._slice = util.Buffer.prototype.slice;
};
/**
 * @override
 */ BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};
/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */ BufferReader._configure();
}),
"[project]/node_modules/protobufjs/src/rpc/service.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = Service;
var util = __turbopack_context__.r("[project]/node_modules/protobufjs/src/util/minimal.js [app-client] (ecmascript)");
// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */ /**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */ /**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */ function Service(rpcImpl, requestDelimited, responseDelimited) {
    if (typeof rpcImpl !== "function") throw TypeError("rpcImpl must be a function");
    util.EventEmitter.call(this);
    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */ this.rpcImpl = rpcImpl;
    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */ this.requestDelimited = Boolean(requestDelimited);
    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */ this.responseDelimited = Boolean(responseDelimited);
}
/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */ Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
    if (!request) throw TypeError("request must be specified");
    var self = this;
    if (!callback) return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);
    if (!self.rpcImpl) {
        setTimeout(function() {
            callback(Error("already ended"));
        }, 0);
        return undefined;
    }
    try {
        return self.rpcImpl(method, requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(), function rpcCallback(err, response) {
            if (err) {
                self.emit("error", err, method);
                return callback(err);
            }
            if (response === null) {
                self.end(/* endedByRPC */ true);
                return undefined;
            }
            if (!(response instanceof responseCtor)) {
                try {
                    response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                } catch (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }
            }
            self.emit("data", response, method);
            return callback(null, response);
        });
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() {
            callback(err);
        }, 0);
        return undefined;
    }
};
/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */ Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};
}),
"[project]/node_modules/protobufjs/src/rpc.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Streaming RPC helpers.
 * @namespace
 */ var rpc = exports;
/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */ /**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */ rpc.Service = __turbopack_context__.r("[project]/node_modules/protobufjs/src/rpc/service.js [app-client] (ecmascript)");
}),
"[project]/node_modules/protobufjs/src/roots.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = {}; /**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available accross modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */ 
}),
"[project]/node_modules/protobufjs/src/index-minimal.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var protobuf = exports;
/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */ protobuf.build = "minimal";
// Serialization
protobuf.Writer = __turbopack_context__.r("[project]/node_modules/protobufjs/src/writer.js [app-client] (ecmascript)");
protobuf.BufferWriter = __turbopack_context__.r("[project]/node_modules/protobufjs/src/writer_buffer.js [app-client] (ecmascript)");
protobuf.Reader = __turbopack_context__.r("[project]/node_modules/protobufjs/src/reader.js [app-client] (ecmascript)");
protobuf.BufferReader = __turbopack_context__.r("[project]/node_modules/protobufjs/src/reader_buffer.js [app-client] (ecmascript)");
// Utility
protobuf.util = __turbopack_context__.r("[project]/node_modules/protobufjs/src/util/minimal.js [app-client] (ecmascript)");
protobuf.rpc = __turbopack_context__.r("[project]/node_modules/protobufjs/src/rpc.js [app-client] (ecmascript)");
protobuf.roots = __turbopack_context__.r("[project]/node_modules/protobufjs/src/roots.js [app-client] (ecmascript)");
protobuf.configure = configure;
/* istanbul ignore next */ /**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */ function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
}
// Set up buffer utility according to the environment
configure();
}),
"[project]/node_modules/protobufjs/minimal.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// minimal library entry point.
module.exports = __turbopack_context__.r("[project]/node_modules/protobufjs/src/index-minimal.js [app-client] (ecmascript)");
}),
"[project]/node_modules/ipfs-unixfs/src/unixfs.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/*eslint-disable*/ var $protobuf = __turbopack_context__.r("[project]/node_modules/protobufjs/minimal.js [app-client] (ecmascript)");
// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
// Exported root namespace
var $root = $protobuf.roots["ipfs-unixfs"] || ($protobuf.roots["ipfs-unixfs"] = {});
$root.Data = function() {
    /**
     * Properties of a Data.
     * @exports IData
     * @interface IData
     * @property {Data.DataType} Type Data Type
     * @property {Uint8Array|null} [Data] Data Data
     * @property {number|null} [filesize] Data filesize
     * @property {Array.<number>|null} [blocksizes] Data blocksizes
     * @property {number|null} [hashType] Data hashType
     * @property {number|null} [fanout] Data fanout
     * @property {number|null} [mode] Data mode
     * @property {IUnixTime|null} [mtime] Data mtime
     */ /**
     * Constructs a new Data.
     * @exports Data
     * @classdesc Represents a Data.
     * @implements IData
     * @constructor
     * @param {IData=} [p] Properties to set
     */ function Data(p) {
        this.blocksizes = [];
        if (p) {
            for(var ks = Object.keys(p), i = 0; i < ks.length; ++i)if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }
    }
    /**
     * Data Type.
     * @member {Data.DataType} Type
     * @memberof Data
     * @instance
     */ Data.prototype.Type = 0;
    /**
     * Data Data.
     * @member {Uint8Array} Data
     * @memberof Data
     * @instance
     */ Data.prototype.Data = $util.newBuffer([]);
    /**
     * Data filesize.
     * @member {number} filesize
     * @memberof Data
     * @instance
     */ Data.prototype.filesize = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * Data blocksizes.
     * @member {Array.<number>} blocksizes
     * @memberof Data
     * @instance
     */ Data.prototype.blocksizes = $util.emptyArray;
    /**
     * Data hashType.
     * @member {number} hashType
     * @memberof Data
     * @instance
     */ Data.prototype.hashType = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * Data fanout.
     * @member {number} fanout
     * @memberof Data
     * @instance
     */ Data.prototype.fanout = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
    /**
     * Data mode.
     * @member {number} mode
     * @memberof Data
     * @instance
     */ Data.prototype.mode = 0;
    /**
     * Data mtime.
     * @member {IUnixTime|null|undefined} mtime
     * @memberof Data
     * @instance
     */ Data.prototype.mtime = null;
    /**
     * Encodes the specified Data message. Does not implicitly {@link Data.verify|verify} messages.
     * @function encode
     * @memberof Data
     * @static
     * @param {IData} m Data message or plain object to encode
     * @param {$protobuf.Writer} [w] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */ Data.encode = function encode(m, w) {
        if (!w) w = $Writer.create();
        w.uint32(8).int32(m.Type);
        if (m.Data != null && Object.hasOwnProperty.call(m, "Data")) w.uint32(18).bytes(m.Data);
        if (m.filesize != null && Object.hasOwnProperty.call(m, "filesize")) w.uint32(24).uint64(m.filesize);
        if (m.blocksizes != null && m.blocksizes.length) {
            for(var i = 0; i < m.blocksizes.length; ++i)w.uint32(32).uint64(m.blocksizes[i]);
        }
        if (m.hashType != null && Object.hasOwnProperty.call(m, "hashType")) w.uint32(40).uint64(m.hashType);
        if (m.fanout != null && Object.hasOwnProperty.call(m, "fanout")) w.uint32(48).uint64(m.fanout);
        if (m.mode != null && Object.hasOwnProperty.call(m, "mode")) w.uint32(56).uint32(m.mode);
        if (m.mtime != null && Object.hasOwnProperty.call(m, "mtime")) $root.UnixTime.encode(m.mtime, w.uint32(66).fork()).ldelim();
        return w;
    };
    /**
     * Decodes a Data message from the specified reader or buffer.
     * @function decode
     * @memberof Data
     * @static
     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
     * @param {number} [l] Message length if known beforehand
     * @returns {Data} Data
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */ Data.decode = function decode(r, l) {
        if (!(r instanceof $Reader)) r = $Reader.create(r);
        var c = l === undefined ? r.len : r.pos + l, m = new $root.Data();
        while(r.pos < c){
            var t = r.uint32();
            switch(t >>> 3){
                case 1:
                    m.Type = r.int32();
                    break;
                case 2:
                    m.Data = r.bytes();
                    break;
                case 3:
                    m.filesize = r.uint64();
                    break;
                case 4:
                    if (!(m.blocksizes && m.blocksizes.length)) m.blocksizes = [];
                    if ((t & 7) === 2) {
                        var c2 = r.uint32() + r.pos;
                        while(r.pos < c2)m.blocksizes.push(r.uint64());
                    } else m.blocksizes.push(r.uint64());
                    break;
                case 5:
                    m.hashType = r.uint64();
                    break;
                case 6:
                    m.fanout = r.uint64();
                    break;
                case 7:
                    m.mode = r.uint32();
                    break;
                case 8:
                    m.mtime = $root.UnixTime.decode(r, r.uint32());
                    break;
                default:
                    r.skipType(t & 7);
                    break;
            }
        }
        if (!m.hasOwnProperty("Type")) throw $util.ProtocolError("missing required 'Type'", {
            instance: m
        });
        return m;
    };
    /**
     * Creates a Data message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Data
     * @static
     * @param {Object.<string,*>} d Plain object
     * @returns {Data} Data
     */ Data.fromObject = function fromObject(d) {
        if (d instanceof $root.Data) return d;
        var m = new $root.Data();
        switch(d.Type){
            case "Raw":
            case 0:
                m.Type = 0;
                break;
            case "Directory":
            case 1:
                m.Type = 1;
                break;
            case "File":
            case 2:
                m.Type = 2;
                break;
            case "Metadata":
            case 3:
                m.Type = 3;
                break;
            case "Symlink":
            case 4:
                m.Type = 4;
                break;
            case "HAMTShard":
            case 5:
                m.Type = 5;
                break;
        }
        if (d.Data != null) {
            if (typeof d.Data === "string") $util.base64.decode(d.Data, m.Data = $util.newBuffer($util.base64.length(d.Data)), 0);
            else if (d.Data.length) m.Data = d.Data;
        }
        if (d.filesize != null) {
            if ($util.Long) (m.filesize = $util.Long.fromValue(d.filesize)).unsigned = true;
            else if (typeof d.filesize === "string") m.filesize = parseInt(d.filesize, 10);
            else if (typeof d.filesize === "number") m.filesize = d.filesize;
            else if (typeof d.filesize === "object") m.filesize = new $util.LongBits(d.filesize.low >>> 0, d.filesize.high >>> 0).toNumber(true);
        }
        if (d.blocksizes) {
            if (!Array.isArray(d.blocksizes)) throw TypeError(".Data.blocksizes: array expected");
            m.blocksizes = [];
            for(var i = 0; i < d.blocksizes.length; ++i){
                if ($util.Long) (m.blocksizes[i] = $util.Long.fromValue(d.blocksizes[i])).unsigned = true;
                else if (typeof d.blocksizes[i] === "string") m.blocksizes[i] = parseInt(d.blocksizes[i], 10);
                else if (typeof d.blocksizes[i] === "number") m.blocksizes[i] = d.blocksizes[i];
                else if (typeof d.blocksizes[i] === "object") m.blocksizes[i] = new $util.LongBits(d.blocksizes[i].low >>> 0, d.blocksizes[i].high >>> 0).toNumber(true);
            }
        }
        if (d.hashType != null) {
            if ($util.Long) (m.hashType = $util.Long.fromValue(d.hashType)).unsigned = true;
            else if (typeof d.hashType === "string") m.hashType = parseInt(d.hashType, 10);
            else if (typeof d.hashType === "number") m.hashType = d.hashType;
            else if (typeof d.hashType === "object") m.hashType = new $util.LongBits(d.hashType.low >>> 0, d.hashType.high >>> 0).toNumber(true);
        }
        if (d.fanout != null) {
            if ($util.Long) (m.fanout = $util.Long.fromValue(d.fanout)).unsigned = true;
            else if (typeof d.fanout === "string") m.fanout = parseInt(d.fanout, 10);
            else if (typeof d.fanout === "number") m.fanout = d.fanout;
            else if (typeof d.fanout === "object") m.fanout = new $util.LongBits(d.fanout.low >>> 0, d.fanout.high >>> 0).toNumber(true);
        }
        if (d.mode != null) {
            m.mode = d.mode >>> 0;
        }
        if (d.mtime != null) {
            if (typeof d.mtime !== "object") throw TypeError(".Data.mtime: object expected");
            m.mtime = $root.UnixTime.fromObject(d.mtime);
        }
        return m;
    };
    /**
     * Creates a plain object from a Data message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Data
     * @static
     * @param {Data} m Data
     * @param {$protobuf.IConversionOptions} [o] Conversion options
     * @returns {Object.<string,*>} Plain object
     */ Data.toObject = function toObject(m, o) {
        if (!o) o = {};
        var d = {};
        if (o.arrays || o.defaults) {
            d.blocksizes = [];
        }
        if (o.defaults) {
            d.Type = o.enums === String ? "Raw" : 0;
            if (o.bytes === String) d.Data = "";
            else {
                d.Data = [];
                if (o.bytes !== Array) d.Data = $util.newBuffer(d.Data);
            }
            if ($util.Long) {
                var n = new $util.Long(0, 0, true);
                d.filesize = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
            } else d.filesize = o.longs === String ? "0" : 0;
            if ($util.Long) {
                var n = new $util.Long(0, 0, true);
                d.hashType = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
            } else d.hashType = o.longs === String ? "0" : 0;
            if ($util.Long) {
                var n = new $util.Long(0, 0, true);
                d.fanout = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
            } else d.fanout = o.longs === String ? "0" : 0;
            d.mode = 0;
            d.mtime = null;
        }
        if (m.Type != null && m.hasOwnProperty("Type")) {
            d.Type = o.enums === String ? $root.Data.DataType[m.Type] : m.Type;
        }
        if (m.Data != null && m.hasOwnProperty("Data")) {
            d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;
        }
        if (m.filesize != null && m.hasOwnProperty("filesize")) {
            if (typeof m.filesize === "number") d.filesize = o.longs === String ? String(m.filesize) : m.filesize;
            else d.filesize = o.longs === String ? $util.Long.prototype.toString.call(m.filesize) : o.longs === Number ? new $util.LongBits(m.filesize.low >>> 0, m.filesize.high >>> 0).toNumber(true) : m.filesize;
        }
        if (m.blocksizes && m.blocksizes.length) {
            d.blocksizes = [];
            for(var j = 0; j < m.blocksizes.length; ++j){
                if (typeof m.blocksizes[j] === "number") d.blocksizes[j] = o.longs === String ? String(m.blocksizes[j]) : m.blocksizes[j];
                else d.blocksizes[j] = o.longs === String ? $util.Long.prototype.toString.call(m.blocksizes[j]) : o.longs === Number ? new $util.LongBits(m.blocksizes[j].low >>> 0, m.blocksizes[j].high >>> 0).toNumber(true) : m.blocksizes[j];
            }
        }
        if (m.hashType != null && m.hasOwnProperty("hashType")) {
            if (typeof m.hashType === "number") d.hashType = o.longs === String ? String(m.hashType) : m.hashType;
            else d.hashType = o.longs === String ? $util.Long.prototype.toString.call(m.hashType) : o.longs === Number ? new $util.LongBits(m.hashType.low >>> 0, m.hashType.high >>> 0).toNumber(true) : m.hashType;
        }
        if (m.fanout != null && m.hasOwnProperty("fanout")) {
            if (typeof m.fanout === "number") d.fanout = o.longs === String ? String(m.fanout) : m.fanout;
            else d.fanout = o.longs === String ? $util.Long.prototype.toString.call(m.fanout) : o.longs === Number ? new $util.LongBits(m.fanout.low >>> 0, m.fanout.high >>> 0).toNumber(true) : m.fanout;
        }
        if (m.mode != null && m.hasOwnProperty("mode")) {
            d.mode = m.mode;
        }
        if (m.mtime != null && m.hasOwnProperty("mtime")) {
            d.mtime = $root.UnixTime.toObject(m.mtime, o);
        }
        return d;
    };
    /**
     * Converts this Data to JSON.
     * @function toJSON
     * @memberof Data
     * @instance
     * @returns {Object.<string,*>} JSON object
     */ Data.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    /**
     * DataType enum.
     * @name Data.DataType
     * @enum {number}
     * @property {number} Raw=0 Raw value
     * @property {number} Directory=1 Directory value
     * @property {number} File=2 File value
     * @property {number} Metadata=3 Metadata value
     * @property {number} Symlink=4 Symlink value
     * @property {number} HAMTShard=5 HAMTShard value
     */ Data.DataType = function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Raw"] = 0;
        values[valuesById[1] = "Directory"] = 1;
        values[valuesById[2] = "File"] = 2;
        values[valuesById[3] = "Metadata"] = 3;
        values[valuesById[4] = "Symlink"] = 4;
        values[valuesById[5] = "HAMTShard"] = 5;
        return values;
    }();
    return Data;
}();
$root.UnixTime = function() {
    /**
     * Properties of an UnixTime.
     * @exports IUnixTime
     * @interface IUnixTime
     * @property {number} Seconds UnixTime Seconds
     * @property {number|null} [FractionalNanoseconds] UnixTime FractionalNanoseconds
     */ /**
     * Constructs a new UnixTime.
     * @exports UnixTime
     * @classdesc Represents an UnixTime.
     * @implements IUnixTime
     * @constructor
     * @param {IUnixTime=} [p] Properties to set
     */ function UnixTime(p) {
        if (p) {
            for(var ks = Object.keys(p), i = 0; i < ks.length; ++i)if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }
    }
    /**
     * UnixTime Seconds.
     * @member {number} Seconds
     * @memberof UnixTime
     * @instance
     */ UnixTime.prototype.Seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
    /**
     * UnixTime FractionalNanoseconds.
     * @member {number} FractionalNanoseconds
     * @memberof UnixTime
     * @instance
     */ UnixTime.prototype.FractionalNanoseconds = 0;
    /**
     * Encodes the specified UnixTime message. Does not implicitly {@link UnixTime.verify|verify} messages.
     * @function encode
     * @memberof UnixTime
     * @static
     * @param {IUnixTime} m UnixTime message or plain object to encode
     * @param {$protobuf.Writer} [w] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */ UnixTime.encode = function encode(m, w) {
        if (!w) w = $Writer.create();
        w.uint32(8).int64(m.Seconds);
        if (m.FractionalNanoseconds != null && Object.hasOwnProperty.call(m, "FractionalNanoseconds")) w.uint32(21).fixed32(m.FractionalNanoseconds);
        return w;
    };
    /**
     * Decodes an UnixTime message from the specified reader or buffer.
     * @function decode
     * @memberof UnixTime
     * @static
     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
     * @param {number} [l] Message length if known beforehand
     * @returns {UnixTime} UnixTime
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */ UnixTime.decode = function decode(r, l) {
        if (!(r instanceof $Reader)) r = $Reader.create(r);
        var c = l === undefined ? r.len : r.pos + l, m = new $root.UnixTime();
        while(r.pos < c){
            var t = r.uint32();
            switch(t >>> 3){
                case 1:
                    m.Seconds = r.int64();
                    break;
                case 2:
                    m.FractionalNanoseconds = r.fixed32();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
            }
        }
        if (!m.hasOwnProperty("Seconds")) throw $util.ProtocolError("missing required 'Seconds'", {
            instance: m
        });
        return m;
    };
    /**
     * Creates an UnixTime message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof UnixTime
     * @static
     * @param {Object.<string,*>} d Plain object
     * @returns {UnixTime} UnixTime
     */ UnixTime.fromObject = function fromObject(d) {
        if (d instanceof $root.UnixTime) return d;
        var m = new $root.UnixTime();
        if (d.Seconds != null) {
            if ($util.Long) (m.Seconds = $util.Long.fromValue(d.Seconds)).unsigned = false;
            else if (typeof d.Seconds === "string") m.Seconds = parseInt(d.Seconds, 10);
            else if (typeof d.Seconds === "number") m.Seconds = d.Seconds;
            else if (typeof d.Seconds === "object") m.Seconds = new $util.LongBits(d.Seconds.low >>> 0, d.Seconds.high >>> 0).toNumber();
        }
        if (d.FractionalNanoseconds != null) {
            m.FractionalNanoseconds = d.FractionalNanoseconds >>> 0;
        }
        return m;
    };
    /**
     * Creates a plain object from an UnixTime message. Also converts values to other types if specified.
     * @function toObject
     * @memberof UnixTime
     * @static
     * @param {UnixTime} m UnixTime
     * @param {$protobuf.IConversionOptions} [o] Conversion options
     * @returns {Object.<string,*>} Plain object
     */ UnixTime.toObject = function toObject(m, o) {
        if (!o) o = {};
        var d = {};
        if (o.defaults) {
            if ($util.Long) {
                var n = new $util.Long(0, 0, false);
                d.Seconds = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
            } else d.Seconds = o.longs === String ? "0" : 0;
            d.FractionalNanoseconds = 0;
        }
        if (m.Seconds != null && m.hasOwnProperty("Seconds")) {
            if (typeof m.Seconds === "number") d.Seconds = o.longs === String ? String(m.Seconds) : m.Seconds;
            else d.Seconds = o.longs === String ? $util.Long.prototype.toString.call(m.Seconds) : o.longs === Number ? new $util.LongBits(m.Seconds.low >>> 0, m.Seconds.high >>> 0).toNumber() : m.Seconds;
        }
        if (m.FractionalNanoseconds != null && m.hasOwnProperty("FractionalNanoseconds")) {
            d.FractionalNanoseconds = m.FractionalNanoseconds;
        }
        return d;
    };
    /**
     * Converts this UnixTime to JSON.
     * @function toJSON
     * @memberof UnixTime
     * @instance
     * @returns {Object.<string,*>} JSON object
     */ UnixTime.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return UnixTime;
}();
$root.Metadata = function() {
    /**
     * Properties of a Metadata.
     * @exports IMetadata
     * @interface IMetadata
     * @property {string|null} [MimeType] Metadata MimeType
     */ /**
     * Constructs a new Metadata.
     * @exports Metadata
     * @classdesc Represents a Metadata.
     * @implements IMetadata
     * @constructor
     * @param {IMetadata=} [p] Properties to set
     */ function Metadata(p) {
        if (p) {
            for(var ks = Object.keys(p), i = 0; i < ks.length; ++i)if (p[ks[i]] != null) this[ks[i]] = p[ks[i]];
        }
    }
    /**
     * Metadata MimeType.
     * @member {string} MimeType
     * @memberof Metadata
     * @instance
     */ Metadata.prototype.MimeType = "";
    /**
     * Encodes the specified Metadata message. Does not implicitly {@link Metadata.verify|verify} messages.
     * @function encode
     * @memberof Metadata
     * @static
     * @param {IMetadata} m Metadata message or plain object to encode
     * @param {$protobuf.Writer} [w] Writer to encode to
     * @returns {$protobuf.Writer} Writer
     */ Metadata.encode = function encode(m, w) {
        if (!w) w = $Writer.create();
        if (m.MimeType != null && Object.hasOwnProperty.call(m, "MimeType")) w.uint32(10).string(m.MimeType);
        return w;
    };
    /**
     * Decodes a Metadata message from the specified reader or buffer.
     * @function decode
     * @memberof Metadata
     * @static
     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from
     * @param {number} [l] Message length if known beforehand
     * @returns {Metadata} Metadata
     * @throws {Error} If the payload is not a reader or valid buffer
     * @throws {$protobuf.util.ProtocolError} If required fields are missing
     */ Metadata.decode = function decode(r, l) {
        if (!(r instanceof $Reader)) r = $Reader.create(r);
        var c = l === undefined ? r.len : r.pos + l, m = new $root.Metadata();
        while(r.pos < c){
            var t = r.uint32();
            switch(t >>> 3){
                case 1:
                    m.MimeType = r.string();
                    break;
                default:
                    r.skipType(t & 7);
                    break;
            }
        }
        return m;
    };
    /**
     * Creates a Metadata message from a plain object. Also converts values to their respective internal types.
     * @function fromObject
     * @memberof Metadata
     * @static
     * @param {Object.<string,*>} d Plain object
     * @returns {Metadata} Metadata
     */ Metadata.fromObject = function fromObject(d) {
        if (d instanceof $root.Metadata) return d;
        var m = new $root.Metadata();
        if (d.MimeType != null) {
            m.MimeType = String(d.MimeType);
        }
        return m;
    };
    /**
     * Creates a plain object from a Metadata message. Also converts values to other types if specified.
     * @function toObject
     * @memberof Metadata
     * @static
     * @param {Metadata} m Metadata
     * @param {$protobuf.IConversionOptions} [o] Conversion options
     * @returns {Object.<string,*>} Plain object
     */ Metadata.toObject = function toObject(m, o) {
        if (!o) o = {};
        var d = {};
        if (o.defaults) {
            d.MimeType = "";
        }
        if (m.MimeType != null && m.hasOwnProperty("MimeType")) {
            d.MimeType = m.MimeType;
        }
        return d;
    };
    /**
     * Converts this Metadata to JSON.
     * @function toJSON
     * @memberof Metadata
     * @instance
     * @returns {Object.<string,*>} JSON object
     */ Metadata.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return Metadata;
}();
module.exports = $root;
}),
"[project]/node_modules/ipfs-unixfs/src/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { Data: PBData } = __turbopack_context__.r("[project]/node_modules/ipfs-unixfs/src/unixfs.js [app-client] (ecmascript)");
const errcode = __turbopack_context__.r("[project]/node_modules/err-code/index.js [app-client] (ecmascript)");
/**
 * @typedef {import('./types').Mtime} Mtime
 * @typedef {import('./types').MtimeLike} MtimeLike
 */ const types = [
    'raw',
    'directory',
    'file',
    'metadata',
    'symlink',
    'hamt-sharded-directory'
];
const dirTypes = [
    'directory',
    'hamt-sharded-directory'
];
const DEFAULT_FILE_MODE = parseInt('0644', 8);
const DEFAULT_DIRECTORY_MODE = parseInt('0755', 8);
/**
 * @param {string | number | undefined} [mode]
 */ function parseMode(mode) {
    if (mode == null) {
        return undefined;
    }
    if (typeof mode === 'number') {
        return mode & 0xFFF;
    }
    mode = mode.toString();
    if (mode.substring(0, 1) === '0') {
        // octal string
        return parseInt(mode, 8) & 0xFFF;
    }
    // decimal string
    return parseInt(mode, 10) & 0xFFF;
}
/**
 * @param {any} input
 */ function parseMtime(input) {
    if (input == null) {
        return undefined;
    }
    /** @type {Mtime | undefined} */ let mtime;
    // { secs, nsecs }
    if (input.secs != null) {
        mtime = {
            secs: input.secs,
            nsecs: input.nsecs
        };
    }
    // UnixFS TimeSpec
    if (input.Seconds != null) {
        mtime = {
            secs: input.Seconds,
            nsecs: input.FractionalNanoseconds
        };
    }
    // process.hrtime()
    if (Array.isArray(input)) {
        mtime = {
            secs: input[0],
            nsecs: input[1]
        };
    }
    // Javascript Date
    if (input instanceof Date) {
        const ms = input.getTime();
        const secs = Math.floor(ms / 1000);
        mtime = {
            secs: secs,
            nsecs: (ms - secs * 1000) * 1000
        };
    }
    /*
  TODO: https://github.com/ipfs/aegir/issues/487

  // process.hrtime.bigint()
  if (input instanceof BigInt) {
    const secs = input / BigInt(1e9)
    const nsecs = input - (secs * BigInt(1e9))

    mtime = {
      secs: parseInt(secs.toString()),
      nsecs: parseInt(nsecs.toString())
    }
  }
  */ if (!Object.prototype.hasOwnProperty.call(mtime, 'secs')) {
        return undefined;
    }
    if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {
        throw errcode(new Error('mtime-nsecs must be within the range [0,999999999]'), 'ERR_INVALID_MTIME_NSECS');
    }
    return mtime;
}
class Data {
    /**
   * Decode from protobuf https://github.com/ipfs/specs/blob/master/UNIXFS.md
   *
   * @param {Uint8Array} marshaled
   */ static unmarshal(marshaled) {
        const message = PBData.decode(marshaled);
        const decoded = PBData.toObject(message, {
            defaults: false,
            arrays: true,
            longs: Number,
            objects: false
        });
        const data = new Data({
            type: types[decoded.Type],
            data: decoded.Data,
            blockSizes: decoded.blocksizes,
            mode: decoded.mode,
            mtime: decoded.mtime ? {
                secs: decoded.mtime.Seconds,
                nsecs: decoded.mtime.FractionalNanoseconds
            } : undefined
        });
        // make sure we honour the original mode
        data._originalMode = decoded.mode || 0;
        return data;
    }
    /**
   * @param {object} [options]
   * @param {string} [options.type='file']
   * @param {Uint8Array} [options.data]
   * @param {number[]} [options.blockSizes]
   * @param {number} [options.hashType]
   * @param {number} [options.fanout]
   * @param {MtimeLike | null} [options.mtime]
   * @param {number | string} [options.mode]
   */ constructor(options = {
        type: 'file'
    }){
        const { type, data, blockSizes, hashType, fanout, mtime, mode } = options;
        if (type && !types.includes(type)) {
            throw errcode(new Error('Type: ' + type + ' is not valid'), 'ERR_INVALID_TYPE');
        }
        this.type = type || 'file';
        this.data = data;
        this.hashType = hashType;
        this.fanout = fanout;
        /** @type {number[]} */ this.blockSizes = blockSizes || [];
        this._originalMode = 0;
        this.mode = parseMode(mode);
        if (mtime) {
            this.mtime = parseMtime(mtime);
            if (this.mtime && !this.mtime.nsecs) {
                this.mtime.nsecs = 0;
            }
        }
    }
    /**
   * @param {number | undefined} mode
   */ set mode(mode) {
        this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE : DEFAULT_FILE_MODE;
        const parsedMode = parseMode(mode);
        if (parsedMode !== undefined) {
            this._mode = parsedMode;
        }
    }
    /**
   * @returns {number | undefined}
   */ get mode() {
        return this._mode;
    }
    isDirectory() {
        return Boolean(this.type && dirTypes.includes(this.type));
    }
    /**
   * @param {number} size
   */ addBlockSize(size) {
        this.blockSizes.push(size);
    }
    /**
   * @param {number} index
   */ removeBlockSize(index) {
        this.blockSizes.splice(index, 1);
    }
    /**
   * Returns `0` for directories or `data.length + sum(blockSizes)` for everything else
   */ fileSize() {
        if (this.isDirectory()) {
            // dirs don't have file size
            return 0;
        }
        let sum = 0;
        this.blockSizes.forEach((size)=>{
            sum += size;
        });
        if (this.data) {
            sum += this.data.length;
        }
        return sum;
    }
    /**
   * encode to protobuf Uint8Array
   */ marshal() {
        let type;
        switch(this.type){
            case 'raw':
                type = PBData.DataType.Raw;
                break;
            case 'directory':
                type = PBData.DataType.Directory;
                break;
            case 'file':
                type = PBData.DataType.File;
                break;
            case 'metadata':
                type = PBData.DataType.Metadata;
                break;
            case 'symlink':
                type = PBData.DataType.Symlink;
                break;
            case 'hamt-sharded-directory':
                type = PBData.DataType.HAMTShard;
                break;
            default:
                throw errcode(new Error('Type: ' + type + ' is not valid'), 'ERR_INVALID_TYPE');
        }
        let data = this.data;
        if (!this.data || !this.data.length) {
            data = undefined;
        }
        let mode;
        if (this.mode != null) {
            mode = this._originalMode & 0xFFFFF000 | (parseMode(this.mode) || 0);
            if (mode === DEFAULT_FILE_MODE && !this.isDirectory()) {
                mode = undefined;
            }
            if (mode === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {
                mode = undefined;
            }
        }
        let mtime;
        if (this.mtime != null) {
            const parsed = parseMtime(this.mtime);
            if (parsed) {
                mtime = {
                    Seconds: parsed.secs,
                    FractionalNanoseconds: parsed.nsecs
                };
                if (mtime.FractionalNanoseconds === 0) {
                    delete mtime.FractionalNanoseconds;
                }
            }
        }
        const pbData = {
            Type: type,
            Data: data,
            filesize: this.isDirectory() ? undefined : this.fileSize(),
            blocksizes: this.blockSizes,
            hashType: this.hashType,
            fanout: this.fanout,
            mode,
            mtime
        };
        return PBData.encode(pbData).finish();
    }
}
module.exports = {
    UnixFS: Data,
    parseMode,
    parseMtime
};
}),
"[project]/node_modules/multicodec/src/util.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const varint = __turbopack_context__.r("[project]/node_modules/varint/index.js [app-client] (ecmascript)");
const { toString: uint8ArrayToString } = __turbopack_context__.r("[project]/node_modules/uint8arrays/esm/src/to-string.js [app-client] (ecmascript)");
const { fromString: uint8ArrayFromString } = __turbopack_context__.r("[project]/node_modules/uint8arrays/esm/src/from-string.js [app-client] (ecmascript)");
module.exports = {
    numberToUint8Array,
    uint8ArrayToNumber,
    varintUint8ArrayEncode,
    varintEncode
};
/**
 * @param {Uint8Array} buf
 */ function uint8ArrayToNumber(buf) {
    return parseInt(uint8ArrayToString(buf, 'base16'), 16);
}
/**
 * @param {number} num
 */ function numberToUint8Array(num) {
    let hexString = num.toString(16);
    if (hexString.length % 2 === 1) {
        hexString = '0' + hexString;
    }
    return uint8ArrayFromString(hexString, 'base16');
}
/**
 * @param {Uint8Array} input
 */ function varintUint8ArrayEncode(input) {
    return Uint8Array.from(varint.encode(uint8ArrayToNumber(input)));
}
/**
 * @param {number} num
 */ function varintEncode(num) {
    return Uint8Array.from(varint.encode(num));
}
}),
"[project]/node_modules/multicodec/src/generated-table.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// DO NOT CHANGE THIS FILE. IT IS GENERATED BY tools/update-table.js
/* eslint quote-props: off */ /**
 * @type {import('./generated-types').NameCodeMap}
 */ const baseTable = Object.freeze({
    'identity': 0x00,
    'cidv1': 0x01,
    'cidv2': 0x02,
    'cidv3': 0x03,
    'ip4': 0x04,
    'tcp': 0x06,
    'sha1': 0x11,
    'sha2-256': 0x12,
    'sha2-512': 0x13,
    'sha3-512': 0x14,
    'sha3-384': 0x15,
    'sha3-256': 0x16,
    'sha3-224': 0x17,
    'shake-128': 0x18,
    'shake-256': 0x19,
    'keccak-224': 0x1a,
    'keccak-256': 0x1b,
    'keccak-384': 0x1c,
    'keccak-512': 0x1d,
    'blake3': 0x1e,
    'dccp': 0x21,
    'murmur3-128': 0x22,
    'murmur3-32': 0x23,
    'ip6': 0x29,
    'ip6zone': 0x2a,
    'path': 0x2f,
    'multicodec': 0x30,
    'multihash': 0x31,
    'multiaddr': 0x32,
    'multibase': 0x33,
    'dns': 0x35,
    'dns4': 0x36,
    'dns6': 0x37,
    'dnsaddr': 0x38,
    'protobuf': 0x50,
    'cbor': 0x51,
    'raw': 0x55,
    'dbl-sha2-256': 0x56,
    'rlp': 0x60,
    'bencode': 0x63,
    'dag-pb': 0x70,
    'dag-cbor': 0x71,
    'libp2p-key': 0x72,
    'git-raw': 0x78,
    'torrent-info': 0x7b,
    'torrent-file': 0x7c,
    'leofcoin-block': 0x81,
    'leofcoin-tx': 0x82,
    'leofcoin-pr': 0x83,
    'sctp': 0x84,
    'dag-jose': 0x85,
    'dag-cose': 0x86,
    'eth-block': 0x90,
    'eth-block-list': 0x91,
    'eth-tx-trie': 0x92,
    'eth-tx': 0x93,
    'eth-tx-receipt-trie': 0x94,
    'eth-tx-receipt': 0x95,
    'eth-state-trie': 0x96,
    'eth-account-snapshot': 0x97,
    'eth-storage-trie': 0x98,
    'eth-receipt-log-trie': 0x99,
    'eth-reciept-log': 0x9a,
    'bitcoin-block': 0xb0,
    'bitcoin-tx': 0xb1,
    'bitcoin-witness-commitment': 0xb2,
    'zcash-block': 0xc0,
    'zcash-tx': 0xc1,
    'caip-50': 0xca,
    'streamid': 0xce,
    'stellar-block': 0xd0,
    'stellar-tx': 0xd1,
    'md4': 0xd4,
    'md5': 0xd5,
    'bmt': 0xd6,
    'decred-block': 0xe0,
    'decred-tx': 0xe1,
    'ipld-ns': 0xe2,
    'ipfs-ns': 0xe3,
    'swarm-ns': 0xe4,
    'ipns-ns': 0xe5,
    'zeronet': 0xe6,
    'secp256k1-pub': 0xe7,
    'bls12_381-g1-pub': 0xea,
    'bls12_381-g2-pub': 0xeb,
    'x25519-pub': 0xec,
    'ed25519-pub': 0xed,
    'bls12_381-g1g2-pub': 0xee,
    'dash-block': 0xf0,
    'dash-tx': 0xf1,
    'swarm-manifest': 0xfa,
    'swarm-feed': 0xfb,
    'udp': 0x0111,
    'p2p-webrtc-star': 0x0113,
    'p2p-webrtc-direct': 0x0114,
    'p2p-stardust': 0x0115,
    'p2p-circuit': 0x0122,
    'dag-json': 0x0129,
    'udt': 0x012d,
    'utp': 0x012e,
    'unix': 0x0190,
    'thread': 0x0196,
    'p2p': 0x01a5,
    'ipfs': 0x01a5,
    'https': 0x01bb,
    'onion': 0x01bc,
    'onion3': 0x01bd,
    'garlic64': 0x01be,
    'garlic32': 0x01bf,
    'tls': 0x01c0,
    'noise': 0x01c6,
    'quic': 0x01cc,
    'ws': 0x01dd,
    'wss': 0x01de,
    'p2p-websocket-star': 0x01df,
    'http': 0x01e0,
    'swhid-1-snp': 0x01f0,
    'json': 0x0200,
    'messagepack': 0x0201,
    'libp2p-peer-record': 0x0301,
    'libp2p-relay-rsvp': 0x0302,
    'car-index-sorted': 0x0400,
    'sha2-256-trunc254-padded': 0x1012,
    'ripemd-128': 0x1052,
    'ripemd-160': 0x1053,
    'ripemd-256': 0x1054,
    'ripemd-320': 0x1055,
    'x11': 0x1100,
    'p256-pub': 0x1200,
    'p384-pub': 0x1201,
    'p521-pub': 0x1202,
    'ed448-pub': 0x1203,
    'x448-pub': 0x1204,
    'ed25519-priv': 0x1300,
    'secp256k1-priv': 0x1301,
    'x25519-priv': 0x1302,
    'kangarootwelve': 0x1d01,
    'sm3-256': 0x534d,
    'blake2b-8': 0xb201,
    'blake2b-16': 0xb202,
    'blake2b-24': 0xb203,
    'blake2b-32': 0xb204,
    'blake2b-40': 0xb205,
    'blake2b-48': 0xb206,
    'blake2b-56': 0xb207,
    'blake2b-64': 0xb208,
    'blake2b-72': 0xb209,
    'blake2b-80': 0xb20a,
    'blake2b-88': 0xb20b,
    'blake2b-96': 0xb20c,
    'blake2b-104': 0xb20d,
    'blake2b-112': 0xb20e,
    'blake2b-120': 0xb20f,
    'blake2b-128': 0xb210,
    'blake2b-136': 0xb211,
    'blake2b-144': 0xb212,
    'blake2b-152': 0xb213,
    'blake2b-160': 0xb214,
    'blake2b-168': 0xb215,
    'blake2b-176': 0xb216,
    'blake2b-184': 0xb217,
    'blake2b-192': 0xb218,
    'blake2b-200': 0xb219,
    'blake2b-208': 0xb21a,
    'blake2b-216': 0xb21b,
    'blake2b-224': 0xb21c,
    'blake2b-232': 0xb21d,
    'blake2b-240': 0xb21e,
    'blake2b-248': 0xb21f,
    'blake2b-256': 0xb220,
    'blake2b-264': 0xb221,
    'blake2b-272': 0xb222,
    'blake2b-280': 0xb223,
    'blake2b-288': 0xb224,
    'blake2b-296': 0xb225,
    'blake2b-304': 0xb226,
    'blake2b-312': 0xb227,
    'blake2b-320': 0xb228,
    'blake2b-328': 0xb229,
    'blake2b-336': 0xb22a,
    'blake2b-344': 0xb22b,
    'blake2b-352': 0xb22c,
    'blake2b-360': 0xb22d,
    'blake2b-368': 0xb22e,
    'blake2b-376': 0xb22f,
    'blake2b-384': 0xb230,
    'blake2b-392': 0xb231,
    'blake2b-400': 0xb232,
    'blake2b-408': 0xb233,
    'blake2b-416': 0xb234,
    'blake2b-424': 0xb235,
    'blake2b-432': 0xb236,
    'blake2b-440': 0xb237,
    'blake2b-448': 0xb238,
    'blake2b-456': 0xb239,
    'blake2b-464': 0xb23a,
    'blake2b-472': 0xb23b,
    'blake2b-480': 0xb23c,
    'blake2b-488': 0xb23d,
    'blake2b-496': 0xb23e,
    'blake2b-504': 0xb23f,
    'blake2b-512': 0xb240,
    'blake2s-8': 0xb241,
    'blake2s-16': 0xb242,
    'blake2s-24': 0xb243,
    'blake2s-32': 0xb244,
    'blake2s-40': 0xb245,
    'blake2s-48': 0xb246,
    'blake2s-56': 0xb247,
    'blake2s-64': 0xb248,
    'blake2s-72': 0xb249,
    'blake2s-80': 0xb24a,
    'blake2s-88': 0xb24b,
    'blake2s-96': 0xb24c,
    'blake2s-104': 0xb24d,
    'blake2s-112': 0xb24e,
    'blake2s-120': 0xb24f,
    'blake2s-128': 0xb250,
    'blake2s-136': 0xb251,
    'blake2s-144': 0xb252,
    'blake2s-152': 0xb253,
    'blake2s-160': 0xb254,
    'blake2s-168': 0xb255,
    'blake2s-176': 0xb256,
    'blake2s-184': 0xb257,
    'blake2s-192': 0xb258,
    'blake2s-200': 0xb259,
    'blake2s-208': 0xb25a,
    'blake2s-216': 0xb25b,
    'blake2s-224': 0xb25c,
    'blake2s-232': 0xb25d,
    'blake2s-240': 0xb25e,
    'blake2s-248': 0xb25f,
    'blake2s-256': 0xb260,
    'skein256-8': 0xb301,
    'skein256-16': 0xb302,
    'skein256-24': 0xb303,
    'skein256-32': 0xb304,
    'skein256-40': 0xb305,
    'skein256-48': 0xb306,
    'skein256-56': 0xb307,
    'skein256-64': 0xb308,
    'skein256-72': 0xb309,
    'skein256-80': 0xb30a,
    'skein256-88': 0xb30b,
    'skein256-96': 0xb30c,
    'skein256-104': 0xb30d,
    'skein256-112': 0xb30e,
    'skein256-120': 0xb30f,
    'skein256-128': 0xb310,
    'skein256-136': 0xb311,
    'skein256-144': 0xb312,
    'skein256-152': 0xb313,
    'skein256-160': 0xb314,
    'skein256-168': 0xb315,
    'skein256-176': 0xb316,
    'skein256-184': 0xb317,
    'skein256-192': 0xb318,
    'skein256-200': 0xb319,
    'skein256-208': 0xb31a,
    'skein256-216': 0xb31b,
    'skein256-224': 0xb31c,
    'skein256-232': 0xb31d,
    'skein256-240': 0xb31e,
    'skein256-248': 0xb31f,
    'skein256-256': 0xb320,
    'skein512-8': 0xb321,
    'skein512-16': 0xb322,
    'skein512-24': 0xb323,
    'skein512-32': 0xb324,
    'skein512-40': 0xb325,
    'skein512-48': 0xb326,
    'skein512-56': 0xb327,
    'skein512-64': 0xb328,
    'skein512-72': 0xb329,
    'skein512-80': 0xb32a,
    'skein512-88': 0xb32b,
    'skein512-96': 0xb32c,
    'skein512-104': 0xb32d,
    'skein512-112': 0xb32e,
    'skein512-120': 0xb32f,
    'skein512-128': 0xb330,
    'skein512-136': 0xb331,
    'skein512-144': 0xb332,
    'skein512-152': 0xb333,
    'skein512-160': 0xb334,
    'skein512-168': 0xb335,
    'skein512-176': 0xb336,
    'skein512-184': 0xb337,
    'skein512-192': 0xb338,
    'skein512-200': 0xb339,
    'skein512-208': 0xb33a,
    'skein512-216': 0xb33b,
    'skein512-224': 0xb33c,
    'skein512-232': 0xb33d,
    'skein512-240': 0xb33e,
    'skein512-248': 0xb33f,
    'skein512-256': 0xb340,
    'skein512-264': 0xb341,
    'skein512-272': 0xb342,
    'skein512-280': 0xb343,
    'skein512-288': 0xb344,
    'skein512-296': 0xb345,
    'skein512-304': 0xb346,
    'skein512-312': 0xb347,
    'skein512-320': 0xb348,
    'skein512-328': 0xb349,
    'skein512-336': 0xb34a,
    'skein512-344': 0xb34b,
    'skein512-352': 0xb34c,
    'skein512-360': 0xb34d,
    'skein512-368': 0xb34e,
    'skein512-376': 0xb34f,
    'skein512-384': 0xb350,
    'skein512-392': 0xb351,
    'skein512-400': 0xb352,
    'skein512-408': 0xb353,
    'skein512-416': 0xb354,
    'skein512-424': 0xb355,
    'skein512-432': 0xb356,
    'skein512-440': 0xb357,
    'skein512-448': 0xb358,
    'skein512-456': 0xb359,
    'skein512-464': 0xb35a,
    'skein512-472': 0xb35b,
    'skein512-480': 0xb35c,
    'skein512-488': 0xb35d,
    'skein512-496': 0xb35e,
    'skein512-504': 0xb35f,
    'skein512-512': 0xb360,
    'skein1024-8': 0xb361,
    'skein1024-16': 0xb362,
    'skein1024-24': 0xb363,
    'skein1024-32': 0xb364,
    'skein1024-40': 0xb365,
    'skein1024-48': 0xb366,
    'skein1024-56': 0xb367,
    'skein1024-64': 0xb368,
    'skein1024-72': 0xb369,
    'skein1024-80': 0xb36a,
    'skein1024-88': 0xb36b,
    'skein1024-96': 0xb36c,
    'skein1024-104': 0xb36d,
    'skein1024-112': 0xb36e,
    'skein1024-120': 0xb36f,
    'skein1024-128': 0xb370,
    'skein1024-136': 0xb371,
    'skein1024-144': 0xb372,
    'skein1024-152': 0xb373,
    'skein1024-160': 0xb374,
    'skein1024-168': 0xb375,
    'skein1024-176': 0xb376,
    'skein1024-184': 0xb377,
    'skein1024-192': 0xb378,
    'skein1024-200': 0xb379,
    'skein1024-208': 0xb37a,
    'skein1024-216': 0xb37b,
    'skein1024-224': 0xb37c,
    'skein1024-232': 0xb37d,
    'skein1024-240': 0xb37e,
    'skein1024-248': 0xb37f,
    'skein1024-256': 0xb380,
    'skein1024-264': 0xb381,
    'skein1024-272': 0xb382,
    'skein1024-280': 0xb383,
    'skein1024-288': 0xb384,
    'skein1024-296': 0xb385,
    'skein1024-304': 0xb386,
    'skein1024-312': 0xb387,
    'skein1024-320': 0xb388,
    'skein1024-328': 0xb389,
    'skein1024-336': 0xb38a,
    'skein1024-344': 0xb38b,
    'skein1024-352': 0xb38c,
    'skein1024-360': 0xb38d,
    'skein1024-368': 0xb38e,
    'skein1024-376': 0xb38f,
    'skein1024-384': 0xb390,
    'skein1024-392': 0xb391,
    'skein1024-400': 0xb392,
    'skein1024-408': 0xb393,
    'skein1024-416': 0xb394,
    'skein1024-424': 0xb395,
    'skein1024-432': 0xb396,
    'skein1024-440': 0xb397,
    'skein1024-448': 0xb398,
    'skein1024-456': 0xb399,
    'skein1024-464': 0xb39a,
    'skein1024-472': 0xb39b,
    'skein1024-480': 0xb39c,
    'skein1024-488': 0xb39d,
    'skein1024-496': 0xb39e,
    'skein1024-504': 0xb39f,
    'skein1024-512': 0xb3a0,
    'skein1024-520': 0xb3a1,
    'skein1024-528': 0xb3a2,
    'skein1024-536': 0xb3a3,
    'skein1024-544': 0xb3a4,
    'skein1024-552': 0xb3a5,
    'skein1024-560': 0xb3a6,
    'skein1024-568': 0xb3a7,
    'skein1024-576': 0xb3a8,
    'skein1024-584': 0xb3a9,
    'skein1024-592': 0xb3aa,
    'skein1024-600': 0xb3ab,
    'skein1024-608': 0xb3ac,
    'skein1024-616': 0xb3ad,
    'skein1024-624': 0xb3ae,
    'skein1024-632': 0xb3af,
    'skein1024-640': 0xb3b0,
    'skein1024-648': 0xb3b1,
    'skein1024-656': 0xb3b2,
    'skein1024-664': 0xb3b3,
    'skein1024-672': 0xb3b4,
    'skein1024-680': 0xb3b5,
    'skein1024-688': 0xb3b6,
    'skein1024-696': 0xb3b7,
    'skein1024-704': 0xb3b8,
    'skein1024-712': 0xb3b9,
    'skein1024-720': 0xb3ba,
    'skein1024-728': 0xb3bb,
    'skein1024-736': 0xb3bc,
    'skein1024-744': 0xb3bd,
    'skein1024-752': 0xb3be,
    'skein1024-760': 0xb3bf,
    'skein1024-768': 0xb3c0,
    'skein1024-776': 0xb3c1,
    'skein1024-784': 0xb3c2,
    'skein1024-792': 0xb3c3,
    'skein1024-800': 0xb3c4,
    'skein1024-808': 0xb3c5,
    'skein1024-816': 0xb3c6,
    'skein1024-824': 0xb3c7,
    'skein1024-832': 0xb3c8,
    'skein1024-840': 0xb3c9,
    'skein1024-848': 0xb3ca,
    'skein1024-856': 0xb3cb,
    'skein1024-864': 0xb3cc,
    'skein1024-872': 0xb3cd,
    'skein1024-880': 0xb3ce,
    'skein1024-888': 0xb3cf,
    'skein1024-896': 0xb3d0,
    'skein1024-904': 0xb3d1,
    'skein1024-912': 0xb3d2,
    'skein1024-920': 0xb3d3,
    'skein1024-928': 0xb3d4,
    'skein1024-936': 0xb3d5,
    'skein1024-944': 0xb3d6,
    'skein1024-952': 0xb3d7,
    'skein1024-960': 0xb3d8,
    'skein1024-968': 0xb3d9,
    'skein1024-976': 0xb3da,
    'skein1024-984': 0xb3db,
    'skein1024-992': 0xb3dc,
    'skein1024-1000': 0xb3dd,
    'skein1024-1008': 0xb3de,
    'skein1024-1016': 0xb3df,
    'skein1024-1024': 0xb3e0,
    'poseidon-bls12_381-a2-fc1': 0xb401,
    'poseidon-bls12_381-a2-fc1-sc': 0xb402,
    'zeroxcert-imprint-256': 0xce11,
    'fil-commitment-unsealed': 0xf101,
    'fil-commitment-sealed': 0xf102,
    'holochain-adr-v0': 0x807124,
    'holochain-adr-v1': 0x817124,
    'holochain-key-v0': 0x947124,
    'holochain-key-v1': 0x957124,
    'holochain-sig-v0': 0xa27124,
    'holochain-sig-v1': 0xa37124,
    'skynet-ns': 0xb19910,
    'arweave-ns': 0xb29910
});
module.exports = {
    baseTable
};
}),
"[project]/node_modules/multicodec/src/maps.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/** @typedef {import('./generated-types').ConstantCodeMap} ConstantCodeMap */ /** @typedef {import('./generated-types').NameUint8ArrayMap} NameUint8ArrayMap */ /** @typedef {import('./generated-types').CodeNameMap} CodeNameMap */ /** @typedef {import('./generated-types').CodecName} CodecName */ /** @typedef {import('./generated-types').CodecConstant} CodecConstant */ const { baseTable } = __turbopack_context__.r("[project]/node_modules/multicodec/src/generated-table.js [app-client] (ecmascript)");
const varintEncode = __turbopack_context__.r("[project]/node_modules/multicodec/src/util.js [app-client] (ecmascript)").varintEncode;
const nameToVarint = {};
const constantToCode = {};
const codeToName = {};
// eslint-disable-next-line guard-for-in
for(const name in baseTable){
    const codecName = name;
    const code = baseTable[codecName];
    nameToVarint[codecName] = varintEncode(code);
    const constant = codecName.toUpperCase().replace(/-/g, '_');
    constantToCode[constant] = code;
    if (!codeToName[code]) {
        codeToName[code] = codecName;
    }
}
Object.freeze(nameToVarint);
Object.freeze(constantToCode);
Object.freeze(codeToName);
const nameToCode = Object.freeze(baseTable);
module.exports = {
    nameToVarint,
    constantToCode,
    nameToCode,
    codeToName
};
}),
"[project]/node_modules/multicodec/src/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Implementation of the multicodec specification.
 *
 * @module multicodec
 * @example
 * const multicodec = require('multicodec')
 *
 * const prefixedProtobuf = multicodec.addPrefix('protobuf', protobufBuffer)
 * // prefixedProtobuf 0x50...
 *
 */ /** @typedef {import('./generated-types').CodecName} CodecName */ /** @typedef {import('./generated-types').CodecCode} CodecCode */ const varint = __turbopack_context__.r("[project]/node_modules/varint/index.js [app-client] (ecmascript)");
const { concat: uint8ArrayConcat } = __turbopack_context__.r("[project]/node_modules/uint8arrays/esm/src/concat.js [app-client] (ecmascript)");
const util = __turbopack_context__.r("[project]/node_modules/multicodec/src/util.js [app-client] (ecmascript)");
const { nameToVarint, constantToCode, nameToCode, codeToName } = __turbopack_context__.r("[project]/node_modules/multicodec/src/maps.js [app-client] (ecmascript)");
/**
 * Prefix a buffer with a multicodec-packed.
 *
 * @param {CodecName|Uint8Array} multicodecStrOrCode
 * @param {Uint8Array} data
 * @returns {Uint8Array}
 */ function addPrefix(multicodecStrOrCode, data) {
    let prefix;
    if (multicodecStrOrCode instanceof Uint8Array) {
        prefix = util.varintUint8ArrayEncode(multicodecStrOrCode);
    } else {
        if (nameToVarint[multicodecStrOrCode]) {
            prefix = nameToVarint[multicodecStrOrCode];
        } else {
            throw new Error('multicodec not recognized');
        }
    }
    return uint8ArrayConcat([
        prefix,
        data
    ], prefix.length + data.length);
}
/**
 * Decapsulate the multicodec-packed prefix from the data.
 *
 * @param {Uint8Array} data
 * @returns {Uint8Array}
 */ function rmPrefix(data) {
    varint.decode(data);
    return data.slice(varint.decode.bytes);
}
/**
 * Get the codec name of the prefixed data.
 *
 * @param {Uint8Array} prefixedData
 * @returns {CodecName}
 */ function getNameFromData(prefixedData) {
    const code = varint.decode(prefixedData);
    const name = codeToName[code];
    if (name === undefined) {
        throw new Error(`Code "${code}" not found`);
    }
    return name;
}
/**
 * Get the codec name from a code.
 *
 * @param {CodecCode} codec
 * @returns {CodecName}
 */ function getNameFromCode(codec) {
    return codeToName[codec];
}
/**
 * Get the code of the codec
 *
 * @param {CodecName} name
 * @returns {CodecCode}
 */ function getCodeFromName(name) {
    const code = nameToCode[name];
    if (code === undefined) {
        throw new Error(`Codec "${name}" not found`);
    }
    return code;
}
/**
 * Get the code of the prefixed data.
 *
 * @param {Uint8Array} prefixedData
 * @returns {CodecCode}
 */ function getCodeFromData(prefixedData) {
    return varint.decode(prefixedData);
}
/**
 * Get the code as varint of a codec name.
 *
 * @param {CodecName} name
 * @returns {Uint8Array}
 */ function getVarintFromName(name) {
    const code = nameToVarint[name];
    if (code === undefined) {
        throw new Error(`Codec "${name}" not found`);
    }
    return code;
}
/**
 * Get the varint of a code.
 *
 * @param {CodecCode} code
 * @returns {Uint8Array}
 */ function getVarintFromCode(code) {
    return util.varintEncode(code);
}
/**
 * Get the codec name of the prefixed data.
 *
 * @deprecated use getNameFromData instead.
 * @param {Uint8Array} prefixedData
 * @returns {CodecName}
 */ function getCodec(prefixedData) {
    return getNameFromData(prefixedData);
}
/**
 * Get the codec name from a code.
 *
 * @deprecated use getNameFromCode instead.
 * @param {CodecCode} codec
 * @returns {CodecName}
 */ function getName(codec) {
    return getNameFromCode(codec);
}
/**
 * Get the code of the codec
 *
 * @deprecated use getCodeFromName instead.
 * @param {CodecName} name
 * @returns {CodecCode}
 */ function getNumber(name) {
    return getCodeFromName(name);
}
/**
 * Get the code of the prefixed data.
 *
 * @deprecated use getCodeFromData instead.
 * @param {Uint8Array} prefixedData
 * @returns {CodecCode}
 */ function getCode(prefixedData) {
    return getCodeFromData(prefixedData);
}
/**
 * Get the code as varint of a codec name.
 *
 * @deprecated use getVarintFromName instead.
 * @param {CodecName} name
 * @returns {Uint8Array}
 */ function getCodeVarint(name) {
    return getVarintFromName(name);
}
/**
 * Get the varint of a code.
 *
 * @deprecated use getVarintFromCode instead.
 * @param {CodecCode} code
 * @returns {Array.<number>}
 */ function getVarint(code) {
    return Array.from(getVarintFromCode(code));
}
module.exports = {
    addPrefix,
    rmPrefix,
    getNameFromData,
    getNameFromCode,
    getCodeFromName,
    getCodeFromData,
    getVarintFromName,
    getVarintFromCode,
    // Deprecated
    getCodec,
    getName,
    getNumber,
    getCode,
    getCodeVarint,
    getVarint,
    // Make the constants top-level constants
    ...constantToCode,
    // Export the maps
    nameToVarint,
    nameToCode,
    codeToName
};
}),
"[project]/node_modules/cids/src/cid-util.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const mh = __turbopack_context__.r("[project]/node_modules/multihashes/src/index.js [app-client] (ecmascript)");
const CIDUtil = {
    /**
   * Test if the given input is a valid CID object.
   * Returns an error message if it is not.
   * Returns undefined if it is a valid CID.
   *
   * @param {any} other
   * @returns {string|undefined}
   */ checkCIDComponents: function(other) {
        if (other == null) {
            return 'null values are not valid CIDs';
        }
        if (!(other.version === 0 || other.version === 1)) {
            return 'Invalid version, must be a number equal to 1 or 0';
        }
        if (typeof other.codec !== 'string') {
            return 'codec must be string';
        }
        if (other.version === 0) {
            if (other.codec !== 'dag-pb') {
                return "codec must be 'dag-pb' for CIDv0";
            }
            if (other.multibaseName !== 'base58btc') {
                return "multibaseName must be 'base58btc' for CIDv0";
            }
        }
        if (!(other.multihash instanceof Uint8Array)) {
            return 'multihash must be a Uint8Array';
        }
        try {
            mh.validate(other.multihash);
        } catch (err) {
            let errorMsg = err.message;
            if (!errorMsg) {
                errorMsg = 'Multihash validation failed';
            }
            return errorMsg;
        }
    }
};
module.exports = CIDUtil;
}),
"[project]/node_modules/cids/src/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const mh = __turbopack_context__.r("[project]/node_modules/multihashes/src/index.js [app-client] (ecmascript)");
const multibase = __turbopack_context__.r("[project]/node_modules/multibase/src/index.js [app-client] (ecmascript)");
const multicodec = __turbopack_context__.r("[project]/node_modules/multicodec/src/index.js [app-client] (ecmascript)");
const CIDUtil = __turbopack_context__.r("[project]/node_modules/cids/src/cid-util.js [app-client] (ecmascript)");
const { concat: uint8ArrayConcat } = __turbopack_context__.r("[project]/node_modules/uint8arrays/esm/src/concat.js [app-client] (ecmascript)");
const { toString: uint8ArrayToString } = __turbopack_context__.r("[project]/node_modules/uint8arrays/esm/src/to-string.js [app-client] (ecmascript)");
const { equals: uint8ArrayEquals } = __turbopack_context__.r("[project]/node_modules/uint8arrays/esm/src/equals.js [app-client] (ecmascript)");
const codecs = multicodec.nameToCode;
const codecInts = /** @type {CodecName[]} */ Object.keys(codecs).reduce((p, name)=>{
    p[codecs[name]] = name;
    return p;
}, {});
const symbol = Symbol.for('@ipld/js-cid/CID');
/**
 * @typedef {Object} SerializedCID
 * @property {string} codec
 * @property {number} version
 * @property {Uint8Array} hash
 */ /**
 * @typedef {0|1} CIDVersion
 * @typedef {import('multibase').BaseNameOrCode} BaseNameOrCode
 * @typedef {import('multicodec').CodecName} CodecName
 * @typedef {import('multicodec').CodecCode} CodecCode
 */ /**
 * Class representing a CID `<mbase><version><mcodec><mhash>`
 * , as defined in [ipld/cid](https://github.com/multiformats/cid).
 *
 * @class CID
 */ class CID {
    /**
   * Create a new CID.
   *
   * The algorithm for argument input is roughly:
   * ```
   * if (cid)
   *   -> create a copy
   * else if (str)
   *   if (1st char is on multibase table) -> CID String
   *   else -> bs58 encoded multihash
   * else if (Uint8Array)
   *   if (1st byte is 0 or 1) -> CID
   *   else -> multihash
   * else if (Number)
   *   -> construct CID by parts
   * ```
   *
   * @param {CIDVersion | string | Uint8Array | CID} version
   * @param {string|number} [codec]
   * @param {Uint8Array} [multihash]
   * @param {string} [multibaseName]
   *
   * @example
   * new CID(<version>, <codec>, <multihash>, <multibaseName>)
   * new CID(<cidStr>)
   * new CID(<cid.bytes>)
   * new CID(<multihash>)
   * new CID(<bs58 encoded multihash>)
   * new CID(<cid>)
   */ constructor(version, codec, multihash, multibaseName){
        // We have below three blank field accessors only because
        // otherwise TS will not pick them up if done after assignemnts
        /**
     * The version of the CID.
     *
     * @type {CIDVersion}
     */ // eslint-disable-next-line no-unused-expressions
        this.version;
        /**
     * The codec of the CID.
     *
     * @deprecated
     * @type {CodecName}
     */ // eslint-disable-next-line no-unused-expressions
        this.codec;
        /**
     * The multihash of the CID.
     *
     * @type {Uint8Array}
     */ // eslint-disable-next-line no-unused-expressions
        this.multihash;
        Object.defineProperty(this, symbol, {
            value: true
        });
        if (CID.isCID(version)) {
            // version is an exising CID instance
            const cid = version;
            this.version = cid.version;
            this.codec = cid.codec;
            this.multihash = cid.multihash;
            // Default guard for when a CID < 0.7 is passed with no multibaseName
            // @ts-ignore
            this.multibaseName = cid.multibaseName || (cid.version === 0 ? 'base58btc' : 'base32');
            return;
        }
        if (typeof version === 'string') {
            // e.g. 'base32' or false
            const baseName = multibase.isEncoded(version);
            if (baseName) {
                // version is a CID String encoded with multibase, so v1
                const cid = multibase.decode(version);
                this.version = parseInt(cid[0].toString(), 16);
                this.codec = multicodec.getCodec(cid.slice(1));
                this.multihash = multicodec.rmPrefix(cid.slice(1));
                this.multibaseName = baseName;
            } else {
                // version is a base58btc string multihash, so v0
                this.version = 0;
                this.codec = 'dag-pb';
                this.multihash = mh.fromB58String(version);
                this.multibaseName = 'base58btc';
            }
            CID.validateCID(this);
            Object.defineProperty(this, 'string', {
                value: version
            });
            return;
        }
        if (version instanceof Uint8Array) {
            const v = parseInt(version[0].toString(), 16);
            if (v === 1) {
                // version is a CID Uint8Array
                const cid = version;
                this.version = v;
                this.codec = multicodec.getCodec(cid.slice(1));
                this.multihash = multicodec.rmPrefix(cid.slice(1));
                this.multibaseName = 'base32';
            } else {
                // version is a raw multihash Uint8Array, so v0
                this.version = 0;
                this.codec = 'dag-pb';
                this.multihash = version;
                this.multibaseName = 'base58btc';
            }
            CID.validateCID(this);
            return;
        }
        // otherwise, assemble the CID from the parameters
        this.version = version;
        if (typeof codec === 'number') {
            // @ts-ignore
            codec = codecInts[codec];
        }
        this.codec = codec;
        this.multihash = multihash;
        /**
     * Multibase name as string.
     *
     * @deprecated
     * @type {string}
     */ this.multibaseName = multibaseName || (version === 0 ? 'base58btc' : 'base32');
        CID.validateCID(this);
    }
    /**
   * The CID as a `Uint8Array`
   *
   * @returns {Uint8Array}
   *
   */ get bytes() {
        // @ts-ignore
        let bytes = this._bytes;
        if (!bytes) {
            if (this.version === 0) {
                bytes = this.multihash;
            } else if (this.version === 1) {
                const codec = multicodec.getCodeVarint(this.codec);
                bytes = uint8ArrayConcat([
                    [
                        1
                    ],
                    codec,
                    this.multihash
                ], 1 + codec.byteLength + this.multihash.byteLength);
            } else {
                throw new Error('unsupported version');
            }
            // Cache this Uint8Array so it doesn't have to be recreated
            Object.defineProperty(this, '_bytes', {
                value: bytes
            });
        }
        return bytes;
    }
    /**
   * The prefix of the CID.
   *
   * @returns {Uint8Array}
   */ get prefix() {
        const codec = multicodec.getCodeVarint(this.codec);
        const multihash = mh.prefix(this.multihash);
        const prefix = uint8ArrayConcat([
            [
                this.version
            ],
            codec,
            multihash
        ], 1 + codec.byteLength + multihash.byteLength);
        return prefix;
    }
    /**
   * The codec of the CID in its number form.
   *
   * @returns {CodecCode}
   */ get code() {
        return codecs[this.codec];
    }
    /**
   * Convert to a CID of version `0`.
   *
   * @returns {CID}
   */ toV0() {
        if (this.codec !== 'dag-pb') {
            throw new Error('Cannot convert a non dag-pb CID to CIDv0');
        }
        const { name, length } = mh.decode(this.multihash);
        if (name !== 'sha2-256') {
            throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');
        }
        if (length !== 32) {
            throw new Error('Cannot convert non 32 byte multihash CID to CIDv0');
        }
        return new CID(0, this.codec, this.multihash);
    }
    /**
   * Convert to a CID of version `1`.
   *
   * @returns {CID}
   */ toV1() {
        return new CID(1, this.codec, this.multihash, this.multibaseName);
    }
    /**
   * Encode the CID into a string.
   *
   * @param {BaseNameOrCode} [base=this.multibaseName] - Base encoding to use.
   * @returns {string}
   */ toBaseEncodedString(base = this.multibaseName) {
        // @ts-ignore non enumerable cache property
        if (this.string && this.string.length !== 0 && base === this.multibaseName) {
            // @ts-ignore non enumerable cache property
            return this.string;
        }
        let str;
        if (this.version === 0) {
            if (base !== 'base58btc') {
                throw new Error('not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()');
            }
            str = mh.toB58String(this.multihash);
        } else if (this.version === 1) {
            str = uint8ArrayToString(multibase.encode(base, this.bytes));
        } else {
            throw new Error('unsupported version');
        }
        if (base === this.multibaseName) {
            // cache the string value
            Object.defineProperty(this, 'string', {
                value: str
            });
        }
        return str;
    }
    /**
   * CID(QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n)
   *
   * @returns {string}
   */ [Symbol.for('nodejs.util.inspect.custom')]() {
        return 'CID(' + this.toString() + ')';
    }
    /**
   * Encode the CID into a string.
   *
   * @param {BaseNameOrCode} [base=this.multibaseName] - Base encoding to use.
   * @returns {string}
   */ toString(base) {
        return this.toBaseEncodedString(base);
    }
    /**
   * Serialize to a plain object.
   *
   * @returns {SerializedCID}
   */ toJSON() {
        return {
            codec: this.codec,
            version: this.version,
            hash: this.multihash
        };
    }
    /**
   * Compare equality with another CID.
   *
   * @param {CID} other
   * @returns {boolean}
   */ equals(other) {
        return this.codec === other.codec && this.version === other.version && uint8ArrayEquals(this.multihash, other.multihash);
    }
    /**
   * Test if the given input is a valid CID object.
   * Throws if it is not.
   *
   * @param {any} other - The other CID.
   * @returns {void}
   */ static validateCID(other) {
        const errorMsg = CIDUtil.checkCIDComponents(other);
        if (errorMsg) {
            throw new Error(errorMsg);
        }
    }
    /**
   * Check if object is a CID instance
   *
   * @param {any} value
   * @returns {value is CID}
   */ static isCID(value) {
        return value instanceof CID || Boolean(value && value[symbol]);
    }
}
CID.codecs = codecs;
module.exports = CID;
}),
"[project]/node_modules/stable/stable.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

//! stable.js 0.1.8, https://github.com/Two-Screen/stable
//!  2018 Angry Bytes and contributors. MIT licensed.
(function(global, factory) {
    ("TURBOPACK compile-time truthy", 1) ? module.exports = factory() : "TURBOPACK unreachable";
})(/*TURBOPACK member replacement*/ __turbopack_context__.e, function() {
    'use strict';
    // A stable array sort, because `Array#sort()` is not guaranteed stable.
    // This is an implementation of merge sort, without recursion.
    var stable = function(arr, comp) {
        return exec(arr.slice(), comp);
    };
    stable.inplace = function(arr, comp) {
        var result = exec(arr, comp);
        // This simply copies back if the result isn't in the original array,
        // which happens on an odd number of passes.
        if (result !== arr) {
            pass(result, null, arr.length, arr);
        }
        return arr;
    };
    // Execute the sort using the input array and a second buffer as work space.
    // Returns one of those two, containing the final result.
    function exec(arr, comp) {
        if (typeof comp !== 'function') {
            comp = function(a, b) {
                return String(a).localeCompare(b);
            };
        }
        // Short-circuit when there's nothing to sort.
        var len = arr.length;
        if (len <= 1) {
            return arr;
        }
        // Rather than dividing input, simply iterate chunks of 1, 2, 4, 8, etc.
        // Chunks are the size of the left or right hand in merge sort.
        // Stop when the left-hand covers all of the array.
        var buffer = new Array(len);
        for(var chk = 1; chk < len; chk *= 2){
            pass(arr, comp, chk, buffer);
            var tmp = arr;
            arr = buffer;
            buffer = tmp;
        }
        return arr;
    }
    // Run a single pass with the given chunk size.
    var pass = function(arr, comp, chk, result) {
        var len = arr.length;
        var i = 0;
        // Step size / double chunk size.
        var dbl = chk * 2;
        // Bounds of the left and right chunks.
        var l, r, e;
        // Iterators over the left and right chunk.
        var li, ri;
        // Iterate over pairs of chunks.
        for(l = 0; l < len; l += dbl){
            r = l + chk;
            e = r + chk;
            if (r > len) r = len;
            if (e > len) e = len;
            // Iterate both chunks in parallel.
            li = l;
            ri = r;
            while(true){
                // Compare the chunks.
                if (li < r && ri < e) {
                    // This works for a regular `sort()` compatible comparator,
                    // but also for a simple comparator like: `a > b`
                    if (comp(arr[li], arr[ri]) <= 0) {
                        result[i++] = arr[li++];
                    } else {
                        result[i++] = arr[ri++];
                    }
                } else if (li < r) {
                    result[i++] = arr[li++];
                } else if (ri < e) {
                    result[i++] = arr[ri++];
                } else {
                    break;
                }
            }
        }
    };
    return stable;
});
}),
"[project]/node_modules/it-all/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Collects all values from an (async) iterable into an array and returns it.
 *
 * @template T
 * @param {AsyncIterable<T>|Iterable<T>} source
 */ const all = async (source)=>{
    const arr = [];
    for await (const entry of source){
        arr.push(entry);
    }
    return arr;
};
module.exports = all;
}),
"[project]/node_modules/bl/BufferList.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const { Buffer } = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
const symbol = Symbol.for('BufferList');
function BufferList(buf) {
    if (!(this instanceof BufferList)) {
        return new BufferList(buf);
    }
    BufferList._init.call(this, buf);
}
BufferList._init = function _init(buf) {
    Object.defineProperty(this, symbol, {
        value: true
    });
    this._bufs = [];
    this.length = 0;
    if (buf) {
        this.append(buf);
    }
};
BufferList.prototype._new = function _new(buf) {
    return new BufferList(buf);
};
BufferList.prototype._offset = function _offset(offset) {
    if (offset === 0) {
        return [
            0,
            0
        ];
    }
    let tot = 0;
    for(let i = 0; i < this._bufs.length; i++){
        const _t = tot + this._bufs[i].length;
        if (offset < _t || i === this._bufs.length - 1) {
            return [
                i,
                offset - tot
            ];
        }
        tot = _t;
    }
};
BufferList.prototype._reverseOffset = function(blOffset) {
    const bufferId = blOffset[0];
    let offset = blOffset[1];
    for(let i = 0; i < bufferId; i++){
        offset += this._bufs[i].length;
    }
    return offset;
};
BufferList.prototype.get = function get(index) {
    if (index > this.length || index < 0) {
        return undefined;
    }
    const offset = this._offset(index);
    return this._bufs[offset[0]][offset[1]];
};
BufferList.prototype.slice = function slice(start, end) {
    if (typeof start === 'number' && start < 0) {
        start += this.length;
    }
    if (typeof end === 'number' && end < 0) {
        end += this.length;
    }
    return this.copy(null, 0, start, end);
};
BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
    if (typeof srcStart !== 'number' || srcStart < 0) {
        srcStart = 0;
    }
    if (typeof srcEnd !== 'number' || srcEnd > this.length) {
        srcEnd = this.length;
    }
    if (srcStart >= this.length) {
        return dst || Buffer.alloc(0);
    }
    if (srcEnd <= 0) {
        return dst || Buffer.alloc(0);
    }
    const copy = !!dst;
    const off = this._offset(srcStart);
    const len = srcEnd - srcStart;
    let bytes = len;
    let bufoff = copy && dstStart || 0;
    let start = off[1];
    // copy/slice everything
    if (srcStart === 0 && srcEnd === this.length) {
        if (!copy) {
            // slice, but full concat if multiple buffers
            return this._bufs.length === 1 ? this._bufs[0] : Buffer.concat(this._bufs, this.length);
        }
        // copy, need to copy individual buffers
        for(let i = 0; i < this._bufs.length; i++){
            this._bufs[i].copy(dst, bufoff);
            bufoff += this._bufs[i].length;
        }
        return dst;
    }
    // easy, cheap case where it's a subset of one of the buffers
    if (bytes <= this._bufs[off[0]].length - start) {
        return copy ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
    }
    if (!copy) {
        // a slice, we need something to copy in to
        dst = Buffer.allocUnsafe(len);
    }
    for(let i = off[0]; i < this._bufs.length; i++){
        const l = this._bufs[i].length - start;
        if (bytes > l) {
            this._bufs[i].copy(dst, bufoff, start);
            bufoff += l;
        } else {
            this._bufs[i].copy(dst, bufoff, start, start + bytes);
            bufoff += l;
            break;
        }
        bytes -= l;
        if (start) {
            start = 0;
        }
    }
    // safeguard so that we don't return uninitialized memory
    if (dst.length > bufoff) return dst.slice(0, bufoff);
    return dst;
};
BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
    start = start || 0;
    end = typeof end !== 'number' ? this.length : end;
    if (start < 0) {
        start += this.length;
    }
    if (end < 0) {
        end += this.length;
    }
    if (start === end) {
        return this._new();
    }
    const startOffset = this._offset(start);
    const endOffset = this._offset(end);
    const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
    if (endOffset[1] === 0) {
        buffers.pop();
    } else {
        buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
    }
    if (startOffset[1] !== 0) {
        buffers[0] = buffers[0].slice(startOffset[1]);
    }
    return this._new(buffers);
};
BufferList.prototype.toString = function toString(encoding, start, end) {
    return this.slice(start, end).toString(encoding);
};
BufferList.prototype.consume = function consume(bytes) {
    // first, normalize the argument, in accordance with how Buffer does it
    bytes = Math.trunc(bytes);
    // do nothing if not a positive number
    if (Number.isNaN(bytes) || bytes <= 0) return this;
    while(this._bufs.length){
        if (bytes >= this._bufs[0].length) {
            bytes -= this._bufs[0].length;
            this.length -= this._bufs[0].length;
            this._bufs.shift();
        } else {
            this._bufs[0] = this._bufs[0].slice(bytes);
            this.length -= bytes;
            break;
        }
    }
    return this;
};
BufferList.prototype.duplicate = function duplicate() {
    const copy = this._new();
    for(let i = 0; i < this._bufs.length; i++){
        copy.append(this._bufs[i]);
    }
    return copy;
};
BufferList.prototype.append = function append(buf) {
    if (buf == null) {
        return this;
    }
    if (buf.buffer) {
        // append a view of the underlying ArrayBuffer
        this._appendBuffer(Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength));
    } else if (Array.isArray(buf)) {
        for(let i = 0; i < buf.length; i++){
            this.append(buf[i]);
        }
    } else if (this._isBufferList(buf)) {
        // unwrap argument into individual BufferLists
        for(let i = 0; i < buf._bufs.length; i++){
            this.append(buf._bufs[i]);
        }
    } else {
        // coerce number arguments to strings, since Buffer(number) does
        // uninitialized memory allocation
        if (typeof buf === 'number') {
            buf = buf.toString();
        }
        this._appendBuffer(Buffer.from(buf));
    }
    return this;
};
BufferList.prototype._appendBuffer = function appendBuffer(buf) {
    this._bufs.push(buf);
    this.length += buf.length;
};
BufferList.prototype.indexOf = function(search, offset, encoding) {
    if (encoding === undefined && typeof offset === 'string') {
        encoding = offset;
        offset = undefined;
    }
    if (typeof search === 'function' || Array.isArray(search)) {
        throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
    } else if (typeof search === 'number') {
        search = Buffer.from([
            search
        ]);
    } else if (typeof search === 'string') {
        search = Buffer.from(search, encoding);
    } else if (this._isBufferList(search)) {
        search = search.slice();
    } else if (Array.isArray(search.buffer)) {
        search = Buffer.from(search.buffer, search.byteOffset, search.byteLength);
    } else if (!Buffer.isBuffer(search)) {
        search = Buffer.from(search);
    }
    offset = Number(offset || 0);
    if (isNaN(offset)) {
        offset = 0;
    }
    if (offset < 0) {
        offset = this.length + offset;
    }
    if (offset < 0) {
        offset = 0;
    }
    if (search.length === 0) {
        return offset > this.length ? this.length : offset;
    }
    const blOffset = this._offset(offset);
    let blIndex = blOffset[0] // index of which internal buffer we're working on
    ;
    let buffOffset = blOffset[1] // offset of the internal buffer we're working on
    ;
    // scan over each buffer
    for(; blIndex < this._bufs.length; blIndex++){
        const buff = this._bufs[blIndex];
        while(buffOffset < buff.length){
            const availableWindow = buff.length - buffOffset;
            if (availableWindow >= search.length) {
                const nativeSearchResult = buff.indexOf(search, buffOffset);
                if (nativeSearchResult !== -1) {
                    return this._reverseOffset([
                        blIndex,
                        nativeSearchResult
                    ]);
                }
                buffOffset = buff.length - search.length + 1; // end of native search window
            } else {
                const revOffset = this._reverseOffset([
                    blIndex,
                    buffOffset
                ]);
                if (this._match(revOffset, search)) {
                    return revOffset;
                }
                buffOffset++;
            }
        }
        buffOffset = 0;
    }
    return -1;
};
BufferList.prototype._match = function(offset, search) {
    if (this.length - offset < search.length) {
        return false;
    }
    for(let searchOffset = 0; searchOffset < search.length; searchOffset++){
        if (this.get(offset + searchOffset) !== search[searchOffset]) {
            return false;
        }
    }
    return true;
};
(function() {
    const methods = {
        readDoubleBE: 8,
        readDoubleLE: 8,
        readFloatBE: 4,
        readFloatLE: 4,
        readInt32BE: 4,
        readInt32LE: 4,
        readUInt32BE: 4,
        readUInt32LE: 4,
        readInt16BE: 2,
        readInt16LE: 2,
        readUInt16BE: 2,
        readUInt16LE: 2,
        readInt8: 1,
        readUInt8: 1,
        readIntBE: null,
        readIntLE: null,
        readUIntBE: null,
        readUIntLE: null
    };
    for(const m in methods){
        (function(m) {
            if (methods[m] === null) {
                BufferList.prototype[m] = function(offset, byteLength) {
                    return this.slice(offset, offset + byteLength)[m](0, byteLength);
                };
            } else {
                BufferList.prototype[m] = function(offset = 0) {
                    return this.slice(offset, offset + methods[m])[m](0);
                };
            }
        })(m);
    }
})();
// Used internally by the class and also as an indicator of this object being
// a `BufferList`. It's not possible to use `instanceof BufferList` in a browser
// environment because there could be multiple different copies of the
// BufferList class and some `BufferList`s might be `BufferList`s.
BufferList.prototype._isBufferList = function _isBufferList(b) {
    return b instanceof BufferList || BufferList.isBufferList(b);
};
BufferList.isBufferList = function isBufferList(b) {
    return b != null && b[symbol];
};
module.exports = BufferList;
}),
"[project]/node_modules/rabin-wasm/src/rabin.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/**
 * Rabin fingerprinting
 *
 * @class Rabin
 */ class Rabin {
    /**
     * Creates an instance of Rabin.
     * @param { import("./../dist/rabin-wasm") } asModule
     * @param {number} [bits=12]
     * @param {number} [min=8 * 1024]
     * @param {number} [max=32 * 1024]
     * @param {number} polynomial
     * @memberof Rabin
     */ constructor(asModule, bits = 12, min = 8 * 1024, max = 32 * 1024, windowSize = 64, polynomial){
        this.bits = bits;
        this.min = min;
        this.max = max;
        this.asModule = asModule;
        this.rabin = new asModule.Rabin(bits, min, max, windowSize, polynomial);
        this.polynomial = polynomial;
    }
    /**
     * Fingerprints the buffer
     *
     * @param {Uint8Array} buf
     * @returns {Array<number>}
     * @memberof Rabin
     */ fingerprint(buf) {
        const { __retain, __release, __allocArray, __getInt32Array, Int32Array_ID, Uint8Array_ID } = this.asModule;
        const lengths = new Int32Array(Math.ceil(buf.length / this.min));
        const lengthsPtr = __retain(__allocArray(Int32Array_ID, lengths));
        const pointer = __retain(__allocArray(Uint8Array_ID, buf));
        const out = this.rabin.fingerprint(pointer, lengthsPtr);
        const processed = __getInt32Array(out);
        __release(pointer);
        __release(lengthsPtr);
        const end = processed.indexOf(0);
        return end >= 0 ? processed.subarray(0, end) : processed;
    }
}
module.exports = Rabin;
}),
"[project]/node_modules/rabin-wasm/dist/rabin-wasm.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

const { instantiate } = __turbopack_context__.r("[project]/node_modules/@assemblyscript/loader/index.js [app-client] (ecmascript)");
loadWebAssembly.supported = typeof WebAssembly !== 'undefined';
function loadWebAssembly(imp = {}) {
    if (!loadWebAssembly.supported) return null;
    var wasm = new Uint8Array([
        0,
        97,
        115,
        109,
        1,
        0,
        0,
        0,
        1,
        78,
        14,
        96,
        2,
        127,
        126,
        0,
        96,
        1,
        127,
        1,
        126,
        96,
        2,
        127,
        127,
        0,
        96,
        1,
        127,
        1,
        127,
        96,
        1,
        127,
        0,
        96,
        2,
        127,
        127,
        1,
        127,
        96,
        3,
        127,
        127,
        127,
        1,
        127,
        96,
        0,
        0,
        96,
        3,
        127,
        127,
        127,
        0,
        96,
        0,
        1,
        127,
        96,
        4,
        127,
        127,
        127,
        127,
        0,
        96,
        5,
        127,
        127,
        127,
        127,
        127,
        1,
        127,
        96,
        1,
        126,
        1,
        127,
        96,
        2,
        126,
        126,
        1,
        126,
        2,
        13,
        1,
        3,
        101,
        110,
        118,
        5,
        97,
        98,
        111,
        114,
        116,
        0,
        10,
        3,
        54,
        53,
        2,
        2,
        8,
        9,
        3,
        5,
        2,
        8,
        6,
        5,
        3,
        4,
        2,
        6,
        9,
        12,
        13,
        2,
        5,
        11,
        3,
        2,
        3,
        2,
        3,
        2,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        1,
        0,
        6,
        7,
        7,
        4,
        4,
        5,
        3,
        1,
        0,
        1,
        6,
        47,
        9,
        127,
        1,
        65,
        0,
        11,
        127,
        1,
        65,
        0,
        11,
        127,
        0,
        65,
        3,
        11,
        127,
        0,
        65,
        4,
        11,
        127,
        1,
        65,
        0,
        11,
        127,
        1,
        65,
        0,
        11,
        127,
        1,
        65,
        0,
        11,
        127,
        0,
        65,
        240,
        2,
        11,
        127,
        0,
        65,
        6,
        11,
        7,
        240,
        5,
        41,
        6,
        109,
        101,
        109,
        111,
        114,
        121,
        2,
        0,
        7,
        95,
        95,
        97,
        108,
        108,
        111,
        99,
        0,
        10,
        8,
        95,
        95,
        114,
        101,
        116,
        97,
        105,
        110,
        0,
        11,
        9,
        95,
        95,
        114,
        101,
        108,
        101,
        97,
        115,
        101,
        0,
        12,
        9,
        95,
        95,
        99,
        111,
        108,
        108,
        101,
        99,
        116,
        0,
        51,
        11,
        95,
        95,
        114,
        116,
        116,
        105,
        95,
        98,
        97,
        115,
        101,
        3,
        7,
        13,
        73,
        110,
        116,
        51,
        50,
        65,
        114,
        114,
        97,
        121,
        95,
        73,
        68,
        3,
        2,
        13,
        85,
        105,
        110,
        116,
        56,
        65,
        114,
        114,
        97,
        121,
        95,
        73,
        68,
        3,
        3,
        6,
        100,
        101,
        103,
        114,
        101,
        101,
        0,
        16,
        3,
        109,
        111,
        100,
        0,
        17,
        5,
        82,
        97,
        98,
        105,
        110,
        3,
        8,
        16,
        82,
        97,
        98,
        105,
        110,
        35,
        103,
        101,
        116,
        58,
        119,
        105,
        110,
        100,
        111,
        119,
        0,
        21,
        16,
        82,
        97,
        98,
        105,
        110,
        35,
        115,
        101,
        116,
        58,
        119,
        105,
        110,
        100,
        111,
        119,
        0,
        22,
        21,
        82,
        97,
        98,
        105,
        110,
        35,
        103,
        101,
        116,
        58,
        119,
        105,
        110,
        100,
        111,
        119,
        95,
        115,
        105,
        122,
        101,
        0,
        23,
        21,
        82,
        97,
        98,
        105,
        110,
        35,
        115,
        101,
        116,
        58,
        119,
        105,
        110,
        100,
        111,
        119,
        95,
        115,
        105,
        122,
        101,
        0,
        24,
        14,
        82,
        97,
        98,
        105,
        110,
        35,
        103,
        101,
        116,
        58,
        119,
        112,
        111,
        115,
        0,
        25,
        14,
        82,
        97,
        98,
        105,
        110,
        35,
        115,
        101,
        116,
        58,
        119,
        112,
        111,
        115,
        0,
        26,
        15,
        82,
        97,
        98,
        105,
        110,
        35,
        103,
        101,
        116,
        58,
        99,
        111,
        117,
        110,
        116,
        0,
        27,
        15,
        82,
        97,
        98,
        105,
        110,
        35,
        115,
        101,
        116,
        58,
        99,
        111,
        117,
        110,
        116,
        0,
        28,
        13,
        82,
        97,
        98,
        105,
        110,
        35,
        103,
        101,
        116,
        58,
        112,
        111,
        115,
        0,
        29,
        13,
        82,
        97,
        98,
        105,
        110,
        35,
        115,
        101,
        116,
        58,
        112,
        111,
        115,
        0,
        30,
        15,
        82,
        97,
        98,
        105,
        110,
        35,
        103,
        101,
        116,
        58,
        115,
        116,
        97,
        114,
        116,
        0,
        31,
        15,
        82,
        97,
        98,
        105,
        110,
        35,
        115,
        101,
        116,
        58,
        115,
        116,
        97,
        114,
        116,
        0,
        32,
        16,
        82,
        97,
        98,
        105,
        110,
        35,
        103,
        101,
        116,
        58,
        100,
        105,
        103,
        101,
        115,
        116,
        0,
        33,
        16,
        82,
        97,
        98,
        105,
        110,
        35,
        115,
        101,
        116,
        58,
        100,
        105,
        103,
        101,
        115,
        116,
        0,
        34,
        21,
        82,
        97,
        98,
        105,
        110,
        35,
        103,
        101,
        116,
        58,
        99,
        104,
        117,
        110,
        107,
        95,
        115,
        116,
        97,
        114,
        116,
        0,
        35,
        21,
        82,
        97,
        98,
        105,
        110,
        35,
        115,
        101,
        116,
        58,
        99,
        104,
        117,
        110,
        107,
        95,
        115,
        116,
        97,
        114,
        116,
        0,
        36,
        22,
        82,
        97,
        98,
        105,
        110,
        35,
        103,
        101,
        116,
        58,
        99,
        104,
        117,
        110,
        107,
        95,
        108,
        101,
        110,
        103,
        116,
        104,
        0,
        37,
        22,
        82,
        97,
        98,
        105,
        110,
        35,
        115,
        101,
        116,
        58,
        99,
        104,
        117,
        110,
        107,
        95,
        108,
        101,
        110,
        103,
        116,
        104,
        0,
        38,
        31,
        82,
        97,
        98,
        105,
        110,
        35,
        103,
        101,
        116,
        58,
        99,
        104,
        117,
        110,
        107,
        95,
        99,
        117,
        116,
        95,
        102,
        105,
        110,
        103,
        101,
        114,
        112,
        114,
        105,
        110,
        116,
        0,
        39,
        31,
        82,
        97,
        98,
        105,
        110,
        35,
        115,
        101,
        116,
        58,
        99,
        104,
        117,
        110,
        107,
        95,
        99,
        117,
        116,
        95,
        102,
        105,
        110,
        103,
        101,
        114,
        112,
        114,
        105,
        110,
        116,
        0,
        40,
        20,
        82,
        97,
        98,
        105,
        110,
        35,
        103,
        101,
        116,
        58,
        112,
        111,
        108,
        121,
        110,
        111,
        109,
        105,
        97,
        108,
        0,
        41,
        20,
        82,
        97,
        98,
        105,
        110,
        35,
        115,
        101,
        116,
        58,
        112,
        111,
        108,
        121,
        110,
        111,
        109,
        105,
        97,
        108,
        0,
        42,
        17,
        82,
        97,
        98,
        105,
        110,
        35,
        103,
        101,
        116,
        58,
        109,
        105,
        110,
        115,
        105,
        122,
        101,
        0,
        43,
        17,
        82,
        97,
        98,
        105,
        110,
        35,
        115,
        101,
        116,
        58,
        109,
        105,
        110,
        115,
        105,
        122,
        101,
        0,
        44,
        17,
        82,
        97,
        98,
        105,
        110,
        35,
        103,
        101,
        116,
        58,
        109,
        97,
        120,
        115,
        105,
        122,
        101,
        0,
        45,
        17,
        82,
        97,
        98,
        105,
        110,
        35,
        115,
        101,
        116,
        58,
        109,
        97,
        120,
        115,
        105,
        122,
        101,
        0,
        46,
        14,
        82,
        97,
        98,
        105,
        110,
        35,
        103,
        101,
        116,
        58,
        109,
        97,
        115,
        107,
        0,
        47,
        14,
        82,
        97,
        98,
        105,
        110,
        35,
        115,
        101,
        116,
        58,
        109,
        97,
        115,
        107,
        0,
        48,
        17,
        82,
        97,
        98,
        105,
        110,
        35,
        99,
        111,
        110,
        115,
        116,
        114,
        117,
        99,
        116,
        111,
        114,
        0,
        20,
        17,
        82,
        97,
        98,
        105,
        110,
        35,
        102,
        105,
        110,
        103,
        101,
        114,
        112,
        114,
        105,
        110,
        116,
        0,
        49,
        8,
        1,
        50,
        10,
        165,
        31,
        53,
        199,
        1,
        1,
        4,
        127,
        32,
        1,
        40,
        2,
        0,
        65,
        124,
        113,
        34,
        2,
        65,
        128,
        2,
        73,
        4,
        127,
        32,
        2,
        65,
        4,
        118,
        33,
        4,
        65,
        0,
        5,
        32,
        2,
        65,
        31,
        32,
        2,
        103,
        107,
        34,
        3,
        65,
        4,
        107,
        118,
        65,
        16,
        115,
        33,
        4,
        32,
        3,
        65,
        7,
        107,
        11,
        33,
        3,
        32,
        1,
        40,
        2,
        20,
        33,
        2,
        32,
        1,
        40,
        2,
        16,
        34,
        5,
        4,
        64,
        32,
        5,
        32,
        2,
        54,
        2,
        20,
        11,
        32,
        2,
        4,
        64,
        32,
        2,
        32,
        5,
        54,
        2,
        16,
        11,
        32,
        1,
        32,
        0,
        32,
        4,
        32,
        3,
        65,
        4,
        116,
        106,
        65,
        2,
        116,
        106,
        40,
        2,
        96,
        70,
        4,
        64,
        32,
        0,
        32,
        4,
        32,
        3,
        65,
        4,
        116,
        106,
        65,
        2,
        116,
        106,
        32,
        2,
        54,
        2,
        96,
        32,
        2,
        69,
        4,
        64,
        32,
        0,
        32,
        3,
        65,
        2,
        116,
        106,
        32,
        0,
        32,
        3,
        65,
        2,
        116,
        106,
        40,
        2,
        4,
        65,
        1,
        32,
        4,
        116,
        65,
        127,
        115,
        113,
        34,
        1,
        54,
        2,
        4,
        32,
        1,
        69,
        4,
        64,
        32,
        0,
        32,
        0,
        40,
        2,
        0,
        65,
        1,
        32,
        3,
        116,
        65,
        127,
        115,
        113,
        54,
        2,
        0,
        11,
        11,
        11,
        11,
        226,
        2,
        1,
        6,
        127,
        32,
        1,
        40,
        2,
        0,
        33,
        3,
        32,
        1,
        65,
        16,
        106,
        32,
        1,
        40,
        2,
        0,
        65,
        124,
        113,
        106,
        34,
        4,
        40,
        2,
        0,
        34,
        5,
        65,
        1,
        113,
        4,
        64,
        32,
        3,
        65,
        124,
        113,
        65,
        16,
        106,
        32,
        5,
        65,
        124,
        113,
        106,
        34,
        2,
        65,
        240,
        255,
        255,
        255,
        3,
        73,
        4,
        64,
        32,
        0,
        32,
        4,
        16,
        1,
        32,
        1,
        32,
        2,
        32,
        3,
        65,
        3,
        113,
        114,
        34,
        3,
        54,
        2,
        0,
        32,
        1,
        65,
        16,
        106,
        32,
        1,
        40,
        2,
        0,
        65,
        124,
        113,
        106,
        34,
        4,
        40,
        2,
        0,
        33,
        5,
        11,
        11,
        32,
        3,
        65,
        2,
        113,
        4,
        64,
        32,
        1,
        65,
        4,
        107,
        40,
        2,
        0,
        34,
        2,
        40,
        2,
        0,
        34,
        6,
        65,
        124,
        113,
        65,
        16,
        106,
        32,
        3,
        65,
        124,
        113,
        106,
        34,
        7,
        65,
        240,
        255,
        255,
        255,
        3,
        73,
        4,
        64,
        32,
        0,
        32,
        2,
        16,
        1,
        32,
        2,
        32,
        7,
        32,
        6,
        65,
        3,
        113,
        114,
        34,
        3,
        54,
        2,
        0,
        32,
        2,
        33,
        1,
        11,
        11,
        32,
        4,
        32,
        5,
        65,
        2,
        114,
        54,
        2,
        0,
        32,
        4,
        65,
        4,
        107,
        32,
        1,
        54,
        2,
        0,
        32,
        0,
        32,
        3,
        65,
        124,
        113,
        34,
        2,
        65,
        128,
        2,
        73,
        4,
        127,
        32,
        2,
        65,
        4,
        118,
        33,
        4,
        65,
        0,
        5,
        32,
        2,
        65,
        31,
        32,
        2,
        103,
        107,
        34,
        2,
        65,
        4,
        107,
        118,
        65,
        16,
        115,
        33,
        4,
        32,
        2,
        65,
        7,
        107,
        11,
        34,
        3,
        65,
        4,
        116,
        32,
        4,
        106,
        65,
        2,
        116,
        106,
        40,
        2,
        96,
        33,
        2,
        32,
        1,
        65,
        0,
        54,
        2,
        16,
        32,
        1,
        32,
        2,
        54,
        2,
        20,
        32,
        2,
        4,
        64,
        32,
        2,
        32,
        1,
        54,
        2,
        16,
        11,
        32,
        0,
        32,
        4,
        32,
        3,
        65,
        4,
        116,
        106,
        65,
        2,
        116,
        106,
        32,
        1,
        54,
        2,
        96,
        32,
        0,
        32,
        0,
        40,
        2,
        0,
        65,
        1,
        32,
        3,
        116,
        114,
        54,
        2,
        0,
        32,
        0,
        32,
        3,
        65,
        2,
        116,
        106,
        32,
        0,
        32,
        3,
        65,
        2,
        116,
        106,
        40,
        2,
        4,
        65,
        1,
        32,
        4,
        116,
        114,
        54,
        2,
        4,
        11,
        119,
        1,
        1,
        127,
        32,
        2,
        2,
        127,
        32,
        0,
        40,
        2,
        160,
        12,
        34,
        2,
        4,
        64,
        32,
        2,
        32,
        1,
        65,
        16,
        107,
        70,
        4,
        64,
        32,
        2,
        40,
        2,
        0,
        33,
        3,
        32,
        1,
        65,
        16,
        107,
        33,
        1,
        11,
        11,
        32,
        1,
        11,
        107,
        34,
        2,
        65,
        48,
        73,
        4,
        64,
        15,
        11,
        32,
        1,
        32,
        3,
        65,
        2,
        113,
        32,
        2,
        65,
        32,
        107,
        65,
        1,
        114,
        114,
        54,
        2,
        0,
        32,
        1,
        65,
        0,
        54,
        2,
        16,
        32,
        1,
        65,
        0,
        54,
        2,
        20,
        32,
        1,
        32,
        2,
        106,
        65,
        16,
        107,
        34,
        2,
        65,
        2,
        54,
        2,
        0,
        32,
        0,
        32,
        2,
        54,
        2,
        160,
        12,
        32,
        0,
        32,
        1,
        16,
        2,
        11,
        155,
        1,
        1,
        3,
        127,
        35,
        0,
        34,
        0,
        69,
        4,
        64,
        65,
        1,
        63,
        0,
        34,
        0,
        74,
        4,
        127,
        65,
        1,
        32,
        0,
        107,
        64,
        0,
        65,
        0,
        72,
        5,
        65,
        0,
        11,
        4,
        64,
        0,
        11,
        65,
        176,
        3,
        34,
        0,
        65,
        0,
        54,
        2,
        0,
        65,
        208,
        15,
        65,
        0,
        54,
        2,
        0,
        3,
        64,
        32,
        1,
        65,
        23,
        73,
        4,
        64,
        32,
        1,
        65,
        2,
        116,
        65,
        176,
        3,
        106,
        65,
        0,
        54,
        2,
        4,
        65,
        0,
        33,
        2,
        3,
        64,
        32,
        2,
        65,
        16,
        73,
        4,
        64,
        32,
        1,
        65,
        4,
        116,
        32,
        2,
        106,
        65,
        2,
        116,
        65,
        176,
        3,
        106,
        65,
        0,
        54,
        2,
        96,
        32,
        2,
        65,
        1,
        106,
        33,
        2,
        12,
        1,
        11,
        11,
        32,
        1,
        65,
        1,
        106,
        33,
        1,
        12,
        1,
        11,
        11,
        65,
        176,
        3,
        65,
        224,
        15,
        63,
        0,
        65,
        16,
        116,
        16,
        3,
        65,
        176,
        3,
        36,
        0,
        11,
        32,
        0,
        11,
        45,
        0,
        32,
        0,
        65,
        240,
        255,
        255,
        255,
        3,
        79,
        4,
        64,
        65,
        32,
        65,
        224,
        0,
        65,
        201,
        3,
        65,
        29,
        16,
        0,
        0,
        11,
        32,
        0,
        65,
        15,
        106,
        65,
        112,
        113,
        34,
        0,
        65,
        16,
        32,
        0,
        65,
        16,
        75,
        27,
        11,
        169,
        1,
        1,
        1,
        127,
        32,
        0,
        32,
        1,
        65,
        128,
        2,
        73,
        4,
        127,
        32,
        1,
        65,
        4,
        118,
        33,
        1,
        65,
        0,
        5,
        32,
        1,
        65,
        248,
        255,
        255,
        255,
        1,
        73,
        4,
        64,
        32,
        1,
        65,
        1,
        65,
        27,
        32,
        1,
        103,
        107,
        116,
        106,
        65,
        1,
        107,
        33,
        1,
        11,
        32,
        1,
        65,
        31,
        32,
        1,
        103,
        107,
        34,
        2,
        65,
        4,
        107,
        118,
        65,
        16,
        115,
        33,
        1,
        32,
        2,
        65,
        7,
        107,
        11,
        34,
        2,
        65,
        2,
        116,
        106,
        40,
        2,
        4,
        65,
        127,
        32,
        1,
        116,
        113,
        34,
        1,
        4,
        127,
        32,
        0,
        32,
        1,
        104,
        32,
        2,
        65,
        4,
        116,
        106,
        65,
        2,
        116,
        106,
        40,
        2,
        96,
        5,
        32,
        0,
        40,
        2,
        0,
        65,
        127,
        32,
        2,
        65,
        1,
        106,
        116,
        113,
        34,
        1,
        4,
        127,
        32,
        0,
        32,
        0,
        32,
        1,
        104,
        34,
        0,
        65,
        2,
        116,
        106,
        40,
        2,
        4,
        104,
        32,
        0,
        65,
        4,
        116,
        106,
        65,
        2,
        116,
        106,
        40,
        2,
        96,
        5,
        65,
        0,
        11,
        11,
        11,
        111,
        1,
        1,
        127,
        63,
        0,
        34,
        2,
        32,
        1,
        65,
        248,
        255,
        255,
        255,
        1,
        73,
        4,
        127,
        32,
        1,
        65,
        1,
        65,
        27,
        32,
        1,
        103,
        107,
        116,
        65,
        1,
        107,
        106,
        5,
        32,
        1,
        11,
        65,
        16,
        32,
        0,
        40,
        2,
        160,
        12,
        32,
        2,
        65,
        16,
        116,
        65,
        16,
        107,
        71,
        116,
        106,
        65,
        255,
        255,
        3,
        106,
        65,
        128,
        128,
        124,
        113,
        65,
        16,
        118,
        34,
        1,
        32,
        2,
        32,
        1,
        74,
        27,
        64,
        0,
        65,
        0,
        72,
        4,
        64,
        32,
        1,
        64,
        0,
        65,
        0,
        72,
        4,
        64,
        0,
        11,
        11,
        32,
        0,
        32,
        2,
        65,
        16,
        116,
        63,
        0,
        65,
        16,
        116,
        16,
        3,
        11,
        113,
        1,
        2,
        127,
        32,
        1,
        40,
        2,
        0,
        34,
        3,
        65,
        124,
        113,
        32,
        2,
        107,
        34,
        4,
        65,
        32,
        79,
        4,
        64,
        32,
        1,
        32,
        2,
        32,
        3,
        65,
        2,
        113,
        114,
        54,
        2,
        0,
        32,
        2,
        32,
        1,
        65,
        16,
        106,
        106,
        34,
        1,
        32,
        4,
        65,
        16,
        107,
        65,
        1,
        114,
        54,
        2,
        0,
        32,
        0,
        32,
        1,
        16,
        2,
        5,
        32,
        1,
        32,
        3,
        65,
        126,
        113,
        54,
        2,
        0,
        32,
        1,
        65,
        16,
        106,
        32,
        1,
        40,
        2,
        0,
        65,
        124,
        113,
        106,
        32,
        1,
        65,
        16,
        106,
        32,
        1,
        40,
        2,
        0,
        65,
        124,
        113,
        106,
        40,
        2,
        0,
        65,
        125,
        113,
        54,
        2,
        0,
        11,
        11,
        91,
        1,
        2,
        127,
        32,
        0,
        32,
        1,
        16,
        5,
        34,
        4,
        16,
        6,
        34,
        3,
        69,
        4,
        64,
        65,
        1,
        36,
        1,
        65,
        0,
        36,
        1,
        32,
        0,
        32,
        4,
        16,
        6,
        34,
        3,
        69,
        4,
        64,
        32,
        0,
        32,
        4,
        16,
        7,
        32,
        0,
        32,
        4,
        16,
        6,
        33,
        3,
        11,
        11,
        32,
        3,
        65,
        0,
        54,
        2,
        4,
        32,
        3,
        32,
        2,
        54,
        2,
        8,
        32,
        3,
        32,
        1,
        54,
        2,
        12,
        32,
        0,
        32,
        3,
        16,
        1,
        32,
        0,
        32,
        3,
        32,
        4,
        16,
        8,
        32,
        3,
        11,
        13,
        0,
        16,
        4,
        32,
        0,
        32,
        1,
        16,
        9,
        65,
        16,
        106,
        11,
        33,
        1,
        1,
        127,
        32,
        0,
        65,
        172,
        3,
        75,
        4,
        64,
        32,
        0,
        65,
        16,
        107,
        34,
        1,
        32,
        1,
        40,
        2,
        4,
        65,
        1,
        106,
        54,
        2,
        4,
        11,
        32,
        0,
        11,
        18,
        0,
        32,
        0,
        65,
        172,
        3,
        75,
        4,
        64,
        32,
        0,
        65,
        16,
        107,
        16,
        52,
        11,
        11,
        140,
        3,
        1,
        1,
        127,
        2,
        64,
        32,
        1,
        69,
        13,
        0,
        32,
        0,
        65,
        0,
        58,
        0,
        0,
        32,
        0,
        32,
        1,
        106,
        65,
        1,
        107,
        65,
        0,
        58,
        0,
        0,
        32,
        1,
        65,
        2,
        77,
        13,
        0,
        32,
        0,
        65,
        1,
        106,
        65,
        0,
        58,
        0,
        0,
        32,
        0,
        65,
        2,
        106,
        65,
        0,
        58,
        0,
        0,
        32,
        0,
        32,
        1,
        106,
        34,
        2,
        65,
        2,
        107,
        65,
        0,
        58,
        0,
        0,
        32,
        2,
        65,
        3,
        107,
        65,
        0,
        58,
        0,
        0,
        32,
        1,
        65,
        6,
        77,
        13,
        0,
        32,
        0,
        65,
        3,
        106,
        65,
        0,
        58,
        0,
        0,
        32,
        0,
        32,
        1,
        106,
        65,
        4,
        107,
        65,
        0,
        58,
        0,
        0,
        32,
        1,
        65,
        8,
        77,
        13,
        0,
        32,
        1,
        65,
        0,
        32,
        0,
        107,
        65,
        3,
        113,
        34,
        1,
        107,
        33,
        2,
        32,
        0,
        32,
        1,
        106,
        34,
        0,
        65,
        0,
        54,
        2,
        0,
        32,
        0,
        32,
        2,
        65,
        124,
        113,
        34,
        1,
        106,
        65,
        4,
        107,
        65,
        0,
        54,
        2,
        0,
        32,
        1,
        65,
        8,
        77,
        13,
        0,
        32,
        0,
        65,
        4,
        106,
        65,
        0,
        54,
        2,
        0,
        32,
        0,
        65,
        8,
        106,
        65,
        0,
        54,
        2,
        0,
        32,
        0,
        32,
        1,
        106,
        34,
        2,
        65,
        12,
        107,
        65,
        0,
        54,
        2,
        0,
        32,
        2,
        65,
        8,
        107,
        65,
        0,
        54,
        2,
        0,
        32,
        1,
        65,
        24,
        77,
        13,
        0,
        32,
        0,
        65,
        12,
        106,
        65,
        0,
        54,
        2,
        0,
        32,
        0,
        65,
        16,
        106,
        65,
        0,
        54,
        2,
        0,
        32,
        0,
        65,
        20,
        106,
        65,
        0,
        54,
        2,
        0,
        32,
        0,
        65,
        24,
        106,
        65,
        0,
        54,
        2,
        0,
        32,
        0,
        32,
        1,
        106,
        34,
        2,
        65,
        28,
        107,
        65,
        0,
        54,
        2,
        0,
        32,
        2,
        65,
        24,
        107,
        65,
        0,
        54,
        2,
        0,
        32,
        2,
        65,
        20,
        107,
        65,
        0,
        54,
        2,
        0,
        32,
        2,
        65,
        16,
        107,
        65,
        0,
        54,
        2,
        0,
        32,
        0,
        32,
        0,
        65,
        4,
        113,
        65,
        24,
        106,
        34,
        2,
        106,
        33,
        0,
        32,
        1,
        32,
        2,
        107,
        33,
        1,
        3,
        64,
        32,
        1,
        65,
        32,
        79,
        4,
        64,
        32,
        0,
        66,
        0,
        55,
        3,
        0,
        32,
        0,
        65,
        8,
        106,
        66,
        0,
        55,
        3,
        0,
        32,
        0,
        65,
        16,
        106,
        66,
        0,
        55,
        3,
        0,
        32,
        0,
        65,
        24,
        106,
        66,
        0,
        55,
        3,
        0,
        32,
        1,
        65,
        32,
        107,
        33,
        1,
        32,
        0,
        65,
        32,
        106,
        33,
        0,
        12,
        1,
        11,
        11,
        11,
        11,
        178,
        1,
        1,
        3,
        127,
        32,
        1,
        65,
        240,
        255,
        255,
        255,
        3,
        32,
        2,
        118,
        75,
        4,
        64,
        65,
        144,
        1,
        65,
        192,
        1,
        65,
        23,
        65,
        56,
        16,
        0,
        0,
        11,
        32,
        1,
        32,
        2,
        116,
        34,
        3,
        65,
        0,
        16,
        10,
        34,
        2,
        32,
        3,
        16,
        13,
        32,
        0,
        69,
        4,
        64,
        65,
        12,
        65,
        2,
        16,
        10,
        34,
        0,
        65,
        172,
        3,
        75,
        4,
        64,
        32,
        0,
        65,
        16,
        107,
        34,
        1,
        32,
        1,
        40,
        2,
        4,
        65,
        1,
        106,
        54,
        2,
        4,
        11,
        11,
        32,
        0,
        65,
        0,
        54,
        2,
        0,
        32,
        0,
        65,
        0,
        54,
        2,
        4,
        32,
        0,
        65,
        0,
        54,
        2,
        8,
        32,
        2,
        34,
        1,
        32,
        0,
        40,
        2,
        0,
        34,
        4,
        71,
        4,
        64,
        32,
        1,
        65,
        172,
        3,
        75,
        4,
        64,
        32,
        1,
        65,
        16,
        107,
        34,
        5,
        32,
        5,
        40,
        2,
        4,
        65,
        1,
        106,
        54,
        2,
        4,
        11,
        32,
        4,
        16,
        12,
        11,
        32,
        0,
        32,
        1,
        54,
        2,
        0,
        32,
        0,
        32,
        2,
        54,
        2,
        4,
        32,
        0,
        32,
        3,
        54,
        2,
        8,
        32,
        0,
        11,
        46,
        1,
        2,
        127,
        65,
        12,
        65,
        5,
        16,
        10,
        34,
        0,
        65,
        172,
        3,
        75,
        4,
        64,
        32,
        0,
        65,
        16,
        107,
        34,
        1,
        32,
        1,
        40,
        2,
        4,
        65,
        1,
        106,
        54,
        2,
        4,
        11,
        32,
        0,
        65,
        128,
        2,
        65,
        3,
        16,
        14,
        11,
        9,
        0,
        65,
        63,
        32,
        0,
        121,
        167,
        107,
        11,
        49,
        1,
        2,
        127,
        65,
        63,
        32,
        1,
        121,
        167,
        107,
        33,
        2,
        3,
        64,
        65,
        63,
        32,
        0,
        121,
        167,
        107,
        32,
        2,
        107,
        34,
        3,
        65,
        0,
        78,
        4,
        64,
        32,
        0,
        32,
        1,
        32,
        3,
        172,
        134,
        133,
        33,
        0,
        12,
        1,
        11,
        11,
        32,
        0,
        11,
        40,
        0,
        32,
        1,
        32,
        0,
        40,
        2,
        8,
        79,
        4,
        64,
        65,
        128,
        2,
        65,
        192,
        2,
        65,
        163,
        1,
        65,
        44,
        16,
        0,
        0,
        11,
        32,
        1,
        32,
        0,
        40,
        2,
        4,
        106,
        65,
        0,
        58,
        0,
        0,
        11,
        38,
        0,
        32,
        1,
        32,
        0,
        40,
        2,
        8,
        79,
        4,
        64,
        65,
        128,
        2,
        65,
        192,
        2,
        65,
        152,
        1,
        65,
        44,
        16,
        0,
        0,
        11,
        32,
        1,
        32,
        0,
        40,
        2,
        4,
        106,
        45,
        0,
        0,
        11,
        254,
        5,
        2,
        1,
        127,
        4,
        126,
        32,
        0,
        69,
        4,
        64,
        65,
        232,
        0,
        65,
        6,
        16,
        10,
        34,
        0,
        65,
        172,
        3,
        75,
        4,
        64,
        32,
        0,
        65,
        16,
        107,
        34,
        5,
        32,
        5,
        40,
        2,
        4,
        65,
        1,
        106,
        54,
        2,
        4,
        11,
        11,
        32,
        0,
        65,
        0,
        54,
        2,
        0,
        32,
        0,
        65,
        0,
        54,
        2,
        4,
        32,
        0,
        65,
        0,
        54,
        2,
        8,
        32,
        0,
        66,
        0,
        55,
        3,
        16,
        32,
        0,
        66,
        0,
        55,
        3,
        24,
        32,
        0,
        66,
        0,
        55,
        3,
        32,
        32,
        0,
        66,
        0,
        55,
        3,
        40,
        32,
        0,
        66,
        0,
        55,
        3,
        48,
        32,
        0,
        66,
        0,
        55,
        3,
        56,
        32,
        0,
        66,
        0,
        55,
        3,
        64,
        32,
        0,
        66,
        0,
        55,
        3,
        72,
        32,
        0,
        66,
        0,
        55,
        3,
        80,
        32,
        0,
        66,
        0,
        55,
        3,
        88,
        32,
        0,
        66,
        0,
        55,
        3,
        96,
        32,
        0,
        32,
        2,
        173,
        55,
        3,
        80,
        32,
        0,
        32,
        3,
        173,
        55,
        3,
        88,
        65,
        12,
        65,
        4,
        16,
        10,
        34,
        2,
        65,
        172,
        3,
        75,
        4,
        64,
        32,
        2,
        65,
        16,
        107,
        34,
        3,
        32,
        3,
        40,
        2,
        4,
        65,
        1,
        106,
        54,
        2,
        4,
        11,
        32,
        2,
        32,
        4,
        65,
        0,
        16,
        14,
        33,
        2,
        32,
        0,
        40,
        2,
        0,
        16,
        12,
        32,
        0,
        32,
        2,
        54,
        2,
        0,
        32,
        0,
        32,
        4,
        54,
        2,
        4,
        32,
        0,
        66,
        1,
        32,
        1,
        173,
        134,
        66,
        1,
        125,
        55,
        3,
        96,
        32,
        0,
        66,
        243,
        130,
        183,
        218,
        216,
        230,
        232,
        30,
        55,
        3,
        72,
        35,
        4,
        69,
        4,
        64,
        65,
        0,
        33,
        2,
        3,
        64,
        32,
        2,
        65,
        128,
        2,
        72,
        4,
        64,
        32,
        2,
        65,
        255,
        1,
        113,
        173,
        33,
        6,
        32,
        0,
        41,
        3,
        72,
        34,
        7,
        33,
        8,
        65,
        63,
        32,
        7,
        121,
        167,
        107,
        33,
        1,
        3,
        64,
        65,
        63,
        32,
        6,
        121,
        167,
        107,
        32,
        1,
        107,
        34,
        3,
        65,
        0,
        78,
        4,
        64,
        32,
        6,
        32,
        8,
        32,
        3,
        172,
        134,
        133,
        33,
        6,
        12,
        1,
        11,
        11,
        65,
        0,
        33,
        4,
        3,
        64,
        32,
        4,
        32,
        0,
        40,
        2,
        4,
        65,
        1,
        107,
        72,
        4,
        64,
        32,
        6,
        66,
        8,
        134,
        33,
        6,
        32,
        0,
        41,
        3,
        72,
        34,
        7,
        33,
        8,
        65,
        63,
        32,
        7,
        121,
        167,
        107,
        33,
        1,
        3,
        64,
        65,
        63,
        32,
        6,
        121,
        167,
        107,
        32,
        1,
        107,
        34,
        3,
        65,
        0,
        78,
        4,
        64,
        32,
        6,
        32,
        8,
        32,
        3,
        172,
        134,
        133,
        33,
        6,
        12,
        1,
        11,
        11,
        32,
        4,
        65,
        1,
        106,
        33,
        4,
        12,
        1,
        11,
        11,
        35,
        6,
        40,
        2,
        4,
        32,
        2,
        65,
        3,
        116,
        106,
        32,
        6,
        55,
        3,
        0,
        32,
        2,
        65,
        1,
        106,
        33,
        2,
        12,
        1,
        11,
        11,
        65,
        63,
        32,
        0,
        41,
        3,
        72,
        121,
        167,
        107,
        172,
        33,
        7,
        65,
        0,
        33,
        2,
        3,
        64,
        32,
        2,
        65,
        128,
        2,
        72,
        4,
        64,
        35,
        5,
        33,
        1,
        32,
        2,
        172,
        32,
        7,
        134,
        34,
        8,
        33,
        6,
        65,
        63,
        32,
        0,
        41,
        3,
        72,
        34,
        9,
        121,
        167,
        107,
        33,
        3,
        3,
        64,
        65,
        63,
        32,
        6,
        121,
        167,
        107,
        32,
        3,
        107,
        34,
        4,
        65,
        0,
        78,
        4,
        64,
        32,
        6,
        32,
        9,
        32,
        4,
        172,
        134,
        133,
        33,
        6,
        12,
        1,
        11,
        11,
        32,
        1,
        40,
        2,
        4,
        32,
        2,
        65,
        3,
        116,
        106,
        32,
        6,
        32,
        8,
        132,
        55,
        3,
        0,
        32,
        2,
        65,
        1,
        106,
        33,
        2,
        12,
        1,
        11,
        11,
        65,
        1,
        36,
        4,
        11,
        32,
        0,
        66,
        0,
        55,
        3,
        24,
        32,
        0,
        66,
        0,
        55,
        3,
        32,
        65,
        0,
        33,
        2,
        3,
        64,
        32,
        2,
        32,
        0,
        40,
        2,
        4,
        72,
        4,
        64,
        32,
        0,
        40,
        2,
        0,
        32,
        2,
        16,
        18,
        32,
        2,
        65,
        1,
        106,
        33,
        2,
        12,
        1,
        11,
        11,
        32,
        0,
        66,
        0,
        55,
        3,
        40,
        32,
        0,
        65,
        0,
        54,
        2,
        8,
        32,
        0,
        66,
        0,
        55,
        3,
        16,
        32,
        0,
        66,
        0,
        55,
        3,
        40,
        32,
        0,
        40,
        2,
        0,
        32,
        0,
        40,
        2,
        8,
        16,
        19,
        33,
        1,
        32,
        0,
        40,
        2,
        8,
        32,
        0,
        40,
        2,
        0,
        40,
        2,
        4,
        106,
        65,
        1,
        58,
        0,
        0,
        32,
        0,
        32,
        0,
        41,
        3,
        40,
        35,
        6,
        40,
        2,
        4,
        32,
        1,
        65,
        3,
        116,
        106,
        41,
        3,
        0,
        133,
        55,
        3,
        40,
        32,
        0,
        32,
        0,
        40,
        2,
        8,
        65,
        1,
        106,
        32,
        0,
        40,
        2,
        4,
        111,
        54,
        2,
        8,
        32,
        0,
        35,
        5,
        40,
        2,
        4,
        32,
        0,
        41,
        3,
        40,
        34,
        6,
        66,
        45,
        136,
        167,
        65,
        3,
        116,
        106,
        41,
        3,
        0,
        32,
        6,
        66,
        8,
        134,
        66,
        1,
        132,
        133,
        55,
        3,
        40,
        32,
        0,
        11,
        38,
        1,
        1,
        127,
        32,
        0,
        40,
        2,
        0,
        34,
        0,
        65,
        172,
        3,
        75,
        4,
        64,
        32,
        0,
        65,
        16,
        107,
        34,
        1,
        32,
        1,
        40,
        2,
        4,
        65,
        1,
        106,
        54,
        2,
        4,
        11,
        32,
        0,
        11,
        55,
        1,
        2,
        127,
        32,
        1,
        32,
        0,
        40,
        2,
        0,
        34,
        2,
        71,
        4,
        64,
        32,
        1,
        65,
        172,
        3,
        75,
        4,
        64,
        32,
        1,
        65,
        16,
        107,
        34,
        3,
        32,
        3,
        40,
        2,
        4,
        65,
        1,
        106,
        54,
        2,
        4,
        11,
        32,
        2,
        16,
        12,
        11,
        32,
        0,
        32,
        1,
        54,
        2,
        0,
        11,
        7,
        0,
        32,
        0,
        40,
        2,
        4,
        11,
        9,
        0,
        32,
        0,
        32,
        1,
        54,
        2,
        4,
        11,
        7,
        0,
        32,
        0,
        40,
        2,
        8,
        11,
        9,
        0,
        32,
        0,
        32,
        1,
        54,
        2,
        8,
        11,
        7,
        0,
        32,
        0,
        41,
        3,
        16,
        11,
        9,
        0,
        32,
        0,
        32,
        1,
        55,
        3,
        16,
        11,
        7,
        0,
        32,
        0,
        41,
        3,
        24,
        11,
        9,
        0,
        32,
        0,
        32,
        1,
        55,
        3,
        24,
        11,
        7,
        0,
        32,
        0,
        41,
        3,
        32,
        11,
        9,
        0,
        32,
        0,
        32,
        1,
        55,
        3,
        32,
        11,
        7,
        0,
        32,
        0,
        41,
        3,
        40,
        11,
        9,
        0,
        32,
        0,
        32,
        1,
        55,
        3,
        40,
        11,
        7,
        0,
        32,
        0,
        41,
        3,
        48,
        11,
        9,
        0,
        32,
        0,
        32,
        1,
        55,
        3,
        48,
        11,
        7,
        0,
        32,
        0,
        41,
        3,
        56,
        11,
        9,
        0,
        32,
        0,
        32,
        1,
        55,
        3,
        56,
        11,
        7,
        0,
        32,
        0,
        41,
        3,
        64,
        11,
        9,
        0,
        32,
        0,
        32,
        1,
        55,
        3,
        64,
        11,
        7,
        0,
        32,
        0,
        41,
        3,
        72,
        11,
        9,
        0,
        32,
        0,
        32,
        1,
        55,
        3,
        72,
        11,
        7,
        0,
        32,
        0,
        41,
        3,
        80,
        11,
        9,
        0,
        32,
        0,
        32,
        1,
        55,
        3,
        80,
        11,
        7,
        0,
        32,
        0,
        41,
        3,
        88,
        11,
        9,
        0,
        32,
        0,
        32,
        1,
        55,
        3,
        88,
        11,
        7,
        0,
        32,
        0,
        41,
        3,
        96,
        11,
        9,
        0,
        32,
        0,
        32,
        1,
        55,
        3,
        96,
        11,
        172,
        4,
        2,
        5,
        127,
        1,
        126,
        32,
        2,
        65,
        172,
        3,
        75,
        4,
        64,
        32,
        2,
        65,
        16,
        107,
        34,
        4,
        32,
        4,
        40,
        2,
        4,
        65,
        1,
        106,
        54,
        2,
        4,
        11,
        32,
        2,
        33,
        4,
        65,
        0,
        33,
        2,
        32,
        1,
        40,
        2,
        8,
        33,
        5,
        32,
        1,
        40,
        2,
        4,
        33,
        6,
        3,
        64,
        2,
        127,
        65,
        0,
        33,
        3,
        3,
        64,
        32,
        3,
        32,
        5,
        72,
        4,
        64,
        32,
        3,
        32,
        6,
        106,
        45,
        0,
        0,
        33,
        1,
        32,
        0,
        40,
        2,
        0,
        32,
        0,
        40,
        2,
        8,
        16,
        19,
        33,
        7,
        32,
        0,
        40,
        2,
        8,
        32,
        0,
        40,
        2,
        0,
        40,
        2,
        4,
        106,
        32,
        1,
        58,
        0,
        0,
        32,
        0,
        32,
        0,
        41,
        3,
        40,
        35,
        6,
        40,
        2,
        4,
        32,
        7,
        65,
        3,
        116,
        106,
        41,
        3,
        0,
        133,
        55,
        3,
        40,
        32,
        0,
        32,
        0,
        40,
        2,
        8,
        65,
        1,
        106,
        32,
        0,
        40,
        2,
        4,
        111,
        54,
        2,
        8,
        32,
        0,
        35,
        5,
        40,
        2,
        4,
        32,
        0,
        41,
        3,
        40,
        34,
        8,
        66,
        45,
        136,
        167,
        65,
        3,
        116,
        106,
        41,
        3,
        0,
        32,
        1,
        173,
        32,
        8,
        66,
        8,
        134,
        132,
        133,
        55,
        3,
        40,
        32,
        0,
        32,
        0,
        41,
        3,
        16,
        66,
        1,
        124,
        55,
        3,
        16,
        32,
        0,
        32,
        0,
        41,
        3,
        24,
        66,
        1,
        124,
        55,
        3,
        24,
        32,
        0,
        41,
        3,
        16,
        32,
        0,
        41,
        3,
        80,
        90,
        4,
        127,
        32,
        0,
        41,
        3,
        40,
        32,
        0,
        41,
        3,
        96,
        131,
        80,
        5,
        65,
        0,
        11,
        4,
        127,
        65,
        1,
        5,
        32,
        0,
        41,
        3,
        16,
        32,
        0,
        41,
        3,
        88,
        90,
        11,
        4,
        64,
        32,
        0,
        32,
        0,
        41,
        3,
        32,
        55,
        3,
        48,
        32,
        0,
        32,
        0,
        41,
        3,
        16,
        55,
        3,
        56,
        32,
        0,
        32,
        0,
        41,
        3,
        40,
        55,
        3,
        64,
        65,
        0,
        33,
        1,
        3,
        64,
        32,
        1,
        32,
        0,
        40,
        2,
        4,
        72,
        4,
        64,
        32,
        0,
        40,
        2,
        0,
        32,
        1,
        16,
        18,
        32,
        1,
        65,
        1,
        106,
        33,
        1,
        12,
        1,
        11,
        11,
        32,
        0,
        66,
        0,
        55,
        3,
        40,
        32,
        0,
        65,
        0,
        54,
        2,
        8,
        32,
        0,
        66,
        0,
        55,
        3,
        16,
        32,
        0,
        66,
        0,
        55,
        3,
        40,
        32,
        0,
        40,
        2,
        0,
        32,
        0,
        40,
        2,
        8,
        16,
        19,
        33,
        1,
        32,
        0,
        40,
        2,
        8,
        32,
        0,
        40,
        2,
        0,
        40,
        2,
        4,
        106,
        65,
        1,
        58,
        0,
        0,
        32,
        0,
        32,
        0,
        41,
        3,
        40,
        35,
        6,
        40,
        2,
        4,
        32,
        1,
        65,
        3,
        116,
        106,
        41,
        3,
        0,
        133,
        55,
        3,
        40,
        32,
        0,
        32,
        0,
        40,
        2,
        8,
        65,
        1,
        106,
        32,
        0,
        40,
        2,
        4,
        111,
        54,
        2,
        8,
        32,
        0,
        35,
        5,
        40,
        2,
        4,
        32,
        0,
        41,
        3,
        40,
        34,
        8,
        66,
        45,
        136,
        167,
        65,
        3,
        116,
        106,
        41,
        3,
        0,
        32,
        8,
        66,
        8,
        134,
        66,
        1,
        132,
        133,
        55,
        3,
        40,
        32,
        3,
        65,
        1,
        106,
        12,
        3,
        11,
        32,
        3,
        65,
        1,
        106,
        33,
        3,
        12,
        1,
        11,
        11,
        65,
        127,
        11,
        34,
        1,
        65,
        0,
        78,
        4,
        64,
        32,
        5,
        32,
        1,
        107,
        33,
        5,
        32,
        1,
        32,
        6,
        106,
        33,
        6,
        32,
        2,
        34,
        1,
        65,
        1,
        106,
        33,
        2,
        32,
        4,
        40,
        2,
        4,
        32,
        1,
        65,
        2,
        116,
        106,
        32,
        0,
        41,
        3,
        56,
        62,
        2,
        0,
        12,
        1,
        11,
        11,
        32,
        4,
        11,
        10,
        0,
        16,
        15,
        36,
        5,
        16,
        15,
        36,
        6,
        11,
        3,
        0,
        1,
        11,
        73,
        1,
        2,
        127,
        32,
        0,
        40,
        2,
        4,
        34,
        1,
        65,
        255,
        255,
        255,
        255,
        0,
        113,
        34,
        2,
        65,
        1,
        70,
        4,
        64,
        32,
        0,
        65,
        16,
        106,
        16,
        53,
        32,
        0,
        32,
        0,
        40,
        2,
        0,
        65,
        1,
        114,
        54,
        2,
        0,
        35,
        0,
        32,
        0,
        16,
        2,
        5,
        32,
        0,
        32,
        2,
        65,
        1,
        107,
        32,
        1,
        65,
        128,
        128,
        128,
        128,
        127,
        113,
        114,
        54,
        2,
        4,
        11,
        11,
        58,
        0,
        2,
        64,
        2,
        64,
        2,
        64,
        32,
        0,
        65,
        8,
        107,
        40,
        2,
        0,
        14,
        7,
        0,
        0,
        1,
        1,
        1,
        1,
        1,
        2,
        11,
        15,
        11,
        32,
        0,
        40,
        2,
        0,
        34,
        0,
        4,
        64,
        32,
        0,
        65,
        172,
        3,
        79,
        4,
        64,
        32,
        0,
        65,
        16,
        107,
        16,
        52,
        11,
        11,
        15,
        11,
        0,
        11,
        11,
        137,
        3,
        7,
        0,
        65,
        16,
        11,
        55,
        40,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        40,
        0,
        0,
        0,
        97,
        0,
        108,
        0,
        108,
        0,
        111,
        0,
        99,
        0,
        97,
        0,
        116,
        0,
        105,
        0,
        111,
        0,
        110,
        0,
        32,
        0,
        116,
        0,
        111,
        0,
        111,
        0,
        32,
        0,
        108,
        0,
        97,
        0,
        114,
        0,
        103,
        0,
        101,
        0,
        65,
        208,
        0,
        11,
        45,
        30,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        30,
        0,
        0,
        0,
        126,
        0,
        108,
        0,
        105,
        0,
        98,
        0,
        47,
        0,
        114,
        0,
        116,
        0,
        47,
        0,
        116,
        0,
        108,
        0,
        115,
        0,
        102,
        0,
        46,
        0,
        116,
        0,
        115,
        0,
        65,
        128,
        1,
        11,
        43,
        28,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        28,
        0,
        0,
        0,
        73,
        0,
        110,
        0,
        118,
        0,
        97,
        0,
        108,
        0,
        105,
        0,
        100,
        0,
        32,
        0,
        108,
        0,
        101,
        0,
        110,
        0,
        103,
        0,
        116,
        0,
        104,
        0,
        65,
        176,
        1,
        11,
        53,
        38,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        38,
        0,
        0,
        0,
        126,
        0,
        108,
        0,
        105,
        0,
        98,
        0,
        47,
        0,
        97,
        0,
        114,
        0,
        114,
        0,
        97,
        0,
        121,
        0,
        98,
        0,
        117,
        0,
        102,
        0,
        102,
        0,
        101,
        0,
        114,
        0,
        46,
        0,
        116,
        0,
        115,
        0,
        65,
        240,
        1,
        11,
        51,
        36,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        36,
        0,
        0,
        0,
        73,
        0,
        110,
        0,
        100,
        0,
        101,
        0,
        120,
        0,
        32,
        0,
        111,
        0,
        117,
        0,
        116,
        0,
        32,
        0,
        111,
        0,
        102,
        0,
        32,
        0,
        114,
        0,
        97,
        0,
        110,
        0,
        103,
        0,
        101,
        0,
        65,
        176,
        2,
        11,
        51,
        36,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        36,
        0,
        0,
        0,
        126,
        0,
        108,
        0,
        105,
        0,
        98,
        0,
        47,
        0,
        116,
        0,
        121,
        0,
        112,
        0,
        101,
        0,
        100,
        0,
        97,
        0,
        114,
        0,
        114,
        0,
        97,
        0,
        121,
        0,
        46,
        0,
        116,
        0,
        115,
        0,
        65,
        240,
        2,
        11,
        53,
        7,
        0,
        0,
        0,
        16,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        16,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        16,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        145,
        4,
        0,
        0,
        2,
        0,
        0,
        0,
        49,
        0,
        0,
        0,
        2,
        0,
        0,
        0,
        17,
        1,
        0,
        0,
        2,
        0,
        0,
        0,
        16,
        0,
        34,
        16,
        115,
        111,
        117,
        114,
        99,
        101,
        77,
        97,
        112,
        112,
        105,
        110,
        103,
        85,
        82,
        76,
        16,
        46,
        47,
        114,
        97,
        98,
        105,
        110,
        46,
        119,
        97,
        115,
        109,
        46,
        109,
        97,
        112
    ]);
    // make it work async because browsers throw when a wasm module is bigger than 4kb and load sync
    return instantiate(new Response(new Blob([
        wasm
    ], {
        type: 'application/wasm'
    })), imp);
}
module.exports = loadWebAssembly;
}),
"[project]/node_modules/rabin-wasm/src/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

const Rabin = __turbopack_context__.r("[project]/node_modules/rabin-wasm/src/rabin.js [app-client] (ecmascript)");
const getRabin = __turbopack_context__.r("[project]/node_modules/rabin-wasm/dist/rabin-wasm.js [app-client] (ecmascript)");
const create = async (avg, min, max, windowSize, polynomial)=>{
    const compiled = await getRabin();
    return new Rabin(compiled, avg, min, max, windowSize, polynomial);
};
module.exports = {
    Rabin,
    create
};
}),
"[project]/node_modules/@assemblyscript/loader/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// Runtime header offsets
const ID_OFFSET = -8;
const SIZE_OFFSET = -4;
// Runtime ids
const ARRAYBUFFER_ID = 0;
const STRING_ID = 1;
const ARRAYBUFFERVIEW_ID = 2;
// Runtime type information
const ARRAYBUFFERVIEW = 1 << 0;
const ARRAY = 1 << 1;
const SET = 1 << 2;
const MAP = 1 << 3;
const VAL_ALIGN_OFFSET = 5;
const VAL_ALIGN = 1 << VAL_ALIGN_OFFSET;
const VAL_SIGNED = 1 << 10;
const VAL_FLOAT = 1 << 11;
const VAL_NULLABLE = 1 << 12;
const VAL_MANAGED = 1 << 13;
const KEY_ALIGN_OFFSET = 14;
const KEY_ALIGN = 1 << KEY_ALIGN_OFFSET;
const KEY_SIGNED = 1 << 19;
const KEY_FLOAT = 1 << 20;
const KEY_NULLABLE = 1 << 21;
const KEY_MANAGED = 1 << 22;
// Array(BufferView) layout
const ARRAYBUFFERVIEW_BUFFER_OFFSET = 0;
const ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;
const ARRAYBUFFERVIEW_DATALENGTH_OFFSET = 8;
const ARRAYBUFFERVIEW_SIZE = 12;
const ARRAY_LENGTH_OFFSET = 12;
const ARRAY_SIZE = 16;
const BIGINT = typeof BigUint64Array !== "undefined";
const THIS = Symbol();
const CHUNKSIZE = 1024;
/** Gets a string from an U32 and an U16 view on a memory. */ function getStringImpl(buffer, ptr) {
    const U32 = new Uint32Array(buffer);
    const U16 = new Uint16Array(buffer);
    var length = U32[ptr + SIZE_OFFSET >>> 2] >>> 1;
    var offset = ptr >>> 1;
    if (length <= CHUNKSIZE) return String.fromCharCode.apply(String, U16.subarray(offset, offset + length));
    const parts = [];
    do {
        const last = U16[offset + CHUNKSIZE - 1];
        const size = last >= 0xD800 && last < 0xDC00 ? CHUNKSIZE - 1 : CHUNKSIZE;
        parts.push(String.fromCharCode.apply(String, U16.subarray(offset, offset += size)));
        length -= size;
    }while (length > CHUNKSIZE)
    return parts.join("") + String.fromCharCode.apply(String, U16.subarray(offset, offset + length));
}
/** Prepares the base module prior to instantiation. */ function preInstantiate(imports) {
    const baseModule = {};
    function getString(memory, ptr) {
        if (!memory) return "<yet unknown>";
        return getStringImpl(memory.buffer, ptr);
    }
    // add common imports used by stdlib for convenience
    const env = imports.env = imports.env || {};
    env.abort = env.abort || function abort(mesg, file, line, colm) {
        const memory = baseModule.memory || env.memory; // prefer exported, otherwise try imported
        throw Error("abort: " + getString(memory, mesg) + " at " + getString(memory, file) + ":" + line + ":" + colm);
    };
    env.trace = env.trace || function trace(mesg, n) {
        const memory = baseModule.memory || env.memory;
        console.log("trace: " + getString(memory, mesg) + (n ? " " : "") + Array.prototype.slice.call(arguments, 2, 2 + n).join(", "));
    };
    imports.Math = imports.Math || Math;
    imports.Date = imports.Date || Date;
    return baseModule;
}
/** Prepares the final module once instantiation is complete. */ function postInstantiate(baseModule, instance) {
    const rawExports = instance.exports;
    const memory = rawExports.memory;
    const table = rawExports.table;
    const alloc = rawExports["__alloc"];
    const retain = rawExports["__retain"];
    const rttiBase = rawExports["__rtti_base"] || ~0; // oob if not present
    /** Gets the runtime type info for the given id. */ function getInfo(id) {
        const U32 = new Uint32Array(memory.buffer);
        const count = U32[rttiBase >>> 2];
        if ((id >>>= 0) >= count) throw Error("invalid id: " + id);
        return U32[(rttiBase + 4 >>> 2) + id * 2];
    }
    /** Gets the runtime base id for the given id. */ function getBase(id) {
        const U32 = new Uint32Array(memory.buffer);
        const count = U32[rttiBase >>> 2];
        if ((id >>>= 0) >= count) throw Error("invalid id: " + id);
        return U32[(rttiBase + 4 >>> 2) + id * 2 + 1];
    }
    /** Gets the runtime alignment of a collection's values. */ function getValueAlign(info) {
        return 31 - Math.clz32(info >>> VAL_ALIGN_OFFSET & 31); // -1 if none
    }
    /** Gets the runtime alignment of a collection's keys. */ function getKeyAlign(info) {
        return 31 - Math.clz32(info >>> KEY_ALIGN_OFFSET & 31); // -1 if none
    }
    /** Allocates a new string in the module's memory and returns its retained pointer. */ function __allocString(str) {
        const length = str.length;
        const ptr = alloc(length << 1, STRING_ID);
        const U16 = new Uint16Array(memory.buffer);
        for(var i = 0, p = ptr >>> 1; i < length; ++i)U16[p + i] = str.charCodeAt(i);
        return ptr;
    }
    baseModule.__allocString = __allocString;
    /** Reads a string from the module's memory by its pointer. */ function __getString(ptr) {
        const buffer = memory.buffer;
        const id = new Uint32Array(buffer)[ptr + ID_OFFSET >>> 2];
        if (id !== STRING_ID) throw Error("not a string: " + ptr);
        return getStringImpl(buffer, ptr);
    }
    baseModule.__getString = __getString;
    /** Gets the view matching the specified alignment, signedness and floatness. */ function getView(alignLog2, signed, float) {
        const buffer = memory.buffer;
        if (float) {
            switch(alignLog2){
                case 2:
                    return new Float32Array(buffer);
                case 3:
                    return new Float64Array(buffer);
            }
        } else {
            switch(alignLog2){
                case 0:
                    return new (signed ? Int8Array : Uint8Array)(buffer);
                case 1:
                    return new (signed ? Int16Array : Uint16Array)(buffer);
                case 2:
                    return new (signed ? Int32Array : Uint32Array)(buffer);
                case 3:
                    return new (signed ? BigInt64Array : BigUint64Array)(buffer);
            }
        }
        throw Error("unsupported align: " + alignLog2);
    }
    /** Allocates a new array in the module's memory and returns its retained pointer. */ function __allocArray(id, values) {
        const info = getInfo(id);
        if (!(info & (ARRAYBUFFERVIEW | ARRAY))) throw Error("not an array: " + id + " @ " + info);
        const align = getValueAlign(info);
        const length = values.length;
        const buf = alloc(length << align, ARRAYBUFFER_ID);
        const arr = alloc(info & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, id);
        const U32 = new Uint32Array(memory.buffer);
        U32[arr + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = retain(buf);
        U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = buf;
        U32[arr + ARRAYBUFFERVIEW_DATALENGTH_OFFSET >>> 2] = length << align;
        if (info & ARRAY) U32[arr + ARRAY_LENGTH_OFFSET >>> 2] = length;
        const view = getView(align, info & VAL_SIGNED, info & VAL_FLOAT);
        if (info & VAL_MANAGED) {
            for(let i = 0; i < length; ++i)view[(buf >>> align) + i] = retain(values[i]);
        } else {
            view.set(values, buf >>> align);
        }
        return arr;
    }
    baseModule.__allocArray = __allocArray;
    /** Gets a live view on an array's values in the module's memory. Infers the array type from RTTI. */ function __getArrayView(arr) {
        const U32 = new Uint32Array(memory.buffer);
        const id = U32[arr + ID_OFFSET >>> 2];
        const info = getInfo(id);
        if (!(info & ARRAYBUFFERVIEW)) throw Error("not an array: " + id);
        const align = getValueAlign(info);
        var buf = U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];
        const length = info & ARRAY ? U32[arr + ARRAY_LENGTH_OFFSET >>> 2] : U32[buf + SIZE_OFFSET >>> 2] >>> align;
        return getView(align, info & VAL_SIGNED, info & VAL_FLOAT).subarray(buf >>>= align, buf + length);
    }
    baseModule.__getArrayView = __getArrayView;
    /** Copies an array's values from the module's memory. Infers the array type from RTTI. */ function __getArray(arr) {
        const input = __getArrayView(arr);
        const len = input.length;
        const out = new Array(len);
        for(let i = 0; i < len; i++)out[i] = input[i];
        return out;
    }
    baseModule.__getArray = __getArray;
    /** Copies an ArrayBuffer's value from the module's memory. */ function __getArrayBuffer(ptr) {
        const buffer = memory.buffer;
        const length = new Uint32Array(buffer)[ptr + SIZE_OFFSET >>> 2];
        return buffer.slice(ptr, ptr + length);
    }
    baseModule.__getArrayBuffer = __getArrayBuffer;
    /** Copies a typed array's values from the module's memory. */ function getTypedArray(Type, alignLog2, ptr) {
        return new Type(getTypedArrayView(Type, alignLog2, ptr));
    }
    /** Gets a live view on a typed array's values in the module's memory. */ function getTypedArrayView(Type, alignLog2, ptr) {
        const buffer = memory.buffer;
        const U32 = new Uint32Array(buffer);
        const bufPtr = U32[ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];
        return new Type(buffer, bufPtr, U32[bufPtr + SIZE_OFFSET >>> 2] >>> alignLog2);
    }
    baseModule.__getInt8Array = getTypedArray.bind(null, Int8Array, 0);
    baseModule.__getInt8ArrayView = getTypedArrayView.bind(null, Int8Array, 0);
    baseModule.__getUint8Array = getTypedArray.bind(null, Uint8Array, 0);
    baseModule.__getUint8ArrayView = getTypedArrayView.bind(null, Uint8Array, 0);
    baseModule.__getUint8ClampedArray = getTypedArray.bind(null, Uint8ClampedArray, 0);
    baseModule.__getUint8ClampedArrayView = getTypedArrayView.bind(null, Uint8ClampedArray, 0);
    baseModule.__getInt16Array = getTypedArray.bind(null, Int16Array, 1);
    baseModule.__getInt16ArrayView = getTypedArrayView.bind(null, Int16Array, 1);
    baseModule.__getUint16Array = getTypedArray.bind(null, Uint16Array, 1);
    baseModule.__getUint16ArrayView = getTypedArrayView.bind(null, Uint16Array, 1);
    baseModule.__getInt32Array = getTypedArray.bind(null, Int32Array, 2);
    baseModule.__getInt32ArrayView = getTypedArrayView.bind(null, Int32Array, 2);
    baseModule.__getUint32Array = getTypedArray.bind(null, Uint32Array, 2);
    baseModule.__getUint32ArrayView = getTypedArrayView.bind(null, Uint32Array, 2);
    if (BIGINT) {
        baseModule.__getInt64Array = getTypedArray.bind(null, BigInt64Array, 3);
        baseModule.__getInt64ArrayView = getTypedArrayView.bind(null, BigInt64Array, 3);
        baseModule.__getUint64Array = getTypedArray.bind(null, BigUint64Array, 3);
        baseModule.__getUint64ArrayView = getTypedArrayView.bind(null, BigUint64Array, 3);
    }
    baseModule.__getFloat32Array = getTypedArray.bind(null, Float32Array, 2);
    baseModule.__getFloat32ArrayView = getTypedArrayView.bind(null, Float32Array, 2);
    baseModule.__getFloat64Array = getTypedArray.bind(null, Float64Array, 3);
    baseModule.__getFloat64ArrayView = getTypedArrayView.bind(null, Float64Array, 3);
    /** Tests whether an object is an instance of the class represented by the specified base id. */ function __instanceof(ptr, baseId) {
        const U32 = new Uint32Array(memory.buffer);
        var id = U32[ptr + ID_OFFSET >>> 2];
        if (id <= U32[rttiBase >>> 2]) {
            do if (id == baseId) return true;
            while (id = getBase(id))
        }
        return false;
    }
    baseModule.__instanceof = __instanceof;
    // Pull basic exports to baseModule so code in preInstantiate can use them
    baseModule.memory = baseModule.memory || memory;
    baseModule.table = baseModule.table || table;
    // Demangle exports and provide the usual utility on the prototype
    return demangle(rawExports, baseModule);
}
function isResponse(o) {
    return typeof Response !== "undefined" && o instanceof Response;
}
/** Asynchronously instantiates an AssemblyScript module from anything that can be instantiated. */ async function instantiate(source, imports) {
    if (isResponse(source = await source)) return instantiateStreaming(source, imports);
    return postInstantiate(preInstantiate(imports || (imports = {})), await WebAssembly.instantiate(source instanceof WebAssembly.Module ? source : await WebAssembly.compile(source), imports));
}
exports.instantiate = instantiate;
/** Synchronously instantiates an AssemblyScript module from a WebAssembly.Module or binary buffer. */ function instantiateSync(source, imports) {
    return postInstantiate(preInstantiate(imports || (imports = {})), new WebAssembly.Instance(source instanceof WebAssembly.Module ? source : new WebAssembly.Module(source), imports));
}
exports.instantiateSync = instantiateSync;
/** Asynchronously instantiates an AssemblyScript module from a response, i.e. as obtained by `fetch`. */ async function instantiateStreaming(source, imports) {
    if (!WebAssembly.instantiateStreaming) {
        return instantiate(isResponse(source = await source) ? source.arrayBuffer() : source, imports);
    }
    return postInstantiate(preInstantiate(imports || (imports = {})), (await WebAssembly.instantiateStreaming(source, imports)).instance);
}
exports.instantiateStreaming = instantiateStreaming;
/** Demangles an AssemblyScript module's exports to a friendly object structure. */ function demangle(exports1, baseModule) {
    var module = baseModule ? Object.create(baseModule) : {};
    var setArgumentsLength = exports1["__argumentsLength"] ? function(length) {
        exports1["__argumentsLength"].value = length;
    } : exports1["__setArgumentsLength"] || exports1["__setargc"] || function() {};
    for(let internalName in exports1){
        if (!Object.prototype.hasOwnProperty.call(exports1, internalName)) continue;
        const elem = exports1[internalName];
        let parts = internalName.split(".");
        let curr = module;
        while(parts.length > 1){
            let part = parts.shift();
            if (!Object.prototype.hasOwnProperty.call(curr, part)) curr[part] = {};
            curr = curr[part];
        }
        let name = parts[0];
        let hash = name.indexOf("#");
        if (hash >= 0) {
            let className = name.substring(0, hash);
            let classElem = curr[className];
            if (typeof classElem === "undefined" || !classElem.prototype) {
                let ctor = function(...args) {
                    return ctor.wrap(ctor.prototype.constructor(0, ...args));
                };
                ctor.prototype = {
                    valueOf: function valueOf() {
                        return this[THIS];
                    }
                };
                ctor.wrap = function(thisValue) {
                    return Object.create(ctor.prototype, {
                        [THIS]: {
                            value: thisValue,
                            writable: false
                        }
                    });
                };
                if (classElem) Object.getOwnPropertyNames(classElem).forEach((name)=>Object.defineProperty(ctor, name, Object.getOwnPropertyDescriptor(classElem, name)));
                curr[className] = ctor;
            }
            name = name.substring(hash + 1);
            curr = curr[className].prototype;
            if (/^(get|set):/.test(name)) {
                if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {
                    let getter = exports1[internalName.replace("set:", "get:")];
                    let setter = exports1[internalName.replace("get:", "set:")];
                    Object.defineProperty(curr, name, {
                        get: function() {
                            return getter(this[THIS]);
                        },
                        set: function(value) {
                            setter(this[THIS], value);
                        },
                        enumerable: true
                    });
                }
            } else {
                if (name === 'constructor') {
                    (curr[name] = (...args)=>{
                        setArgumentsLength(args.length);
                        return elem(...args);
                    }).original = elem;
                } else {
                    (curr[name] = function(...args) {
                        setArgumentsLength(args.length);
                        return elem(this[THIS], ...args);
                    }).original = elem;
                }
            }
        } else {
            if (/^(get|set):/.test(name)) {
                if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {
                    Object.defineProperty(curr, name, {
                        get: exports1[internalName.replace("set:", "get:")],
                        set: exports1[internalName.replace("get:", "set:")],
                        enumerable: true
                    });
                }
            } else if (typeof elem === "function" && elem !== setArgumentsLength) {
                (curr[name] = (...args)=>{
                    setArgumentsLength(args.length);
                    return elem(...args);
                }).original = elem;
            } else {
                curr[name] = elem;
            }
        }
    }
    return module;
}
exports.demangle = demangle;
}),
"[project]/node_modules/sparse-array/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// JS treats subjects of bitwise operators as SIGNED 32 bit numbers,
// which means the maximum amount of bits we can store inside each byte
// is 7..
const BITS_PER_BYTE = 7;
module.exports = class SparseArray {
    constructor(){
        this._bitArrays = [];
        this._data = [];
        this._length = 0;
        this._changedLength = false;
        this._changedData = false;
    }
    set(index, value) {
        let pos = this._internalPositionFor(index, false);
        if (value === undefined) {
            // unsetting
            if (pos !== -1) {
                // remove item from bit array and array itself
                this._unsetInternalPos(pos);
                this._unsetBit(index);
                this._changedLength = true;
                this._changedData = true;
            }
        } else {
            let needsSort = false;
            if (pos === -1) {
                pos = this._data.length;
                this._setBit(index);
                this._changedData = true;
            } else {
                needsSort = true;
            }
            this._setInternalPos(pos, index, value, needsSort);
            this._changedLength = true;
        }
    }
    unset(index) {
        this.set(index, undefined);
    }
    get(index) {
        this._sortData();
        const pos = this._internalPositionFor(index, true);
        if (pos === -1) {
            return undefined;
        }
        return this._data[pos][1];
    }
    push(value) {
        this.set(this.length, value);
        return this.length;
    }
    get length() {
        this._sortData();
        if (this._changedLength) {
            const last = this._data[this._data.length - 1];
            this._length = last ? last[0] + 1 : 0;
            this._changedLength = false;
        }
        return this._length;
    }
    forEach(iterator) {
        let i = 0;
        while(i < this.length){
            iterator(this.get(i), i, this);
            i++;
        }
    }
    map(iterator) {
        let i = 0;
        let mapped = new Array(this.length);
        while(i < this.length){
            mapped[i] = iterator(this.get(i), i, this);
            i++;
        }
        return mapped;
    }
    reduce(reducer, initialValue) {
        let i = 0;
        let acc = initialValue;
        while(i < this.length){
            const value = this.get(i);
            acc = reducer(acc, value, i);
            i++;
        }
        return acc;
    }
    find(finder) {
        let i = 0, found, last;
        while(i < this.length && !found){
            last = this.get(i);
            found = finder(last);
            i++;
        }
        return found ? last : undefined;
    }
    _internalPositionFor(index, noCreate) {
        const bytePos = this._bytePosFor(index, noCreate);
        if (bytePos >= this._bitArrays.length) {
            return -1;
        }
        const byte = this._bitArrays[bytePos];
        const bitPos = index - bytePos * BITS_PER_BYTE;
        const exists = (byte & 1 << bitPos) > 0;
        if (!exists) {
            return -1;
        }
        const previousPopCount = this._bitArrays.slice(0, bytePos).reduce(popCountReduce, 0);
        const mask = ~(0xffffffff << bitPos + 1);
        const bytePopCount = popCount(byte & mask);
        const arrayPos = previousPopCount + bytePopCount - 1;
        return arrayPos;
    }
    _bytePosFor(index, noCreate) {
        const bytePos = Math.floor(index / BITS_PER_BYTE);
        const targetLength = bytePos + 1;
        while(!noCreate && this._bitArrays.length < targetLength){
            this._bitArrays.push(0);
        }
        return bytePos;
    }
    _setBit(index) {
        const bytePos = this._bytePosFor(index, false);
        this._bitArrays[bytePos] |= 1 << index - bytePos * BITS_PER_BYTE;
    }
    _unsetBit(index) {
        const bytePos = this._bytePosFor(index, false);
        this._bitArrays[bytePos] &= ~(1 << index - bytePos * BITS_PER_BYTE);
    }
    _setInternalPos(pos, index, value, needsSort) {
        const data = this._data;
        const elem = [
            index,
            value
        ];
        if (needsSort) {
            this._sortData();
            data[pos] = elem;
        } else {
            // new element. just shove it into the array
            // but be nice about where we shove it
            // in order to make sorting it later easier
            if (data.length) {
                if (data[data.length - 1][0] >= index) {
                    data.push(elem);
                } else if (data[0][0] <= index) {
                    data.unshift(elem);
                } else {
                    const randomIndex = Math.round(data.length / 2);
                    this._data = data.slice(0, randomIndex).concat(elem).concat(data.slice(randomIndex));
                }
            } else {
                this._data.push(elem);
            }
            this._changedData = true;
            this._changedLength = true;
        }
    }
    _unsetInternalPos(pos) {
        this._data.splice(pos, 1);
    }
    _sortData() {
        if (this._changedData) {
            this._data.sort(sortInternal);
        }
        this._changedData = false;
    }
    bitField() {
        const bytes = [];
        let pendingBitsForResultingByte = 8;
        let pendingBitsForNewByte = 0;
        let resultingByte = 0;
        let newByte;
        const pending = this._bitArrays.slice();
        while(pending.length || pendingBitsForNewByte){
            if (pendingBitsForNewByte === 0) {
                newByte = pending.shift();
                pendingBitsForNewByte = 7;
            }
            const usingBits = Math.min(pendingBitsForNewByte, pendingBitsForResultingByte);
            const mask = ~(0b11111111 << usingBits);
            const masked = newByte & mask;
            resultingByte |= masked << 8 - pendingBitsForResultingByte;
            newByte = newByte >>> usingBits;
            pendingBitsForNewByte -= usingBits;
            pendingBitsForResultingByte -= usingBits;
            if (!pendingBitsForResultingByte || !pendingBitsForNewByte && !pending.length) {
                bytes.push(resultingByte);
                resultingByte = 0;
                pendingBitsForResultingByte = 8;
            }
        }
        // remove trailing zeroes
        for(var i = bytes.length - 1; i > 0; i--){
            const value = bytes[i];
            if (value === 0) {
                bytes.pop();
            } else {
                break;
            }
        }
        return bytes;
    }
    compactArray() {
        this._sortData();
        return this._data.map(valueOnly);
    }
};
function popCountReduce(count, byte) {
    return count + popCount(byte);
}
function popCount(_v) {
    let v = _v;
    v = v - (v >> 1 & 0x55555555); // reuse input as temporary
    v = (v & 0x33333333) + (v >> 2 & 0x33333333); // temp
    return (v + (v >> 4) & 0xF0F0F0F) * 0x1010101 >> 24;
}
function sortInternal(a, b) {
    return a[0] - b[0];
}
function valueOnly(elem) {
    return elem[1];
}
}),
"[project]/node_modules/hamt-sharding/src/bucket.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// @ts-ignore
const SparseArray = __turbopack_context__.r("[project]/node_modules/sparse-array/index.js [app-client] (ecmascript)");
const { fromString: uint8ArrayFromString } = __turbopack_context__.r("[project]/node_modules/uint8arrays/esm/src/from-string.js [app-client] (ecmascript)");
/**
 * @typedef {import('./consumable-hash').InfiniteHash} InfiniteHash
 * @typedef {import('../').UserBucketOptions} UserBucketOptions
 */ /**
 * @template V
 * @typedef {object} BucketChild<V>
 * @property {string} key
 * @property {V} value
 * @property {InfiniteHash} hash
 */ /**
 * @template B
 *
 * @typedef {object} SA<B>
 * @property {number} length
 * @property {() => B[]} compactArray
 * @property {(i: number) => B} get
 * @property {(i: number, value: B) => void} set
 * @property {<A> (fn: (acc: A, curr: B, index: number) => A, initial: A) => B} reduce
 * @property {(fn: (item: B) => boolean) => B | undefined} find
 * @property {() => number[]} bitField
 * @property {(i: number) => void} unset
 */ /**
 * @template T
 *
 * @typedef {object} BucketPosition<T>
 * @property {Bucket<T>} bucket
 * @property {number} pos
 * @property {InfiniteHash} hash
 * @property {BucketChild<T>} [existingChild]
 */ /**
 * @typedef {object} BucketOptions
 * @property {number} bits
 * @property {(value: Uint8Array | InfiniteHash) => InfiniteHash} hash
 */ /**
 * @template T
 */ class Bucket {
    /**
   * @param {BucketOptions} options
   * @param {Bucket<T>} [parent]
   * @param {number} [posAtParent=0]
   */ constructor(options, parent, posAtParent = 0){
        this._options = options;
        this._popCount = 0;
        this._parent = parent;
        this._posAtParent = posAtParent;
        /** @type {SA<Bucket<T> | BucketChild<T>>} */ this._children = new SparseArray();
        /** @type {string | null} */ this.key = null;
    }
    /**
   * @param {string} key
   * @param {T} value
   */ async put(key, value) {
        const place = await this._findNewBucketAndPos(key);
        await place.bucket._putAt(place, key, value);
    }
    /**
   * @param {string} key
   */ async get(key) {
        const child = await this._findChild(key);
        if (child) {
            return child.value;
        }
    }
    /**
   * @param {string} key
   */ async del(key) {
        const place = await this._findPlace(key);
        const child = place.bucket._at(place.pos);
        if (child && child.key === key) {
            place.bucket._delAt(place.pos);
        }
    }
    /**
   * @returns {number}
   */ leafCount() {
        const children = this._children.compactArray();
        return children.reduce((acc, child)=>{
            if (child instanceof Bucket) {
                return acc + child.leafCount();
            }
            return acc + 1;
        }, 0);
    }
    childrenCount() {
        return this._children.length;
    }
    onlyChild() {
        return this._children.get(0);
    }
    /**
   * @returns {Iterable<BucketChild<T>>}
   */ *eachLeafSeries() {
        const children = this._children.compactArray();
        for (const child of children){
            if (child instanceof Bucket) {
                yield* child.eachLeafSeries();
            } else {
                yield child;
            }
        }
        // this is necessary because tsc requires a @return annotation as it
        // can't derive a return type due to the recursion, and eslint requires
        // a return statement when there is a @return annotation
        return [];
    }
    /**
   * @param {(value: BucketChild<T>, index: number) => T} map
   * @param {(reduced: any) => any} reduce
   */ serialize(map, reduce) {
        /** @type {T[]} */ const acc = [];
        // serialize to a custom non-sparse representation
        return reduce(this._children.reduce((acc, child, index)=>{
            if (child) {
                if (child instanceof Bucket) {
                    acc.push(child.serialize(map, reduce));
                } else {
                    acc.push(map(child, index));
                }
            }
            return acc;
        }, acc));
    }
    /**
   * @param {(value: BucketChild<T>) => Promise<T[]>} asyncMap
   * @param {(reduced: any) => Promise<any>} asyncReduce
   */ asyncTransform(asyncMap, asyncReduce) {
        return asyncTransformBucket(this, asyncMap, asyncReduce);
    }
    toJSON() {
        return this.serialize(mapNode, reduceNodes);
    }
    prettyPrint() {
        return JSON.stringify(this.toJSON(), null, '  ');
    }
    tableSize() {
        return Math.pow(2, this._options.bits);
    }
    /**
   * @param {string} key
   * @returns {Promise<BucketChild<T> | undefined>}
   */ async _findChild(key) {
        const result = await this._findPlace(key);
        const child = result.bucket._at(result.pos);
        if (child instanceof Bucket) {
            // should not be possible, this._findPlace should always
            // return a location for a child, not a bucket
            return undefined;
        }
        if (child && child.key === key) {
            return child;
        }
    }
    /**
   * @param {string | InfiniteHash} key
   * @returns {Promise<BucketPosition<T>>}
   */ async _findPlace(key) {
        const hashValue = this._options.hash(typeof key === 'string' ? uint8ArrayFromString(key) : key);
        const index = await hashValue.take(this._options.bits);
        const child = this._children.get(index);
        if (child instanceof Bucket) {
            return child._findPlace(hashValue);
        }
        return {
            bucket: this,
            pos: index,
            hash: hashValue,
            existingChild: child
        };
    }
    /**
   * @param {string | InfiniteHash} key
   * @returns {Promise<BucketPosition<T>>}
   */ async _findNewBucketAndPos(key) {
        const place = await this._findPlace(key);
        if (place.existingChild && place.existingChild.key !== key) {
            // conflict
            const bucket = new Bucket(this._options, place.bucket, place.pos);
            place.bucket._putObjectAt(place.pos, bucket);
            // put the previous value
            const newPlace = await bucket._findPlace(place.existingChild.hash);
            newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value);
            return bucket._findNewBucketAndPos(place.hash);
        }
        // no conflict, we found the place
        return place;
    }
    /**
   * @param {BucketPosition<T>} place
   * @param {string} key
   * @param {T} value
   */ _putAt(place, key, value) {
        this._putObjectAt(place.pos, {
            key: key,
            value: value,
            hash: place.hash
        });
    }
    /**
   * @param {number} pos
   * @param {Bucket<T> | BucketChild<T>} object
   */ _putObjectAt(pos, object) {
        if (!this._children.get(pos)) {
            this._popCount++;
        }
        this._children.set(pos, object);
    }
    /**
   * @param {number} pos
   */ _delAt(pos) {
        if (pos === -1) {
            throw new Error('Invalid position');
        }
        if (this._children.get(pos)) {
            this._popCount--;
        }
        this._children.unset(pos);
        this._level();
    }
    _level() {
        if (this._parent && this._popCount <= 1) {
            if (this._popCount === 1) {
                // remove myself from parent, replacing me with my only child
                const onlyChild = this._children.find(exists);
                if (onlyChild && !(onlyChild instanceof Bucket)) {
                    const hash = onlyChild.hash;
                    hash.untake(this._options.bits);
                    const place = {
                        pos: this._posAtParent,
                        hash: hash,
                        bucket: this._parent
                    };
                    this._parent._putAt(place, onlyChild.key, onlyChild.value);
                }
            } else {
                this._parent._delAt(this._posAtParent);
            }
        }
    }
    /**
   * @param {number} index
   * @returns {BucketChild<T> | Bucket<T> | undefined}
   */ _at(index) {
        return this._children.get(index);
    }
}
/**
 * @param {any} o
 */ function exists(o) {
    return Boolean(o);
}
/**
 *
 * @param {*} node
 * @param {number} index
 */ function mapNode(node, index) {
    return node.key;
}
/**
 * @param {*} nodes
 */ function reduceNodes(nodes) {
    return nodes;
}
/**
 * @template T
 *
 * @param {Bucket<T>} bucket
 * @param {(value: BucketChild<T>) => Promise<T[]>} asyncMap
 * @param {(reduced: any) => Promise<any>} asyncReduce
 */ async function asyncTransformBucket(bucket, asyncMap, asyncReduce) {
    const output = [];
    for (const child of bucket._children.compactArray()){
        if (child instanceof Bucket) {
            await asyncTransformBucket(child, asyncMap, asyncReduce);
        } else {
            const mappedChildren = await asyncMap(child);
            output.push({
                bitField: bucket._children.bitField(),
                children: mappedChildren
            });
        }
    }
    return asyncReduce(output);
}
module.exports = Bucket;
}),
"[project]/node_modules/hamt-sharding/src/consumable-buffer.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const START_MASKS = [
    0b11111111,
    0b11111110,
    0b11111100,
    0b11111000,
    0b11110000,
    0b11100000,
    0b11000000,
    0b10000000
];
const STOP_MASKS = [
    0b00000001,
    0b00000011,
    0b00000111,
    0b00001111,
    0b00011111,
    0b00111111,
    0b01111111,
    0b11111111
];
module.exports = class ConsumableBuffer {
    /**
   * @param {Uint8Array} value
   */ constructor(value){
        this._value = value;
        this._currentBytePos = value.length - 1;
        this._currentBitPos = 7;
    }
    availableBits() {
        return this._currentBitPos + 1 + this._currentBytePos * 8;
    }
    totalBits() {
        return this._value.length * 8;
    }
    /**
   * @param {number} bits
   */ take(bits) {
        let pendingBits = bits;
        let result = 0;
        while(pendingBits && this._haveBits()){
            const byte = this._value[this._currentBytePos];
            const availableBits = this._currentBitPos + 1;
            const taking = Math.min(availableBits, pendingBits);
            const value = byteBitsToInt(byte, availableBits - taking, taking);
            result = (result << taking) + value;
            pendingBits -= taking;
            this._currentBitPos -= taking;
            if (this._currentBitPos < 0) {
                this._currentBitPos = 7;
                this._currentBytePos--;
            }
        }
        return result;
    }
    /**
   * @param {number} bits
   */ untake(bits) {
        this._currentBitPos += bits;
        while(this._currentBitPos > 7){
            this._currentBitPos -= 8;
            this._currentBytePos += 1;
        }
    }
    _haveBits() {
        return this._currentBytePos >= 0;
    }
};
/**
 * @param {number} byte
 * @param {number} start
 * @param {number} length
 */ function byteBitsToInt(byte, start, length) {
    const mask = maskFor(start, length);
    return (byte & mask) >>> start;
}
/**
 * @param {number} start
 * @param {number} length
 */ function maskFor(start, length) {
    return START_MASKS[start] & STOP_MASKS[Math.min(length + start - 1, 7)];
}
}),
"[project]/node_modules/hamt-sharding/src/consumable-hash.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const ConsumableBuffer = __turbopack_context__.r("[project]/node_modules/hamt-sharding/src/consumable-buffer.js [app-client] (ecmascript)");
const { concat: uint8ArrayConcat } = __turbopack_context__.r("[project]/node_modules/uint8arrays/esm/src/concat.js [app-client] (ecmascript)");
/**
 * @param {(value: Uint8Array) => Promise<Uint8Array>} hashFn
 */ function wrapHash(hashFn) {
    /**
   * @param {InfiniteHash | Uint8Array} value
   */ function hashing(value) {
        if (value instanceof InfiniteHash) {
            // already a hash. return it
            return value;
        } else {
            return new InfiniteHash(value, hashFn);
        }
    }
    return hashing;
}
class InfiniteHash {
    /**
   *
   * @param {Uint8Array} value
   * @param {(value: Uint8Array) => Promise<Uint8Array>} hashFn
   */ constructor(value, hashFn){
        if (!(value instanceof Uint8Array)) {
            throw new Error('can only hash Uint8Arrays');
        }
        this._value = value;
        this._hashFn = hashFn;
        this._depth = -1;
        this._availableBits = 0;
        this._currentBufferIndex = 0;
        /** @type {ConsumableBuffer[]} */ this._buffers = [];
    }
    /**
   * @param {number} bits
   */ async take(bits) {
        let pendingBits = bits;
        while(this._availableBits < pendingBits){
            await this._produceMoreBits();
        }
        let result = 0;
        while(pendingBits > 0){
            const hash = this._buffers[this._currentBufferIndex];
            const available = Math.min(hash.availableBits(), pendingBits);
            const took = hash.take(available);
            result = (result << available) + took;
            pendingBits -= available;
            this._availableBits -= available;
            if (hash.availableBits() === 0) {
                this._currentBufferIndex++;
            }
        }
        return result;
    }
    /**
   * @param {number} bits
   */ untake(bits) {
        let pendingBits = bits;
        while(pendingBits > 0){
            const hash = this._buffers[this._currentBufferIndex];
            const availableForUntake = Math.min(hash.totalBits() - hash.availableBits(), pendingBits);
            hash.untake(availableForUntake);
            pendingBits -= availableForUntake;
            this._availableBits += availableForUntake;
            if (this._currentBufferIndex > 0 && hash.totalBits() === hash.availableBits()) {
                this._depth--;
                this._currentBufferIndex--;
            }
        }
    }
    async _produceMoreBits() {
        this._depth++;
        const value = this._depth ? uint8ArrayConcat([
            this._value,
            Uint8Array.from([
                this._depth
            ])
        ]) : this._value;
        const hashValue = await this._hashFn(value);
        const buffer = new ConsumableBuffer(hashValue);
        this._buffers.push(buffer);
        this._availableBits += buffer.availableBits();
    }
}
module.exports = wrapHash;
module.exports.InfiniteHash = InfiniteHash;
}),
"[project]/node_modules/hamt-sharding/src/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

const Bucket = __turbopack_context__.r("[project]/node_modules/hamt-sharding/src/bucket.js [app-client] (ecmascript)");
const wrapHash = __turbopack_context__.r("[project]/node_modules/hamt-sharding/src/consumable-hash.js [app-client] (ecmascript)");
/**
 * @typedef {object} UserBucketOptions
 * @property {(value: Uint8Array) => Promise<Uint8Array>} hashFn
 * @property {number} [bits=8]
 */ /**
 * @param {UserBucketOptions} options
 */ function createHAMT(options) {
    if (!options || !options.hashFn) {
        throw new Error('please define an options.hashFn');
    }
    const bucketOptions = {
        bits: options.bits || 8,
        hash: wrapHash(options.hashFn)
    };
    return new Bucket(bucketOptions);
}
module.exports = {
    createHAMT,
    Bucket
};
}),
"[project]/node_modules/ipfs-only-hash/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

const { importer } = __turbopack_context__.r("[project]/node_modules/ipfs-unixfs-importer/src/index.js [app-client] (ecmascript)");
const block = {
    get: async (cid)=>{
        throw new Error(`unexpected block API get for ${cid}`);
    },
    put: async ()=>{
        throw new Error('unexpected block API put');
    }
};
exports.of = async (content, options)=>{
    options = options || {};
    options.onlyHash = true;
    if (typeof content === 'string') {
        content = new TextEncoder().encode(content);
    }
    let lastCid;
    for await (const { cid } of importer([
        {
            content
        }
    ], block, options)){
        lastCid = cid;
    }
    return `${lastCid}`;
};
}),
"[project]/node_modules/typestub-ipfs-only-hash/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = __turbopack_context__.r("[project]/node_modules/ipfs-only-hash/index.js [app-client] (ecmascript)");
}),
"[project]/node_modules/eventemitter3/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var has = Object.prototype.hasOwnProperty, prefix = '~';
/**
 * Constructor to create a storage for our `EE` objects.
 * An `Events` instance is a plain object whose properties are event names.
 *
 * @constructor
 * @private
 */ function Events() {}
//
// We try to not inherit from `Object.prototype`. In some engines creating an
// instance in this way is faster than calling `Object.create(null)` directly.
// If `Object.create(null)` is not supported we prefix the event names with a
// character to make sure that the built-in object properties are not
// overridden or used as an attack vector.
//
if (Object.create) {
    Events.prototype = Object.create(null);
    //
    // This hack is needed because the `__proto__` property is still inherited in
    // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
    //
    if (!new Events().__proto__) prefix = false;
}
/**
 * Representation of a single event listener.
 *
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
 * @constructor
 * @private
 */ function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
}
/**
 * Add a listener for a given event.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} context The context to invoke the listener with.
 * @param {Boolean} once Specify if the listener is a one-time listener.
 * @returns {EventEmitter}
 * @private
 */ function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== 'function') {
        throw new TypeError('The listener must be a function');
    }
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
    else emitter._events[evt] = [
        emitter._events[evt],
        listener
    ];
    return emitter;
}
/**
 * Clear event by name.
 *
 * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
 * @param {(String|Symbol)} evt The Event name.
 * @private
 */ function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0) emitter._events = new Events();
    else delete emitter._events[evt];
}
/**
 * Minimal `EventEmitter` interface that is molded against the Node.js
 * `EventEmitter` interface.
 *
 * @constructor
 * @public
 */ function EventEmitter() {
    this._events = new Events();
    this._eventsCount = 0;
}
/**
 * Return an array listing the events for which the emitter has registered
 * listeners.
 *
 * @returns {Array}
 * @public
 */ EventEmitter.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0) return names;
    for(name in events = this._events){
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
};
/**
 * Return the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Array} The registered listeners.
 * @public
 */ EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers) return [];
    if (handlers.fn) return [
        handlers.fn
    ];
    for(var i = 0, l = handlers.length, ee = new Array(l); i < l; i++){
        ee[i] = handlers[i].fn;
    }
    return ee;
};
/**
 * Return the number of listeners listening to a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Number} The number of listeners.
 * @public
 */ EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners) return 0;
    if (listeners.fn) return 1;
    return listeners.length;
};
/**
 * Calls each of the listeners registered for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @returns {Boolean} `true` if the event had listeners, else `false`.
 * @public
 */ EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
        switch(len){
            case 1:
                return listeners.fn.call(listeners.context), true;
            case 2:
                return listeners.fn.call(listeners.context, a1), true;
            case 3:
                return listeners.fn.call(listeners.context, a1, a2), true;
            case 4:
                return listeners.fn.call(listeners.context, a1, a2, a3), true;
            case 5:
                return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
            case 6:
                return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for(i = 1, args = new Array(len - 1); i < len; i++){
            args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
    } else {
        var length = listeners.length, j;
        for(i = 0; i < length; i++){
            if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
            switch(len){
                case 1:
                    listeners[i].fn.call(listeners[i].context);
                    break;
                case 2:
                    listeners[i].fn.call(listeners[i].context, a1);
                    break;
                case 3:
                    listeners[i].fn.call(listeners[i].context, a1, a2);
                    break;
                case 4:
                    listeners[i].fn.call(listeners[i].context, a1, a2, a3);
                    break;
                default:
                    if (!args) for(j = 1, args = new Array(len - 1); j < len; j++){
                        args[j - 1] = arguments[j];
                    }
                    listeners[i].fn.apply(listeners[i].context, args);
            }
        }
    }
    return true;
};
/**
 * Add a listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */ EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
};
/**
 * Add a one-time listener for a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn The listener function.
 * @param {*} [context=this] The context to invoke the listener with.
 * @returns {EventEmitter} `this`.
 * @public
 */ EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
};
/**
 * Remove the listeners of a given event.
 *
 * @param {(String|Symbol)} event The event name.
 * @param {Function} fn Only remove the listeners that match this function.
 * @param {*} context Only remove the listeners that have this context.
 * @param {Boolean} once Only remove one-time listeners.
 * @returns {EventEmitter} `this`.
 * @public
 */ EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return this;
    if (!fn) {
        clearEvent(this, evt);
        return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
            clearEvent(this, evt);
        }
    } else {
        for(var i = 0, events = [], length = listeners.length; i < length; i++){
            if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
                events.push(listeners[i]);
            }
        }
        //
        // Reset the array, or remove it completely if we have no more listeners.
        //
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
    }
    return this;
};
/**
 * Remove all listeners, or those of the specified event.
 *
 * @param {(String|Symbol)} [event] The event name.
 * @returns {EventEmitter} `this`.
 * @public
 */ EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
    } else {
        this._events = new Events();
        this._eventsCount = 0;
    }
    return this;
};
//
// Alias methods names because people roll like that.
//
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.addListener = EventEmitter.prototype.on;
//
// Expose the prefix.
//
EventEmitter.prefixed = prefix;
//
// Allow `EventEmitter` to be imported as module namespace.
//
EventEmitter.EventEmitter = EventEmitter;
//
// Expose the module.
//
if ("TURBOPACK compile-time truthy", 1) {
    module.exports = EventEmitter;
}
}),
"[project]/node_modules/date-and-time/date-and-time.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

(function(global, factory) {
    ("TURBOPACK compile-time truthy", 1) ? module.exports = factory() : "TURBOPACK unreachable";
})(/*TURBOPACK member replacement*/ __turbopack_context__.e, function() {
    'use strict';
    /**
     * @preserve date-and-time (c) KNOWLEDGECODE | MIT
     */ var locales = {}, plugins = {}, lang = 'en', _res = {
        MMMM: [
            'January',
            'February',
            'March',
            'April',
            'May',
            'June',
            'July',
            'August',
            'September',
            'October',
            'November',
            'December'
        ],
        MMM: [
            'Jan',
            'Feb',
            'Mar',
            'Apr',
            'May',
            'Jun',
            'Jul',
            'Aug',
            'Sep',
            'Oct',
            'Nov',
            'Dec'
        ],
        dddd: [
            'Sunday',
            'Monday',
            'Tuesday',
            'Wednesday',
            'Thursday',
            'Friday',
            'Saturday'
        ],
        ddd: [
            'Sun',
            'Mon',
            'Tue',
            'Wed',
            'Thu',
            'Fri',
            'Sat'
        ],
        dd: [
            'Su',
            'Mo',
            'Tu',
            'We',
            'Th',
            'Fr',
            'Sa'
        ],
        A: [
            'AM',
            'PM'
        ]
    }, _formatter = {
        YYYY: function(d /*, formatString*/ ) {
            return ('000' + d.getFullYear()).slice(-4);
        },
        YY: function(d /*, formatString*/ ) {
            return ('0' + d.getFullYear()).slice(-2);
        },
        Y: function(d /*, formatString*/ ) {
            return '' + d.getFullYear();
        },
        MMMM: function(d /*, formatString*/ ) {
            return this.res.MMMM[d.getMonth()];
        },
        MMM: function(d /*, formatString*/ ) {
            return this.res.MMM[d.getMonth()];
        },
        MM: function(d /*, formatString*/ ) {
            return ('0' + (d.getMonth() + 1)).slice(-2);
        },
        M: function(d /*, formatString*/ ) {
            return '' + (d.getMonth() + 1);
        },
        DD: function(d /*, formatString*/ ) {
            return ('0' + d.getDate()).slice(-2);
        },
        D: function(d /*, formatString*/ ) {
            return '' + d.getDate();
        },
        HH: function(d /*, formatString*/ ) {
            return ('0' + d.getHours()).slice(-2);
        },
        H: function(d /*, formatString*/ ) {
            return '' + d.getHours();
        },
        A: function(d /*, formatString*/ ) {
            return this.res.A[d.getHours() > 11 | 0];
        },
        hh: function(d /*, formatString*/ ) {
            return ('0' + (d.getHours() % 12 || 12)).slice(-2);
        },
        h: function(d /*, formatString*/ ) {
            return '' + (d.getHours() % 12 || 12);
        },
        mm: function(d /*, formatString*/ ) {
            return ('0' + d.getMinutes()).slice(-2);
        },
        m: function(d /*, formatString*/ ) {
            return '' + d.getMinutes();
        },
        ss: function(d /*, formatString*/ ) {
            return ('0' + d.getSeconds()).slice(-2);
        },
        s: function(d /*, formatString*/ ) {
            return '' + d.getSeconds();
        },
        SSS: function(d /*, formatString*/ ) {
            return ('00' + d.getMilliseconds()).slice(-3);
        },
        SS: function(d /*, formatString*/ ) {
            return ('0' + (d.getMilliseconds() / 10 | 0)).slice(-2);
        },
        S: function(d /*, formatString*/ ) {
            return '' + (d.getMilliseconds() / 100 | 0);
        },
        dddd: function(d /*, formatString*/ ) {
            return this.res.dddd[d.getDay()];
        },
        ddd: function(d /*, formatString*/ ) {
            return this.res.ddd[d.getDay()];
        },
        dd: function(d /*, formatString*/ ) {
            return this.res.dd[d.getDay()];
        },
        Z: function(d /*, formatString*/ ) {
            var offset = d.getTimezoneOffset() / 0.6 | 0;
            return (offset > 0 ? '-' : '+') + ('000' + Math.abs(offset - (offset % 100 * 0.4 | 0))).slice(-4);
        },
        ZZ: function(d /*, formatString*/ ) {
            var offset = d.getTimezoneOffset();
            var mod = Math.abs(offset);
            return (offset > 0 ? '-' : '+') + ('0' + (mod / 60 | 0)).slice(-2) + ':' + ('0' + mod % 60).slice(-2);
        },
        post: function(str) {
            return str;
        },
        res: _res
    }, _parser = {
        YYYY: function(str /*, formatString */ ) {
            return this.exec(/^\d{4}/, str);
        },
        Y: function(str /*, formatString */ ) {
            return this.exec(/^\d{1,4}/, str);
        },
        MMMM: function(str /*, formatString */ ) {
            var result = this.find(this.res.MMMM, str);
            result.value++;
            return result;
        },
        MMM: function(str /*, formatString */ ) {
            var result = this.find(this.res.MMM, str);
            result.value++;
            return result;
        },
        MM: function(str /*, formatString */ ) {
            return this.exec(/^\d\d/, str);
        },
        M: function(str /*, formatString */ ) {
            return this.exec(/^\d\d?/, str);
        },
        DD: function(str /*, formatString */ ) {
            return this.exec(/^\d\d/, str);
        },
        D: function(str /*, formatString */ ) {
            return this.exec(/^\d\d?/, str);
        },
        HH: function(str /*, formatString */ ) {
            return this.exec(/^\d\d/, str);
        },
        H: function(str /*, formatString */ ) {
            return this.exec(/^\d\d?/, str);
        },
        A: function(str /*, formatString */ ) {
            return this.find(this.res.A, str);
        },
        hh: function(str /*, formatString */ ) {
            return this.exec(/^\d\d/, str);
        },
        h: function(str /*, formatString */ ) {
            return this.exec(/^\d\d?/, str);
        },
        mm: function(str /*, formatString */ ) {
            return this.exec(/^\d\d/, str);
        },
        m: function(str /*, formatString */ ) {
            return this.exec(/^\d\d?/, str);
        },
        ss: function(str /*, formatString */ ) {
            return this.exec(/^\d\d/, str);
        },
        s: function(str /*, formatString */ ) {
            return this.exec(/^\d\d?/, str);
        },
        SSS: function(str /*, formatString */ ) {
            return this.exec(/^\d{1,3}/, str);
        },
        SS: function(str /*, formatString */ ) {
            var result = this.exec(/^\d\d?/, str);
            result.value *= 10;
            return result;
        },
        S: function(str /*, formatString */ ) {
            var result = this.exec(/^\d/, str);
            result.value *= 100;
            return result;
        },
        Z: function(str /*, formatString */ ) {
            var result = this.exec(/^[\+-]\d{2}[0-5]\d/, str);
            result.value = (result.value / 100 | 0) * -60 - result.value % 100;
            return result;
        },
        ZZ: function(str /*, formatString */ ) {
            var arr = /^([\+-])(\d{2}):([0-5]\d)/.exec(str) || [
                '',
                '',
                '',
                ''
            ];
            return {
                value: 0 - ((arr[1] + arr[2] | 0) * 60 + (arr[1] + arr[3] | 0)),
                length: arr[0].length
            };
        },
        h12: function(h, a) {
            return (h === 12 ? 0 : h) + a * 12;
        },
        exec: function(re, str) {
            var result = (re.exec(str) || [
                ''
            ])[0];
            return {
                value: result | 0,
                length: result.length
            };
        },
        find: function(array, str) {
            var index = -1, length = 0;
            for(var i = 0, len = array.length, item; i < len; i++){
                item = array[i];
                if (!str.indexOf(item) && item.length > length) {
                    index = i;
                    length = item.length;
                }
            }
            return {
                value: index,
                length: length
            };
        },
        pre: function(str) {
            return str;
        },
        res: _res
    }, extend = function(base, props, override, res) {
        var obj = {}, key;
        for(key in base){
            obj[key] = base[key];
        }
        for(key in props || {}){
            if (!(!!override ^ !!obj[key])) {
                obj[key] = props[key];
            }
        }
        if (res) {
            obj.res = res;
        }
        return obj;
    }, proto = {
        _formatter: _formatter,
        _parser: _parser
    }, localized_proto, date;
    /**
     * Compiling format strings
     * @param {string} formatString - A format string
     * @returns {Array.<string>} A compiled object
     */ proto.compile = function(formatString) {
        var re = /\[([^\[\]]|\[[^\[\]]*])*]|([A-Za-z])\2+|\.{3}|./g, keys, pattern = [
            formatString
        ];
        while(keys = re.exec(formatString)){
            pattern[pattern.length] = keys[0];
        }
        return pattern;
    };
    /**
     * Formatting date and time objects (Date -> String)
     * @param {Date} dateObj - A Date object
     * @param {string|Array.<string>} arg - A format string or its compiled object
     * @param {boolean} [utc] - Output as UTC
     * @returns {string} A formatted string
     */ proto.format = function(dateObj, arg, utc) {
        var ctx = this || date, pattern = typeof arg === 'string' ? ctx.compile(arg) : arg, offset = dateObj.getTimezoneOffset(), d = ctx.addMinutes(dateObj, utc ? offset : 0), formatter = ctx._formatter, str = '';
        d.getTimezoneOffset = function() {
            return utc ? 0 : offset;
        };
        for(var i = 1, len = pattern.length, token; i < len; i++){
            token = pattern[i];
            str += formatter[token] ? formatter.post(formatter[token](d, pattern[0])) : token.replace(/\[(.*)]/, '$1');
        }
        return str;
    };
    /**
     * Pre-parsing date and time strings
     * @param {string} dateString - A date and time string
     * @param {string|Array.<string>} arg - A format string or its compiled object
     * @param {boolean} [utc] - Input as UTC
     * @returns {Object} A pre-parsed result object
     */ proto.preparse = function(dateString, arg) {
        var ctx = this || date, pattern = typeof arg === 'string' ? ctx.compile(arg) : arg, dt = {
            Y: 1970,
            M: 1,
            D: 1,
            H: 0,
            A: 0,
            h: 0,
            m: 0,
            s: 0,
            S: 0,
            Z: 0,
            _index: 0,
            _length: 0,
            _match: 0
        }, comment = /\[(.*)]/, parser = ctx._parser, offset = 0;
        dateString = parser.pre(dateString);
        for(var i = 1, len = pattern.length, token, result; i < len; i++){
            token = pattern[i];
            if (parser[token]) {
                result = parser[token](dateString.slice(offset), pattern[0]);
                if (!result.length) {
                    break;
                }
                offset += result.length;
                dt[result.token || token.charAt(0)] = result.value;
                dt._match++;
            } else if (token === dateString.charAt(offset) || token === ' ') {
                offset++;
            } else if (comment.test(token) && !dateString.slice(offset).indexOf(comment.exec(token)[1])) {
                offset += token.length - 2;
            } else if (token === '...') {
                offset = dateString.length;
                break;
            } else {
                break;
            }
        }
        dt.H = dt.H || parser.h12(dt.h, dt.A);
        dt._index = offset;
        dt._length = dateString.length;
        return dt;
    };
    /**
     * Parsing of date and time string (String -> Date)
     * @param {string} dateString - A date-time string
     * @param {string|Array.<string>} arg - A format string or its compiled object
     * @param {boolean} [utc] - Input as UTC
     * @returns {Date} A Date object
     */ proto.parse = function(dateString, arg, utc) {
        var ctx = this || date, pattern = typeof arg === 'string' ? ctx.compile(arg) : arg, dt = ctx.preparse(dateString, pattern);
        if (ctx.isValid(dt)) {
            dt.M -= dt.Y < 100 ? 22801 : 1; // 22801 = 1900 * 12 + 1
            if (utc || ~ctx._parser.find(pattern, 'ZZ').value) {
                return new Date(Date.UTC(dt.Y, dt.M, dt.D, dt.H, dt.m + dt.Z, dt.s, dt.S));
            }
            return new Date(dt.Y, dt.M, dt.D, dt.H, dt.m, dt.s, dt.S);
        }
        return new Date(NaN);
    };
    /**
     * Date and time string validation
     * @param {Object|string} arg1 - A pre-parsed result object or a date and time string
     * @param {string|Array.<string>} [arg2] - A format string or its compiled object
     * @returns {boolean} Whether the date and time string is a valid date and time
     */ proto.isValid = function(arg1, arg2) {
        var ctx = this || date, dt = typeof arg1 === 'string' ? ctx.preparse(arg1, arg2) : arg1, last = [
            31,
            28 + ctx.isLeapYear(dt.Y) | 0,
            31,
            30,
            31,
            30,
            31,
            31,
            30,
            31,
            30,
            31
        ][dt.M - 1];
        return !(dt._index < 1 || dt._length < 1 || dt._index - dt._length || dt._match < 1 || dt.Y < 1 || dt.Y > 9999 || dt.M < 1 || dt.M > 12 || dt.D < 1 || dt.D > last || dt.H < 0 || dt.H > 23 || dt.m < 0 || dt.m > 59 || dt.s < 0 || dt.s > 59 || dt.S < 0 || dt.S > 999 || dt.Z < -840 || dt.Z > 720);
    };
    /**
     * Format transformation of date and time string (String -> String)
     * @param {string} dateString - A date and time string
     * @param {string|Array.<string>} arg1 - A format string or its compiled object before transformation
     * @param {string|Array.<string>} arg2 - A format string or its compiled object after transformation
     * @param {boolean} [utc] - Output as UTC
     * @returns {string} A formatted string
     */ proto.transform = function(dateString, arg1, arg2, utc) {
        const ctx = this || date;
        return ctx.format(ctx.parse(dateString, arg1), arg2, utc);
    };
    /**
     * Adding years
     * @param {Date} dateObj - A Date object
     * @param {number} years - Number of years to add
     * @returns {Date} The Date object after adding the value
     */ proto.addYears = function(dateObj, years) {
        return (this || date).addMonths(dateObj, years * 12);
    };
    /**
     * Adding months
     * @param {Date} dateObj - A Date object
     * @param {number} months - Number of months to add
     * @returns {Date} The Date object after adding the value
     */ proto.addMonths = function(dateObj, months) {
        var d = new Date(dateObj.getTime());
        d.setUTCMonth(d.getUTCMonth() + months);
        return d;
    };
    /**
     * Adding days
     * @param {Date} dateObj - A Date object
     * @param {number} days - Number of days to add
     * @returns {Date} The Date object after adding the value
     */ proto.addDays = function(dateObj, days) {
        var d = new Date(dateObj.getTime());
        d.setUTCDate(d.getUTCDate() + days);
        return d;
    };
    /**
     * Adding hours
     * @param {Date} dateObj - A Date object
     * @param {number} hours - Number of hours to add
     * @returns {Date} The Date object after adding the value
     */ proto.addHours = function(dateObj, hours) {
        return (this || date).addMinutes(dateObj, hours * 60);
    };
    /**
     * Adding minutes
     * @param {Date} dateObj - A Date object
     * @param {number} minutes - Number of minutes to add
     * @returns {Date} The Date object after adding the value
     */ proto.addMinutes = function(dateObj, minutes) {
        return (this || date).addSeconds(dateObj, minutes * 60);
    };
    /**
     * Adding seconds
     * @param {Date} dateObj - A Date object
     * @param {number} seconds - Number of seconds to add
     * @returns {Date} The Date object after adding the value
     */ proto.addSeconds = function(dateObj, seconds) {
        return (this || date).addMilliseconds(dateObj, seconds * 1000);
    };
    /**
     * Adding milliseconds
     * @param {Date} dateObj - A Date object
     * @param {number} milliseconds - Number of milliseconds to add
     * @returns {Date} The Date object after adding the value
     */ proto.addMilliseconds = function(dateObj, milliseconds) {
        return new Date(dateObj.getTime() + milliseconds);
    };
    /**
     * Subtracting two dates (date1 - date2)
     * @param {Date} date1 - A Date object
     * @param {Date} date2 - A Date object
     * @returns {Object} The result object of subtracting date2 from date1
     */ proto.subtract = function(date1, date2) {
        var delta = date1.getTime() - date2.getTime();
        return {
            toMilliseconds: function() {
                return delta;
            },
            toSeconds: function() {
                return delta / 1000;
            },
            toMinutes: function() {
                return delta / 60000;
            },
            toHours: function() {
                return delta / 3600000;
            },
            toDays: function() {
                return delta / 86400000;
            }
        };
    };
    /**
     * Whether a year is a leap year
     * @param {number} y - A year to check
     * @returns {boolean} Whether the year is a leap year
     */ proto.isLeapYear = function(y) {
        return !(y % 4) && !!(y % 100) || !(y % 400);
    };
    /**
     * Comparison of two dates
     * @param {Date} date1 - A Date object
     * @param {Date} date2 - A Date object
     * @returns {boolean} Whether the two dates are the same day (time is ignored)
     */ proto.isSameDay = function(date1, date2) {
        return date1.toDateString() === date2.toDateString();
    };
    /**
     * Definition of new locale
     * @param {string} code - A language code
     * @param {Function} locale - A locale installer
     * @returns {void}
     */ proto.locale = function(code, locale) {
        if (!locales[code]) {
            locales[code] = locale;
        }
    };
    /**
     * Definition of new plugin
     * @param {string} name - A plugin name
     * @param {Function} plugin - A plugin installer
     * @returns {void}
     */ proto.plugin = function(name, plugin) {
        if (!plugins[name]) {
            plugins[name] = plugin;
        }
    };
    localized_proto = extend(proto);
    date = extend(proto);
    /**
     * Changing locales
     * @param {Function|string} [locale] - A locale installer or language code
     * @returns {string} The current language code
     */ date.locale = function(locale) {
        var install = typeof locale === 'function' ? locale : date.locale[locale];
        if (!install) {
            return lang;
        }
        lang = install(proto);
        var extension = locales[lang] || {};
        var res = extend(_res, extension.res, true);
        var formatter = extend(_formatter, extension.formatter, true, res);
        var parser = extend(_parser, extension.parser, true, res);
        date._formatter = localized_proto._formatter = formatter;
        date._parser = localized_proto._parser = parser;
        for(var plugin in plugins){
            date.extend(plugins[plugin]);
        }
        return lang;
    };
    /**
     * Functional extension
     * @param {Object} extension - An extension object
     * @returns {void}
     */ date.extend = function(extension) {
        var res = extend(date._parser.res, extension.res);
        var extender = extension.extender || {};
        date._formatter = extend(date._formatter, extension.formatter, false, res);
        date._parser = extend(date._parser, extension.parser, false, res);
        for(var key in extender){
            if (!date[key]) {
                date[key] = extender[key];
            }
        }
    };
    /**
     * Importing plugins
     * @param {Function|string} plugin - A plugin installer or plugin name
     * @returns {void}
     */ date.plugin = function(plugin) {
        var install = typeof plugin === 'function' ? plugin : date.plugin[plugin];
        if (install) {
            date.extend(plugins[install(proto, localized_proto)] || {});
        }
    };
    var date$1 = date;
    return date$1;
});
}),
"[project]/node_modules/@noble/ed25519/lib/esm/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */ __turbopack_context__.s([
    "CURVE",
    ()=>CURVE,
    "ExtendedPoint",
    ()=>ExtendedPoint,
    "Point",
    ()=>Point,
    "RistrettoPoint",
    ()=>RistrettoPoint,
    "Signature",
    ()=>Signature,
    "bytesToHex",
    ()=>bytesToHex,
    "curve25519",
    ()=>curve25519,
    "getPublicKey",
    ()=>getPublicKey,
    "getSharedSecret",
    ()=>getSharedSecret,
    "hexToBytes",
    ()=>hexToBytes,
    "sign",
    ()=>sign,
    "sync",
    ()=>sync,
    "utils",
    ()=>utils,
    "verify",
    ()=>verify
]);
;
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const _8n = BigInt(8);
const CU_O = BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989');
const CURVE = Object.freeze({
    a: BigInt(-1),
    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),
    P: BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819949'),
    l: CU_O,
    n: CU_O,
    h: BigInt(8),
    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),
    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960')
});
;
const POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');
const SQRT_M1 = BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');
const SQRT_D = BigInt('6853475219497561581579357271197624642482790079785650197046958215289687604742');
const SQRT_AD_MINUS_ONE = BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');
const INVSQRT_A_MINUS_D = BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');
const ONE_MINUS_D_SQ = BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');
const D_MINUS_ONE_SQ = BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');
class ExtendedPoint {
    constructor(x, y, z, t){
        this.x = x;
        this.y = y;
        this.z = z;
        this.t = t;
    }
    static fromAffine(p) {
        if (!(p instanceof Point)) {
            throw new TypeError('ExtendedPoint#fromAffine: expected Point');
        }
        if (p.equals(Point.ZERO)) return ExtendedPoint.ZERO;
        return new ExtendedPoint(p.x, p.y, _1n, mod(p.x * p.y));
    }
    static toAffineBatch(points) {
        const toInv = invertBatch(points.map((p)=>p.z));
        return points.map((p, i)=>p.toAffine(toInv[i]));
    }
    static normalizeZ(points) {
        return this.toAffineBatch(points).map(this.fromAffine);
    }
    equals(other) {
        assertExtPoint(other);
        const { x: X1, y: Y1, z: Z1 } = this;
        const { x: X2, y: Y2, z: Z2 } = other;
        const X1Z2 = mod(X1 * Z2);
        const X2Z1 = mod(X2 * Z1);
        const Y1Z2 = mod(Y1 * Z2);
        const Y2Z1 = mod(Y2 * Z1);
        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
    }
    negate() {
        return new ExtendedPoint(mod(-this.x), this.y, this.z, mod(-this.t));
    }
    double() {
        const { x: X1, y: Y1, z: Z1 } = this;
        const { a } = CURVE;
        const M = mod;
        const A = M(X1 * X1);
        const B = M(Y1 * Y1);
        const C = M(_2n * M(Z1 * Z1));
        const D = M(a * A);
        const x1y1 = X1 + Y1;
        const E = M(M(x1y1 * x1y1) - A - B);
        const G = D + B;
        const F = G - C;
        const H = D - B;
        const X3 = M(E * F);
        const Y3 = M(G * H);
        const T3 = M(E * H);
        const Z3 = M(F * G);
        return new ExtendedPoint(X3, Y3, Z3, T3);
    }
    add(other) {
        const { x: X1, y: Y1, z: Z1, t: T1 } = this;
        assertExtPoint(other);
        const { x: X2, y: Y2, z: Z2, t: T2 } = other;
        const { a, d } = CURVE;
        const M = mod;
        const A = M(X1 * X2);
        const B = M(Y1 * Y2);
        const C = M(T1 * d * T2);
        const D = M(Z1 * Z2);
        const E = M((X1 + Y1) * (X2 + Y2) - A - B);
        const F = M(D - C);
        const G = M(D + C);
        const H = M(B - a * A);
        const X3 = M(E * F);
        const Y3 = M(G * H);
        const T3 = M(E * H);
        const Z3 = M(F * G);
        return new ExtendedPoint(X3, Y3, Z3, T3);
    }
    subtract(other) {
        return this.add(other.negate());
    }
    precomputeWindow(W) {
        const windows = 1 + 256 / W;
        const points = [];
        let p = this;
        let base = p;
        for(let window = 0; window < windows; window++){
            base = p;
            points.push(base);
            for(let i = 1; i < 2 ** (W - 1); i++){
                base = base.add(p);
                points.push(base);
            }
            p = base.double();
        }
        return points;
    }
    wNAF(n, affinePoint) {
        if (!affinePoint && this.equals(ExtendedPoint.BASE)) affinePoint = Point.BASE;
        const W = affinePoint && affinePoint._WINDOW_SIZE || 1;
        if (256 % W) {
            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');
        }
        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
        if (!precomputes) {
            precomputes = this.precomputeWindow(W);
            if (affinePoint && W !== 1) {
                precomputes = ExtendedPoint.normalizeZ(precomputes);
                pointPrecomputes.set(affinePoint, precomputes);
            }
        }
        let p = ExtendedPoint.ZERO;
        let f = ExtendedPoint.BASE;
        const windows = 1 + 256 / W;
        const windowSize = 2 ** (W - 1);
        const mask = BigInt(2 ** W - 1);
        const maxNumber = 2 ** W;
        const shiftBy = BigInt(W);
        for(let window = 0; window < windows; window++){
            const offset = window * windowSize;
            let wbits = Number(n & mask);
            n >>= shiftBy;
            if (wbits > windowSize) {
                wbits -= maxNumber;
                n += _1n;
            }
            const offset1 = offset;
            const offset2 = offset + Math.abs(wbits) - 1;
            const cond1 = window % 2 !== 0;
            const cond2 = wbits < 0;
            if (wbits === 0) {
                f = f.add(constTimeNegate(cond1, precomputes[offset1]));
            } else {
                p = p.add(constTimeNegate(cond2, precomputes[offset2]));
            }
        }
        return ExtendedPoint.normalizeZ([
            p,
            f
        ])[0];
    }
    multiply(scalar, affinePoint) {
        return this.wNAF(normalizeScalar(scalar, CURVE.l), affinePoint);
    }
    multiplyUnsafe(scalar) {
        let n = normalizeScalar(scalar, CURVE.l, false);
        const G = ExtendedPoint.BASE;
        const P0 = ExtendedPoint.ZERO;
        if (n === _0n) return P0;
        if (this.equals(P0) || n === _1n) return this;
        if (this.equals(G)) return this.wNAF(n);
        let p = P0;
        let d = this;
        while(n > _0n){
            if (n & _1n) p = p.add(d);
            d = d.double();
            n >>= _1n;
        }
        return p;
    }
    isSmallOrder() {
        return this.multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);
    }
    isTorsionFree() {
        let p = this.multiplyUnsafe(CURVE.l / _2n).double();
        if (CURVE.l % _2n) p = p.add(this);
        return p.equals(ExtendedPoint.ZERO);
    }
    toAffine(invZ) {
        const { x, y, z } = this;
        const is0 = this.equals(ExtendedPoint.ZERO);
        if (invZ == null) invZ = is0 ? _8n : invert(z);
        const ax = mod(x * invZ);
        const ay = mod(y * invZ);
        const zz = mod(z * invZ);
        if (is0) return Point.ZERO;
        if (zz !== _1n) throw new Error('invZ was invalid');
        return new Point(ax, ay);
    }
    fromRistrettoBytes() {
        legacyRist();
    }
    toRistrettoBytes() {
        legacyRist();
    }
    fromRistrettoHash() {
        legacyRist();
    }
}
ExtendedPoint.BASE = new ExtendedPoint(CURVE.Gx, CURVE.Gy, _1n, mod(CURVE.Gx * CURVE.Gy));
ExtendedPoint.ZERO = new ExtendedPoint(_0n, _1n, _1n, _0n);
function constTimeNegate(condition, item) {
    const neg = item.negate();
    return condition ? neg : item;
}
function assertExtPoint(other) {
    if (!(other instanceof ExtendedPoint)) throw new TypeError('ExtendedPoint expected');
}
function assertRstPoint(other) {
    if (!(other instanceof RistrettoPoint)) throw new TypeError('RistrettoPoint expected');
}
function legacyRist() {
    throw new Error('Legacy method: switch to RistrettoPoint');
}
class RistrettoPoint {
    constructor(ep){
        this.ep = ep;
    }
    static calcElligatorRistrettoMap(r0) {
        const { d } = CURVE;
        const r = mod(SQRT_M1 * r0 * r0);
        const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);
        let c = BigInt(-1);
        const D = mod((c - d * r) * mod(r + d));
        let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
        let s_ = mod(s * r0);
        if (!edIsNegative(s_)) s_ = mod(-s_);
        if (!Ns_D_is_sq) s = s_;
        if (!Ns_D_is_sq) c = r;
        const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);
        const s2 = s * s;
        const W0 = mod((s + s) * D);
        const W1 = mod(Nt * SQRT_AD_MINUS_ONE);
        const W2 = mod(_1n - s2);
        const W3 = mod(_1n + s2);
        return new ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));
    }
    static hashToCurve(hex) {
        hex = ensureBytes(hex, 64);
        const r1 = bytes255ToNumberLE(hex.slice(0, 32));
        const R1 = this.calcElligatorRistrettoMap(r1);
        const r2 = bytes255ToNumberLE(hex.slice(32, 64));
        const R2 = this.calcElligatorRistrettoMap(r2);
        return new RistrettoPoint(R1.add(R2));
    }
    static fromHex(hex) {
        hex = ensureBytes(hex, 32);
        const { a, d } = CURVE;
        const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';
        const s = bytes255ToNumberLE(hex);
        if (!equalBytes(numberTo32BytesLE(s), hex) || edIsNegative(s)) throw new Error(emsg);
        const s2 = mod(s * s);
        const u1 = mod(_1n + a * s2);
        const u2 = mod(_1n - a * s2);
        const u1_2 = mod(u1 * u1);
        const u2_2 = mod(u2 * u2);
        const v = mod(a * d * u1_2 - u2_2);
        const { isValid, value: I } = invertSqrt(mod(v * u2_2));
        const Dx = mod(I * u2);
        const Dy = mod(I * Dx * v);
        let x = mod((s + s) * Dx);
        if (edIsNegative(x)) x = mod(-x);
        const y = mod(u1 * Dy);
        const t = mod(x * y);
        if (!isValid || edIsNegative(t) || y === _0n) throw new Error(emsg);
        return new RistrettoPoint(new ExtendedPoint(x, y, _1n, t));
    }
    toRawBytes() {
        let { x, y, z, t } = this.ep;
        const u1 = mod(mod(z + y) * mod(z - y));
        const u2 = mod(x * y);
        const u2sq = mod(u2 * u2);
        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq));
        const D1 = mod(invsqrt * u1);
        const D2 = mod(invsqrt * u2);
        const zInv = mod(D1 * D2 * t);
        let D;
        if (edIsNegative(t * zInv)) {
            let _x = mod(y * SQRT_M1);
            let _y = mod(x * SQRT_M1);
            x = _x;
            y = _y;
            D = mod(D1 * INVSQRT_A_MINUS_D);
        } else {
            D = D2;
        }
        if (edIsNegative(x * zInv)) y = mod(-y);
        let s = mod((z - y) * D);
        if (edIsNegative(s)) s = mod(-s);
        return numberTo32BytesLE(s);
    }
    toHex() {
        return bytesToHex(this.toRawBytes());
    }
    toString() {
        return this.toHex();
    }
    equals(other) {
        assertRstPoint(other);
        const a = this.ep;
        const b = other.ep;
        const one = mod(a.x * b.y) === mod(a.y * b.x);
        const two = mod(a.y * b.y) === mod(a.x * b.x);
        return one || two;
    }
    add(other) {
        assertRstPoint(other);
        return new RistrettoPoint(this.ep.add(other.ep));
    }
    subtract(other) {
        assertRstPoint(other);
        return new RistrettoPoint(this.ep.subtract(other.ep));
    }
    multiply(scalar) {
        return new RistrettoPoint(this.ep.multiply(scalar));
    }
    multiplyUnsafe(scalar) {
        return new RistrettoPoint(this.ep.multiplyUnsafe(scalar));
    }
}
RistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);
RistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);
const pointPrecomputes = new WeakMap();
class Point {
    constructor(x, y){
        this.x = x;
        this.y = y;
    }
    _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes.delete(this);
    }
    static fromHex(hex, strict = true) {
        const { d, P } = CURVE;
        hex = ensureBytes(hex, 32);
        const normed = hex.slice();
        normed[31] = hex[31] & ~0x80;
        const y = bytesToNumberLE(normed);
        if (strict && y >= P) throw new Error('Expected 0 < hex < P');
        if (!strict && y >= POW_2_256) throw new Error('Expected 0 < hex < 2**256');
        const y2 = mod(y * y);
        const u = mod(y2 - _1n);
        const v = mod(d * y2 + _1n);
        let { isValid, value: x } = uvRatio(u, v);
        if (!isValid) throw new Error('Point.fromHex: invalid y coordinate');
        const isXOdd = (x & _1n) === _1n;
        const isLastByteOdd = (hex[31] & 0x80) !== 0;
        if (isLastByteOdd !== isXOdd) {
            x = mod(-x);
        }
        return new Point(x, y);
    }
    static async fromPrivateKey(privateKey) {
        return (await getExtendedPublicKey(privateKey)).point;
    }
    toRawBytes() {
        const bytes = numberTo32BytesLE(this.y);
        bytes[31] |= this.x & _1n ? 0x80 : 0;
        return bytes;
    }
    toHex() {
        return bytesToHex(this.toRawBytes());
    }
    toX25519() {
        const { y } = this;
        const u = mod((_1n + y) * invert(_1n - y));
        return numberTo32BytesLE(u);
    }
    isTorsionFree() {
        return ExtendedPoint.fromAffine(this).isTorsionFree();
    }
    equals(other) {
        return this.x === other.x && this.y === other.y;
    }
    negate() {
        return new Point(mod(-this.x), this.y);
    }
    add(other) {
        return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();
    }
    subtract(other) {
        return this.add(other.negate());
    }
    multiply(scalar) {
        return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();
    }
}
Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
Point.ZERO = new Point(_0n, _1n);
class Signature {
    constructor(r, s){
        this.r = r;
        this.s = s;
        this.assertValidity();
    }
    static fromHex(hex) {
        const bytes = ensureBytes(hex, 64);
        const r = Point.fromHex(bytes.slice(0, 32), false);
        const s = bytesToNumberLE(bytes.slice(32, 64));
        return new Signature(r, s);
    }
    assertValidity() {
        const { r, s } = this;
        if (!(r instanceof Point)) throw new Error('Expected Point instance');
        normalizeScalar(s, CURVE.l, false);
        return this;
    }
    toRawBytes() {
        const u8 = new Uint8Array(64);
        u8.set(this.r.toRawBytes());
        u8.set(numberTo32BytesLE(this.s), 32);
        return u8;
    }
    toHex() {
        return bytesToHex(this.toRawBytes());
    }
}
;
function isBytes(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array';
}
function abytes(item) {
    if (!isBytes(item)) throw new Error('Uint8Array expected');
}
function concatBytes(...arrays) {
    arrays.every(abytes);
    if (arrays.length === 1) return arrays[0];
    const length = arrays.reduce((a, arr)=>a + arr.length, 0);
    const result = new Uint8Array(length);
    for(let i = 0, pad = 0; i < arrays.length; i++){
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
    }
    return result;
}
const hexes = Array.from({
    length: 256
}, (_, i)=>i.toString(16).padStart(2, '0'));
function bytesToHex(bytes) {
    abytes(bytes);
    let hex = '';
    for(let i = 0; i < bytes.length; i++){
        hex += hexes[bytes[i]];
    }
    return hex;
}
const asciis = {
    _0: 48,
    _9: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};
function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0;
    if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10);
    if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10);
    return;
}
function hexToBytes(hex) {
    if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);
    const array = new Uint8Array(al);
    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
    }
    return array;
}
function numberTo32BytesBE(num) {
    const length = 32;
    const hex = num.toString(16).padStart(length * 2, '0');
    return hexToBytes(hex);
}
function numberTo32BytesLE(num) {
    return numberTo32BytesBE(num).reverse();
}
function edIsNegative(num) {
    return (mod(num) & _1n) === _1n;
}
function bytesToNumberLE(uint8a) {
    abytes(uint8a);
    return BigInt('0x' + bytesToHex(Uint8Array.from(uint8a).reverse()));
}
const MAX_255B = BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');
function bytes255ToNumberLE(bytes) {
    return mod(bytesToNumberLE(bytes) & MAX_255B);
}
function mod(a, b = CURVE.P) {
    const res = a % b;
    return res >= _0n ? res : b + res;
}
function invert(number, modulo = CURVE.P) {
    if (number === _0n || modulo <= _0n) {
        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
    }
    let a = mod(number, modulo);
    let b = modulo;
    let x = _0n, y = _1n, u = _1n, v = _0n;
    while(a !== _0n){
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        b = a, a = r, x = u, y = v, u = m, v = n;
    }
    const gcd = b;
    if (gcd !== _1n) throw new Error('invert: does not exist');
    return mod(x, modulo);
}
function invertBatch(nums, p = CURVE.P) {
    const tmp = new Array(nums.length);
    const lastMultiplied = nums.reduce((acc, num, i)=>{
        if (num === _0n) return acc;
        tmp[i] = acc;
        return mod(acc * num, p);
    }, _1n);
    const inverted = invert(lastMultiplied, p);
    nums.reduceRight((acc, num, i)=>{
        if (num === _0n) return acc;
        tmp[i] = mod(acc * tmp[i], p);
        return mod(acc * num, p);
    }, inverted);
    return tmp;
}
function pow2(x, power) {
    const { P } = CURVE;
    let res = x;
    while(power-- > _0n){
        res *= res;
        res %= P;
    }
    return res;
}
function pow_2_252_3(x) {
    const { P } = CURVE;
    const _5n = BigInt(5);
    const _10n = BigInt(10);
    const _20n = BigInt(20);
    const _40n = BigInt(40);
    const _80n = BigInt(80);
    const x2 = x * x % P;
    const b2 = x2 * x % P;
    const b4 = pow2(b2, _2n) * b2 % P;
    const b5 = pow2(b4, _1n) * x % P;
    const b10 = pow2(b5, _5n) * b5 % P;
    const b20 = pow2(b10, _10n) * b10 % P;
    const b40 = pow2(b20, _20n) * b20 % P;
    const b80 = pow2(b40, _40n) * b40 % P;
    const b160 = pow2(b80, _80n) * b80 % P;
    const b240 = pow2(b160, _80n) * b80 % P;
    const b250 = pow2(b240, _10n) * b10 % P;
    const pow_p_5_8 = pow2(b250, _2n) * x % P;
    return {
        pow_p_5_8,
        b2
    };
}
function uvRatio(u, v) {
    const v3 = mod(v * v * v);
    const v7 = mod(v3 * v3 * v);
    const pow = pow_2_252_3(u * v7).pow_p_5_8;
    let x = mod(u * v3 * pow);
    const vx2 = mod(v * x * x);
    const root1 = x;
    const root2 = mod(x * SQRT_M1);
    const useRoot1 = vx2 === u;
    const useRoot2 = vx2 === mod(-u);
    const noRoot = vx2 === mod(-u * SQRT_M1);
    if (useRoot1) x = root1;
    if (useRoot2 || noRoot) x = root2;
    if (edIsNegative(x)) x = mod(-x);
    return {
        isValid: useRoot1 || useRoot2,
        value: x
    };
}
function invertSqrt(number) {
    return uvRatio(_1n, number);
}
function modlLE(hash) {
    return mod(bytesToNumberLE(hash), CURVE.l);
}
function equalBytes(b1, b2) {
    if (b1.length !== b2.length) {
        return false;
    }
    for(let i = 0; i < b1.length; i++){
        if (b1[i] !== b2[i]) {
            return false;
        }
    }
    return true;
}
function ensureBytes(hex, expectedLength) {
    const bytes = isBytes(hex) ? Uint8Array.from(hex) : hexToBytes(hex);
    if (typeof expectedLength === 'number' && bytes.length !== expectedLength) throw new Error(`Expected ${expectedLength} bytes`);
    return bytes;
}
function normalizeScalar(num, max, strict = true) {
    if (!max) throw new TypeError('Specify max value');
    if (typeof num === 'number' && Number.isSafeInteger(num)) num = BigInt(num);
    if (typeof num === 'bigint' && num < max) {
        if (strict) {
            if (_0n < num) return num;
        } else {
            if (_0n <= num) return num;
        }
    }
    throw new TypeError('Expected valid scalar: 0 < scalar < max');
}
function adjustBytes25519(bytes) {
    bytes[0] &= 248;
    bytes[31] &= 127;
    bytes[31] |= 64;
    return bytes;
}
function decodeScalar25519(n) {
    return bytesToNumberLE(adjustBytes25519(ensureBytes(n, 32)));
}
function checkPrivateKey(key) {
    key = typeof key === 'bigint' || typeof key === 'number' ? numberTo32BytesBE(normalizeScalar(key, POW_2_256)) : ensureBytes(key);
    if (key.length !== 32) throw new Error(`Expected 32 bytes`);
    return key;
}
function getKeyFromHash(hashed) {
    const head = adjustBytes25519(hashed.slice(0, 32));
    const prefix = hashed.slice(32, 64);
    const scalar = modlLE(head);
    const point = Point.BASE.multiply(scalar);
    const pointBytes = point.toRawBytes();
    return {
        head,
        prefix,
        scalar,
        point,
        pointBytes
    };
}
let _sha512Sync;
function sha512s(...m) {
    if (typeof _sha512Sync !== 'function') throw new Error('utils.sha512Sync must be set to use sync methods');
    return _sha512Sync(...m);
}
async function getExtendedPublicKey(key) {
    return getKeyFromHash(await utils.sha512(checkPrivateKey(key)));
}
function getExtendedPublicKeySync(key) {
    return getKeyFromHash(sha512s(checkPrivateKey(key)));
}
async function getPublicKey(privateKey) {
    return (await getExtendedPublicKey(privateKey)).pointBytes;
}
function getPublicKeySync(privateKey) {
    return getExtendedPublicKeySync(privateKey).pointBytes;
}
async function sign(message, privateKey) {
    message = ensureBytes(message);
    const { prefix, scalar, pointBytes } = await getExtendedPublicKey(privateKey);
    const r = modlLE(await utils.sha512(prefix, message));
    const R = Point.BASE.multiply(r);
    const k = modlLE(await utils.sha512(R.toRawBytes(), pointBytes, message));
    const s = mod(r + k * scalar, CURVE.l);
    return new Signature(R, s).toRawBytes();
}
function signSync(message, privateKey) {
    message = ensureBytes(message);
    const { prefix, scalar, pointBytes } = getExtendedPublicKeySync(privateKey);
    const r = modlLE(sha512s(prefix, message));
    const R = Point.BASE.multiply(r);
    const k = modlLE(sha512s(R.toRawBytes(), pointBytes, message));
    const s = mod(r + k * scalar, CURVE.l);
    return new Signature(R, s).toRawBytes();
}
function prepareVerification(sig, message, publicKey) {
    message = ensureBytes(message);
    if (!(publicKey instanceof Point)) publicKey = Point.fromHex(publicKey, false);
    const { r, s } = sig instanceof Signature ? sig.assertValidity() : Signature.fromHex(sig);
    const SB = ExtendedPoint.BASE.multiplyUnsafe(s);
    return {
        r,
        s,
        SB,
        pub: publicKey,
        msg: message
    };
}
function finishVerification(publicKey, r, SB, hashed) {
    const k = modlLE(hashed);
    const kA = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(k);
    const RkA = ExtendedPoint.fromAffine(r).add(kA);
    return RkA.subtract(SB).multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);
}
async function verify(sig, message, publicKey) {
    const { r, SB, msg, pub } = prepareVerification(sig, message, publicKey);
    const hashed = await utils.sha512(r.toRawBytes(), pub.toRawBytes(), msg);
    return finishVerification(pub, r, SB, hashed);
}
function verifySync(sig, message, publicKey) {
    const { r, SB, msg, pub } = prepareVerification(sig, message, publicKey);
    const hashed = sha512s(r.toRawBytes(), pub.toRawBytes(), msg);
    return finishVerification(pub, r, SB, hashed);
}
const sync = {
    getExtendedPublicKey: getExtendedPublicKeySync,
    getPublicKey: getPublicKeySync,
    sign: signSync,
    verify: verifySync
};
async function getSharedSecret(privateKey, publicKey) {
    const { head } = await getExtendedPublicKey(privateKey);
    const u = Point.fromHex(publicKey).toX25519();
    return curve25519.scalarMult(head, u);
}
Point.BASE._setWindowSize(8);
function cswap(swap, x_2, x_3) {
    const dummy = mod(swap * (x_2 - x_3));
    x_2 = mod(x_2 - dummy);
    x_3 = mod(x_3 + dummy);
    return [
        x_2,
        x_3
    ];
}
function montgomeryLadder(pointU, scalar) {
    const { P } = CURVE;
    const u = normalizeScalar(pointU, P);
    const k = normalizeScalar(scalar, P);
    const a24 = BigInt(121665);
    const x_1 = u;
    let x_2 = _1n;
    let z_2 = _0n;
    let x_3 = u;
    let z_3 = _1n;
    let swap = _0n;
    let sw;
    for(let t = BigInt(255 - 1); t >= _0n; t--){
        const k_t = k >> t & _1n;
        swap ^= k_t;
        sw = cswap(swap, x_2, x_3);
        x_2 = sw[0];
        x_3 = sw[1];
        sw = cswap(swap, z_2, z_3);
        z_2 = sw[0];
        z_3 = sw[1];
        swap = k_t;
        const A = x_2 + z_2;
        const AA = mod(A * A);
        const B = x_2 - z_2;
        const BB = mod(B * B);
        const E = AA - BB;
        const C = x_3 + z_3;
        const D = x_3 - z_3;
        const DA = mod(D * A);
        const CB = mod(C * B);
        const dacb = DA + CB;
        const da_cb = DA - CB;
        x_3 = mod(dacb * dacb);
        z_3 = mod(x_1 * mod(da_cb * da_cb));
        x_2 = mod(AA * BB);
        z_2 = mod(E * (AA + mod(a24 * E)));
    }
    sw = cswap(swap, x_2, x_3);
    x_2 = sw[0];
    x_3 = sw[1];
    sw = cswap(swap, z_2, z_3);
    z_2 = sw[0];
    z_3 = sw[1];
    const { pow_p_5_8, b2 } = pow_2_252_3(z_2);
    const xp2 = mod(pow2(pow_p_5_8, BigInt(3)) * b2);
    return mod(x_2 * xp2);
}
function encodeUCoordinate(u) {
    return numberTo32BytesLE(mod(u, CURVE.P));
}
function decodeUCoordinate(uEnc) {
    const u = ensureBytes(uEnc, 32);
    u[31] &= 127;
    return bytesToNumberLE(u);
}
const curve25519 = {
    BASE_POINT_U: '0900000000000000000000000000000000000000000000000000000000000000',
    scalarMult (privateKey, publicKey) {
        const u = decodeUCoordinate(publicKey);
        const p = decodeScalar25519(privateKey);
        const pu = montgomeryLadder(u, p);
        if (pu === _0n) throw new Error('Invalid private or public key received');
        return encodeUCoordinate(pu);
    },
    scalarMultBase (privateKey) {
        return curve25519.scalarMult(privateKey, curve25519.BASE_POINT_U);
    }
};
const crypto = {
    node: void 0,
    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined
};
const utils = {
    bytesToHex,
    hexToBytes,
    concatBytes,
    getExtendedPublicKey,
    mod,
    invert,
    TORSION_SUBGROUP: [
        '0100000000000000000000000000000000000000000000000000000000000000',
        'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',
        '0000000000000000000000000000000000000000000000000000000000000080',
        '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',
        'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',
        '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',
        '0000000000000000000000000000000000000000000000000000000000000000',
        'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa'
    ],
    hashToPrivateScalar: (hash)=>{
        hash = ensureBytes(hash);
        if (hash.length < 40 || hash.length > 1024) throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');
        return mod(bytesToNumberLE(hash), CURVE.l - _1n) + _1n;
    },
    randomBytes: (bytesLength = 32)=>{
        if (crypto.web) {
            return crypto.web.getRandomValues(new Uint8Array(bytesLength));
        } else if (crypto.node) {
            const { randomBytes } = crypto.node;
            return new Uint8Array(randomBytes(bytesLength).buffer);
        } else {
            throw new Error("The environment doesn't have randomBytes function");
        }
    },
    randomPrivateKey: ()=>{
        return utils.randomBytes(32);
    },
    sha512: async (...messages)=>{
        const message = concatBytes(...messages);
        if (crypto.web) {
            const buffer = await crypto.web.subtle.digest('SHA-512', message.buffer);
            return new Uint8Array(buffer);
        } else if (crypto.node) {
            return Uint8Array.from(crypto.node.createHash('sha512').update(message).digest());
        } else {
            throw new Error("The environment doesn't have sha512 function");
        }
    },
    precompute (windowSize = 8, point = Point.BASE) {
        const cached = point.equals(Point.BASE) ? point : new Point(point.x, point.y);
        cached._setWindowSize(windowSize);
        cached.multiply(_2n);
        return cached;
    },
    sha512Sync: undefined
};
Object.defineProperties(utils, {
    sha512Sync: {
        configurable: false,
        get () {
            return _sha512Sync;
        },
        set (val) {
            if (!_sha512Sync) _sha512Sync = val;
        }
    }
});
}),
"[project]/node_modules/@scure/base/lib/esm/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */ __turbopack_context__.s([
    "base16",
    ()=>base16,
    "base32",
    ()=>base32,
    "base32crockford",
    ()=>base32crockford,
    "base32hex",
    ()=>base32hex,
    "base32hexnopad",
    ()=>base32hexnopad,
    "base32nopad",
    ()=>base32nopad,
    "base58",
    ()=>base58,
    "base58check",
    ()=>base58check,
    "base58flickr",
    ()=>base58flickr,
    "base58xmr",
    ()=>base58xmr,
    "base58xrp",
    ()=>base58xrp,
    "base64",
    ()=>base64,
    "base64nopad",
    ()=>base64nopad,
    "base64url",
    ()=>base64url,
    "base64urlnopad",
    ()=>base64urlnopad,
    "bech32",
    ()=>bech32,
    "bech32m",
    ()=>bech32m,
    "bytes",
    ()=>bytes,
    "bytesToString",
    ()=>bytesToString,
    "createBase58check",
    ()=>createBase58check,
    "hex",
    ()=>hex,
    "str",
    ()=>str,
    "stringToBytes",
    ()=>stringToBytes,
    "utf8",
    ()=>utf8,
    "utils",
    ()=>utils
]);
function isBytes(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array';
}
/** Asserts something is Uint8Array. */ function abytes(b, ...lengths) {
    if (!isBytes(b)) throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);
}
function isArrayOf(isString, arr) {
    if (!Array.isArray(arr)) return false;
    if (arr.length === 0) return true;
    if (isString) {
        return arr.every((item)=>typeof item === 'string');
    } else {
        return arr.every((item)=>Number.isSafeInteger(item));
    }
}
// no abytes: seems to have 10% slowdown. Why?!
function afn(input) {
    if (typeof input !== 'function') throw new Error('function expected');
    return true;
}
function astr(label, input) {
    if (typeof input !== 'string') throw new Error(`${label}: string expected`);
    return true;
}
function anumber(n) {
    if (!Number.isSafeInteger(n)) throw new Error(`invalid integer: ${n}`);
}
function aArr(input) {
    if (!Array.isArray(input)) throw new Error('array expected');
}
function astrArr(label, input) {
    if (!isArrayOf(true, input)) throw new Error(`${label}: array of strings expected`);
}
function anumArr(label, input) {
    if (!isArrayOf(false, input)) throw new Error(`${label}: array of numbers expected`);
}
/**
 * @__NO_SIDE_EFFECTS__
 */ function chain(...args) {
    const id = (a)=>a;
    // Wrap call in closure so JIT can inline calls
    const wrap = (a, b)=>(c)=>a(b(c));
    // Construct chain of args[-1].encode(args[-2].encode([...]))
    const encode = args.map((x)=>x.encode).reduceRight(wrap, id);
    // Construct chain of args[0].decode(args[1].decode(...))
    const decode = args.map((x)=>x.decode).reduce(wrap, id);
    return {
        encode,
        decode
    };
}
/**
 * Encodes integer radix representation to array of strings using alphabet and back.
 * Could also be array of strings.
 * @__NO_SIDE_EFFECTS__
 */ function alphabet(letters) {
    // mapping 1 to "b"
    const lettersA = typeof letters === 'string' ? letters.split('') : letters;
    const len = lettersA.length;
    astrArr('alphabet', lettersA);
    // mapping "b" to 1
    const indexes = new Map(lettersA.map((l, i)=>[
            l,
            i
        ]));
    return {
        encode: (digits)=>{
            aArr(digits);
            return digits.map((i)=>{
                if (!Number.isSafeInteger(i) || i < 0 || i >= len) throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${letters}`);
                return lettersA[i];
            });
        },
        decode: (input)=>{
            aArr(input);
            return input.map((letter)=>{
                astr('alphabet.decode', letter);
                const i = indexes.get(letter);
                if (i === undefined) throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
                return i;
            });
        }
    };
}
/**
 * @__NO_SIDE_EFFECTS__
 */ function join(separator = '') {
    astr('join', separator);
    return {
        encode: (from)=>{
            astrArr('join.decode', from);
            return from.join(separator);
        },
        decode: (to)=>{
            astr('join.decode', to);
            return to.split(separator);
        }
    };
}
/**
 * Pad strings array so it has integer number of bits
 * @__NO_SIDE_EFFECTS__
 */ function padding(bits, chr = '=') {
    anumber(bits);
    astr('padding', chr);
    return {
        encode (data) {
            astrArr('padding.encode', data);
            while(data.length * bits % 8)data.push(chr);
            return data;
        },
        decode (input) {
            astrArr('padding.decode', input);
            let end = input.length;
            if (end * bits % 8) throw new Error('padding: invalid, string should have whole number of bytes');
            for(; end > 0 && input[end - 1] === chr; end--){
                const last = end - 1;
                const byte = last * bits;
                if (byte % 8 === 0) throw new Error('padding: invalid, string has too much padding');
            }
            return input.slice(0, end);
        }
    };
}
/**
 * @__NO_SIDE_EFFECTS__
 */ function normalize(fn) {
    afn(fn);
    return {
        encode: (from)=>from,
        decode: (to)=>fn(to)
    };
}
/**
 * Slow: O(n^2) time complexity
 */ function convertRadix(data, from, to) {
    // base 1 is impossible
    if (from < 2) throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);
    if (to < 2) throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);
    aArr(data);
    if (!data.length) return [];
    let pos = 0;
    const res = [];
    const digits = Array.from(data, (d)=>{
        anumber(d);
        if (d < 0 || d >= from) throw new Error(`invalid integer: ${d}`);
        return d;
    });
    const dlen = digits.length;
    while(true){
        let carry = 0;
        let done = true;
        for(let i = pos; i < dlen; i++){
            const digit = digits[i];
            const fromCarry = from * carry;
            const digitBase = fromCarry + digit;
            if (!Number.isSafeInteger(digitBase) || fromCarry / from !== carry || digitBase - digit !== fromCarry) {
                throw new Error('convertRadix: carry overflow');
            }
            const div = digitBase / to;
            carry = digitBase % to;
            const rounded = Math.floor(div);
            digits[i] = rounded;
            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase) throw new Error('convertRadix: carry overflow');
            if (!done) continue;
            else if (!rounded) pos = i;
            else done = false;
        }
        res.push(carry);
        if (done) break;
    }
    for(let i = 0; i < data.length - 1 && data[i] === 0; i++)res.push(0);
    return res.reverse();
}
const gcd = (a, b)=>b === 0 ? a : gcd(b, a % b);
const radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from, to)=>from + (to - gcd(from, to));
const powers = /* @__PURE__ */ (()=>{
    let res = [];
    for(let i = 0; i < 40; i++)res.push(2 ** i);
    return res;
})();
/**
 * Implemented with numbers, because BigInt is 5x slower
 */ function convertRadix2(data, from, to, padding) {
    aArr(data);
    if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);
    if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);
    if (radix2carry(from, to) > 32) {
        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
    }
    let carry = 0;
    let pos = 0; // bitwise position in current element
    const max = powers[from];
    const mask = powers[to] - 1;
    const res = [];
    for (const n of data){
        anumber(n);
        if (n >= max) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
        carry = carry << from | n;
        if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
        pos += from;
        for(; pos >= to; pos -= to)res.push((carry >> pos - to & mask) >>> 0);
        const pow = powers[pos];
        if (pow === undefined) throw new Error('invalid carry');
        carry &= pow - 1; // clean carry, otherwise it will cause overflow
    }
    carry = carry << to - pos & mask;
    if (!padding && pos >= from) throw new Error('Excess padding');
    if (!padding && carry > 0) throw new Error(`Non-zero padding: ${carry}`);
    if (padding && pos > 0) res.push(carry >>> 0);
    return res;
}
/**
 * @__NO_SIDE_EFFECTS__
 */ function radix(num) {
    anumber(num);
    const _256 = 2 ** 8;
    return {
        encode: (bytes)=>{
            if (!isBytes(bytes)) throw new Error('radix.encode input should be Uint8Array');
            return convertRadix(Array.from(bytes), _256, num);
        },
        decode: (digits)=>{
            anumArr('radix.decode', digits);
            return Uint8Array.from(convertRadix(digits, num, _256));
        }
    };
}
/**
 * If both bases are power of same number (like `2**8 <-> 2**64`),
 * there is a linear algorithm. For now we have implementation for power-of-two bases only.
 * @__NO_SIDE_EFFECTS__
 */ function radix2(bits, revPadding = false) {
    anumber(bits);
    if (bits <= 0 || bits > 32) throw new Error('radix2: bits should be in (0..32]');
    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32) throw new Error('radix2: carry overflow');
    return {
        encode: (bytes)=>{
            if (!isBytes(bytes)) throw new Error('radix2.encode input should be Uint8Array');
            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
        },
        decode: (digits)=>{
            anumArr('radix2.decode', digits);
            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
        }
    };
}
function unsafeWrapper(fn) {
    afn(fn);
    return function(...args) {
        try {
            return fn.apply(null, args);
        } catch (e) {}
    };
}
function checksum(len, fn) {
    anumber(len);
    afn(fn);
    return {
        encode (data) {
            if (!isBytes(data)) throw new Error('checksum.encode: input should be Uint8Array');
            const sum = fn(data).slice(0, len);
            const res = new Uint8Array(data.length + len);
            res.set(data);
            res.set(sum, data.length);
            return res;
        },
        decode (data) {
            if (!isBytes(data)) throw new Error('checksum.decode: input should be Uint8Array');
            const payload = data.slice(0, -len);
            const oldChecksum = data.slice(-len);
            const newChecksum = fn(payload).slice(0, len);
            for(let i = 0; i < len; i++)if (newChecksum[i] !== oldChecksum[i]) throw new Error('Invalid checksum');
            return payload;
        }
    };
}
const utils = {
    alphabet,
    chain,
    checksum,
    convertRadix,
    convertRadix2,
    radix,
    radix2,
    join,
    padding
};
const base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));
const base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));
const base32nopad = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), join(''));
const base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));
const base32hexnopad = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), join(''));
const base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s)=>s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));
// Built-in base64 conversion https://caniuse.com/mdn-javascript_builtins_uint8array_frombase64
// prettier-ignore
const hasBase64Builtin = /* @__PURE__ */ (()=>typeof Uint8Array.from([]).toBase64 === 'function' && typeof Uint8Array.fromBase64 === 'function')();
const decodeBase64Builtin = (s, isUrl)=>{
    astr('base64', s);
    const re = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;
    const alphabet = isUrl ? 'base64url' : 'base64';
    if (s.length > 0 && !re.test(s)) throw new Error('invalid base64');
    return Uint8Array.fromBase64(s, {
        alphabet,
        lastChunkHandling: 'strict'
    });
};
const base64 = hasBase64Builtin ? {
    encode (b) {
        abytes(b);
        return b.toBase64();
    },
    decode (s) {
        return decodeBase64Builtin(s, false);
    }
} : chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));
const base64nopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), join(''));
const base64url = hasBase64Builtin ? {
    encode (b) {
        abytes(b);
        return b.toBase64({
            alphabet: 'base64url'
        });
    },
    decode (s) {
        return decodeBase64Builtin(s, true);
    }
} : chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));
const base64urlnopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));
// base58 code
// -----------
const genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc)=>chain(radix(58), alphabet(abc), join(''));
const base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');
const base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');
const base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');
// Data len (index) -> encoded block len
const XMR_BLOCK_LEN = [
    0,
    2,
    3,
    5,
    6,
    7,
    9,
    10,
    11
];
const base58xmr = {
    encode (data) {
        let res = '';
        for(let i = 0; i < data.length; i += 8){
            const block = data.subarray(i, i + 8);
            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');
        }
        return res;
    },
    decode (str) {
        let res = [];
        for(let i = 0; i < str.length; i += 11){
            const slice = str.slice(i, i + 11);
            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);
            const block = base58.decode(slice);
            for(let j = 0; j < block.length - blockLen; j++){
                if (block[j] !== 0) throw new Error('base58xmr: wrong padding');
            }
            res = res.concat(Array.from(block.slice(block.length - blockLen)));
        }
        return Uint8Array.from(res);
    }
};
const createBase58check = (sha256)=>chain(checksum(4, (data)=>sha256(sha256(data))), base58);
const base58check = createBase58check;
const BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));
const POLYMOD_GENERATORS = [
    0x3b6a57b2,
    0x26508e6d,
    0x1ea119fa,
    0x3d4233dd,
    0x2a1462b3
];
function bech32Polymod(pre) {
    const b = pre >> 25;
    let chk = (pre & 0x1ffffff) << 5;
    for(let i = 0; i < POLYMOD_GENERATORS.length; i++){
        if ((b >> i & 1) === 1) chk ^= POLYMOD_GENERATORS[i];
    }
    return chk;
}
function bechChecksum(prefix, words, encodingConst = 1) {
    const len = prefix.length;
    let chk = 1;
    for(let i = 0; i < len; i++){
        const c = prefix.charCodeAt(i);
        if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);
        chk = bech32Polymod(chk) ^ c >> 5;
    }
    chk = bech32Polymod(chk);
    for(let i = 0; i < len; i++)chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 0x1f;
    for (let v of words)chk = bech32Polymod(chk) ^ v;
    for(let i = 0; i < 6; i++)chk = bech32Polymod(chk);
    chk ^= encodingConst;
    return BECH_ALPHABET.encode(convertRadix2([
        chk % powers[30]
    ], 30, 5, false));
}
/**
 * @__NO_SIDE_EFFECTS__
 */ function genBech32(encoding) {
    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;
    const _words = radix2(5);
    const fromWords = _words.decode;
    const toWords = _words.encode;
    const fromWordsUnsafe = unsafeWrapper(fromWords);
    function encode(prefix, words, limit = 90) {
        astr('bech32.encode prefix', prefix);
        if (isBytes(words)) words = Array.from(words);
        anumArr('bech32.encode', words);
        const plen = prefix.length;
        if (plen === 0) throw new TypeError(`Invalid prefix length ${plen}`);
        const actualLength = plen + 7 + words.length;
        if (limit !== false && actualLength > limit) throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
        const lowered = prefix.toLowerCase();
        const sum = bechChecksum(lowered, words, ENCODING_CONST);
        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
    }
    function decode(str, limit = 90) {
        astr('bech32.decode input', str);
        const slen = str.length;
        if (slen < 8 || limit !== false && slen > limit) throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);
        // don't allow mixed case
        const lowered = str.toLowerCase();
        if (str !== lowered && str !== str.toUpperCase()) throw new Error(`String must be lowercase or uppercase`);
        const sepIndex = lowered.lastIndexOf('1');
        if (sepIndex === 0 || sepIndex === -1) throw new Error(`Letter "1" must be present between prefix and data only`);
        const prefix = lowered.slice(0, sepIndex);
        const data = lowered.slice(sepIndex + 1);
        if (data.length < 6) throw new Error('Data must be at least 6 characters long');
        const words = BECH_ALPHABET.decode(data).slice(0, -6);
        const sum = bechChecksum(prefix, words, ENCODING_CONST);
        if (!data.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
        return {
            prefix,
            words
        };
    }
    const decodeUnsafe = unsafeWrapper(decode);
    function decodeToBytes(str) {
        const { prefix, words } = decode(str, false);
        return {
            prefix,
            words,
            bytes: fromWords(words)
        };
    }
    function encodeFromBytes(prefix, bytes) {
        return encode(prefix, toWords(bytes));
    }
    return {
        encode,
        decode,
        encodeFromBytes,
        decodeToBytes,
        decodeUnsafe,
        fromWords,
        fromWordsUnsafe,
        toWords
    };
}
const bech32 = genBech32('bech32');
const bech32m = genBech32('bech32m');
const utf8 = {
    encode: (data)=>new TextDecoder().decode(data),
    decode: (str)=>new TextEncoder().encode(str)
};
// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex
// prettier-ignore
const hasHexBuiltin = /* @__PURE__ */ (()=>typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();
// prettier-ignore
const hexBuiltin = {
    encode (data) {
        abytes(data);
        return data.toHex();
    },
    decode (s) {
        astr('hex', s);
        return Uint8Array.fromHex(s);
    }
};
const hex = hasHexBuiltin ? hexBuiltin : chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s)=>{
    if (typeof s !== 'string' || s.length % 2 !== 0) throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
    return s.toLowerCase();
}));
// prettier-ignore
const CODERS = {
    utf8,
    hex,
    base16,
    base32,
    base64,
    base64url,
    base58,
    base58xmr
};
const coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';
const bytesToString = (type, bytes)=>{
    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);
    if (!isBytes(bytes)) throw new TypeError('bytesToString() expects Uint8Array');
    return CODERS[type].encode(bytes);
};
const str = bytesToString; // as in python, but for bytes only
const stringToBytes = (type, str)=>{
    if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);
    if (typeof str !== 'string') throw new TypeError('stringToBytes() expects string');
    return CODERS[type].decode(str);
};
const bytes = stringToBytes; //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@scure/bip39/esm/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Audited & minimal JS implementation of
 * [BIP39 mnemonic phrases](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki).
 * @module
 * @example
```js
import * as bip39 from '@scure/bip39';
import { wordlist } from '@scure/bip39/wordlists/english';
const mn = bip39.generateMnemonic(wordlist);
console.log(mn);
const ent = bip39.mnemonicToEntropy(mn, wordlist)
bip39.entropyToMnemonic(ent, wordlist);
bip39.validateMnemonic(mn, wordlist);
await bip39.mnemonicToSeed(mn, 'password');
bip39.mnemonicToSeedSync(mn, 'password');

// Wordlists
import { wordlist as czech } from '@scure/bip39/wordlists/czech';
import { wordlist as english } from '@scure/bip39/wordlists/english';
import { wordlist as french } from '@scure/bip39/wordlists/french';
import { wordlist as italian } from '@scure/bip39/wordlists/italian';
import { wordlist as japanese } from '@scure/bip39/wordlists/japanese';
import { wordlist as korean } from '@scure/bip39/wordlists/korean';
import { wordlist as portuguese } from '@scure/bip39/wordlists/portuguese';
import { wordlist as simplifiedChinese } from '@scure/bip39/wordlists/simplified-chinese';
import { wordlist as spanish } from '@scure/bip39/wordlists/spanish';
import { wordlist as traditionalChinese } from '@scure/bip39/wordlists/traditional-chinese';
```
 */ /*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */ __turbopack_context__.s([
    "entropyToMnemonic",
    ()=>entropyToMnemonic,
    "generateMnemonic",
    ()=>generateMnemonic,
    "mnemonicToEntropy",
    ()=>mnemonicToEntropy,
    "mnemonicToSeed",
    ()=>mnemonicToSeed,
    "mnemonicToSeedSync",
    ()=>mnemonicToSeedSync,
    "validateMnemonic",
    ()=>validateMnemonic
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$pbkdf2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@scure/bip39/node_modules/@noble/hashes/esm/pbkdf2.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@scure/bip39/node_modules/@noble/hashes/esm/sha2.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@scure/bip39/node_modules/@noble/hashes/esm/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$base$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@scure/base/lib/esm/index.js [app-client] (ecmascript)");
;
;
;
;
// Japanese wordlist
const isJapanese = (wordlist)=>wordlist[0] === '\u3042\u3044\u3053\u304f\u3057\u3093';
// Normalization replaces equivalent sequences of characters
// so that any two texts that are equivalent will be reduced
// to the same sequence of code points, called the normal form of the original text.
// https://tonsky.me/blog/unicode/#why-is-a----
function nfkd(str) {
    if (typeof str !== 'string') throw new TypeError('invalid mnemonic type: ' + typeof str);
    return str.normalize('NFKD');
}
function normalize(str) {
    const norm = nfkd(str);
    const words = norm.split(' ');
    if (![
        12,
        15,
        18,
        21,
        24
    ].includes(words.length)) throw new Error('Invalid mnemonic');
    return {
        nfkd: norm,
        words
    };
}
function aentropy(ent) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["abytes"])(ent, 16, 20, 24, 28, 32);
}
function generateMnemonic(wordlist, strength = 128) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["anumber"])(strength);
    if (strength % 32 !== 0 || strength > 256) throw new TypeError('Invalid entropy');
    return entropyToMnemonic((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["randomBytes"])(strength / 8), wordlist);
}
const calcChecksum = (entropy)=>{
    // Checksum is ent.length/4 bits long
    const bitsLeft = 8 - entropy.length / 4;
    // Zero rightmost "bitsLeft" bits in byte
    // For example: bitsLeft=4 val=10111101 -> 10110000
    return new Uint8Array([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sha256"])(entropy)[0] >> bitsLeft << bitsLeft
    ]);
};
function getCoder(wordlist) {
    if (!Array.isArray(wordlist) || wordlist.length !== 2048 || typeof wordlist[0] !== 'string') throw new Error('Wordlist: expected array of 2048 strings');
    wordlist.forEach((i)=>{
        if (typeof i !== 'string') throw new Error('wordlist: non-string element: ' + i);
    });
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$base$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["utils"].chain(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$base$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["utils"].checksum(1, calcChecksum), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$base$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["utils"].radix2(11, true), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$base$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["utils"].alphabet(wordlist));
}
function mnemonicToEntropy(mnemonic, wordlist) {
    const { words } = normalize(mnemonic);
    const entropy = getCoder(wordlist).decode(words);
    aentropy(entropy);
    return entropy;
}
function entropyToMnemonic(entropy, wordlist) {
    aentropy(entropy);
    const words = getCoder(wordlist).encode(entropy);
    return words.join(isJapanese(wordlist) ? '\u3000' : ' ');
}
function validateMnemonic(mnemonic, wordlist) {
    try {
        mnemonicToEntropy(mnemonic, wordlist);
    } catch (e) {
        return false;
    }
    return true;
}
const psalt = (passphrase)=>nfkd('mnemonic' + passphrase);
function mnemonicToSeed(mnemonic, passphrase = '') {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$pbkdf2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pbkdf2Async"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sha512"], normalize(mnemonic).nfkd, psalt(passphrase), {
        c: 2048,
        dkLen: 64
    });
}
function mnemonicToSeedSync(mnemonic, passphrase = '') {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$pbkdf2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pbkdf2"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sha512"], normalize(mnemonic).nfkd, psalt(passphrase), {
        c: 2048,
        dkLen: 64
    });
}
}),
"[project]/node_modules/@scure/bip39/esm/wordlists/english.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "wordlist",
    ()=>wordlist
]);
const wordlist = `abandon
ability
able
about
above
absent
absorb
abstract
absurd
abuse
access
accident
account
accuse
achieve
acid
acoustic
acquire
across
act
action
actor
actress
actual
adapt
add
addict
address
adjust
admit
adult
advance
advice
aerobic
affair
afford
afraid
again
age
agent
agree
ahead
aim
air
airport
aisle
alarm
album
alcohol
alert
alien
all
alley
allow
almost
alone
alpha
already
also
alter
always
amateur
amazing
among
amount
amused
analyst
anchor
ancient
anger
angle
angry
animal
ankle
announce
annual
another
answer
antenna
antique
anxiety
any
apart
apology
appear
apple
approve
april
arch
arctic
area
arena
argue
arm
armed
armor
army
around
arrange
arrest
arrive
arrow
art
artefact
artist
artwork
ask
aspect
assault
asset
assist
assume
asthma
athlete
atom
attack
attend
attitude
attract
auction
audit
august
aunt
author
auto
autumn
average
avocado
avoid
awake
aware
away
awesome
awful
awkward
axis
baby
bachelor
bacon
badge
bag
balance
balcony
ball
bamboo
banana
banner
bar
barely
bargain
barrel
base
basic
basket
battle
beach
bean
beauty
because
become
beef
before
begin
behave
behind
believe
below
belt
bench
benefit
best
betray
better
between
beyond
bicycle
bid
bike
bind
biology
bird
birth
bitter
black
blade
blame
blanket
blast
bleak
bless
blind
blood
blossom
blouse
blue
blur
blush
board
boat
body
boil
bomb
bone
bonus
book
boost
border
boring
borrow
boss
bottom
bounce
box
boy
bracket
brain
brand
brass
brave
bread
breeze
brick
bridge
brief
bright
bring
brisk
broccoli
broken
bronze
broom
brother
brown
brush
bubble
buddy
budget
buffalo
build
bulb
bulk
bullet
bundle
bunker
burden
burger
burst
bus
business
busy
butter
buyer
buzz
cabbage
cabin
cable
cactus
cage
cake
call
calm
camera
camp
can
canal
cancel
candy
cannon
canoe
canvas
canyon
capable
capital
captain
car
carbon
card
cargo
carpet
carry
cart
case
cash
casino
castle
casual
cat
catalog
catch
category
cattle
caught
cause
caution
cave
ceiling
celery
cement
census
century
cereal
certain
chair
chalk
champion
change
chaos
chapter
charge
chase
chat
cheap
check
cheese
chef
cherry
chest
chicken
chief
child
chimney
choice
choose
chronic
chuckle
chunk
churn
cigar
cinnamon
circle
citizen
city
civil
claim
clap
clarify
claw
clay
clean
clerk
clever
click
client
cliff
climb
clinic
clip
clock
clog
close
cloth
cloud
clown
club
clump
cluster
clutch
coach
coast
coconut
code
coffee
coil
coin
collect
color
column
combine
come
comfort
comic
common
company
concert
conduct
confirm
congress
connect
consider
control
convince
cook
cool
copper
copy
coral
core
corn
correct
cost
cotton
couch
country
couple
course
cousin
cover
coyote
crack
cradle
craft
cram
crane
crash
crater
crawl
crazy
cream
credit
creek
crew
cricket
crime
crisp
critic
crop
cross
crouch
crowd
crucial
cruel
cruise
crumble
crunch
crush
cry
crystal
cube
culture
cup
cupboard
curious
current
curtain
curve
cushion
custom
cute
cycle
dad
damage
damp
dance
danger
daring
dash
daughter
dawn
day
deal
debate
debris
decade
december
decide
decline
decorate
decrease
deer
defense
define
defy
degree
delay
deliver
demand
demise
denial
dentist
deny
depart
depend
deposit
depth
deputy
derive
describe
desert
design
desk
despair
destroy
detail
detect
develop
device
devote
diagram
dial
diamond
diary
dice
diesel
diet
differ
digital
dignity
dilemma
dinner
dinosaur
direct
dirt
disagree
discover
disease
dish
dismiss
disorder
display
distance
divert
divide
divorce
dizzy
doctor
document
dog
doll
dolphin
domain
donate
donkey
donor
door
dose
double
dove
draft
dragon
drama
drastic
draw
dream
dress
drift
drill
drink
drip
drive
drop
drum
dry
duck
dumb
dune
during
dust
dutch
duty
dwarf
dynamic
eager
eagle
early
earn
earth
easily
east
easy
echo
ecology
economy
edge
edit
educate
effort
egg
eight
either
elbow
elder
electric
elegant
element
elephant
elevator
elite
else
embark
embody
embrace
emerge
emotion
employ
empower
empty
enable
enact
end
endless
endorse
enemy
energy
enforce
engage
engine
enhance
enjoy
enlist
enough
enrich
enroll
ensure
enter
entire
entry
envelope
episode
equal
equip
era
erase
erode
erosion
error
erupt
escape
essay
essence
estate
eternal
ethics
evidence
evil
evoke
evolve
exact
example
excess
exchange
excite
exclude
excuse
execute
exercise
exhaust
exhibit
exile
exist
exit
exotic
expand
expect
expire
explain
expose
express
extend
extra
eye
eyebrow
fabric
face
faculty
fade
faint
faith
fall
false
fame
family
famous
fan
fancy
fantasy
farm
fashion
fat
fatal
father
fatigue
fault
favorite
feature
february
federal
fee
feed
feel
female
fence
festival
fetch
fever
few
fiber
fiction
field
figure
file
film
filter
final
find
fine
finger
finish
fire
firm
first
fiscal
fish
fit
fitness
fix
flag
flame
flash
flat
flavor
flee
flight
flip
float
flock
floor
flower
fluid
flush
fly
foam
focus
fog
foil
fold
follow
food
foot
force
forest
forget
fork
fortune
forum
forward
fossil
foster
found
fox
fragile
frame
frequent
fresh
friend
fringe
frog
front
frost
frown
frozen
fruit
fuel
fun
funny
furnace
fury
future
gadget
gain
galaxy
gallery
game
gap
garage
garbage
garden
garlic
garment
gas
gasp
gate
gather
gauge
gaze
general
genius
genre
gentle
genuine
gesture
ghost
giant
gift
giggle
ginger
giraffe
girl
give
glad
glance
glare
glass
glide
glimpse
globe
gloom
glory
glove
glow
glue
goat
goddess
gold
good
goose
gorilla
gospel
gossip
govern
gown
grab
grace
grain
grant
grape
grass
gravity
great
green
grid
grief
grit
grocery
group
grow
grunt
guard
guess
guide
guilt
guitar
gun
gym
habit
hair
half
hammer
hamster
hand
happy
harbor
hard
harsh
harvest
hat
have
hawk
hazard
head
health
heart
heavy
hedgehog
height
hello
helmet
help
hen
hero
hidden
high
hill
hint
hip
hire
history
hobby
hockey
hold
hole
holiday
hollow
home
honey
hood
hope
horn
horror
horse
hospital
host
hotel
hour
hover
hub
huge
human
humble
humor
hundred
hungry
hunt
hurdle
hurry
hurt
husband
hybrid
ice
icon
idea
identify
idle
ignore
ill
illegal
illness
image
imitate
immense
immune
impact
impose
improve
impulse
inch
include
income
increase
index
indicate
indoor
industry
infant
inflict
inform
inhale
inherit
initial
inject
injury
inmate
inner
innocent
input
inquiry
insane
insect
inside
inspire
install
intact
interest
into
invest
invite
involve
iron
island
isolate
issue
item
ivory
jacket
jaguar
jar
jazz
jealous
jeans
jelly
jewel
job
join
joke
journey
joy
judge
juice
jump
jungle
junior
junk
just
kangaroo
keen
keep
ketchup
key
kick
kid
kidney
kind
kingdom
kiss
kit
kitchen
kite
kitten
kiwi
knee
knife
knock
know
lab
label
labor
ladder
lady
lake
lamp
language
laptop
large
later
latin
laugh
laundry
lava
law
lawn
lawsuit
layer
lazy
leader
leaf
learn
leave
lecture
left
leg
legal
legend
leisure
lemon
lend
length
lens
leopard
lesson
letter
level
liar
liberty
library
license
life
lift
light
like
limb
limit
link
lion
liquid
list
little
live
lizard
load
loan
lobster
local
lock
logic
lonely
long
loop
lottery
loud
lounge
love
loyal
lucky
luggage
lumber
lunar
lunch
luxury
lyrics
machine
mad
magic
magnet
maid
mail
main
major
make
mammal
man
manage
mandate
mango
mansion
manual
maple
marble
march
margin
marine
market
marriage
mask
mass
master
match
material
math
matrix
matter
maximum
maze
meadow
mean
measure
meat
mechanic
medal
media
melody
melt
member
memory
mention
menu
mercy
merge
merit
merry
mesh
message
metal
method
middle
midnight
milk
million
mimic
mind
minimum
minor
minute
miracle
mirror
misery
miss
mistake
mix
mixed
mixture
mobile
model
modify
mom
moment
monitor
monkey
monster
month
moon
moral
more
morning
mosquito
mother
motion
motor
mountain
mouse
move
movie
much
muffin
mule
multiply
muscle
museum
mushroom
music
must
mutual
myself
mystery
myth
naive
name
napkin
narrow
nasty
nation
nature
near
neck
need
negative
neglect
neither
nephew
nerve
nest
net
network
neutral
never
news
next
nice
night
noble
noise
nominee
noodle
normal
north
nose
notable
note
nothing
notice
novel
now
nuclear
number
nurse
nut
oak
obey
object
oblige
obscure
observe
obtain
obvious
occur
ocean
october
odor
off
offer
office
often
oil
okay
old
olive
olympic
omit
once
one
onion
online
only
open
opera
opinion
oppose
option
orange
orbit
orchard
order
ordinary
organ
orient
original
orphan
ostrich
other
outdoor
outer
output
outside
oval
oven
over
own
owner
oxygen
oyster
ozone
pact
paddle
page
pair
palace
palm
panda
panel
panic
panther
paper
parade
parent
park
parrot
party
pass
patch
path
patient
patrol
pattern
pause
pave
payment
peace
peanut
pear
peasant
pelican
pen
penalty
pencil
people
pepper
perfect
permit
person
pet
phone
photo
phrase
physical
piano
picnic
picture
piece
pig
pigeon
pill
pilot
pink
pioneer
pipe
pistol
pitch
pizza
place
planet
plastic
plate
play
please
pledge
pluck
plug
plunge
poem
poet
point
polar
pole
police
pond
pony
pool
popular
portion
position
possible
post
potato
pottery
poverty
powder
power
practice
praise
predict
prefer
prepare
present
pretty
prevent
price
pride
primary
print
priority
prison
private
prize
problem
process
produce
profit
program
project
promote
proof
property
prosper
protect
proud
provide
public
pudding
pull
pulp
pulse
pumpkin
punch
pupil
puppy
purchase
purity
purpose
purse
push
put
puzzle
pyramid
quality
quantum
quarter
question
quick
quit
quiz
quote
rabbit
raccoon
race
rack
radar
radio
rail
rain
raise
rally
ramp
ranch
random
range
rapid
rare
rate
rather
raven
raw
razor
ready
real
reason
rebel
rebuild
recall
receive
recipe
record
recycle
reduce
reflect
reform
refuse
region
regret
regular
reject
relax
release
relief
rely
remain
remember
remind
remove
render
renew
rent
reopen
repair
repeat
replace
report
require
rescue
resemble
resist
resource
response
result
retire
retreat
return
reunion
reveal
review
reward
rhythm
rib
ribbon
rice
rich
ride
ridge
rifle
right
rigid
ring
riot
ripple
risk
ritual
rival
river
road
roast
robot
robust
rocket
romance
roof
rookie
room
rose
rotate
rough
round
route
royal
rubber
rude
rug
rule
run
runway
rural
sad
saddle
sadness
safe
sail
salad
salmon
salon
salt
salute
same
sample
sand
satisfy
satoshi
sauce
sausage
save
say
scale
scan
scare
scatter
scene
scheme
school
science
scissors
scorpion
scout
scrap
screen
script
scrub
sea
search
season
seat
second
secret
section
security
seed
seek
segment
select
sell
seminar
senior
sense
sentence
series
service
session
settle
setup
seven
shadow
shaft
shallow
share
shed
shell
sheriff
shield
shift
shine
ship
shiver
shock
shoe
shoot
shop
short
shoulder
shove
shrimp
shrug
shuffle
shy
sibling
sick
side
siege
sight
sign
silent
silk
silly
silver
similar
simple
since
sing
siren
sister
situate
six
size
skate
sketch
ski
skill
skin
skirt
skull
slab
slam
sleep
slender
slice
slide
slight
slim
slogan
slot
slow
slush
small
smart
smile
smoke
smooth
snack
snake
snap
sniff
snow
soap
soccer
social
sock
soda
soft
solar
soldier
solid
solution
solve
someone
song
soon
sorry
sort
soul
sound
soup
source
south
space
spare
spatial
spawn
speak
special
speed
spell
spend
sphere
spice
spider
spike
spin
spirit
split
spoil
sponsor
spoon
sport
spot
spray
spread
spring
spy
square
squeeze
squirrel
stable
stadium
staff
stage
stairs
stamp
stand
start
state
stay
steak
steel
stem
step
stereo
stick
still
sting
stock
stomach
stone
stool
story
stove
strategy
street
strike
strong
struggle
student
stuff
stumble
style
subject
submit
subway
success
such
sudden
suffer
sugar
suggest
suit
summer
sun
sunny
sunset
super
supply
supreme
sure
surface
surge
surprise
surround
survey
suspect
sustain
swallow
swamp
swap
swarm
swear
sweet
swift
swim
swing
switch
sword
symbol
symptom
syrup
system
table
tackle
tag
tail
talent
talk
tank
tape
target
task
taste
tattoo
taxi
teach
team
tell
ten
tenant
tennis
tent
term
test
text
thank
that
theme
then
theory
there
they
thing
this
thought
three
thrive
throw
thumb
thunder
ticket
tide
tiger
tilt
timber
time
tiny
tip
tired
tissue
title
toast
tobacco
today
toddler
toe
together
toilet
token
tomato
tomorrow
tone
tongue
tonight
tool
tooth
top
topic
topple
torch
tornado
tortoise
toss
total
tourist
toward
tower
town
toy
track
trade
traffic
tragic
train
transfer
trap
trash
travel
tray
treat
tree
trend
trial
tribe
trick
trigger
trim
trip
trophy
trouble
truck
true
truly
trumpet
trust
truth
try
tube
tuition
tumble
tuna
tunnel
turkey
turn
turtle
twelve
twenty
twice
twin
twist
two
type
typical
ugly
umbrella
unable
unaware
uncle
uncover
under
undo
unfair
unfold
unhappy
uniform
unique
unit
universe
unknown
unlock
until
unusual
unveil
update
upgrade
uphold
upon
upper
upset
urban
urge
usage
use
used
useful
useless
usual
utility
vacant
vacuum
vague
valid
valley
valve
van
vanish
vapor
various
vast
vault
vehicle
velvet
vendor
venture
venue
verb
verify
version
very
vessel
veteran
viable
vibrant
vicious
victory
video
view
village
vintage
violin
virtual
virus
visa
visit
visual
vital
vivid
vocal
voice
void
volcano
volume
vote
voyage
wage
wagon
wait
walk
wall
walnut
want
warfare
warm
warrior
wash
wasp
waste
water
wave
way
wealth
weapon
wear
weasel
weather
web
wedding
weekend
weird
welcome
west
wet
whale
what
wheat
wheel
when
where
whip
whisper
wide
width
wife
wild
will
win
window
wine
wing
wink
winner
winter
wire
wisdom
wise
wish
witness
wolf
woman
wonder
wood
wool
word
work
world
worry
worth
wrap
wreck
wrestle
wrist
write
wrong
yard
year
yellow
you
young
youth
zebra
zero
zone
zoo`.split('\n');
}),
"[project]/node_modules/one-webcrypto/browser.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "webcrypto",
    ()=>webcrypto
]);
const _globalReference = globalThis || window || self;
const webcrypto = _globalReference.crypto;
}),
"[project]/node_modules/p-defer/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>pDefer
]);
function pDefer() {
    const deferred = {};
    deferred.promise = new Promise((resolve, reject)=>{
        deferred.resolve = resolve;
        deferred.reject = reject;
    });
    return deferred;
}
}),
"[project]/node_modules/sync-multihash-sha2/src/sha256/digest.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Digest",
    ()=>Digest,
    "code",
    ()=>code,
    "name",
    ()=>name,
    "prefix",
    ()=>prefix,
    "size",
    ()=>size
]);
const name = 'sha2-256';
const code = 0x12;
const size = 32;
const prefix = new Uint8Array([
    18,
    32
]);
class Digest {
    /**
   * @param {Uint8Array} bytes
   */ constructor(bytes){
        /** @type {typeof code} */ this.code = code;
        /** @type {typeof name} */ this.name = name;
        this.bytes = bytes;
        /** @type {typeof size} */ this.size = size;
        this.digest = bytes.subarray(2);
    }
}
}),
"[project]/node_modules/sync-multihash-sha2/src/sha256/web.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

/* c8 ignore next */ __turbopack_context__.s([
    "digest",
    ()=>digest
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/sha256.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sync$2d$multihash$2d$sha2$2f$src$2f$sha256$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/sync-multihash-sha2/src/sha256/digest.js [app-client] (ecmascript)");
;
;
;
const digest = (payload)=>{
    const digest = new Uint8Array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sync$2d$multihash$2d$sha2$2f$src$2f$sha256$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["prefix"].length + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sync$2d$multihash$2d$sha2$2f$src$2f$sha256$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["size"]);
    digest.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sync$2d$multihash$2d$sha2$2f$src$2f$sha256$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["prefix"], 0);
    digest.set((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sha256"])(payload), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sync$2d$multihash$2d$sha2$2f$src$2f$sha256$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["prefix"].length);
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sync$2d$multihash$2d$sha2$2f$src$2f$sha256$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Digest"](digest);
};
}),
"[project]/node_modules/sync-multihash-sha2/src/sha256/web.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "code",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sync$2d$multihash$2d$sha2$2f$src$2f$sha256$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["code"],
    "digest",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sync$2d$multihash$2d$sha2$2f$src$2f$sha256$2f$web$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["digest"],
    "name",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sync$2d$multihash$2d$sha2$2f$src$2f$sha256$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["name"],
    "size",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sync$2d$multihash$2d$sha2$2f$src$2f$sha256$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["size"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sync$2d$multihash$2d$sha2$2f$src$2f$sha256$2f$web$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/sync-multihash-sha2/src/sha256/web.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sync$2d$multihash$2d$sha2$2f$src$2f$sha256$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/sync-multihash-sha2/src/sha256/digest.js [app-client] (ecmascript)");
}),
"[project]/node_modules/retry/lib/retry_operation.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

function RetryOperation(timeouts, options) {
    // Compatibility for the old (timeouts, retryForever) signature
    if (typeof options === 'boolean') {
        options = {
            forever: options
        };
    }
    this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
    this._timeouts = timeouts;
    this._options = options || {};
    this._maxRetryTime = options && options.maxRetryTime || Infinity;
    this._fn = null;
    this._errors = [];
    this._attempts = 1;
    this._operationTimeout = null;
    this._operationTimeoutCb = null;
    this._timeout = null;
    this._operationStart = null;
    this._timer = null;
    if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
    }
}
module.exports = RetryOperation;
RetryOperation.prototype.reset = function() {
    this._attempts = 1;
    this._timeouts = this._originalTimeouts.slice(0);
};
RetryOperation.prototype.stop = function() {
    if (this._timeout) {
        clearTimeout(this._timeout);
    }
    if (this._timer) {
        clearTimeout(this._timer);
    }
    this._timeouts = [];
    this._cachedTimeouts = null;
};
RetryOperation.prototype.retry = function(err) {
    if (this._timeout) {
        clearTimeout(this._timeout);
    }
    if (!err) {
        return false;
    }
    var currentTime = new Date().getTime();
    if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.push(err);
        this._errors.unshift(new Error('RetryOperation timeout occurred'));
        return false;
    }
    this._errors.push(err);
    var timeout = this._timeouts.shift();
    if (timeout === undefined) {
        if (this._cachedTimeouts) {
            // retry forever, only keep last error
            this._errors.splice(0, this._errors.length - 1);
            timeout = this._cachedTimeouts.slice(-1);
        } else {
            return false;
        }
    }
    var self = this;
    this._timer = setTimeout(function() {
        self._attempts++;
        if (self._operationTimeoutCb) {
            self._timeout = setTimeout(function() {
                self._operationTimeoutCb(self._attempts);
            }, self._operationTimeout);
            if (self._options.unref) {
                self._timeout.unref();
            }
        }
        self._fn(self._attempts);
    }, timeout);
    if (this._options.unref) {
        this._timer.unref();
    }
    return true;
};
RetryOperation.prototype.attempt = function(fn, timeoutOps) {
    this._fn = fn;
    if (timeoutOps) {
        if (timeoutOps.timeout) {
            this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
            this._operationTimeoutCb = timeoutOps.cb;
        }
    }
    var self = this;
    if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
            self._operationTimeoutCb();
        }, self._operationTimeout);
    }
    this._operationStart = new Date().getTime();
    this._fn(this._attempts);
};
RetryOperation.prototype.try = function(fn) {
    console.log('Using RetryOperation.try() is deprecated');
    this.attempt(fn);
};
RetryOperation.prototype.start = function(fn) {
    console.log('Using RetryOperation.start() is deprecated');
    this.attempt(fn);
};
RetryOperation.prototype.start = RetryOperation.prototype.try;
RetryOperation.prototype.errors = function() {
    return this._errors;
};
RetryOperation.prototype.attempts = function() {
    return this._attempts;
};
RetryOperation.prototype.mainError = function() {
    if (this._errors.length === 0) {
        return null;
    }
    var counts = {};
    var mainError = null;
    var mainErrorCount = 0;
    for(var i = 0; i < this._errors.length; i++){
        var error = this._errors[i];
        var message = error.message;
        var count = (counts[message] || 0) + 1;
        counts[message] = count;
        if (count >= mainErrorCount) {
            mainError = error;
            mainErrorCount = count;
        }
    }
    return mainError;
};
}),
"[project]/node_modules/retry/lib/retry.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

var RetryOperation = __turbopack_context__.r("[project]/node_modules/retry/lib/retry_operation.js [app-client] (ecmascript)");
exports.operation = function(options) {
    var timeouts = exports.timeouts(options);
    return new RetryOperation(timeouts, {
        forever: options && (options.forever || options.retries === Infinity),
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
    });
};
exports.timeouts = function(options) {
    if (options instanceof Array) {
        return [].concat(options);
    }
    var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1000,
        maxTimeout: Infinity,
        randomize: false
    };
    for(var key in options){
        opts[key] = options[key];
    }
    if (opts.minTimeout > opts.maxTimeout) {
        throw new Error('minTimeout is greater than maxTimeout');
    }
    var timeouts = [];
    for(var i = 0; i < opts.retries; i++){
        timeouts.push(this.createTimeout(i, opts));
    }
    if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts));
    }
    // sort the array numerically ascending
    timeouts.sort(function(a, b) {
        return a - b;
    });
    return timeouts;
};
exports.createTimeout = function(attempt, opts) {
    var random = opts.randomize ? Math.random() + 1 : 1;
    var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
    timeout = Math.min(timeout, opts.maxTimeout);
    return timeout;
};
exports.wrap = function(obj, options, methods) {
    if (options instanceof Array) {
        methods = options;
        options = null;
    }
    if (!methods) {
        methods = [];
        for(var key in obj){
            if (typeof obj[key] === 'function') {
                methods.push(key);
            }
        }
    }
    for(var i = 0; i < methods.length; i++){
        var method = methods[i];
        var original = obj[method];
        obj[method] = (function retryWrapper(original) {
            var op = exports.operation(options);
            var args = Array.prototype.slice.call(arguments, 1);
            var callback = args.pop();
            args.push(function(err) {
                if (op.retry(err)) {
                    return;
                }
                if (err) {
                    arguments[0] = op.mainError();
                }
                callback.apply(this, arguments);
            });
            op.attempt(function() {
                original.apply(obj, args);
            });
        }).bind(obj, original);
        obj[method].options = options;
    }
};
}),
"[project]/node_modules/retry/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = __turbopack_context__.r("[project]/node_modules/retry/lib/retry.js [app-client] (ecmascript)");
}),
"[project]/node_modules/is-network-error/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>isNetworkError
]);
const objectToString = Object.prototype.toString;
const isError = (value)=>objectToString.call(value) === '[object Error]';
const errorMessages = new Set([
    'network error',
    'Failed to fetch',
    'NetworkError when attempting to fetch resource.',
    'The Internet connection appears to be offline.',
    'Network request failed',
    'fetch failed',
    'terminated',
    ' A network error occurred.',
    'Network connection lost'
]);
function isNetworkError(error) {
    const isValid = error && isError(error) && error.name === 'TypeError' && typeof error.message === 'string';
    if (!isValid) {
        return false;
    }
    const { message, stack } = error;
    // Safari 17+ has generic message but no stack for network errors
    if (message === 'Load failed') {
        return stack === undefined || '__sentry_captured__' in error;
    }
    // Deno network errors start with specific text
    if (message.startsWith('error sending request for url')) {
        return true;
    }
    // Standard network error messages
    return errorMessages.has(message);
}
}),
"[project]/node_modules/actor/src/task.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

// This is file is only here to allow importing type namespace
// from JS.
__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$actor$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/actor/src/lib.js [app-client] (ecmascript) <locals>");
;
}),
"[project]/node_modules/actor/src/lib.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "abort",
    ()=>abort,
    "all",
    ()=>all,
    "batch",
    ()=>batch,
    "current",
    ()=>current,
    "effect",
    ()=>effect,
    "effects",
    ()=>effects,
    "exit",
    ()=>exit,
    "fork",
    ()=>fork,
    "group",
    ()=>group,
    "isInstruction",
    ()=>isInstruction,
    "isMessage",
    ()=>isMessage,
    "join",
    ()=>join,
    "listen",
    ()=>listen,
    "loop",
    ()=>loop,
    "main",
    ()=>main,
    "none",
    ()=>none,
    "resume",
    ()=>resume,
    "send",
    ()=>send,
    "sleep",
    ()=>sleep,
    "spawn",
    ()=>spawn,
    "suspend",
    ()=>suspend,
    "tag",
    ()=>tag,
    "terminate",
    ()=>terminate,
    "then",
    ()=>then,
    "wait",
    ()=>wait
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$actor$2f$src$2f$task$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/actor/src/task.js [app-client] (ecmascript) <locals>");
;
;
const effect = function*(task) {
    const message = yield* task;
    yield* send(message);
};
function* current() {
    return yield CURRENT;
}
const suspend = function*() {
    yield SUSPEND;
};
function* sleep(duration = 0) {
    const task = yield* current();
    const id = setTimeout(enqueue, duration, task);
    try {
        yield* suspend();
    } finally{
        clearTimeout(id);
    }
}
const wait = function*(input) {
    const task = yield* current();
    if (isAsync(input)) {
        let failed = false;
        /** @type {unknown} */ let output = undefined;
        input.then((value)=>{
            failed = false;
            output = value;
            enqueue(task);
        }, (error)=>{
            failed = true;
            output = error;
            enqueue(task);
        });
        yield* suspend();
        if (failed) {
            throw output;
        } else {
            return output;
        }
    } else {
        // This may seem redundunt but it is not, by enqueuing this task we allow
        // scheduler to perform other queued tasks first. This way many race
        // conditions can be avoided when values are sometimes promises and other
        // times aren't.
        // Unlike `await` however this will resume in the same tick.
        main(wake(task));
        yield* suspend();
        return input;
    }
};
/**
 * @template T, X, M
 * @param {Task.Controller<T, X, M>} task
 * @returns {Task.Task<void, never, never>}
 */ function* wake(task) {
    enqueue(task);
}
/**
 * Checks if value value is a promise (or it's lookalike).
 *
 * @template T
 * @param {any} node
 * @returns {node is PromiseLike<T>}
 */ const isAsync = (node)=>node != null && typeof /** @type {{then?:unknown}} */ node.then === "function";
const send = function*(message) {
    yield message;
};
const listen = function*(source) {
    /** @type {Task.Fork<void, never, Tagged<Tag, T>>[]} */ const forks = [];
    for (const entry of Object.entries(source)){
        const [name, effect] = entry;
        if (effect !== NONE) {
            forks.push((yield* fork(tag(effect, name))));
        }
    }
    yield* group(forks);
};
const effects = (tasks)=>tasks.length > 0 ? batch(tasks.map(effect)) : NONE;
function* batch(effects) {
    const forks = [];
    for (const effect of effects){
        forks.push((yield* fork(effect)));
    }
    yield* group(forks);
}
const tag = (effect, tag)=>// @ts-ignore
    effect === NONE ? NONE : effect instanceof Tagger ? new Tagger([
        ...effect.tags,
        tag
    ], effect.source) : new Tagger([
        tag
    ], effect);
/**
 * @template {string} Tag
 * @template Success, Failure, Message
 *
 * @implements {Task.Task<Success, Failure, Tagged<Tag, Message>>}
 * @implements {Task.Controller<Success, Failure, Tagged<Tag, Message>>}
 */ class Tagger {
    /**
   * @param {Task.Task<Success, Failure, Message>} source
   * @param {string[]} tags
   */ constructor(tags, source){
        this.tags = tags;
        this.source = source;
        /** @type {Task.Controller<Success, Failure, Message>} */ this.controller;
    }
    /* c8 ignore next 3 */ [Symbol.iterator]() {
        if (!this.controller) {
            this.controller = this.source[Symbol.iterator]();
        }
        return this;
    }
    /**
   * @param {Task.TaskState<Success, Message>} state
   * @returns {Task.TaskState<Success, Tagged<Tag, Message>>}
   */ box(state) {
        if (state.done) {
            return state;
        } else {
            switch(state.value){
                case SUSPEND:
                case CURRENT:
                    return state;
                default:
                    {
                        // Instead of boxing result at each transform step we perform in-place
                        // mutation as we know nothing else is accessing this value.
                        const tagged = state;
                        let { value } = tagged;
                        for (const tag of this.tags){
                            value = withTag(tag, value);
                        }
                        tagged.value = value;
                        return tagged;
                    }
            }
        }
    }
    /**
   *
   * @param {Task.Instruction<Message>} instruction
   */ next(instruction) {
        return this.box(this.controller.next(instruction));
    }
    /**
   *
   * @param {Failure} error
   */ throw(error) {
        return this.box(this.controller.throw(error));
    }
    /**
   * @param {Success} value
   */ return(value) {
        return this.box(this.controller.return(value));
    }
    get [Symbol.toStringTag]() {
        return "TaggedEffect";
    }
}
const none = ()=>NONE;
const all = function*(tasks) {
    const self = yield* current();
    /** @type {(id:number) => (value:T) => void} */ const succeed = (id)=>(value)=>{
            delete forks[id];
            results[id] = value;
            count -= 1;
            if (count === 0) {
                enqueue(self);
            }
        };
    /** @type {(error:X) => void} */ const fail = (error)=>{
        for (const handle of forks){
            if (handle) {
                enqueue(abort(handle, error));
            }
        }
        enqueue(abort(self, error));
    };
    /** @type {Task.Fork<void, never>[]} */ let forks = [];
    let count = 0;
    for (const task of tasks){
        forks.push((yield* fork(then(task, succeed(count++), fail))));
    }
    const results = new Array(count);
    if (count > 0) {
        yield* suspend();
    }
    return results;
};
/**
 * @template {string} Tag
 * @template T
 * @param {Tag} tag
 * @param {Task.Message<T>} value
 */ const withTag = (tag, value)=>/** @type {Tagged<Tag, T>} */ ({
        type: tag,
        [tag]: value
    });
function* then(task, resolve, reject) {
    try {
        return resolve((yield* task));
    } catch (error) {
        return reject(error);
    }
}
// Special control instructions recognized by a scheduler.
const CURRENT = Symbol("current");
const SUSPEND = Symbol("suspend");
const isMessage = (value)=>{
    switch(value){
        case SUSPEND:
        case CURRENT:
            return false;
        default:
            return true;
    }
};
const isInstruction = (value)=>!isMessage(value);
/**
 * @template T, X, M
 * @implements {Task.TaskGroup<T, X, M>}
 */ class Group {
    /**
   * @template T, X, M
   * @param {Task.Controller<T, X, M>|Task.Fork<T, X, M>} member
   * @returns {Task.Group<T, X, M>}
   */ static of(member) {
        return /** @type {{group?:Task.TaskGroup<T, X, M>}} */ member.group || MAIN;
    }
    /**
   * @template T, X, M
   * @param {(Task.Controller<T, X, M>|Task.Fork<T, X, M>) & {group?:Task.TaskGroup<T, X, M>}} member
   * @param {Task.TaskGroup<T, X, M>} group
   */ static enqueue(member, group) {
        member.group = group;
        group.stack.active.push(member);
    }
    /**
   * @param {Task.Controller<T, X, M>} driver
   * @param {Task.Controller<T, X, M>[]} [active]
   * @param {Set<Task.Controller<T, X, M>>} [idle]
   * @param {Task.Stack<T, X, M>} [stack]
   */ constructor(driver, active = [], idle = new Set(), stack = new Stack(active, idle)){
        this.driver = driver;
        this.parent = Group.of(driver);
        this.stack = stack;
        this.id = ++ID;
    }
}
/**
 * @template T, X, M
 * @implements {Task.Main<T, X, M>}
 */ class Main {
    constructor(){
        this.status = IDLE;
        this.stack = new Stack();
        this.id = 0;
    }
}
/**
 * @template T, X, M
 */ class Stack {
    /**
   * @param {Task.Controller<T, X, M>[]} [active]
   * @param {Set<Task.Controller<T, X, M>>} [idle]
   */ constructor(active = [], idle = new Set()){
        this.active = active;
        this.idle = idle;
    }
    /**
   *
   * @param {Task.Stack<unknown, unknown, unknown>} stack
   * @returns
   */ static size({ active, idle }) {
        return active.length + idle.size;
    }
}
const main = (task)=>enqueue(task[Symbol.iterator]());
/**
 * @template T, X, M
 * @param {Task.Controller<T, X, M>} task
 */ const enqueue = (task)=>{
    let group = Group.of(task);
    group.stack.active.push(task);
    group.stack.idle.delete(task);
    // then walk up the group chain and unblock their driver tasks.
    while(group.parent){
        const { idle, active } = group.parent.stack;
        if (idle.has(group.driver)) {
            idle.delete(group.driver);
            active.push(group.driver);
        } else {
            break;
        }
        group = group.parent;
    }
    if (MAIN.status === IDLE) {
        MAIN.status = ACTIVE;
        while(true){
            try {
                for (const _message of step(MAIN)){}
                MAIN.status = IDLE;
                break;
            } catch (_error) {
                // Top level task may crash and throw an error, but given this is a main
                // group we do not want to interupt other unrelated tasks, which is why
                // we discard the error and the task that caused it.
                MAIN.stack.active.shift();
            }
        }
    }
};
const resume = (task)=>enqueue(task);
/**
 * @template T, X, M
 * @param {Task.Group<T, X, M>} group
 */ const step = function*(group) {
    const { active } = group.stack;
    let task = active[0];
    group.stack.idle.delete(task);
    while(task){
        /** @type {Task.TaskState<T, M>} */ let state = INIT;
        // Keep processing insturctions until task is done, it send suspend request
        // or it's has been removed from the active queue.
        //  Group changes require extra care so please make sure to understand
        // the detail here. It occurs when spawned task(s) are joined into a group
        // which will change the task driver, that is when `task === active[0]` will
        // became false and need to to drop the task immediately otherwise race
        // condition will occur due to task been  driven by multiple concurrent
        // schedulers.
        loop: while(!state.done && task === active[0]){
            const instruction = state.value;
            switch(instruction){
                // if task is suspended we add it to the idle list and break the loop
                // to move to a next task.
                case SUSPEND:
                    group.stack.idle.add(task);
                    break loop;
                // if task requested a context (which is usually to suspend itself)
                // pass back a task reference and continue.
                case CURRENT:
                    state = task.next(task);
                    break;
                default:
                    // otherwise task sent a message which we yield to the driver and
                    // continue
                    state = task.next((yield instruction));
                    break;
            }
        }
        // If task is complete, or got suspended we move to a next task
        active.shift();
        task = active[0];
        group.stack.idle.delete(task);
    }
};
function* spawn(task) {
    main(task);
}
const fork = (task, options)=>new Fork(task, options);
const exit = (handle, value)=>conclude(handle, {
        ok: true,
        value
    });
const terminate = (handle)=>conclude(handle, {
        ok: true,
        value: undefined
    });
const abort = (handle, error)=>conclude(handle, {
        ok: false,
        error
    });
/**
 * Aborts given task with an given error.
 *
 * @template T, M, X
 * @param {Task.Controller<T, X, M>} handle
 * @param {Task.Result<T, X>} result
 * @returns {Task.Task<void, never> & Task.Controller<void, never>}
 */ function* conclude(handle, result) {
    try {
        const task = handle;
        const state = result.ok ? task.return(result.value) : task.throw(result.error);
        if (!state.done) {
            if (state.value === SUSPEND) {
                const { idle } = Group.of(task).stack;
                idle.add(task);
            } else {
                enqueue(task);
            }
        }
    } catch (error) {}
}
function* group(forks) {
    // Abort eraly if there'se no work todo.
    if (forks.length === 0) return;
    const self = yield* current();
    /** @type {Task.TaskGroup<T, X, M>} */ const group = new Group(self);
    /** @type {Task.Failure<X>|null} */ let failure = null;
    for (const fork of forks){
        const { result } = fork;
        if (result) {
            if (!result.ok && !failure) {
                failure = result;
            }
            continue;
        }
        move(fork, group);
    }
    // Keep work looping until there is nom more work to be done
    try {
        if (failure) {
            throw failure.error;
        }
        while(true){
            yield* step(group);
            if (Stack.size(group.stack) > 0) {
                yield* suspend();
            } else {
                break;
            }
        }
    } catch (error) {
        for (const task of group.stack.active){
            yield* abort(task, error);
        }
        for (const task of group.stack.idle){
            yield* abort(task, error);
            enqueue(task);
        }
        throw error;
    }
}
/**
 * @template T, X, M
 * @param {Task.Fork<T, X, M>} fork
 * @param {Task.TaskGroup<T, X, M>} group
 */ const move = (fork, group)=>{
    const from = Group.of(fork);
    if (from !== group) {
        const { active, idle } = from.stack;
        const target = group.stack;
        fork.group = group;
        // If it is idle just move from one group to the other
        // and update the group task thinks it belongs to.
        if (idle.has(fork)) {
            idle.delete(fork);
            target.idle.add(fork);
        } else {
            const index = active.indexOf(fork);
            // If task is in the job queue, we move it to a target job queue. Moving
            // top task in the queue requires extra care so it does not end up
            // processed by two groups which would lead to race. For that reason
            // `step` loop checks for group changes on each turn.
            if (index >= 0) {
                active.splice(index, 1);
                target.active.push(fork);
            }
        // otherwise task is complete
        }
    }
};
function* join(fork) {
    // If fork is still idle activate it.
    if (fork.status === IDLE) {
        yield* fork;
    }
    if (!fork.result) {
        yield* group([
            fork
        ]);
    }
    const result = fork.result;
    if (result.ok) {
        return result.value;
    } else {
        throw result.error;
    }
}
/**
 * @template T, X
 * @implements {Task.Future<T, X>}
 */ class Future {
    /**
   * @param {Task.StateHandler<T, X>} handler
   */ constructor(handler){
        this.handler = handler;
        /**
     * @abstract
     * @type {Task.Result<T, X>|void}
     */ this.result;
    }
    /**
   * @type {Promise<T>}
   */ get promise() {
        const { result } = this;
        const promise = result == null ? new Promise((succeed, fail)=>{
            this.handler.onsuccess = succeed;
            this.handler.onfailure = fail;
        }) : result.ok ? Promise.resolve(result.value) : Promise.reject(result.error);
        Object.defineProperty(this, "promise", {
            value: promise
        });
        return promise;
    }
    /**
   * @template U, [E=never]
   * @param {((value:T) => U | PromiseLike<U>)|undefined|null} [onresolve]
   * @param {((error:X) => E|PromiseLike<E>)|undefined|null} [onreject]
   * @returns {Promise<U|E>}
   */ then(onresolve, onreject) {
        return this.activate().promise.then(onresolve, onreject);
    }
    /**
   * @template [U=never]
   * @param {(error:X) => U} onreject
   */ catch(onreject) {
        return this.activate().promise.catch(onreject);
    }
    /**
   * @param {() => void} onfinally
   * @returns {Task.Future<T, X>}
   */ finally(onfinally) {
        return this.activate().promise.finally(onfinally);
    }
    /**
   * @abstract
   */ /* c8 ignore next 3 */ activate() {
        return this;
    }
}
/**
 * @template T, X, M
 * @implements {Task.Fork<T, X, M>}
 * @implements {Task.Controller<T, X, M>}
 * @implements {Task.Task<Task.Fork<T, X, M>, never>}
 * @implements {Task.Future<T, X>}
 * @extends {Future<T, X>}
 */ class Fork extends Future {
    /**
   * @param {Task.Task<T, X, M>} task
   * @param {Task.ForkOptions} [options]
   * @param {Task.StateHandler<T, X>} [handler]
   * @param {Task.TaskState<T, M>} [state]
   */ constructor(task, options = BLANK, handler = {}, state = INIT){
        super(handler);
        this.id = ++ID;
        this.name = options.name || "";
        /** @type {Task.Task<T, X, M>} */ this.task = task;
        this.state = state;
        this.status = IDLE;
        /** @type {Task.Result<T, X>} */ this.result;
        this.handler = handler;
        /** @type {Task.Controller<T, X, M>} */ this.controller;
    }
    *resume() {
        resume(this);
    }
    /**
   * @returns {Task.Task<T, X, M>}
   */ join() {
        return join(this);
    }
    /**
   * @param {X} error
   */ abort(error) {
        return abort(this, error);
    }
    /**
   * @param {T} value
   */ exit(value) {
        return exit(this, value);
    }
    get [Symbol.toStringTag]() {
        return "Fork";
    }
    /**
   * @returns {Task.Controller<Task.Fork<T, X, M>, never, never>}
   */ *[Symbol.iterator]() {
        return this.activate();
    }
    activate() {
        this.controller = this.task[Symbol.iterator]();
        this.status = ACTIVE;
        enqueue(this);
        return this;
    }
    /**
   * @private
   * @param {any} error
   * @returns {never}
   */ panic(error) {
        this.result = {
            ok: false,
            error
        };
        this.status = FINISHED;
        const { handler } = this;
        if (handler.onfailure) {
            handler.onfailure(error);
        }
        throw error;
    }
    /**
   * @private
   * @param {Task.TaskState<T, M>} state
   */ step(state) {
        this.state = state;
        if (state.done) {
            this.result = {
                ok: true,
                value: state.value
            };
            this.status = FINISHED;
            const { handler } = this;
            if (handler.onsuccess) {
                handler.onsuccess(state.value);
            }
        }
        return state;
    }
    /**
   * @param {unknown} value
   */ next(value) {
        try {
            return this.step(this.controller.next(value));
        } catch (error) {
            return this.panic(error);
        }
    }
    /**
   * @param {T} value
   */ return(value) {
        try {
            return this.step(this.controller.return(value));
        } catch (error) {
            return this.panic(error);
        }
    }
    /**
   * @param {X} error
   */ throw(error) {
        try {
            return this.step(this.controller.throw(error));
        } catch (error) {
            return this.panic(error);
        }
    }
}
const loop = function*(init, next) {
    /** @type {Task.Controller<void, never, M>} */ const controller = yield* current();
    const group = new Group(controller);
    Group.enqueue(init[Symbol.iterator](), group);
    while(true){
        for (const message of step(group)){
            Group.enqueue(next(message)[Symbol.iterator](), group);
        }
        if (Stack.size(group.stack) > 0) {
            yield* suspend();
        } else {
            break;
        }
    }
};
let ID = 0;
/** @type {Task.Status} */ const IDLE = "idle";
const ACTIVE = "active";
const FINISHED = "finished";
/** @type {Task.TaskState<any, any>} */ const INIT = {
    done: false,
    value: CURRENT
};
const BLANK = {};
/** @type {Task.Effect<never>} */ const NONE = function* none() {}();
/** @type {Task.Main<any, any, any>} */ const MAIN = new Main();
}),
"[project]/node_modules/@perma/map/src/api.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
;
}),
"[project]/node_modules/@perma/map/src/bitfield/api.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
;
}),
"[project]/node_modules/@perma/map/src/bitfield/Uint32.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "and",
    ()=>and,
    "bitCount",
    ()=>bitCount,
    "empty",
    ()=>empty,
    "from",
    ()=>from,
    "fromBytes",
    ()=>fromBytes,
    "get",
    ()=>get,
    "or",
    ()=>or,
    "popcount",
    ()=>popcount,
    "set",
    ()=>set,
    "size",
    ()=>size,
    "toBytes",
    ()=>toBytes,
    "unset",
    ()=>unset
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/bitfield/api.js [app-client] (ecmascript)");
;
;
const empty = (size = 32)=>{
    // We could support < 32, but it seems impractical and would negatively affect
    // performance as we would have to do extra bound checks.
    if (size !== 32) {
        throw new Error(`Uint32 BitField does not support size: ${size}`);
    }
    return 0;
};
const from = (bits, size)=>{
    let bitfield = empty(size);
    for (const bit of bits){
        bitfield = set(bitfield, bit);
    }
    return bitfield;
};
const size = (_bitField)=>32;
/**
 * Reads out 5 bits at the given bit offset.
 *
 * @param {API.Uint32} bitField - Bitfield in Uint32 representation.
 * @param {API.Uint32} index - Index with-in `bitField` to read bits from.
 * @returns {API.Uint32}
 */ const mask = (bitField, index)=>bitField >>> index & 0b11111;
/**
 * Creates mask that can be used to check a bit in nodes bitmap for the give
 * key (hash) at given depth.
 *
 * @param {API.Uint32} bitField - Key hash as 32 bit integer.
 * @param {API.Uint32} index - Index with-in the 32bit bitfield
 */ const offset = (bitField, index)=>1 << mask(bitField, index);
const popcount = (bitField, index = 31)=>bitCount(bitField & offset(index, 0) - 1);
const set = (bitField, index)=>bitField | 1 << index;
const unset = (bitField, index)=>bitField & (0xff ^ 1 << index);
const get = (bitField, index)=>(bitField >> index & 0x1) !== 0;
const bitCount = (bitField)=>{
    const n1 = bitField - (bitField >> 1 & 0x55555555);
    const n2 = (n1 & 0x33333333) + (n1 >> 2 & 0x33333333);
    const n3 = (n2 + (n2 >> 4) & 0xf0f0f0f) * 0x1010101;
    return n3 >> 24;
};
const and = (left, right)=>left & right;
const or = (left, right)=>left | right;
const toBytes = (bitField)=>Uint8Array.of(bitField >> 24 & 0b1111_1111, bitField >> 16 & 0b1111_1111, bitField >> 8 & 0b1111_1111, bitField & 0b1111_1111);
const fromBytes = (bytes)=>{
    if (bytes.length !== 4) {
        throw new Error(`Expected 4 bytes instead got ${bytes.length}`);
    }
    return (bytes[0] << 24) + (bytes[1] << 16) + (bytes[2] << 8) + bytes[3];
};
}),
"[project]/node_modules/@perma/map/src/bitfield/Uint32.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "API",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    "and",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["and"],
    "bitCount",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bitCount"],
    "empty",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["empty"],
    "from",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["from"],
    "fromBytes",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromBytes"],
    "get",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["get"],
    "or",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["or"],
    "popcount",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["popcount"],
    "set",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["set"],
    "size",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["size"],
    "toBytes",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["toBytes"],
    "unset",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["unset"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/bitfield/Uint32.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/bitfield/api.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@perma/map/src/path/api.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
;
}),
"[project]/node_modules/@perma/map/src/path/Uint32.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "configure",
    ()=>configure,
    "hash32",
    ()=>hash32
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$path$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/path/api.js [app-client] (ecmascript)");
// @ts-expect-error - has no types
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$murmurhash3js$2d$revisited$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/murmurhash3js-revisited/index.js [app-client] (ecmascript)");
;
;
const utf8 = new TextEncoder();
const hash32 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$murmurhash3js$2d$revisited$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].x64.hash126;
const configure = ({ bitWidth = 5, hash = hash32 })=>{
    const hashSize = 4;
    if (bitWidth > hashSize * 8) {
        throw new RangeError(`Can not use bitWidth ${bitWidth} which exceeds the hashSize ${hashSize}`);
    }
    if (hashSize * 8 > 32) {
        throw new RangeError(`Can not use hashSize ${hashSize} as it can not be encoded in Uint32`);
    }
    // Mask for reading `bitWidth` number of bits from the end.
    const mask = 0xffffffff >>> 32 - bitWidth;
    /**
   * Determines bit position for the path entry at the given `depth`.
   * ```js
   * const key = hash("result") // 0b00011010010110010101111100110010
   * // Which is following path (in reverse as we read from the right)
   * // 10010/11001/10111/10010/00101/01101/00000 -> [ 18, 25, 23, 18, 5, 13, 0 ]
   * at(key, 0) // 0b10010 -> 18
   * at(key, 1) // 0b11001 -> 25
   * at(key, 2) // 0b10111 -> 23
   * at(key, 3) // 0b10010 -> 18
   * at(key, 4) // 0b00101 -> 5
   * at(key, 5) // 0b01101 -> 13
   * at(key, 6) // 0b00000 -> 0
   * ```
   *
   * @param {API.Uint32} path
   * @param {number} depth
   */ const at = (path, depth)=>path >>> depth * bitWidth & mask;
    /**
   * @param {string} key
   * @returns {API.Uint32}
   */ const from = (key)=>hash(utf8.encode(key));
    return {
        at,
        from,
        size: Math.ceil(hashSize * 8 / bitWidth)
    };
};
}),
"[project]/node_modules/@perma/map/src/node.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "associate",
    ()=>associate,
    "associateCollision",
    ()=>associateCollision,
    "copyAndSetChild",
    ()=>copyAndSetChild,
    "create",
    ()=>create,
    "delete",
    ()=>remove,
    "dissociate",
    ()=>dissociate,
    "dissociateCollision",
    ()=>dissociateCollision,
    "entries",
    ()=>entries,
    "fork",
    ()=>fork,
    "forkAndSet",
    ()=>forkAndSet,
    "forkCollision",
    ()=>forkCollision,
    "get",
    ()=>get,
    "inlineChild",
    ()=>inlineChild,
    "keyAt",
    ()=>keyAt,
    "keyPosition",
    ()=>keyPosition,
    "keys",
    ()=>keys,
    "lookup",
    ()=>lookup,
    "lookupCollision",
    ()=>lookupCollision,
    "mergeTwoLeaves",
    ()=>mergeTwoLeaves,
    "migrateLeafToBranch",
    ()=>migrateLeafToBranch,
    "resolveNode",
    ()=>resolveNode,
    "set",
    ()=>set,
    "valueAt",
    ()=>valueAt,
    "valuePosition",
    ()=>valuePosition,
    "values",
    ()=>values
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/api.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/bitfield/Uint32.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/bitfield/Uint32.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$path$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/path/Uint32.js [app-client] (ecmascript)");
;
;
;
;
;
/**
 * @template T
 * @template {string} K
 * @template {API.Config} C
 * @implements {API.BitmapIndexedNode<T, K, C>}
 */ class BitmapIndexedNode {
    /**
   * @param {API.Edit|null} edit
   * @param {ReturnType<C['BitField']['empty']>} datamap
   * @param {ReturnType<C['BitField']['empty']>} nodemap
   * @param {API.Children<T, K, C>} children
   * @param {C} config
   */ constructor(edit, datamap, nodemap, children, config){
        this.edit = edit;
        this.config = config;
        this.datamap = datamap;
        this.nodemap = nodemap;
        this.children = children;
    }
    get nodeArity() {
        return this.config.BitField.popcount(this.nodemap);
    }
    get dataArity() {
        return this.config.BitField.popcount(this.datamap);
    }
    /**
   * @returns {API.BitmapIndexedNode<T, K, C>}
   */ /* c8 ignore next 3 */ empty() {
        return create(this.config);
    }
    /**
   * @template X
   * @param {API.Uint32} depth
   * @param {ReturnType<C['Path']['from']>} path
   * @param {K} key
   * @param {X} notFound
   * @returns {T|X}
   */ lookup(depth, path, key, notFound) {
        return lookup(this, depth, path, key, notFound);
    }
    /**
   * @template {string} R
   * @param {API.Edit|null} edit
   * @param {API.Uint32} depth
   * @param {ReturnType<C['Path']['from']>} path
   * @param {K|R} key
   * @param {T} value
   * @param {{value:boolean}} addedLeaf
   * @returns {API.BitmapIndexedNode<T, K | R, C>}
   */ associate(edit, depth, path, key, value, addedLeaf) {
        return associate(this, edit, depth, path, key, value, addedLeaf);
    }
    /**
   * @param {API.Edit|null} edit
   * @param {API.Uint32} depth
   * @param {ReturnType<C['Path']['from']>} path
   * @param {K} key
   * @param {{value:boolean}} removedLeaf
   * @returns {API.BitmapIndexedNode<T, K, C>}
   */ dissociate(edit, depth, path, key, removedLeaf) {
        return dissociate(this, edit, depth, path, key, removedLeaf);
    }
    /**
   * @param {API.Edit|null} edit
   * @returns {API.BitmapIndexedNode<T, K, C>}
   */ fork(edit = null) {
        return fork(this, edit);
    }
    /**
   * @returns {IterableIterator<[K, T]>}
   */ entries() {
        return entries(this);
    }
    /**
   * @returns {IterableIterator<K>}
   */ keys() {
        return keys(this);
    }
    /**
   * @returns {IterableIterator<T>}
   */ values() {
        return values(this);
    }
}
/**
 * @template T
 * @template {string} K
 * @template {API.Config} C
 * @implements {API.HashCollisionNode<T, K, C>}
 */ class HashCollisionNode {
    /**
   * @param {API.Edit|null} edit
   * @param {number} count
   * @param {API.CollisionEntries<T, K>} children
   * @param {C} config
   */ /* c8 ignore next 12 */ constructor(edit, count, children, config){
        this.edit = edit;
        this.count = count;
        this.children = children;
        this.config = config;
    }
    get nodeArity() {
        return 0;
    }
    get dataArity() {
        return this.count;
    }
    /**
   * @template X
   * @param {API.Uint32} _shift
   * @param {unknown} _path
   * @param {K} key
   * @param {X} notFound
   * @returns {T|X}
   */ /* c8 ignore next 3 */ lookup(_shift, _path, key, notFound) {
        return lookupCollision(this, key, notFound);
    }
    /**
   * @template {string} R
   * @param {API.Edit|null} edit
   * @param {API.Uint32} _shift
   * @param {ReturnType<C['Path']['from']>} path
   * @param {K|R} key
   * @param {T} value
   * @param {{value:boolean}} addedLeaf
   * @returns {API.HashCollisionNode<T, K | R, C>}
   */ /* c8 ignore next 3 */ associate(edit, _shift, path, key, value, addedLeaf) {
        return associateCollision(this, edit, path, key, value, addedLeaf);
    }
    /**
   * @param {API.Edit|null} edit
   * @param {API.Uint32} _shift
   * @param {ReturnType<C['Path']['from']>} path
   * @param {K} key
   * @param {{value:boolean}} removedLeaf
   * @returns {API.Node<T, K, C>}
   */ /* c8 ignore next 3 */ dissociate(edit, _shift, path, key, removedLeaf) {
        return dissociateCollision(this, edit, path, key, removedLeaf);
    }
    /**
   * @param {API.Edit|null} edit
   * @returns {this}
   */ /* c8 ignore next 3 */ fork(edit = null) {
        return forkCollision(this, edit);
    }
    /**
   * @returns {IterableIterator<[K, T]>}
   */ /* c8 ignore next 3 */ entries() {
        return entries(this);
    }
    /**
   * @returns {IterableIterator<K>}
   */ /* c8 ignore next 3 */ keys() {
        return keys(this);
    }
    /**
   * @returns {IterableIterator<T>}
   */ /* c8 ignore next 3 */ values() {
        return values(this);
    }
}
const lookupCollision = (node, name, notFound)=>{
    const { children: entries, count } = node;
    // find where entry with this name belongs
    const n = findHashCollisionNodeIndex(entries, count, name);
    // if entry name at this index matches given name return the value otherwise
    // return `notFound` as we have no such entry.
    return entries[n] === name ? entries[n + 1] : notFound;
};
const associateCollision = (node, edit, key, name, value, addedLeaf)=>{
    const { children, count } = node;
    const index = findHashCollisionNodeIndex(children, count, name);
    // If entry at this index has a different name we fork the node and
    // add a new entry.
    if (children[index] !== name) {
        const newNode = node.fork(edit);
        addedLeaf.value = true;
        newNode.count += 1;
        newNode.children.splice(index, key, value);
        return newNode;
    } else if (children[index + 1] !== value) {
        const newNode = node.fork(edit);
        newNode.children[index + 1] = value;
        return newNode;
    } else {
        return node;
    }
};
const dissociateCollision = (node, edit, hash, name, removedLeaf)=>{
    const { children: entries, count, config } = node;
    const index = findHashCollisionNodeIndex(entries, count, name);
    // If there is no entry with a the given name this is noop so we just
    // return back this node.
    if (entries[index] !== name) {
        return node;
    } else {
        removedLeaf.value = true;
        // If conflict contained only two entries removing one of them would
        // leave us with no conflict which is why we create a new node with a
        // an entry other than one that would correspond provided name
        if (count === 2) {
            const offset = index === 0 ? 2 : 0;
            return associate(create(config), edit, 0, hash, entries[offset], entries[offset + 1], removedLeaf);
        } else {
            const newNode = node.fork(edit);
            newNode.children.splice(index, 2);
            newNode.count -= 1;
            return newNode;
        }
    }
};
const forkCollision = (node, edit = null)=>{
    if (canEdit(node.edit, edit)) {
        return node;
    } else {
        return new HashCollisionNode(edit, node.count, node.children.slice(), node.config);
    }
};
/**
 * Finds the index inside collision entries where given `key` belongs, which is
 * index where `key <= entries[index]` is `true`. If no index satisfies this
 * constraint index will be `entries.length` indicating that key belongs in the
 * last position.
 *
 * @template T
 * @template {string} K
 * @param {API.CollisionEntries<T, K>} entries
 * @param {number} count
 * @param {K} key
 */ /* c8 ignore next 8 */ const findHashCollisionNodeIndex = (entries, count, key)=>{
    let index = 0;
    // increase index until we find a index where key <= entries[index]
    while(index < count && entries[index] > key){
        index += 2;
    }
    return index;
};
const defaultConfig = {
    bitWidth: 32,
    BitField: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    Path: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$path$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__
};
const create = (config, edit = null)=>new BitmapIndexedNode(edit, config.BitField.empty(Math.pow(2, config.bitWidth)), config.BitField.empty(Math.pow(2, config.bitWidth)), [], config);
const get = (node, key, notFound)=>lookup(node, 0, node.config.Path.from(key), key, notFound);
const lookup = (node, depth, path, key, notFound)=>{
    const { datamap, nodemap, config } = node;
    const { Path, BitField } = config;
    const offset = Path.at(path, depth);
    // If bit is set in the data bitmap we have some key, value under the
    // matching hash segment.
    if (BitField.get(datamap, offset)) {
        const index = BitField.popcount(datamap, offset);
        // If key matches actual key in the map we found the the value
        // otherwise we did not.
        if (keyAt(node, index) === key) {
            return valueAt(node, index);
        } else {
            return notFound;
        }
    } else if (BitField.get(nodemap, offset)) {
        // Resolve node and continue lookup within it.
        const child = resolveNode(node, offset);
        return child.lookup(depth + 1, path, key, notFound);
    } else {
        return notFound;
    }
};
const set = (node, edit, key, value, addedLeaf)=>associate(node, edit, 0, node.config.Path.from(key), key, value, addedLeaf);
const associate = (node, edit, depth, path, key, value, addedLeaf)=>{
    const { datamap, nodemap, config } = node;
    const { Path, BitField } = config;
    const offset = Path.at(path, depth);
    // If bit is set in the data bitmap we have some key, value under the
    // matching hash segment.
    if (BitField.get(datamap, offset)) {
        const index = BitField.popcount(datamap, offset);
        const found = keyAt(node, index);
        // If we have entry with given name and value is the same return node
        // as is, otherwise fork node and set the value.
        if (key === found) {
            return valueAt(node, index) === value ? node : forkAndSet(node, edit, index, value);
        } else {
            const branch = mergeTwoLeaves(config, edit, depth + 1, Path.from(found), found, valueAt(node, index), path, key, value);
            addedLeaf.value = true;
            return migrateLeafToBranch(node, edit, offset, branch);
        }
    } else if (BitField.get(nodemap, offset)) {
        const child = resolveNode(node, offset);
        const newChild = child.associate(edit, depth + 1, path, key, value, addedLeaf);
        if (child === newChild) {
            return node;
        } else {
            return copyAndSetChild(node, edit, offset, newChild);
        }
    } else {
        const index = BitField.popcount(datamap, offset);
        addedLeaf.value = true;
        /** @type {API.BitmapIndexedNode<T, K|R, C>} */ const newNode = node.fork(edit);
        // Capture new entry in the data bitmap
        newNode.datamap = BitField.set(datamap, offset);
        newNode.children.splice(keyPosition(index), 0, key, value);
        return newNode;
    }
};
/**
 * @template T
 * @template {string} K
 * @template {API.Config} C
 * @param {API.BitmapIndexedNode<T, K, C>} node
 * @param {API.Edit|null} edit
 * @param {K} key
 * @param {{ value: boolean }} removedLeaf
 * @returns {API.BitmapIndexedNode<T, K, C>}
 */ const remove = (node, edit, key, removedLeaf)=>dissociate(node, edit, 0, node.config.Path.from(key), key, removedLeaf);
;
const dissociate = (source, edit, depth, path, key, removedLeaf)=>{
    const { datamap, nodemap, config } = source;
    const { BitField, Path } = config;
    const offset = Path.at(path, depth);
    // If bit is set in the data bitmap we have an entry under the
    // matching hash segment.
    if (BitField.get(datamap, offset)) {
        const index = BitField.popcount(datamap, offset);
        // If key at a given index matches given `name` we fork a node and remove
        // the entry
        if (key === keyAt(source, index)) {
            removedLeaf.value = true;
            const node = fork(source, edit);
            // Update the bitmap
            node.datamap = BitField.unset(source.datamap, offset);
            // remove the child
            node.children.splice(keyPosition(index), 2);
            return node;
        } else {
            return source;
        }
    } else if (BitField.get(nodemap, offset)) {
        const node = resolveNode(source, offset);
        const child = node.dissociate(edit, depth + 1, path, key, removedLeaf);
        // if child has a single element we need to canonicalize
        if (hasSingleLeaf(child)) {
            // if source has a single child, we collapse and return the child
            // otherwise we inline the child.
            return hasSingleNode(source) ? child : inlineChild(source, edit, offset, child);
        } else if (node === child) {
            return source;
        } else {
            return copyAndSetChild(source, edit, offset, child);
        }
    } else {
        return source;
    }
};
const entries = function*({ children }) {
    let offset = 0;
    const count = children.length;
    while(offset < count){
        const key = children[offset];
        if (typeof key === "string") {
            offset += 1;
            const value = children[offset];
            yield [
                key,
                value
            ];
            offset += 1;
        } else {
            break;
        }
    }
    while(offset < count){
        const node = children[offset];
        yield* node.entries();
        offset += 1;
    }
};
const fork = (node, edit)=>{
    if (canEdit(node.edit, edit)) {
        return node;
    } else {
        const newNode = new BitmapIndexedNode(edit, node.datamap, node.nodemap, node.children.slice(), node.config);
        return newNode;
    }
};
const keys = function*({ children }) {
    let offset = 0;
    const count = children.length;
    while(offset < count){
        const key = children[offset];
        if (typeof key === "string") {
            yield key;
            offset += 2;
        } else {
            break;
        }
    }
    while(offset < count){
        const node = children[offset];
        yield* node.keys();
        offset += 1;
    }
};
const values = function*({ children }) {
    let offset = 0;
    const count = children.length;
    while(offset < count){
        const key = children[offset];
        if (typeof key === "string") {
            offset += 1;
            yield children[offset];
            offset += 1;
        } else {
            break;
        }
    }
    while(offset < count){
        const node = children[offset];
        yield* node.values();
        offset += 1;
    }
};
const forkAndSet = (node, edit, offset, value)=>{
    const newNode = node.fork(edit);
    newNode.children[valuePosition(offset)] = value;
    return newNode;
};
const inlineChild = (source, edit, offset, child)=>{
    const { datamap, nodemap, config } = source;
    const { BitField } = config;
    const node = fork(source, edit);
    // remove the node that we are inlining
    node.children.splice(nodePosition(source, offset), 1);
    // add key-value pair where it wolud fall
    node.children.splice(keyPosition(BitField.popcount(datamap, offset)), 0, child.children[0], child.children[1]);
    node.datamap = BitField.set(datamap, offset);
    node.nodemap = BitField.unset(nodemap, offset);
    return node;
};
const copyAndSetChild = (node, edit, offset, child)=>{
    const newNode = fork(node, edit);
    newNode.children[nodePosition(node, offset)] = child;
    return newNode;
};
const migrateLeafToBranch = (source, edit, offset, branch)=>{
    const { nodemap, datamap, config } = source;
    const { BitField } = config;
    const index = BitField.popcount(datamap, offset);
    // Previous id corresponds to the key position
    const oldId = keyPosition(index);
    const newId = nodePosition(source, offset);
    const node = fork(source, edit);
    // remove an old leaf
    node.datamap = BitField.unset(datamap, offset);
    node.children.splice(oldId, 2);
    // add a new branch
    node.nodemap = BitField.set(nodemap, offset);
    node.children.splice(newId - 1, 0, branch);
    return node;
};
const mergeTwoLeaves = (config, edit, depth, oldPath, oldKey, oldValue, newPath, newKey, newValue)=>{
    const { BitField, Path } = config;
    // If we have reached end of the path we can no longer create another
    // `BitmapIndexedNode`, instead we create a node containing (hash) colliding
    // entries
    /* c8 ignore next 7 */ if (Path.size < depth) {
        return new HashCollisionNode(edit, 2, [
            oldKey,
            oldValue,
            newKey,
            newValue
        ], config);
    } else {
        const oldOffset = Path.at(oldPath, depth);
        const newOffset = Path.at(newPath, depth);
        // If offsets still match create another intermediery node and merge these
        // two nodes at next depth level.
        if (oldOffset === newOffset) {
            return new BitmapIndexedNode(edit, BitField.empty(Math.pow(2, config.bitWidth)), BitField.from([
                oldOffset
            ], Math.pow(2, config.bitWidth)), [
                mergeTwoLeaves(config, edit, depth + 1, oldPath, oldKey, oldValue, newPath, newKey, newValue)
            ], config);
        } else {
            return new BitmapIndexedNode(edit, BitField.from([
                oldOffset,
                newOffset
            ], Math.pow(2, config.bitWidth)), BitField.empty(Math.pow(2, config.bitWidth)), // We insert child with a lower index first so that we can derive it's
            // index on access via popcount
            oldOffset < newOffset ? [
                oldKey,
                oldValue,
                newKey,
                newValue
            ] : [
                newKey,
                newValue,
                oldKey,
                oldValue
            ], config);
        }
    }
};
const keyAt = ({ children }, index)=>children[keyPosition(index)];
const keyPosition = (index)=>index * 2;
const valueAt = ({ children }, index)=>children[valuePosition(index)];
const valuePosition = (index)=>index * 2 + 1;
const resolveNode = (node, offset)=>node.children[nodePosition(node, offset)];
/**
 * @template T
 * @template {string} K
 * @template {API.Config} C
 * @param {API.BitmapIndexedNode<T, K, C>} node
 * @param {number} offset
 */ const nodePosition = ({ children, nodemap, config }, offset)=>children.length - 1 - config.BitField.popcount(nodemap, offset);
/**
 * @param {API.Edit|null} owner
 * @param {API.Edit|null} editor
 */ const canEdit = (owner, editor)=>owner != null && owner === editor;
/**
 * Returns `true` if node has a single entry. It also refines type to
 * `BitmapIndexedNode` because `HashCollisionNode` is normalized to
 * `BitmapIndexedNode` when it contains only a single entry.
 *
 * @template T
 * @template {string} K
 * @template {API.Config} C
 * @param {API.Node<T, K, C>} node
 * @returns {node is API.BitmapIndexedNode<T, K, C>}
 */ const hasSingleLeaf = (node)=>node.nodeArity === 0 && node.dataArity === 1;
/**
 * Returns `true` if node has a single childe node and 0 child leaves.
 *
 * @template T
 * @template {string} K
 * @template {API.Config} C
 * @param {API.BitmapIndexedNode<T, K, C>} node
 * @returns {node is API.BitmapIndexedNode<T, K, C>}
 */ const hasSingleNode = ({ config: { BitField }, datamap, nodemap })=>BitField.popcount(datamap) === 0 && BitField.popcount(nodemap) === 1;
}),
"[project]/node_modules/@perma/map/src/path/Uint8Array.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "configure",
    ()=>configure,
    "hash64",
    ()=>hash64,
    "toInt",
    ()=>toInt
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$path$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/path/api.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$murmur3$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/murmur3/src/index.js [app-client] (ecmascript)");
;
const utf8 = new TextEncoder();
;
const hash64 = (bytes)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$murmur3$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["murmur364"].encode(bytes);
const configure = ({ bitWidth = 8, hash = hash64 } = {})=>{
    const hashSize = hash(new Uint8Array()).byteLength;
    /**
   * @param {Uint8Array} path
   * @param {number} depth
   * @returns {API.Uint32}
   */ const at = (path, depth)=>{
        const offset = depth * bitWidth;
        if (offset > hashSize) {
            throw new RangeError(`Out of bounds`);
        }
        return toInt(path, offset, bitWidth);
    };
    /**
   * @param {string} key
   * @returns {Uint8Array}
   */ const from = (key)=>hash(utf8.encode(key));
    return {
        from,
        at,
        size: Math.ceil(hashSize * 8 / bitWidth)
    };
};
const toInt = (bytes, offset, count)=>{
    let byteOffset = offset / 8 | 0;
    let bitOffset = offset % 8;
    let desired = count;
    let bits = 0;
    while(desired > 0 && byteOffset < bytes.byteLength){
        const byte = bytes[byteOffset];
        const available = 8 - bitOffset;
        const taking = available < desired ? available : desired;
        const bitsLeft = 8 - bitOffset - taking;
        // mask to turn of bits before bitOffset
        const mask = 0xff >> bitOffset;
        // turn off offset bits and shift to drop remaining bit on the right
        const value = (mask & byte) >> bitsLeft;
        bits = (bits << taking) + value;
        desired -= taking;
        byteOffset++;
        bitOffset = 0;
    }
    return bits;
};
}),
"[project]/node_modules/@perma/map/src/bitfield/Uint8Array.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "and",
    ()=>and,
    "empty",
    ()=>empty,
    "from",
    ()=>from,
    "fromBytes",
    ()=>fromBytes,
    "get",
    ()=>get,
    "or",
    ()=>or,
    "popcount",
    ()=>popcount,
    "set",
    ()=>set,
    "size",
    ()=>size,
    "toBytes",
    ()=>toBytes,
    "unset",
    ()=>unset
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/bitfield/Uint32.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/bitfield/api.js [app-client] (ecmascript)");
;
;
const empty = (size = 256)=>{
    if (size % 8 !== 0) {
        throw new Error(`Must be multiple of 8`);
    }
    return new Uint8Array(size / 8);
};
const from = (bits, size)=>{
    let bitfield = empty(size);
    for (const index of bits){
        const { byte, byteOffset, bitOffset } = at(bitfield, index);
        bitfield[byteOffset] = byte | 1 << bitOffset;
    }
    return bitfield;
};
const size = (bitfield)=>bitfield.byteLength * 8;
/**
 * Compute offset for the given index
 *
 * @param {Uint8Array} bitfield
 * @param {number} index
 */ const at = (bitfield, index)=>{
    const byteOffset = bitfield.byteLength - 1 - (index / 8 | 0);
    const bitOffset = index % 8;
    const byte = bitfield[byteOffset];
    return {
        byte,
        byteOffset,
        bitOffset
    };
};
/**
 * Set a particular bit.
 *
 * @param {Uint8Array} bytes
 * @param {number} index
 * @param {number} byte
 * @returns {Uint8Array}
 */ const setByte = (bytes, index, byte)=>{
    if (bytes[index] !== byte) {
        const result = bytes.slice(0);
        result[index] = byte;
        return result;
    }
    return bytes;
};
const set = (bitfield, index)=>{
    const { byte, byteOffset, bitOffset } = at(bitfield, index);
    return setByte(bitfield, byteOffset, byte | 1 << bitOffset);
};
const unset = (bitfield, index)=>{
    const { byte, byteOffset, bitOffset } = at(bitfield, index);
    return setByte(bitfield, byteOffset, byte & (0xff ^ 1 << bitOffset));
};
const get = (bitfield, index)=>{
    var { byte, bitOffset } = at(bitfield, index);
    return (byte >> bitOffset & 0x1) !== 0;
};
const toBytes = (bitfield)=>bitfield;
const fromBytes = (bytes)=>bytes;
const popcount = (bitfield, index = bitfield.byteLength * 8)=>{
    const { byteOffset, bitOffset, byte } = at(bitfield, index);
    let count = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["popcount"])(byte, bitOffset);
    let offset = bitfield.byteLength - 1;
    while(offset > byteOffset){
        const byte = bitfield[offset];
        count += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bitCount"])(byte);
        offset--;
    }
    return count;
};
const or = (left, right)=>{
    const result = left.slice();
    let offset = 0;
    while(offset < left.length){
        result[offset] |= right[offset];
        offset++;
    }
    return result;
};
const and = (left, right)=>{
    const result = left.slice();
    let offset = 0;
    while(offset < left.length){
        result[offset] &= right[offset];
        offset++;
    }
    return result;
};
;
}),
"[project]/node_modules/@perma/map/src/bitfield/Uint8Array.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "API",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    "and",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["and"],
    "empty",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["empty"],
    "from",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["from"],
    "fromBytes",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromBytes"],
    "get",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["get"],
    "or",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["or"],
    "popcount",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["popcount"],
    "set",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["set"],
    "size",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["size"],
    "toBytes",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["toBytes"],
    "unset",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["unset"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/bitfield/Uint8Array.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/bitfield/api.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@perma/map/src/lib.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "builder",
    ()=>builder,
    "empty",
    ()=>empty,
    "from",
    ()=>from,
    "get",
    ()=>get,
    "has",
    ()=>has
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/api.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/node.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$path$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/path/Uint32.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$path$2f$Uint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/path/Uint8Array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/bitfield/Uint32.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/bitfield/Uint32.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/bitfield/Uint8Array.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/bitfield/Uint8Array.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
const NOT_FOUND = new RangeError("Not Found");
const empty = (options)=>{
    const config = configure(options);
    return new PersistentHashMap(0, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["create"])(config, null), config);
};
/**
 * @template {API.Config} [C=API.Config<API.Uint32>]
 * @param {Partial<C>} config
 * @returns {C}
 */ const configure = ({ bitWidth = 5, /* c8 ignore next 4 */ BitField = bitWidth === 5 ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__, Path = bitWidth === 5 ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$path$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["configure"]({
    bitWidth
}) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$path$2f$Uint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["configure"]({
    bitWidth
}) } = {})=>/** @type {C} */ ({
        bitWidth,
        BitField,
        Path
    });
const from = (entries, options)=>{
    const node = builder(options);
    for (const [key, value] of entries){
        node.set(key, value);
    }
    return node.build();
};
const has = (hamt, key)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["get"](hamt.root, key, NOT_FOUND) !== NOT_FOUND;
const get = (hamt, key, notFound = undefined)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["get"](hamt.root, key, notFound);
const builder = (options)=>{
    const edit = {};
    const config = configure(options);
    return new HashMapBuilder(edit, 0, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["create"])(config, edit), config);
};
/**
 * @template T
 * @template {string} K
 * @template {API.Config} C
 * @implements {API.PersistentHashMap<T, K, C>}
 */ class PersistentHashMap {
    /**
   *
   * @param {number} count
   * @param {API.BitmapIndexedNode<T, K, C>} root
   * @param {C} config
   */ constructor(count = 0, root, config){
        this.count = count;
        this.root = root;
        this.config = config;
    }
    get size() {
        return this.count;
    }
    clone() {
        return new PersistentHashMap(this.count, this.root, this.config);
    }
    /**
   * @returns {API.PersistentHashMap<T, K, C>}
   */ empty() {
        return new PersistentHashMap(0, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["create"])(this.config, null), this.config);
    }
    /**
   * @param {K} key
   * @returns {boolean}
   */ has(key) {
        return has(this, key);
    }
    /**
   * @param {K} key
   * @returns {T|undefined}
   */ get(key) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["get"](this.root, key, undefined);
    }
    /**
   * @template {string} R
   * @param {R} key
   * @param {T} value
   * @returns {PersistentHashMap<T, K|R, C>}
   */ set(key, value) {
        const addedLeaf = {
            value: false
        };
        const root = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["set"](this.root, null, key, value, addedLeaf);
        if (root === this.root) {
            return this;
        } else {
            return new PersistentHashMap(addedLeaf.value ? this.count + 1 : this.count, root, this.config);
        }
    }
    /**
   * @param {K} key
   */ delete(key) {
        const root = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["delete"](this.root, null, key, {
            value: false
        });
        if (root === this.root) {
            return this;
        } else {
            return new PersistentHashMap(this.count - 1, root, this.config);
        }
    }
    /* c8 ignore next 3 */ get bitField() {
        return this.config.BitField.or(this.root.datamap, this.root.nodemap);
    }
    [Symbol.iterator]() {
        return this.entries();
    }
    entries() {
        return this.root.entries();
    }
    keys() {
        return this.root.keys();
    }
    values() {
        return this.root.values();
    }
    /**
   * @returns {API.HashMapBuilder<T, K, C>}
   */ createBuilder() {
        return new HashMapBuilder({}, this.count, this.root, this.config);
    }
}
/**
 * @template T
 * @template {string} K
 * @template {API.Config} C
 */ class HashMapBuilder {
    /**
   * @param {API.Edit} edit
   * @param {number} count
   * @param {API.BitmapIndexedNode<T, K, C>} root
   * @param {C} config
   */ constructor(edit, count, root, config){
        /**
     * @type {API.Edit|null}
     * @private
     */ this.edit = edit;
        /**
     * @private
     */ this.count = count;
        this.root = root;
        this.config = config;
    }
    get size() {
        if (this.edit) {
            return this.count;
        } else {
            throw new Error(`.size was accessed on the finalized builder`);
        }
    }
    /**
   * @template {string} R
   * @param {R} key
   * @param {T} value
   * @returns {HashMapBuilder<T, K|R, C>}
   */ set(key, value) {
        if (this.edit) {
            const addedLeaf = {
                value: false
            };
            const root = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["set"](this.root, this.edit, key, value, addedLeaf);
            if (this.root !== root) {
                this.root = root;
            }
            if (addedLeaf.value) {
                this.count += 1;
            }
            return this;
        } else {
            throw new Error(`.set was called on the finalized builder`);
        }
    }
    /**
   * @param {K} key
   */ delete(key) {
        if (this.edit) {
            if (this.count === 0) {
                return this;
            }
            const removedLeaf = {
                value: false
            };
            const root = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["delete"](this.root, this.edit, key, removedLeaf);
            if (root !== this.root) {
                this.root = root;
            }
            if (removedLeaf.value) {
                this.count -= 1;
            }
            return this;
        } else {
            throw new Error(`.delete was called on the finalized builder`);
        }
    }
    build() {
        if (this.edit) {
            this.edit = null;
            return new PersistentHashMap(this.count, this.root, this.config);
        } else {
            throw new Error(`.build was called on the finalized builder`);
        }
    }
}
}),
"[project]/node_modules/@perma/map/src/path/InfiniteUint8Array.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "configure",
    ()=>configure,
    "hash64",
    ()=>hash64,
    "read",
    ()=>read
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$path$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/path/api.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$path$2f$Uint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/path/Uint8Array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$murmur3$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/murmur3/src/index.js [app-client] (ecmascript)");
;
;
;
const utf8 = new TextEncoder();
const hash64 = (bytes)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$murmur3$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["murmur364"].encode(bytes);
const configure = ({ bitWidth = 8, hash = hash64 })=>{
    const hashSize = hash(new Uint8Array()).byteLength;
    const options = {
        bitWidth,
        hash,
        hashSize
    };
    /**
   * @param {Uint8Array} path
   * @param {number} depth
   * @returns {API.Uint32}
   */ const at = (path, depth)=>read(path, depth, options);
    /**
   * @param {string} key
   */ const from = (key)=>utf8.encode(key);
    return {
        at,
        from,
        size: Infinity
    };
};
const read = (key, depth = 0, { bitWidth = 8, hash, hashSize })=>{
    // key digest consists of infinite number of hash frames that are computed
    // from key + frame n which looks like
    // [hash(key), hash([key, 1]), hash([key, n])]
    // You can think of the hash as concatination of all frames. Here we calculate
    // frame bit size from hash size as we going to use that several times.
    const frameBitSize = hashSize * 8;
    // We start with 0 digest and required `bitCount` corresponding to `bitWith`.
    // In the loop we'll going to consume `bitCount` hash bits.
    let digest = 0;
    let bitCount = bitWidth;
    // Calculate absolute bit offset within the key digest.
    let bitOffset = bitWidth * depth;
    while(bitCount > 0){
        // We derive frame number based on current bit offset.
        const frameOffset = bitOffset / frameBitSize >> 0;
        // Then we compute that hash frame
        const frame = frameOffset === 0 ? hash(key) : hash(appendByte(key, frameOffset));
        // compute bit offset within the current frame
        const offset = frameBitSize <= bitOffset ? bitOffset % frameBitSize : bitOffset;
        // calculate number of bits remaining in this frame
        const maxBits = frameBitSize - offset;
        // we will consume all required bits from frame if enough are available
        // otherwise we consume whatever's available and continue rest in the next
        // cycle(s).
        const count = maxBits < bitCount ? maxBits : bitCount;
        digest = (digest << count) + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$path$2f$Uint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toInt"])(frame, offset, count);
        bitCount -= count;
        bitOffset += count;
    }
    return digest;
};
/**
 * @param {Uint8Array} source
 * @param {number} byte
 */ const appendByte = (source, byte)=>{
    const bytes = new Uint8Array(source.byteLength + 1).fill(byte, source.byteLength);
    bytes.set(source);
    return bytes;
};
}),
"[project]/node_modules/@perma/map/src/unixfs.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "bitField",
    ()=>bitField,
    "bitWidth",
    ()=>bitWidth,
    "builder",
    ()=>builder,
    "config",
    ()=>config,
    "empty",
    ()=>empty,
    "from",
    ()=>from,
    "iterate",
    ()=>iterate,
    "tableSize",
    ()=>tableSize
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/lib.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/node.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$path$2f$InfiniteUint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/path/InfiniteUint8Array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/api.js [app-client] (ecmascript)");
;
;
;
;
;
const bitWidth = 8;
const config = {
    bitWidth,
    Path: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$path$2f$InfiniteUint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["configure"]({
        bitWidth
    })
};
const tableSize = (hamt)=>Math.pow(2, hamt.config.bitWidth);
const empty = (options = config)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["empty"](options);
const builder = (options = config)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["builder"](options);
const from = (entries, options = config)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["from"](entries, options);
const bitField = ({ datamap, nodemap, config: { BitField } })=>withoutLeadingZeros(BitField.toBytes(BitField.or(datamap, nodemap)));
/**
 * @param {Uint8Array} bytes
 */ const withoutLeadingZeros = (bytes)=>{
    let offset = 0;
    while(offset < bytes.byteLength){
        if (bytes[offset] !== 0) {
            return bytes.subarray(offset);
        }
        offset += 1;
    }
    return bytes.subarray(offset);
};
const iterate = function*(root) {
    const { config, datamap, nodemap } = root;
    const { BitField: bitfield } = config;
    const size = bitfield.size(datamap);
    let bitOffset = 0;
    let dataCount = 0;
    while(bitOffset < size){
        const prefix = bitOffset.toString(16).toUpperCase().padStart(2, "0");
        if (bitfield.get(datamap, bitOffset)) {
            const key = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["keyAt"](root, dataCount);
            yield {
                prefix,
                key,
                value: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["valueAt"](root, dataCount)
            };
            dataCount++;
        } else if (bitfield.get(nodemap, bitOffset)) {
            yield {
                prefix,
                // UnixFS never contains hash collision nodes because it uses
                // inifinite hashes
                node: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["resolveNode"](root, bitOffset)
            };
        }
        bitOffset++;
    }
};
}),
"[project]/node_modules/carstream/src/varint.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "decode",
    ()=>decode,
    "encode",
    ()=>encode
]);
const MSB = 0x80;
const REST = 0x7F;
const MSBALL = ~REST;
const INT = Math.pow(2, 31);
const encode = (num)=>{
    /** @type {number[]} */ const out = [];
    let offset = 0;
    while(num >= INT){
        out[offset++] = num & 0xFF | MSB;
        num /= 128;
    }
    while(num & MSBALL){
        out[offset++] = num & 0xFF | MSB;
        num >>>= 7;
    }
    out[offset] = num | 0;
    return out;
};
const decode = (buf, offset)=>{
    let res = 0;
    offset = offset || 0;
    let shift = 0;
    let counter = offset;
    let b;
    const l = buf.length;
    do {
        if (counter >= l || shift > 49) throw new RangeError('Could not decode varint');
        b = buf.get(counter++);
        res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
        shift += 7;
    }while (b >= MSB)
    return [
        res,
        counter - offset
    ];
};
}),
"[project]/node_modules/carstream/src/reader.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* eslint-env browser */ __turbopack_context__.s([
    "CARReaderStream",
    ()=>CARReaderStream
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arraylist/dist/src/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-cbor/src/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$carstream$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/carstream/node_modules/multiformats/dist/src/hashes/digest.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$carstream$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/carstream/node_modules/multiformats/dist/src/link.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$carstream$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/carstream/src/varint.js [app-client] (ecmascript)");
;
;
;
;
;
const State = {
    ReadHeaderLength: 0,
    ReadHeader: 1,
    ReadBlockLength: 2,
    ReadBlock: 3
};
const CIDV0_BYTES = {
    SHA2_256: 0x12,
    LENGTH: 0x20,
    DAG_PB: 0x70
};
class CARReaderStream extends TransformStream {
    /** @type {Promise<import('./api.js').CARHeader>} */ #headerPromise;
    /**
   * @param {QueuingStrategy<Uint8Array>} [writableStrategy]
   * An object that optionally defines a queuing strategy for the stream.
   * @param {QueuingStrategy<import('./api.js').Block & import('./api.js').Position>} [readableStrategy]
   * An object that optionally defines a queuing strategy for the stream.
   * Defaults to a CountQueuingStrategy with highWaterMark of `1` to allow
   * `getHeader` to be called before the stream is consumed.
   */ constructor(writableStrategy, readableStrategy){
        const buffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Uint8ArrayList"]();
        let offset = 0;
        let prevOffset = offset;
        let wanted = 8;
        let state = State.ReadHeaderLength;
        /** @type {(value: import('./api.js').CARHeader) => void} */ let resolveHeader;
        const headerPromise = new Promise((resolve)=>{
            resolveHeader = resolve;
        });
        super({
            transform (chunk, controller) {
                buffer.append(chunk);
                while(true){
                    if (buffer.length < wanted) break;
                    if (state === State.ReadHeaderLength) {
                        const [length, bytes] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$carstream$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])(buffer);
                        buffer.consume(bytes);
                        prevOffset = offset;
                        offset += bytes;
                        state = State.ReadHeader;
                        wanted = length;
                    } else if (state === State.ReadHeader) {
                        const header = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])(buffer.slice(0, wanted));
                        resolveHeader && resolveHeader(header);
                        buffer.consume(wanted);
                        prevOffset = offset;
                        offset += wanted;
                        state = State.ReadBlockLength;
                        wanted = 8;
                    } else if (state === State.ReadBlockLength) {
                        const [length, bytes] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$carstream$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])(buffer);
                        buffer.consume(bytes);
                        prevOffset = offset;
                        offset += bytes;
                        state = State.ReadBlock;
                        wanted = length;
                    } else if (state === State.ReadBlock) {
                        const _offset = prevOffset;
                        const length = offset - prevOffset + wanted;
                        prevOffset = offset;
                        /** @type {import('multiformats').UnknownLink} */ let cid;
                        if (buffer.get(0) === CIDV0_BYTES.SHA2_256 && buffer.get(1) === CIDV0_BYTES.LENGTH) {
                            const bytes = buffer.subarray(0, 34);
                            const multihash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$carstream$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])(bytes);
                            // @ts-expect-error
                            cid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$carstream$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createLegacy"])(multihash);
                            buffer.consume(34);
                            offset += 34;
                        } else {
                            const [version, versionBytes] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$carstream$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])(buffer);
                            if (version !== 1) throw new Error(`unexpected CID version (${version})`);
                            buffer.consume(versionBytes);
                            offset += versionBytes;
                            const [codec, codecBytes] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$carstream$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])(buffer);
                            buffer.consume(codecBytes);
                            offset += codecBytes;
                            const multihashBytes = getMultihashLength(buffer);
                            const multihash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$carstream$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])(buffer.subarray(0, multihashBytes));
                            cid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$carstream$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["create"])(codec, multihash);
                            buffer.consume(multihashBytes);
                            offset += multihashBytes;
                        }
                        const blockBytes = wanted - (offset - prevOffset);
                        const bytes = buffer.subarray(0, blockBytes);
                        controller.enqueue({
                            cid,
                            bytes,
                            offset: _offset,
                            length,
                            blockOffset: offset,
                            blockLength: blockBytes
                        });
                        buffer.consume(blockBytes);
                        prevOffset = offset;
                        offset += blockBytes;
                        state = State.ReadBlockLength;
                        wanted = 8;
                    }
                }
            },
            flush (controller) {
                if (state !== State.ReadBlockLength) {
                    controller.error(new Error('unexpected end of data'));
                }
            }
        }, writableStrategy, readableStrategy ?? new CountQueuingStrategy({
            highWaterMark: 1
        }));
        this.#headerPromise = headerPromise;
    }
    /**
   * Get the decoded CAR header.
   */ getHeader() {
        return this.#headerPromise;
    }
}
/** @param {Uint8ArrayList} bytes */ const getMultihashLength = (bytes)=>{
    const [, codeBytes] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$carstream$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])(bytes);
    const [length, lengthBytes] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$carstream$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])(bytes, codeBytes);
    return codeBytes + lengthBytes + length;
};
}),
"[project]/node_modules/carstream/src/writer.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* eslint-env browser */ __turbopack_context__.s([
    "CARWriterStream",
    ()=>CARWriterStream,
    "encodeBlock",
    ()=>encodeBlock,
    "encodeHeader",
    ()=>encodeHeader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-cbor/src/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$carstream$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/carstream/src/varint.js [app-client] (ecmascript)");
;
;
const encodeHeader = (roots)=>{
    const headerBytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"])({
        version: 1,
        roots
    });
    const varintBytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$carstream$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"])(headerBytes.length);
    const header = new Uint8Array(varintBytes.length + headerBytes.length);
    header.set(varintBytes, 0);
    header.set(headerBytes, varintBytes.length);
    return header;
};
const encodeBlock = (block)=>{
    const varintBytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$carstream$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"])(block.cid.bytes.length + block.bytes.length);
    const bytes = new Uint8Array(varintBytes.length + block.cid.bytes.length + block.bytes.length);
    bytes.set(varintBytes);
    bytes.set(block.cid.bytes, varintBytes.length);
    bytes.set(block.bytes, varintBytes.length + block.cid.bytes.length);
    return bytes;
};
class CARWriterStream extends TransformStream {
    /**
   * @param {import('multiformats').UnknownLink[]} [roots]
   * @param {QueuingStrategy<import('./api.js').Block>} [writableStrategy]
   * @param {QueuingStrategy<Uint8Array>} [readableStrategy]
   */ constructor(roots = [], writableStrategy, readableStrategy){
        super({
            start: (controller)=>controller.enqueue(encodeHeader(roots)),
            transform: (block, controller)=>controller.enqueue(encodeBlock(block))
        }, writableStrategy, readableStrategy);
    }
}
}),
"[project]/node_modules/carstream/src/index.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "code",
    ()=>code
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$carstream$2f$src$2f$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/carstream/src/reader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$carstream$2f$src$2f$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/carstream/src/writer.js [app-client] (ecmascript)");
;
;
const code = 0x0202;
}),
"[project]/node_modules/@storacha/access/dist/drivers/memory.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @template T
 * @typedef {import('./types.js').Driver<T>} Driver
 */ /**
 * Driver implementation that stores data in memory."
 *
 * Usage:
 *
 * ```js
 * import { MemoryDriver } from '@storacha/access/drivers/memory'
 * ```
 *
 * @template {Record<string, any>} T
 * @implements {Driver<T>}
 */ __turbopack_context__.s([
    "MemoryDriver",
    ()=>MemoryDriver
]);
class MemoryDriver {
    /**
     * @type {T|undefined}
     */ #data;
    constructor(){
        this.#data = undefined;
    }
    async open() {}
    async close() {}
    async reset() {
        this.#data = undefined;
    }
    /** @param {T} data */ async save(data) {
        this.#data = {
            ...data
        };
    }
    /** @returns {Promise<T|undefined>} */ async load() {
        if (this.#data === undefined) return;
        if (Object.keys(this.#data).length === 0) return;
        return this.#data;
    }
} //# sourceMappingURL=memory.js.map
}),
"[project]/node_modules/@storacha/access/dist/stores/store-memory.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "StoreMemory",
    ()=>StoreMemory
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$drivers$2f$memory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/dist/drivers/memory.js [app-client] (ecmascript)");
;
class StoreMemory extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$drivers$2f$memory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MemoryDriver"] {
} //# sourceMappingURL=store-memory.js.map
}),
"[project]/node_modules/@storacha/access/dist/drivers/indexeddb.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "IndexedDBDriver",
    ()=>IndexedDBDriver
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p$2d$defer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p-defer/index.js [app-client] (ecmascript)");
;
/**
 * @template T
 * @typedef {import('./types.js').Driver<T>} Driver
 */ const STORE_NAME = 'AccessStore';
const DATA_ID = 1;
class IndexedDBDriver {
    /** @type {string} */ #dbName;
    /** @type {number|undefined} */ #dbVersion;
    /** @type {string} */ #dbStoreName;
    /** @type {IDBDatabase|undefined} */ #db;
    /** @type {boolean} */ #autoOpen;
    /**
     * @param {string} dbName
     * @param {object} [options]
     * @param {number} [options.dbVersion]
     * @param {string} [options.dbStoreName]
     * @param {boolean} [options.autoOpen]
     */ constructor(dbName, options = {}){
        this.#dbName = dbName;
        this.#dbVersion = options.dbVersion;
        this.#dbStoreName = options.dbStoreName ?? STORE_NAME;
        this.#autoOpen = options.autoOpen ?? true;
    }
    /** @returns {Promise<IDBDatabase>} */ async #getOpenDB() {
        if (!this.#db) {
            if (!this.#autoOpen) throw new Error('Store is not open');
            await this.open();
        }
        // @ts-expect-error open sets this.#db
        return this.#db;
    }
    async open() {
        const db = this.#db;
        if (db) return;
        /** @type {import('p-defer').DeferredPromise<void>} */ const { resolve, reject, promise } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p$2d$defer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])();
        const openReq = indexedDB.open(this.#dbName, this.#dbVersion);
        openReq.addEventListener('upgradeneeded', ()=>{
            const db = openReq.result;
            db.createObjectStore(this.#dbStoreName, {
                keyPath: 'id'
            });
        });
        openReq.addEventListener('success', ()=>{
            this.#db = openReq.result;
            resolve();
        });
        openReq.addEventListener('error', ()=>reject(openReq.error));
        return promise;
    }
    async close() {
        const db = this.#db;
        if (!db) throw new Error('Store is not open');
        db.close();
        this.#db = undefined;
    }
    /** @param {T} data */ async save(data) {
        const db = await this.#getOpenDB();
        const putData = withObjectStore(db, 'readwrite', this.#dbStoreName, async (store)=>{
            /** @type {import('p-defer').DeferredPromise<void>} */ const { resolve, reject, promise } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p$2d$defer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])();
            const putReq = store.put({
                id: DATA_ID,
                ...data
            });
            putReq.addEventListener('success', ()=>resolve());
            putReq.addEventListener('error', ()=>reject(new Error('failed to query DB', {
                    cause: putReq.error
                })));
            return promise;
        });
        return await putData();
    }
    async load() {
        const db = await this.#getOpenDB();
        const getData = withObjectStore(db, 'readonly', this.#dbStoreName, async (store)=>{
            /** @type {import('p-defer').DeferredPromise<T|undefined>} */ const { resolve, reject, promise } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p$2d$defer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])();
            const getReq = store.get(DATA_ID);
            getReq.addEventListener('success', ()=>resolve(getReq.result));
            getReq.addEventListener('error', ()=>reject(new Error('failed to query DB', {
                    cause: getReq.error
                })));
            return promise;
        });
        return await getData();
    }
    async reset() {
        const db = await this.#getOpenDB();
        const clear = withObjectStore(db, 'readwrite', this.#dbStoreName, (s)=>{
            /** @type {import('p-defer').DeferredPromise<void>} */ const { resolve, reject, promise } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p$2d$defer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])();
            const req = s.clear();
            req.addEventListener('success', ()=>{
                resolve();
            });
            req.addEventListener('error', ()=>reject(new Error('failed to query DB', {
                    cause: req.error
                })));
            return promise;
        });
        await clear();
    }
}
/**
 * @template T
 * @param {IDBDatabase} db
 * @param {IDBTransactionMode} txnMode
 * @param {string} storeName
 * @param {(s: IDBObjectStore) => Promise<T>} fn
 * @returns
 */ function withObjectStore(db, txnMode, storeName, fn) {
    return async ()=>{
        const tx = db.transaction(storeName, txnMode);
        /** @type {import('p-defer').DeferredPromise<T>} */ const { resolve, reject, promise } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p$2d$defer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])();
        /** @type {T} */ let result;
        tx.addEventListener('complete', ()=>resolve(result));
        tx.addEventListener('abort', ()=>reject(tx.error || new Error('transaction aborted')));
        tx.addEventListener('error', ()=>reject(new Error('transaction error', {
                cause: tx.error
            })));
        try {
            result = await fn(tx.objectStore(storeName));
            tx.commit();
        } catch (error) {
            reject(error);
            tx.abort();
        }
        return promise;
    };
} //# sourceMappingURL=indexeddb.js.map
}),
"[project]/node_modules/@storacha/access/dist/stores/store-indexeddb.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "StoreIndexedDB",
    ()=>StoreIndexedDB
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$drivers$2f$indexeddb$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/dist/drivers/indexeddb.js [app-client] (ecmascript)");
;
class StoreIndexedDB extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$drivers$2f$indexeddb$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IndexedDBDriver"] {
} //# sourceMappingURL=store-indexeddb.js.map
}),
"[project]/node_modules/@storacha/access/dist/utils/json.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// JSON.stringify and JSON.parse with URL, Map and Uint8Array type support.
/**
 * @param {string} k
 * @param {any} v
 */ __turbopack_context__.s([
    "parse",
    ()=>parse,
    "replacer",
    ()=>replacer,
    "reviver",
    ()=>reviver,
    "stringify",
    ()=>stringify
]);
const replacer = (k, v)=>{
    if (v instanceof URL) {
        return {
            $url: v.toString()
        };
    } else if (v instanceof Map) {
        return {
            $map: [
                ...v.entries()
            ]
        };
    } else if (v instanceof Uint8Array) {
        return {
            $bytes: [
                ...v.values()
            ]
        };
    } else if (v instanceof ArrayBuffer) {
        return {
            $bytes: [
                ...new Uint8Array(v).values()
            ]
        };
    } else if (v?.type === 'Buffer' && Array.isArray(v.data)) {
        return {
            $bytes: v.data
        };
    }
    return v;
};
const reviver = (k, v)=>{
    if (!v) return v;
    if (v.$url) return new URL(v.$url);
    if (v.$map) return new Map(v.$map);
    if (v.$bytes) return new Uint8Array(v.$bytes);
    return v;
};
const stringify = (value, space)=>JSON.stringify(value, replacer, space);
const parse = (value)=>JSON.parse(value, reviver); //# sourceMappingURL=json.js.map
}),
"[project]/node_modules/@storacha/access/dist/drivers/conf.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ConfDriver",
    ()=>ConfDriver
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$conf$2f$dist$2f$source$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/conf/dist/source/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$utils$2f$json$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/dist/utils/json.js [app-client] (ecmascript)");
;
;
class ConfDriver {
    /**
     * @type {Conf<T>}
     */ #config;
    /**
     * @param {{ profile: string }} opts
     */ constructor(opts){
        this.#config = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$conf$2f$dist$2f$source$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]({
            projectName: 'w3access',
            projectSuffix: '',
            configName: opts.profile,
            serialize: (v)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$utils$2f$json$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["stringify"](v),
            deserialize: (v)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$utils$2f$json$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parse"](v)
        });
        this.path = this.#config.path;
    }
    async open() {}
    async close() {}
    async reset() {
        this.#config.clear();
    }
    /** @param {T} data */ async save(data) {
        if (typeof data === 'object') {
            data = {
                ...data
            };
            for (const [k, v] of Object.entries(data)){
                if (v === undefined) {
                    delete data[k];
                }
            }
        }
        this.#config.set(data);
    }
    /** @returns {Promise<T|undefined>} */ async load() {
        const data = this.#config.store ?? {};
        if (Object.keys(data).length === 0) return;
        return data;
    }
} //# sourceMappingURL=conf.js.map
}),
"[project]/node_modules/@storacha/access/dist/stores/store-conf.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "StoreConf",
    ()=>StoreConf
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$drivers$2f$conf$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/dist/drivers/conf.js [app-client] (ecmascript)");
;
class StoreConf extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$drivers$2f$conf$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ConfDriver"] {
} //# sourceMappingURL=store-conf.js.map
}),
"[project]/node_modules/@storacha/client/dist/stores/memory.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$stores$2f$store$2d$memory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/dist/stores/store-memory.js [app-client] (ecmascript)"); //# sourceMappingURL=memory.js.map
;
}),
"[project]/node_modules/@storacha/client/dist/stores/indexeddb.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$stores$2f$store$2d$indexeddb$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/dist/stores/store-indexeddb.js [app-client] (ecmascript)"); //# sourceMappingURL=indexeddb.js.map
;
}),
"[project]/node_modules/@storacha/client/dist/stores/conf.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$stores$2f$store$2d$conf$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/dist/stores/store-conf.js [app-client] (ecmascript)"); //# sourceMappingURL=conf.js.map
;
}),
"[project]/node_modules/@storacha/client/dist/stores/index.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$client$2f$dist$2f$stores$2f$memory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@storacha/client/dist/stores/memory.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$stores$2f$store$2d$memory$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/dist/stores/store-memory.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$client$2f$dist$2f$stores$2f$indexeddb$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@storacha/client/dist/stores/indexeddb.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$stores$2f$store$2d$indexeddb$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/dist/stores/store-indexeddb.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$client$2f$dist$2f$stores$2f$conf$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@storacha/client/dist/stores/conf.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$stores$2f$store$2d$conf$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/dist/stores/store-conf.js [app-client] (ecmascript)");
;
;
;
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/dot-prop/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "deepKeys",
    ()=>deepKeys,
    "deleteProperty",
    ()=>deleteProperty,
    "escapePath",
    ()=>escapePath,
    "getProperty",
    ()=>getProperty,
    "hasProperty",
    ()=>hasProperty,
    "setProperty",
    ()=>setProperty
]);
const isObject = (value)=>{
    const type = typeof value;
    return value !== null && (type === 'object' || type === 'function');
};
const disallowedKeys = new Set([
    '__proto__',
    'prototype',
    'constructor'
]);
const digits = new Set('0123456789');
function getPathSegments(path) {
    const parts = [];
    let currentSegment = '';
    let currentPart = 'start';
    let isIgnoring = false;
    for (const character of path){
        switch(character){
            case '\\':
                if (currentPart === 'index') {
                    throw new Error('Invalid character in an index');
                }
                if (currentPart === 'indexEnd') {
                    throw new Error('Invalid character after an index');
                }
                if (isIgnoring) {
                    currentSegment += character;
                }
                currentPart = 'property';
                isIgnoring = !isIgnoring;
                break;
            case '.':
                if (currentPart === 'index') {
                    throw new Error('Invalid character in an index');
                }
                if (currentPart === 'indexEnd') {
                    currentPart = 'property';
                    break;
                }
                if (isIgnoring) {
                    isIgnoring = false;
                    currentSegment += character;
                    break;
                }
                if (disallowedKeys.has(currentSegment)) {
                    return [];
                }
                parts.push(currentSegment);
                currentSegment = '';
                currentPart = 'property';
                break;
            case '[':
                if (currentPart === 'index') {
                    throw new Error('Invalid character in an index');
                }
                if (currentPart === 'indexEnd') {
                    currentPart = 'index';
                    break;
                }
                if (isIgnoring) {
                    isIgnoring = false;
                    currentSegment += character;
                    break;
                }
                if (currentPart === 'property') {
                    if (disallowedKeys.has(currentSegment)) {
                        return [];
                    }
                    parts.push(currentSegment);
                    currentSegment = '';
                }
                currentPart = 'index';
                break;
            case ']':
                if (currentPart === 'index') {
                    parts.push(Number.parseInt(currentSegment, 10));
                    currentSegment = '';
                    currentPart = 'indexEnd';
                    break;
                }
                if (currentPart === 'indexEnd') {
                    throw new Error('Invalid character after an index');
                }
            // Falls through
            default:
                if (currentPart === 'index' && !digits.has(character)) {
                    throw new Error('Invalid character in an index');
                }
                if (currentPart === 'indexEnd') {
                    throw new Error('Invalid character after an index');
                }
                if (currentPart === 'start') {
                    currentPart = 'property';
                }
                if (isIgnoring) {
                    isIgnoring = false;
                    currentSegment += '\\';
                }
                currentSegment += character;
        }
    }
    if (isIgnoring) {
        currentSegment += '\\';
    }
    switch(currentPart){
        case 'property':
            {
                if (disallowedKeys.has(currentSegment)) {
                    return [];
                }
                parts.push(currentSegment);
                break;
            }
        case 'index':
            {
                throw new Error('Index was not closed');
            }
        case 'start':
            {
                parts.push('');
                break;
            }
    }
    return parts;
}
function isStringIndex(object, key) {
    if (typeof key !== 'number' && Array.isArray(object)) {
        const index = Number.parseInt(key, 10);
        return Number.isInteger(index) && object[index] === object[key];
    }
    return false;
}
function assertNotStringIndex(object, key) {
    if (isStringIndex(object, key)) {
        throw new Error('Cannot use string index');
    }
}
function getProperty(object, path, value) {
    if (!isObject(object) || typeof path !== 'string') {
        return value === undefined ? object : value;
    }
    const pathArray = getPathSegments(path);
    if (pathArray.length === 0) {
        return value;
    }
    for(let index = 0; index < pathArray.length; index++){
        const key = pathArray[index];
        if (isStringIndex(object, key)) {
            object = index === pathArray.length - 1 ? undefined : null;
        } else {
            object = object[key];
        }
        if (object === undefined || object === null) {
            // `object` is either `undefined` or `null` so we want to stop the loop, and
            // if this is not the last bit of the path, and
            // if it didn't return `undefined`
            // it would return `null` if `object` is `null`
            // but we want `get({foo: null}, 'foo.bar')` to equal `undefined`, or the supplied value, not `null`
            if (index !== pathArray.length - 1) {
                return value;
            }
            break;
        }
    }
    return object === undefined ? value : object;
}
function setProperty(object, path, value) {
    if (!isObject(object) || typeof path !== 'string') {
        return object;
    }
    const root = object;
    const pathArray = getPathSegments(path);
    for(let index = 0; index < pathArray.length; index++){
        const key = pathArray[index];
        assertNotStringIndex(object, key);
        if (index === pathArray.length - 1) {
            object[key] = value;
        } else if (!isObject(object[key])) {
            object[key] = typeof pathArray[index + 1] === 'number' ? [] : {};
        }
        object = object[key];
    }
    return root;
}
function deleteProperty(object, path) {
    if (!isObject(object) || typeof path !== 'string') {
        return false;
    }
    const pathArray = getPathSegments(path);
    for(let index = 0; index < pathArray.length; index++){
        const key = pathArray[index];
        assertNotStringIndex(object, key);
        if (index === pathArray.length - 1) {
            delete object[key];
            return true;
        }
        object = object[key];
        if (!isObject(object)) {
            return false;
        }
    }
}
function hasProperty(object, path) {
    if (!isObject(object) || typeof path !== 'string') {
        return false;
    }
    const pathArray = getPathSegments(path);
    if (pathArray.length === 0) {
        return false;
    }
    for (const key of pathArray){
        if (!isObject(object) || !(key in object) || isStringIndex(object, key)) {
            return false;
        }
        object = object[key];
    }
    return true;
}
function escapePath(path) {
    if (typeof path !== 'string') {
        throw new TypeError('Expected a string');
    }
    return path.replace(/[\\.[]/g, '\\$&');
}
// The keys returned by Object.entries() for arrays are strings
function entries(value) {
    if (Array.isArray(value)) {
        return value.map((value, index)=>[
                index,
                value
            ]);
    }
    return Object.entries(value);
}
function stringifyPath(pathSegments) {
    let result = '';
    for (let [index, segment] of entries(pathSegments)){
        if (typeof segment === 'number') {
            result += `[${segment}]`;
        } else {
            segment = escapePath(segment);
            result += index === 0 ? segment : `.${segment}`;
        }
    }
    return result;
}
function* deepKeysIterator(object, currentPath = []) {
    if (!isObject(object)) {
        if (currentPath.length > 0) {
            yield stringifyPath(currentPath);
        }
        return;
    }
    for (const [key, value] of entries(object)){
        yield* deepKeysIterator(value, [
            ...currentPath,
            key
        ]);
    }
}
function deepKeys(object) {
    return [
        ...deepKeysIterator(object)
    ];
}
}),
"[project]/node_modules/env-paths/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>envPaths
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$path$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/path-browserify/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$os$2d$browserify$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/os-browserify/browser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
;
;
;
const homedir = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$os$2d$browserify$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].homedir();
const tmpdir = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$os$2d$browserify$2f$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].tmpdir();
const { env } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"];
const macos = (name)=>{
    const library = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$path$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].join(homedir, 'Library');
    return {
        data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$path$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].join(library, 'Application Support', name),
        config: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$path$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].join(library, 'Preferences', name),
        cache: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$path$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].join(library, 'Caches', name),
        log: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$path$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].join(library, 'Logs', name),
        temp: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$path$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].join(tmpdir, name)
    };
};
const windows = (name)=>{
    const appData = env.APPDATA || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$path$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].join(homedir, 'AppData', 'Roaming');
    const localAppData = env.LOCALAPPDATA || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$path$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].join(homedir, 'AppData', 'Local');
    return {
        // Data/config/cache/log are invented by me as Windows isn't opinionated about this
        data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$path$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].join(localAppData, name, 'Data'),
        config: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$path$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].join(appData, name, 'Config'),
        cache: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$path$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].join(localAppData, name, 'Cache'),
        log: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$path$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].join(localAppData, name, 'Log'),
        temp: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$path$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].join(tmpdir, name)
    };
};
// https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html
const linux = (name)=>{
    const username = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$path$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].basename(homedir);
    return {
        data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$path$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].join(env.XDG_DATA_HOME || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$path$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].join(homedir, '.local', 'share'), name),
        config: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$path$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].join(env.XDG_CONFIG_HOME || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$path$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].join(homedir, '.config'), name),
        cache: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$path$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].join(env.XDG_CACHE_HOME || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$path$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].join(homedir, '.cache'), name),
        // https://wiki.debian.org/XDGBaseDirectorySpecification#state
        log: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$path$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].join(env.XDG_STATE_HOME || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$path$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].join(homedir, '.local', 'state'), name),
        temp: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$path$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].join(tmpdir, username, name)
    };
};
function envPaths(name, { suffix = 'nodejs' } = {}) {
    if (typeof name !== 'string') {
        throw new TypeError(`Expected a string, got ${typeof name}`);
    }
    if (suffix) {
        // Add suffix to prevent possible conflict with native apps
        name += `-${suffix}`;
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].platform === 'darwin') {
        return macos(name);
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].platform === 'win32') {
        return windows(name);
    }
    return linux(name);
}
}),
"[project]/node_modules/stubborn-utils/dist/attemptify_async.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* IMPORT */ /* MAIN */ __turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
const attemptifyAsync = (fn, options)=>{
    const { onError } = options;
    return function attemptified(...args) {
        return fn.apply(undefined, args).catch(onError);
    }; //TSC
};
const __TURBOPACK__default__export__ = attemptifyAsync;
}),
"[project]/node_modules/stubborn-utils/dist/attemptify_sync.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* IMPORT */ /* MAIN */ __turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
const attemptifySync = (fn, options)=>{
    const { onError } = options;
    return function attemptified(...args) {
        try {
            return fn.apply(undefined, args);
        } catch (error) {
            return onError(error);
        }
    }; //TSC
};
const __TURBOPACK__default__export__ = attemptifySync;
}),
"[project]/node_modules/stubborn-utils/dist/constants.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* MAIN */ __turbopack_context__.s([
    "RETRY_INTERVAL",
    ()=>RETRY_INTERVAL
]);
const RETRY_INTERVAL = 250;
;
}),
"[project]/node_modules/stubborn-utils/dist/retryify_async.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* IMPORT */ __turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stubborn$2d$utils$2f$dist$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stubborn-utils/dist/constants.js [app-client] (ecmascript)");
;
/* MAIN */ const retryifyAsync = (fn, options)=>{
    const { isRetriable } = options;
    return function retryified(options) {
        const { timeout } = options;
        const interval = options.interval ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stubborn$2d$utils$2f$dist$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RETRY_INTERVAL"];
        const timestamp = Date.now() + timeout;
        return function attempt(...args) {
            return fn.apply(undefined, args).catch((error)=>{
                if (!isRetriable(error)) throw error;
                if (Date.now() >= timestamp) throw error;
                const delay = Math.round(interval * Math.random());
                if (delay > 0) {
                    const delayPromise = new Promise((resolve)=>setTimeout(resolve, delay));
                    return delayPromise.then(()=>attempt.apply(undefined, args));
                } else {
                    return attempt.apply(undefined, args);
                }
            });
        }; //TSC
    };
};
const __TURBOPACK__default__export__ = retryifyAsync;
}),
"[project]/node_modules/stubborn-utils/dist/retryify_sync.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* IMPORT */ /* MAIN */ __turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
const retryifySync = (fn, options)=>{
    const { isRetriable } = options;
    return function retryified(options) {
        const { timeout } = options;
        const timestamp = Date.now() + timeout;
        return function attempt(...args) {
            while(true){
                try {
                    return fn.apply(undefined, args);
                } catch (error) {
                    if (!isRetriable(error)) throw error;
                    if (Date.now() >= timestamp) throw error;
                    continue;
                }
            }
        }; //TSC
    };
};
const __TURBOPACK__default__export__ = retryifySync;
}),
"[project]/node_modules/stubborn-utils/dist/index.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

/* IMPORT */ __turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stubborn$2d$utils$2f$dist$2f$attemptify_async$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stubborn-utils/dist/attemptify_async.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stubborn$2d$utils$2f$dist$2f$attemptify_sync$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stubborn-utils/dist/attemptify_sync.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stubborn$2d$utils$2f$dist$2f$retryify_async$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stubborn-utils/dist/retryify_async.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stubborn$2d$utils$2f$dist$2f$retryify_sync$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stubborn-utils/dist/retryify_sync.js [app-client] (ecmascript)");
;
;
;
;
;
}),
"[project]/node_modules/stubborn-utils/dist/attemptify_async.js [app-client] (ecmascript) <export default as attemptifyAsync>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "attemptifyAsync",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stubborn$2d$utils$2f$dist$2f$attemptify_async$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stubborn$2d$utils$2f$dist$2f$attemptify_async$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stubborn-utils/dist/attemptify_async.js [app-client] (ecmascript)");
}),
"[project]/node_modules/stubborn-utils/dist/attemptify_sync.js [app-client] (ecmascript) <export default as attemptifySync>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "attemptifySync",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stubborn$2d$utils$2f$dist$2f$attemptify_sync$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stubborn$2d$utils$2f$dist$2f$attemptify_sync$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stubborn-utils/dist/attemptify_sync.js [app-client] (ecmascript)");
}),
"[project]/node_modules/stubborn-utils/dist/retryify_async.js [app-client] (ecmascript) <export default as retryifyAsync>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "retryifyAsync",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stubborn$2d$utils$2f$dist$2f$retryify_async$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stubborn$2d$utils$2f$dist$2f$retryify_async$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stubborn-utils/dist/retryify_async.js [app-client] (ecmascript)");
}),
"[project]/node_modules/stubborn-utils/dist/retryify_sync.js [app-client] (ecmascript) <export default as retryifySync>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "retryifySync",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stubborn$2d$utils$2f$dist$2f$retryify_sync$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stubborn$2d$utils$2f$dist$2f$retryify_sync$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stubborn-utils/dist/retryify_sync.js [app-client] (ecmascript)");
}),
"[project]/node_modules/stubborn-fs/dist/handlers.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* IMPORT */ __turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stubborn$2d$fs$2f$dist$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stubborn-fs/dist/constants.js [app-client] (ecmascript)");
;
/* MAIN */ const Handlers = {
    /* API */ isChangeErrorOk: (error)=>{
        if (!Handlers.isNodeError(error)) return false;
        const { code } = error;
        if (code === 'ENOSYS') return true;
        if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stubborn$2d$fs$2f$dist$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IS_USER_ROOT"] && (code === 'EINVAL' || code === 'EPERM')) return true;
        return false;
    },
    isNodeError: (error)=>{
        return error instanceof Error;
    },
    isRetriableError: (error)=>{
        if (!Handlers.isNodeError(error)) return false;
        const { code } = error;
        if (code === 'EMFILE' || code === 'ENFILE' || code === 'EAGAIN' || code === 'EBUSY' || code === 'EACCESS' || code === 'EACCES' || code === 'EACCS' || code === 'EPERM') return true;
        return false;
    },
    onChangeError: (error)=>{
        if (!Handlers.isNodeError(error)) throw error;
        if (Handlers.isChangeErrorOk(error)) return;
        throw error;
    }
};
const __TURBOPACK__default__export__ = Handlers;
}),
"[project]/node_modules/stubborn-fs/dist/constants.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* IMPORT */ __turbopack_context__.s([
    "ATTEMPTIFY_CHANGE_ERROR_OPTIONS",
    ()=>ATTEMPTIFY_CHANGE_ERROR_OPTIONS,
    "ATTEMPTIFY_NOOP_OPTIONS",
    ()=>ATTEMPTIFY_NOOP_OPTIONS,
    "IS_USER_ROOT",
    ()=>IS_USER_ROOT,
    "RETRYIFY_OPTIONS",
    ()=>RETRYIFY_OPTIONS
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stubborn$2d$fs$2f$dist$2f$handlers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stubborn-fs/dist/handlers.js [app-client] (ecmascript)");
;
;
/* MAIN */ const ATTEMPTIFY_CHANGE_ERROR_OPTIONS = {
    onError: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stubborn$2d$fs$2f$dist$2f$handlers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].onChangeError
};
const ATTEMPTIFY_NOOP_OPTIONS = {
    onError: ()=>undefined
};
const IS_USER_ROOT = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getuid ? !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getuid() : false;
const RETRYIFY_OPTIONS = {
    isRetriable: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stubborn$2d$fs$2f$dist$2f$handlers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].isRetriableError
};
;
}),
"[project]/node_modules/stubborn-fs/dist/index.js [app-client] (ecmascript)", (() => {{

throw new Error("An error occurred while generating the chunk item [project]/node_modules/stubborn-fs/dist/index.js [app-client] (ecmascript)\n\nCaused by:\n- the chunking context (unknown) does not support external modules (request: node:fs)\n\nDebug info:\n- An error occurred while generating the chunk item [project]/node_modules/stubborn-fs/dist/index.js [app-client] (ecmascript)\n- Execution of <ModuleChunkItem as EcmascriptChunkItem>::content_with_async_module_info failed\n- Execution of *EcmascriptChunkItemContent::new failed\n- Execution of EcmascriptModuleContent::new failed\n- the chunking context (unknown) does not support external modules (request: node:fs)");

}}),
"[project]/node_modules/atomically/dist/constants.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* IMPORT */ __turbopack_context__.s([
    "DEFAULT_ENCODING",
    ()=>DEFAULT_ENCODING,
    "DEFAULT_FILE_MODE",
    ()=>DEFAULT_FILE_MODE,
    "DEFAULT_FOLDER_MODE",
    ()=>DEFAULT_FOLDER_MODE,
    "DEFAULT_INTERVAL_ASYNC",
    ()=>DEFAULT_INTERVAL_ASYNC,
    "DEFAULT_READ_OPTIONS",
    ()=>DEFAULT_READ_OPTIONS,
    "DEFAULT_TIMEOUT_ASYNC",
    ()=>DEFAULT_TIMEOUT_ASYNC,
    "DEFAULT_TIMEOUT_SYNC",
    ()=>DEFAULT_TIMEOUT_SYNC,
    "DEFAULT_USER_GID",
    ()=>DEFAULT_USER_GID,
    "DEFAULT_USER_UID",
    ()=>DEFAULT_USER_UID,
    "DEFAULT_WRITE_OPTIONS",
    ()=>DEFAULT_WRITE_OPTIONS,
    "IS_POSIX",
    ()=>IS_POSIX,
    "IS_USER_ROOT",
    ()=>IS_USER_ROOT,
    "LIMIT_BASENAME_LENGTH",
    ()=>LIMIT_BASENAME_LENGTH,
    "NOOP",
    ()=>NOOP
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
;
/* MAIN */ const DEFAULT_ENCODING = 'utf8';
const DEFAULT_FILE_MODE = 0o666;
const DEFAULT_FOLDER_MODE = 0o777;
const DEFAULT_READ_OPTIONS = {};
const DEFAULT_WRITE_OPTIONS = {};
const DEFAULT_USER_UID = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].geteuid ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].geteuid() : -1;
const DEFAULT_USER_GID = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getegid ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getegid() : -1;
const DEFAULT_INTERVAL_ASYNC = 200;
const DEFAULT_TIMEOUT_ASYNC = 7500;
const DEFAULT_TIMEOUT_SYNC = 1000;
const IS_POSIX = !!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getuid;
const IS_USER_ROOT = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getuid ? !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].getuid() : false;
const LIMIT_BASENAME_LENGTH = 128; //TODO: Fetch the real limit from the filesystem //TODO: Fetch the whole-path length limit too
const NOOP = ()=>{};
;
}),
"[project]/node_modules/atomically/dist/utils/lang.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* IMPORT */ /* MAIN */ __turbopack_context__.s([
    "isException",
    ()=>isException,
    "isFunction",
    ()=>isFunction,
    "isString",
    ()=>isString,
    "isUndefined",
    ()=>isUndefined
]);
const isException = (value)=>{
    return value instanceof Error && 'code' in value;
};
const isFunction = (value)=>{
    return typeof value === 'function';
};
const isString = (value)=>{
    return typeof value === 'string';
};
const isUndefined = (value)=>{
    return value === undefined;
};
;
}),
"[project]/node_modules/atomically/dist/utils/scheduler.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* IMPORT */ /* HELPERS */ __turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
const Queues = {};
/* MAIN */ //TODO: Maybe publish this as a standalone package
const Scheduler = {
    /* API */ next: (id)=>{
        const queue = Queues[id];
        if (!queue) return;
        queue.shift();
        const job = queue[0];
        if (job) {
            job(()=>Scheduler.next(id));
        } else {
            delete Queues[id];
        }
    },
    schedule: (id)=>{
        return new Promise((resolve)=>{
            let queue = Queues[id];
            if (!queue) queue = Queues[id] = [];
            queue.push(resolve);
            if (queue.length > 1) return;
            resolve(()=>Scheduler.next(id));
        });
    }
};
const __TURBOPACK__default__export__ = Scheduler;
}),
"[project]/node_modules/atomically/dist/utils/temp.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* IMPORT */ __turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$path$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/path-browserify/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stubborn$2d$fs$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/stubborn-fs/dist/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$when$2d$exit$2f$dist$2f$browser$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/when-exit/dist/browser/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$atomically$2f$dist$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/atomically/dist/constants.js [app-client] (ecmascript)");
;
;
;
;
/* MAIN */ //TODO: Maybe publish this as a standalone package
const Temp = {
    /* VARIABLES */ store: {},
    /* API */ create: (filePath)=>{
        const randomness = `000000${Math.floor(Math.random() * 16777215).toString(16)}`.slice(-6); // 6 random-enough hex characters
        const timestamp = Date.now().toString().slice(-10); // 10 precise timestamp digits
        const prefix = 'tmp-';
        const suffix = `.${prefix}${timestamp}${randomness}`;
        const tempPath = `${filePath}${suffix}`;
        return tempPath;
    },
    get: (filePath, creator, purge = true)=>{
        const tempPath = Temp.truncate(creator(filePath));
        if (tempPath in Temp.store) return Temp.get(filePath, creator, purge); // Collision found, try again
        Temp.store[tempPath] = purge;
        const disposer = ()=>delete Temp.store[tempPath];
        return [
            tempPath,
            disposer
        ];
    },
    purge: (filePath)=>{
        if (!Temp.store[filePath]) return;
        delete Temp.store[filePath];
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stubborn$2d$fs$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].attempt.unlink(filePath);
    },
    purgeSync: (filePath)=>{
        if (!Temp.store[filePath]) return;
        delete Temp.store[filePath];
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$stubborn$2d$fs$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].attempt.unlinkSync(filePath);
    },
    purgeSyncAll: ()=>{
        for(const filePath in Temp.store){
            Temp.purgeSync(filePath);
        }
    },
    truncate: (filePath)=>{
        const basename = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$path$2d$browserify$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].basename(filePath);
        if (basename.length <= __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$atomically$2f$dist$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LIMIT_BASENAME_LENGTH"]) return filePath; //FIXME: Rough and quick attempt at detecting ok lengths
        const truncable = /^(\.?)(.*?)((?:\.[^.]+)?(?:\.tmp-\d{10}[a-f0-9]{6})?)$/.exec(basename);
        if (!truncable) return filePath; //FIXME: No truncable part detected, can't really do much without also changing the parent path, which is unsafe, hoping for the best here
        const truncationLength = basename.length - __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$atomically$2f$dist$2f$constants$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LIMIT_BASENAME_LENGTH"];
        return `${filePath.slice(0, -basename.length)}${truncable[1]}${truncable[2].slice(0, -truncationLength)}${truncable[3]}`; //FIXME: The truncable part might be shorter than needed here
    }
};
/* INIT */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$when$2d$exit$2f$dist$2f$browser$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(Temp.purgeSyncAll); // Ensuring purgeable temp files are purged on exit
const __TURBOPACK__default__export__ = Temp;
}),
"[project]/node_modules/atomically/dist/index.js [app-client] (ecmascript)", (() => {{

throw new Error("An error occurred while generating the chunk item [project]/node_modules/atomically/dist/index.js [app-client] (ecmascript)\n\nCaused by:\n- the chunking context (unknown) does not support external modules (request: node:fs)\n\nDebug info:\n- An error occurred while generating the chunk item [project]/node_modules/atomically/dist/index.js [app-client] (ecmascript)\n- Execution of <ModuleChunkItem as EcmascriptChunkItem>::content_with_async_module_info failed\n- Execution of *EcmascriptChunkItemContent::new failed\n- Execution of EcmascriptModuleContent::new failed\n- the chunking context (unknown) does not support external modules (request: node:fs)");

}}),
"[project]/node_modules/when-exit/dist/browser/interceptor.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* IMPORT */ /* MAIN */ __turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
class Interceptor {
    /* CONSTRUCTOR */ constructor(){
        /* VARIABLES */ this.callbacks = new Set();
        /* API */ this.exit = ()=>{
            for (const callback of this.callbacks){
                callback();
            }
        };
        this.hook = ()=>{
            window.addEventListener('beforeunload', this.exit);
        };
        this.register = (callback)=>{
            this.callbacks.add(callback);
            return ()=>{
                this.callbacks.delete(callback);
            };
        };
        this.hook();
    }
}
const __TURBOPACK__default__export__ = new Interceptor();
}),
"[project]/node_modules/when-exit/dist/browser/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* IMPORT */ __turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$when$2d$exit$2f$dist$2f$browser$2f$interceptor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/when-exit/dist/browser/interceptor.js [app-client] (ecmascript)");
;
/* MAIN */ const whenExit = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$when$2d$exit$2f$dist$2f$browser$2f$interceptor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].register;
const __TURBOPACK__default__export__ = whenExit;
}),
"[project]/node_modules/mimic-fn/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>mimicFunction
]);
const copyProperty = (to, from, property, ignoreNonConfigurable)=>{
    // `Function#length` should reflect the parameters of `to` not `from` since we keep its body.
    // `Function#prototype` is non-writable and non-configurable so can never be modified.
    if (property === 'length' || property === 'prototype') {
        return;
    }
    // `Function#arguments` and `Function#caller` should not be copied. They were reported to be present in `Reflect.ownKeys` for some devices in React Native (#41), so we explicitly ignore them here.
    if (property === 'arguments' || property === 'caller') {
        return;
    }
    const toDescriptor = Object.getOwnPropertyDescriptor(to, property);
    const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);
    if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {
        return;
    }
    Object.defineProperty(to, property, fromDescriptor);
};
// `Object.defineProperty()` throws if the property exists, is not configurable and either:
// - one its descriptors is changed
// - it is non-writable and its value is changed
const canCopyProperty = function(toDescriptor, fromDescriptor) {
    return toDescriptor === undefined || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
};
const changePrototype = (to, from)=>{
    const fromPrototype = Object.getPrototypeOf(from);
    if (fromPrototype === Object.getPrototypeOf(to)) {
        return;
    }
    Object.setPrototypeOf(to, fromPrototype);
};
const wrappedToString = (withName, fromBody)=>`/* Wrapped ${withName}*/\n${fromBody}`;
const toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, 'toString');
const toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, 'name');
// We call `from.toString()` early (not lazily) to ensure `from` can be garbage collected.
// We use `bind()` instead of a closure for the same reason.
// Calling `from.toString()` early also allows caching it in case `to.toString()` is called several times.
const changeToString = (to, from, name)=>{
    const withName = name === '' ? '' : `with ${name.trim()}() `;
    const newToString = wrappedToString.bind(null, withName, from.toString());
    // Ensure `to.toString.toString` is non-enumerable and has the same `same`
    Object.defineProperty(newToString, 'name', toStringName);
    Object.defineProperty(to, 'toString', {
        ...toStringDescriptor,
        value: newToString
    });
};
function mimicFunction(to, from, { ignoreNonConfigurable = false } = {}) {
    const { name } = to;
    for (const property of Reflect.ownKeys(from)){
        copyProperty(to, from, property, ignoreNonConfigurable);
    }
    changePrototype(to, from);
    changeToString(to, from, name);
    return to;
}
}),
"[project]/node_modules/debounce-fn/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mimic$2d$fn$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mimic-fn/index.js [app-client] (ecmascript)");
;
const debounceFn = (inputFunction, options = {})=>{
    if (typeof inputFunction !== 'function') {
        throw new TypeError(`Expected the first argument to be a function, got \`${typeof inputFunction}\``);
    }
    const { wait = 0, maxWait = Number.POSITIVE_INFINITY, before = false, after = true } = options;
    if (!before && !after) {
        throw new Error('Both `before` and `after` are false, function wouldn\'t be called.');
    }
    let timeout;
    let maxTimeout;
    let result;
    const debouncedFunction = function(...arguments_) {
        const context = this; // eslint-disable-line unicorn/no-this-assignment
        const later = ()=>{
            timeout = undefined;
            if (maxTimeout) {
                clearTimeout(maxTimeout);
                maxTimeout = undefined;
            }
            if (after) {
                result = inputFunction.apply(context, arguments_);
            }
        };
        const maxLater = ()=>{
            maxTimeout = undefined;
            if (timeout) {
                clearTimeout(timeout);
                timeout = undefined;
            }
            if (after) {
                result = inputFunction.apply(context, arguments_);
            }
        };
        const shouldCallNow = before && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (maxWait > 0 && maxWait !== Number.POSITIVE_INFINITY && !maxTimeout) {
            maxTimeout = setTimeout(maxLater, maxWait);
        }
        if (shouldCallNow) {
            result = inputFunction.apply(context, arguments_);
        }
        return result;
    };
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mimic$2d$fn$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(debouncedFunction, inputFunction);
    debouncedFunction.cancel = ()=>{
        if (timeout) {
            clearTimeout(timeout);
            timeout = undefined;
        }
        if (maxTimeout) {
            clearTimeout(maxTimeout);
            maxTimeout = undefined;
        }
    };
    return debouncedFunction;
};
const __TURBOPACK__default__export__ = debounceFn;
}),
]);

//# sourceMappingURL=node_modules_c32f6296._.js.map