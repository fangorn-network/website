{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/unixfs/src/api.js"],"sourcesContent":["// @ts-nocheck\n\n/**\n * This is file is shadowed by api.ts and only exists so JS could import it to\n * refer to types without encountering runtime errors\n * @see https://github.com/microsoft/TypeScript/issues/41825\n */\n"],"names":[],"mappings":"AAAA,cAAc;AAEd;;;;CAIC","ignoreList":[0]}},
    {"offset": {"line": 14, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/unixfs/src/file/api.js"],"sourcesContent":["// @ts-nocheck\n\n/**\n * This is file is shadowed by api.ts and only exists so JS could import it to\n * refer to types without encountering runtime errors\n * @see https://github.com/microsoft/TypeScript/issues/41825\n */\n"],"names":[],"mappings":"AAAA,cAAc;AAEd;;;;CAIC","ignoreList":[0]}},
    {"offset": {"line": 24, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/unixfs/gen/unixfs.js"],"sourcesContent":["/*eslint-disable*/\nimport $protobuf from \"protobufjs/minimal.js\";\n\n// Common aliases\nconst $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;\n\n// Exported root namespace\nconst $root = $protobuf.roots.unixfs || ($protobuf.roots.unixfs = {});\n\nexport const Data = $root.Data = (() => {\n\n    /**\n     * Properties of a Data.\n     * @exports IData\n     * @interface IData\n     * @property {Data.DataType} Type Data Type\n     * @property {Uint8Array|null} [Data] Data Data\n     * @property {number|null} [filesize] Data filesize\n     * @property {Array.<number>|null} [blocksizes] Data blocksizes\n     * @property {number|null} [hashType] Data hashType\n     * @property {number|null} [fanout] Data fanout\n     * @property {number|null} [mode] Data mode\n     * @property {IUnixTime|null} [mtime] Data mtime\n     */\n\n    /**\n     * Constructs a new Data.\n     * @exports Data\n     * @classdesc Represents a Data.\n     * @implements IData\n     * @constructor\n     * @param {IData=} [p] Properties to set\n     */\n    function Data(p) {\n        this.blocksizes = [];\n        if (p)\n            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                if (p[ks[i]] != null)\n                    this[ks[i]] = p[ks[i]];\n    }\n\n    /**\n     * Data Type.\n     * @member {Data.DataType} Type\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.Type = 0;\n\n    /**\n     * Data Data.\n     * @member {Uint8Array} Data\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.Data = $util.newBuffer([]);\n\n    /**\n     * Data filesize.\n     * @member {number} filesize\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.filesize = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * Data blocksizes.\n     * @member {Array.<number>} blocksizes\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.blocksizes = $util.emptyArray;\n\n    /**\n     * Data hashType.\n     * @member {number} hashType\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.hashType = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * Data fanout.\n     * @member {number} fanout\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.fanout = $util.Long ? $util.Long.fromBits(0,0,true) : 0;\n\n    /**\n     * Data mode.\n     * @member {number} mode\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.mode = 0;\n\n    /**\n     * Data mtime.\n     * @member {IUnixTime|null|undefined} mtime\n     * @memberof Data\n     * @instance\n     */\n    Data.prototype.mtime = null;\n\n    /**\n     * Encodes the specified Data message. Does not implicitly {@link Data.verify|verify} messages.\n     * @function encode\n     * @memberof Data\n     * @static\n     * @param {IData} m Data message or plain object to encode\n     * @param {$protobuf.Writer} [w] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Data.encode = function encode(m, w) {\n        if (!w)\n            w = $Writer.create();\n        w.uint32(8).int32(m.Type);\n        if (m.Data != null && Object.hasOwnProperty.call(m, \"Data\"))\n            w.uint32(18).bytes(m.Data);\n        if (m.filesize != null && Object.hasOwnProperty.call(m, \"filesize\"))\n            w.uint32(24).uint64(m.filesize);\n        if (m.blocksizes != null && m.blocksizes.length) {\n            for (var i = 0; i < m.blocksizes.length; ++i)\n                w.uint32(32).uint64(m.blocksizes[i]);\n        }\n        if (m.hashType != null && Object.hasOwnProperty.call(m, \"hashType\"))\n            w.uint32(40).uint64(m.hashType);\n        if (m.fanout != null && Object.hasOwnProperty.call(m, \"fanout\"))\n            w.uint32(48).uint64(m.fanout);\n        if (m.mode != null && Object.hasOwnProperty.call(m, \"mode\"))\n            w.uint32(56).uint32(m.mode);\n        if (m.mtime != null && Object.hasOwnProperty.call(m, \"mtime\"))\n            $root.UnixTime.encode(m.mtime, w.uint32(66).fork()).ldelim();\n        return w;\n    };\n\n    /**\n     * Decodes a Data message from the specified reader or buffer.\n     * @function decode\n     * @memberof Data\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n     * @param {number} [l] Message length if known beforehand\n     * @returns {Data} Data\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Data.decode = function decode(r, l) {\n        if (!(r instanceof $Reader))\n            r = $Reader.create(r);\n        var c = l === undefined ? r.len : r.pos + l, m = new $root.Data();\n        while (r.pos < c) {\n            var t = r.uint32();\n            switch (t >>> 3) {\n            case 1:\n                m.Type = r.int32();\n                break;\n            case 2:\n                m.Data = r.bytes();\n                break;\n            case 3:\n                m.filesize = r.uint64();\n                break;\n            case 4:\n                if (!(m.blocksizes && m.blocksizes.length))\n                    m.blocksizes = [];\n                if ((t & 7) === 2) {\n                    var c2 = r.uint32() + r.pos;\n                    while (r.pos < c2)\n                        m.blocksizes.push(r.uint64());\n                } else\n                    m.blocksizes.push(r.uint64());\n                break;\n            case 5:\n                m.hashType = r.uint64();\n                break;\n            case 6:\n                m.fanout = r.uint64();\n                break;\n            case 7:\n                m.mode = r.uint32();\n                break;\n            case 8:\n                m.mtime = $root.UnixTime.decode(r, r.uint32());\n                break;\n            default:\n                r.skipType(t & 7);\n                break;\n            }\n        }\n        if (!m.hasOwnProperty(\"Type\"))\n            throw $util.ProtocolError(\"missing required 'Type'\", { instance: m });\n        return m;\n    };\n\n    /**\n     * Creates a Data message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Data\n     * @static\n     * @param {Object.<string,*>} d Plain object\n     * @returns {Data} Data\n     */\n    Data.fromObject = function fromObject(d) {\n        if (d instanceof $root.Data)\n            return d;\n        var m = new $root.Data();\n        switch (d.Type) {\n        case \"Raw\":\n        case 0:\n            m.Type = 0;\n            break;\n        case \"Directory\":\n        case 1:\n            m.Type = 1;\n            break;\n        case \"File\":\n        case 2:\n            m.Type = 2;\n            break;\n        case \"Metadata\":\n        case 3:\n            m.Type = 3;\n            break;\n        case \"Symlink\":\n        case 4:\n            m.Type = 4;\n            break;\n        case \"HAMTShard\":\n        case 5:\n            m.Type = 5;\n            break;\n        }\n        if (d.Data != null) {\n            if (typeof d.Data === \"string\")\n                $util.base64.decode(d.Data, m.Data = $util.newBuffer($util.base64.length(d.Data)), 0);\n            else if (d.Data.length)\n                m.Data = d.Data;\n        }\n        if (d.filesize != null) {\n            if ($util.Long)\n                (m.filesize = $util.Long.fromValue(d.filesize)).unsigned = true;\n            else if (typeof d.filesize === \"string\")\n                m.filesize = parseInt(d.filesize, 10);\n            else if (typeof d.filesize === \"number\")\n                m.filesize = d.filesize;\n            else if (typeof d.filesize === \"object\")\n                m.filesize = new $util.LongBits(d.filesize.low >>> 0, d.filesize.high >>> 0).toNumber(true);\n        }\n        if (d.blocksizes) {\n            if (!Array.isArray(d.blocksizes))\n                throw TypeError(\".Data.blocksizes: array expected\");\n            m.blocksizes = [];\n            for (var i = 0; i < d.blocksizes.length; ++i) {\n                if ($util.Long)\n                    (m.blocksizes[i] = $util.Long.fromValue(d.blocksizes[i])).unsigned = true;\n                else if (typeof d.blocksizes[i] === \"string\")\n                    m.blocksizes[i] = parseInt(d.blocksizes[i], 10);\n                else if (typeof d.blocksizes[i] === \"number\")\n                    m.blocksizes[i] = d.blocksizes[i];\n                else if (typeof d.blocksizes[i] === \"object\")\n                    m.blocksizes[i] = new $util.LongBits(d.blocksizes[i].low >>> 0, d.blocksizes[i].high >>> 0).toNumber(true);\n            }\n        }\n        if (d.hashType != null) {\n            if ($util.Long)\n                (m.hashType = $util.Long.fromValue(d.hashType)).unsigned = true;\n            else if (typeof d.hashType === \"string\")\n                m.hashType = parseInt(d.hashType, 10);\n            else if (typeof d.hashType === \"number\")\n                m.hashType = d.hashType;\n            else if (typeof d.hashType === \"object\")\n                m.hashType = new $util.LongBits(d.hashType.low >>> 0, d.hashType.high >>> 0).toNumber(true);\n        }\n        if (d.fanout != null) {\n            if ($util.Long)\n                (m.fanout = $util.Long.fromValue(d.fanout)).unsigned = true;\n            else if (typeof d.fanout === \"string\")\n                m.fanout = parseInt(d.fanout, 10);\n            else if (typeof d.fanout === \"number\")\n                m.fanout = d.fanout;\n            else if (typeof d.fanout === \"object\")\n                m.fanout = new $util.LongBits(d.fanout.low >>> 0, d.fanout.high >>> 0).toNumber(true);\n        }\n        if (d.mode != null) {\n            m.mode = d.mode >>> 0;\n        }\n        if (d.mtime != null) {\n            if (typeof d.mtime !== \"object\")\n                throw TypeError(\".Data.mtime: object expected\");\n            m.mtime = $root.UnixTime.fromObject(d.mtime);\n        }\n        return m;\n    };\n\n    /**\n     * Creates a plain object from a Data message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Data\n     * @static\n     * @param {Data} m Data\n     * @param {$protobuf.IConversionOptions} [o] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Data.toObject = function toObject(m, o) {\n        if (!o)\n            o = {};\n        var d = {};\n        if (o.arrays || o.defaults) {\n            d.blocksizes = [];\n        }\n        if (o.defaults) {\n            d.Type = o.enums === String ? \"Raw\" : 0;\n            if (o.bytes === String)\n                d.Data = \"\";\n            else {\n                d.Data = [];\n                if (o.bytes !== Array)\n                    d.Data = $util.newBuffer(d.Data);\n            }\n            if ($util.Long) {\n                var n = new $util.Long(0, 0, true);\n                d.filesize = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;\n            } else\n                d.filesize = o.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n                var n = new $util.Long(0, 0, true);\n                d.hashType = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;\n            } else\n                d.hashType = o.longs === String ? \"0\" : 0;\n            if ($util.Long) {\n                var n = new $util.Long(0, 0, true);\n                d.fanout = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;\n            } else\n                d.fanout = o.longs === String ? \"0\" : 0;\n            d.mode = 0;\n            d.mtime = null;\n        }\n        if (m.Type != null && m.hasOwnProperty(\"Type\")) {\n            d.Type = o.enums === String ? $root.Data.DataType[m.Type] : m.Type;\n        }\n        if (m.Data != null && m.hasOwnProperty(\"Data\")) {\n            d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;\n        }\n        if (m.filesize != null && m.hasOwnProperty(\"filesize\")) {\n            if (typeof m.filesize === \"number\")\n                d.filesize = o.longs === String ? String(m.filesize) : m.filesize;\n            else\n                d.filesize = o.longs === String ? $util.Long.prototype.toString.call(m.filesize) : o.longs === Number ? new $util.LongBits(m.filesize.low >>> 0, m.filesize.high >>> 0).toNumber(true) : m.filesize;\n        }\n        if (m.blocksizes && m.blocksizes.length) {\n            d.blocksizes = [];\n            for (var j = 0; j < m.blocksizes.length; ++j) {\n                if (typeof m.blocksizes[j] === \"number\")\n                    d.blocksizes[j] = o.longs === String ? String(m.blocksizes[j]) : m.blocksizes[j];\n                else\n                    d.blocksizes[j] = o.longs === String ? $util.Long.prototype.toString.call(m.blocksizes[j]) : o.longs === Number ? new $util.LongBits(m.blocksizes[j].low >>> 0, m.blocksizes[j].high >>> 0).toNumber(true) : m.blocksizes[j];\n            }\n        }\n        if (m.hashType != null && m.hasOwnProperty(\"hashType\")) {\n            if (typeof m.hashType === \"number\")\n                d.hashType = o.longs === String ? String(m.hashType) : m.hashType;\n            else\n                d.hashType = o.longs === String ? $util.Long.prototype.toString.call(m.hashType) : o.longs === Number ? new $util.LongBits(m.hashType.low >>> 0, m.hashType.high >>> 0).toNumber(true) : m.hashType;\n        }\n        if (m.fanout != null && m.hasOwnProperty(\"fanout\")) {\n            if (typeof m.fanout === \"number\")\n                d.fanout = o.longs === String ? String(m.fanout) : m.fanout;\n            else\n                d.fanout = o.longs === String ? $util.Long.prototype.toString.call(m.fanout) : o.longs === Number ? new $util.LongBits(m.fanout.low >>> 0, m.fanout.high >>> 0).toNumber(true) : m.fanout;\n        }\n        if (m.mode != null && m.hasOwnProperty(\"mode\")) {\n            d.mode = m.mode;\n        }\n        if (m.mtime != null && m.hasOwnProperty(\"mtime\")) {\n            d.mtime = $root.UnixTime.toObject(m.mtime, o);\n        }\n        return d;\n    };\n\n    /**\n     * Converts this Data to JSON.\n     * @function toJSON\n     * @memberof Data\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Data.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    /**\n     * DataType enum.\n     * @name Data.DataType\n     * @enum {number}\n     * @property {number} Raw=0 Raw value\n     * @property {number} Directory=1 Directory value\n     * @property {number} File=2 File value\n     * @property {number} Metadata=3 Metadata value\n     * @property {number} Symlink=4 Symlink value\n     * @property {number} HAMTShard=5 HAMTShard value\n     */\n    Data.DataType = (function() {\n        const valuesById = {}, values = Object.create(valuesById);\n        values[valuesById[0] = \"Raw\"] = 0;\n        values[valuesById[1] = \"Directory\"] = 1;\n        values[valuesById[2] = \"File\"] = 2;\n        values[valuesById[3] = \"Metadata\"] = 3;\n        values[valuesById[4] = \"Symlink\"] = 4;\n        values[valuesById[5] = \"HAMTShard\"] = 5;\n        return values;\n    })();\n\n    return Data;\n})();\n\nexport const UnixTime = $root.UnixTime = (() => {\n\n    /**\n     * Properties of an UnixTime.\n     * @exports IUnixTime\n     * @interface IUnixTime\n     * @property {number} Seconds UnixTime Seconds\n     * @property {number|null} [FractionalNanoseconds] UnixTime FractionalNanoseconds\n     */\n\n    /**\n     * Constructs a new UnixTime.\n     * @exports UnixTime\n     * @classdesc Represents an UnixTime.\n     * @implements IUnixTime\n     * @constructor\n     * @param {IUnixTime=} [p] Properties to set\n     */\n    function UnixTime(p) {\n        if (p)\n            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                if (p[ks[i]] != null)\n                    this[ks[i]] = p[ks[i]];\n    }\n\n    /**\n     * UnixTime Seconds.\n     * @member {number} Seconds\n     * @memberof UnixTime\n     * @instance\n     */\n    UnixTime.prototype.Seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;\n\n    /**\n     * UnixTime FractionalNanoseconds.\n     * @member {number} FractionalNanoseconds\n     * @memberof UnixTime\n     * @instance\n     */\n    UnixTime.prototype.FractionalNanoseconds = 0;\n\n    /**\n     * Encodes the specified UnixTime message. Does not implicitly {@link UnixTime.verify|verify} messages.\n     * @function encode\n     * @memberof UnixTime\n     * @static\n     * @param {IUnixTime} m UnixTime message or plain object to encode\n     * @param {$protobuf.Writer} [w] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    UnixTime.encode = function encode(m, w) {\n        if (!w)\n            w = $Writer.create();\n        w.uint32(8).int64(m.Seconds);\n        if (m.FractionalNanoseconds != null && Object.hasOwnProperty.call(m, \"FractionalNanoseconds\"))\n            w.uint32(21).fixed32(m.FractionalNanoseconds);\n        return w;\n    };\n\n    /**\n     * Decodes an UnixTime message from the specified reader or buffer.\n     * @function decode\n     * @memberof UnixTime\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n     * @param {number} [l] Message length if known beforehand\n     * @returns {UnixTime} UnixTime\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    UnixTime.decode = function decode(r, l) {\n        if (!(r instanceof $Reader))\n            r = $Reader.create(r);\n        var c = l === undefined ? r.len : r.pos + l, m = new $root.UnixTime();\n        while (r.pos < c) {\n            var t = r.uint32();\n            switch (t >>> 3) {\n            case 1:\n                m.Seconds = r.int64();\n                break;\n            case 2:\n                m.FractionalNanoseconds = r.fixed32();\n                break;\n            default:\n                r.skipType(t & 7);\n                break;\n            }\n        }\n        if (!m.hasOwnProperty(\"Seconds\"))\n            throw $util.ProtocolError(\"missing required 'Seconds'\", { instance: m });\n        return m;\n    };\n\n    /**\n     * Creates an UnixTime message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof UnixTime\n     * @static\n     * @param {Object.<string,*>} d Plain object\n     * @returns {UnixTime} UnixTime\n     */\n    UnixTime.fromObject = function fromObject(d) {\n        if (d instanceof $root.UnixTime)\n            return d;\n        var m = new $root.UnixTime();\n        if (d.Seconds != null) {\n            if ($util.Long)\n                (m.Seconds = $util.Long.fromValue(d.Seconds)).unsigned = false;\n            else if (typeof d.Seconds === \"string\")\n                m.Seconds = parseInt(d.Seconds, 10);\n            else if (typeof d.Seconds === \"number\")\n                m.Seconds = d.Seconds;\n            else if (typeof d.Seconds === \"object\")\n                m.Seconds = new $util.LongBits(d.Seconds.low >>> 0, d.Seconds.high >>> 0).toNumber();\n        }\n        if (d.FractionalNanoseconds != null) {\n            m.FractionalNanoseconds = d.FractionalNanoseconds >>> 0;\n        }\n        return m;\n    };\n\n    /**\n     * Creates a plain object from an UnixTime message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof UnixTime\n     * @static\n     * @param {UnixTime} m UnixTime\n     * @param {$protobuf.IConversionOptions} [o] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    UnixTime.toObject = function toObject(m, o) {\n        if (!o)\n            o = {};\n        var d = {};\n        if (o.defaults) {\n            if ($util.Long) {\n                var n = new $util.Long(0, 0, false);\n                d.Seconds = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;\n            } else\n                d.Seconds = o.longs === String ? \"0\" : 0;\n            d.FractionalNanoseconds = 0;\n        }\n        if (m.Seconds != null && m.hasOwnProperty(\"Seconds\")) {\n            if (typeof m.Seconds === \"number\")\n                d.Seconds = o.longs === String ? String(m.Seconds) : m.Seconds;\n            else\n                d.Seconds = o.longs === String ? $util.Long.prototype.toString.call(m.Seconds) : o.longs === Number ? new $util.LongBits(m.Seconds.low >>> 0, m.Seconds.high >>> 0).toNumber() : m.Seconds;\n        }\n        if (m.FractionalNanoseconds != null && m.hasOwnProperty(\"FractionalNanoseconds\")) {\n            d.FractionalNanoseconds = m.FractionalNanoseconds;\n        }\n        return d;\n    };\n\n    /**\n     * Converts this UnixTime to JSON.\n     * @function toJSON\n     * @memberof UnixTime\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    UnixTime.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return UnixTime;\n})();\n\nexport const Metadata = $root.Metadata = (() => {\n\n    /**\n     * Properties of a Metadata.\n     * @exports IMetadata\n     * @interface IMetadata\n     * @property {string|null} [MimeType] Metadata MimeType\n     */\n\n    /**\n     * Constructs a new Metadata.\n     * @exports Metadata\n     * @classdesc Represents a Metadata.\n     * @implements IMetadata\n     * @constructor\n     * @param {IMetadata=} [p] Properties to set\n     */\n    function Metadata(p) {\n        if (p)\n            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)\n                if (p[ks[i]] != null)\n                    this[ks[i]] = p[ks[i]];\n    }\n\n    /**\n     * Metadata MimeType.\n     * @member {string} MimeType\n     * @memberof Metadata\n     * @instance\n     */\n    Metadata.prototype.MimeType = \"\";\n\n    /**\n     * Encodes the specified Metadata message. Does not implicitly {@link Metadata.verify|verify} messages.\n     * @function encode\n     * @memberof Metadata\n     * @static\n     * @param {IMetadata} m Metadata message or plain object to encode\n     * @param {$protobuf.Writer} [w] Writer to encode to\n     * @returns {$protobuf.Writer} Writer\n     */\n    Metadata.encode = function encode(m, w) {\n        if (!w)\n            w = $Writer.create();\n        if (m.MimeType != null && Object.hasOwnProperty.call(m, \"MimeType\"))\n            w.uint32(10).string(m.MimeType);\n        return w;\n    };\n\n    /**\n     * Decodes a Metadata message from the specified reader or buffer.\n     * @function decode\n     * @memberof Metadata\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} r Reader or buffer to decode from\n     * @param {number} [l] Message length if known beforehand\n     * @returns {Metadata} Metadata\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    Metadata.decode = function decode(r, l) {\n        if (!(r instanceof $Reader))\n            r = $Reader.create(r);\n        var c = l === undefined ? r.len : r.pos + l, m = new $root.Metadata();\n        while (r.pos < c) {\n            var t = r.uint32();\n            switch (t >>> 3) {\n            case 1:\n                m.MimeType = r.string();\n                break;\n            default:\n                r.skipType(t & 7);\n                break;\n            }\n        }\n        return m;\n    };\n\n    /**\n     * Creates a Metadata message from a plain object. Also converts values to their respective internal types.\n     * @function fromObject\n     * @memberof Metadata\n     * @static\n     * @param {Object.<string,*>} d Plain object\n     * @returns {Metadata} Metadata\n     */\n    Metadata.fromObject = function fromObject(d) {\n        if (d instanceof $root.Metadata)\n            return d;\n        var m = new $root.Metadata();\n        if (d.MimeType != null) {\n            m.MimeType = String(d.MimeType);\n        }\n        return m;\n    };\n\n    /**\n     * Creates a plain object from a Metadata message. Also converts values to other types if specified.\n     * @function toObject\n     * @memberof Metadata\n     * @static\n     * @param {Metadata} m Metadata\n     * @param {$protobuf.IConversionOptions} [o] Conversion options\n     * @returns {Object.<string,*>} Plain object\n     */\n    Metadata.toObject = function toObject(m, o) {\n        if (!o)\n            o = {};\n        var d = {};\n        if (o.defaults) {\n            d.MimeType = \"\";\n        }\n        if (m.MimeType != null && m.hasOwnProperty(\"MimeType\")) {\n            d.MimeType = m.MimeType;\n        }\n        return d;\n    };\n\n    /**\n     * Converts this Metadata to JSON.\n     * @function toJSON\n     * @memberof Metadata\n     * @instance\n     * @returns {Object.<string,*>} JSON object\n     */\n    Metadata.prototype.toJSON = function toJSON() {\n        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);\n    };\n\n    return Metadata;\n})();\n\nexport { $root as default };\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 616, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/unixfs/src/unixfs.js"],"sourcesContent":["// @ts-nocheck\n\n/**\n * This is file is shadowed by api.ts and only exists so JS could import it to\n * refer to types without encountering runtime errors\n * @see https://github.com/microsoft/TypeScript/issues/41825\n */\n\nimport { Data } from \"../gen/unixfs.js\"\nexport const NodeType = Data.DataType\n"],"names":[],"mappings":"AAAA,cAAc;AAEd;;;;CAIC;;;;AAED;;AACO,MAAM,WAAW,4JAAI,CAAC,QAAQ","ignoreList":[0]}},
    {"offset": {"line": 632, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/unixfs/src/codec.js"],"sourcesContent":["import * as PB from \"@ipld/dag-pb\"\nimport * as UnixFS from \"./unixfs.js\"\nimport { NodeType } from \"./unixfs.js\"\nimport { Data } from \"../gen/unixfs.js\"\n\nexport * from \"./unixfs.js\"\n\n/** @type {ReadonlyArray<any>} */\nconst EMPTY = Object.freeze([])\nconst EMPTY_BUFFER = new Uint8Array(0)\n\nconst BLANK = Object.freeze({})\nexport const DEFAULT_FILE_MODE = parseInt(\"0644\", 8)\nexport const DEFAULT_DIRECTORY_MODE = parseInt(\"0755\", 8)\n\nexport const code = PB.code\nexport const name = \"UnixFS\"\n\n/**\n * @param {UnixFS.IData} data\n * @param {ReadonlyArray<UnixFS.PBLink>} links\n */\nconst encodePB = (data, links) => {\n  Object(globalThis).debug && console.log({ data, links })\n\n  return PB.encode(\n    // We run through prepare as links need to be sorted by name which it will\n    // do.\n    PB.prepare({\n      Data: Data.encode(data).finish(),\n      // We can cast to mutable array as we know no mutation occurs there\n      Links:\n        /** @type {PB.PBLink[]} */ (links),\n    })\n  )\n}\n\n/**\n * @param {Uint8Array} content\n * @returns {UnixFS.Raw}\n */\nexport const createRaw = content => ({\n  type: NodeType.Raw,\n  content,\n})\n\n/**\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.SimpleFile}\n */\nexport const createEmptyFile = metadata =>\n  createSimpleFile(EMPTY_BUFFER, metadata)\n\n/**\n * @param {Uint8Array} content\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.SimpleFile}\n */\nexport const createSimpleFile = (content, metadata) => ({\n  type: NodeType.File,\n  layout: \"simple\",\n  content,\n  metadata: decodeMetadata(metadata),\n})\n\n/**\n * @param {Uint8Array} content\n * @returns {UnixFS.FileChunk}\n */\nexport const createFileChunk = content => ({\n  type: NodeType.File,\n  layout: \"simple\",\n  content,\n})\n\n/**\n * @param {UnixFS.FileLink[]} parts\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.AdvancedFile}\n */\nexport const createAdvancedFile = (parts, metadata) => ({\n  type: NodeType.File,\n  layout: \"advanced\",\n  parts,\n  metadata: decodeMetadata(metadata),\n})\n\n/**\n * @param {UnixFS.FileLink[]} parts\n * @returns {UnixFS.FileShard}\n */\nexport const createFileShard = parts => ({\n  type: NodeType.File,\n  layout: \"advanced\",\n  parts,\n})\n\n/**\n * @deprecated\n * @param {Uint8Array} content\n * @param {UnixFS.FileLink[]} parts\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.ComplexFile}\n */\nexport const createComplexFile = (content, parts, metadata) => ({\n  type: NodeType.File,\n  layout: \"complex\",\n  content,\n  parts,\n  metadata: decodeMetadata(metadata),\n})\n\n/**\n * @param {UnixFS.DirectoryEntryLink[]} entries\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.FlatDirectory}\n */\nexport const createFlatDirectory = (entries, metadata) => ({\n  type: NodeType.Directory,\n  metadata: decodeMetadata(metadata),\n  entries,\n})\n\n/**\n * @param {UnixFS.ShardedDirectoryLink[]} entries\n * @param {Uint8Array} bitfield\n * @param {number} fanout\n * @param {number} hashType\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.ShardedDirectory}\n */\nexport const createShardedDirectory = (\n  entries,\n  bitfield,\n  fanout,\n  hashType,\n  metadata = BLANK\n) => ({\n  type: NodeType.HAMTShard,\n  bitfield,\n  fanout: readFanout(fanout),\n  hashType: readInt(hashType),\n  entries,\n  metadata: decodeMetadata(metadata),\n})\n\n/**\n * @param {UnixFS.ShardedDirectoryLink[]} entries\n * @param {Uint8Array} bitfield\n * @param {number} fanout\n * @param {number} hashType\n * @returns {UnixFS.DirectoryShard}\n */\nexport const createDirectoryShard = (entries, bitfield, fanout, hashType) => ({\n  type: NodeType.HAMTShard,\n  bitfield,\n  fanout: readFanout(fanout),\n  hashType: readInt(hashType),\n  entries,\n})\n\n/**\n *\n * @param {Uint8Array} content\n * @returns {UnixFS.ByteView<UnixFS.Raw>}\n */\nexport const encodeRaw = content =>\n  encodePB(\n    {\n      Type: NodeType.Raw,\n      // TODO:\n      Data: content.byteLength > 0 ? content : undefined,\n      filesize: content.byteLength,\n      // @ts-ignore\n      blocksizes: EMPTY,\n    },\n    []\n  )\n\n/**\n * @param {UnixFS.File|UnixFS.FileChunk|UnixFS.FileShard} node\n * @param {boolean} [ignoreMetadata]\n * @returns {UnixFS.ByteView<UnixFS.SimpleFile|UnixFS.AdvancedFile|UnixFS.ComplexFile>}\n */\nexport const encodeFile = (node, ignoreMetadata = false) => {\n  const metadata = ignoreMetadata ? BLANK : Object(node).metadata\n  switch (node.layout) {\n    case \"simple\":\n      return encodeSimpleFile(node.content, metadata)\n    case \"advanced\":\n      return encodeAdvancedFile(node.parts, metadata)\n    case \"complex\":\n      return encodeComplexFile(node.content, node.parts, metadata)\n    default:\n      throw new TypeError(\n        `File with unknown layout \"${Object(node).layout}\" was passed`\n      )\n  }\n}\n\n/**\n * @param {Uint8Array} content\n * @returns {UnixFS.ByteView<UnixFS.FileChunk>}\n */\nexport const encodeFileChunk = content => encodeSimpleFile(content, BLANK)\n\n/**\n * @param {ReadonlyArray<UnixFS.FileLink>} parts\n * @returns {UnixFS.ByteView<UnixFS.FileShard>}\n */\nexport const encodeFileShard = parts =>\n  encodePB(\n    {\n      Type: NodeType.File,\n      blocksizes: parts.map(contentByteLength),\n      filesize: cumulativeContentByteLength(parts),\n    },\n    parts.map(encodeLink)\n  )\n\n/**\n * @param {ReadonlyArray<UnixFS.FileLink>} parts\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.ByteView<UnixFS.AdvancedFile>}\n */\nexport const encodeAdvancedFile = (parts, metadata = BLANK) =>\n  encodePB(\n    {\n      Type: NodeType.File,\n      blocksizes: parts.map(contentByteLength),\n      filesize: cumulativeContentByteLength(parts),\n\n      ...encodeMetadata(metadata),\n    },\n    parts.map(encodeLink)\n  )\n\n/**\n * @param {UnixFS.DAGLink} dag\n * @returns {UnixFS.PBLink}\n */\nexport const encodeLink = dag => ({\n  Name: \"\",\n  Tsize: dag.dagByteLength,\n  // @ts-ignore - @see https://github.com/multiformats/js-multiformats/pull/161\n  Hash: dag.cid,\n})\n\n/**\n * @param {Uint8Array} content\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.ByteView<UnixFS.SimpleFile>}\n */\n\nexport const encodeSimpleFile = (content, metadata = BLANK) =>\n  encodePB(\n    {\n      Type: NodeType.File,\n      // adding empty file to both go-ipfs and js-ipfs produces block in\n      // which `Data` is omitted but filesize and blocksizes are present.\n      // For the sake of hash consistency we do the same.\n      Data: content.byteLength > 0 ? content : undefined,\n      filesize: content.byteLength,\n      blocksizes: [],\n      ...encodeMetadata(metadata),\n    },\n    []\n  )\n\n/**\n *\n * @param {Uint8Array} content\n * @param {ReadonlyArray<UnixFS.FileLink>} parts\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.ByteView<UnixFS.ComplexFile>}\n */\nexport const encodeComplexFile = (content, parts, metadata = BLANK) =>\n  encodePB(\n    {\n      Type: NodeType.File,\n      Data: content,\n      filesize: content.byteLength + cumulativeContentByteLength(parts),\n      blocksizes: parts.map(contentByteLength),\n    },\n    parts.map(encodeLink)\n  )\n\n/**\n * @param {UnixFS.FlatDirectory} node\n * @returns {UnixFS.ByteView<UnixFS.FlatDirectory>}\n */\nexport const encodeDirectory = node =>\n  encodePB(\n    {\n      Type: node.type,\n      ...encodeDirectoryMetadata(node.metadata || BLANK),\n    },\n    node.entries.map(encodeNamedLink)\n  )\n\n/**\n * @param {UnixFS.ShardedDirectory|UnixFS.DirectoryShard} node\n * @returns {UnixFS.ByteView<UnixFS.ShardedDirectory>}\n */\nexport const encodeHAMTShard = ({\n  bitfield,\n  fanout,\n  hashType,\n  entries,\n  metadata = BLANK,\n}) =>\n  encodePB(\n    {\n      Type: NodeType.HAMTShard,\n      Data: bitfield.byteLength > 0 ? bitfield : undefined,\n      fanout: readFanout(fanout),\n      hashType: readInt(hashType),\n\n      ...encodeDirectoryMetadata(metadata),\n    },\n    entries.map(encodeNamedLink)\n  )\n\n/**\n * @param {number} n\n * @returns {number}\n */\nconst readFanout = n => {\n  if (Math.log2(n) % 1 === 0) {\n    return n\n  } else {\n    throw new TypeError(\n      `Expected hamt size to be a power of two instead got ${n}`\n    )\n  }\n}\n\n/**\n * @param {number} n\n * @returns {number}\n */\n\nconst readInt = n => {\n  if (Number.isInteger(n)) {\n    return n\n  } else {\n    throw new TypeError(`Expected an integer value instead got ${n}`)\n  }\n}\n\n/**\n * @param {Uint8Array} bytes\n */\nconst readData = bytes => (bytes.byteLength > 0 ? bytes : undefined)\n\n/**\n * @param {Uint8Array} path\n * @param {UnixFS.Metadata} [metadata]\n * @returns {UnixFS.Symlink}\n */\nexport const createSymlink = (path, metadata = BLANK) => ({\n  type: NodeType.Symlink,\n  content: path,\n  metadata: decodeMetadata(metadata),\n})\n\n/**\n * @param {UnixFS.Symlink} node\n * @param {boolean} [ignoreMetadata]\n * @returns {UnixFS.ByteView<UnixFS.Symlink>}\n */\nexport const encodeSymlink = (node, ignoreMetadata = false) => {\n  const metadata = ignoreMetadata ? BLANK : Object(node).metadata\n  // We do not include filesize on symlinks because that is what go-ipfs does\n  // when doing `ipfs add mysymlink`. js-ipfs on the other hand seems to store\n  // it, here we choose to follow go-ipfs\n  // @see https://explore.ipld.io/#/explore/QmPZ1CTc5fYErTH2XXDGrfsPsHicYXtkZeVojGycwAfm3v\n  // @see https://github.com/ipfs/js-ipfs-unixfs/issues/195\n  return encodePB(\n    {\n      Type: NodeType.Symlink,\n      Data: node.content,\n      ...encodeMetadata(metadata || BLANK),\n    },\n    []\n  )\n}\n\n/**\n * @template {UnixFS.Node} T\n * @param {T} node\n * @param {boolean} root\n */\nexport const encode = (node, root = true) => {\n  switch (node.type) {\n    case NodeType.Raw:\n      return encodeRaw(node.content)\n    case NodeType.File:\n      return encodeFile(node)\n    case NodeType.Directory:\n      return encodeDirectory(node)\n    case NodeType.HAMTShard:\n      return encodeHAMTShard(node)\n    case NodeType.Symlink:\n      return encodeSymlink(node)\n    default:\n      throw new Error(`Unknown node type ${Object(node).type}`)\n  }\n}\n\n/**\n * @param {UnixFS.ByteView<UnixFS.Node>} bytes\n * @returns {UnixFS.Node}\n */\nexport const decode = bytes => {\n  const pb = PB.decode(bytes)\n  const message = Data.decode(/** @type {Uint8Array} */ (pb.Data))\n\n  const {\n    Type: type,\n    Data: data,\n    mtime,\n    mode,\n    blocksizes,\n    ...rest\n  } = Data.toObject(message, {\n    defaults: false,\n    arrays: true,\n    longs: Number,\n    objects: false,\n  })\n  const metadata = {\n    ...(mode && { mode }),\n    ...decodeMtime(mtime),\n  }\n  /** @type {UnixFS.PBLink[]} */\n  const links = pb.Links\n\n  switch (message.Type) {\n    case NodeType.Raw:\n      return createRaw(data)\n    case NodeType.File:\n      if (links.length === 0) {\n        return new SimpleFileView(data, metadata)\n      } else if (data.byteLength === 0) {\n        return new AdvancedFileView(\n          decodeFileLinks(rest.blocksizes, links),\n          metadata\n        )\n      } else {\n        return new ComplexFileView(\n          data,\n          decodeFileLinks(rest.blocksizes, links),\n          metadata\n        )\n      }\n    case NodeType.Directory:\n      return createFlatDirectory(decodeDirectoryLinks(links), metadata)\n    case NodeType.HAMTShard:\n      return createShardedDirectory(\n        decodeDirectoryLinks(links),\n        data || EMPTY_BUFFER,\n        rest.fanout,\n        rest.hashType,\n        metadata\n      )\n    case NodeType.Symlink:\n      return createSymlink(data, metadata)\n    default:\n      throw new TypeError(`Unsupported node type ${message.Type}`)\n  }\n}\n\n/**\n * @param {UnixFS.UnixTime|undefined} mtime\n */\nconst decodeMtime = mtime =>\n  mtime == null\n    ? undefined\n    : {\n        mtime: { secs: mtime.Seconds, nsecs: mtime.FractionalNanoseconds || 0 },\n      }\n\n/**\n * @param {NodeType} type\n * @param {number[]|undefined} blocksizes\n */\nconst decodeBlocksizes = (type, blocksizes) => {\n  switch (type) {\n    case NodeType.File:\n      return blocksizes && blocksizes.length > 0 ? { blocksizes } : undefined\n    default:\n      return undefined\n  }\n}\n\n/**\n *\n * @param {number[]} blocksizes\n * @param {UnixFS.PBLink[]} links\n * @returns {UnixFS.FileLink[]}\n */\n\nconst decodeFileLinks = (blocksizes, links) => {\n  const parts = []\n  const length = blocksizes.length\n  let n = 0\n  while (n < length) {\n    parts.push(\n      /** @type {UnixFS.FileLink} */ ({\n        cid: links[n].Hash,\n        dagByteLength: links[n].Tsize || 0,\n        contentByteLength: blocksizes[n],\n      })\n    )\n  }\n  return parts\n}\n\n/**\n * @param {UnixFS.PBLink[]} links\n * @returns {UnixFS.DirectoryEntryLink[]}\n */\nconst decodeDirectoryLinks = links =>\n  links.map(\n    link =>\n      /** @type {UnixFS.DirectoryEntryLink} */ ({\n        cid: link.Hash,\n        name: link.Name || \"\",\n        dagByteLength: link.Tsize || 0,\n      })\n  )\n\n/**\n * @param {ReadonlyArray<UnixFS.FileLink>} links\n * @returns {number}\n */\nexport const cumulativeContentByteLength = links =>\n  links.reduce((size, link) => size + link.contentByteLength, 0)\n\n/**\n * @param {Uint8Array} root\n * @param {ReadonlyArray<UnixFS.DAGLink>} links\n * @returns {number}\n */\nexport const cumulativeDagByteLength = (root, links) =>\n  links.reduce((size, link) => size + link.dagByteLength, root.byteLength)\n\n/**\n *\n * @param {UnixFS.FileLink} link\n */\nconst contentByteLength = link => link.contentByteLength\n\n/**\n * @param {UnixFS.NamedDAGLink<unknown>} link\n * @returns {UnixFS.PBLink}\n */\nconst encodeNamedLink = ({ name, dagByteLength, cid }) => ({\n  Name: name,\n  Tsize: dagByteLength,\n  Hash: cid,\n})\n\n/**\n * @param {UnixFS.Metadata} metadata\n */\nexport const encodeDirectoryMetadata = metadata =>\n  encodeMetadata(metadata, DEFAULT_DIRECTORY_MODE)\n\n/**\n * @param {UnixFS.Metadata} metadata\n * @param {UnixFS.Mode} defaultMode\n */\nexport const encodeMetadata = (\n  { mode, mtime },\n  defaultMode = DEFAULT_FILE_MODE\n) => ({\n  mode: mode != null ? encodeMode(mode, defaultMode) : undefined,\n  mtime: mtime != null ? encodeMTime(mtime) : undefined,\n})\n\n/**\n * @param {UnixFS.Metadata} [data]\n */\nexport const decodeMetadata = data =>\n  data == null\n    ? BLANK\n    : {\n        ...(data.mode == null ? undefined : { mode: decodeMode(data.mode) }),\n        ...(data.mtime == null ? undefined : { mtime: data.mtime }),\n      }\n\n/**\n * @param {UnixFS.MTime} mtime\n */\nconst encodeMTime = mtime => {\n  return mtime == null\n    ? undefined\n    : mtime.nsecs !== 0\n    ? { Seconds: mtime.secs, FractionalNanoseconds: mtime.nsecs }\n    : { Seconds: mtime.secs }\n}\n\n/**\n * @param {number} specifiedMode\n * @param {number} defaultMode\n */\nexport const encodeMode = (specifiedMode, defaultMode) => {\n  const mode = specifiedMode == null ? undefined : decodeMode(specifiedMode)\n  return mode === defaultMode || mode == null ? undefined : mode\n}\n\n/**\n * @param {UnixFS.Mode} mode\n * @returns {UnixFS.Mode}\n */\nconst decodeMode = mode => (mode & 0xfff) | (mode & 0xfffff000)\n\n/**\n * @param {{content?: Uint8Array, parts?: ReadonlyArray<UnixFS.FileLink>, metadata?: UnixFS.Metadata }} node\n * @returns {UnixFS.SimpleFile|UnixFS.AdvancedFile|UnixFS.ComplexFile}\n */\nexport const matchFile = ({\n  content = EMPTY_BUFFER,\n  parts = EMPTY,\n  metadata = BLANK,\n  ...rest\n}) => {\n  if (parts.length === 0) {\n    return new SimpleFileView(content, metadata)\n  } else if (content.byteLength === 0) {\n    return new AdvancedFileView(parts, metadata)\n  } else {\n    return new ComplexFileView(content, parts, metadata)\n  }\n}\n\n/**\n * @implements {UnixFS.SimpleFile}\n */\nclass SimpleFileView {\n  /**\n   * @param {Uint8Array} content\n   * @param {UnixFS.Metadata} metadata\n   */\n  constructor(content, metadata) {\n    this.content = content\n    this.metadata = metadata\n    /**\n     * @readonly\n     * @type {\"simple\"}\n     */\n    this.layout = \"simple\"\n    /**\n     * @readonly\n     * @type {NodeType.File}\n     */\n    this.type = NodeType.File\n  }\n\n  get filesize() {\n    return this.content.byteLength\n  }\n\n  encode() {\n    return encodeSimpleFile(this.content, this.metadata)\n  }\n}\n\n/**\n * @implements {UnixFS.AdvancedFile}\n */\nclass AdvancedFileView {\n  /**\n   * @param {ReadonlyArray<UnixFS.FileLink>} parts\n   * @param {UnixFS.Metadata} metadata\n   */\n  constructor(parts, metadata) {\n    this.parts = parts\n    this.metadata = metadata\n  }\n  /** @type {\"advanced\"} */\n  get layout() {\n    return \"advanced\"\n  }\n\n  /**\n   * @returns {NodeType.File}\n   */\n  get type() {\n    return NodeType.File\n  }\n  get fileSize() {\n    return cumulativeContentByteLength(this.parts)\n  }\n  get blockSizes() {\n    return this.parts.map(contentByteLength)\n  }\n\n  encode() {\n    return encodeAdvancedFile(this.parts, this.metadata)\n  }\n}\n\n/**\n * @implements {UnixFS.ComplexFile}\n */\nclass ComplexFileView {\n  /**\n   * @param {Uint8Array} content\n   * @param {ReadonlyArray<UnixFS.FileLink>} parts\n   * @param {UnixFS.Metadata} metadata\n   */\n  constructor(content, parts, metadata) {\n    this.content = content\n    this.parts = parts\n    this.metadata = metadata\n  }\n  /** @type {\"complex\"} */\n  get layout() {\n    return \"complex\"\n  }\n\n  /**\n   * @returns {NodeType.File}\n   */\n  get type() {\n    return NodeType.File\n  }\n  get fileSize() {\n    return this.content.byteLength + cumulativeContentByteLength(this.parts)\n  }\n  get blockSizes() {\n    return this.parts.map(contentByteLength)\n  }\n\n  encode() {\n    return encodeComplexFile(this.content, this.parts, this.metadata)\n  }\n}\n\n/**\n * @param {UnixFS.File|UnixFS.Raw|UnixFS.FileChunk|UnixFS.FileShard|UnixFS.Symlink} node\n * @returns {number}\n */\nexport const filesize = node => {\n  switch (node.type) {\n    case NodeType.Raw:\n    case NodeType.Symlink:\n      return node.content.byteLength\n    case NodeType.File:\n      switch (node.layout) {\n        case \"simple\":\n          return node.content.byteLength\n        case \"advanced\":\n          return cumulativeContentByteLength(node.parts)\n        case \"complex\":\n          return (\n            node.content.byteLength + cumulativeContentByteLength(node.parts)\n          )\n      }\n    default:\n      return 0\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1240, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/unixfs/src/file/layout/api.js"],"sourcesContent":["// @ts-nocheck\n\n/**\n * This is file is shadowed by api.ts and only exists so JS could import it to\n * refer to types without encountering runtime errors\n * @see https://github.com/microsoft/TypeScript/issues/41825\n */\n"],"names":[],"mappings":"AAAA,cAAc;AAEd;;;;CAIC","ignoreList":[0]}},
    {"offset": {"line": 1250, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/unixfs/src/file/chunker/indexed.js"],"sourcesContent":["function Indexed() {}\n\nObject.defineProperties(Indexed, {\n  prototype: {\n    value: new Proxy(Object.prototype, {\n      /**\n       * @param {object} target\n       * @param {PropertyKey} property\n       * @param {{get(key:PropertyKey): any}} receiver\n       */\n      get(target, property, receiver) {\n        return typeof property === \"symbol\"\n          ? Reflect.get(target, property, receiver)\n          : receiver.get(property)\n      },\n    }),\n  },\n})\n\nexport { Indexed }\n"],"names":[],"mappings":";;;;AAAA,SAAS,WAAW;AAEpB,OAAO,gBAAgB,CAAC,SAAS;IAC/B,WAAW;QACT,OAAO,IAAI,MAAM,OAAO,SAAS,EAAE;YACjC;;;;OAIC,GACD,KAAI,MAAM,EAAE,QAAQ,EAAE,QAAQ;gBAC5B,OAAO,OAAO,aAAa,WACvB,QAAQ,GAAG,CAAC,QAAQ,UAAU,YAC9B,SAAS,GAAG,CAAC;YACnB;QACF;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 1273, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/unixfs/src/file/chunker/buffer.js"],"sourcesContent":["import { Indexed } from \"./indexed.js\"\n\n/**\n * @typedef {{\n * readonly byteOffset: number\n * readonly byteLength: number\n * readonly segments: Uint8Array[]\n * }} BufferSlice\n */\n\n/** @typedef {BufferView} View */\nexport const empty = () => new BufferView()\n\n/**\n * @param {Uint8Array[]} segments\n * @param {number} byteOffset\n * @param {number} byteLength\n */\nexport const create = (\n  segments,\n  byteOffset = 0,\n  byteLength = totalByteLength(segments)\n) => new BufferView(segments, byteOffset, byteLength)\n\n/**\n *\n * @param {Uint8Array[]} segments\n * @returns\n */\nconst totalByteLength = segments => {\n  let byteLength = 0\n  for (const segment of segments) {\n    byteLength += segment.byteLength\n  }\n  return byteLength\n}\n\n/**\n * @param {BufferSlice} buffer\n * @param {number} [startOffset]\n * @param {number} [endOffset]\n */\nexport const slice = (\n  buffer,\n  startOffset = 0,\n  endOffset = buffer.byteLength\n) => {\n  const segments = []\n  const start = startOffset < 0 ? buffer.byteLength - startOffset : startOffset\n  const end = endOffset < 0 ? buffer.byteLength - endOffset : endOffset\n\n  // If start at 0 offset and end is past buffer range it is effectively\n  // as same buffer.\n  if (start === 0 && end >= buffer.byteLength) {\n    return buffer\n  }\n\n  // If range is not within the current buffer just create an empty slice.\n  if (start > end || start > buffer.byteLength || end <= 0) {\n    return empty()\n  }\n\n  let byteLength = 0\n  let offset = 0\n  for (const segment of buffer.segments) {\n    const nextOffset = offset + segment.byteLength\n    // Have not found a start yet\n    if (byteLength === 0) {\n      // If end offset is within the current segment we know start is also,\n      // because it preceeds the end & we had not found start yet.\n      // In such case we create a view with only single segment of bytes\n      // in the range.\n      if (end <= nextOffset) {\n        const range = segment.subarray(start - offset, end - offset)\n        segments.push(range)\n        byteLength = range.byteLength\n        break\n      }\n      // If start offeset falls with in current range (but not the end)\n      // we save matching buffer slice and update byteLength.\n      else if (start < nextOffset) {\n        const range =\n          start === offset ? segment : segment.subarray(start - offset)\n        segments.push(range)\n        byteLength = range.byteLength\n      }\n    }\n    // Otherwise we already started collecting matching segments and are looking\n    // for the end end of the slice. If it is with in the current range capture\n    // the segment and create a view.\n    else if (end <= nextOffset) {\n      const range =\n        end === nextOffset ? segment : segment.subarray(0, end - offset)\n      segments.push(range)\n      byteLength += range.byteLength\n      break\n    }\n    // If end is past current range we just save the segment and continue.\n    else {\n      segments.push(segment)\n      byteLength += segment.byteLength\n    }\n\n    offset = nextOffset\n  }\n\n  return new BufferView(segments, buffer.byteOffset + start, byteLength)\n}\n\n/**\n * @param {BufferSlice} buffer\n * @param {Uint8Array} part\n */\n\nexport const push = (buffer, part) => {\n  if (part.byteLength > 0) {\n    // We MUTATE here but that is ok because it is out of bound for the passed\n    // buffer view so there will be no visible side effects.\n    buffer.segments.push(part)\n    return new BufferView(\n      buffer.segments,\n      buffer.byteOffset,\n      buffer.byteLength + part.byteLength\n    )\n  } else {\n    return buffer\n  }\n}\n\n/**\n * @param {BufferSlice} buffer\n * @param {number} n\n */\nexport const get = (buffer, n) => {\n  if (n < buffer.byteLength) {\n    let offset = 0\n    for (const segment of buffer.segments) {\n      if (n < offset + segment.byteLength) {\n        return segment[n - offset]\n      } else {\n        offset += segment.byteLength\n      }\n    }\n  }\n\n  return undefined\n}\n\n/**\n *\n * @param {BufferView} buffer\n * @param {Uint8Array} target\n * @param {number} byteOffset\n */\nexport const copyTo = (buffer, target, byteOffset) => {\n  let offset = byteOffset\n  for (const segment of buffer.segments) {\n    target.set(segment, offset)\n    offset += segment.byteLength\n  }\n\n  return target\n}\n\n/**\n *\n * @param {BufferView} buffer\n */\nexport function* iterate(buffer) {\n  for (const part of buffer.segments) {\n    yield* part\n  }\n}\n\n/**\n * @extends {Indexed<number>}\n */\nclass BufferView extends Indexed {\n  /**\n   * @param {Uint8Array[]} segments\n   * @param {number} byteOffset\n   * @param {number} byteLength\n   */\n  constructor(segments = [], byteOffset = 0, byteLength = 0) {\n    super()\n    /** @hide */\n    this.segments = segments\n    /** @readonly */\n    this.byteLength = byteLength\n    /** @readonly */\n    this.length = byteLength\n    /** @readonly */\n    this.byteOffset = byteOffset\n  }\n\n  [Symbol.iterator]() {\n    return iterate(this)\n  }\n\n  /**\n   * @param {number} [start]\n   * @param {number} [end]\n   */\n  slice(start, end) {\n    return /** @type {BufferView} */ (slice(this, start, end))\n  }\n\n  /**\n   * @param {number} [start]\n   * @param {number} [end]\n   */\n  subarray(start, end) {\n    return /** @type {BufferView} */ (slice(this, start, end))\n  }\n\n  /**\n   *\n   * @param {Uint8Array} bytes\n   */\n  push(bytes) {\n    return /** @type {BufferView} */ (push(this, bytes))\n  }\n\n  /**\n   * @param {number} n\n   */\n  get(n) {\n    return get(this, n)\n  }\n\n  /**\n   *\n   * @param {Uint8Array} target\n   * @param {number} offset\n   */\n  copyTo(target, offset) {\n    return copyTo(this, target, offset)\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1438, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/unixfs/src/file/chunker/api.js"],"sourcesContent":["// @ts-nocheck\n\n/**\n * This is file is shadowed by api.ts and only exists so JS could import it to\n * refer to types without encountering runtime errors\n * @see https://github.com/microsoft/TypeScript/issues/41825\n */\n"],"names":[],"mappings":"AAAA,cAAc;AAEd;;;;CAIC","ignoreList":[0]}},
    {"offset": {"line": 1448, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/unixfs/src/writer/util.js"],"sourcesContent":["/**\n * @param {string} reason\n * @returns {never}\n */\nexport const panic = reason => {\n  throw new Error(reason)\n}\n\n/**\n * @param {{ raw: readonly string[] | ArrayLike<string>}} template\n * @param {never} [subject]\n * @param {unknown[]} substitutions\n * @returns {never}\n */\nexport const unreachable = (template, subject, ...substitutions) =>\n  panic(String.raw(template, JSON.stringify(subject), ...substitutions))\n\nexport const EMPTY_BUFFER = new Uint8Array(0)\n/** @type {any[]} */\nexport const EMPTY = []\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;;;;;AACM,MAAM,QAAQ,CAAA;IACnB,MAAM,IAAI,MAAM;AAClB;AAQO,MAAM,cAAc,CAAC,UAAU,SAAS,GAAG,gBAChD,MAAM,OAAO,GAAG,CAAC,UAAU,KAAK,SAAS,CAAC,aAAa;AAElD,MAAM,eAAe,IAAI,WAAW;AAEpC,MAAM,QAAQ,EAAE","ignoreList":[0]}},
    {"offset": {"line": 1471, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/unixfs/src/file/chunker.js"],"sourcesContent":["import * as BufferQueue from \"./chunker/buffer.js\"\nimport * as Chunker from \"./chunker/api.js\"\nimport { EMPTY } from \"../writer/util.js\"\nexport * from \"./chunker/api.js\"\n\n/**\n * @typedef {{\n * chunker: Chunker.Chunker\n * }} Config\n *\n *\n * @typedef {{\n * buffer: BufferQueue.View\n * config: Config\n * }} Chunker\n *\n * @typedef {Chunker & {chunks: Chunker.Chunk[]}} ChunkerWithChunks\n */\n\n/**\n * @param {Config} config\n * @returns {Chunker}\n */\nexport const open = config => ({\n  config,\n  buffer: BufferQueue.empty(),\n})\n\n/**\n * @param {Chunker} state\n * @param {Uint8Array} bytes\n * @returns {ChunkerWithChunks}\n */\nexport const write = (state, bytes) =>\n  bytes.byteLength > 0\n    ? split(state.config, state.buffer.push(bytes), false)\n    : { ...state, chunks: EMPTY }\n\n/**\n * @param {Chunker} state\n * @returns {ChunkerWithChunks}\n */\nexport const close = state => split(state.config, state.buffer, true)\n\n/**\n * @param {Config} config\n * @param {BufferQueue.View} buffer\n * @param {boolean} end\n * @returns {ChunkerWithChunks}\n */\n\nexport const split = (config, buffer, end) => {\n  const chunker = config.chunker\n  const chunks = []\n\n  let offset = 0\n  for (const size of chunker.cut(chunker.context, buffer, end)) {\n    // We may be splitting empty buffer in which case there will be no chunks\n    // in it so we make sure that we do not emit empty buffer.\n    if (size > 0) {\n      const chunk = buffer.subarray(offset, offset + size)\n      chunks.push(chunk)\n      offset += size\n    }\n  }\n\n  return { config, chunks, buffer: buffer.subarray(offset) }\n}\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AACA;;;;;AAqBO,MAAM,OAAO,CAAA,SAAU,CAAC;QAC7B;QACA,QAAQ,gLAAiB;IAC3B,CAAC;AAOM,MAAM,QAAQ,CAAC,OAAO,QAC3B,MAAM,UAAU,GAAG,IACf,MAAM,MAAM,MAAM,EAAE,MAAM,MAAM,CAAC,IAAI,CAAC,QAAQ,SAC9C;QAAE,GAAG,KAAK;QAAE,QAAQ,qKAAK;IAAC;AAMzB,MAAM,QAAQ,CAAA,QAAS,MAAM,MAAM,MAAM,EAAE,MAAM,MAAM,EAAE;AASzD,MAAM,QAAQ,CAAC,QAAQ,QAAQ;IACpC,MAAM,UAAU,OAAO,OAAO;IAC9B,MAAM,SAAS,EAAE;IAEjB,IAAI,SAAS;IACb,KAAK,MAAM,QAAQ,QAAQ,GAAG,CAAC,QAAQ,OAAO,EAAE,QAAQ,KAAM;QAC5D,yEAAyE;QACzE,0DAA0D;QAC1D,IAAI,OAAO,GAAG;YACZ,MAAM,QAAQ,OAAO,QAAQ,CAAC,QAAQ,SAAS;YAC/C,OAAO,IAAI,CAAC;YACZ,UAAU;QACZ;IACF;IAEA,OAAO;QAAE;QAAQ;QAAQ,QAAQ,OAAO,QAAQ,CAAC;IAAQ;AAC3D","ignoreList":[0]}},
    {"offset": {"line": 1520, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/unixfs/src/file/layout/queue/api.js"],"sourcesContent":["// @ts-nocheck\n\n/**\n * This is file is shadowed by api.ts and only exists so JS could import it to\n * refer to types without encountering runtime errors\n * @see https://github.com/microsoft/TypeScript/issues/41825\n */\n"],"names":[],"mappings":"AAAA,cAAc;AAEd;;;;CAIC","ignoreList":[0]}},
    {"offset": {"line": 1530, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/unixfs/src/file/layout/queue.js"],"sourcesContent":["import * as Layout from \"./api.js\"\nimport * as Queue from \"./queue/api.js\"\nexport * from \"./queue/api.js\"\n\n/**\n * @returns {Queue.Result}\n */\nexport const empty = () => ({\n  mutable: false,\n  needs: {},\n  nodes: {},\n  links: {},\n  linked: [],\n})\n\nexport const mutable = () => ({\n  mutable: true,\n  needs: {},\n  nodes: {},\n  links: {},\n  linked: EMPTY,\n})\n\n/**\n * Adds given layout node to the layout queue. If links for all of the node\n * children are available correspnoding linked node is added (removing links\n * form the queue) otherwise `nood` is added to the wait queue until all the\n * needed links are added.\n *\n *\n * @param {Layout.Branch} node\n * @param {Queue.Queue} queue\n * @returns {Queue.Result}\n */\nexport const addNode = (node, queue) => addNodes([node], queue)\n\n/**\n *\n * @param {Layout.Branch[]} newNodes\n * @param {Queue.Queue} input\n * @returns {Queue.Result}\n */\nexport const addNodes = (newNodes, input) => {\n  let queue = patch(input, {})\n  for (const node of newNodes) {\n    const { ready, has, wants } = collect(node.children, queue.links)\n    // If node isn't waiting on any of the children it's ready to be linked\n    // so we add linked node diretly.\n    if (wants.length === 0) {\n      queue = patch(queue, {\n        links: assign(undefined, has),\n        linked: [{ id: node.id, links: ready }],\n      })\n    } else {\n      queue = patch(queue, {\n        needs: assign(node.id, wants),\n        nodes: {\n          [node.id]: {\n            children: node.children,\n            count: wants.length,\n          },\n        },\n      })\n    }\n  }\n\n  return queue\n}\n\n/**\n * Adds link to the queue. If queue contains a node that needs this link it gets\n * updated. Either it's gets linked (when it was blocked only on this link) or\n * it's want could is reduced. If no node needed this link it just gets stored\n * for the future node that will need it.\n *\n *\n * @param {Queue.NodeID} id\n * @param {Queue.Link} link\n * @param {Queue.Queue} queue\n * @returns {Queue.Result}\n */\n\nexport const addLink = (id, link, queue) => {\n  const nodeID = queue.needs[id]\n  const node = queue.nodes[nodeID]\n  // We have node than needs this link.\n  if (node != null) {\n    // This is the only link it needed so we materialize the node and remove\n    // links and needs associated with it.\n    if (node.count === 1) {\n      const { ready, has } = collect(node.children, {\n        ...queue.links,\n        [id]: link,\n      })\n\n      return patch(queue, {\n        needs: { [id]: undefined },\n        links: assign(undefined, has),\n        nodes: { [nodeID]: undefined },\n        linked: [{ id: nodeID, links: ready }],\n      })\n    }\n    // If node needs more links we just reduce a want count and remove this\n    // need.\n    else {\n      return patch(queue, {\n        needs: { [id]: undefined },\n        links: { [id]: link },\n        nodes: {\n          [nodeID]: {\n            ...node,\n            count: node.count - 1,\n          },\n        },\n      })\n    }\n  }\n  // If we have no one waiting for this link just add it to the queue\n  else {\n    return patch(queue, {\n      links: { [id]: link },\n    })\n  }\n}\n\n/**\n *\n * @param {Queue.Queue} queue\n * @param {Queue.Delta} delta\n */\n\nconst patch = (queue, { needs, nodes, links, linked }) => {\n  const result = queue.mutable ? queue : { ...queue }\n  const original = queue.mutable ? BLANK : undefined\n\n  if (needs) {\n    result.needs = patchDict(queue.needs, needs, original)\n  }\n\n  if (nodes) {\n    result.nodes = patchDict(queue.nodes, nodes, original)\n  }\n\n  if (links) {\n    result.links = patchDict(queue.links, links, original)\n  }\n\n  result.linked = linked\n    ? append(queue.linked || EMPTY, linked, EMPTY)\n    : queue.linked || []\n\n  return /** @type {Queue.Result} */ (result)\n}\n\n/**\n * @template V\n * @template {PropertyKey} K\n * @param {V} value\n * @param {K[]} keys\n * @returns {Record<K, V>}\n */\n\nconst assign = (value, keys) => {\n  const delta = /** @type {Record<K, V>} */ ({})\n  for (const key of keys) {\n    delta[key] = value\n  }\n\n  return delta\n}\n\n/**\n * @template {PropertyKey} K\n * @template V\n * @param {Record<K, V>} target\n *\n * @param {Record<K, V|void>} delta\n * @param {Record<K, V>} original\n * @returns {Record<K, V>}\n */\n\nconst patchDict = (target, delta, original = target) => {\n  const result = target === original ? { ...target } : target\n  for (const entry of Object.entries(delta)) {\n    const [id, value] = /** @type {[K, V|void]} */ (entry)\n    if (value == null) {\n      delete result[id]\n    } else {\n      result[id] = value\n    }\n  }\n\n  return result\n}\n/**\n *\n * @param {Iterable<[Queue.NodeID, Queue.Link]>} entries\n * @param {Queue.Queue} queue\n * @returns {Queue.Queue}\n */\nexport const addLinks = (entries, queue) => {\n  for (const [id, link] of entries) {\n    queue = addLink(id, link, queue)\n  }\n  return queue\n}\n\n/**\n * @param {Queue.Queue} queue\n */\n\nexport const isEmpty = queue =>\n  Object.keys(queue.nodes).length === 0 && Object.keys(queue.links).length === 0\n\n/**\n * @template T\n * @param {T[]} target\n * @param {T[]} items\n * @param {T[]} original\n */\nconst append = (target, items, original = target) => {\n  if (target === original) {\n    return [...target, ...items]\n  } else {\n    for (const item of items) {\n      target.push(item)\n    }\n    return target\n  }\n}\n\n/**\n * @param {Queue.NodeID[]} children\n * @param {Record<Queue.NodeID, Queue.Link>} source\n * @returns {{has:Queue.NodeID[], wants:Queue.NodeID[], ready:Queue.Link[]}}\n */\nconst collect = (children, source) => {\n  const has = []\n  const wants = []\n  const ready = []\n  for (const child of children) {\n    const link = source[child]\n    if (link) {\n      has.push(child)\n      ready.push(link)\n    } else {\n      wants.push(child)\n    }\n  }\n\n  return { has, wants, ready }\n}\n\nconst EMPTY = /** @type {never[]} */ (Object.freeze([]))\n\nconst BLANK = /** @type {Record<never, never>} */ (Object.freeze({}))\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1759, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/unixfs/src/file/writer.js"],"sourcesContent":["import * as Task from \"actor\"\nimport * as API from \"./api.js\"\nimport * as Layout from \"./layout/api.js\"\nimport * as UnixFS from \"../codec.js\"\nimport * as Chunker from \"./chunker.js\"\nimport { EMPTY_BUFFER, panic, unreachable } from \"../writer/util.js\"\nimport * as Queue from \"./layout/queue.js\"\n\n/**\n * @template Layout\n * @typedef {{\n * readonly status: 'open'\n * readonly metadata: UnixFS.Metadata\n * readonly config: API.EncoderSettings<Layout>\n * readonly writer: API.BlockWriter\n * chunker: Chunker.Chunker\n * layout: Layout\n * nodeQueue: Queue.Queue\n * }} Open\n */\n/**\n * @template Layout\n * @typedef {{\n * readonly status: 'closed'\n * readonly metadata: UnixFS.Metadata\n * readonly config: API.EncoderSettings<Layout>\n * readonly writer: API.BlockWriter\n * readonly rootID: Layout.NodeID\n * readonly end?: Task.Fork<void, never>\n * chunker?: null\n * layout?: null\n * nodeQueue: Queue.Queue\n * }} Closed\n */\n/**\n * @template Layout\n * @typedef {{\n * readonly status: 'linked'\n * readonly metadata: UnixFS.Metadata\n * readonly config: API.EncoderSettings<Layout>\n * readonly writer: API.BlockWriter\n * readonly link: Layout.Link\n * chunker?: null\n * layout?: null\n * nodeQueue: Queue.Queue\n * }} Linked\n */\n\n/**\n * @template Layout\n * @typedef {Open<Layout>|Closed<Layout>|Linked<Layout>} State\n */\n\n/**\n * @template {object} Layout\n * @typedef {{\n * state: State<Layout>\n * effect: Task.Effect<Message>\n * }} Update\n */\n/**\n * @typedef {never\n * |{type:\"write\", bytes:Uint8Array}\n * |{type:\"link\", link:API.EncodedFile}\n * |{type:\"block\"}\n * |{type: \"close\"}\n * |{type: \"end\"}\n * } Message\n */\n\n/**\n * @template Layout\n * @param {Message} message\n * @param {State<Layout>} state\n */\nexport const update = (message, state) => {\n  switch (message.type) {\n    case \"write\":\n      return write(state, message.bytes)\n    case \"link\":\n      return link(state, message.link)\n    /* c8 ignore next 2 */\n    case \"block\":\n      return { state, effect: Task.none() }\n    case \"close\":\n      return close(state)\n    case \"end\":\n      return { state, effect: Task.none() }\n    default:\n      return unreachable`File Writer got unknown message ${message}`\n  }\n}\n\n/**\n * @template Layout\n * @param {API.BlockWriter} writer\n * @param {UnixFS.Metadata} metadata\n * @param {API.EncoderSettings} config\n * @returns {State<Layout>}\n */\nexport const init = (writer, metadata, config) => {\n  return {\n    status: \"open\",\n    metadata,\n    config,\n    writer,\n    chunker: Chunker.open({ chunker: config.chunker }),\n    layout: config.fileLayout.open(),\n    // Note: Writing in large slices e.g. 1GiB at a time creates large queues\n    // with around `16353` items. Immutable version ends up copying it every\n    // time state of the queue changes, which introduces significant overhead.\n    // To avoid this overhead we use mutable implementation which is API\n    // compatible but makes in place updates.\n    // TODO: We should consider using Persistent bit-partitioned vector tries\n    // instead of arrays which would provide immutable interface with neglegable\n    // overhead.\n    // @see https://github.com/Gozala/vectrie\n    nodeQueue: Queue.mutable(),\n  }\n}\n/**\n * @template Layout\n * @param {State<Layout>} state\n * @param {Uint8Array} bytes\n * @returns {Update<Layout>}\n */\nexport const write = (state, bytes) => {\n  if (state.status === \"open\") {\n    // Chunk up provided bytes\n    const { chunks, ...chunker } = Chunker.write(state.chunker, bytes)\n\n    // Pass chunks to layout engine to produce nodes\n    const { nodes, leaves, layout } = state.config.fileLayout.write(\n      state.layout,\n      chunks\n    )\n\n    const { linked, ...nodeQueue } = Queue.addNodes(nodes, state.nodeQueue)\n\n    // Create leaf encode tasks for all new leaves\n    const tasks = [\n      ...encodeLeaves(leaves, state.config),\n      ...encodeBranches(linked, state.config),\n    ]\n\n    return {\n      state: {\n        ...state,\n        chunker,\n        layout,\n        nodeQueue,\n      },\n      effect: Task.listen({\n        link: Task.effects(tasks),\n      }),\n    }\n  } else {\n    return panic(\"Unable to perform write on closed file\")\n  }\n}\n\n/**\n * @template Layout\n * @param {State<Layout>} state\n * @param {API.EncodedFile} entry\n * @returns {Update<Layout>}\n */\nexport const link = (state, { id, link, block }) => {\n  let { linked, ...nodeQueue } = Queue.addLink(id, link, state.nodeQueue)\n\n  const tasks = encodeBranches(linked, state.config)\n\n  /** @type {State<Layout>} */\n  const newState =\n    state.status === \"closed\" && id === state.rootID\n      ? {\n          ...state,\n          status: \"linked\",\n          link,\n          nodeQueue,\n        }\n      : { ...state, nodeQueue }\n\n  // If we just linked a root and there is a **suspended** \"end\" task we create\n  // a task to resume it.\n  const end =\n    state.status === \"closed\" && id === state.rootID && state.end\n      ? state.end.resume()\n      : Task.none()\n\n  return {\n    state: newState,\n    effect: Task.listen({\n      link: Task.effects(tasks),\n      block: writeBlock(state.writer, block),\n      end,\n    }),\n  }\n}\n\n/**\n * @template Layout\n * @param {State<Layout>} state\n * @returns {Update<Layout>}\n */\nexport const close = state => {\n  if (state.status === \"open\") {\n    const { chunks } = Chunker.close(state.chunker)\n    const { layout, ...write } = state.config.fileLayout.write(\n      state.layout,\n      chunks\n    )\n\n    const { root, ...close } = state.config.fileLayout.close(\n      layout,\n      state.metadata\n    )\n\n    const [nodes, leaves] = isLeafNode(root)\n      ? [\n          [...write.nodes, ...close.nodes],\n          [...write.leaves, ...close.leaves, root],\n        ]\n      : [\n          [...write.nodes, ...close.nodes, root],\n          [...write.leaves, ...close.leaves],\n        ]\n\n    const { linked, ...nodeQueue } = Queue.addNodes(nodes, state.nodeQueue)\n\n    const tasks = [\n      ...encodeLeaves(leaves, state.config),\n      ...encodeBranches(linked, state.config),\n    ]\n\n    // We want to keep run loop around until root node is linked. To\n    // accomplish this we fork a task that suspends itself, which we will\n    // resume when root is linked (see link function).\n    // Below we join this forked task in our effect, this way effect is not\n    // complete until task forked task is, which will do once we link the\n    // root.\n    const fork = Task.fork(Task.suspend())\n\n    return {\n      state: {\n        ...state,\n        chunker: null,\n        layout: null,\n        rootID: root.id,\n        status: \"closed\",\n        end: fork,\n        nodeQueue,\n      },\n      effect: Task.listen({\n        link: Task.effects(tasks),\n        end: Task.join(fork),\n      }),\n    }\n  } else {\n    return { state, effect: Task.none() }\n  }\n}\n\n/**\n * Creates concurrent leaf encode tasks. Each one will have an ID corresponding\n * to index in the queue.\n *\n * @param {Layout.Leaf[]} leaves\n * @param {API.EncoderSettings} config\n */\nconst encodeLeaves = (leaves, config) =>\n  leaves.map(leaf => encodeLeaf(config, leaf, config.fileChunkEncoder))\n\n/**\n * @param {API.EncoderSettings} config\n * @param {Layout.Leaf} leaf\n * @param {API.FileChunkEncoder} encoder\n * @returns {Task.Task<API.EncodedFile, never>}\n */\nconst encodeLeaf = function* ({ hasher, linker }, { id, content }, encoder) {\n  const bytes = encoder.encode(content ? asUint8Array(content) : EMPTY_BUFFER)\n  const hash = yield* Task.wait(hasher.digest(bytes))\n  const cid = linker.createLink(encoder.code, hash)\n\n  const block = { cid, bytes }\n  const link = /** @type {UnixFS.FileLink} */ ({\n    cid,\n    contentByteLength: content ? content.byteLength : 0,\n    dagByteLength: bytes.byteLength,\n  })\n\n  return { id, block, link }\n}\n\n/**\n * @param {Queue.LinkedNode[]} nodes\n * @param {API.EncoderSettings} config\n */\nconst encodeBranches = (nodes, config) =>\n  nodes.map(node => encodeBranch(config, node))\n\n/**\n * @template Layout\n * @param {API.EncoderSettings<Layout>} config\n * @param {Queue.LinkedNode} node\n * @param {UnixFS.Metadata} [metadata]\n * @returns {Task.Task<API.EncodedFile>}\n */\nexport const encodeBranch = function* (config, { id, links }, metadata) {\n  const bytes = config.fileEncoder.encode({\n    type: UnixFS.NodeType.File,\n    layout: \"advanced\",\n    parts: links,\n    metadata,\n  })\n  const hash = yield* Task.wait(Promise.resolve(config.hasher.digest(bytes)))\n  const cid = config.linker.createLink(config.fileEncoder.code, hash)\n  const block = { bytes, cid }\n  const link = /** @type {UnixFS.FileLink} */ ({\n    cid,\n    contentByteLength: UnixFS.cumulativeContentByteLength(links),\n    dagByteLength: UnixFS.cumulativeDagByteLength(bytes, links),\n  })\n\n  return { id, block, link }\n}\n\n/**\n * @param {API.BlockWriter} writer\n * @param {UnixFS.Block} block\n * @returns {Task.Task<void, never>}\n */\n\nexport const writeBlock = function* (writer, block) {\n  if ((writer.desiredSize || 0) <= 0) {\n    yield* Task.wait(writer.ready)\n  }\n  writer.write(block)\n}\n\n/**\n *\n * @param {Uint8Array|Chunker.Chunk} buffer\n * @returns\n */\n\nconst asUint8Array = buffer =>\n  buffer instanceof Uint8Array\n    ? buffer\n    : buffer.copyTo(new Uint8Array(buffer.byteLength), 0)\n\n/**\n * @param {Layout.Node} node\n * @returns {node is Layout.Leaf}\n */\nconst isLeafNode = node => node.children == null\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2023, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/unixfs/src/file/chunker/fixed.js"],"sourcesContent":["import * as API from \"./api.js\"\n\nexport const name = \"fixed\"\n/**\n * @typedef {Object} FixedSize\n * @property {number} maxChunkSize\n */\n\n/** @type {FixedSize} */\nexport const context = {\n  maxChunkSize: 262144,\n}\n\nexport const type = \"Stateless\"\n\n/**\n * @param {number} maxChunkSize\n * @returns {API.StatelessChunker<FixedSize>}\n */\nexport const withMaxChunkSize = maxChunkSize => ({\n  type: \"Stateless\",\n  context: { maxChunkSize },\n  name,\n  cut,\n})\n\n/**\n * @param {FixedSize} maxChunkSize\n * @param {API.Chunk} buffer\n * @param {boolean} end\n * @returns {number[]}\n */\nexport const cut = ({ maxChunkSize }, { byteLength }, end) => {\n  // number of fixed size chunks that would fit\n  const n = (byteLength / maxChunkSize) | 0\n  const chunks = new Array(n).fill(maxChunkSize)\n  const lastChunkSize = end ? byteLength - n * maxChunkSize : 0\n  if (lastChunkSize > 0) {\n    chunks.push(lastChunkSize)\n  }\n  return chunks\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;;AAEO,MAAM,OAAO;AAOb,MAAM,UAAU;IACrB,cAAc;AAChB;AAEO,MAAM,OAAO;AAMb,MAAM,mBAAmB,CAAA,eAAgB,CAAC;QAC/C,MAAM;QACN,SAAS;YAAE;QAAa;QACxB;QACA;IACF,CAAC;AAQM,MAAM,MAAM,CAAC,EAAE,YAAY,EAAE,EAAE,EAAE,UAAU,EAAE,EAAE;IACpD,6CAA6C;IAC7C,MAAM,IAAI,AAAC,aAAa,eAAgB;IACxC,MAAM,SAAS,IAAI,MAAM,GAAG,IAAI,CAAC;IACjC,MAAM,gBAAgB,MAAM,aAAa,IAAI,eAAe;IAC5D,IAAI,gBAAgB,GAAG;QACrB,OAAO,IAAI,CAAC;IACd;IACA,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 2064, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/unixfs/src/file/layout/balanced.js"],"sourcesContent":["import * as Layout from \"./api.js\"\nimport * as Chunker from \"./../chunker/api.js\"\n\n/**\n * Type representing a state of the balanced tree. First row hold leaves coming\n * into a builder, once number of leaves in the stack reaches `maxChildren` they\n * are moved into `RootNode` instance which is pushed into the next row of nodes.\n * If next row now contains `maxChildren` nodes from there are again moved into\n * a new `RootNode` and pushed into next row etc...\n *\n * For illustration let's assume we have `maxChildren: 3`, after 3 leafs were\n * added tree will have following layout\n *\n * ```\n *           (root1)\n *              |\n *    ----------------------\n *    |         |          |\n * (leaf1)   (leaf2)    (leaf3)\n * ```\n *\n * Which in our model before flushing is represented as follows:\n *\n * ```js\n * {\n *    width: 3\n *    leafIndex: [leaf1, leaf2, leaf3]\n *    nodeIndex: []\n *    nodes: []\n * }\n * ```\n *\n * After flushing 3 leaves (which is width) are moved into a `RootNode` that\n * is added to `nodes` array (and returned so that caller can create a block).\n * Additionally position of the added node is captured in the `index` at an\n * appropriate depth `0` (that is because we don't count leaves into depth).\n *\n * ```js\n * {\n *    width: 3\n *    leafIndex: []\n *    nodeIndex: [[0]]\n *    nodes: [new RootNode([leaf1, leaf2, leaf3])]\n * }\n * ```\n *\n * Increasing number of leaves to 10 would produce following tree layout\n *\n *```\n *                                                         (root7)\n *                                                           |\n *                                    ------------------------------------------\n *                                    |                                        |\n *                                 (root4)                                  (root6)\n *                                    |                                        |\n *            -------------------------------------------------                |\n *            |                       |                       |                |\n *         (root1)                 (root2)                 (root3)          (root5)\n *            |                       |                       |                |\n *    --------|--------       --------|--------       --------|--------        |\n *    |       |       |       |       |       |       |       |       |        |\n * (leaf1) (leaf2) (leaf3) (leaf4) (leaf5) (leaf6) (leaf7) (leaf8) (leaf9) (leaf10)\n * ```\n *\n * Which in our model will look as follows (note we do not have root5 - root7\n * in model because they are build once width is reached or once builder is\n * closed)\n *\n * ```js\n * {\n *    width: 3\n *    leafIndex: [leaf10]\n *    nodeIndex: [\n *      [0, 1, 2], // [r1, r2, r3]\n *      [3]        // [r4]\n *     ]\n *    nodes: [\n *      new Node([leaf1, leaf2, leaf3]), // r1\n *      new Node([leaf4, leaf5, leaf6]), // r2\n *      new Node([leaf7, leaf8, leaf9]), // r3\n *      new Node([ // r4\n *         new Node([leaf1, leaf2, leaf3]), // r1\n *         new Node([leaf4, leaf5, leaf6]), // r2\n *         new Node([leaf7, leaf8, leaf9]), // r3\n *      ])\n *    ]\n * }\n * ```\n *\n * @typedef {{\n * width: number\n * head: Chunker.Chunk | null\n * leafIndex: number[]\n * nodeIndex: number[][]\n * lastID: number\n * }} Balanced\n */\n\nclass Node {\n  /**\n   *\n   * @param {number} id\n   * @param {number[]} children\n   * @param {Layout.Metadata} [metadata]\n   */\n  constructor(id, children, metadata) {\n    this.id = id\n    this.children = children\n    this.metadata = metadata\n  }\n}\n\n/**\n * @typedef Options\n * @property {number} width - Max children per node.\n *\n * @param {number} width\n * @returns {Layout.LayoutEngine<Balanced>}\n */\nexport const withWidth = width => ({\n  open: () => open({ width }),\n  write,\n  close,\n})\n\nexport const defaults = { width: 174 }\n\n/**\n * @param {Options} options\n * @returns {Balanced}\n */\nexport const open = ({ width } = defaults) => ({\n  width,\n\n  head: null,\n  leafIndex: [],\n  nodeIndex: [],\n  lastID: 0,\n})\n\n/**\n *\n * @param {Balanced} layout\n * @param {Chunker.Chunk[]} chunks\n * @returns {Layout.WriteResult<Balanced>}\n */\nexport const write = (layout, chunks) => {\n  if (chunks.length === 0) {\n    return { layout, nodes: EMPTY, leaves: EMPTY }\n  } else {\n    let { lastID } = layout\n    // We need to hold on to the first chunk until we either get a second chunk\n    // (at which point we know our layout will have branches) or until we close\n    // (at which point our layout will be single leaf or node depneding on\n    // metadata)\n    const [head, slices] = layout.head\n      ? // If we had a head we have more then two chunks (we already checked\n        // chunks weren't empty) so we process head along with other chunks.\n        [null, (chunks.unshift(layout.head), chunks)]\n      : // If we have no head no leaves and got only one chunk we have to save it\n      // until we can decide what to do with it.\n      chunks.length === 1 && layout.leafIndex.length === 0\n      ? [chunks[0], EMPTY]\n      : // Otherwise we have no head but got enough chunks to know we'll have a\n        // node.\n        [null, chunks]\n\n    if (slices.length === 0) {\n      return { layout: { ...layout, head }, nodes: EMPTY, leaves: EMPTY }\n    } else {\n      const leafIndex = [...layout.leafIndex]\n      const leaves = []\n      for (const chunk of slices) {\n        const leaf = { id: ++lastID, content: chunk }\n        leaves.push(leaf)\n        leafIndex.push(leaf.id)\n      }\n\n      if (leafIndex.length > layout.width) {\n        return flush({ ...layout, leafIndex, head, lastID }, leaves)\n      } else {\n        return {\n          layout: { ...layout, head, leafIndex, lastID },\n          leaves,\n          nodes: EMPTY,\n        }\n      }\n    }\n  }\n}\n\n/**\n * @param {Balanced} state\n * @param {Layout.Leaf[]} leaves\n * @param {Layout.Branch[]} [nodes]\n * @param {boolean} [close]\n * @returns {Layout.WriteResult<Balanced>}\n */\nexport const flush = (state, leaves = EMPTY, nodes = [], close = false) => {\n  let { lastID } = state\n  const nodeIndex = state.nodeIndex.map(row => [...row])\n  const leafIndex = [...state.leafIndex]\n  const { width } = state\n\n  // Move leaves into nodes\n  while (leafIndex.length > width || (leafIndex.length > 0 && close)) {\n    grow(nodeIndex, 1)\n    const node = new Node(++lastID, leafIndex.splice(0, width))\n    nodeIndex[0].push(node.id)\n    nodes.push(node)\n  }\n\n  let depth = 0\n  while (depth < nodeIndex.length) {\n    const row = nodeIndex[depth]\n    depth++\n\n    while (\n      row.length > width ||\n      (row.length > 0 && close && depth < nodeIndex.length)\n    ) {\n      const node = new Node(++lastID, row.splice(0, width))\n      grow(nodeIndex, depth + 1)\n      nodeIndex[depth].push(node.id)\n      nodes.push(node)\n    }\n  }\n\n  return { layout: { ...state, lastID, leafIndex, nodeIndex }, leaves, nodes }\n}\n\n/**\n * @param {Balanced} layout\n * @param {Layout.Metadata} [metadata]\n * @returns {Layout.CloseResult}\n */\nexport const close = (layout, metadata) => {\n  const state = layout\n  if (layout.head) {\n    return {\n      root: { id: 1, content: layout.head, metadata },\n      leaves: EMPTY,\n      nodes: EMPTY,\n    }\n  } else if (layout.leafIndex.length === 0) {\n    return {\n      root: { id: 1, metadata },\n      leaves: EMPTY,\n      nodes: EMPTY,\n    }\n  } else {\n    // Flush with width 1 so all the items will be propagate up the tree\n    // and height of `depth-1` so we propagate nodes all but from the top\n    // most level\n    const { nodes, layout } = flush(state, EMPTY, [], true)\n\n    const { nodeIndex } = layout\n    const height = nodeIndex.length - 1\n\n    const top = nodeIndex[height]\n    if (top.length === 1) {\n      const root = nodes[nodes.length - 1]\n      nodes.length = nodes.length - 1\n      return { root, nodes, leaves: EMPTY }\n    } else {\n      const root = new Node(layout.lastID + 1, top, metadata)\n      return { root, nodes, leaves: EMPTY }\n    }\n  }\n}\n\n/**\n * @template T\n * @param {T[][]} index\n * @param {number} length\n */\nconst grow = (index, length) => {\n  while (index.length < length) {\n    index.push([])\n  }\n  return index\n}\n\n/** @type {never[]} */\nconst EMPTY = []\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2374, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/unixfs/src/file.js"],"sourcesContent":["import * as API from \"./file/api.js\"\nimport * as UnixFS from \"./codec.js\"\nimport * as Writer from \"./file/writer.js\"\nimport * as Task from \"actor\"\nimport { panic } from \"./writer/util.js\"\nimport * as FixedSize from \"./file/chunker/fixed.js\"\nimport { sha256 } from \"multiformats/hashes/sha2\"\nimport { CID } from \"multiformats/cid\"\nimport * as Balanced from \"./file/layout/balanced.js\"\n\nexport * from \"./file/api.js\"\n\n/**\n * @returns {API.EncoderSettings}\n */\nexport const defaults = () => ({\n  chunker: FixedSize,\n  fileChunkEncoder: UnixFSLeaf,\n  smallFileEncoder: UnixFSLeaf,\n  fileEncoder: UnixFS,\n  fileLayout: Balanced.withWidth(174),\n  hasher: sha256,\n  linker: { createLink: CID.createV1 },\n})\n\n/**\n * @template {unknown} Layout\n * @param {Partial<API.EncoderSettings<Layout>>} config\n * @returns {API.EncoderSettings<Layout>}\n */\nexport const configure = config => ({\n  ...defaults(),\n  ...config,\n})\n\nexport const UnixFSLeaf = {\n  code: UnixFS.code,\n  name: UnixFS.name,\n  encode: UnixFS.encodeFileChunk,\n}\n\nexport const UnixFSRawLeaf = {\n  code: UnixFS.code,\n  name: UnixFS.name,\n  encode: UnixFS.encodeRaw,\n}\n\n/**\n * @template Layout\n * @param {API.Options<Layout>} options\n * @returns {API.View<Layout>}\n */\nexport const create = ({ writer, metadata = {}, settings = defaults() }) =>\n  new FileWriterView(Writer.init(writer, metadata, configure(settings)))\n\n/**\n * @template T\n * @param {API.View<T>} view\n * @param {Uint8Array} bytes\n * @return {Promise<API.View<T>>}\n */\n\nexport const write = async (view, bytes) => {\n  await perform(view, Task.send({ type: \"write\", bytes }))\n  return view\n}\n\n/**\n * @template T\n * @param {API.View<T>} view\n * @param {API.CloseOptions} options\n */\nexport const close = async (\n  view,\n  { releaseLock = false, closeWriter = false } = {}\n) => {\n  await perform(view, Task.send({ type: \"close\" }))\n  const { state } = view\n  if (state.status === \"linked\") {\n    if (closeWriter) {\n      await view.state.writer.close()\n    } else if (releaseLock) {\n      view.state.writer.releaseLock()\n    }\n    return state.link\n    /* c8 ignore next 5 */\n  } else {\n    panic(\n      `Expected writer to be in 'linked' state after close, but it is in \"${state.status}\" instead`\n    )\n  }\n}\n\n/**\n * @template T\n * @param {API.View<T>} view\n * @param {Task.Effect<Writer.Message>} effect\n */\nconst perform = (view, effect) =>\n  Task.fork(\n    Task.loop(effect, message => {\n      const { state, effect } = Writer.update(message, view.state)\n      view.state = state\n      return effect\n    })\n  )\n\n/**\n * @template Layout\n * @implements {API.View<Layout>}\n */\nclass FileWriterView {\n  /**\n   * @param {Writer.State<Layout>} state\n   */\n  constructor(state) {\n    this.state = state\n  }\n  get writer() {\n    return this.state.writer\n  }\n  get settings() {\n    return this.state.config\n  }\n  /**\n   * @param {Uint8Array} bytes\n   * @returns {Promise<API.View<Layout>>}\n   */\n  write(bytes) {\n    return write(this, bytes)\n  }\n  /**\n   * @param {API.CloseOptions} [options]\n   * @returns {Promise<UnixFS.FileLink>}\n   */\n  close(options) {\n    return close(this, options)\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAOO,MAAM,WAAW,IAAM,CAAC;QAC7B,SAAS;QACT,kBAAkB;QAClB,kBAAkB;QAClB,aAAa;QACb,YAAY,qLAAkB,CAAC;QAC/B,QAAQ,qLAAM;QACd,QAAQ;YAAE,YAAY,4KAAG,CAAC,QAAQ;QAAC;IACrC,CAAC;AAOM,MAAM,YAAY,CAAA,SAAU,CAAC;QAClC,GAAG,UAAU;QACb,GAAG,MAAM;IACX,CAAC;AAEM,MAAM,aAAa;IACxB,MAAM,oJAAO,IAAI;IACjB,MAAM,oJAAO,IAAI;IACjB,QAAQ,oJAAO,eAAe;AAChC;AAEO,MAAM,gBAAgB;IAC3B,MAAM,oJAAO,IAAI;IACjB,MAAM,oJAAO,IAAI;IACjB,QAAQ,oJAAO,SAAS;AAC1B;AAOO,MAAM,SAAS,CAAC,EAAE,MAAM,EAAE,WAAW,CAAC,CAAC,EAAE,WAAW,UAAU,EAAE,GACrE,IAAI,eAAe,oKAAW,CAAC,QAAQ,UAAU,UAAU;AAStD,MAAM,QAAQ,OAAO,MAAM;IAChC,MAAM,QAAQ,MAAM,8JAAS,CAAC;QAAE,MAAM;QAAS;IAAM;IACrD,OAAO;AACT;AAOO,MAAM,QAAQ,OACnB,MACA,EAAE,cAAc,KAAK,EAAE,cAAc,KAAK,EAAE,GAAG,CAAC,CAAC;IAEjD,MAAM,QAAQ,MAAM,8JAAS,CAAC;QAAE,MAAM;IAAQ;IAC9C,MAAM,EAAE,KAAK,EAAE,GAAG;IAClB,IAAI,MAAM,MAAM,KAAK,UAAU;QAC7B,IAAI,aAAa;YACf,MAAM,KAAK,KAAK,CAAC,MAAM,CAAC,KAAK;QAC/B,OAAO,IAAI,aAAa;YACtB,KAAK,KAAK,CAAC,MAAM,CAAC,WAAW;QAC/B;QACA,OAAO,MAAM,IAAI;IACjB,oBAAoB,GACtB,OAAO;QACL,IAAA,qKAAK,EACH,CAAC,mEAAmE,EAAE,MAAM,MAAM,CAAC,SAAS,CAAC;IAEjG;AACF;AAEA;;;;CAIC,GACD,MAAM,UAAU,CAAC,MAAM,SACrB,8JAAS,CACP,8JAAS,CAAC,QAAQ,CAAA;QAChB,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,GAAG,sKAAa,CAAC,SAAS,KAAK,KAAK;QAC3D,KAAK,KAAK,GAAG;QACb,OAAO;IACT;AAGJ;;;CAGC,GACD,MAAM;IACJ;;GAEC,GACD,YAAY,KAAK,CAAE;QACjB,IAAI,CAAC,KAAK,GAAG;IACf;IACA,IAAI,SAAS;QACX,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM;IAC1B;IACA,IAAI,WAAW;QACb,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM;IAC1B;IACA;;;GAGC,GACD,MAAM,KAAK,EAAE;QACX,OAAO,MAAM,IAAI,EAAE;IACrB;IACA;;;GAGC,GACD,MAAM,OAAO,EAAE;QACb,OAAO,MAAM,IAAI,EAAE;IACrB;AACF","ignoreList":[0]}},
    {"offset": {"line": 2500, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/unixfs/src/directory/api.js"],"sourcesContent":["// @ts-nocheck\n\n/**\n * This is file is shadowed by api.ts and only exists so JS could import it to\n * refer to types without encountering runtime errors\n * @see https://github.com/microsoft/TypeScript/issues/41825\n */\n"],"names":[],"mappings":"AAAA,cAAc;AAEd;;;;CAIC","ignoreList":[0]}},
    {"offset": {"line": 2510, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/unixfs/src/directory.js"],"sourcesContent":["import * as API from \"./directory/api.js\"\nimport * as File from \"./file.js\"\nimport * as UnixFS from \"./codec.js\"\nexport * from \"./directory/api.js\"\n\nexport const configure = File.configure\nexport const defaults = File.defaults\n\n/**\n * @template [Layout=unknown]\n * @param {API.Options<Layout>} config\n * @returns {API.View<Layout>}\n */\nexport const create = ({ writer, settings = defaults(), metadata = {} }) =>\n  new DirectoryWriter({\n    writer,\n    metadata,\n    settings,\n    entries: new Map(),\n    closed: false,\n  })\n\n/**\n * @template {unknown} L\n * @template {{ state: API.State<L> }} View\n * @param {View} view\n * @param {string} name\n * @param {API.EntryLink} link\n * @param {API.WriteOptions} options\n */\nexport const set = (view, name, link, { overwrite = false } = {}) => {\n  const writable = asWritable(view.state)\n  if (name.includes(\"/\")) {\n    throw new Error(\n      `Directory entry name \"${name}\" contains forbidden \"/\" character`\n    )\n  }\n  if (!overwrite && writable.entries.has(name)) {\n    throw new Error(`Directory already contains entry with name \"${name}\"`)\n  } else {\n    writable.entries.set(name, link)\n    return view\n  }\n}\n\n/**\n * @template {unknown} L\n * @template {{ state: API.State<L> }} View\n * @param {View} view\n * @param {string} name\n */\nexport const remove = (view, name) => {\n  const writer = asWritable(view.state)\n  writer.entries.delete(name)\n  return view\n}\n\n/**\n * @template {API.State} Writer\n * @param {Writer} writer\n * @returns {Writer}\n */\nconst asWritable = writer => {\n  if (!writer.closed) {\n    return writer\n  } else {\n    throw new Error(\n      `Can not change written directory, but you can .fork() and make changes to it`\n    )\n  }\n}\n\n/**\n * @template {unknown} Layout\n * @param {{ state: API.State<Layout> }} view\n * @param {API.CloseOptions} options\n * @returns {Promise<UnixFS.DirectoryLink>}\n */\nexport const close = async (\n  view,\n  { closeWriter = false, releaseLock = false } = {}\n) => {\n  const { writer, settings, metadata } = asWritable(view.state)\n  view.state.closed = true\n  const entries = [...links(view)]\n  const node = UnixFS.createFlatDirectory(entries, metadata)\n  const bytes = UnixFS.encodeDirectory(node)\n  const digest = await settings.hasher.digest(bytes)\n  /** @type {UnixFS.Link<UnixFS.Directory>} */\n  const cid = settings.linker.createLink(UnixFS.code, digest)\n\n  // we make sure that writer has some capacity for this write. If it\n  // does not we await.\n  if ((writer.desiredSize || 0) <= 0) {\n    await writer.ready\n  }\n  // once writer has some capacity we write a block, however we do not\n  // await completion as we don't care when it's taken off the stream.\n  writer.write({ cid, bytes })\n\n  if (closeWriter) {\n    await writer.close()\n  } else if (releaseLock) {\n    writer.releaseLock()\n  }\n\n  return {\n    cid,\n    dagByteLength: UnixFS.cumulativeDagByteLength(bytes, entries),\n  }\n}\n\n/**\n * @template {unknown} Layout\n * @param {{ state: API.State<Layout> }} view\n * @returns {IterableIterator<UnixFS.DirectoryEntryLink>}\n */\nexport const links = function* ({ state }) {\n  for (const [name, { dagByteLength, cid }] of state.entries) {\n    yield /** @type {UnixFS.DirectoryEntryLink} */ ({\n      name,\n      dagByteLength,\n      cid,\n    })\n  }\n}\n\n/**\n * @template L1, L2\n * @param {API.View<L1>} state\n * @param {Partial<API.Options<L1|L2>>} options\n * @returns {API.View<L1|L2>}\n */\nexport const fork = (\n  { state },\n  {\n    writer = state.writer,\n    metadata = state.metadata,\n    settings = state.settings,\n  } = {}\n) =>\n  new DirectoryWriter({\n    writer,\n    metadata,\n    settings,\n    entries: new Map(state.entries.entries()),\n    closed: false,\n  })\n\n/**\n * @template [Layout=unknown]\n * @implements {API.View<Layout>}\n */\nclass DirectoryWriter {\n  /**\n   * @param {API.State<Layout>} state\n   */\n  constructor(state) {\n    this.state = state\n  }\n  get writer() {\n    return this.state.writer\n  }\n  get settings() {\n    return this.state.settings\n  }\n\n  links() {\n    return links(this)\n  }\n\n  /**\n   * @param {string} name\n   * @param {UnixFS.FileLink | UnixFS.DirectoryLink} link\n   * @param {API.WriteOptions} [options]\n   */\n\n  set(name, link, options) {\n    return set(this, name, link, options)\n  }\n\n  /**\n   * @param {string} name\n   */\n  remove(name) {\n    return remove(this, name)\n  }\n\n  /**\n   * @template L\n   * @param {Partial<API.Options<L>>} [options]\n   * @returns {API.View<Layout|L>}\n   */\n  fork(options) {\n    return fork(this, options)\n  }\n\n  /**\n   * @param {API.CloseOptions} [options]\n   * @returns {Promise<UnixFS.DirectoryLink>}\n   */\n  close(options) {\n    return close(this, options)\n  }\n\n  entries() {\n    return this.state.entries.entries()\n  }\n  /**\n   * @param {string} name\n   */\n  has(name) {\n    return this.state.entries.has(name)\n  }\n  get size() {\n    return this.state.entries.size\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2678, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/unixfs/src/sharded-directory.js"],"sourcesContent":["\nimport * as PermaMap from \"@perma/map\"\nimport * as UnixFSPermaMap from \"@perma/map/unixfs\"\nimport * as PB from \"@ipld/dag-pb\"\nimport { murmur364 } from \"@multiformats/murmur3\"\nimport { Block } from 'multiformats/block'\nimport * as API from \"./directory/api.js\"\nimport * as File from \"./file.js\"\nimport * as UnixFS from \"./codec.js\"\nimport { set, remove } from \"./directory.js\"\n\nexport * from \"./directory/api.js\"\nexport { set, remove } from \"./directory.js\"\n\nexport const configure = File.configure\nexport const defaults = File.defaults\n\n/**\n * @template [Layout=unknown]\n * @param {API.Options<Layout>} config\n * @returns {API.View<Layout>}\n */\nexport const create = ({ writer, settings = defaults(), metadata = {} }) =>\n  new HAMTDirectoryWriter({\n    writer,\n    metadata,\n    settings,\n    entries: new HashMap(),\n    closed: false,\n  })\n\n/**\n * @template {API.State} Writer\n * @param {Writer} writer\n * @returns {Writer}\n */\nconst asWritable = writer => {\n  if (!writer.closed) {\n    return writer\n  } else {\n    throw new Error(\"Can not change written HAMT directory, but you can .fork() and make changes to it\")\n  }\n}\n\n/**\n * @template {unknown} Layout\n * @param {{ state: API.State<Layout> }} view\n * @param {API.CloseOptions} options\n * @returns {Promise<UnixFS.DirectoryLink>}\n */\nexport const close = async (\n  view,\n  { closeWriter = false, releaseLock = false } = {}\n) => {\n  const { writer, settings, metadata } = asWritable(view.state)\n  view.state.closed = true\n\n  const { entries } = view.state\n  /* c8 ignore next 3 */\n  if (!(entries instanceof HashMap)) {\n    throw new Error(`not a HAMT: ${entries}`)\n  }\n\n  const hamt = entries.builder.build()\n  const blocks = iterateBlocks(hamt, hamt.root, settings)\n\n  /** @type {UnixFS.BlockView<UnixFS.DirectoryShard>?} */\n  let root = null\n  for await (const block of blocks) {\n    root = block\n    // we make sure that writer has some capacity for this write. If it\n    // does not we await.\n    if ((writer.desiredSize || 0) <= 0) {\n      await writer.ready\n    }\n    // once writer has some capacity we write a block, however we do not\n    // await completion as we don't care when it's taken off the stream.\n    writer.write(block)\n  }\n  /* c8 ignore next */\n  if (root == null) throw new Error(\"no root block yielded\")\n\n  if (closeWriter) {\n    await writer.close()\n  } else if (releaseLock) {\n    writer.releaseLock()\n  }\n\n  return {\n    cid: root.cid,\n    dagByteLength: UnixFS.cumulativeDagByteLength(root.bytes, root.value.entries),\n  }\n}\n\n/**\n * @template {unknown} Layout\n * @param {UnixFSPermaMap.PersistentHashMap<API.EntryLink>} hamt\n * @param {UnixFSPermaMap.BitmapIndexedNode<API.EntryLink>} node\n * @param {API.EncoderSettings<Layout>} settings\n * @returns {AsyncIterableIterator<UnixFS.BlockView<UnixFS.DirectoryShard>>}\n */\nconst iterateBlocks = async function* (hamt, node, settings) {\n  /** @type {UnixFS.DirectoryEntryLink[]} */\n  const entries = []\n  for (const ent of UnixFSPermaMap.iterate(node)) {\n    if ('key' in ent) {\n      entries.push(/** @type {UnixFS.DirectoryEntryLink} */ ({\n        name: `${ent.prefix ?? ''}${ent.key ?? ''}`,\n        dagByteLength: ent.value.dagByteLength,\n        cid: ent.value.cid,\n      }))\n    } else {\n      /** @type {UnixFS.BlockView<UnixFS.DirectoryShard>?} */\n      let root = null\n      for await (const block of iterateBlocks(hamt, ent.node, settings)) {\n        yield block\n        root = block\n      }\n      /* c8 ignore next */\n      if (root == null) throw new Error(\"no root block yielded\")\n\n      entries.push(/** @type {UnixFS.ShardedDirectoryLink} */ ({\n        name: ent.prefix,\n        dagByteLength: UnixFS.cumulativeDagByteLength(root.bytes, root.value.entries),\n        cid: root.cid\n      }))\n    }\n  }\n\n  const shard = UnixFS.createDirectoryShard(\n    entries,\n    UnixFSPermaMap.bitField(node),\n    UnixFSPermaMap.tableSize(hamt),\n    murmur364.code\n  )\n  yield await encodeHAMTShardBlock(shard, settings)\n}\n\n/**\n * @template {unknown} Layout\n * @param {UnixFS.DirectoryShard} shard\n * @param {API.EncoderSettings<Layout>} settings\n * @returns {Promise<UnixFS.BlockView<UnixFS.DirectoryShard>>}\n */\nasync function encodeHAMTShardBlock (shard, settings) {\n  const bytes = UnixFS.encodeHAMTShard(shard)\n  const hash = await settings.hasher.digest(bytes)\n  const cid = settings.linker.createLink(PB.code, hash)\n  // @ts-ignore Link is not CID\n  return new Block({ cid, bytes, value: shard })\n}\n\n/**\n * @template L1, L2\n * @param {API.View<L1>} state\n * @param {Partial<API.Options<L1|L2>>} options\n * @returns {API.View<L1|L2>}\n */\nexport const fork = (\n  { state },\n  {\n    writer = state.writer,\n    metadata = state.metadata,\n    settings = state.settings,\n  } = {}\n) =>\n  new HAMTDirectoryWriter({\n    writer,\n    metadata,\n    settings,\n    entries: new HashMap(UnixFSPermaMap.from(state.entries.entries()).createBuilder()),\n    closed: false,\n  })\n\n/**\n * @template [Layout=unknown]\n * @implements {API.View<Layout>}\n */\nclass HAMTDirectoryWriter {\n  /**\n   * @param {API.State<Layout>} state\n   */\n  constructor(state) {\n    this.state = state\n  }\n  get writer() {\n    return this.state.writer\n  }\n  get settings() {\n    return this.state.settings\n  }\n\n  /**\n   * @param {string} name\n   * @param {UnixFS.FileLink | UnixFS.DirectoryLink} link\n   * @param {API.WriteOptions} [options]\n   */\n\n  set(name, link, options) {\n    return set(this, name, link, options)\n  }\n\n  /**\n   * @param {string} name\n   */\n  remove(name) {\n    return remove(this, name)\n  }\n\n  /**\n   * @template L\n   * @param {Partial<API.Options<L>>} [options]\n   * @returns {API.View<Layout|L>}\n   */\n  fork(options) {\n    return fork(this, options)\n  }\n\n  /**\n   * @param {API.CloseOptions} [options]\n   * @returns {Promise<UnixFS.DirectoryLink>}\n   */\n  close(options) {\n    return close(this, options)\n  }\n\n  entries() {\n    return this.state.entries.entries()\n  }\n  /**\n   * @param {string} name\n   */\n  has(name) {\n    return this.state.entries.has(name)\n  }\n  get size() {\n    return this.state.entries.size\n  }\n}\n\n/**\n * @implements {Map<string, API.EntryLink>}\n */\nclass HashMap extends Map {\n  /**\n   * @param {UnixFSPermaMap.HashMapBuilder} [builder]\n   */\n  constructor (builder = UnixFSPermaMap.builder()) {\n    super()\n    /** @type {UnixFSPermaMap.HashMapBuilder} */\n    this.builder = builder\n  }\n\n  clear() {\n    this.builder = UnixFSPermaMap.builder()\n  }\n\n  /**\n   * @param {string} key\n   */\n  delete(key) {\n    const { root } = this.builder\n    this.builder.delete(key)\n    return this.builder.root !== root\n  }\n\n  /**\n   * @param {(value: API.EntryLink, key: string, map: Map<string, API.EntryLink>) => void} callbackfn\n   * @param {any} [thisArg]\n   */\n  forEach(callbackfn, thisArg = this) {\n    for (const [k, v] of this.builder.root.entries()) {\n      callbackfn.call(thisArg, v, k, this)\n    }\n  }\n\n  /**\n   * @param {string} key\n   */\n  get(key) {\n    return PermaMap.get(this.builder, key)\n  }\n\n  /**\n   * @param {string} key\n   */\n  has(key) {\n    return PermaMap.has(this.builder, key)\n  }\n\n  /**\n   * @param {string} key \n   * @param {API.EntryLink} value \n   */\n  set(key, value) {\n    this.builder.set(key, value)\n    return this\n  }\n\n  get size () {\n    return this.builder.size\n  }\n\n  [Symbol.iterator]() {\n    return this.builder.root.entries()\n  }\n\n  entries() {\n    return this.builder.root.entries()\n  }\n\n  keys() {\n    return this.builder.root.keys()\n  }\n\n  values() {\n    return this.builder.root.values()\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2933, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/unixfs/src/lib.js"],"sourcesContent":["import * as API from \"./api.js\"\nimport * as File from \"./file.js\"\nimport * as Directory from \"./directory.js\"\n\nexport * from \"./api.js\"\n\nexport { encode, decode, NodeType, code } from \"./codec.js\"\nexport {\n  create as createFileWriter,\n  close as closeFile,\n  write,\n  configure,\n  defaults,\n  UnixFSLeaf,\n  UnixFSRawLeaf,\n} from \"./file.js\"\nexport {\n  create as createDirectoryWriter,\n  close as closeDirectory,\n  fork as forkDirectory,\n  set,\n  remove,\n} from \"./directory.js\"\nexport {\n  create as createShardedDirectoryWriter,\n  close as closeShardedDirectory,\n  fork as forkShardedDirectory,\n} from \"./sharded-directory.js\"\n\n/**\n * @template [Layout=unknown]\n * @param {API.Options<Layout>} options\n * @returns {API.View<Layout>}\n */\nexport const createWriter = ({ writable, settings = File.defaults() }) =>\n  new FileSystemWriter({\n    writer: writable.getWriter(),\n    settings,\n  })\n\n/**\n * @template {{writer:API.BlockWriter}} View\n * @param {View} view\n * @param {API.CloseOptions} options\n */\nexport const close = async (\n  view,\n  { releaseLock = true, closeWriter = true } = {}\n) => {\n  if (closeWriter) {\n    await view.writer.close()\n  } else if (releaseLock) {\n    view.writer.releaseLock()\n  }\n\n  return view\n}\n\n/**\n * @template [Layout=unknown]\n * @implemets {API.View<Layout>}\n */\nclass FileSystemWriter {\n  /**\n   * @param {object} options\n   * @param {API.BlockWriter} options.writer\n   * @param {Partial<API.EncoderSettings<Layout>>} options.settings\n   */\n  constructor({ writer, settings }) {\n    this.writer = writer\n    this.settings = File.configure(settings)\n  }\n\n  /**\n   * @template [L=unknown]\n   * @param {API.WriterOptions<L|Layout>} config\n   */\n  createFileWriter({ settings = this.settings, metadata } = {}) {\n    return File.create({\n      writer: this.writer,\n      settings,\n      metadata,\n    })\n  }\n\n  /**\n   * @template [L=unknown]\n   * @param {API.WriterOptions<L|Layout>} config\n   */\n  createDirectoryWriter({ settings = this.settings, metadata } = {}) {\n    return Directory.create({\n      writer: this.writer,\n      settings,\n      metadata,\n    })\n  }\n\n  /**\n   * @param {API.CloseOptions} [options]\n   */\n  close(options) {\n    return close(this, options)\n  }\n}\n\n// BlockSizeLimit specifies the maximum size an imported block can have.\n// @see https://github.com/ipfs/go-unixfs/blob/68c015a6f317ed5e21a4870f7c423a4b38b90a96/importer/helpers/helpers.go#L7-L8\nexport const BLOCK_SIZE_LIMIT = 1048576 // 1 MB\nexport const defaultCapacity = BLOCK_SIZE_LIMIT * 100\n\n/**\n * Creates `QueuingStrategy` that can fit blocks with total size up to given\n * byteLength.\n *\n * @param {number} byteLength\n * @returns {Required<QueuingStrategy<API.Block>>}\n */\nexport const withCapacity = (byteLength = defaultCapacity) => ({\n  highWaterMark: byteLength,\n  size: block => block.bytes.length,\n})\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;AACA;AACA;AAIA;AAiBA;;;;;;;;;AAWO,MAAM,eAAe,CAAC,EAAE,QAAQ,EAAE,WAAW,8KAAa,EAAE,EAAE,GACnE,IAAI,iBAAiB;QACnB,QAAQ,SAAS,SAAS;QAC1B;IACF;AAOK,MAAM,QAAQ,OACnB,MACA,EAAE,cAAc,IAAI,EAAE,cAAc,IAAI,EAAE,GAAG,CAAC,CAAC;IAE/C,IAAI,aAAa;QACf,MAAM,KAAK,MAAM,CAAC,KAAK;IACzB,OAAO,IAAI,aAAa;QACtB,KAAK,MAAM,CAAC,WAAW;IACzB;IAEA,OAAO;AACT;AAEA;;;CAGC,GACD,MAAM;IACJ;;;;GAIC,GACD,YAAY,EAAE,MAAM,EAAE,QAAQ,EAAE,CAAE;QAChC,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,QAAQ,GAAG,+KAAc,CAAC;IACjC;IAEA;;;GAGC,GACD,iBAAiB,EAAE,WAAW,IAAI,CAAC,QAAQ,EAAE,QAAQ,EAAE,GAAG,CAAC,CAAC,EAAE;QAC5D,OAAO,4KAAW,CAAC;YACjB,QAAQ,IAAI,CAAC,MAAM;YACnB;YACA;QACF;IACF;IAEA;;;GAGC,GACD,sBAAsB,EAAE,WAAW,IAAI,CAAC,QAAQ,EAAE,QAAQ,EAAE,GAAG,CAAC,CAAC,EAAE;QACjE,OAAO,iLAAgB,CAAC;YACtB,QAAQ,IAAI,CAAC,MAAM;YACnB;YACA;QACF;IACF;IAEA;;GAEC,GACD,MAAM,OAAO,EAAE;QACb,OAAO,MAAM,IAAI,EAAE;IACrB;AACF;AAIO,MAAM,mBAAmB,QAAQ,OAAO;;AACxC,MAAM,kBAAkB,mBAAmB;AAS3C,MAAM,eAAe,CAAC,aAAa,eAAe,GAAK,CAAC;QAC7D,eAAe;QACf,MAAM,CAAA,QAAS,MAAM,KAAK,CAAC,MAAM;IACnC,CAAC","ignoreList":[0]}}]
}