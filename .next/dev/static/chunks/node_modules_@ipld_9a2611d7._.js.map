{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 9, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/dag-ucan/src/utf8.js"],"sourcesContent":["export const encoder = new TextEncoder()\nexport const decoder = new TextDecoder()\n\n/**\n * @template T\n * @param {import('./ucan').ToString<T>} text\n * @returns {import('./ucan').ByteView<T>}\n */\nexport const encode = text => encoder.encode(text)\n\n/**\n * @template T\n * @param {import('./ucan').ByteView<T>} bytes\n * @returns {import('./ucan').ToString<T>}\n */\nexport const decode = bytes => decoder.decode(bytes)\n"],"names":[],"mappings":";;;;;;;;;;AAAO,MAAM,UAAU,IAAI;AACpB,MAAM,UAAU,IAAI;AAOpB,MAAM,SAAS,CAAA,OAAQ,QAAQ,MAAM,CAAC;AAOtC,MAAM,SAAS,CAAA,QAAS,QAAQ,MAAM,CAAC","ignoreList":[0]}},
    {"offset": {"line": 27, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/dag-ucan/src/did.js"],"sourcesContent":["import * as UCAN from \"./ucan.js\"\nimport { base58btc } from \"multiformats/bases/base58\"\nimport { varint } from \"multiformats\"\nimport * as UTF8 from \"./utf8.js\"\n\nconst DID_PREFIX = \"did:\"\nconst DID_PREFIX_SIZE = DID_PREFIX.length\nconst DID_KEY_PREFIX = `did:key:`\nconst DID_KEY_PREFIX_SIZE = DID_KEY_PREFIX.length\n\nexport const ED25519 = 0xed\nexport const RSA = 0x1205\nexport const P256 = 0x1200\nexport const P384 = 0x1201\nexport const P521 = 0x1202\nexport const SECP256K1 = 0xe7\nexport const BLS12381G1 = 0xea\nexport const BLS12381G2 = 0xeb\nexport const DID_CORE = 0x0d1d\nconst METHOD_OFFSET = varint.encodingLength(DID_CORE)\n\n/**\n * @typedef {typeof ED25519|typeof RSA|typeof P256|typeof P384|typeof P521|typeof DID_CORE} Code\n */\n\n/**\n * Parses a DID string into a DID buffer view\n *\n * @template {UCAN.DID} ID\n * @param {ID|UCAN.ToString<unknown>} did\n * @returns {UCAN.PrincipalView<ID>}\n */\nexport const parse = did => {\n  if (!did.startsWith(DID_PREFIX)) {\n    throw new RangeError(`Invalid DID \"${did}\", must start with 'did:'`)\n  } else if (did.startsWith(DID_KEY_PREFIX)) {\n    const key = base58btc.decode(did.slice(DID_KEY_PREFIX_SIZE))\n    return decode(key)\n  } else {\n    const suffix = UTF8.encode(did.slice(DID_PREFIX_SIZE))\n    const bytes = new Uint8Array(suffix.byteLength + METHOD_OFFSET)\n    varint.encodeTo(DID_CORE, bytes)\n    bytes.set(suffix, METHOD_OFFSET)\n    return new DID(bytes)\n  }\n}\n\n/**\n * @template {UCAN.DID} ID\n * @param {UCAN.Principal<ID>} id\n * @returns {ID}\n */\nexport const format = id => id.did()\n\n/**\n * @template {UCAN.DID} ID\n * @param {UCAN.PrincipalView<ID>|UCAN.ByteView<UCAN.Principal<ID>>|UCAN.Principal<ID>|ID|UCAN.ToJSONString<unknown>} principal\n * @returns {UCAN.PrincipalView<ID>}\n */\nexport const from = principal => {\n  if (principal instanceof DID) {\n    return principal\n  } else if (principal instanceof Uint8Array) {\n    return decode(principal)\n  } else if (typeof principal === \"string\") {\n    return parse(principal)\n  } else {\n    return parse(principal.did())\n  }\n}\n\n/**\n * @template {UCAN.DID} ID\n * @param {UCAN.ByteView<UCAN.Principal<ID>>} bytes\n * @returns {UCAN.PrincipalView<ID>}\n */\nexport const decode = bytes => {\n  const [code] = varint.decode(bytes)\n  const { buffer, byteOffset, byteLength } = bytes\n  switch (code) {\n    case P256:\n      if (bytes.length > 35) {\n        throw new RangeError(`Only p256-pub compressed is supported.`)\n      }\n    case ED25519:\n    case RSA:\n    case P384:\n    case P521:\n    case BLS12381G1:\n    case BLS12381G2:\n    case SECP256K1:\n      return /** @type {UCAN.PrincipalView<any>} */ (\n        new DIDKey(buffer, byteOffset, byteLength)\n      )\n    case DID_CORE:\n      return new DID(buffer, byteOffset, byteLength)\n    default:\n      throw new RangeError(\n        `Unsupported DID encoding, unknown multicode 0x${code.toString(16)}.`\n      )\n  }\n}\n\n/**\n * @template {UCAN.DID} ID\n * @param {UCAN.Principal<ID>} principal\n * @returns {UCAN.PrincipalView<ID>}\n */\nexport const encode = principal => parse(principal.did())\n\n/**\n * @template {UCAN.DID} ID\n * @implements {UCAN.PrincipalView<ID>}\n * @extends {Uint8Array}\n */\nclass DID extends Uint8Array {\n  /**\n   * @returns {ID}\n   */\n  did() {\n    const bytes = new Uint8Array(this.buffer, this.byteOffset + METHOD_OFFSET)\n    return /** @type {ID} */ (`did:${UTF8.decode(bytes)}`)\n  }\n\n  toJSON() {\n    return this.did()\n  }\n}\n\n/**\n * @implements {UCAN.PrincipalView<UCAN.DID<\"key\">>}\n * @extends {DID<UCAN.DID<\"key\">>}\n */\nclass DIDKey extends DID {\n  /**\n   * @return {`did:key:${string}`}\n   */\n  did() {\n    return `did:key:${base58btc.encode(this)}`\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AAAA;AACA;;;;;AAEA,MAAM,aAAa;AACnB,MAAM,kBAAkB,WAAW,MAAM;AACzC,MAAM,iBAAiB,CAAC,QAAQ,CAAC;AACjC,MAAM,sBAAsB,eAAe,MAAM;AAE1C,MAAM,UAAU;AAChB,MAAM,MAAM;AACZ,MAAM,OAAO;AACb,MAAM,OAAO;AACb,MAAM,OAAO;AACb,MAAM,YAAY;AAClB,MAAM,aAAa;AACnB,MAAM,aAAa;AACnB,MAAM,WAAW;AACxB,MAAM,gBAAgB,6OAAM,CAAC,cAAc,CAAC;AAarC,MAAM,QAAQ,CAAA;IACnB,IAAI,CAAC,IAAI,UAAU,CAAC,aAAa;QAC/B,MAAM,IAAI,WAAW,CAAC,aAAa,EAAE,IAAI,yBAAyB,CAAC;IACrE,OAAO,IAAI,IAAI,UAAU,CAAC,iBAAiB;QACzC,MAAM,MAAM,uNAAS,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC;QACvC,OAAO,OAAO;IAChB,OAAO;QACL,MAAM,SAAS,iKAAW,CAAC,IAAI,KAAK,CAAC;QACrC,MAAM,QAAQ,IAAI,WAAW,OAAO,UAAU,GAAG;QACjD,6OAAM,CAAC,QAAQ,CAAC,UAAU;QAC1B,MAAM,GAAG,CAAC,QAAQ;QAClB,OAAO,IAAI,IAAI;IACjB;AACF;AAOO,MAAM,SAAS,CAAA,KAAM,GAAG,GAAG;AAO3B,MAAM,OAAO,CAAA;IAClB,IAAI,qBAAqB,KAAK;QAC5B,OAAO;IACT,OAAO,IAAI,qBAAqB,YAAY;QAC1C,OAAO,OAAO;IAChB,OAAO,IAAI,OAAO,cAAc,UAAU;QACxC,OAAO,MAAM;IACf,OAAO;QACL,OAAO,MAAM,UAAU,GAAG;IAC5B;AACF;AAOO,MAAM,SAAS,CAAA;IACpB,MAAM,CAAC,KAAK,GAAG,6OAAM,CAAC,MAAM,CAAC;IAC7B,MAAM,EAAE,MAAM,EAAE,UAAU,EAAE,UAAU,EAAE,GAAG;IAC3C,OAAQ;QACN,KAAK;YACH,IAAI,MAAM,MAAM,GAAG,IAAI;gBACrB,MAAM,IAAI,WAAW,CAAC,sCAAsC,CAAC;YAC/D;QACF,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;YACH,OACE,IAAI,OAAO,QAAQ,YAAY;QAEnC,KAAK;YACH,OAAO,IAAI,IAAI,QAAQ,YAAY;QACrC;YACE,MAAM,IAAI,WACR,CAAC,8CAA8C,EAAE,KAAK,QAAQ,CAAC,IAAI,CAAC,CAAC;IAE3E;AACF;AAOO,MAAM,SAAS,CAAA,YAAa,MAAM,UAAU,GAAG;AAEtD;;;;CAIC,GACD,MAAM,YAAY;IAChB;;GAEC,GACD,MAAM;QACJ,MAAM,QAAQ,IAAI,WAAW,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,UAAU,GAAG;QAC5D,OAA0B,CAAC,IAAI,EAAE,iKAAW,CAAC,QAAQ;IACvD;IAEA,SAAS;QACP,OAAO,IAAI,CAAC,GAAG;IACjB;AACF;AAEA;;;CAGC,GACD,MAAM,eAAe;IACnB;;GAEC,GACD,MAAM;QACJ,OAAO,CAAC,QAAQ,EAAE,uNAAS,CAAC,MAAM,CAAC,IAAI,GAAG;IAC5C;AACF","ignoreList":[0]}},
    {"offset": {"line": 158, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/dag-ucan/src/signature.js"],"sourcesContent":["import * as UCAN from \"./ucan.js\"\nimport { varint } from \"multiformats\"\nimport { base64url, base64 } from \"multiformats/bases/base64\"\nimport * as UTF8 from \"./utf8.js\"\n\nexport const NON_STANDARD = 0xd000\nexport const ES256K = 0xd0e7\nexport const BLS12381G1 = 0xd0ea\nexport const BLS12381G2 = 0xd0eb\nexport const EdDSA = 0xd0ed\nexport const ES256 = 0xd01200\nexport const ES384 = 0xd01201\nexport const ES512 = 0xd01202\nexport const RS256 = 0xd01205\nexport const EIP191 = 0xd191\n\n/**\n * @param {number} code\n * @returns {string}\n */\nconst codeName = code => {\n  switch (code) {\n    case ES256K:\n      return \"ES256K\"\n    case BLS12381G1:\n      return \"BLS12381G1\"\n    case BLS12381G2:\n      return \"BLS12381G2\"\n    case EdDSA:\n      return \"EdDSA\"\n    case ES256:\n      return \"ES256\"\n    case ES384:\n      return \"ES384\"\n    case ES512:\n      return \"ES512\"\n    case RS256:\n      return \"RS256\"\n    case EIP191:\n      return \"EIP191\"\n    default:\n      throw new RangeError(\n        `Unknown signature algorithm code 0x${code.toString(16)}`\n      )\n  }\n}\n\n/**\n *\n * @param {string} name\n */\nexport const nameCode = name => {\n  switch (name) {\n    case \"ES256K\":\n      return ES256K\n    case \"BLS12381G1\":\n      return BLS12381G1\n    case \"BLS12381G2\":\n      return BLS12381G2\n    case \"EdDSA\":\n      return EdDSA\n    case \"ES256\":\n      return ES256\n    case \"ES384\":\n      return ES384\n    case \"ES512\":\n      return ES512\n    case \"RS256\":\n      return RS256\n    case \"EIP191\":\n      return EIP191\n    default:\n      return NON_STANDARD\n  }\n}\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @implements {UCAN.SignatureView<T, A>}\n */\nexport class Signature extends Uint8Array {\n  get code() {\n    const [code] = varint.decode(this)\n    Object.defineProperties(this, { code: { value: code } })\n    return /** @type {A} */ (code)\n  }\n\n  get size() {\n    const value = size(this)\n    Object.defineProperties(this, { size: { value } })\n    return value\n  }\n  get algorithm() {\n    const value = algorithm(this)\n    Object.defineProperties(this, { algorithm: { value } })\n    return value\n  }\n\n  get raw() {\n    const { buffer, byteOffset, size, code } = this\n    const codeSize = varint.encodingLength(code)\n    const rawSize = varint.encodingLength(size)\n    const value = new Uint8Array(buffer, byteOffset + codeSize + rawSize, size)\n    Object.defineProperties(this, { raw: { value } })\n    return value\n  }\n\n  /**\n   * Verify that this signature was created by the given key.\n   *\n   * @param {UCAN.Crypto.Verifier<A>} signer\n   * @param {UCAN.ByteView<T>} payload\n   */\n  async verify(signer, payload) {\n    try {\n      if ((await signer.verify(payload, this)) === true) {\n        return { ok: {} }\n      } else {\n        throw new Error(\"Invalid signature\")\n      }\n    } catch (cause) {\n      return { error: /** @type {Error} */ (cause) }\n    }\n  }\n\n  toJSON() {\n    return toJSON(this)\n  }\n}\n\n/**\n * @param {UCAN.Signature} signature\n */\nconst algorithm = signature => {\n  const { code, raw, buffer, byteOffset } = signature\n  if (code === NON_STANDARD) {\n    const offset =\n      raw.byteLength +\n      varint.encodingLength(code) +\n      varint.encodingLength(raw.byteLength)\n    const bytes = new Uint8Array(buffer, byteOffset + offset)\n    return UTF8.decode(bytes)\n  } else {\n    return codeName(code)\n  }\n}\n\n/**\n * @param {UCAN.Signature} signature\n */\nconst size = signature => {\n  const offset = varint.encodingLength(signature.code)\n  const [size] = varint.decode(\n    new Uint8Array(signature.buffer, signature.byteOffset + offset)\n  )\n  return size\n}\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @param {A} code\n * @param {Uint8Array} raw\n * @returns {UCAN.SignatureView<T, A>}\n */\nexport const create = (code, raw) => {\n  const _ = codeName(code)\n  const codeSize = varint.encodingLength(code)\n  const rawSize = varint.encodingLength(raw.byteLength)\n\n  /** @type {Signature<T, A>} */\n  const signature = new Signature(codeSize + rawSize + raw.byteLength)\n  varint.encodeTo(code, signature)\n  varint.encodeTo(raw.byteLength, signature, codeSize)\n  signature.set(raw, codeSize + rawSize)\n  Object.defineProperties(signature, {\n    code: { value: code },\n    size: { value: raw.byteLength },\n  })\n  return signature\n}\n\n/**\n * @template {unknown} T\n * @param {string} name\n * @param {Uint8Array} raw\n * @return {UCAN.SignatureView<T>}\n */\nexport const createNamed = (name, raw) => {\n  const code = nameCode(name)\n  return code === NON_STANDARD\n    ? createNonStandard(name, raw)\n    : create(code, raw)\n}\n\n/**\n * @template {unknown} T\n * @param {string} name\n * @param {Uint8Array} raw\n * @return {UCAN.SignatureView<T, typeof NON_STANDARD>}\n */\nexport const createNonStandard = (name, raw) => {\n  const code = NON_STANDARD\n  const codeSize = varint.encodingLength(code)\n  const rawSize = varint.encodingLength(raw.byteLength)\n  const nameBytes = UTF8.encode(name)\n  /** @type {Signature<T, typeof NON_STANDARD>} */\n  const signature = new Signature(\n    codeSize + rawSize + raw.byteLength + nameBytes.byteLength\n  )\n  varint.encodeTo(code, signature)\n  varint.encodeTo(raw.byteLength, signature, codeSize)\n  signature.set(raw, codeSize + rawSize)\n  signature.set(nameBytes, codeSize + rawSize + raw.byteLength)\n\n  return signature\n}\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @param {UCAN.ByteView<UCAN.Signature<T, A>>} bytes\n * @returns {UCAN.SignatureView<T, A>}\n */\nexport const view = bytes =>\n  new Signature(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @param {UCAN.ByteView<UCAN.Signature<T, A>>} bytes\n * @returns {UCAN.SignatureView<T, A>}\n */\nexport const decode = bytes => {\n  if (!(bytes instanceof Uint8Array)) {\n    throw new TypeError(\n      `Can only decode Uint8Array into a Signature, instead got ${JSON.stringify(\n        bytes\n      )}`\n    )\n  }\n\n  /** @type {UCAN.SignatureView<T, A>} */\n  const signature = view(bytes)\n  const { code, algorithm, raw } = signature\n  return signature\n}\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @param {UCAN.Signature<T, A>} signature\n * @returns {UCAN.ByteView<UCAN.Signature<T, A>>}\n */\nexport const encode = signature => decode(signature)\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @template {string} [Prefix=\"u\"]\n * @param {UCAN.Signature<T, A>} signature\n * @param {UCAN.MultibaseEncoder<Prefix>} [base]\n * @returns {UCAN.ToString<UCAN.Signature<T, A>>}\n */\nexport const format = (signature, base) => (base || base64url).encode(signature)\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @template {string} [Prefix=\"u\"]\n * @param {UCAN.ToString<UCAN.Signature<T, A>>} signature\n * @param {UCAN.MultibaseDecoder<Prefix>} [base]\n * @returns {UCAN.SignatureView<T, A>}\n */\nexport const parse = (signature, base) =>\n  /** @type {UCAN.SignatureView<T, A>} */ (\n    decode((base || base64url).decode(signature))\n  )\n\n/**\n * @template {UCAN.Signature} Signature\n * @param {Signature} signature\n * @returns {UCAN.SignatureJSON<Signature>}\n */\nexport const toJSON = signature => ({\n  \"/\": { bytes: base64.baseEncode(signature) },\n})\n\n/**\n * @template {unknown} T\n * @template {UCAN.SigAlg} A\n * @param {UCAN.SignatureJSON<UCAN.Signature<T, A>>} json\n * @returns {UCAN.SignatureView<T, A>}\n */\nexport const fromJSON = json => decode(base64.baseDecode(json[\"/\"].bytes))\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 413, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/dag-ucan/src/schema.js"],"sourcesContent":["import * as UCAN from \"./ucan.js\"\nimport * as UTF8 from \"./utf8.js\"\nimport * as Link from \"multiformats/link\"\nimport { identity } from \"multiformats/hashes/identity\"\nimport * as DID from \"./did.js\"\nimport * as raw from \"multiformats/codecs/raw\"\nimport * as Signature from \"./signature.js\"\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {Record<string, unknown>|UCAN.Payload<C>} data\n * @returns {UCAN.Payload<C>}\n */\nexport const readPayload = data =>\n  readPayloadWith(data, {\n    readPrincipal,\n    readProof,\n  })\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {Record<string, unknown>|UCAN.Payload<C>} data\n * @returns {UCAN.Payload<C>}\n */\nexport const readJWTPayload = data =>\n  readPayloadWith(data, {\n    readPrincipal: readStringPrincipal,\n    readProof: readStringProof,\n  })\n/**\n *\n * @template {UCAN.Capabilities} C\n * @param {Record<string, unknown>|UCAN.Payload<C>} data\n * @param {object} readers\n * @param {(source:unknown, context:string) => UCAN.Principal} readers.readPrincipal\n * @param {(source:unknown, context:string) => UCAN.Link} readers.readProof\n * @returns {UCAN.Payload<C>}\n */\nconst readPayloadWith = (data, { readPrincipal, readProof }) => ({\n  iss: readPrincipal(data.iss, \"iss\"),\n  aud: readPrincipal(data.aud, \"aud\"),\n  att: readCapabilities(data.att, \"att\"),\n  prf: readOptionalArray(data.prf, readProof, \"prf\") || [],\n  exp: readNullable(data.exp === Infinity ? null : data.exp, readInt, \"exp\"),\n  nbf: readOptional(data.nbf, readInt, \"nbf\"),\n  fct: readOptionalArray(data.fct, readFact, \"fct\") || [],\n  nnc: readOptional(data.nnc, readString, \"nnc\"),\n})\n\n/**\n * @template {unknown} T\n * @template {number} A\n * @param {UCAN.ByteView<UCAN.Signature<T, A>>|unknown} source\n */\nexport const readSignature = source => {\n  if (source instanceof Uint8Array) {\n    return Signature.decode(source)\n  } else {\n    throw new TypeError(\n      `Can only decode Uint8Array into a Signature, instead got ${JSON.stringify(\n        source\n      )}`\n    )\n  }\n}\n\n/**\n * @param {unknown} input\n * @param {string} name\n * @returns {number}\n */\nexport const readInt = (input, name) =>\n  Number.isInteger(input)\n    ? /** @type {number} */ (input)\n    : ParseError.throw(\n        `Expected ${name} to be integer, instead got ${JSON.stringify(input)}`\n      )\n\n/**\n * @param {unknown} input\n * @param {string} context\n */\n\nexport const readCapability = (input, context) =>\n  readStruct(input, asCapability, context)\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {unknown|C} input\n * @param {string} context\n * @returns {C}\n */\nexport const readCapabilities = (input, context) =>\n  /** @type {C} */ (readArray(input, readCapability, context))\n\n/**\n * @template {UCAN.Capability} C\n * @param {object & {can?:unknown, with?:unknown}|C} input\n * @returns {C}\n */\nexport const asCapability = input =>\n  /** @type {C} */ ({\n    ...input,\n    can: readAbility(input.can),\n    with: readResource(input.with),\n  })\n\n/**\n * @param {unknown} input\n */\nconst readAbility = input =>\n  typeof input !== \"string\"\n    ? ParseError.throw(\n        `Capability has invalid 'can: ${JSON.stringify(\n          input\n        )}', value must be a string`\n      )\n    : input.slice(1, -1).includes(\"/\")\n    ? /** @type {UCAN.Ability} */ (input.toLocaleLowerCase())\n    : input === \"*\"\n    ? input\n    : ParseError.throw(\n        `Capability has invalid 'can: \"${input}\"', value must have at least one path segment`\n      )\n\n/**\n * @param {unknown} input\n */\nconst readResource = input =>\n  typeof input !== \"string\"\n    ? ParseError.throw(\n        `Capability has invalid 'with: ${JSON.stringify(\n          input\n        )}', value must be a string`\n      )\n    : parseURL(input) ||\n      ParseError.throw(\n        `Capability has invalid 'with: \"${input}\"', value must be a valid URI string`\n      )\n\n/**\n * @param {string} input\n */\nconst parseURL = input => {\n  try {\n    new URL(input)\n    return input\n  } catch (_) {\n    return null\n  }\n}\n/**\n * @template T\n * @param {unknown} input\n * @param {(input:unknown, context:string) => T} read\n * @param {string} context\n * @returns {T[]}\n */\nexport const readArray = (input, read, context) =>\n  Array.isArray(input)\n    ? input.map((element, n) => read(element, `${context}[${n}]`))\n    : ParseError.throw(`${context} must be an array`)\n\n/**\n * @template T\n * @param {unknown} input\n * @param {(input:unknown, context: string) => T} reader\n * @param {string} context\n * @returns {T[]|undefined}\n */\nexport const readOptionalArray = (input, reader, context) =>\n  input === undefined ? input : readArray(input, reader, context)\n\n/**\n * @template T\n * @param {unknown} input\n * @param {(input:object) => T} reader\n * @param {string} context\n * @returns {T}\n */\nexport const readStruct = (input, reader, context) =>\n  input != null && typeof input === \"object\"\n    ? reader(input)\n    : ParseError.throw(\n        `${context} must be of type object, instead got ${input}`\n      )\n\n/**\n * @param {unknown} input\n * @param {string} context\n * @returns {UCAN.Fact}\n */\nexport const readFact = (input, context) => readStruct(input, Object, context)\n\n/**\n * @param {unknown} source\n * @param {string} context\n * @returns {UCAN.Link}\n */\nexport const readProof = (source, context) =>\n  Link.isLink(source)\n    ? /** @type {UCAN.Link} */ (source)\n    : fail(\n        `Expected ${context} to be IPLD link, instead got ${JSON.stringify(\n          source\n        )}`\n      )\n\n/**\n * @param {unknown} source\n * @param {string} context\n * @returns {UCAN.Link}\n */\nexport const readStringProof = (source, context) =>\n  parseProof(readString(source, context))\n\n/**\n * @param {string} source\n * @returns {UCAN.Link}\n */\nconst parseProof = source => {\n  // First we attempt to read proof as CID, if we fail fallback to reading it as\n  // an inline proof.\n  try {\n    return Link.parse(source)\n  } catch (error) {\n    return Link.create(raw.code, identity.digest(UTF8.encode(source)))\n  }\n}\n\n/**\n * @param {unknown} input\n * @param {string} context\n */\nexport const readPrincipal = (input, context) =>\n  DID.decode(readBytes(input, context))\n\n/**\n * @param {unknown} source\n * @param {string} context\n */\nexport const readStringPrincipal = (source, context) =>\n  DID.parse(readString(source, context))\n\n/**\n * @template T\n * @param {unknown} source\n * @param {(source:unknown, context:string) => T} read\n * @param {string} [context]\n * @returns {T|undefined}\n */\nexport const readOptional = (source, read, context = \"Field\") =>\n  source !== undefined ? read(source, context) : undefined\n\n/**\n * @template T\n * @param {unknown} source\n * @param {(source:unknown, context:string) => T} read\n * @param {string} context\n * @returns {T|null}\n */\nexport const readNullable = (source, read, context) =>\n  source === null ? null : read(source, context)\n\n/**\n * @param {unknown} source\n * @param {string} [context]\n * @returns {string}\n */\nexport const readString = (source, context = \"Field\") =>\n  typeof source === \"string\"\n    ? source\n    : fail(`${context} has invalid value ${source}`)\n\n/**\n *\n * @param {unknown} source\n * @param {string} context\n * @returns {Uint8Array}\n */\nexport const readBytes = (source, context) =>\n  source instanceof Uint8Array\n    ? source\n    : fail(\n        `Expected ${context} to be Uint8Array, instead got ${JSON.stringify(\n          source\n        )}`\n      )\n\n/**\n * @param {unknown} input\n * @param {string} context\n * @returns {UCAN.Version}\n */\nexport const readVersion = (input, context) =>\n  /\\d+\\.\\d+\\.\\d+/.test(/** @type {string} */ (input))\n    ? /** @type {UCAN.Version} */ (input)\n    : ParseError.throw(`Invalid version '${context}: ${JSON.stringify(input)}'`)\n\n/**\n * @template {string|number|boolean|null} T\n * @param {unknown} input\n * @param {T} literal\n * @param {string} context\n * @returns {T}\n */\nexport const readLiteral = (input, literal, context) =>\n  input === literal\n    ? literal\n    : ParseError.throw(\n        `Expected ${context} to be a ${JSON.stringify(\n          literal\n        )} instead got ${JSON.stringify(input)}`\n      )\n\nexport class ParseError extends TypeError {\n  get name() {\n    return \"ParseError\"\n  }\n  /**\n   * @param {string} message\n   * @returns {never}\n   */\n  static throw(message) {\n    throw new this(message)\n  }\n}\n\n/**\n * @param {string} reason\n */\nexport const fail = reason => ParseError.throw(reason)\n\nexport { fail as throw }\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 577, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/dag-ucan/src/formatter.js"],"sourcesContent":["import * as UCAN from \"./ucan.js\"\nimport * as DID from \"./did.js\"\nimport * as json from \"@ipld/dag-json\"\nimport { base64url } from \"multiformats/bases/base64\"\nimport * as Signature from \"./signature.js\"\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.Model<C>} model\n * @returns {UCAN.JWT<C>}\n */\nexport const format = model => {\n  const header = formatHeader(model.v, model.s.algorithm)\n  const payload = formatPayload(model)\n  const signature = formatSignature(model.s)\n  return /** @type {UCAN.JWT<C>} */ (`${header}.${payload}.${signature}`)\n}\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.Payload<C>} payload\n * @param {UCAN.Version} version\n * @param {string} alg\n */\nexport const formatSignPayload = (payload, version, alg) =>\n  `${formatHeader(version, alg)}.${formatPayload(payload)}`\n\n/**\n * @param {UCAN.Version} version\n * @param {string} alg\n */\nexport const formatHeader = (version, alg) =>\n  base64url.baseEncode(encodeHeader(version, alg))\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.Payload<C>} data\n */\nexport const formatPayload = data => base64url.baseEncode(encodePayload(data))\n\n/**\n * @param {UCAN.Signature<string>} signature\n */\nexport const formatSignature = signature => base64url.baseEncode(signature.raw)\n\n/**\n * @param {UCAN.Version} v\n * @param {string} alg\n * @returns {UCAN.ByteView<UCAN.JWTHeader>}\n */\nconst encodeHeader = (v, alg) =>\n  json.encode({\n    alg,\n    ucv: v,\n    typ: \"JWT\",\n  })\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.Payload<C>} data\n * @returns {UCAN.ByteView<UCAN.JWTPayload<C>>}\n */\nconst encodePayload = data =>\n  json.encode({\n    iss: DID.format(data.iss),\n    aud: DID.format(data.aud),\n    att: data.att,\n    exp: data.exp,\n    prf: data.prf.map(encodeProof),\n    // leave out optionals and empty fields\n    ...(data.fct.length > 0 && { fct: data.fct }),\n    ...(data.nnc && { nnc: data.nnc }),\n    ...(data.nbf && { nbf: data.nbf }),\n  })\n\n/**\n * @param {UCAN.Link} proof\n * @returns {UCAN.ToString<UCAN.Link>}\n */\nconst encodeProof = proof =>\n  /** @type {UCAN.ToString<UCAN.Link>} */ (proof.toString())\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAOO,MAAM,SAAS,CAAA;IACpB,MAAM,SAAS,aAAa,MAAM,CAAC,EAAE,MAAM,CAAC,CAAC,SAAS;IACtD,MAAM,UAAU,cAAc;IAC9B,MAAM,YAAY,gBAAgB,MAAM,CAAC;IACzC,OAAmC,GAAG,OAAO,CAAC,EAAE,QAAQ,CAAC,EAAE,WAAW;AACxE;AAQO,MAAM,oBAAoB,CAAC,SAAS,SAAS,MAClD,GAAG,aAAa,SAAS,KAAK,CAAC,EAAE,cAAc,UAAU;AAMpD,MAAM,eAAe,CAAC,SAAS,MACpC,uNAAS,CAAC,UAAU,CAAC,aAAa,SAAS;AAMtC,MAAM,gBAAgB,CAAA,OAAQ,uNAAS,CAAC,UAAU,CAAC,cAAc;AAKjE,MAAM,kBAAkB,CAAA,YAAa,uNAAS,CAAC,UAAU,CAAC,UAAU,GAAG;AAE9E;;;;CAIC,GACD,MAAM,eAAe,CAAC,GAAG,MACvB,kKAAW,CAAC;QACV;QACA,KAAK;QACL,KAAK;IACP;AAEF;;;;CAIC,GACD,MAAM,gBAAgB,CAAA,OACpB,kKAAW,CAAC;QACV,KAAK,gKAAU,CAAC,KAAK,GAAG;QACxB,KAAK,gKAAU,CAAC,KAAK,GAAG;QACxB,KAAK,KAAK,GAAG;QACb,KAAK,KAAK,GAAG;QACb,KAAK,KAAK,GAAG,CAAC,GAAG,CAAC;QAClB,uCAAuC;QACvC,GAAI,KAAK,GAAG,CAAC,MAAM,GAAG,KAAK;YAAE,KAAK,KAAK,GAAG;QAAC,CAAC;QAC5C,GAAI,KAAK,GAAG,IAAI;YAAE,KAAK,KAAK,GAAG;QAAC,CAAC;QACjC,GAAI,KAAK,GAAG,IAAI;YAAE,KAAK,KAAK,GAAG;QAAC,CAAC;IACnC;AAEF;;;CAGC,GACD,MAAM,cAAc,CAAA,QACuB,MAAM,QAAQ","ignoreList":[0]}},
    {"offset": {"line": 647, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/dag-ucan/src/view.js"],"sourcesContent":["import * as UCAN from \"./ucan.js\"\nimport * as DID from \"./did.js\"\nimport { encode as encodeJSON } from \"@ipld/dag-json\"\nimport { decode as decodeUTF8 } from \"./utf8.js\"\n\n/**\n * @param {unknown} data\n */\nconst toJSON = data => JSON.parse(decodeUTF8(encodeJSON(data)))\n\n/**\n * @template {UCAN.Capabilities} C\n */\nexport class View {\n  /**\n   * @param {UCAN.UCAN<C>} model\n   */\n  constructor(model) {\n    /** @readonly */\n    this.model = model\n  }\n\n  get version() {\n    return this.model.v\n  }\n\n  get issuer() {\n    return DID.from(this.model.iss)\n  }\n\n  get audience() {\n    return DID.from(this.model.aud)\n  }\n\n  /**\n   * @returns {C}\n   */\n  get capabilities() {\n    return this.model.att\n  }\n\n  /**\n   * @returns {number}\n   */\n  get expiration() {\n    const { exp } = this.model\n    return exp === null ? Infinity : exp\n  }\n\n  /**\n   * @returns {undefined|number}\n   */\n  get notBefore() {\n    return this.model.nbf\n  }\n\n  /**\n   * @returns {undefined|string}\n   */\n\n  get nonce() {\n    return this.model.nnc\n  }\n\n  /**\n   * @returns {UCAN.Fact[]}\n   */\n  get facts() {\n    return this.model.fct\n  }\n\n  /**\n   * @returns {UCAN.Link[]}\n   */\n\n  get proofs() {\n    return this.model.prf\n  }\n\n  get signature() {\n    return this.model.s\n  }\n\n  // compatibility with UCAN.UCAN\n  get jwt() {\n    return this.model.jwt\n  }\n  get s() {\n    return this.model.s\n  }\n  get v() {\n    return this.model.v\n  }\n  get iss() {\n    return this.model.iss\n  }\n  get aud() {\n    return this.model.aud\n  }\n  get att() {\n    return this.model.att\n  }\n  get exp() {\n    return this.model.exp\n  }\n  get nbf() {\n    return this.model.nbf\n  }\n  get nnc() {\n    return this.model.nnc\n  }\n  get fct() {\n    return this.model.fct\n  }\n  get prf() {\n    return this.model.prf\n  }\n\n  /**\n   * @returns {UCAN.ToJSON<UCAN.UCAN<C>, UCAN.UCANJSON<this>>}\n   */\n  toJSON() {\n    const { v, iss, aud, s, att, prf, exp, fct, nnc, nbf } = this.model\n\n    return {\n      iss,\n      aud,\n      v,\n      s,\n      exp,\n      ...toJSON({\n        att,\n        prf,\n        ...(fct.length > 0 && { fct }),\n      }),\n      ...(nnc != null && { nnc }),\n      ...(nbf && { nbf }),\n    }\n  }\n}\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEA;;CAEC,GACD,MAAM,SAAS,CAAA,OAAQ,KAAK,KAAK,CAAC,IAAA,iKAAU,EAAC,IAAA,kKAAU,EAAC;AAKjD,MAAM;IACX;;GAEC,GACD,YAAY,KAAK,CAAE;QACjB,cAAc,GACd,IAAI,CAAC,KAAK,GAAG;IACf;IAEA,IAAI,UAAU;QACZ,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC;IACrB;IAEA,IAAI,SAAS;QACX,OAAO,8JAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG;IAChC;IAEA,IAAI,WAAW;QACb,OAAO,8JAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG;IAChC;IAEA;;GAEC,GACD,IAAI,eAAe;QACjB,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG;IACvB;IAEA;;GAEC,GACD,IAAI,aAAa;QACf,MAAM,EAAE,GAAG,EAAE,GAAG,IAAI,CAAC,KAAK;QAC1B,OAAO,QAAQ,OAAO,WAAW;IACnC;IAEA;;GAEC,GACD,IAAI,YAAY;QACd,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG;IACvB;IAEA;;GAEC,GAED,IAAI,QAAQ;QACV,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG;IACvB;IAEA;;GAEC,GACD,IAAI,QAAQ;QACV,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG;IACvB;IAEA;;GAEC,GAED,IAAI,SAAS;QACX,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG;IACvB;IAEA,IAAI,YAAY;QACd,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC;IACrB;IAEA,+BAA+B;IAC/B,IAAI,MAAM;QACR,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG;IACvB;IACA,IAAI,IAAI;QACN,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC;IACrB;IACA,IAAI,IAAI;QACN,OAAO,IAAI,CAAC,KAAK,CAAC,CAAC;IACrB;IACA,IAAI,MAAM;QACR,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG;IACvB;IACA,IAAI,MAAM;QACR,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG;IACvB;IACA,IAAI,MAAM;QACR,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG;IACvB;IACA,IAAI,MAAM;QACR,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG;IACvB;IACA,IAAI,MAAM;QACR,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG;IACvB;IACA,IAAI,MAAM;QACR,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG;IACvB;IACA,IAAI,MAAM;QACR,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG;IACvB;IACA,IAAI,MAAM;QACR,OAAO,IAAI,CAAC,KAAK,CAAC,GAAG;IACvB;IAEA;;GAEC,GACD,SAAS;QACP,MAAM,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI,CAAC,KAAK;QAEnE,OAAO;YACL;YACA;YACA;YACA;YACA;YACA,GAAG,OAAO;gBACR;gBACA;gBACA,GAAI,IAAI,MAAM,GAAG,KAAK;oBAAE;gBAAI,CAAC;YAC/B,EAAE;YACF,GAAI,OAAO,QAAQ;gBAAE;YAAI,CAAC;YAC1B,GAAI,OAAO;gBAAE;YAAI,CAAC;QACpB;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 775, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/dag-ucan/src/codec/cbor.js"],"sourcesContent":["import * as UCAN from \"../ucan.js\"\nimport * as CBOR from \"@ipld/dag-cbor\"\nimport { readPayload, readVersion, readSignature } from \"../schema.js\"\nimport { format } from \"../formatter.js\"\nimport * as Signature from \"../signature.js\"\nimport { View } from \"../view.js\"\n\nexport const name = \"dag-ucan\"\nexport const code = CBOR.code\n\n/**\n * Creates a UCAN view from the underlying data model. Please note that this\n * function does no verification of the model and it is callers responsibility\n * to ensure that:\n *\n * 1. Data model is correct contains all the field etc...\n * 2. Payload of the signature will match paylodad when model is serialized\n *    with DAG-JSON.\n *\n * In other words you should never use this function unless you've parsed or\n * decoded a valid UCAN and want to wrap it into a view.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.FromModel<C>} model\n * @returns {UCAN.View<C>}\n */\nexport const from = model => new CBORView(model)\n\n/**\n * Encodes given UCAN (in either IPLD or JWT representation) and encodes it into\n * corresponding bytes representation. UCAN in IPLD representation is encoded as\n * DAG-CBOR which JWT representation is encoded as raw bytes of JWT string.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.Model<C>} model\n * @returns {UCAN.ByteView<UCAN.Model<C>>}\n */\nexport const encode = model => {\n  const { fct, nnc, nbf, ...payload } = readPayload(model)\n\n  return /** @type {Uint8Array} */ (\n    CBOR.encode({\n      // leave out optionals unless they are set\n      ...(fct.length > 0 && { fct }),\n      ...(nnc != null && { nnc }),\n      ...(nbf && { nbf }),\n      ...payload,\n      // add version and signature\n      v: readVersion(model.v, \"v\"),\n      s: encodeSignature(model.s, \"s\"),\n    })\n  )\n}\n\n/**\n * @param {UCAN.Signature} signature\n * @param {string} context\n */\nconst encodeSignature = (signature, context) => {\n  try {\n    return Signature.encode(signature)\n  } catch (cause) {\n    throw new Error(\n      `Expected signature ${context}, instead got ${JSON.stringify(signature)}`,\n      // @ts-expect-error - types don't know about second arg\n      { cause }\n    )\n  }\n}\n\n/**\n * Decodes UCAN in primary CBOR representation. It does not validate UCAN, it's\n * signature or proof chain. This is to say decoded UCAN may be invalid.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.ByteView<UCAN.Model<C>>} bytes\n * @returns {UCAN.View<C>}\n */\nexport const decode = bytes => {\n  const model = CBOR.decode(bytes)\n  return new CBORView({\n    ...readPayload(model),\n    v: readVersion(model.v, \"v\"),\n    s: readSignature(model.s),\n  })\n}\n\nexport { format }\n\n/**\n * @template {UCAN.Capabilities} C\n * @extends {View<C>}\n */\nclass CBORView extends View {\n  /** @type {UCAN.MulticodecCode<typeof code, \"CBOR\">} */\n  get code() {\n    return code\n  }\n  format() {\n    return format(this.model)\n  }\n  encode() {\n    return encode(this.model)\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAEO,MAAM,OAAO;AACb,MAAM,OAAO,gKAAS;AAkBtB,MAAM,OAAO,CAAA,QAAS,IAAI,SAAS;AAWnC,MAAM,SAAS,CAAA;IACpB,MAAM,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,SAAS,GAAG,IAAA,wKAAW,EAAC;IAElD,OACE,kKAAW,CAAC;QACV,0CAA0C;QAC1C,GAAI,IAAI,MAAM,GAAG,KAAK;YAAE;QAAI,CAAC;QAC7B,GAAI,OAAO,QAAQ;YAAE;QAAI,CAAC;QAC1B,GAAI,OAAO;YAAE;QAAI,CAAC;QAClB,GAAG,OAAO;QACV,4BAA4B;QAC5B,GAAG,IAAA,wKAAW,EAAC,MAAM,CAAC,EAAE;QACxB,GAAG,gBAAgB,MAAM,CAAC,EAAE;IAC9B;AAEJ;AAEA;;;CAGC,GACD,MAAM,kBAAkB,CAAC,WAAW;IAClC,IAAI;QACF,OAAO,sKAAgB,CAAC;IAC1B,EAAE,OAAO,OAAO;QACd,MAAM,IAAI,MACR,CAAC,mBAAmB,EAAE,QAAQ,cAAc,EAAE,KAAK,SAAS,CAAC,YAAY,EACzE,uDAAuD;QACvD;YAAE;QAAM;IAEZ;AACF;AAUO,MAAM,SAAS,CAAA;IACpB,MAAM,QAAQ,kKAAW,CAAC;IAC1B,OAAO,IAAI,SAAS;QAClB,GAAG,IAAA,wKAAW,EAAC,MAAM;QACrB,GAAG,IAAA,wKAAW,EAAC,MAAM,CAAC,EAAE;QACxB,GAAG,IAAA,0KAAa,EAAC,MAAM,CAAC;IAC1B;AACF;;AAIA;;;CAGC,GACD,MAAM,iBAAiB,+JAAI;IACzB,qDAAqD,GACrD,IAAI,OAAO;QACT,OAAO;IACT;IACA,SAAS;QACP,OAAO,IAAA,sKAAM,EAAC,IAAI,CAAC,KAAK;IAC1B;IACA,SAAS;QACP,OAAO,OAAO,IAAI,CAAC,KAAK;IAC1B;AACF","ignoreList":[0]}},
    {"offset": {"line": 861, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/dag-ucan/src/parser.js"],"sourcesContent":["import * as UCAN from \"./ucan.js\"\nimport * as json from \"@ipld/dag-json\"\nimport * as Schema from \"./schema.js\"\nimport { base64url } from \"multiformats/bases/base64\"\nimport { createNamed as createSignature } from \"./signature.js\"\n\n/**\n * Parse JWT formatted UCAN. Note than no validation takes place here.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.JWT<C>|string} jwt\n * @returns {UCAN.Model<C>}\n */\nexport const parse = jwt => {\n  const segments = jwt.split(\".\")\n  const [header, payload, signature] =\n    segments.length === 3\n      ? segments\n      : Schema.throw(\n          `Can't parse UCAN: ${jwt}: Expected JWT format: 3 dot-separated base64url-encoded values.`\n        )\n\n  const { ucv, alg } = parseHeader(header)\n\n  return {\n    ...parsePayload(payload),\n    v: ucv,\n    s: createSignature(alg, base64url.baseDecode(signature)),\n  }\n}\n\n/**\n * @param {string} header\n */\nexport const parseHeader = header => {\n  const { ucv, alg, typ } = json.decode(base64url.baseDecode(header))\n\n  return {\n    typ: Schema.readLiteral(typ, \"JWT\", \"typ\"),\n    ucv: Schema.readVersion(ucv, \"ucv\"),\n    alg: Schema.readString(alg, \"alg\"),\n  }\n}\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {string} source\n * @returns {UCAN.Payload<C>}\n */\nexport const parsePayload = source => {\n  /** @type {Record<string, unknown>} */\n  const payload = json.decode(base64url.baseDecode(source))\n  return Schema.readJWTPayload(payload)\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AASO,MAAM,QAAQ,CAAA;IACnB,MAAM,WAAW,IAAI,KAAK,CAAC;IAC3B,MAAM,CAAC,QAAQ,SAAS,UAAU,GAChC,SAAS,MAAM,KAAK,IAChB,WACA,kKAAY,CACV,CAAC,kBAAkB,EAAE,IAAI,gEAAgE,CAAC;IAGlG,MAAM,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,YAAY;IAEjC,OAAO;QACL,GAAG,aAAa,QAAQ;QACxB,GAAG;QACH,GAAG,IAAA,2KAAe,EAAC,KAAK,uNAAS,CAAC,UAAU,CAAC;IAC/C;AACF;AAKO,MAAM,cAAc,CAAA;IACzB,MAAM,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,kKAAW,CAAC,uNAAS,CAAC,UAAU,CAAC;IAE3D,OAAO;QACL,KAAK,wKAAkB,CAAC,KAAK,OAAO;QACpC,KAAK,wKAAkB,CAAC,KAAK;QAC7B,KAAK,uKAAiB,CAAC,KAAK;IAC9B;AACF;AAOO,MAAM,eAAe,CAAA;IAC1B,oCAAoC,GACpC,MAAM,UAAU,kKAAW,CAAC,uNAAS,CAAC,UAAU,CAAC;IACjD,OAAO,2KAAqB,CAAC;AAC/B","ignoreList":[0]}},
    {"offset": {"line": 905, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/dag-ucan/src/codec/jwt.js"],"sourcesContent":["import * as UCAN from \"../ucan.js\"\nimport * as UTF8 from \"../utf8.js\"\nimport { parse } from \"../parser.js\"\nimport { code } from \"multiformats/codecs/raw\"\nimport { View } from \"../view.js\"\n\nexport { code }\nexport const name = \"dag-ucan\"\n\n/**\n * Creates a UCAN view from the underlying data model. Please note that this\n * function does no verification of the model and it is callers responsibility\n * to ensure that:\n *\n * 1. Data model is correct contains all the field etc...\n * 2. Payload of the signature will match paylodad when model is serialized\n *    with DAG-JSON.\n *\n * In other words you should never use this function unless you've parsed or\n * decoded a valid UCAN and want to wrap it into a view.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.FromJWT<C>} model\n * @returns {UCAN.View<C>}\n */\nexport const from = model => new JWTView(model)\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.ByteView<UCAN.FromJWT<C>>} bytes\n * @returns {UCAN.View<C>}\n */\nexport const decode = bytes => {\n  const jwt = /** @type {UCAN.JWT<C>} */ (UTF8.decode(bytes))\n\n  return new JWTView({ ...parse(jwt), jwt })\n}\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.FromJWT<C>} model\n * @returns {UCAN.ByteView<UCAN.UCAN<C>>}\n */\nexport const encode = ({ jwt }) => UTF8.encode(jwt)\n\n/**\n * @template {UCAN.Capabilities} C\n * @param {UCAN.FromJWT<C>} model\n * @returns {UCAN.JWT<C>}\n */\nexport const format = ({ jwt }) => jwt\n\n/**\n * @template {UCAN.Capabilities} C\n * @extends {View<C>}\n */\nclass JWTView extends View {\n  /**\n   * @param {UCAN.FromJWT<C>} model\n   */\n  constructor(model) {\n    super(model)\n    this.model = model\n  }\n  /** @type {UCAN.MulticodecCode<typeof code, \"Raw\">} */\n  get code() {\n    return code\n  }\n  format() {\n    return format(this.model)\n  }\n  encode() {\n    return encode(this.model)\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;;;;;;;AAGO,MAAM,OAAO;AAkBb,MAAM,OAAO,CAAA,QAAS,IAAI,QAAQ;AAOlC,MAAM,SAAS,CAAA;IACpB,MAAM,MAAkC,iKAAW,CAAC;IAEpD,OAAO,IAAI,QAAQ;QAAE,GAAG,IAAA,kKAAK,EAAC,IAAI;QAAE;IAAI;AAC1C;AAOO,MAAM,SAAS,CAAC,EAAE,GAAG,EAAE,GAAK,iKAAW,CAAC;AAOxC,MAAM,SAAS,CAAC,EAAE,GAAG,EAAE,GAAK;AAEnC;;;CAGC,GACD,MAAM,gBAAgB,+JAAI;IACxB;;GAEC,GACD,YAAY,KAAK,CAAE;QACjB,KAAK,CAAC;QACN,IAAI,CAAC,KAAK,GAAG;IACf;IACA,oDAAoD,GACpD,IAAI,OAAO;QACT,OAAO,gNAAI;IACb;IACA,SAAS;QACP,OAAO,OAAO,IAAI,CAAC,KAAK;IAC1B;IACA,SAAS;QACP,OAAO,OAAO,IAAI,CAAC,KAAK;IAC1B;AACF","ignoreList":[0]}},
    {"offset": {"line": 963, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/dag-ucan/src/lib.js"],"sourcesContent":["import * as UCAN from \"./ucan.js\"\nimport * as CBOR from \"./codec/cbor.js\"\nimport * as JWT from \"./codec/jwt.js\"\nimport * as UTF8 from \"./utf8.js\"\nimport { readPayload } from \"./schema.js\"\nimport { parse as parseDID } from \"./did.js\"\nimport { parse as parseJWT } from \"./parser.js\"\nimport { formatSignPayload } from \"./formatter.js\"\nimport { sha256 } from \"multiformats/hashes/sha2\"\nimport { create as createLink } from \"multiformats/link\"\nimport { format as formatDID } from \"./did.js\"\n\nexport * from \"./ucan.js\"\n\nexport const VERSION = \"0.9.1\"\nexport const name = \"dag-ucan\"\nexport const code = /** @type {UCAN.Code} */ (CBOR.code)\n\n/**\n * We cast sha256 to workaround typescripts limited inference problem when using\n * sha256 as default. If hasher is omitted type `A` should match sha256.code\n * but TS fails to deduce that.\n * @type {UCAN.MultihashHasher<any>}\n */\nconst defaultHasher = sha256\n\n/**\n * Encodes given UCAN (in either IPLD or JWT representation) and encodes it into\n * corresponding bytes representation. UCAN in IPLD representation is encoded as\n * DAG-CBOR which JWT representation is encoded as raw bytes of JWT string.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.UCAN<C>} ucan\n * @returns {UCAN.ByteView<UCAN.UCAN<C>>}\n */\nexport const encode = ucan => (ucan.jwt ? JWT.encode(ucan) : CBOR.encode(ucan))\n\n/**\n * Decodes binary encoded UCAN. It assumes UCAN is in primary IPLD\n * representation and attempts to decode it with DAG-CBOR, if that\n * fails it falls back to secondary representation and parses it as\n * a JWT.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.ByteView<UCAN.UCAN<C>>} bytes\n * @returns {UCAN.View<C>}\n */\nexport const decode = bytes => {\n  try {\n    return CBOR.decode(bytes)\n  } catch (_) {\n    return JWT.decode(/** @type {UCAN.ByteView<UCAN.FromJWT<C>>} */ (bytes))\n  }\n}\n\n/**\n * Convenience function to create a CID for the given UCAN. If UCAN is\n * in JWT representation get CID with RAW multicodec, while UCANs in IPLD\n * representation get UCAN multicodec code.\n *\n * @template {UCAN.Capabilities} C\n * @template {number} [A=typeof sha256.code] - Multihash code\n * @param {UCAN.View<C>} ucan\n * @param {{hasher?: UCAN.MultihashHasher<A>}} [options]\n */\nexport const link = async (ucan, options) => {\n  const { cid } = await write(ucan, options)\n  return cid\n}\n\n/**\n * @template {UCAN.Capabilities} C\n * @template {number} [A=typeof sha256.code] - Multihash code\n * @param {UCAN.UCAN<C>} ucan\n * @param {{hasher?: UCAN.MultihashHasher<A>}} options\n * @returns {Promise<UCAN.Block<C, UCAN.Code, A>>}\n */\nexport const write = async (ucan, { hasher = defaultHasher } = {}) => {\n  const [code, bytes] = ucan.jwt\n    ? [/** @type {UCAN.Code} */ (JWT.code), JWT.encode(ucan)]\n    : [/** @type {UCAN.Code} */ (CBOR.code), CBOR.encode(ucan)]\n  const digest = await hasher.digest(bytes)\n\n  return {\n    bytes,\n    cid: createLink(code, digest),\n    data: ucan,\n  }\n}\n\n/**\n * Parses UCAN formatted as JWT string. Returns UCAN view in IPLD representation\n * when serializing it back would produce original string, otherwise returns UCAN\n * view in secondary JWT representation which is not as compact, but it retains\n * key order and whitespaces so it could be formatted back to same JWT string.\n * View will have `type` field with either `\"IPLD\"` or `\"JWT\"` value telling\n * in which representation UCAN is.\n *\n * Note: Parsing does not perform validation of capabilities or semantics of the\n * UCAN, it only ensures structure is spec compliant and throws `ParseError`\n * if it is not.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.JWT<C>|string} jwt\n * @returns {UCAN.View<C>}\n */\nexport const parse = jwt => {\n  const model = parseJWT(jwt)\n\n  // If formatting UCAN produces same jwt string we can use IPLD representation\n  // otherwise we need to fallback to raw representation. This decision will\n  // affect how we `encode` the UCAN.\n  return CBOR.format(model) === jwt\n    ? CBOR.from(model)\n    : JWT.from({ ...model, jwt: /** @type {UCAN.JWT<C>} */ (jwt) })\n}\n\n/**\n * Takes UCAN object and formats it into JWT string.\n *\n * @template {UCAN.Capabilities} C\n * @param {UCAN.UCAN<C>} ucan\n * @returns {UCAN.JWT<C>}\n */\nexport const format = ucan => (ucan.jwt ? JWT.format(ucan) : CBOR.format(ucan))\n\n/**\n * Creates a new signed token with a given `options.issuer`. If expiration is\n * not set it defaults to 30 seconds from now. Returns UCAN in primary - IPLD\n * representation.\n *\n * @template {number} A\n * @template {UCAN.Capabilities} C\n * @param {UCAN.UCANOptions<C, A>} options\n * @returns {Promise<UCAN.View<C>>}\n */\nexport const issue = async ({\n  issuer,\n  audience,\n  capabilities,\n  lifetimeInSeconds = 30,\n  expiration = now() + lifetimeInSeconds,\n  notBefore,\n  facts = [],\n  proofs = [],\n  nonce,\n}) => {\n  const v = VERSION\n  const data = readPayload({\n    iss: parseDID(issuer.did()),\n    aud: parseDID(audience.did()),\n    att: capabilities,\n    fct: facts,\n    exp: expiration,\n    nbf: notBefore,\n    prf: proofs,\n    nnc: nonce,\n  })\n  const payload = encodeSignaturePayload(data, v, issuer.signatureAlgorithm)\n\n  return CBOR.from({\n    ...data,\n    v,\n    s: await issuer.sign(payload),\n  })\n}\n\n/**\n *\n * @param {UCAN.Payload} payload\n * @param {UCAN.Version} version\n * @param {string} algorithm\n * @returns\n */\nconst encodeSignaturePayload = (payload, version, algorithm) =>\n  UTF8.encode(formatSignPayload(payload, version, algorithm))\n\n/**\n * Verifies UCAN signature.\n *\n * @param {UCAN.View} ucan\n * @param {UCAN.Verifier} verifier\n */\nexport const verifySignature = (ucan, verifier) =>\n  formatDID(ucan.issuer) === verifier.did() &&\n  verifier.verify(\n    encodeSignaturePayload(ucan.model, ucan.model.v, ucan.signature.algorithm),\n    ucan.signature\n  )\n\n/**\n * Check if a UCAN is expired.\n *\n * @param {UCAN.View} ucan\n */\nexport const isExpired = ucan => ucan.expiration <= now()\n\n/**\n * Check if a UCAN is not active yet.\n * @param {UCAN.View} ucan\n */\nexport const isTooEarly = ucan =>\n  ucan.notBefore != null && now() <= ucan.notBefore\n\n/**\n * Returns UTC Unix timestamp for comparing it against time window of the UCAN.\n */\nexport const now = () => Math.floor(Date.now() / 1000)\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;AAKO,MAAM,UAAU;AAChB,MAAM,OAAO;AACb,MAAM,OAAiC,wLAAS;AAEvD;;;;;CAKC,GACD,MAAM,gBAAgB,8NAAM;AAWrB,MAAM,SAAS,CAAA,OAAS,KAAK,GAAG,GAAG,yLAAU,CAAC,QAAQ,0LAAW,CAAC;AAYlE,MAAM,SAAS,CAAA;IACpB,IAAI;QACF,OAAO,0LAAW,CAAC;IACrB,EAAE,OAAO,GAAG;QACV,OAAO,yLAAU,CAAgD;IACnE;AACF;AAYO,MAAM,OAAO,OAAO,MAAM;IAC/B,MAAM,EAAE,GAAG,EAAE,GAAG,MAAM,MAAM,MAAM;IAClC,OAAO;AACT;AASO,MAAM,QAAQ,OAAO,MAAM,EAAE,SAAS,aAAa,EAAE,GAAG,CAAC,CAAC;IAC/D,MAAM,CAAC,MAAM,MAAM,GAAG,KAAK,GAAG,GAC1B;QAA2B,gNAAQ;QAAG,yLAAU,CAAC;KAAM,GACvD;QAA2B,wLAAS;QAAG,0LAAW,CAAC;KAAM;IAC7D,MAAM,SAAS,MAAM,OAAO,MAAM,CAAC;IAEnC,OAAO;QACL;QACA,KAAK,IAAA,yNAAU,EAAC,MAAM;QACtB,MAAM;IACR;AACF;AAkBO,MAAM,QAAQ,CAAA;IACnB,MAAM,QAAQ,IAAA,kKAAQ,EAAC;IAEvB,6EAA6E;IAC7E,0EAA0E;IAC1E,mCAAmC;IACnC,OAAO,sKAAW,CAAC,WAAW,MAC1B,wLAAS,CAAC,SACV,uLAAQ,CAAC;QAAE,GAAG,KAAK;QAAE,KAAiC;IAAK;AACjE;AASO,MAAM,SAAS,CAAA,OAAS,KAAK,GAAG,GAAG,yLAAU,CAAC,QAAQ,sKAAW,CAAC;AAYlE,MAAM,QAAQ,OAAO,EAC1B,MAAM,EACN,QAAQ,EACR,YAAY,EACZ,oBAAoB,EAAE,EACtB,aAAa,QAAQ,iBAAiB,EACtC,SAAS,EACT,QAAQ,EAAE,EACV,SAAS,EAAE,EACX,KAAK,EACN;IACC,MAAM,IAAI;IACV,MAAM,OAAO,IAAA,wKAAW,EAAC;QACvB,KAAK,IAAA,+JAAQ,EAAC,OAAO,GAAG;QACxB,KAAK,IAAA,+JAAQ,EAAC,SAAS,GAAG;QAC1B,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;IACP;IACA,MAAM,UAAU,uBAAuB,MAAM,GAAG,OAAO,kBAAkB;IAEzE,OAAO,wLAAS,CAAC;QACf,GAAG,IAAI;QACP;QACA,GAAG,MAAM,OAAO,IAAI,CAAC;IACvB;AACF;AAEA;;;;;;CAMC,GACD,MAAM,yBAAyB,CAAC,SAAS,SAAS,YAChD,iKAAW,CAAC,IAAA,iLAAiB,EAAC,SAAS,SAAS;AAQ3C,MAAM,kBAAkB,CAAC,MAAM,WACpC,IAAA,gKAAS,EAAC,KAAK,MAAM,MAAM,SAAS,GAAG,MACvC,SAAS,MAAM,CACb,uBAAuB,KAAK,KAAK,EAAE,KAAK,KAAK,CAAC,CAAC,EAAE,KAAK,SAAS,CAAC,SAAS,GACzE,KAAK,SAAS;AAQX,MAAM,YAAY,CAAA,OAAQ,KAAK,UAAU,IAAI;AAM7C,MAAM,aAAa,CAAA,OACxB,KAAK,SAAS,IAAI,QAAQ,SAAS,KAAK,SAAS;AAK5C,MAAM,MAAM,IAAM,KAAK,KAAK,CAAC,KAAK,GAAG,KAAK","ignoreList":[0]}},
    {"offset": {"line": 1097, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/dag-cbor/src/index.js"],"sourcesContent":["import * as cborg from 'cborg'\nimport { CID } from 'multiformats/cid'\n\n// https://github.com/ipfs/go-ipfs/issues/3570#issuecomment-273931692\nconst CID_CBOR_TAG = 42\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView\n */\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} buf\n * @returns {ByteView<T>}\n */\nexport function toByteView (buf) {\n  if (buf instanceof ArrayBuffer) {\n    return new Uint8Array(buf, 0, buf.byteLength)\n  }\n\n  return buf\n}\n\n/**\n * cidEncoder will receive all Objects during encode, it needs to filter out\n * anything that's not a CID and return `null` for that so it's encoded as\n * normal.\n *\n * @param {any} obj\n * @returns {cborg.Token[]|null}\n */\nfunction cidEncoder (obj) {\n  if (obj.asCID !== obj && obj['/'] !== obj.bytes) {\n    return null // any other kind of object\n  }\n  const cid = CID.asCID(obj)\n  /* c8 ignore next 4 */\n  // very unlikely case, and it'll probably throw a recursion error in cborg\n  if (!cid) {\n    return null\n  }\n  const bytes = new Uint8Array(cid.bytes.byteLength + 1)\n  bytes.set(cid.bytes, 1) // prefix is 0x00, for historical reasons\n  return [\n    new cborg.Token(cborg.Type.tag, CID_CBOR_TAG),\n    new cborg.Token(cborg.Type.bytes, bytes)\n  ]\n}\n\n// eslint-disable-next-line jsdoc/require-returns-check\n/**\n * Intercept all `undefined` values from an object walk and reject the entire\n * object if we find one.\n *\n * @returns {null}\n */\nfunction undefinedEncoder () {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded')\n}\n\n/**\n * Intercept all `number` values from an object walk and reject the entire\n * object if we find something that doesn't fit the IPLD data model (NaN &\n * Infinity).\n *\n * @param {number} num\n * @returns {null}\n */\nfunction numberEncoder (num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  return null\n}\n\n/**\n * @param {Map<any, any>} map\n * @returns {null}\n */\nfunction mapEncoder (map) {\n  for (const key of map.keys()) {\n    if (typeof key !== 'string' || key.length === 0) {\n      throw new Error('Non-string Map keys are not supported by the IPLD Data Model and cannot be encoded')\n    }\n  }\n  return null\n}\n\nconst _encodeOptions = {\n  float64: true,\n  typeEncoders: {\n    Map: mapEncoder,\n    Object: cidEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n}\n\nexport const encodeOptions = {\n  ..._encodeOptions,\n  typeEncoders: {\n    ..._encodeOptions.typeEncoders\n  }\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {CID}\n */\nfunction cidDecoder (bytes) {\n  if (bytes[0] !== 0) {\n    throw new Error('Invalid CID for CBOR tag 42; expected leading 0x00')\n  }\n  return CID.decode(bytes.subarray(1)) // ignore leading 0x00\n}\n\nconst _decodeOptions = {\n  allowIndefinite: false,\n  coerceUndefinedToNull: true,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true, // this will lead to BigInt for ints outside of\n  // safe-integer range, which may surprise users\n  strict: true,\n  useMaps: false,\n  rejectDuplicateMapKeys: true,\n  /** @type {import('cborg').TagDecoder[]} */\n  tags: []\n}\n_decodeOptions.tags[CID_CBOR_TAG] = cidDecoder\n\nexport const decodeOptions = {\n  ..._decodeOptions,\n  tags: _decodeOptions.tags.slice()\n}\n\nexport const name = 'dag-cbor'\nexport const code = 0x71\n\n/**\n * @template T\n * @param {T} node\n * @returns {ByteView<T>}\n */\nexport const encode = (node) => cborg.encode(node, _encodeOptions)\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} data\n * @returns {T}\n */\nexport const decode = (data) => cborg.decode(toByteView(data), _decodeOptions)\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AACA;;;AAEA,qEAAqE;AACrE,MAAM,eAAe;AAiBd,SAAS,WAAY,GAAG;IAC7B,IAAI,eAAe,aAAa;QAC9B,OAAO,IAAI,WAAW,KAAK,GAAG,IAAI,UAAU;IAC9C;IAEA,OAAO;AACT;AAEA;;;;;;;CAOC,GACD,SAAS,WAAY,GAAG;IACtB,IAAI,IAAI,KAAK,KAAK,OAAO,GAAG,CAAC,IAAI,KAAK,IAAI,KAAK,EAAE;QAC/C,OAAO,KAAK,2BAA2B;;IACzC;IACA,MAAM,MAAM,qNAAG,CAAC,KAAK,CAAC;IACtB,oBAAoB,GACpB,0EAA0E;IAC1E,IAAI,CAAC,KAAK;QACR,OAAO;IACT;IACA,MAAM,QAAQ,IAAI,WAAW,IAAI,KAAK,CAAC,UAAU,GAAG;IACpD,MAAM,GAAG,CAAC,IAAI,KAAK,EAAE,IAAG,yCAAyC;IACjE,OAAO;QACL,IAAI,iJAAW,CAAC,gJAAU,CAAC,GAAG,EAAE;QAChC,IAAI,iJAAW,CAAC,gJAAU,CAAC,KAAK,EAAE;KACnC;AACH;AAEA,uDAAuD;AACvD;;;;;CAKC,GACD,SAAS;IACP,MAAM,IAAI,MAAM;AAClB;AAEA;;;;;;;CAOC,GACD,SAAS,cAAe,GAAG;IACzB,IAAI,OAAO,KAAK,CAAC,MAAM;QACrB,MAAM,IAAI,MAAM;IAClB;IACA,IAAI,QAAQ,YAAY,QAAQ,CAAC,UAAU;QACzC,MAAM,IAAI,MAAM;IAClB;IACA,OAAO;AACT;AAEA;;;CAGC,GACD,SAAS,WAAY,GAAG;IACtB,KAAK,MAAM,OAAO,IAAI,IAAI,GAAI;QAC5B,IAAI,OAAO,QAAQ,YAAY,IAAI,MAAM,KAAK,GAAG;YAC/C,MAAM,IAAI,MAAM;QAClB;IACF;IACA,OAAO;AACT;AAEA,MAAM,iBAAiB;IACrB,SAAS;IACT,cAAc;QACZ,KAAK;QACL,QAAQ;QACR,WAAW;QACX,QAAQ;IACV;AACF;AAEO,MAAM,gBAAgB;IAC3B,GAAG,cAAc;IACjB,cAAc;QACZ,GAAG,eAAe,YAAY;IAChC;AACF;AAEA;;;CAGC,GACD,SAAS,WAAY,KAAK;IACxB,IAAI,KAAK,CAAC,EAAE,KAAK,GAAG;QAClB,MAAM,IAAI,MAAM;IAClB;IACA,OAAO,qNAAG,CAAC,MAAM,CAAC,MAAM,QAAQ,CAAC,IAAI,sBAAsB;;AAC7D;AAEA,MAAM,iBAAiB;IACrB,iBAAiB;IACjB,uBAAuB;IACvB,UAAU;IACV,eAAe;IACf,aAAa;IACb,+CAA+C;IAC/C,QAAQ;IACR,SAAS;IACT,wBAAwB;IACxB,yCAAyC,GACzC,MAAM,EAAE;AACV;AACA,eAAe,IAAI,CAAC,aAAa,GAAG;AAE7B,MAAM,gBAAgB;IAC3B,GAAG,cAAc;IACjB,MAAM,eAAe,IAAI,CAAC,KAAK;AACjC;AAEO,MAAM,OAAO;AACb,MAAM,OAAO;AAOb,MAAM,SAAS,CAAC,OAAS,mJAAY,CAAC,MAAM;AAO5C,MAAM,SAAS,CAAC,OAAS,mJAAY,CAAC,WAAW,OAAO","ignoreList":[0]}},
    {"offset": {"line": 1238, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/dag-json/src/index.js"],"sourcesContent":["/* eslint max-depth: [\"error\", 7] */\nimport { Token, Type } from 'cborg'\nimport * as cborgJson from 'cborg/json'\nimport { CID } from 'multiformats'\nimport { base64 } from 'multiformats/bases/base64'\n\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView\n */\n/**\n * @template T\n * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView\n */\n/**\n * @template T\n * @typedef {import('multiformats').ToString<T>} ToString\n */\n/**\n * @typedef {import('cborg/interface').DecodeTokenizer} DecodeTokenizer\n */\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} buf\n * @returns {ByteView<T>}\n */\nfunction toByteView (buf) {\n  if (buf instanceof ArrayBuffer) {\n    return new Uint8Array(buf, 0, buf.byteLength)\n  }\n\n  return buf\n}\n\n/**\n * cidEncoder will receive all Objects during encode, it needs to filter out\n * anything that's not a CID and return `null` for that so it's encoded as\n * normal. Encoding a CID means replacing it with a `{\"/\":\"<CidString>}`\n * object as per the DAG-JSON spec.\n *\n * @param {any} obj\n * @returns {Token[]|null}\n */\nfunction cidEncoder (obj) {\n  if (obj.asCID !== obj && obj['/'] !== obj.bytes) {\n    return null // any other kind of object\n  }\n  const cid = CID.asCID(obj)\n  /* c8 ignore next 4 */\n  // very unlikely case, and it'll probably throw a recursion error in cborg\n  if (!cid) {\n    return null\n  }\n  const cidString = cid.toString()\n\n  return [\n    new Token(Type.map, Infinity, 1),\n    new Token(Type.string, '/', 1), // key\n    new Token(Type.string, cidString, cidString.length), // value\n    new Token(Type.break, undefined, 1)\n  ]\n}\n\n/**\n * bytesEncoder will receive all Uint8Arrays (and friends) during encode, it\n * needs to replace it with a `{\"/\":{\"bytes\":\"Base64ByteString\"}}` object as\n * per the DAG-JSON spec.\n *\n * @param {Uint8Array} bytes\n * @returns {Token[]|null}\n */\nfunction bytesEncoder (bytes) {\n  const bytesString = base64.encode(bytes).slice(1) // no mbase prefix\n  return [\n    new Token(Type.map, Infinity, 1),\n    new Token(Type.string, '/', 1), // key\n    new Token(Type.map, Infinity, 1), // value\n    new Token(Type.string, 'bytes', 5), // inner key\n    new Token(Type.string, bytesString, bytesString.length), // inner value\n    new Token(Type.break, undefined, 1),\n    new Token(Type.break, undefined, 1)\n  ]\n}\n\n/**\n * taBytesEncoder wraps bytesEncoder() but for the more exotic typed arrays so\n * that we access the underlying ArrayBuffer data\n *\n * @param {Int8Array|Uint16Array|Int16Array|Uint32Array|Int32Array|Float32Array|Float64Array|Uint8ClampedArray|BigInt64Array|BigUint64Array} obj\n * @returns {Token[]|null}\n */\nfunction taBytesEncoder (obj) {\n  return bytesEncoder(new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength))\n}\n\n/**\n * abBytesEncoder wraps bytesEncoder() but for plain ArrayBuffers\n *\n * @param {ArrayBuffer} ab\n * @returns {Token[]|null}\n */\nfunction abBytesEncoder (ab) {\n  return bytesEncoder(new Uint8Array(ab))\n}\n\n// eslint-disable-next-line jsdoc/require-returns-check\n/**\n * Intercept all `undefined` values from an object walk and reject the entire\n * object if we find one.\n *\n * @returns {null}\n */\nfunction undefinedEncoder () {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded')\n}\n\n/**\n * Intercept all `number` values from an object walk and reject the entire\n * object if we find something that doesn't fit the IPLD data model (NaN &\n * Infinity).\n *\n * @param {number} num\n * @returns {null}\n */\nfunction numberEncoder (num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded')\n  }\n  return null // process with standard number encoder\n}\n\nconst encodeOptions = {\n  typeEncoders: {\n    Object: cidEncoder,\n    Buffer: bytesEncoder,\n    Uint8Array: bytesEncoder,\n    Int8Array: taBytesEncoder,\n    Uint16Array: taBytesEncoder,\n    Int16Array: taBytesEncoder,\n    Uint32Array: taBytesEncoder,\n    Int32Array: taBytesEncoder,\n    Float32Array: taBytesEncoder,\n    Float64Array: taBytesEncoder,\n    Uint8ClampedArray: taBytesEncoder,\n    BigInt64Array: taBytesEncoder,\n    BigUint64Array: taBytesEncoder,\n    DataView: taBytesEncoder,\n    ArrayBuffer: abBytesEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n}\n\n/**\n * @implements {DecodeTokenizer}\n */\nclass DagJsonTokenizer extends cborgJson.Tokenizer {\n  /**\n   * @param {Uint8Array} data\n   * @param {object} [options]\n   */\n  constructor (data, options) {\n    super(data, options)\n    /** @type {Token[]} */\n    this.tokenBuffer = []\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  done () {\n    return this.tokenBuffer.length === 0 && super.done()\n  }\n\n  /**\n   * @returns {Token}\n   */\n  _next () {\n    if (this.tokenBuffer.length > 0) {\n      // @ts-ignore https://github.com/Microsoft/TypeScript/issues/30406\n      return this.tokenBuffer.pop()\n    }\n    return super.next()\n  }\n\n  /**\n   * Implements rules outlined in https://github.com/ipld/specs/pull/356\n   *\n   * @returns {Token}\n   */\n  next () {\n    const token = this._next()\n\n    if (token.type === Type.map) {\n      const keyToken = this._next()\n      if (keyToken.type === Type.string && keyToken.value === '/') {\n        const valueToken = this._next()\n        if (valueToken.type === Type.string) { // *must* be a CID\n          const breakToken = this._next() // swallow the end-of-map token\n          if (breakToken.type !== Type.break) {\n            throw new Error('Invalid encoded CID form')\n          }\n          this.tokenBuffer.push(valueToken) // CID.parse will pick this up after our tag token\n          return new Token(Type.tag, 42, 0)\n        }\n        if (valueToken.type === Type.map) {\n          const innerKeyToken = this._next()\n          if (innerKeyToken.type === Type.string && innerKeyToken.value === 'bytes') {\n            const innerValueToken = this._next()\n            if (innerValueToken.type === Type.string) { // *must* be Bytes\n              for (let i = 0; i < 2; i++) {\n                const breakToken = this._next() // swallow two end-of-map tokens\n                if (breakToken.type !== Type.break) {\n                  throw new Error('Invalid encoded Bytes form')\n                }\n              }\n              const bytes = base64.decode(`m${innerValueToken.value}`)\n              return new Token(Type.bytes, bytes, innerValueToken.value.length)\n            }\n            this.tokenBuffer.push(innerValueToken) // bail\n          }\n          this.tokenBuffer.push(innerKeyToken) // bail\n        }\n        this.tokenBuffer.push(valueToken) // bail\n      }\n      this.tokenBuffer.push(keyToken) // bail\n    }\n    return token\n  }\n}\n\nconst decodeOptions = {\n  allowIndefinite: false,\n  allowUndefined: false,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true, // this will lead to BigInt for ints outside of\n  // safe-integer range, which may surprise users\n  strict: true,\n  useMaps: false,\n  rejectDuplicateMapKeys: true,\n  /** @type {import('cborg').TagDecoder[]} */\n  tags: []\n}\n\n// we're going to get TAG(42)STRING(\"bafy...\") from the tokenizer so we only need\n// to deal with the STRING(\"bafy...\") at this point\ndecodeOptions.tags[42] = CID.parse\n\nexport const name = 'dag-json'\nexport const code = 0x0129\n\n/**\n * @template T\n * @param {T} node\n * @returns {ByteView<T>}\n */\nexport const encode = (node) => cborgJson.encode(node, encodeOptions)\n\n/**\n * @template T\n * @param {ByteView<T> | ArrayBufferView<T>} data\n * @returns {T}\n */\nexport const decode = (data) => {\n  const buf = toByteView(data)\n  // the tokenizer is stateful so we need a single instance of it\n  const options = Object.assign(decodeOptions, { tokenizer: new DagJsonTokenizer(buf, decodeOptions) })\n  return cborgJson.decode(buf, options)\n}\n\n/**\n * @template T\n * @param {T} node\n * @returns {ToString<T>}\n */\nexport const format = (node) => utf8Decoder.decode(encode(node))\nexport { format as stringify }\nconst utf8Decoder = new TextDecoder()\n\n/**\n * @template T\n * @param {ToString<T>} data\n * @returns {T}\n */\nexport const parse = (data) => decode(utf8Encoder.encode(data))\nconst utf8Encoder = new TextEncoder()\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1501, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/car/src/decoder-common.js"],"sourcesContent":["import varint from 'varint'\n\nexport const CIDV0_BYTES = {\n  SHA2_256: 0x12,\n  LENGTH: 0x20,\n  DAG_PB: 0x70\n}\n\nexport const V2_HEADER_LENGTH = /* characteristics */ 16 /* v1 offset */ + 8 /* v1 size */ + 8 /* index offset */ + 8\n\n/**\n * Decodes varint and seeks the buffer\n *\n * ```js\n * // needs bytes to be read first\n * const bytes = reader.upTo(8) // maybe async\n * ```\n *\n * @param {Uint8Array} bytes\n * @param {import('./coding.js').Seekable} seeker\n * @returns {number}\n */\nexport function decodeVarint (bytes, seeker) {\n  if (!bytes.length) {\n    throw new Error('Unexpected end of data')\n  }\n  const i = varint.decode(bytes)\n  seeker.seek(/** @type {number} */(varint.decode.bytes))\n  return i\n}\n\n/**\n * Decode v2 header\n *\n * ```js\n * // needs bytes to be read first\n * const bytes = reader.exactly(V2_HEADER_LENGTH, true) // maybe async\n * ```\n *\n * @param {Uint8Array} bytes\n * @returns {import('./coding.js').CarV2FixedHeader}\n */\nexport function decodeV2Header (bytes) {\n  const dv = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength)\n  let offset = 0\n  const header = {\n    version: 2,\n    /** @type {[bigint, bigint]} */\n    characteristics: [\n      dv.getBigUint64(offset, true),\n      dv.getBigUint64(offset += 8, true)\n    ],\n    dataOffset: Number(dv.getBigUint64(offset += 8, true)),\n    dataSize: Number(dv.getBigUint64(offset += 8, true)),\n    indexOffset: Number(dv.getBigUint64(offset += 8, true))\n  }\n  return header\n}\n\n/**\n * Checks the length of the multihash to be read afterwards\n *\n * ```js\n * // needs bytes to be read first\n * const bytes = reader.upTo(8) // maybe async\n * ```\n *\n * @param {Uint8Array} bytes\n */\nexport function getMultihashLength (bytes) {\n  // | code | length | .... |\n  // where both code and length are varints, so we have to decode\n  // them first before we can know total length\n\n  varint.decode(bytes) // code\n  const codeLength = /** @type {number} */(varint.decode.bytes)\n  const length = varint.decode(bytes.subarray(varint.decode.bytes))\n  const lengthLength = /** @type {number} */(varint.decode.bytes)\n  const mhLength = codeLength + lengthLength + length\n\n  return mhLength\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;;AAEO,MAAM,cAAc;IACzB,UAAU;IACV,QAAQ;IACR,QAAQ;AACV;AAEO,MAAM,mBAAmB,mBAAmB,GAAG,GAAG,aAAa,MAAK,EAAE,WAAW,MAAK,EAAE,gBAAgB,MAAK;AAc7G,SAAS,aAAc,KAAK,EAAE,MAAM;IACzC,IAAI,CAAC,MAAM,MAAM,EAAE;QACjB,MAAM,IAAI,MAAM;IAClB;IACA,MAAM,IAAI,6IAAM,CAAC,MAAM,CAAC;IACxB,OAAO,IAAI,CAAuB,6IAAM,CAAC,MAAM,CAAC,KAAK;IACrD,OAAO;AACT;AAaO,SAAS,eAAgB,KAAK;IACnC,MAAM,KAAK,IAAI,SAAS,MAAM,MAAM,EAAE,MAAM,UAAU,EAAE,MAAM,UAAU;IACxE,IAAI,SAAS;IACb,MAAM,SAAS;QACb,SAAS;QACT,6BAA6B,GAC7B,iBAAiB;YACf,GAAG,YAAY,CAAC,QAAQ;YACxB,GAAG,YAAY,CAAC,UAAU,GAAG;SAC9B;QACD,YAAY,OAAO,GAAG,YAAY,CAAC,UAAU,GAAG;QAChD,UAAU,OAAO,GAAG,YAAY,CAAC,UAAU,GAAG;QAC9C,aAAa,OAAO,GAAG,YAAY,CAAC,UAAU,GAAG;IACnD;IACA,OAAO;AACT;AAYO,SAAS,mBAAoB,KAAK;IACvC,2BAA2B;IAC3B,+DAA+D;IAC/D,6CAA6C;IAE7C,6IAAM,CAAC,MAAM,CAAC,QAAO,OAAO;IAC5B,MAAM,aAAmC,6IAAM,CAAC,MAAM,CAAC,KAAK;IAC5D,MAAM,SAAS,6IAAM,CAAC,MAAM,CAAC,MAAM,QAAQ,CAAC,6IAAM,CAAC,MAAM,CAAC,KAAK;IAC/D,MAAM,eAAqC,6IAAM,CAAC,MAAM,CAAC,KAAK;IAC9D,MAAM,WAAW,aAAa,eAAe;IAE7C,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 1559, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/car/src/header-validator.js"],"sourcesContent":["/* eslint-disable jsdoc/check-indentation, max-depth */\n\n/**\n * Auto-generated with @ipld/schema@v4.2.0 at Thu Sep 14 2023 from IPLD Schema:\n *\n * # CarV1HeaderOrV2Pragma is a more relaxed form, and can parse {version:x} where\n * # roots are optional. This is typically useful for the {verison:2} CARv2\n * # pragma.\n *\n * type CarV1HeaderOrV2Pragma struct {\n *   roots optional [&Any]\n *   # roots is _not_ optional for CarV1 but we defer that check within code to\n *   # gracefully handle the V2 case where it's just {version:X}\n *   version Int\n * }\n *\n * # CarV1Header is the strict form of the header, and requires roots to be\n * # present. This is compatible with the CARv1 specification.\n *\n * # type CarV1Header struct {\n * #   roots [&Any]\n * #   version Int\n * # }\n *\n */\n\nconst Kinds = {\n  Null: /**\n         * @param obj\n         * @returns {undefined|null}\n         */ (/** @type {any} */ obj) => obj === null ? obj : undefined,\n  Int: /**\n        * @param obj\n        * @returns {undefined|number}\n        */ (/** @type {any} */ obj) => Number.isInteger(obj) ? obj : undefined,\n  Float: /**\n          * @param obj\n          * @returns {undefined|number}\n          */ (/** @type {any} */ obj) => typeof obj === 'number' && Number.isFinite(obj) ? obj : undefined,\n  String: /**\n           * @param obj\n           * @returns {undefined|string}\n           */ (/** @type {any} */ obj) => typeof obj === 'string' ? obj : undefined,\n  Bool: /**\n         * @param obj\n         * @returns {undefined|boolean}\n         */ (/** @type {any} */ obj) => typeof obj === 'boolean' ? obj : undefined,\n  Bytes: /**\n          * @param obj\n          * @returns {undefined|Uint8Array}\n          */ (/** @type {any} */ obj) => obj instanceof Uint8Array ? obj : undefined,\n  Link: /**\n         * @param obj\n         * @returns {undefined|object}\n         */ (/** @type {any} */ obj) => obj !== null && typeof obj === 'object' && obj.asCID === obj ? obj : undefined,\n  List: /**\n         * @param obj\n         * @returns {undefined|Array<any>}\n         */ (/** @type {any} */ obj) => Array.isArray(obj) ? obj : undefined,\n  Map: /**\n        * @param obj\n        * @returns {undefined|object}\n        */ (/** @type {any} */ obj) => obj !== null && typeof obj === 'object' && obj.asCID !== obj && !Array.isArray(obj) && !(obj instanceof Uint8Array) ? obj : undefined\n}\n/** @type {{ [k in string]: (obj:any)=>undefined|any}} */\nconst Types = {\n  'CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)': Kinds.Link,\n  'CarV1HeaderOrV2Pragma > roots (anon)': /**\n                                           * @param obj\n                                           * @returns {undefined|any}\n                                           */ (/** @type {any} */ obj) => {\n    if (Kinds.List(obj) === undefined) {\n      return undefined\n    }\n    for (let i = 0; i < obj.length; i++) {\n      let v = obj[i]\n      v = Types['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v)\n      if (v === undefined) {\n        return undefined\n      }\n      if (v !== obj[i]) {\n        const ret = obj.slice(0, i)\n        for (let j = i; j < obj.length; j++) {\n          let v = obj[j]\n          v = Types['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v)\n          if (v === undefined) {\n            return undefined\n          }\n          ret.push(v)\n        }\n        return ret\n      }\n    }\n    return obj\n  },\n  Int: Kinds.Int,\n  CarV1HeaderOrV2Pragma: /**\n                          * @param obj\n                          * @returns {undefined|any}\n                          */ (/** @type {any} */ obj) => {\n    if (Kinds.Map(obj) === undefined) {\n      return undefined\n    }\n    const entries = Object.entries(obj)\n    /** @type {{[k in string]: any}} */\n    let ret = obj\n    let requiredCount = 1\n    for (let i = 0; i < entries.length; i++) {\n      const [key, value] = entries[i]\n      switch (key) {\n        case 'roots':\n          {\n            const v = Types['CarV1HeaderOrV2Pragma > roots (anon)'](obj[key])\n            if (v === undefined) {\n              return undefined\n            }\n            if (v !== value || ret !== obj) {\n              if (ret === obj) {\n                /** @type {{[k in string]: any}} */\n                ret = {}\n                for (let j = 0; j < i; j++) {\n                  ret[entries[j][0]] = entries[j][1]\n                }\n              }\n              ret.roots = v\n            }\n          }\n          break\n        case 'version':\n          {\n            requiredCount--\n            const v = Types.Int(obj[key])\n            if (v === undefined) {\n              return undefined\n            }\n            if (v !== value || ret !== obj) {\n              if (ret === obj) {\n                /** @type {{[k in string]: any}} */\n                ret = {}\n                for (let j = 0; j < i; j++) {\n                  ret[entries[j][0]] = entries[j][1]\n                }\n              }\n              ret.version = v\n            }\n          }\n          break\n        default:\n          return undefined\n      }\n    }\n\n    if (requiredCount > 0) {\n      return undefined\n    }\n    return ret\n  }\n}\n/** @type {{ [k in string]: (obj:any)=>undefined|any}} */\nconst Reprs = {\n  'CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)': Kinds.Link,\n  'CarV1HeaderOrV2Pragma > roots (anon)': /**\n                                           * @param obj\n                                           * @returns {undefined|any}\n                                           */ (/** @type {any} */ obj) => {\n    if (Kinds.List(obj) === undefined) {\n      return undefined\n    }\n    for (let i = 0; i < obj.length; i++) {\n      let v = obj[i]\n      v = Reprs['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v)\n      if (v === undefined) {\n        return undefined\n      }\n      if (v !== obj[i]) {\n        const ret = obj.slice(0, i)\n        for (let j = i; j < obj.length; j++) {\n          let v = obj[j]\n          v = Reprs['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v)\n          if (v === undefined) {\n            return undefined\n          }\n          ret.push(v)\n        }\n        return ret\n      }\n    }\n    return obj\n  },\n  Int: Kinds.Int,\n  CarV1HeaderOrV2Pragma: /**\n                          * @param obj\n                          * @returns {undefined|any}\n                          */ (/** @type {any} */ obj) => {\n    if (Kinds.Map(obj) === undefined) {\n      return undefined\n    }\n    const entries = Object.entries(obj)\n    /** @type {{[k in string]: any}} */\n    let ret = obj\n    let requiredCount = 1\n    for (let i = 0; i < entries.length; i++) {\n      const [key, value] = entries[i]\n      switch (key) {\n        case 'roots':\n          {\n            const v = Reprs['CarV1HeaderOrV2Pragma > roots (anon)'](value)\n            if (v === undefined) {\n              return undefined\n            }\n            if (v !== value || ret !== obj) {\n              if (ret === obj) {\n                /** @type {{[k in string]: any}} */\n                ret = {}\n                for (let j = 0; j < i; j++) {\n                  ret[entries[j][0]] = entries[j][1]\n                }\n              }\n              ret.roots = v\n            }\n          }\n          break\n        case 'version':\n          {\n            requiredCount--\n            const v = Reprs.Int(value)\n            if (v === undefined) {\n              return undefined\n            }\n            if (v !== value || ret !== obj) {\n              if (ret === obj) {\n                /** @type {{[k in string]: any}} */\n                ret = {}\n                for (let j = 0; j < i; j++) {\n                  ret[entries[j][0]] = entries[j][1]\n                }\n              }\n              ret.version = v\n            }\n          }\n          break\n        default:\n          return undefined\n      }\n    }\n    if (requiredCount > 0) {\n      return undefined\n    }\n    return ret\n  }\n}\n\nexport const CarV1HeaderOrV2Pragma = {\n  toTyped: Types.CarV1HeaderOrV2Pragma,\n  toRepresentation: Reprs.CarV1HeaderOrV2Pragma\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1809, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/car/src/buffer-decoder.js"],"sourcesContent":["import { decode as decodeDagCbor } from '@ipld/dag-cbor'\nimport { CID } from 'multiformats/cid'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { CIDV0_BYTES, decodeV2Header, decodeVarint, getMultihashLength, V2_HEADER_LENGTH } from './decoder-common.js'\nimport { CarV1HeaderOrV2Pragma } from './header-validator.js'\n\n/**\n * @typedef {import('./api.js').Block} Block\n * @typedef {import('./api.js').BlockHeader} BlockHeader\n * @typedef {import('./api.js').BlockIndex} BlockIndex\n * @typedef {import('./coding.js').BytesBufferReader} BytesBufferReader\n * @typedef {import('./coding.js').CarHeader} CarHeader\n * @typedef {import('./coding.js').CarV2Header} CarV2Header\n * @typedef {import('./coding.js').CarV2FixedHeader} CarV2FixedHeader\n */\n\n/**\n * Reads header data from a `BytesReader`. The header may either be in the form\n * of a `CarHeader` or `CarV2Header` depending on the CAR being read.\n *\n * @name decoder.readHeader(reader)\n * @param {BytesBufferReader} reader\n * @param {number} [strictVersion]\n * @returns {CarHeader | CarV2Header}\n */\nexport function readHeader (reader, strictVersion) {\n  const length = decodeVarint(reader.upTo(8), reader)\n  if (length === 0) {\n    throw new Error('Invalid CAR header (zero length)')\n  }\n  const header = reader.exactly(length, true)\n  const block = decodeDagCbor(header)\n  if (CarV1HeaderOrV2Pragma.toTyped(block) === undefined) {\n    throw new Error('Invalid CAR header format')\n  }\n  if ((block.version !== 1 && block.version !== 2) || (strictVersion !== undefined && block.version !== strictVersion)) {\n    throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== undefined ? ` (expected ${strictVersion})` : ''}`)\n  }\n  if (block.version === 1) {\n    // CarV1HeaderOrV2Pragma makes roots optional, let's make it mandatory\n    if (!Array.isArray(block.roots)) {\n      throw new Error('Invalid CAR header format')\n    }\n    return block\n  }\n  // version 2\n  if (block.roots !== undefined) {\n    throw new Error('Invalid CAR header format')\n  }\n  const v2Header = decodeV2Header(reader.exactly(V2_HEADER_LENGTH, true))\n  reader.seek(v2Header.dataOffset - reader.pos)\n  const v1Header = readHeader(reader, 1)\n  return Object.assign(v1Header, v2Header)\n}\n\n/**\n * Reads CID sync\n *\n * @param {BytesBufferReader} reader\n * @returns {CID}\n */\nfunction readCid (reader) {\n  const first = reader.exactly(2, false)\n  if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {\n    // cidv0 32-byte sha2-256\n    const bytes = reader.exactly(34, true)\n    const multihash = Digest.decode(bytes)\n    return CID.create(0, CIDV0_BYTES.DAG_PB, multihash)\n  }\n\n  const version = decodeVarint(reader.upTo(8), reader)\n  if (version !== 1) {\n    throw new Error(`Unexpected CID version (${version})`)\n  }\n  const codec = decodeVarint(reader.upTo(8), reader)\n  const bytes = reader.exactly(getMultihashLength(reader.upTo(8)), true)\n  const multihash = Digest.decode(bytes)\n  return CID.create(version, codec, multihash)\n}\n\n/**\n * Reads the leading data of an individual block from CAR data from a\n * `BytesBufferReader`. Returns a `BlockHeader` object which contains\n * `{ cid, length, blockLength }` which can be used to either index the block\n * or read the block binary data.\n *\n * @name async decoder.readBlockHead(reader)\n * @param {BytesBufferReader} reader\n * @returns {BlockHeader}\n */\nexport function readBlockHead (reader) {\n  // length includes a CID + Binary, where CID has a variable length\n  // we have to deal with\n  const start = reader.pos\n  let length = decodeVarint(reader.upTo(8), reader)\n  if (length === 0) {\n    throw new Error('Invalid CAR section (zero length)')\n  }\n  length += (reader.pos - start)\n  const cid = readCid(reader)\n  const blockLength = length - Number(reader.pos - start) // subtract CID length\n\n  return { cid, length, blockLength }\n}\n\n/**\n * Returns Car header and blocks from a Uint8Array\n *\n * @param {Uint8Array} bytes\n * @returns {{ header : CarHeader | CarV2Header , blocks: Block[]}}\n */\nexport function fromBytes (bytes) {\n  let reader = bytesReader(bytes)\n  const header = readHeader(reader)\n  if (header.version === 2) {\n    const v1length = reader.pos - header.dataOffset\n    reader = limitReader(reader, header.dataSize - v1length)\n  }\n\n  const blocks = []\n  while (reader.upTo(8).length > 0) {\n    const { cid, blockLength } = readBlockHead(reader)\n\n    blocks.push({ cid, bytes: reader.exactly(blockLength, true) })\n  }\n\n  return {\n    header, blocks\n  }\n}\n\n/**\n * Creates a `BytesBufferReader` from a `Uint8Array`.\n *\n * @name decoder.bytesReader(bytes)\n * @param {Uint8Array} bytes\n * @returns {BytesBufferReader}\n */\nexport function bytesReader (bytes) {\n  let pos = 0\n\n  /** @type {BytesBufferReader} */\n  return {\n    upTo (length) {\n      return bytes.subarray(pos, pos + Math.min(length, bytes.length - pos))\n    },\n\n    exactly (length, seek = false) {\n      if (length > bytes.length - pos) {\n        throw new Error('Unexpected end of data')\n      }\n\n      const out = bytes.subarray(pos, pos + length)\n      if (seek) {\n        pos += length\n      }\n      return out\n    },\n\n    seek (length) {\n      pos += length\n    },\n\n    get pos () {\n      return pos\n    }\n  }\n}\n\n/**\n * Wraps a `BytesBufferReader` in a limiting `BytesBufferReader` which limits maximum read\n * to `byteLimit` bytes. It _does not_ update `pos` of the original\n * `BytesBufferReader`.\n *\n * @name decoder.limitReader(reader, byteLimit)\n * @param {BytesBufferReader} reader\n * @param {number} byteLimit\n * @returns {BytesBufferReader}\n */\nexport function limitReader (reader, byteLimit) {\n  let bytesRead = 0\n\n  /** @type {BytesBufferReader} */\n  return {\n    upTo (length) {\n      let bytes = reader.upTo(length)\n      if (bytes.length + bytesRead > byteLimit) {\n        bytes = bytes.subarray(0, byteLimit - bytesRead)\n      }\n      return bytes\n    },\n\n    exactly (length, seek = false) {\n      const bytes = reader.exactly(length, seek)\n      if (bytes.length + bytesRead > byteLimit) {\n        throw new Error('Unexpected end of data')\n      }\n      if (seek) {\n        bytesRead += length\n      }\n      return bytes\n    },\n\n    seek (length) {\n      bytesRead += length\n      reader.seek(length)\n    },\n\n    get pos () {\n      return reader.pos\n    }\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1977, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/car/src/buffer-reader-browser.js"],"sourcesContent":["import * as BufferDecoder from './buffer-decoder.js'\n\n/**\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('./api.js').Block} Block\n * @typedef {import('./api.js').CarBufferReader} ICarBufferReader\n * @typedef {import('./coding.js').CarHeader} CarHeader\n * @typedef {import('./coding.js').CarV2Header} CarV2Header\n */\n\n/**\n * Provides blockstore-like access to a CAR.\n *\n * Implements the `RootsBufferReader` interface:\n * {@link ICarBufferReader.getRoots `getRoots()`}. And the `BlockBufferReader` interface:\n * {@link ICarBufferReader.get `get()`}, {@link ICarBufferReader.has `has()`},\n * {@link ICarBufferReader.blocks `blocks()`} and\n * {@link ICarBufferReader.cids `cids()`}.\n *\n * Load this class with either `import { CarBufferReader } from '@ipld/car/buffer-reader'`\n * (`const { CarBufferReader } = require('@ipld/car/buffer-reader')`). Or\n * `import { CarBufferReader } from '@ipld/car'` (`const { CarBufferReader } = require('@ipld/car')`).\n * The former will likely result in smaller bundle sizes where this is\n * important.\n *\n * @name CarBufferReader\n * @class\n * @implements {ICarBufferReader}\n * @property {number} version The version number of the CAR referenced by this\n * reader (should be `1` or `2`).\n */\nexport class CarBufferReader {\n  /**\n   * @constructs CarBufferReader\n   * @param {CarHeader|CarV2Header} header\n   * @param {Block[]} blocks\n   */\n  constructor (header, blocks) {\n    this._header = header\n    this._blocks = blocks\n    this._cids = undefined\n  }\n\n  /**\n   * @property {number} version of the CAR\n   * @memberof CarBufferReader\n   * @instance\n   */\n  get version () {\n    return this._header.version\n  }\n\n  /**\n   * Get the list of roots defined by the CAR referenced by this reader. May be\n   * zero or more `CID`s.\n   *\n   * @function\n   * @memberof CarBufferReader\n   * @instance\n   * @returns {CID[]}\n   */\n  getRoots () {\n    return this._header.roots\n  }\n\n  /**\n   * Check whether a given `CID` exists within the CAR referenced by this\n   * reader.\n   *\n   * @function\n   * @memberof CarBufferReader\n   * @instance\n   * @param {CID} key\n   * @returns {boolean}\n   */\n  has (key) {\n    return this._blocks.some(b => b.cid.equals(key))\n  }\n\n  /**\n   * Fetch a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) from the CAR\n   * referenced by this reader matching the provided `CID`. In the case where\n   * the provided `CID` doesn't exist within the CAR, `undefined` will be\n   * returned.\n   *\n   * @function\n   * @memberof CarBufferReader\n   * @instance\n   * @param {CID} key\n   * @returns {Block | undefined}\n   */\n  get (key) {\n    return this._blocks.find(b => b.cid.equals(key))\n  }\n\n  /**\n   * Returns a `Block[]` of the `Block`s (`{ cid:CID, bytes:Uint8Array }` pairs) contained within\n   * the CAR referenced by this reader.\n   *\n   * @function\n   * @memberof CarBufferReader\n   * @instance\n   * @returns {Block[]}\n   */\n  blocks () {\n    return this._blocks\n  }\n\n  /**\n   * Returns a `CID[]` of the `CID`s contained within the CAR referenced by this reader.\n   *\n   * @function\n   * @memberof CarBufferReader\n   * @instance\n   * @returns {CID[]}\n   */\n  cids () {\n    if (!this._cids) {\n      this._cids = this._blocks.map(b => b.cid)\n    }\n    return this._cids\n  }\n\n  /**\n   * Instantiate a {@link CarBufferReader} from a `Uint8Array` blob. This performs a\n   * decode fully in memory and maintains the decoded state in memory for full\n   * access to the data via the `CarReader` API.\n   *\n   * @static\n   * @memberof CarBufferReader\n   * @param {Uint8Array} bytes\n   * @returns {CarBufferReader}\n   */\n  static fromBytes (bytes) {\n    if (!(bytes instanceof Uint8Array)) {\n      throw new TypeError('fromBytes() requires a Uint8Array')\n    }\n\n    const { header, blocks } = BufferDecoder.fromBytes(bytes)\n    return new CarBufferReader(header, blocks)\n  }\n}\n\nexport const __browser = true\n"],"names":[],"mappings":";;;;;;AAAA;;AA+BO,MAAM;IACX;;;;GAIC,GACD,YAAa,MAAM,EAAE,MAAM,CAAE;QAC3B,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,KAAK,GAAG;IACf;IAEA;;;;GAIC,GACD,IAAI,UAAW;QACb,OAAO,IAAI,CAAC,OAAO,CAAC,OAAO;IAC7B;IAEA;;;;;;;;GAQC,GACD,WAAY;QACV,OAAO,IAAI,CAAC,OAAO,CAAC,KAAK;IAC3B;IAEA;;;;;;;;;GASC,GACD,IAAK,GAAG,EAAE;QACR,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAA,IAAK,EAAE,GAAG,CAAC,MAAM,CAAC;IAC7C;IAEA;;;;;;;;;;;GAWC,GACD,IAAK,GAAG,EAAE;QACR,OAAO,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,CAAA,IAAK,EAAE,GAAG,CAAC,MAAM,CAAC;IAC7C;IAEA;;;;;;;;GAQC,GACD,SAAU;QACR,OAAO,IAAI,CAAC,OAAO;IACrB;IAEA;;;;;;;GAOC,GACD,OAAQ;QACN,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE;YACf,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAA,IAAK,EAAE,GAAG;QAC1C;QACA,OAAO,IAAI,CAAC,KAAK;IACnB;IAEA;;;;;;;;;GASC,GACD,OAAO,UAAW,KAAK,EAAE;QACvB,IAAI,CAAC,CAAC,iBAAiB,UAAU,GAAG;YAClC,MAAM,IAAI,UAAU;QACtB;QAEA,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,GAAG,yKAAuB,CAAC;QACnD,OAAO,IAAI,gBAAgB,QAAQ;IACrC;AACF;AAEO,MAAM,YAAY","ignoreList":[0]}},
    {"offset": {"line": 2085, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/car/src/buffer-writer.js"],"sourcesContent":["import * as CBOR from '@ipld/dag-cbor'\nimport { Token, Type } from 'cborg'\nimport { tokensToLength } from 'cborg/length'\nimport varint from 'varint'\n\n/**\n * @typedef {import('./api.js').CID} CID\n * @typedef {import('./api.js').Block} Block\n * @typedef {import('./api.js').CarBufferWriter} Writer\n * @typedef {import('./api.js').CarBufferWriterOptions} Options\n * @typedef {import('./coding.js').CarEncoder} CarEncoder\n */\n\n/**\n * A simple CAR writer that writes to a pre-allocated buffer.\n *\n * @class\n * @name CarBufferWriter\n * @implements {Writer}\n */\nclass CarBufferWriter {\n  /**\n   * @param {Uint8Array} bytes\n   * @param {number} headerSize\n   */\n  constructor (bytes, headerSize) {\n    /** @readonly */\n    this.bytes = bytes\n    this.byteOffset = headerSize\n\n    /**\n     * @readonly\n     * @type {CID[]}\n     */\n    this.roots = []\n    this.headerSize = headerSize\n  }\n\n  /**\n   * Add a root to this writer, to be used to create a header when the CAR is\n   * finalized with {@link CarBufferWriter.close `close()`}\n   *\n   * @param {CID} root\n   * @param {{resize?:boolean}} [options]\n   * @returns {CarBufferWriter}\n   */\n  addRoot (root, options) {\n    addRoot(this, root, options)\n    return this\n  }\n\n  /**\n   * Write a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) to the archive.\n   * Throws if there is not enough capacity.\n   *\n   * @param {Block} block - A `{ cid:CID, bytes:Uint8Array }` pair.\n   * @returns {CarBufferWriter}\n   */\n  write (block) {\n    addBlock(this, block)\n    return this\n  }\n\n  /**\n   * Finalize the CAR and return it as a `Uint8Array`.\n   *\n   * @param {object} [options]\n   * @param {boolean} [options.resize]\n   * @returns {Uint8Array}\n   */\n  close (options) {\n    return close(this, options)\n  }\n}\n\n/**\n * @param {CarBufferWriter} writer\n * @param {CID} root\n * @param {{resize?:boolean}} [options]\n */\nexport const addRoot = (writer, root, options = {}) => {\n  const { resize = false } = options\n  const { bytes, headerSize, byteOffset, roots } = writer\n  writer.roots.push(root)\n  const size = headerLength(writer)\n  // If there is not enough space for the new root\n  if (size > headerSize) {\n    // Check if we root would fit if we were to resize the head.\n    if (size - headerSize + byteOffset < bytes.byteLength) {\n      // If resize is enabled resize head\n      if (resize) {\n        resizeHeader(writer, size)\n      // otherwise remove head and throw an error suggesting to resize\n      } else {\n        roots.pop()\n        throw new RangeError(`Header of size ${headerSize} has no capacity for new root ${root}.\n  However there is a space in the buffer and you could call addRoot(root, { resize: root }) to resize header to make a space for this root.`)\n      }\n    // If head would not fit even with resize pop new root and throw error\n    } else {\n      roots.pop()\n      throw new RangeError(`Buffer has no capacity for a new root ${root}`)\n    }\n  }\n}\n\n/**\n * Calculates number of bytes required for storing given block in CAR. Useful in\n * estimating size of an `ArrayBuffer` for the `CarBufferWriter`.\n *\n * @name CarBufferWriter.blockLength(Block)\n * @param {Block} block\n * @returns {number}\n */\nexport const blockLength = ({ cid, bytes }) => {\n  const size = cid.bytes.byteLength + bytes.byteLength\n  return varint.encodingLength(size) + size\n}\n\n/**\n * @param {CarBufferWriter} writer\n * @param {Block} block\n */\nexport const addBlock = (writer, { cid, bytes }) => {\n  const byteLength = cid.bytes.byteLength + bytes.byteLength\n  const size = varint.encode(byteLength)\n  if (writer.byteOffset + size.length + byteLength > writer.bytes.byteLength) {\n    throw new RangeError('Buffer has no capacity for this block')\n  } else {\n    writeBytes(writer, size)\n    writeBytes(writer, cid.bytes)\n    writeBytes(writer, bytes)\n  }\n}\n\n/**\n * @param {CarBufferWriter} writer\n * @param {object} [options]\n * @param {boolean} [options.resize]\n */\nexport const close = (writer, options = {}) => {\n  const { resize = false } = options\n  const { roots, bytes, byteOffset, headerSize } = writer\n\n  const headerBytes = CBOR.encode({ version: 1, roots })\n  const varintBytes = varint.encode(headerBytes.length)\n\n  const size = varintBytes.length + headerBytes.byteLength\n  const offset = headerSize - size\n\n  // If header size estimate was accurate we just write header and return\n  // view into buffer.\n  if (offset === 0) {\n    writeHeader(writer, varintBytes, headerBytes)\n    return bytes.subarray(0, byteOffset)\n    // If header was overestimated and `{resize: true}` is passed resize header\n  } else if (resize) {\n    resizeHeader(writer, size)\n    writeHeader(writer, varintBytes, headerBytes)\n    return bytes.subarray(0, writer.byteOffset)\n  } else {\n    throw new RangeError(`Header size was overestimated.\nYou can use close({ resize: true }) to resize header`)\n  }\n}\n\n/**\n * @param {CarBufferWriter} writer\n * @param {number} byteLength\n */\nexport const resizeHeader = (writer, byteLength) => {\n  const { bytes, headerSize } = writer\n  // Move data section to a new offset\n  bytes.set(bytes.subarray(headerSize, writer.byteOffset), byteLength)\n  // Update header size & byteOffset\n  writer.byteOffset += byteLength - headerSize\n  writer.headerSize = byteLength\n}\n\n/**\n * @param {CarBufferWriter} writer\n * @param {number[]|Uint8Array} bytes\n */\n\nconst writeBytes = (writer, bytes) => {\n  writer.bytes.set(bytes, writer.byteOffset)\n  writer.byteOffset += bytes.length\n}\n/**\n * @param {{bytes:Uint8Array}} writer\n * @param {number[]} varint\n * @param {Uint8Array} header\n */\nconst writeHeader = ({ bytes }, varint, header) => {\n  bytes.set(varint)\n  bytes.set(header, varint.length)\n}\n\nconst headerPreludeTokens = [\n  new Token(Type.map, 2),\n  new Token(Type.string, 'version'),\n  new Token(Type.uint, 1),\n  new Token(Type.string, 'roots')\n]\n\nconst CID_TAG = new Token(Type.tag, 42)\n\n/**\n * Calculates header size given the array of byteLength for roots.\n *\n * @name CarBufferWriter.calculateHeaderLength(rootLengths)\n * @param {number[]} rootLengths\n * @returns {number}\n */\nexport const calculateHeaderLength = (rootLengths) => {\n  const tokens = [...headerPreludeTokens]\n  tokens.push(new Token(Type.array, rootLengths.length))\n  for (const rootLength of rootLengths) {\n    tokens.push(CID_TAG)\n    tokens.push(new Token(Type.bytes, { length: rootLength + 1 }))\n  }\n  const length = tokensToLength(tokens) // no options needed here because we have simple tokens\n  return varint.encodingLength(length) + length\n}\n\n/**\n * Calculates header size given the array of roots.\n *\n * @name CarBufferWriter.headerLength({ roots })\n * @param {object} options\n * @param {CID[]} options.roots\n * @returns {number}\n */\nexport const headerLength = ({ roots }) =>\n  calculateHeaderLength(roots.map(cid => cid.bytes.byteLength))\n\n/**\n * Estimates header size given a count of the roots and the expected byte length\n * of the root CIDs. The default length works for a standard CIDv1 with a\n * single-byte multihash code, such as SHA2-256 (i.e. the most common CIDv1).\n *\n * @name CarBufferWriter.estimateHeaderLength(rootCount[, rootByteLength])\n * @param {number} rootCount\n * @param {number} [rootByteLength]\n * @returns {number}\n */\nexport const estimateHeaderLength = (rootCount, rootByteLength = 36) =>\n  calculateHeaderLength(new Array(rootCount).fill(rootByteLength))\n\n/**\n * Creates synchronous CAR writer that can be used to encode blocks into a given\n * buffer. Optionally you could pass `byteOffset` and `byteLength` to specify a\n * range inside buffer to write into. If car file is going to have `roots` you\n * need to either pass them under `options.roots` (from which header size will\n * be calculated) or provide `options.headerSize` to allocate required space\n * in the buffer. You may also provide known `roots` and `headerSize` to\n * allocate space for the roots that may not be known ahead of time.\n *\n * Note: Incorrect `headerSize` may lead to copying bytes inside a buffer\n * which will have a negative impact on performance.\n *\n * @name CarBufferWriter.createWriter(buffer[, options])\n * @param {ArrayBuffer} buffer\n * @param {object} [options]\n * @param {CID[]} [options.roots]\n * @param {number} [options.byteOffset]\n * @param {number} [options.byteLength]\n * @param {number} [options.headerSize]\n * @returns {CarBufferWriter}\n */\nexport const createWriter = (buffer, options = {}) => {\n  const {\n    roots = [],\n    byteOffset = 0,\n    byteLength = buffer.byteLength,\n    headerSize = headerLength({ roots })\n  } = options\n  const bytes = new Uint8Array(buffer, byteOffset, byteLength)\n\n  const writer = new CarBufferWriter(bytes, headerSize)\n  for (const root of roots) {\n    writer.addRoot(root)\n  }\n\n  return writer\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2297, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/car/src/indexed-reader-browser.js"],"sourcesContent":["export class CarIndexedReader {\n  static async fromFile () {\n    throw new Error('Unsupported in this environment')\n  }\n}\n\nexport const __browser = true\n"],"names":[],"mappings":";;;;;;AAAO,MAAM;IACX,aAAa,WAAY;QACvB,MAAM,IAAI,MAAM;IAClB;AACF;AAEO,MAAM,YAAY","ignoreList":[0]}},
    {"offset": {"line": 2313, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/car/src/decoder.js"],"sourcesContent":["import { decode as decodeDagCbor } from '@ipld/dag-cbor'\nimport { CID } from 'multiformats/cid'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { CIDV0_BYTES, decodeV2Header, decodeVarint, getMultihashLength, V2_HEADER_LENGTH } from './decoder-common.js'\nimport { CarV1HeaderOrV2Pragma } from './header-validator.js'\n\n/**\n * @typedef {import('./api.js').Block} Block\n * @typedef {import('./api.js').BlockHeader} BlockHeader\n * @typedef {import('./api.js').BlockIndex} BlockIndex\n * @typedef {import('./coding.js').BytesReader} BytesReader\n * @typedef {import('./coding.js').CarHeader} CarHeader\n * @typedef {import('./coding.js').CarV2Header} CarV2Header\n * @typedef {import('./coding.js').CarV2FixedHeader} CarV2FixedHeader\n * @typedef {import('./coding.js').CarDecoder} CarDecoder\n */\n\n/**\n * Reads header data from a `BytesReader`. The header may either be in the form\n * of a `CarHeader` or `CarV2Header` depending on the CAR being read.\n *\n * @name async decoder.readHeader(reader)\n * @param {BytesReader} reader\n * @param {number} [strictVersion]\n * @returns {Promise<CarHeader|CarV2Header>}\n */\nexport async function readHeader (reader, strictVersion) {\n  const length = decodeVarint(await reader.upTo(8), reader)\n  if (length === 0) {\n    throw new Error('Invalid CAR header (zero length)')\n  }\n  const header = await reader.exactly(length, true)\n  const block = decodeDagCbor(header)\n  if (CarV1HeaderOrV2Pragma.toTyped(block) === undefined) {\n    throw new Error('Invalid CAR header format')\n  }\n  if ((block.version !== 1 && block.version !== 2) || (strictVersion !== undefined && block.version !== strictVersion)) {\n    throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== undefined ? ` (expected ${strictVersion})` : ''}`)\n  }\n  if (block.version === 1) {\n    // CarV1HeaderOrV2Pragma makes roots optional, let's make it mandatory\n    if (!Array.isArray(block.roots)) {\n      throw new Error('Invalid CAR header format')\n    }\n    return block\n  }\n  // version 2\n  if (block.roots !== undefined) {\n    throw new Error('Invalid CAR header format')\n  }\n  const v2Header = decodeV2Header(await reader.exactly(V2_HEADER_LENGTH, true))\n  reader.seek(v2Header.dataOffset - reader.pos)\n  const v1Header = await readHeader(reader, 1)\n  return Object.assign(v1Header, v2Header)\n}\n\n/**\n * @param {BytesReader} reader\n * @returns {Promise<CID>}\n */\nasync function readCid (reader) {\n  const first = await reader.exactly(2, false)\n  if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {\n    // cidv0 32-byte sha2-256\n    const bytes = await reader.exactly(34, true)\n    const multihash = Digest.decode(bytes)\n    return CID.create(0, CIDV0_BYTES.DAG_PB, multihash)\n  }\n\n  const version = decodeVarint(await reader.upTo(8), reader)\n  if (version !== 1) {\n    throw new Error(`Unexpected CID version (${version})`)\n  }\n  const codec = decodeVarint(await reader.upTo(8), reader)\n  const bytes = await reader.exactly(getMultihashLength(await reader.upTo(8)), true)\n  const multihash = Digest.decode(bytes)\n  return CID.create(version, codec, multihash)\n}\n\n/**\n * Reads the leading data of an individual block from CAR data from a\n * `BytesReader`. Returns a `BlockHeader` object which contains\n * `{ cid, length, blockLength }` which can be used to either index the block\n * or read the block binary data.\n *\n * @name async decoder.readBlockHead(reader)\n * @param {BytesReader} reader\n * @returns {Promise<BlockHeader>}\n */\nexport async function readBlockHead (reader) {\n  // length includes a CID + Binary, where CID has a variable length\n  // we have to deal with\n  const start = reader.pos\n  let length = decodeVarint(await reader.upTo(8), reader)\n  if (length === 0) {\n    throw new Error('Invalid CAR section (zero length)')\n  }\n  length += (reader.pos - start)\n  const cid = await readCid(reader)\n  const blockLength = length - Number(reader.pos - start) // subtract CID length\n\n  return { cid, length, blockLength }\n}\n\n/**\n * @param {BytesReader} reader\n * @returns {Promise<Block>}\n */\nasync function readBlock (reader) {\n  const { cid, blockLength } = await readBlockHead(reader)\n  const bytes = await reader.exactly(blockLength, true)\n  return { bytes, cid }\n}\n\n/**\n * @param {BytesReader} reader\n * @returns {Promise<BlockIndex>}\n */\nasync function readBlockIndex (reader) {\n  const offset = reader.pos\n  const { cid, length, blockLength } = await readBlockHead(reader)\n  const index = { cid, length, blockLength, offset, blockOffset: reader.pos }\n  reader.seek(index.blockLength)\n  return index\n}\n\n/**\n * Creates a `CarDecoder` from a `BytesReader`. The `CarDecoder` is as async\n * interface that will consume the bytes from the `BytesReader` to yield a\n * `header()` and either `blocks()` or `blocksIndex()` data.\n *\n * @name decoder.createDecoder(reader)\n * @param {BytesReader} reader\n * @returns {CarDecoder}\n */\nexport function createDecoder (reader) {\n  const headerPromise = (async () => {\n    const header = await readHeader(reader)\n    if (header.version === 2) {\n      const v1length = reader.pos - header.dataOffset\n      reader = limitReader(reader, header.dataSize - v1length)\n    }\n    return header\n  })()\n\n  return {\n    header: () => headerPromise,\n\n    async * blocks () {\n      await headerPromise\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlock(reader)\n      }\n    },\n\n    async * blocksIndex () {\n      await headerPromise\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlockIndex(reader)\n      }\n    }\n  }\n}\n\n/**\n * Creates a `BytesReader` from a `Uint8Array`.\n *\n * @name decoder.bytesReader(bytes)\n * @param {Uint8Array} bytes\n * @returns {BytesReader}\n */\nexport function bytesReader (bytes) {\n  let pos = 0\n\n  /** @type {BytesReader} */\n  return {\n    async upTo (length) {\n      const out = bytes.subarray(pos, pos + Math.min(length, bytes.length - pos))\n      return out\n    },\n\n    async exactly (length, seek = false) {\n      if (length > bytes.length - pos) {\n        throw new Error('Unexpected end of data')\n      }\n      const out = bytes.subarray(pos, pos + length)\n      if (seek) {\n        pos += length\n      }\n      return out\n    },\n\n    seek (length) {\n      pos += length\n    },\n\n    get pos () {\n      return pos\n    }\n  }\n}\n\n/**\n * reusable reader for streams and files, we just need a way to read an\n * additional chunk (of some undetermined size) and a way to close the\n * reader when finished\n *\n * @param {() => Promise<Uint8Array|null>} readChunk\n * @returns {BytesReader}\n */\nexport function chunkReader (readChunk /*, closer */) {\n  let pos = 0\n  let have = 0\n  let offset = 0\n  let currentChunk = new Uint8Array(0)\n\n  const read = async (/** @type {number} */ length) => {\n    have = currentChunk.length - offset\n    const bufa = /** @type {Uint8Array<ArrayBufferLike>[]} */([currentChunk.subarray(offset)])\n    while (have < length) {\n      const chunk = await readChunk()\n      if (chunk == null) {\n        break\n      }\n      /* c8 ignore next 8 */\n      // undo this ignore ^ when we have a fd implementation that can seek()\n      if (have < 0) { // because of a seek()\n        /* c8 ignore next 4 */\n        // toohard to test the else\n        if (chunk.length > have) {\n          bufa.push(chunk.subarray(-have))\n        } // else discard\n      } else {\n        bufa.push(chunk)\n      }\n      have += chunk.length\n    }\n    currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0))\n    let off = 0\n    for (const b of bufa) {\n      currentChunk.set(b, off)\n      off += b.length\n    }\n    offset = 0\n  }\n\n  /** @type {BytesReader} */\n  return {\n    async upTo (length) {\n      if (currentChunk.length - offset < length) {\n        await read(length)\n      }\n      return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length))\n    },\n\n    async exactly (length, seek = false) {\n      if (currentChunk.length - offset < length) {\n        await read(length)\n      }\n      if (currentChunk.length - offset < length) {\n        throw new Error('Unexpected end of data')\n      }\n      const out = currentChunk.subarray(offset, offset + length)\n      if (seek) {\n        pos += length\n        offset += length\n      }\n      return out\n    },\n\n    seek (length) {\n      pos += length\n      offset += length\n    },\n\n    get pos () {\n      return pos\n    }\n  }\n}\n\n/**\n * Creates a `BytesReader` from an `AsyncIterable<Uint8Array>`, which allows for\n * consumption of CAR data from a streaming source.\n *\n * @name decoder.asyncIterableReader(asyncIterable)\n * @param {AsyncIterable<Uint8Array>} asyncIterable\n * @returns {BytesReader}\n */\nexport function asyncIterableReader (asyncIterable) {\n  const iterator = asyncIterable[Symbol.asyncIterator]()\n\n  async function readChunk () {\n    const next = await iterator.next()\n    if (next.done) {\n      return null\n    }\n    return next.value\n  }\n\n  return chunkReader(readChunk)\n}\n\n/**\n * Wraps a `BytesReader` in a limiting `BytesReader` which limits maximum read\n * to `byteLimit` bytes. It _does not_ update `pos` of the original\n * `BytesReader`.\n *\n * @name decoder.limitReader(reader, byteLimit)\n * @param {BytesReader} reader\n * @param {number} byteLimit\n * @returns {BytesReader}\n */\nexport function limitReader (reader, byteLimit) {\n  let bytesRead = 0\n\n  /** @type {BytesReader} */\n  return {\n    async upTo (length) {\n      let bytes = await reader.upTo(length)\n      if (bytes.length + bytesRead > byteLimit) {\n        bytes = bytes.subarray(0, byteLimit - bytesRead)\n      }\n      return bytes\n    },\n\n    async exactly (length, seek = false) {\n      const bytes = await reader.exactly(length, seek)\n      if (bytes.length + bytesRead > byteLimit) {\n        throw new Error('Unexpected end of data')\n      }\n      if (seek) {\n        bytesRead += length\n      }\n      return bytes\n    },\n\n    seek (length) {\n      bytesRead += length\n      reader.seek(length)\n    },\n\n    get pos () {\n      return reader.pos\n    }\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;;;;;;AAsBO,eAAe,WAAY,MAAM,EAAE,aAAa;IACrD,MAAM,SAAS,IAAA,4KAAY,EAAC,MAAM,OAAO,IAAI,CAAC,IAAI;IAClD,IAAI,WAAW,GAAG;QAChB,MAAM,IAAI,MAAM;IAClB;IACA,MAAM,SAAS,MAAM,OAAO,OAAO,CAAC,QAAQ;IAC5C,MAAM,QAAQ,IAAA,kKAAa,EAAC;IAC5B,IAAI,uLAAqB,CAAC,OAAO,CAAC,WAAW,WAAW;QACtD,MAAM,IAAI,MAAM;IAClB;IACA,IAAI,AAAC,MAAM,OAAO,KAAK,KAAK,MAAM,OAAO,KAAK,KAAO,kBAAkB,aAAa,MAAM,OAAO,KAAK,eAAgB;QACpH,MAAM,IAAI,MAAM,CAAC,qBAAqB,EAAE,MAAM,OAAO,GAAG,kBAAkB,YAAY,CAAC,WAAW,EAAE,cAAc,CAAC,CAAC,GAAG,IAAI;IAC7H;IACA,IAAI,MAAM,OAAO,KAAK,GAAG;QACvB,sEAAsE;QACtE,IAAI,CAAC,MAAM,OAAO,CAAC,MAAM,KAAK,GAAG;YAC/B,MAAM,IAAI,MAAM;QAClB;QACA,OAAO;IACT;IACA,YAAY;IACZ,IAAI,MAAM,KAAK,KAAK,WAAW;QAC7B,MAAM,IAAI,MAAM;IAClB;IACA,MAAM,WAAW,IAAA,8KAAc,EAAC,MAAM,OAAO,OAAO,CAAC,gLAAgB,EAAE;IACvE,OAAO,IAAI,CAAC,SAAS,UAAU,GAAG,OAAO,GAAG;IAC5C,MAAM,WAAW,MAAM,WAAW,QAAQ;IAC1C,OAAO,OAAO,MAAM,CAAC,UAAU;AACjC;AAEA;;;CAGC,GACD,eAAe,QAAS,MAAM;IAC5B,MAAM,QAAQ,MAAM,OAAO,OAAO,CAAC,GAAG;IACtC,IAAI,KAAK,CAAC,EAAE,KAAK,2KAAW,CAAC,QAAQ,IAAI,KAAK,CAAC,EAAE,KAAK,2KAAW,CAAC,MAAM,EAAE;QACxE,yBAAyB;QACzB,MAAM,QAAQ,MAAM,OAAO,OAAO,CAAC,IAAI;QACvC,MAAM,YAAY,6MAAa,CAAC;QAChC,OAAO,6MAAG,CAAC,MAAM,CAAC,GAAG,2KAAW,CAAC,MAAM,EAAE;IAC3C;IAEA,MAAM,UAAU,IAAA,4KAAY,EAAC,MAAM,OAAO,IAAI,CAAC,IAAI;IACnD,IAAI,YAAY,GAAG;QACjB,MAAM,IAAI,MAAM,CAAC,wBAAwB,EAAE,QAAQ,CAAC,CAAC;IACvD;IACA,MAAM,QAAQ,IAAA,4KAAY,EAAC,MAAM,OAAO,IAAI,CAAC,IAAI;IACjD,MAAM,QAAQ,MAAM,OAAO,OAAO,CAAC,IAAA,kLAAkB,EAAC,MAAM,OAAO,IAAI,CAAC,KAAK;IAC7E,MAAM,YAAY,6MAAa,CAAC;IAChC,OAAO,6MAAG,CAAC,MAAM,CAAC,SAAS,OAAO;AACpC;AAYO,eAAe,cAAe,MAAM;IACzC,kEAAkE;IAClE,uBAAuB;IACvB,MAAM,QAAQ,OAAO,GAAG;IACxB,IAAI,SAAS,IAAA,4KAAY,EAAC,MAAM,OAAO,IAAI,CAAC,IAAI;IAChD,IAAI,WAAW,GAAG;QAChB,MAAM,IAAI,MAAM;IAClB;IACA,UAAW,OAAO,GAAG,GAAG;IACxB,MAAM,MAAM,MAAM,QAAQ;IAC1B,MAAM,cAAc,SAAS,OAAO,OAAO,GAAG,GAAG,OAAO,sBAAsB;;IAE9E,OAAO;QAAE;QAAK;QAAQ;IAAY;AACpC;AAEA;;;CAGC,GACD,eAAe,UAAW,MAAM;IAC9B,MAAM,EAAE,GAAG,EAAE,WAAW,EAAE,GAAG,MAAM,cAAc;IACjD,MAAM,QAAQ,MAAM,OAAO,OAAO,CAAC,aAAa;IAChD,OAAO;QAAE;QAAO;IAAI;AACtB;AAEA;;;CAGC,GACD,eAAe,eAAgB,MAAM;IACnC,MAAM,SAAS,OAAO,GAAG;IACzB,MAAM,EAAE,GAAG,EAAE,MAAM,EAAE,WAAW,EAAE,GAAG,MAAM,cAAc;IACzD,MAAM,QAAQ;QAAE;QAAK;QAAQ;QAAa;QAAQ,aAAa,OAAO,GAAG;IAAC;IAC1E,OAAO,IAAI,CAAC,MAAM,WAAW;IAC7B,OAAO;AACT;AAWO,SAAS,cAAe,MAAM;IACnC,MAAM,gBAAgB,CAAC;QACrB,MAAM,SAAS,MAAM,WAAW;QAChC,IAAI,OAAO,OAAO,KAAK,GAAG;YACxB,MAAM,WAAW,OAAO,GAAG,GAAG,OAAO,UAAU;YAC/C,SAAS,YAAY,QAAQ,OAAO,QAAQ,GAAG;QACjD;QACA,OAAO;IACT,CAAC;IAED,OAAO;QACL,QAAQ,IAAM;QAEd,OAAQ;YACN,MAAM;YACN,MAAO,CAAC,MAAM,OAAO,IAAI,CAAC,EAAE,EAAE,MAAM,GAAG,EAAG;gBACxC,MAAM,MAAM,UAAU;YACxB;QACF;QAEA,OAAQ;YACN,MAAM;YACN,MAAO,CAAC,MAAM,OAAO,IAAI,CAAC,EAAE,EAAE,MAAM,GAAG,EAAG;gBACxC,MAAM,MAAM,eAAe;YAC7B;QACF;IACF;AACF;AASO,SAAS,YAAa,KAAK;IAChC,IAAI,MAAM;IAEV,wBAAwB,GACxB,OAAO;QACL,MAAM,MAAM,MAAM;YAChB,MAAM,MAAM,MAAM,QAAQ,CAAC,KAAK,MAAM,KAAK,GAAG,CAAC,QAAQ,MAAM,MAAM,GAAG;YACtE,OAAO;QACT;QAEA,MAAM,SAAS,MAAM,EAAE,OAAO,KAAK;YACjC,IAAI,SAAS,MAAM,MAAM,GAAG,KAAK;gBAC/B,MAAM,IAAI,MAAM;YAClB;YACA,MAAM,MAAM,MAAM,QAAQ,CAAC,KAAK,MAAM;YACtC,IAAI,MAAM;gBACR,OAAO;YACT;YACA,OAAO;QACT;QAEA,MAAM,MAAM;YACV,OAAO;QACT;QAEA,IAAI,OAAO;YACT,OAAO;QACT;IACF;AACF;AAUO,SAAS,YAAa,UAAU,WAAW,GAAZ;IACpC,IAAI,MAAM;IACV,IAAI,OAAO;IACX,IAAI,SAAS;IACb,IAAI,eAAe,IAAI,WAAW;IAElC,MAAM,OAAO,OAAO,mBAAmB,GAAG;QACxC,OAAO,aAAa,MAAM,GAAG;QAC7B,MAAM,OAAoD;YAAC,aAAa,QAAQ,CAAC;SAAQ;QACzF,MAAO,OAAO,OAAQ;YACpB,MAAM,QAAQ,MAAM;YACpB,IAAI,SAAS,MAAM;gBACjB;YACF;YACA,oBAAoB,GACpB,sEAAsE;YACtE,IAAI,OAAO,GAAG;gBACZ,oBAAoB,GACpB,2BAA2B;gBAC3B,IAAI,MAAM,MAAM,GAAG,MAAM;oBACvB,KAAK,IAAI,CAAC,MAAM,QAAQ,CAAC,CAAC;gBAC5B,EAAE,eAAe;YACnB,OAAO;gBACL,KAAK,IAAI,CAAC;YACZ;YACA,QAAQ,MAAM,MAAM;QACtB;QACA,eAAe,IAAI,WAAW,KAAK,MAAM,CAAC,CAAC,GAAG,IAAM,IAAI,EAAE,MAAM,EAAE;QAClE,IAAI,MAAM;QACV,KAAK,MAAM,KAAK,KAAM;YACpB,aAAa,GAAG,CAAC,GAAG;YACpB,OAAO,EAAE,MAAM;QACjB;QACA,SAAS;IACX;IAEA,wBAAwB,GACxB,OAAO;QACL,MAAM,MAAM,MAAM;YAChB,IAAI,aAAa,MAAM,GAAG,SAAS,QAAQ;gBACzC,MAAM,KAAK;YACb;YACA,OAAO,aAAa,QAAQ,CAAC,QAAQ,SAAS,KAAK,GAAG,CAAC,aAAa,MAAM,GAAG,QAAQ;QACvF;QAEA,MAAM,SAAS,MAAM,EAAE,OAAO,KAAK;YACjC,IAAI,aAAa,MAAM,GAAG,SAAS,QAAQ;gBACzC,MAAM,KAAK;YACb;YACA,IAAI,aAAa,MAAM,GAAG,SAAS,QAAQ;gBACzC,MAAM,IAAI,MAAM;YAClB;YACA,MAAM,MAAM,aAAa,QAAQ,CAAC,QAAQ,SAAS;YACnD,IAAI,MAAM;gBACR,OAAO;gBACP,UAAU;YACZ;YACA,OAAO;QACT;QAEA,MAAM,MAAM;YACV,OAAO;YACP,UAAU;QACZ;QAEA,IAAI,OAAO;YACT,OAAO;QACT;IACF;AACF;AAUO,SAAS,oBAAqB,aAAa;IAChD,MAAM,WAAW,aAAa,CAAC,OAAO,aAAa,CAAC;IAEpD,eAAe;QACb,MAAM,OAAO,MAAM,SAAS,IAAI;QAChC,IAAI,KAAK,IAAI,EAAE;YACb,OAAO;QACT;QACA,OAAO,KAAK,KAAK;IACnB;IAEA,OAAO,YAAY;AACrB;AAYO,SAAS,YAAa,MAAM,EAAE,SAAS;IAC5C,IAAI,YAAY;IAEhB,wBAAwB,GACxB,OAAO;QACL,MAAM,MAAM,MAAM;YAChB,IAAI,QAAQ,MAAM,OAAO,IAAI,CAAC;YAC9B,IAAI,MAAM,MAAM,GAAG,YAAY,WAAW;gBACxC,QAAQ,MAAM,QAAQ,CAAC,GAAG,YAAY;YACxC;YACA,OAAO;QACT;QAEA,MAAM,SAAS,MAAM,EAAE,OAAO,KAAK;YACjC,MAAM,QAAQ,MAAM,OAAO,OAAO,CAAC,QAAQ;YAC3C,IAAI,MAAM,MAAM,GAAG,YAAY,WAAW;gBACxC,MAAM,IAAI,MAAM;YAClB;YACA,IAAI,MAAM;gBACR,aAAa;YACf;YACA,OAAO;QACT;QAEA,MAAM,MAAM;YACV,aAAa;YACb,OAAO,IAAI,CAAC;QACd;QAEA,IAAI,OAAO;YACT,OAAO,OAAO,GAAG;QACnB;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 2591, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/car/src/indexer.js"],"sourcesContent":["import {\n  asyncIterableReader,\n  bytesReader,\n  createDecoder\n} from './decoder.js'\n\n/**\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('./api.js').Block} Block\n * @typedef {import('./api.js').RootsReader} RootsReader\n * @typedef {import('./api.js').BlockIndex} BlockIndex\n * @typedef {import('./coding.js').BytesReader} BytesReader\n */\n\n/**\n * Provides an iterator over all of the `Block`s in a CAR, returning their CIDs\n * and byte-location information. Implements an `AsyncIterable<BlockIndex>`.\n * Where a `BlockIndex` is a\n * `{ cid:CID, length:number, offset:number, blockLength:number, blockOffset:number }`.\n *\n * As an implementer of `AsyncIterable`, this class can be used directly in a\n * `for await (const blockIndex of iterator) {}` loop. Where the `iterator` is\n * constructed using {@link CarIndexer.fromBytes} or\n * {@link CarIndexer.fromIterable}.\n *\n * An iteration can only be performce _once_ per instantiation.\n *\n * `CarIndexer` also implements the `RootsReader` interface and provides\n * the {@link CarIndexer.getRoots `getRoots()`} method.\n *\n * Load this class with either\n * `import { CarIndexer } from '@ipld/car/indexer'`\n * (`const { CarIndexer } = require('@ipld/car/indexer')`). Or\n * `import { CarIndexer } from '@ipld/car'`\n * (`const { CarIndexer } = require('@ipld/car')`). The former will likely\n * result in smaller bundle sizes where this is important.\n *\n * @name CarIndexer\n * @class\n * @implements {RootsReader}\n * @implements {AsyncIterable<BlockIndex>}\n * @property {number} version The version number of the CAR referenced by this\n * reader (should be `1`).\n */\nexport class CarIndexer {\n  /**\n   * @param {number} version\n   * @param {CID[]} roots\n   * @param {AsyncGenerator<BlockIndex>} iterator\n   */\n  constructor (version, roots, iterator) {\n    this._version = version\n    this._roots = roots\n    this._iterator = iterator\n  }\n\n  get version () {\n    return this._version\n  }\n\n  /**\n   * Get the list of roots defined by the CAR referenced by this indexer. May be\n   * zero or more `CID`s.\n   *\n   * @function\n   * @memberof CarIndexer\n   * @instance\n   * @async\n   * @returns {Promise<CID[]>}\n   */\n  async getRoots () {\n    return this._roots\n  }\n\n  /**\n   * @returns {AsyncIterator<BlockIndex>}\n   */\n  [Symbol.asyncIterator] () {\n    return this._iterator\n  }\n\n  /**\n   * Instantiate a {@link CarIndexer} from a `Uint8Array` blob. Only the header\n   * is decoded initially, the remainder is processed and emitted via the\n   * iterator as it is consumed.\n   *\n   * @async\n   * @static\n   * @memberof CarIndexer\n   * @param {Uint8Array} bytes\n   * @returns {Promise<CarIndexer>}\n   */\n  static async fromBytes (bytes) {\n    if (!(bytes instanceof Uint8Array)) {\n      throw new TypeError('fromBytes() requires a Uint8Array')\n    }\n    return decodeIndexerComplete(bytesReader(bytes))\n  }\n\n  /**\n   * Instantiate a {@link CarIndexer} from a `AsyncIterable<Uint8Array>`,\n   * such as a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).\n   * is decoded initially, the remainder is processed and emitted via the\n   * iterator as it is consumed.\n   *\n   * @async\n   * @static\n   * @memberof CarIndexer\n   * @param {AsyncIterable<Uint8Array>} asyncIterable\n   * @returns {Promise<CarIndexer>}\n   */\n  static async fromIterable (asyncIterable) {\n    if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === 'function')) {\n      throw new TypeError('fromIterable() requires an async iterable')\n    }\n    return decodeIndexerComplete(asyncIterableReader(asyncIterable))\n  }\n}\n\n/**\n * @private\n * @param {BytesReader} reader\n * @returns {Promise<CarIndexer>}\n */\nasync function decodeIndexerComplete (reader) {\n  const decoder = createDecoder(reader)\n  const { version, roots } = await decoder.header()\n\n  return new CarIndexer(version, roots, decoder.blocksIndex())\n}\n"],"names":[],"mappings":";;;;AAAA;;AA4CO,MAAM;IACX;;;;GAIC,GACD,YAAa,OAAO,EAAE,KAAK,EAAE,QAAQ,CAAE;QACrC,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,SAAS,GAAG;IACnB;IAEA,IAAI,UAAW;QACb,OAAO,IAAI,CAAC,QAAQ;IACtB;IAEA;;;;;;;;;GASC,GACD,MAAM,WAAY;QAChB,OAAO,IAAI,CAAC,MAAM;IACpB;IAEA;;GAEC,GACD,CAAC,OAAO,aAAa,CAAC,GAAI;QACxB,OAAO,IAAI,CAAC,SAAS;IACvB;IAEA;;;;;;;;;;GAUC,GACD,aAAa,UAAW,KAAK,EAAE;QAC7B,IAAI,CAAC,CAAC,iBAAiB,UAAU,GAAG;YAClC,MAAM,IAAI,UAAU;QACtB;QACA,OAAO,sBAAsB,IAAA,iKAAW,EAAC;IAC3C;IAEA;;;;;;;;;;;GAWC,GACD,aAAa,aAAc,aAAa,EAAE;QACxC,IAAI,CAAC,iBAAiB,CAAC,CAAC,OAAO,aAAa,CAAC,OAAO,aAAa,CAAC,KAAK,UAAU,GAAG;YAClF,MAAM,IAAI,UAAU;QACtB;QACA,OAAO,sBAAsB,IAAA,yKAAmB,EAAC;IACnD;AACF;AAEA;;;;CAIC,GACD,eAAe,sBAAuB,MAAM;IAC1C,MAAM,UAAU,IAAA,mKAAa,EAAC;IAC9B,MAAM,EAAE,OAAO,EAAE,KAAK,EAAE,GAAG,MAAM,QAAQ,MAAM;IAE/C,OAAO,IAAI,WAAW,SAAS,OAAO,QAAQ,WAAW;AAC3D","ignoreList":[0]}},
    {"offset": {"line": 2674, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/car/src/iterator.js"],"sourcesContent":["import {\n  asyncIterableReader,\n  bytesReader,\n  createDecoder\n} from './decoder.js'\n\n/**\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('./api.js').Block} Block\n * @typedef {import('./api.js').RootsReader} RootsReader\n * @typedef {import('./coding.js').BytesReader} BytesReader\n */\n\n/**\n * @class\n * @implements {RootsReader}\n * @property {number} version The version number of the CAR referenced by this reader (should be `1`).\n */\nexport class CarIteratorBase {\n  /**\n   * @param {number} version\n   * @param {CID[]} roots\n   * @param {AsyncIterable<Block>|void} iterable\n   */\n  constructor (version, roots, iterable) {\n    this._version = version\n    this._roots = roots\n    this._iterable = iterable\n    this._decoded = false\n  }\n\n  get version () {\n    return this._version\n  }\n\n  /**\n   * @returns {Promise<CID[]>}\n   */\n  async getRoots () {\n    return this._roots\n  }\n}\n\n/**\n * Provides an iterator over all of the `Block`s in a CAR. Implements a\n * `BlockIterator` interface, or `AsyncIterable<Block>`. Where a `Block` is\n * a `{ cid:CID, bytes:Uint8Array }` pair.\n *\n * As an implementer of `AsyncIterable`, this class can be used directly in a\n * `for await (const block of iterator) {}` loop. Where the `iterator` is\n * constructed using {@link CarBlockiterator.fromBytes} or\n * {@link CarBlockiterator.fromIterable}.\n *\n * An iteration can only be performce _once_ per instantiation.\n *\n * `CarBlockIterator` also implements the `RootsReader` interface and provides\n * the {@link CarBlockiterator.getRoots `getRoots()`} method.\n *\n * Load this class with either\n * `import { CarBlockIterator } from '@ipld/car/iterator'`\n * (`const { CarBlockIterator } = require('@ipld/car/iterator')`). Or\n * `import { CarBlockIterator } from '@ipld/car'`\n * (`const { CarBlockIterator } = require('@ipld/car')`).\n *\n * @name CarBlockIterator\n * @class\n * @implements {RootsReader}\n * @implements {AsyncIterable<Block>}\n * @property {number} version The version number of the CAR referenced by this\n * iterator (should be `1`).\n */\nexport class CarBlockIterator extends CarIteratorBase {\n  // inherited method\n  /**\n   * Get the list of roots defined by the CAR referenced by this iterator. May be\n   * zero or more `CID`s.\n   *\n   * @function getRoots\n   * @memberof CarBlockIterator\n   * @instance\n   * @async\n   * @returns {Promise<CID[]>}\n   */\n\n  /**\n   * @returns {AsyncIterator<Block>}\n   */\n  [Symbol.asyncIterator] () {\n    if (this._decoded) {\n      throw new Error('Cannot decode more than once')\n    }\n    /* c8 ignore next 3 */\n    if (!this._iterable) {\n      throw new Error('Block iterable not found')\n    }\n    this._decoded = true\n    return this._iterable[Symbol.asyncIterator]()\n  }\n\n  /**\n   * Instantiate a {@link CarBlockIterator} from a `Uint8Array` blob. Rather\n   * than decoding the entire byte array prior to returning the iterator, as in\n   * {@link CarReader.fromBytes}, only the header is decoded and the remainder\n   * of the CAR is parsed as the `Block`s as yielded.\n   *\n   * @async\n   * @static\n   * @memberof CarBlockIterator\n   * @param {Uint8Array} bytes\n   * @returns {Promise<CarBlockIterator>}\n   */\n  static async fromBytes (bytes) {\n    const { version, roots, iterator } = await fromBytes(bytes)\n    return new CarBlockIterator(version, roots, iterator)\n  }\n\n  /**\n   * Instantiate a {@link CarBlockIterator} from a `AsyncIterable<Uint8Array>`,\n   * such as a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).\n   * Rather than decoding the entire byte array prior to returning the iterator,\n   * as in {@link CarReader.fromIterable}, only the header is decoded and the\n   * remainder of the CAR is parsed as the `Block`s as yielded.\n   *\n   * @async\n   * @static\n   * @param {AsyncIterable<Uint8Array>} asyncIterable\n   * @returns {Promise<CarBlockIterator>}\n   */\n  static async fromIterable (asyncIterable) {\n    const { version, roots, iterator } = await fromIterable(asyncIterable)\n    return new CarBlockIterator(version, roots, iterator)\n  }\n}\n\n/**\n * Provides an iterator over all of the `CID`s in a CAR. Implements a\n * `CIDIterator` interface, or `AsyncIterable<CID>`. Similar to\n * {@link CarBlockIterator} but only yields the CIDs in the CAR.\n *\n * As an implementer of `AsyncIterable`, this class can be used directly in a\n * `for await (const cid of iterator) {}` loop. Where the `iterator` is\n * constructed using {@link CarCIDiterator.fromBytes} or\n * {@link CarCIDiterator.fromIterable}.\n *\n * An iteration can only be performce _once_ per instantiation.\n *\n * `CarCIDIterator` also implements the `RootsReader` interface and provides\n * the {@link CarCIDiterator.getRoots `getRoots()`} method.\n *\n * Load this class with either\n * `import { CarCIDIterator } from '@ipld/car/iterator'`\n * (`const { CarCIDIterator } = require('@ipld/car/iterator')`). Or\n * `import { CarCIDIterator } from '@ipld/car'`\n * (`const { CarCIDIterator } = require('@ipld/car')`).\n *\n * @name CarCIDIterator\n * @class\n * @implements {RootsReader}\n * @implements {AsyncIterable<CID>}\n * @property {number} version The version number of the CAR referenced by this\n * iterator (should be `1`).\n */\nexport class CarCIDIterator extends CarIteratorBase {\n  // inherited method\n  /**\n   * Get the list of roots defined by the CAR referenced by this iterator. May be\n   * zero or more `CID`s.\n   *\n   * @function getRoots\n   * @memberof CarCIDIterator\n   * @instance\n   * @async\n   * @returns {Promise<CID[]>}\n   */\n\n  /**\n   * @returns {AsyncIterator<CID>}\n   */\n  [Symbol.asyncIterator] () {\n    if (this._decoded) {\n      throw new Error('Cannot decode more than once')\n    }\n    /* c8 ignore next 3 */\n    if (!this._iterable) {\n      throw new Error('Block iterable not found')\n    }\n    this._decoded = true\n    const iterable = this._iterable[Symbol.asyncIterator]()\n    return {\n      async next () {\n        const next = await iterable.next()\n        if (next.done) {\n          return next\n        }\n        return { done: false, value: next.value.cid }\n      }\n    }\n  }\n\n  /**\n   * Instantiate a {@link CarCIDIterator} from a `Uint8Array` blob. Rather\n   * than decoding the entire byte array prior to returning the iterator, as in\n   * {@link CarReader.fromBytes}, only the header is decoded and the remainder\n   * of the CAR is parsed as the `CID`s as yielded.\n   *\n   * @async\n   * @static\n   * @memberof CarCIDIterator\n   * @param {Uint8Array} bytes\n   * @returns {Promise<CarCIDIterator>}\n   */\n  static async fromBytes (bytes) {\n    const { version, roots, iterator } = await fromBytes(bytes)\n    return new CarCIDIterator(version, roots, iterator)\n  }\n\n  /**\n   * Instantiate a {@link CarCIDIterator} from a `AsyncIterable<Uint8Array>`,\n   * such as a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).\n   * Rather than decoding the entire byte array prior to returning the iterator,\n   * as in {@link CarReader.fromIterable}, only the header is decoded and the\n   * remainder of the CAR is parsed as the `CID`s as yielded.\n   *\n   * @async\n   * @static\n   * @memberof CarCIDIterator\n   * @param {AsyncIterable<Uint8Array>} asyncIterable\n   * @returns {Promise<CarCIDIterator>}\n   */\n  static async fromIterable (asyncIterable) {\n    const { version, roots, iterator } = await fromIterable(asyncIterable)\n    return new CarCIDIterator(version, roots, iterator)\n  }\n}\n\n/**\n * @param {Uint8Array} bytes\n * @returns {Promise<{ version:number, roots:CID[], iterator:AsyncIterable<Block>}>}\n */\nasync function fromBytes (bytes) {\n  if (!(bytes instanceof Uint8Array)) {\n    throw new TypeError('fromBytes() requires a Uint8Array')\n  }\n  return decodeIterator(bytesReader(bytes))\n}\n\n/**\n * @param {AsyncIterable<Uint8Array>} asyncIterable\n * @returns {Promise<{ version:number, roots:CID[], iterator:AsyncIterable<Block>}>}\n */\nasync function fromIterable (asyncIterable) {\n  if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === 'function')) {\n    throw new TypeError('fromIterable() requires an async iterable')\n  }\n  return decodeIterator(asyncIterableReader(asyncIterable))\n}\n\n/**\n * @private\n * @param {BytesReader} reader\n * @returns {Promise<{ version:number, roots:CID[], iterator:AsyncIterable<Block>}>}\n */\nasync function decodeIterator (reader) {\n  const decoder = createDecoder(reader)\n  const { version, roots } = await decoder.header()\n  return { version, roots, iterator: decoder.blocks() }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2860, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/car/src/reader-browser.js"],"sourcesContent":["import { asyncIterableReader, bytesReader, createDecoder } from './decoder.js'\n\n/**\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('./api.js').Block} Block\n * @typedef {import('./api.js').CarReader} CarReaderIface\n * @typedef {import('./coding.js').BytesReader} BytesReader\n * @typedef {import('./coding.js').CarHeader} CarHeader\n * @typedef {import('./coding.js').CarV2Header} CarV2Header\n */\n\n/**\n * Provides blockstore-like access to a CAR.\n *\n * Implements the `RootsReader` interface:\n * {@link CarReader.getRoots `getRoots()`}. And the `BlockReader` interface:\n * {@link CarReader.get `get()`}, {@link CarReader.has `has()`},\n * {@link CarReader.blocks `blocks()`} (defined as a `BlockIterator`) and\n * {@link CarReader.cids `cids()`} (defined as a `CIDIterator`).\n *\n * Load this class with either `import { CarReader } from '@ipld/car/reader'`\n * (`const { CarReader } = require('@ipld/car/reader')`). Or\n * `import { CarReader } from '@ipld/car'` (`const { CarReader } = require('@ipld/car')`).\n * The former will likely result in smaller bundle sizes where this is\n * important.\n *\n * @name CarReader\n * @class\n * @implements {CarReaderIface}\n * @property {number} version The version number of the CAR referenced by this\n * reader (should be `1` or `2`).\n */\nexport class CarReader {\n  /**\n   * @constructs CarReader\n   * @param {CarHeader|CarV2Header} header\n   * @param {Block[]} blocks\n   */\n  constructor (header, blocks) {\n    this._header = header\n    this._blocks = blocks\n    this._keys = blocks.map((b) => b.cid.toString())\n  }\n\n  /**\n   * @property\n   * @memberof CarReader\n   * @instance\n   */\n  get version () {\n    return this._header.version\n  }\n\n  /**\n   * Get the list of roots defined by the CAR referenced by this reader. May be\n   * zero or more `CID`s.\n   *\n   * @function\n   * @memberof CarReader\n   * @instance\n   * @async\n   * @returns {Promise<CID[]>}\n   */\n  async getRoots () {\n    return this._header.roots\n  }\n\n  /**\n   * Check whether a given `CID` exists within the CAR referenced by this\n   * reader.\n   *\n   * @function\n   * @memberof CarReader\n   * @instance\n   * @async\n   * @param {CID} key\n   * @returns {Promise<boolean>}\n   */\n  async has (key) {\n    return this._keys.indexOf(key.toString()) > -1\n  }\n\n  /**\n   * Fetch a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) from the CAR\n   * referenced by this reader matching the provided `CID`. In the case where\n   * the provided `CID` doesn't exist within the CAR, `undefined` will be\n   * returned.\n   *\n   * @function\n   * @memberof CarReader\n   * @instance\n   * @async\n   * @param {CID} key\n   * @returns {Promise<Block | undefined>}\n   */\n  async get (key) {\n    const index = this._keys.indexOf(key.toString())\n    return index > -1 ? this._blocks[index] : undefined\n  }\n\n  /**\n   * Returns a `BlockIterator` (`AsyncIterable<Block>`) that iterates over all\n   * of the `Block`s (`{ cid:CID, bytes:Uint8Array }` pairs) contained within\n   * the CAR referenced by this reader.\n   *\n   * @function\n   * @memberof CarReader\n   * @instance\n   * @async\n   * @generator\n   * @returns {AsyncGenerator<Block>}\n   */\n  async * blocks () {\n    for (const block of this._blocks) {\n      yield block\n    }\n  }\n\n  /**\n   * Returns a `CIDIterator` (`AsyncIterable<CID>`) that iterates over all of\n   * the `CID`s contained within the CAR referenced by this reader.\n   *\n   * @function\n   * @memberof CarReader\n   * @instance\n   * @async\n   * @generator\n   * @returns {AsyncGenerator<CID>}\n   */\n  async * cids () {\n    for (const block of this._blocks) {\n      yield block.cid\n    }\n  }\n\n  /**\n   * Instantiate a {@link CarReader} from a `Uint8Array` blob. This performs a\n   * decode fully in memory and maintains the decoded state in memory for full\n   * access to the data via the `CarReader` API.\n   *\n   * @async\n   * @static\n   * @memberof CarReader\n   * @param {Uint8Array} bytes\n   * @returns {Promise<CarReader>}\n   */\n  static async fromBytes (bytes) {\n    if (!(bytes instanceof Uint8Array)) {\n      throw new TypeError('fromBytes() requires a Uint8Array')\n    }\n    return decodeReaderComplete(bytesReader(bytes))\n  }\n\n  /**\n   * Instantiate a {@link CarReader} from a `AsyncIterable<Uint8Array>`, such as\n   * a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).\n   * This performs a decode fully in memory and maintains the decoded state in\n   * memory for full access to the data via the `CarReader` API.\n   *\n   * Care should be taken for large archives; this API may not be appropriate\n   * where memory is a concern or the archive is potentially larger than the\n   * amount of memory that the runtime can handle.\n   *\n   * @async\n   * @static\n   * @memberof CarReader\n   * @param {AsyncIterable<Uint8Array>} asyncIterable\n   * @returns {Promise<CarReader>}\n   */\n  static async fromIterable (asyncIterable) {\n    if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === 'function')) {\n      throw new TypeError('fromIterable() requires an async iterable')\n    }\n    return decodeReaderComplete(asyncIterableReader(asyncIterable))\n  }\n}\n\n/**\n * @private\n * @param {BytesReader} reader\n * @returns {Promise<CarReader>}\n */\nexport async function decodeReaderComplete (reader) {\n  const decoder = createDecoder(reader)\n  const header = await decoder.header()\n  const blocks = []\n  for await (const block of decoder.blocks()) {\n    blocks.push(block)\n  }\n\n  return new CarReader(header, blocks)\n}\n\nexport const __browser = true\n"],"names":[],"mappings":";;;;;;;;AAAA;;AAgCO,MAAM;IACX;;;;GAIC,GACD,YAAa,MAAM,EAAE,MAAM,CAAE;QAC3B,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,OAAO,GAAG;QACf,IAAI,CAAC,KAAK,GAAG,OAAO,GAAG,CAAC,CAAC,IAAM,EAAE,GAAG,CAAC,QAAQ;IAC/C;IAEA;;;;GAIC,GACD,IAAI,UAAW;QACb,OAAO,IAAI,CAAC,OAAO,CAAC,OAAO;IAC7B;IAEA;;;;;;;;;GASC,GACD,MAAM,WAAY;QAChB,OAAO,IAAI,CAAC,OAAO,CAAC,KAAK;IAC3B;IAEA;;;;;;;;;;GAUC,GACD,MAAM,IAAK,GAAG,EAAE;QACd,OAAO,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,QAAQ,MAAM,CAAC;IAC/C;IAEA;;;;;;;;;;;;GAYC,GACD,MAAM,IAAK,GAAG,EAAE;QACd,MAAM,QAAQ,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,QAAQ;QAC7C,OAAO,QAAQ,CAAC,IAAI,IAAI,CAAC,OAAO,CAAC,MAAM,GAAG;IAC5C;IAEA;;;;;;;;;;;GAWC,GACD,OAAQ,SAAU;QAChB,KAAK,MAAM,SAAS,IAAI,CAAC,OAAO,CAAE;YAChC,MAAM;QACR;IACF;IAEA;;;;;;;;;;GAUC,GACD,OAAQ,OAAQ;QACd,KAAK,MAAM,SAAS,IAAI,CAAC,OAAO,CAAE;YAChC,MAAM,MAAM,GAAG;QACjB;IACF;IAEA;;;;;;;;;;GAUC,GACD,aAAa,UAAW,KAAK,EAAE;QAC7B,IAAI,CAAC,CAAC,iBAAiB,UAAU,GAAG;YAClC,MAAM,IAAI,UAAU;QACtB;QACA,OAAO,qBAAqB,IAAA,iKAAW,EAAC;IAC1C;IAEA;;;;;;;;;;;;;;;GAeC,GACD,aAAa,aAAc,aAAa,EAAE;QACxC,IAAI,CAAC,iBAAiB,CAAC,CAAC,OAAO,aAAa,CAAC,OAAO,aAAa,CAAC,KAAK,UAAU,GAAG;YAClF,MAAM,IAAI,UAAU;QACtB;QACA,OAAO,qBAAqB,IAAA,yKAAmB,EAAC;IAClD;AACF;AAOO,eAAe,qBAAsB,MAAM;IAChD,MAAM,UAAU,IAAA,mKAAa,EAAC;IAC9B,MAAM,SAAS,MAAM,QAAQ,MAAM;IACnC,MAAM,SAAS,EAAE;IACjB,WAAW,MAAM,SAAS,QAAQ,MAAM,GAAI;QAC1C,OAAO,IAAI,CAAC;IACd;IAEA,OAAO,IAAI,UAAU,QAAQ;AAC/B;AAEO,MAAM,YAAY","ignoreList":[0]}},
    {"offset": {"line": 3011, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/car/src/encoder.js"],"sourcesContent":["import { encode as dagCborEncode } from '@ipld/dag-cbor'\nimport varint from 'varint'\n\n/**\n * @typedef {import('multiformats').CID} CID\n * @typedef {import('./api.js').Block} Block\n * @typedef {import('./coding.js').CarEncoder} CarEncoder\n * @typedef {import('./coding.js').IteratorChannel_Writer<Uint8Array>} IteratorChannel_Writer\n */\n\nconst CAR_V1_VERSION = 1\n\n/**\n * Create a header from an array of roots.\n *\n * @param {CID[]} roots\n * @returns {Uint8Array}\n */\nexport function createHeader (roots) {\n  const headerBytes = dagCborEncode({ version: CAR_V1_VERSION, roots })\n  const varintBytes = varint.encode(headerBytes.length)\n  const header = new Uint8Array(varintBytes.length + headerBytes.length)\n  header.set(varintBytes, 0)\n  header.set(headerBytes, varintBytes.length)\n  return header\n}\n\n/**\n * @param {IteratorChannel_Writer} writer\n * @returns {CarEncoder}\n */\nfunction createEncoder (writer) {\n  // none of this is wrapped in a mutex, that needs to happen above this to\n  // avoid overwrites\n\n  return {\n    /**\n     * @param {CID[]} roots\n     * @returns {Promise<void>}\n     */\n    async setRoots (roots) {\n      const bytes = createHeader(roots)\n      await writer.write(bytes)\n    },\n\n    /**\n     * @param {Block} block\n     * @returns {Promise<void>}\n     */\n    async writeBlock (block) {\n      const { cid, bytes } = block\n      await writer.write(new Uint8Array(varint.encode(cid.bytes.length + bytes.length)))\n      await writer.write(cid.bytes)\n      if (bytes.length) {\n        // zero-length blocks are valid, but it'd be safer if we didn't write them\n        await writer.write(bytes)\n      }\n    },\n\n    /**\n     * @returns {Promise<void>}\n     */\n    async close () {\n      await writer.end()\n    },\n\n    /**\n     * @returns {number}\n     */\n    version () {\n      return CAR_V1_VERSION\n    }\n  }\n}\n\nexport { createEncoder }\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAEA;;;;;CAKC,GAED,MAAM,iBAAiB;AAQhB,SAAS,aAAc,KAAK;IACjC,MAAM,cAAc,IAAA,kKAAa,EAAC;QAAE,SAAS;QAAgB;IAAM;IACnE,MAAM,cAAc,6IAAM,CAAC,MAAM,CAAC,YAAY,MAAM;IACpD,MAAM,SAAS,IAAI,WAAW,YAAY,MAAM,GAAG,YAAY,MAAM;IACrE,OAAO,GAAG,CAAC,aAAa;IACxB,OAAO,GAAG,CAAC,aAAa,YAAY,MAAM;IAC1C,OAAO;AACT;AAEA;;;CAGC,GACD,SAAS,cAAe,MAAM;IAC5B,yEAAyE;IACzE,mBAAmB;IAEnB,OAAO;QACL;;;KAGC,GACD,MAAM,UAAU,KAAK;YACnB,MAAM,QAAQ,aAAa;YAC3B,MAAM,OAAO,KAAK,CAAC;QACrB;QAEA;;;KAGC,GACD,MAAM,YAAY,KAAK;YACrB,MAAM,EAAE,GAAG,EAAE,KAAK,EAAE,GAAG;YACvB,MAAM,OAAO,KAAK,CAAC,IAAI,WAAW,6IAAM,CAAC,MAAM,CAAC,IAAI,KAAK,CAAC,MAAM,GAAG,MAAM,MAAM;YAC/E,MAAM,OAAO,KAAK,CAAC,IAAI,KAAK;YAC5B,IAAI,MAAM,MAAM,EAAE;gBAChB,0EAA0E;gBAC1E,MAAM,OAAO,KAAK,CAAC;YACrB;QACF;QAEA;;KAEC,GACD,MAAM;YACJ,MAAM,OAAO,GAAG;QAClB;QAEA;;KAEC,GACD;YACE,OAAO;QACT;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 3081, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/car/src/iterator-channel.js"],"sourcesContent":["/**\n * @template {any} T\n * @typedef {import('./coding.js').IteratorChannel<T>} IteratorChannel\n */\n\nfunction noop () {}\n\n/**\n * @template {any} T\n * @returns {IteratorChannel<T>}\n */\nexport function create () {\n  /** @type {T[]} */\n  const chunkQueue = []\n  /** @type {Promise<void> | null} */\n  let drainer = null\n  let drainerResolver = noop\n  let ended = false\n  /** @type {Promise<IteratorResult<T>> | null} */\n  let outWait = null\n  let outWaitResolver = noop\n\n  const makeDrainer = () => {\n    if (!drainer) {\n      drainer = new Promise((resolve) => {\n        drainerResolver = () => {\n          drainer = null\n          drainerResolver = noop\n          resolve()\n        }\n      })\n    }\n    return drainer\n  }\n\n  /**\n   * @returns {IteratorChannel<T>}\n   */\n  const writer = {\n    /**\n     * @param {T} chunk\n     * @returns {Promise<void>}\n     */\n    write (chunk) {\n      chunkQueue.push(chunk)\n      const drainer = makeDrainer()\n      outWaitResolver()\n      return drainer\n    },\n\n    async end () {\n      ended = true\n      const drainer = makeDrainer()\n      outWaitResolver()\n      await drainer\n    }\n  }\n\n  /** @type {AsyncIterator<T>} */\n  const iterator = {\n    /** @returns {Promise<IteratorResult<T>>} */\n    async next () {\n      const chunk = chunkQueue.shift()\n      if (chunk) {\n        if (chunkQueue.length === 0) {\n          drainerResolver()\n        }\n        return { done: false, value: chunk }\n      }\n\n      if (ended) {\n        drainerResolver()\n        return { done: true, value: undefined }\n      }\n\n      if (!outWait) {\n        outWait = new Promise((resolve) => {\n          outWaitResolver = () => {\n            outWait = null\n            outWaitResolver = noop\n            return resolve(iterator.next())\n          }\n        })\n      }\n\n      return outWait\n    }\n  }\n\n  return { writer, iterator }\n}\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;AAED,SAAS,QAAS;AAMX,SAAS;IACd,gBAAgB,GAChB,MAAM,aAAa,EAAE;IACrB,iCAAiC,GACjC,IAAI,UAAU;IACd,IAAI,kBAAkB;IACtB,IAAI,QAAQ;IACZ,8CAA8C,GAC9C,IAAI,UAAU;IACd,IAAI,kBAAkB;IAEtB,MAAM,cAAc;QAClB,IAAI,CAAC,SAAS;YACZ,UAAU,IAAI,QAAQ,CAAC;gBACrB,kBAAkB;oBAChB,UAAU;oBACV,kBAAkB;oBAClB;gBACF;YACF;QACF;QACA,OAAO;IACT;IAEA;;GAEC,GACD,MAAM,SAAS;QACb;;;KAGC,GACD,OAAO,KAAK;YACV,WAAW,IAAI,CAAC;YAChB,MAAM,UAAU;YAChB;YACA,OAAO;QACT;QAEA,MAAM;YACJ,QAAQ;YACR,MAAM,UAAU;YAChB;YACA,MAAM;QACR;IACF;IAEA,6BAA6B,GAC7B,MAAM,WAAW;QACf,0CAA0C,GAC1C,MAAM;YACJ,MAAM,QAAQ,WAAW,KAAK;YAC9B,IAAI,OAAO;gBACT,IAAI,WAAW,MAAM,KAAK,GAAG;oBAC3B;gBACF;gBACA,OAAO;oBAAE,MAAM;oBAAO,OAAO;gBAAM;YACrC;YAEA,IAAI,OAAO;gBACT;gBACA,OAAO;oBAAE,MAAM;oBAAM,OAAO;gBAAU;YACxC;YAEA,IAAI,CAAC,SAAS;gBACZ,UAAU,IAAI,QAAQ,CAAC;oBACrB,kBAAkB;wBAChB,UAAU;wBACV,kBAAkB;wBAClB,OAAO,QAAQ,SAAS,IAAI;oBAC9B;gBACF;YACF;YAEA,OAAO;QACT;IACF;IAEA,OAAO;QAAE;QAAQ;IAAS;AAC5B","ignoreList":[0]}},
    {"offset": {"line": 3167, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/car/src/writer-browser.js"],"sourcesContent":["import { CID } from 'multiformats/cid'\nimport { bytesReader, readHeader } from './decoder.js'\nimport { createEncoder, createHeader } from './encoder.js'\nimport { create as iteratorChannel } from './iterator-channel.js'\n\n/**\n * @typedef {import('./api.js').Block} Block\n * @typedef {import('./api.js').BlockWriter} BlockWriter\n * @typedef {import('./api.js').WriterChannel} WriterChannel\n * @typedef {import('./coding.js').CarEncoder} CarEncoder\n * @typedef {import('./coding.js').IteratorChannel<Uint8Array>} IteratorChannel\n */\n\n/**\n * Provides a writer interface for the creation of CAR files.\n *\n * Creation of a `CarWriter` involves the instatiation of an input / output pair\n * in the form of a `WriterChannel`, which is a\n * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair. These two\n * components form what can be thought of as a stream-like interface. The\n * `writer` component (an instantiated `CarWriter`), has methods to\n * {@link CarWriter.put `put()`} new blocks and {@link CarWriter.put `close()`}\n * the writing operation (finalising the CAR archive). The `out` component is\n * an `AsyncIterable` that yields the bytes of the archive. This can be\n * redirected to a file or other sink. In Node.js, you can use the\n * [`Readable.from()`](https://nodejs.org/api/stream.html#stream_stream_readable_from_iterable_options)\n * API to convert this to a standard Node.js stream, or it can be directly fed\n * to a\n * [`stream.pipeline()`](https://nodejs.org/api/stream.html#stream_stream_pipeline_source_transforms_destination_callback).\n *\n * The channel will provide a form of backpressure. The `Promise` from a\n * `write()` won't resolve until the resulting data is drained from the `out`\n * iterable.\n *\n * It is also possible to ignore the `Promise` from `write()` calls and allow\n * the generated data to queue in memory. This should be avoided for large CAR\n * archives of course due to the memory costs and potential for memory overflow.\n *\n * Load this class with either\n * `import { CarWriter } from '@ipld/car/writer'`\n * (`const { CarWriter } = require('@ipld/car/writer')`). Or\n * `import { CarWriter } from '@ipld/car'`\n * (`const { CarWriter } = require('@ipld/car')`). The former will likely\n * result in smaller bundle sizes where this is important.\n *\n * @name CarWriter\n * @class\n * @implements {BlockWriter}\n */\nexport class CarWriter {\n  /**\n   * @param {CID[]} roots\n   * @param {CarEncoder} encoder\n   */\n  constructor (roots, encoder) {\n    this._encoder = encoder\n    /** @type {Promise<void>} */\n    this._mutex = encoder.setRoots(roots)\n    this._ended = false\n  }\n\n  /**\n   * Write a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) to the archive.\n   *\n   * @function\n   * @memberof CarWriter\n   * @instance\n   * @async\n   * @param {Block} block - A `{ cid:CID, bytes:Uint8Array }` pair.\n   * @returns {Promise<void>} The returned promise will only resolve once the\n   * bytes this block generates are written to the `out` iterable.\n   */\n  async put (block) {\n    if (!(block.bytes instanceof Uint8Array) || !block.cid) {\n      throw new TypeError('Can only write {cid, bytes} objects')\n    }\n    if (this._ended) {\n      throw new Error('Already closed')\n    }\n    const cid = CID.asCID(block.cid)\n    if (!cid) {\n      throw new TypeError('Can only write {cid, bytes} objects')\n    }\n    this._mutex = this._mutex.then(() => this._encoder.writeBlock({ cid, bytes: block.bytes }))\n    return this._mutex\n  }\n\n  /**\n   * Finalise the CAR archive and signal that the `out` iterable should end once\n   * any remaining bytes are written.\n   *\n   * @function\n   * @memberof CarWriter\n   * @instance\n   * @async\n   * @returns {Promise<void>}\n   */\n  async close () {\n    if (this._ended) {\n      throw new Error('Already closed')\n    }\n    await this._mutex\n    this._ended = true\n    return this._encoder.close()\n  }\n\n  /**\n   * Returns the version number of the CAR file being written\n   *\n   * @returns {number}\n   */\n  version () {\n    return this._encoder.version()\n  }\n\n  /**\n   * Create a new CAR writer \"channel\" which consists of a\n   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair.\n   *\n   * @async\n   * @static\n   * @memberof CarWriter\n   * @param {CID[] | CID | void} roots\n   * @returns {WriterChannel} The channel takes the form of\n   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }`.\n   */\n  static create (roots) {\n    roots = toRoots(roots)\n    const { encoder, iterator } = encodeWriter()\n    const writer = new CarWriter(roots, encoder)\n    const out = new CarWriterOut(iterator)\n    return { writer, out }\n  }\n\n  /**\n   * Create a new CAR appender \"channel\" which consists of a\n   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair.\n   * This appender does not consider roots and does not produce a CAR header.\n   * It is designed to append blocks to an _existing_ CAR archive. It is\n   * expected that `out` will be concatenated onto the end of an existing\n   * archive that already has a properly formatted header.\n   *\n   * @async\n   * @static\n   * @memberof CarWriter\n   * @returns {WriterChannel} The channel takes the form of\n   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }`.\n   */\n  static createAppender () {\n    const { encoder, iterator } = encodeWriter()\n    encoder.setRoots = () => Promise.resolve()\n    const writer = new CarWriter([], encoder)\n    const out = new CarWriterOut(iterator)\n    return { writer, out }\n  }\n\n  /**\n   * Update the list of roots in the header of an existing CAR as represented\n   * in a Uint8Array.\n   *\n   * This operation is an _overwrite_, the total length of the CAR will not be\n   * modified. A rejection will occur if the new header will not be the same\n   * length as the existing header, in which case the CAR will not be modified.\n   * It is the responsibility of the user to ensure that the roots being\n   * replaced encode as the same length as the new roots.\n   *\n   * The byte array passed in an argument will be modified and also returned\n   * upon successful modification.\n   *\n   * @async\n   * @static\n   * @memberof CarWriter\n   * @param {Uint8Array} bytes\n   * @param {CID[]} roots - A new list of roots to replace the existing list in\n   * the CAR header. The new header must take up the same number of bytes as the\n   * existing header, so the roots should collectively be the same byte length\n   * as the existing roots.\n   * @returns {Promise<Uint8Array>}\n   */\n  static async updateRootsInBytes (bytes, roots) {\n    const reader = bytesReader(bytes)\n    await readHeader(reader)\n    const newHeader = createHeader(roots)\n    if (Number(reader.pos) !== newHeader.length) {\n      throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${reader.pos} bytes, new header is ${newHeader.length} bytes)`)\n    }\n    bytes.set(newHeader, 0)\n    return bytes\n  }\n}\n\n/**\n * @class\n * @implements {AsyncIterable<Uint8Array>}\n */\nexport class CarWriterOut {\n  /**\n   * @param {AsyncIterator<Uint8Array>} iterator\n   */\n  constructor (iterator) {\n    this._iterator = iterator\n  }\n\n  [Symbol.asyncIterator] () {\n    if (this._iterating) {\n      throw new Error('Multiple iterator not supported')\n    }\n    this._iterating = true\n    return this._iterator\n  }\n}\n\nfunction encodeWriter () {\n  /** @type {IteratorChannel} */\n  const iw = iteratorChannel()\n  const { writer, iterator } = iw\n  const encoder = createEncoder(writer)\n  return { encoder, iterator }\n}\n\n/**\n * @private\n * @param {CID[] | CID | void} roots\n * @returns {CID[]}\n */\nfunction toRoots (roots) {\n  if (roots === undefined) {\n    return []\n  }\n\n  if (!Array.isArray(roots)) {\n    const cid = CID.asCID(roots)\n    if (!cid) {\n      throw new TypeError('roots must be a single CID or an array of CIDs')\n    }\n    return [cid]\n  }\n\n  const _roots = []\n  for (const root of roots) {\n    const _root = CID.asCID(root)\n    if (!_root) {\n      throw new TypeError('roots must be a single CID or an array of CIDs')\n    }\n    _roots.push(_root)\n  }\n  return _roots\n}\n\nexport const __browser = true\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3374, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ipld/car/src/index-browser.js"],"sourcesContent":["import { CarBufferReader } from './buffer-reader.js'\nimport * as CarBufferWriter from './buffer-writer.js'\nimport { CarIndexedReader } from './indexed-reader-browser.js'\nimport { CarIndexer } from './indexer.js'\nimport { CarBlockIterator, CarCIDIterator } from './iterator.js'\nimport { CarReader } from './reader-browser.js'\nimport { CarWriter } from './writer-browser.js'\n\nexport {\n  CarReader,\n  CarIndexer,\n  CarBlockIterator,\n  CarCIDIterator,\n  CarWriter,\n  CarIndexedReader,\n  CarBufferReader,\n  CarBufferWriter\n}\n"],"names":[],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA","ignoreList":[0]}}]
}