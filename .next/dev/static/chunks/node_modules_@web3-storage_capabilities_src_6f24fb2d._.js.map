{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40web3-storage/capabilities/src/utils.js"],"sourcesContent":["import { DID, Schema, fail, ok } from '@ucanto/validator'\n// eslint-disable-next-line no-unused-vars\nimport * as Types from '@ucanto/interface'\n\nimport { equals } from 'uint8arrays/equals'\n\n// e.g. did:web:web3.storage or did:web:staging.web3.storage\nexport const ProviderDID = DID.match({ method: 'web' })\n\nexport const SpaceDID = DID.match({ method: 'key' })\n\nexport const AccountDID = DID.match({ method: 'mailto' })\n\nexport const Await = Schema.struct({\n  'ucan/await': Schema.tuple([Schema.string(), Schema.link()]),\n})\n\n/**\n * Check URI can be delegated.\n *\n * @param {string} [child]\n * @param {string} [parent]\n */\nexport function canDelegateURI(child, parent) {\n  if (parent === undefined) {\n    return ok({})\n  }\n  if (child !== undefined && parent.endsWith('*')) {\n    return child.startsWith(parent.slice(0, -1))\n      ? ok({})\n      : fail(`${child} does not match ${parent}`)\n  }\n\n  return child === parent\n    ? ok({})\n    : fail(`${child} is different from ${parent}`)\n}\n\n/**\n * Checks that `with` on claimed capability is the same as `with`\n * in delegated capability. Note this will ignore `can` field.\n *\n * @param {Types.ParsedCapability} child\n * @param {Types.ParsedCapability} parent\n */\nexport function equalWith(child, parent) {\n  return child.with === parent.with\n    ? ok({})\n    : fail(`Can not derive ${child.can} with ${child.with} from ${parent.with}`)\n}\n\n/**\n * @param {unknown} child\n * @param {unknown} parent\n * @param {string} constraint\n */\nexport function equal(child, parent, constraint) {\n  if (parent === undefined || parent === '*') {\n    return ok({})\n  } else if (String(child) === String(parent)) {\n    return ok({})\n  } else {\n    return fail(\n      `Constrain violation: ${child} violates imposed ${constraint} constraint ${parent}`\n    )\n  }\n}\n\n/**\n * @template {Types.ParsedCapability<\"store/add\"|\"store/get\"|\"store/remove\", Types.URI<'did:'>, {link?: Types.Link<unknown, number, number, 0|1>}>} T\n * @param {T} claimed\n * @param {T} delegated\n * @returns {Types.Result<{}, Types.Failure>}\n */\nexport const equalLink = (claimed, delegated) => {\n  if (claimed.with !== delegated.with) {\n    return fail(\n      `Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`\n    )\n  } else if (\n    delegated.nb.link &&\n    `${delegated.nb.link}` !== `${claimed.nb.link}`\n  ) {\n    return fail(\n      `Link ${claimed.nb.link ? `${claimed.nb.link}` : ''} violates imposed ${\n        delegated.nb.link\n      } constraint.`\n    )\n  } else {\n    return ok({})\n  }\n}\n\n/**\n * @template {Types.ParsedCapability<\"space/blob/add\"|\"space/blob/remove\"|\"web3.storage/blob/allocate\"|\"web3.storage/blob/accept\", Types.URI<'did:'>, {blob: { digest: Uint8Array, size: number }}>} T\n * @param {T} claimed\n * @param {T} delegated\n * @returns {Types.Result<{}, Types.Failure>}\n */\nexport const equalBlob = (claimed, delegated) => {\n  if (claimed.with !== delegated.with) {\n    return fail(\n      `Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`\n    )\n  } else if (\n    delegated.nb.blob.digest &&\n    !equals(delegated.nb.blob.digest, claimed.nb.blob.digest)\n  ) {\n    return fail(\n      `Link ${\n        claimed.nb.blob.digest ? `${claimed.nb.blob.digest}` : ''\n      } violates imposed ${delegated.nb.blob.digest} constraint.`\n    )\n  } else if (\n    claimed.nb.blob.size !== undefined &&\n    delegated.nb.blob.size !== undefined\n  ) {\n    return claimed.nb.blob.size > delegated.nb.blob.size\n      ? fail(\n          `Size constraint violation: ${claimed.nb.blob.size} > ${delegated.nb.blob.size}`\n        )\n      : ok({})\n  } else {\n    return ok({})\n  }\n}\n\n/**\n * @template {Types.ParsedCapability<\"http/put\", Types.URI<'did:'>, {body: { digest: Uint8Array, size: number }}>} T\n * @param {T} claimed\n * @param {T} delegated\n * @returns {Types.Result<{}, Types.Failure>}\n */\nexport const equalBody = (claimed, delegated) => {\n  if (claimed.with !== delegated.with) {\n    return fail(\n      `Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`\n    )\n  } else if (\n    delegated.nb.body.digest &&\n    !equals(delegated.nb.body.digest, claimed.nb.body.digest)\n  ) {\n    return fail(\n      `Link ${\n        claimed.nb.body.digest ? `${claimed.nb.body.digest}` : ''\n      } violates imposed ${delegated.nb.body.digest} constraint.`\n    )\n  } else if (\n    claimed.nb.body.size !== undefined &&\n    delegated.nb.body.size !== undefined\n  ) {\n    return claimed.nb.body.size > delegated.nb.body.size\n      ? fail(\n          `Size constraint violation: ${claimed.nb.body.size} > ${delegated.nb.body.size}`\n        )\n      : ok({})\n  } else {\n    return ok({})\n  }\n}\n\n/**\n * @template {Types.ParsedCapability<\"blob/add\"|\"blob/remove\"|\"blob/allocate\"|\"blob/accept\"|\"http/put\", Types.URI<'did:'>, {content: Uint8Array}>} T\n * @param {T} claimed\n * @param {T} delegated\n * @returns {Types.Result<{}, Types.Failure>}\n */\nexport const equalContent = (claimed, delegated) => {\n  if (claimed.with !== delegated.with) {\n    return fail(\n      `Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`\n    )\n  } else if (\n    delegated.nb.content &&\n    !equals(delegated.nb.content, claimed.nb.content)\n  ) {\n    return fail(\n      `Link ${\n        claimed.nb.content ? `${claimed.nb.content}` : ''\n      } violates imposed ${delegated.nb.content} constraint.`\n    )\n  } else {\n    return ok({})\n  }\n}\n\n/**\n * Checks that `claimed` {@link Types.Link} meets an `imposed` constraint.\n *\n * @param {Types.UnknownLink} claimed\n * @param {Types.UnknownLink|undefined} imposed\n * @param {string} at\n * @returns {Types.Result<{}, Types.Failure>}\n */\nexport const checkLink = (claimed, imposed, at) => {\n  return equal(\n    String(claimed),\n    imposed === undefined ? undefined : String(imposed),\n    at\n  )\n}\n\n/**\n * @template T\n * @param {Types.Result<T , Types.Failure>} result\n * @returns {{error: Types.Failure, ok?:undefined}|undefined}\n */\nexport const and = (result) => (result.error ? result : undefined)\n\n/**\n *\n * @param {import('@ucanto/interface').Ability} ability\n */\nfunction parseAbility(ability) {\n  const [namespace, ...segments] = ability.split('/')\n  return { namespace, segments }\n}\n\n/**\n *\n * TODO: needs to account for caps derived from different namespaces like 'account/info' can be derived from 'store/add'\n *\n * @param {import('@ucanto/interface').Ability} parent\n * @param {import('@ucanto/interface').Ability} child\n */\nexport function canDelegateAbility(parent, child) {\n  const parsedParent = parseAbility(parent)\n  const parsedChild = parseAbility(child)\n\n  // Parent is wildcard\n  if (parsedParent.namespace === '*' && parsedParent.segments.length === 0) {\n    return true\n  }\n\n  // Child is wild card so it can not be delegated from anything\n  if (parsedChild.namespace === '*' && parsedChild.segments.length === 0) {\n    return false\n  }\n\n  // namespaces don't match\n  if (parsedParent.namespace !== parsedChild.namespace) {\n    return false\n  }\n\n  // given that namespaces match and parent first segment is wildcard\n  if (parsedParent.segments[0] === '*') {\n    return true\n  }\n\n  // Array equality\n  if (parsedParent.segments.length !== parsedChild.segments.length) {\n    return false\n  }\n\n  // all segments must match\n  return parsedParent.segments.reduce(\n    (acc, v, i) => acc && parsedChild.segments[i] === v,\n    true\n  )\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 164, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40web3-storage/capabilities/src/store.js"],"sourcesContent":["/**\n * Store Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as Store from '@web3-storage/capabilities/store'\n * ```\n *\n * @module\n */\nimport { capability, Link, Schema, ok, fail } from '@ucanto/validator'\nimport { equalLink, equalWith, SpaceDID } from './utils.js'\n\n// @see https://github.com/multiformats/multicodec/blob/master/table.csv#L140\nexport const code = 0x0202\n\nexport const CARLink = Schema.link({ code, version: 1 })\n\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derived any `store/` prefixed capability for the (memory) space identified\n * by DID in the `with` field.\n */\nexport const store = capability({\n  can: 'store/*',\n  /**\n   * DID of the (memory) space where CAR is intended to\n   * be stored.\n   */\n  with: SpaceDID,\n  derives: equalWith,\n})\n\n/**\n * `store/add` capability allows agent to store a CAR file into a (memory) space\n * identified by did:key in the `with` field. Agent must precompute CAR locally\n * and provide it's CID and size using `nb.link` and `nb.size` fields, allowing\n * a service to provision a write location for the agent to PUT or POST desired\n * CAR into.\n */\nexport const add = capability({\n  can: 'store/add',\n  /**\n   * DID of the (memory) space where CAR is intended to\n   * be stored.\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * CID of the CAR file to be stored. Service will provision write target\n     * for this exact CAR file for agent to PUT or POST it. Attempt to write\n     * any other content will fail.\n     */\n    link: CARLink,\n    /**\n     * Size of the CAR file to be stored. Service will provision write target\n     * for this exact size. Attempt to write a larger CAR file will fail.\n     */\n    size: Schema.integer(),\n    /**\n     * Agent may optionally provide a link to a related CAR file using `origin`\n     * field. This is useful when storing large DAGs, agent could shard it\n     * across multiple CAR files and then link each shard with a previous one.\n     *\n     * Providing this relation tells service that given CAR is shard of the\n     * larger DAG as opposed to it being intentionally partial DAG. When DAG is\n     * not sharded, there will be only one `store/add` with `origin` left out.\n     */\n    origin: Link.optional(),\n  }),\n  derives: (claim, from) => {\n    const result = equalLink(claim, from)\n    if (result.error) {\n      return result\n    } else if (claim.nb.size !== undefined && from.nb.size !== undefined) {\n      return claim.nb.size > from.nb.size\n        ? fail(`Size constraint violation: ${claim.nb.size} > ${from.nb.size}`)\n        : ok({})\n    } else {\n      return ok({})\n    }\n  },\n})\n\n/**\n * Capability to get store metadata by shard CID.\n * Use to check for inclusion, or get shard size and origin\n *\n * `nb.link` is optional to allow delegation of `store/get`\n * capability for any shard CID. If link is specified, then the\n * capability only allows a get for that specific CID.\n *\n * When used as as an invocation, `nb.link` must be specified.\n */\nexport const get = capability({\n  can: 'store/get',\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * shard CID to fetch info about.\n     */\n    link: CARLink.optional(),\n  }),\n  derives: equalLink,\n})\n\n/**\n * Capability can be used to remove the stored CAR file from the (memory)\n * space identified by `with` field.\n */\nexport const remove = capability({\n  can: 'store/remove',\n  /**\n   * DID of the (memory) space where CAR is intended to\n   * be stored.\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * CID of the CAR file to be removed from the store.\n     */\n    link: CARLink,\n  }),\n  derives: equalLink,\n})\n\n/**\n * Capability can be invoked to request a list of stored CAR files in the\n * (memory) space identified by `with` field.\n */\nexport const list = capability({\n  can: 'store/list',\n  /**\n   * DID of the (memory) space where CAR is intended to\n   * be stored.\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * A pointer that can be moved back and forth on the list.\n     * It can be used to paginate a list for instance.\n     */\n    cursor: Schema.string().optional(),\n    /**\n     * Maximum number of items per page.\n     */\n    size: Schema.integer().optional(),\n    /**\n     * If true, return page of results preceding cursor. Defaults to false.\n     */\n    pre: Schema.boolean().optional(),\n  }),\n  derives: (claimed, delegated) => {\n    if (claimed.with !== delegated.with) {\n      return fail(\n        `Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`\n      )\n    }\n    return ok({})\n  },\n})\n\nexport const all = add.or(remove).or(list)\n\n// ⚠️ We export imports here so they are not omitted in generated typedes\n// @see https://github.com/microsoft/TypeScript/issues/51548\nexport { Schema, Link }\n"],"names":[],"mappings":"AAAA;;;;;;;;;CASC;;;;;;;;;;;;;;;;;;AACD;AAAA;AAAA;AAAA;AAAA;AACA;;;AAGO,MAAM,OAAO;AAEb,MAAM,UAAU,gMAAM,CAAC,IAAI,CAAC;IAAE;IAAM,SAAS;AAAE;AAO/C,MAAM,QAAQ,IAAA,gOAAU,EAAC;IAC9B,KAAK;IACL;;;GAGC,GACD,MAAM,gLAAQ;IACd,SAAS,iLAAS;AACpB;AASO,MAAM,MAAM,IAAA,gOAAU,EAAC;IAC5B,KAAK;IACL;;;GAGC,GACD,MAAM,gLAAQ;IACd,IAAI,gMAAM,CAAC,MAAM,CAAC;QAChB;;;;KAIC,GACD,MAAM;QACN;;;KAGC,GACD,MAAM,gMAAM,CAAC,OAAO;QACpB;;;;;;;;KAQC,GACD,QAAQ,4JAAI,CAAC,QAAQ;IACvB;IACA,SAAS,CAAC,OAAO;QACf,MAAM,SAAS,IAAA,iLAAS,EAAC,OAAO;QAChC,IAAI,OAAO,KAAK,EAAE;YAChB,OAAO;QACT,OAAO,IAAI,MAAM,EAAE,CAAC,IAAI,KAAK,aAAa,KAAK,EAAE,CAAC,IAAI,KAAK,WAAW;YACpE,OAAO,MAAM,EAAE,CAAC,IAAI,GAAG,KAAK,EAAE,CAAC,IAAI,GAC/B,IAAA,4JAAI,EAAC,CAAC,2BAA2B,EAAE,MAAM,EAAE,CAAC,IAAI,CAAC,GAAG,EAAE,KAAK,EAAE,CAAC,IAAI,EAAE,IACpE,IAAA,0JAAE,EAAC,CAAC;QACV,OAAO;YACL,OAAO,IAAA,0JAAE,EAAC,CAAC;QACb;IACF;AACF;AAYO,MAAM,MAAM,IAAA,gOAAU,EAAC;IAC5B,KAAK;IACL,MAAM,gLAAQ;IACd,IAAI,gMAAM,CAAC,MAAM,CAAC;QAChB;;KAEC,GACD,MAAM,QAAQ,QAAQ;IACxB;IACA,SAAS,iLAAS;AACpB;AAMO,MAAM,SAAS,IAAA,gOAAU,EAAC;IAC/B,KAAK;IACL;;;GAGC,GACD,MAAM,gLAAQ;IACd,IAAI,gMAAM,CAAC,MAAM,CAAC;QAChB;;KAEC,GACD,MAAM;IACR;IACA,SAAS,iLAAS;AACpB;AAMO,MAAM,OAAO,IAAA,gOAAU,EAAC;IAC7B,KAAK;IACL;;;GAGC,GACD,MAAM,gLAAQ;IACd,IAAI,gMAAM,CAAC,MAAM,CAAC;QAChB;;;KAGC,GACD,QAAQ,gMAAM,CAAC,MAAM,GAAG,QAAQ;QAChC;;KAEC,GACD,MAAM,gMAAM,CAAC,OAAO,GAAG,QAAQ;QAC/B;;KAEC,GACD,KAAK,gMAAM,CAAC,OAAO,GAAG,QAAQ;IAChC;IACA,SAAS,CAAC,SAAS;QACjB,IAAI,QAAQ,IAAI,KAAK,UAAU,IAAI,EAAE;YACnC,OAAO,IAAA,4JAAI,EACT,CAAC,iBAAiB,EAAE,UAAU,IAAI,CAAC,gBAAgB,EAAE,QAAQ,IAAI,CAAC,CAAC,CAAC;QAExE;QACA,OAAO,IAAA,0JAAE,EAAC,CAAC;IACb;AACF;AAEO,MAAM,MAAM,IAAI,EAAE,CAAC,QAAQ,EAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 332, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40web3-storage/capabilities/src/upload.js"],"sourcesContent":["/**\n * Upload Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as Account from '@web3-storage/capabilities/upload'\n * ```\n *\n * @module\n */\nimport { capability, Link, Schema, ok } from '@ucanto/validator'\nimport { codec as CAR } from '@ucanto/transport/car'\nimport { equalWith, and, equal, SpaceDID } from './utils.js'\n\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derived any `upload/` prefixed capability for the (memory) space identified\n * by DID in the `with` field.\n */\nexport const upload = capability({\n  can: 'upload/*',\n  /**\n   * DID of the (memory) space where upload is add to the\n   * upload list.\n   */\n  with: SpaceDID,\n  derives: equalWith,\n})\n\n/**\n * Schema representing a link (a.k.a CID) to a CAR file. Enforces CAR codec code and CID v1.\n */\nconst CARLink = Link.match({ code: CAR.code, version: 1 })\n\n/**\n * Capability allows an agent to add an arbitrary DAG (root) to the upload list\n * of the specified (memory) space (identified by did:key in the `with` field).\n * It is recommended to provide an optional list of shard links that contain\n * fragments of this DAG, as it allows system to optimize block discovery, it is\n * also a way to communicate DAG partiality - this upload contains partial DAG\n * identified by the given `root`.\n *\n * Usually when agent wants to upload a DAG it will encode it as a one or more\n * CAR files (shards) and invoke `store/add` capability for each one. Once all\n * shards are stored it will invoke `upload/add` capability (providing link to\n * a DAG root and all the shards) to add it the upload list.\n *\n * That said `upload/add` could be invoked without invoking `store/add`s e.g.\n * because another (memory) space may already have those CARs.\n *\n * Note: If DAG with the given root is already in the upload list, invocation\n * will simply update `shards` to be a union of existing and new shards.\n */\nexport const add = capability({\n  can: 'upload/add',\n  /**\n   * DID of the (memory) space where uploaded is added.\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * Root CID of the DAG to be added to the upload list.\n     */\n    root: Link,\n    /**\n     * CIDs to the CAR files that contain blocks of the DAG.\n     */\n    shards: CARLink.array().optional(),\n  }),\n  derives: (self, from) => {\n    return (\n      and(equalWith(self, from)) ||\n      and(equal(self.nb.root, from.nb.root, 'root')) ||\n      and(equal(self.nb.shards, from.nb.shards, 'shards')) ||\n      ok({})\n    )\n  },\n})\n\n/**\n * Capability to get upload metadata by root CID.\n * Use to check for inclusion, or find the shards for a root.\n *\n * `nb.root` is optional to allow delegation of `upload/get`\n * capability for any root. If root is specified, then the\n * capability only allows a get for that single cid.\n *\n * When used as as an invocation, `nb.root` must be specified.\n */\nexport const get = capability({\n  can: 'upload/get',\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * Root CID of the DAG to fetch upload info about.\n     */\n    root: Link.optional(),\n  }),\n  derives: (self, from) => {\n    const res = equalWith(self, from)\n    if (res.error) {\n      return res\n    }\n    if (!from.nb.root) {\n      return res\n    }\n    // root must match if specified in the proof\n    return equal(self.nb.root, from.nb.root, 'root')\n  },\n})\n\n/**\n * Capability removes an upload (identified by it's root CID) from the upload\n * list. Please note that removing an upload does not delete corresponding shards\n * from the store, however that could be done via `store/remove` invocations.\n */\nexport const remove = capability({\n  can: 'upload/remove',\n  /**\n   * DID of the (memory) space where uploaded is removed from.\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * Root CID of the DAG to be removed from the upload list.\n     */\n    root: Link,\n  }),\n  derives: (self, from) => {\n    return (\n      and(equalWith(self, from)) ||\n      and(equal(self.nb.root, from.nb.root, 'root')) ||\n      ok({})\n    )\n  },\n})\n\n/**\n * Capability can be invoked to request a list of uploads in the (memory) space\n * identified by the `with` field.\n */\nexport const list = capability({\n  can: 'upload/list',\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * A pointer that can be moved back and forth on the list.\n     * It can be used to paginate a list for instance.\n     */\n    cursor: Schema.string().optional(),\n    /**\n     * Maximum number of items per page.\n     */\n    size: Schema.integer().optional(),\n    /**\n     * If true, return page of results preceding cursor. Defaults to false.\n     */\n    pre: Schema.boolean().optional(),\n  }),\n})\n\nexport const all = add.or(remove).or(list)\n\n// ⚠️ We export imports here so they are not omitted in generated typedefs\n// @see https://github.com/microsoft/TypeScript/issues/51548\nexport { Link, Schema }\n"],"names":[],"mappings":"AAAA;;;;;;;;;CASC;;;;;;;;;;;;;;AACD;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;;;AAOO,MAAM,SAAS,IAAA,gOAAU,EAAC;IAC/B,KAAK;IACL;;;GAGC,GACD,MAAM,gLAAQ;IACd,SAAS,iLAAS;AACpB;AAEA;;CAEC,GACD,MAAM,UAAU,4JAAI,CAAC,KAAK,CAAC;IAAE,MAAM,2LAAG,CAAC,IAAI;IAAE,SAAS;AAAE;AAqBjD,MAAM,MAAM,IAAA,gOAAU,EAAC;IAC5B,KAAK;IACL;;GAEC,GACD,MAAM,gLAAQ;IACd,IAAI,gMAAM,CAAC,MAAM,CAAC;QAChB;;KAEC,GACD,MAAM,4JAAI;QACV;;KAEC,GACD,QAAQ,QAAQ,KAAK,GAAG,QAAQ;IAClC;IACA,SAAS,CAAC,MAAM;QACd,OACE,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,MAAM,UACpB,IAAA,2KAAG,EAAC,IAAA,6KAAK,EAAC,KAAK,EAAE,CAAC,IAAI,EAAE,KAAK,EAAE,CAAC,IAAI,EAAE,YACtC,IAAA,2KAAG,EAAC,IAAA,6KAAK,EAAC,KAAK,EAAE,CAAC,MAAM,EAAE,KAAK,EAAE,CAAC,MAAM,EAAE,cAC1C,IAAA,0JAAE,EAAC,CAAC;IAER;AACF;AAYO,MAAM,MAAM,IAAA,gOAAU,EAAC;IAC5B,KAAK;IACL,MAAM,gLAAQ;IACd,IAAI,gMAAM,CAAC,MAAM,CAAC;QAChB;;KAEC,GACD,MAAM,4JAAI,CAAC,QAAQ;IACrB;IACA,SAAS,CAAC,MAAM;QACd,MAAM,MAAM,IAAA,iLAAS,EAAC,MAAM;QAC5B,IAAI,IAAI,KAAK,EAAE;YACb,OAAO;QACT;QACA,IAAI,CAAC,KAAK,EAAE,CAAC,IAAI,EAAE;YACjB,OAAO;QACT;QACA,4CAA4C;QAC5C,OAAO,IAAA,6KAAK,EAAC,KAAK,EAAE,CAAC,IAAI,EAAE,KAAK,EAAE,CAAC,IAAI,EAAE;IAC3C;AACF;AAOO,MAAM,SAAS,IAAA,gOAAU,EAAC;IAC/B,KAAK;IACL;;GAEC,GACD,MAAM,gLAAQ;IACd,IAAI,gMAAM,CAAC,MAAM,CAAC;QAChB;;KAEC,GACD,MAAM,4JAAI;IACZ;IACA,SAAS,CAAC,MAAM;QACd,OACE,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,MAAM,UACpB,IAAA,2KAAG,EAAC,IAAA,6KAAK,EAAC,KAAK,EAAE,CAAC,IAAI,EAAE,KAAK,EAAE,CAAC,IAAI,EAAE,YACtC,IAAA,0JAAE,EAAC,CAAC;IAER;AACF;AAMO,MAAM,OAAO,IAAA,gOAAU,EAAC;IAC7B,KAAK;IACL,MAAM,gLAAQ;IACd,IAAI,gMAAM,CAAC,MAAM,CAAC;QAChB;;;KAGC,GACD,QAAQ,gMAAM,CAAC,MAAM,GAAG,QAAQ;QAChC;;KAEC,GACD,MAAM,gMAAM,CAAC,OAAO,GAAG,QAAQ;QAC/B;;KAEC,GACD,KAAK,gMAAM,CAAC,OAAO,GAAG,QAAQ;IAChC;AACF;AAEO,MAAM,MAAM,IAAI,EAAE,CAAC,QAAQ,EAAE,CAAC","ignoreList":[0]}},
    {"offset": {"line": 453, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40web3-storage/capabilities/src/top.js"],"sourcesContent":["/**\n * Top Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as Account from '@web3-storage/capabilities/top'\n * ```\n *\n * @module\n */\n\nimport { capability, Schema } from '@ucanto/validator'\nimport { equalWith } from './utils.js'\n\n/**\n * Represents the top `{ can: '*', with: 'did:key:zAlice' }` capability, which we often\n * also call account linking.\n *\n * @see {@link https://github.com/ucan-wg/spec#52-top}\n */\nexport const top = capability({\n  can: '*',\n  with: Schema.or(Schema.did(), Schema.literal('ucan:*')),\n  derives: equalWith,\n})\n"],"names":[],"mappings":"AAAA;;;;;;;;;CASC;;;;AAED;AAAA;AAAA;AACA;;;AAQO,MAAM,MAAM,IAAA,gOAAU,EAAC;IAC5B,KAAK;IACL,MAAM,gMAAM,CAAC,EAAE,CAAC,gMAAM,CAAC,GAAG,IAAI,gMAAM,CAAC,OAAO,CAAC;IAC7C,SAAS,iLAAS;AACpB","ignoreList":[0]}},
    {"offset": {"line": 481, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40web3-storage/capabilities/src/space.js"],"sourcesContent":["/**\n * Space Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as Space from '@web3-storage/capabilities/space'\n * ```\n *\n * @module\n */\n\nimport * as Store from './store.js'\nimport { capability, Schema, ok, fail } from '@ucanto/validator'\nimport { SpaceDID, equalWith } from './utils.js'\nimport * as Upload from './upload.js'\nexport { top } from './top.js'\n\n// Need this to workaround TS bug\n// @see https://github.com/microsoft/TypeScript/issues/51548\nexport { Store }\n\nexport const space = capability({\n  can: 'space/*',\n  with: SpaceDID,\n  derives: equalWith,\n})\n\n/**\n * `space/info` can be derived from any of the `store/*`\n * capability that has matching `with`. This allows store service\n * to identify account based on any user request.\n */\nexport const info = Store.add\n  .or(Store.list)\n  .or(Store.remove)\n  .or(Upload.add)\n  .or(Upload.list)\n  .or(Upload.remove)\n  .derive({\n    to: capability({\n      can: 'space/info',\n      with: SpaceDID,\n    }),\n    derives: equalWith,\n  })\n\nexport const allocate = capability({\n  can: 'space/allocate',\n  with: SpaceDID,\n  nb: Schema.struct({\n    size: Schema.integer(),\n  }),\n  derives: (child, parent) => {\n    const result = equalWith(child, parent)\n    if (result.ok) {\n      return child.nb.size <= parent.nb.size\n        ? ok({})\n        : fail(\n            `Claimed size ${child.nb.size} escalates delegated size ${parent.nb.size}`\n          )\n    } else {\n      return result\n    }\n  },\n})\n\n/**\n * The capability grants permission for all content serve operations that fall under the \"space/content/serve\" namespace.\n * It can be derived from any of the `space/*` capability that has matching `with`.\n */\n\nexport const contentServe = capability({\n  can: 'space/content/serve/*',\n  with: SpaceDID,\n  derives: equalWith,\n})\n\n/**\n * Capability can be invoked by an agent to record egress data for a given resource.\n * It can be derived from any of the `space/content/serve/*` capability that has matching `with`.\n */\nexport const egressRecord = capability({\n  can: 'space/content/serve/egress/record',\n  with: SpaceDID,\n  nb: Schema.struct({\n    /** CID of the resource that was served. */\n    resource: Schema.link(),\n    /** Amount of bytes served. */\n    bytes: Schema.integer().greaterThan(0),\n    /** Timestamp of the event in milliseconds after Unix epoch. */\n    servedAt: Schema.integer().greaterThan(-1),\n  }),\n  derives: equalWith,\n})\n"],"names":[],"mappings":"AAAA;;;;;;;;;CASC;;;;;;;;;;;;AAED;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;AAMO,MAAM,QAAQ,IAAA,gOAAU,EAAC;IAC9B,KAAK;IACL,MAAM,gLAAQ;IACd,SAAS,iLAAS;AACpB;AAOO,MAAM,OAAO,2LAAS,CAC1B,EAAE,CAAC,4LAAU,EACb,EAAE,CAAC,8LAAY,EACf,EAAE,CAAC,4LAAU,EACb,EAAE,CAAC,6LAAW,EACd,EAAE,CAAC,+LAAa,EAChB,MAAM,CAAC;IACN,IAAI,IAAA,gOAAU,EAAC;QACb,KAAK;QACL,MAAM,gLAAQ;IAChB;IACA,SAAS,iLAAS;AACpB;AAEK,MAAM,WAAW,IAAA,gOAAU,EAAC;IACjC,KAAK;IACL,MAAM,gLAAQ;IACd,IAAI,gMAAM,CAAC,MAAM,CAAC;QAChB,MAAM,gMAAM,CAAC,OAAO;IACtB;IACA,SAAS,CAAC,OAAO;QACf,MAAM,SAAS,IAAA,iLAAS,EAAC,OAAO;QAChC,IAAI,OAAO,EAAE,EAAE;YACb,OAAO,MAAM,EAAE,CAAC,IAAI,IAAI,OAAO,EAAE,CAAC,IAAI,GAClC,IAAA,0JAAE,EAAC,CAAC,KACJ,IAAA,4JAAI,EACF,CAAC,aAAa,EAAE,MAAM,EAAE,CAAC,IAAI,CAAC,0BAA0B,EAAE,OAAO,EAAE,CAAC,IAAI,EAAE;QAElF,OAAO;YACL,OAAO;QACT;IACF;AACF;AAOO,MAAM,eAAe,IAAA,gOAAU,EAAC;IACrC,KAAK;IACL,MAAM,gLAAQ;IACd,SAAS,iLAAS;AACpB;AAMO,MAAM,eAAe,IAAA,gOAAU,EAAC;IACrC,KAAK;IACL,MAAM,gLAAQ;IACd,IAAI,gMAAM,CAAC,MAAM,CAAC;QAChB,yCAAyC,GACzC,UAAU,gMAAM,CAAC,IAAI;QACrB,4BAA4B,GAC5B,OAAO,gMAAM,CAAC,OAAO,GAAG,WAAW,CAAC;QACpC,6DAA6D,GAC7D,UAAU,gMAAM,CAAC,OAAO,GAAG,WAAW,CAAC,CAAC;IAC1C;IACA,SAAS,iLAAS;AACpB","ignoreList":[0]}},
    {"offset": {"line": 563, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40web3-storage/capabilities/src/ucan.js"],"sourcesContent":["/**\n * UCAN core capabilities.\n */\n\nimport { capability, Schema, ok } from '@ucanto/validator'\nimport * as API from '@ucanto/interface'\nimport { equalWith, equal, and, checkLink } from './utils.js'\n\nexport const UCANLink =\n  /** @type {Schema.Schema<API.UCANLink, unknown>} */\n  (Schema.link({ version: 1 }))\n\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derived any `store/` prefixed capability for the (memory) space identified\n * by DID in the `with` field.\n */\nexport const ucan = capability({\n  can: 'ucan/*',\n  with: Schema.did(),\n  derives: equalWith,\n})\n\n/**\n * `ucan/revoke` capability is a replacement for the\n * [UCAN Revocation](https://github.com/ucan-wg/spec#66-revocation) that had\n * been proposed to a UCAN working group and had a tentative support from\n * members.\n *\n * Capability can be used to revoke `nb.ucan` authorization from all proofs\n * chains that lead to the UCAN issued or being delegated to the principal\n * identified by the `with` field. Note that revoked UCAN MUST continue to\n * be valid in the invocation where proof chain does not lead to the principal\n * identified by the `with` field.\n */\nexport const revoke = capability({\n  can: 'ucan/revoke',\n  /**\n   * DID of the principal authorizing revocation.\n   */\n  with: Schema.did(),\n  nb: Schema.struct({\n    /**\n     * UCAN being revoked from all proof chains that lead to the UCAN that is\n     * either issued (iss) by or delegated to (aud) the principal identified\n     * by the `with` field.\n     */\n    ucan: UCANLink,\n    /**\n     * Proof chain illustrating the path from revoked UCAN to the one that is\n     * either issued (iss) by or delegated to (aud) the principal identified\n     * by the `with` field.\n     *\n     * If the UCAN being revoked is either issued (iss) by or delegated to (aud)\n     * the principal identified by the `with` field no `proof` is required and\n     * it can be omitted or set to an empty array.\n     *\n     * It is RECOMMENDED that `proof` is provided in all other cases otherwise\n     * it MAY not be possible to verify that revoking principal is a participant\n     * in the proof chain.\n     */\n    proof: UCANLink.array().optional(),\n  }),\n  derives: (claim, from) =>\n    // With field MUST be the same\n    and(equalWith(claim, from)) ??\n    // UCAN being revoked MUST be the same\n    and(checkLink(claim.nb.ucan, from.nb.ucan, 'nb.ucan')) ??\n    // And proof chain MUST be the same\n    equal(\n      (claim.nb.proof ?? []).join('/'),\n      (from.nb.proof ?? []).join('/'),\n      'nb.proof'\n    ),\n})\n\n/**\n * `ucan/conclude` capability represents a receipt using a special UCAN capability.\n *\n * The UCAN invocation specification defines receipt record, that is cryptographically\n * signed description of the invocation output and requested effects. Receipt\n * structure is very similar to UCAN except it has no notion of expiry nor it is\n * possible to delegate ability to issue receipt to another principal.\n */\nexport const conclude = capability({\n  can: 'ucan/conclude',\n  /**\n   * DID of the principal representing the Conclusion Authority.\n   * MUST be the DID of the audience of the ran invocation.\n   */\n  with: Schema.did(),\n  nb: Schema.struct({\n    /**\n     * CID of the content with the Receipt.\n     */\n    receipt: Schema.link(),\n  }),\n  derives: (claim, from) =>\n    // With field MUST be the same\n    and(equalWith(claim, from)) ||\n    and(checkLink(claim.nb.receipt, from.nb.receipt, 'nb.receipt')) ||\n    ok({}),\n})\n\n/**\n * Issued by trusted authority (usually the one handling invocation) that attest\n * that specific UCAN delegation has been considered authentic.\n *\n * @see https://github.com/storacha/specs/blob/main/w3-session.md#authorization-session\n * \n * @example\n * ```js\n * {\n    iss: \"did:web:web3.storage\",\n    aud: \"did:key:z6Mkk89bC3JrVqKie71YEcc5M1SMVxuCgNx6zLZ8SYJsxALi\",\n    att: [{\n      \"with\": \"did:web:web3.storage\",\n      \"can\": \"ucan/attest\",\n      \"nb\": {\n        \"proof\": {\n          \"/\": \"bafyreifer23oxeyamllbmrfkkyvcqpujevuediffrpvrxmgn736f4fffui\"\n        }\n      }\n    }],\n    exp: null\n    sig: \"...\"\n  }\n * ```\n */\nexport const attest = capability({\n  can: 'ucan/attest',\n  // Should be web3.storage DID\n  with: Schema.did(),\n  nb: Schema.struct({\n    // UCAN delegation that is being attested.\n    proof: Schema.link({ version: 1 }),\n  }),\n  derives: (claim, from) =>\n    // With field MUST be the same\n    and(equalWith(claim, from)) ??\n    // UCAN link MUST be the same\n    checkLink(claim.nb.proof, from.nb.proof, 'nb.proof'),\n})\n"],"names":[],"mappings":"AAAA;;CAEC;;;;;;;;;;;;AAED;AAAA;AAAA;AAAA;AACA;AACA;;;;AAEO,MAAM,WAEV,gMAAM,CAAC,IAAI,CAAC;IAAE,SAAS;AAAE;AAOrB,MAAM,OAAO,IAAA,gOAAU,EAAC;IAC7B,KAAK;IACL,MAAM,gMAAM,CAAC,GAAG;IAChB,SAAS,iLAAS;AACpB;AAcO,MAAM,SAAS,IAAA,gOAAU,EAAC;IAC/B,KAAK;IACL;;GAEC,GACD,MAAM,gMAAM,CAAC,GAAG;IAChB,IAAI,gMAAM,CAAC,MAAM,CAAC;QAChB;;;;KAIC,GACD,MAAM;QACN;;;;;;;;;;;;KAYC,GACD,OAAO,SAAS,KAAK,GAAG,QAAQ;IAClC;IACA,SAAS,CAAC,OAAO,OACf,8BAA8B;QAC9B,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,OAAO,UACrB,sCAAsC;QACtC,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,MAAM,EAAE,CAAC,IAAI,EAAE,KAAK,EAAE,CAAC,IAAI,EAAE,eAC3C,mCAAmC;QACnC,IAAA,6KAAK,EACH,CAAC,MAAM,EAAE,CAAC,KAAK,IAAI,EAAE,EAAE,IAAI,CAAC,MAC5B,CAAC,KAAK,EAAE,CAAC,KAAK,IAAI,EAAE,EAAE,IAAI,CAAC,MAC3B;AAEN;AAUO,MAAM,WAAW,IAAA,gOAAU,EAAC;IACjC,KAAK;IACL;;;GAGC,GACD,MAAM,gMAAM,CAAC,GAAG;IAChB,IAAI,gMAAM,CAAC,MAAM,CAAC;QAChB;;KAEC,GACD,SAAS,gMAAM,CAAC,IAAI;IACtB;IACA,SAAS,CAAC,OAAO,OACf,8BAA8B;QAC9B,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,OAAO,UACrB,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,MAAM,EAAE,CAAC,OAAO,EAAE,KAAK,EAAE,CAAC,OAAO,EAAE,kBACjD,IAAA,0JAAE,EAAC,CAAC;AACR;AA2BO,MAAM,SAAS,IAAA,gOAAU,EAAC;IAC/B,KAAK;IACL,6BAA6B;IAC7B,MAAM,gMAAM,CAAC,GAAG;IAChB,IAAI,gMAAM,CAAC,MAAM,CAAC;QAChB,0CAA0C;QAC1C,OAAO,gMAAM,CAAC,IAAI,CAAC;YAAE,SAAS;QAAE;IAClC;IACA,SAAS,CAAC,OAAO,OACf,8BAA8B;QAC9B,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,OAAO,UACrB,6BAA6B;QAC7B,IAAA,iLAAS,EAAC,MAAM,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,KAAK,EAAE;AAC7C","ignoreList":[0]}},
    {"offset": {"line": 656, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40web3-storage/capabilities/src/access.js"],"sourcesContent":["/**\n * Access Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as Access from '@web3-storage/capabilities/access'\n * ```\n *\n * @module\n */\nimport { capability, URI, DID, Schema, fail, ok } from '@ucanto/validator'\nimport * as Types from '@ucanto/interface'\nimport { attest } from './ucan.js'\nimport { equalWith, equal, and, SpaceDID, checkLink } from './utils.js'\nexport { top } from './top.js'\n\n/**\n * @deprecated - Use `ucan.attest` instead.\n */\nexport const session = attest\n\n/**\n * Account identifier.\n */\nexport const Account = DID.match({ method: 'mailto' })\n\n/**\n * Describes the capability requested.\n */\nexport const CapabilityRequest = Schema.struct({\n  /**\n   * If set to `\"*\"` it corresponds to \"sudo\" access.\n   */\n  can: Schema.string(),\n})\n\n/**\n * Authorization request describing set of desired capabilities.\n */\nexport const AuthorizationRequest = Schema.struct({\n  /**\n   * DID of the Account authorization is requested from.\n   */\n  iss: Account.optional(),\n  /**\n   * Capabilities agent wishes to be granted.\n   */\n  att: CapabilityRequest.array(),\n})\n\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derived any `access/` prefixed capability for the agent identified\n * by did:key in the `with` field.\n */\nexport const access = capability({\n  can: 'access/*',\n  with: URI.match({ protocol: 'did:' }),\n})\n\n/**\n * Capability can be invoked by an agent to request set of capabilities from\n * the account.\n */\nexport const authorize = capability({\n  can: 'access/authorize',\n  with: DID.match({ method: 'key' }),\n  /**\n   * Authorization request describing set of desired capabilities\n   */\n  nb: AuthorizationRequest,\n  derives: (child, parent) => {\n    return (\n      and(equalWith(child, parent)) ||\n      and(equal(child.nb.iss, parent.nb.iss, 'iss')) ||\n      and(subsetCapabilities(child.nb.att, parent.nb.att)) ||\n      ok({})\n    )\n  },\n})\n\n/**\n * Capability is delegated by us to the user allowing them to complete the\n * authorization flow. It allows us to ensure that user clicks the link and\n * we don't have some rogue agent trying to impersonate user clicking the link\n * in order to get access to their account.\n */\nexport const confirm = capability({\n  can: 'access/confirm',\n  with: DID,\n  nb: Schema.struct({\n    /**\n     * Link to the `access/authorize` request that this delegation was created\n     * for.\n     */\n    cause: Schema.link({ version: 1 }),\n    iss: Account,\n    aud: Schema.did(),\n    att: CapabilityRequest.array(),\n  }),\n  derives: (claim, proof) => {\n    return (\n      and(equalWith(claim, proof)) ||\n      and(equal(claim.nb.iss, proof.nb.iss, 'iss')) ||\n      and(equal(claim.nb.aud, proof.nb.aud, 'aud')) ||\n      and(subsetCapabilities(claim.nb.att, proof.nb.att)) ||\n      and(checkLink(claim.nb.cause, proof.nb.cause, 'nb.cause')) ||\n      ok({})\n    )\n  },\n})\n\nexport const claim = capability({\n  can: 'access/claim',\n  with: DID.match({ method: 'key' }).or(DID.match({ method: 'mailto' })),\n})\n\n// https://github.com/storacha/specs/blob/main/w3-access.md#accessdelegate\nexport const delegate = capability({\n  can: 'access/delegate',\n  /**\n   * Field MUST be a space DID with a storage provider. Delegation will be stored just like any other DAG stored using store/add capability.\n   *\n   * @see https://github.com/storacha/specs/blob/main/w3-access.md#delegate-with\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    // keys SHOULD be CIDs, but we won't require it in the schema\n    /**\n     * @type {Schema.Schema<AccessDelegateDelegations>}\n     */\n    delegations: Schema.dictionary({\n      value: Schema.Link.match(),\n    }),\n  }),\n  derives: (claim, proof) => {\n    return (\n      and(equalWith(claim, proof)) ||\n      and(subsetsNbDelegations(claim, proof)) ||\n      ok({})\n    )\n  },\n})\n\n/**\n * @typedef {Schema.Dictionary<string, Types.Link<unknown, number, number, 0 | 1>>} AccessDelegateDelegations\n */\n\n/**\n * Parsed Capability for access/delegate\n *\n * @typedef {object} ParsedAccessDelegate\n * @property {string} can\n * @property {object} nb\n * @property {AccessDelegateDelegations} [nb.delegations]\n */\n\n/**\n * returns whether the claimed ucan is proves by the proof ucan.\n * both are access/delegate, or at least have same semantics for `nb.delegations`, which is a set of delegations.\n * checks that the claimed delegation set is equal to or less than the proven delegation set.\n * usable with {import('@ucanto/interface').Derives}.\n *\n * @param {ParsedAccessDelegate} claim\n * @param {ParsedAccessDelegate} proof\n */\nfunction subsetsNbDelegations(claim, proof) {\n  const missingProofs = setDifference(\n    delegatedCids(claim),\n    new Set(delegatedCids(proof))\n  )\n  if (missingProofs.size > 0) {\n    return fail(`unauthorized nb.delegations ${[...missingProofs].join(', ')}`)\n  }\n  return ok({})\n}\n\n/**\n * Checks that set of requested capabilities is a subset of the capabilities\n * that had been allowed by the owner or the delegate.\n *\n * ⚠️ This function does not currently check that say `store/add` is allowed\n * when say `store/*` was delegated, because it seems very unlikely that we\n * will ever encounter delegations for `access/authorize` at all.\n *\n * @param {Schema.Infer<CapabilityRequest>[]} claim\n * @param {Schema.Infer<CapabilityRequest>[]} proof\n */\nconst subsetCapabilities = (claim, proof) => {\n  const allowed = new Set(proof.map((p) => p.can))\n  // If everything is allowed, no need to check further because it contains\n  // all the capabilities.\n  if (allowed.has('*')) {\n    return ok({})\n  }\n\n  // Otherwise we compute delta between what is allowed and what is requested.\n  const escalated = setDifference(\n    claim.map((c) => c.can),\n    allowed\n  )\n\n  if (escalated.size > 0) {\n    return fail(`unauthorized nb.att.can ${[...escalated].join(', ')}`)\n  }\n\n  return ok({})\n}\n\n/**\n * iterate delegated UCAN CIDs from an access/delegate capability.nb.delegations value.\n *\n * @param {ParsedAccessDelegate} delegate\n * @returns {Iterable<string>}\n */\nfunction* delegatedCids(delegate) {\n  for (const d of Object.values(delegate.nb.delegations || {})) {\n    yield d.toString()\n  }\n}\n\n/**\n * @template S\n * @param {Iterable<S>} minuend - set to subtract from\n * @param {Set<S>} subtrahend - subtracted from minuend\n */\nfunction setDifference(minuend, subtrahend) {\n  /** @type {Set<S>} */\n  const difference = new Set()\n  for (const e of minuend) {\n    if (!subtrahend.has(e)) {\n      difference.add(e)\n    }\n  }\n  return difference\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 858, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 864, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40web3-storage/capabilities/src/provider.js"],"sourcesContent":["/**\n * Provider Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as Provider from '@web3-storage/capabilities/provider'\n * ```\n *\n * @module\n */\nimport { capability, DID, struct, ok } from '@ucanto/validator'\nimport { AccountDID, equalWith, and, equal, SpaceDID } from './utils.js'\n\n// e.g. did:web:web3.storage or did:web:staging.web3.storage\nexport const Provider = DID.match({ method: 'web' })\n\nexport { AccountDID }\n\n/**\n * Capability can be invoked by an agent to add a provider to a space.\n */\nexport const add = capability({\n  can: 'provider/add',\n  with: AccountDID,\n  nb: struct({\n    provider: Provider,\n    consumer: SpaceDID,\n  }),\n  derives: (child, parent) => {\n    return (\n      and(equalWith(child, parent)) ||\n      and(equal(child.nb.provider, parent.nb.provider, 'provider')) ||\n      and(equal(child.nb.consumer, parent.nb.consumer, 'consumer')) ||\n      ok({})\n    )\n  },\n})\n"],"names":[],"mappings":"AAAA;;;;;;;;;CASC;;;;;;AACD;AAAA;AAAA;AAAA;AAAA;AACA;;;AAGO,MAAM,WAAW,2JAAG,CAAC,KAAK,CAAC;IAAE,QAAQ;AAAM;;AAO3C,MAAM,MAAM,IAAA,gOAAU,EAAC;IAC5B,KAAK;IACL,MAAM,kLAAU;IAChB,IAAI,IAAA,wKAAM,EAAC;QACT,UAAU;QACV,UAAU,gLAAQ;IACpB;IACA,SAAS,CAAC,OAAO;QACf,OACE,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,OAAO,YACrB,IAAA,2KAAG,EAAC,IAAA,6KAAK,EAAC,MAAM,EAAE,CAAC,QAAQ,EAAE,OAAO,EAAE,CAAC,QAAQ,EAAE,gBACjD,IAAA,2KAAG,EAAC,IAAA,6KAAK,EAAC,MAAM,EAAE,CAAC,QAAQ,EAAE,OAAO,EAAE,CAAC,QAAQ,EAAE,gBACjD,IAAA,0JAAE,EAAC,CAAC;IAER;AACF","ignoreList":[0]}},
    {"offset": {"line": 996, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40web3-storage/capabilities/src/consumer.js"],"sourcesContent":["import { capability, DID, struct, ok } from '@ucanto/validator'\nimport { equalWith, and, equal, SpaceDID } from './utils.js'\n\n// e.g. did:web:web3.storage or did:web:staging.web3.storage\nexport const ProviderDID = DID.match({ method: 'web' })\n\n/**\n * Capability can be invoked by a provider to check if it has given space as\n * a consumer.\n */\nexport const has = capability({\n  can: 'consumer/has',\n  with: ProviderDID,\n  nb: struct({\n    consumer: SpaceDID,\n  }),\n  derives: (child, parent) => {\n    return (\n      and(equalWith(child, parent)) ||\n      and(equal(child.nb.consumer, parent.nb.consumer, 'consumer')) ||\n      ok({})\n    )\n  },\n})\n\n/**\n * Capability can be invoked by a provider to get information about a consumer.\n */\nexport const get = capability({\n  can: 'consumer/get',\n  with: ProviderDID,\n  nb: struct({\n    consumer: SpaceDID,\n  }),\n  derives: (child, parent) => {\n    return (\n      and(equalWith(child, parent)) ||\n      and(equal(child.nb.consumer, parent.nb.consumer, 'consumer')) ||\n      ok({})\n    )\n  },\n})\n"],"names":[],"mappings":";;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAGO,MAAM,cAAc,2JAAG,CAAC,KAAK,CAAC;IAAE,QAAQ;AAAM;AAM9C,MAAM,MAAM,IAAA,gOAAU,EAAC;IAC5B,KAAK;IACL,MAAM;IACN,IAAI,IAAA,wKAAM,EAAC;QACT,UAAU,gLAAQ;IACpB;IACA,SAAS,CAAC,OAAO;QACf,OACE,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,OAAO,YACrB,IAAA,2KAAG,EAAC,IAAA,6KAAK,EAAC,MAAM,EAAE,CAAC,QAAQ,EAAE,OAAO,EAAE,CAAC,QAAQ,EAAE,gBACjD,IAAA,0JAAE,EAAC,CAAC;IAER;AACF;AAKO,MAAM,MAAM,IAAA,gOAAU,EAAC;IAC5B,KAAK;IACL,MAAM;IACN,IAAI,IAAA,wKAAM,EAAC;QACT,UAAU,gLAAQ;IACpB;IACA,SAAS,CAAC,OAAO;QACf,OACE,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,OAAO,YACrB,IAAA,2KAAG,EAAC,IAAA,6KAAK,EAAC,MAAM,EAAE,CAAC,QAAQ,EAAE,OAAO,EAAE,CAAC,QAAQ,EAAE,gBACjD,IAAA,0JAAE,EAAC,CAAC;IAER;AACF","ignoreList":[0]}},
    {"offset": {"line": 1039, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40web3-storage/capabilities/src/customer.js"],"sourcesContent":["import { capability, DID, struct, ok } from '@ucanto/validator'\nimport { AccountDID, equalWith, and, equal } from './utils.js'\n\n// e.g. did:web:web3.storage or did:web:staging.web3.storage\nexport const ProviderDID = DID.match({ method: 'web' })\n\n/**\n * Capability can be invoked by a provider to get information about the\n * customer.\n */\nexport const get = capability({\n  can: 'customer/get',\n  with: ProviderDID,\n  nb: struct({\n    customer: AccountDID,\n  }),\n  derives: (child, parent) => {\n    return (\n      and(equalWith(child, parent)) ||\n      and(equal(child.nb.customer, parent.nb.customer, 'customer')) ||\n      ok({})\n    )\n  },\n})\n"],"names":[],"mappings":";;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAGO,MAAM,cAAc,2JAAG,CAAC,KAAK,CAAC;IAAE,QAAQ;AAAM;AAM9C,MAAM,MAAM,IAAA,gOAAU,EAAC;IAC5B,KAAK;IACL,MAAM;IACN,IAAI,IAAA,wKAAM,EAAC;QACT,UAAU,kLAAU;IACtB;IACA,SAAS,CAAC,OAAO;QACf,OACE,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,OAAO,YACrB,IAAA,2KAAG,EAAC,IAAA,6KAAK,EAAC,MAAM,EAAE,CAAC,QAAQ,EAAE,OAAO,EAAE,CAAC,QAAQ,EAAE,gBACjD,IAAA,0JAAE,EAAC,CAAC;IAER;AACF","ignoreList":[0]}},
    {"offset": {"line": 1070, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40web3-storage/capabilities/src/console.js"],"sourcesContent":["import { capability, Schema } from '@ucanto/validator'\nimport { equalWith } from './utils.js'\n\nexport const console = capability({\n  can: 'console/*',\n  with: Schema.did(),\n  derives: equalWith,\n})\n\n/**\n * Capability that succeeds with the `nb.value` value.\n */\nexport const log = capability({\n  can: 'console/log',\n  with: Schema.did(),\n  nb: Schema.struct({\n    value: Schema.unknown(),\n  }),\n  derives: equalWith,\n})\n\n/**\n * Capability that fails with an error provided to `nb.error` field.\n */\nexport const error = capability({\n  can: 'console/error',\n  with: Schema.did(),\n  nb: Schema.struct({\n    error: Schema.unknown(),\n  }),\n  derives: equalWith,\n})\n"],"names":[],"mappings":";;;;;;;;AAAA;AAAA;AAAA;AACA;;;AAEO,MAAM,UAAU,IAAA,gOAAU,EAAC;IAChC,KAAK;IACL,MAAM,gMAAM,CAAC,GAAG;IAChB,SAAS,iLAAS;AACpB;AAKO,MAAM,MAAM,IAAA,gOAAU,EAAC;IAC5B,KAAK;IACL,MAAM,gMAAM,CAAC,GAAG;IAChB,IAAI,gMAAM,CAAC,MAAM,CAAC;QAChB,OAAO,gMAAM,CAAC,OAAO;IACvB;IACA,SAAS,iLAAS;AACpB;AAKO,MAAM,QAAQ,IAAA,gOAAU,EAAC;IAC9B,KAAK;IACL,MAAM,gMAAM,CAAC,GAAG;IAChB,IAAI,gMAAM,CAAC,MAAM,CAAC;QAChB,OAAO,gMAAM,CAAC,OAAO;IACvB;IACA,SAAS,iLAAS;AACpB","ignoreList":[0]}},
    {"offset": {"line": 1109, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40web3-storage/capabilities/src/rate-limit.js"],"sourcesContent":["/**\n * Rate Limit Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as RateLimit from '@web3-storage/capabilities/rate-limit'\n * ```\n *\n * @module\n */\nimport { capability, DID, struct, Schema, ok } from '@ucanto/validator'\nimport { equalWith, and, equal } from './utils.js'\n\n// e.g. did:web:web3.storage or did:web:staging.web3.storage\nexport const Provider = DID\n\n/**\n * Capability can be invoked by the provider or an authorized delegate to add a rate limit to a subject.\n */\nexport const add = capability({\n  can: 'rate-limit/add',\n  with: Provider,\n  nb: struct({\n    subject: Schema.string(),\n    rate: Schema.number(),\n  }),\n  derives: (child, parent) => {\n    return (\n      and(equalWith(child, parent)) ||\n      and(equal(child.nb.subject, parent.nb.subject, 'subject')) ||\n      and(equal(child.nb.rate, parent.nb.rate, 'rate')) ||\n      ok({})\n    )\n  },\n})\n\n/**\n * Capability can be invoked by the provider are an authorized delegate to remove rate limits from a subject.\n */\nexport const remove = capability({\n  can: 'rate-limit/remove',\n  with: Provider,\n  nb: struct({\n    id: Schema.string(),\n  }),\n  derives: (child, parent) => {\n    return (\n      and(equalWith(child, parent)) ||\n      and(equal(child.nb.id, parent.nb.id, 'id')) ||\n      ok({})\n    )\n  },\n})\n\n/**\n * Capability can be invoked by the provider or an authorized delegate to list rate limits on the given subject\n */\nexport const list = capability({\n  can: 'rate-limit/list',\n  with: Provider,\n  nb: struct({\n    subject: Schema.string(),\n  }),\n  derives: (child, parent) => {\n    return (\n      and(equalWith(child, parent)) ||\n      and(equal(child.nb.subject, parent.nb.subject, 'subject')) ||\n      ok({})\n    )\n  },\n})\n"],"names":[],"mappings":"AAAA;;;;;;;;;CASC;;;;;;;;;;AACD;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAGO,MAAM,WAAW,2JAAG;AAKpB,MAAM,MAAM,IAAA,gOAAU,EAAC;IAC5B,KAAK;IACL,MAAM;IACN,IAAI,IAAA,wKAAM,EAAC;QACT,SAAS,gMAAM,CAAC,MAAM;QACtB,MAAM,gMAAM,CAAC,MAAM;IACrB;IACA,SAAS,CAAC,OAAO;QACf,OACE,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,OAAO,YACrB,IAAA,2KAAG,EAAC,IAAA,6KAAK,EAAC,MAAM,EAAE,CAAC,OAAO,EAAE,OAAO,EAAE,CAAC,OAAO,EAAE,eAC/C,IAAA,2KAAG,EAAC,IAAA,6KAAK,EAAC,MAAM,EAAE,CAAC,IAAI,EAAE,OAAO,EAAE,CAAC,IAAI,EAAE,YACzC,IAAA,0JAAE,EAAC,CAAC;IAER;AACF;AAKO,MAAM,SAAS,IAAA,gOAAU,EAAC;IAC/B,KAAK;IACL,MAAM;IACN,IAAI,IAAA,wKAAM,EAAC;QACT,IAAI,gMAAM,CAAC,MAAM;IACnB;IACA,SAAS,CAAC,OAAO;QACf,OACE,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,OAAO,YACrB,IAAA,2KAAG,EAAC,IAAA,6KAAK,EAAC,MAAM,EAAE,CAAC,EAAE,EAAE,OAAO,EAAE,CAAC,EAAE,EAAE,UACrC,IAAA,0JAAE,EAAC,CAAC;IAER;AACF;AAKO,MAAM,OAAO,IAAA,gOAAU,EAAC;IAC7B,KAAK;IACL,MAAM;IACN,IAAI,IAAA,wKAAM,EAAC;QACT,SAAS,gMAAM,CAAC,MAAM;IACxB;IACA,SAAS,CAAC,OAAO;QACf,OACE,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,OAAO,YACrB,IAAA,2KAAG,EAAC,IAAA,6KAAK,EAAC,MAAM,EAAE,CAAC,OAAO,EAAE,OAAO,EAAE,CAAC,OAAO,EAAE,eAC/C,IAAA,0JAAE,EAAC,CAAC;IAER;AACF","ignoreList":[0]}},
    {"offset": {"line": 1173, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40web3-storage/capabilities/src/admin.js"],"sourcesContent":["import { capability, struct, ok, Link } from '@ucanto/validator'\nimport { equalWith, and, equal, ProviderDID } from './utils.js'\n\nexport const admin = capability({\n  can: 'admin/*',\n  with: ProviderDID,\n  derives: equalWith,\n})\n\nexport const upload = {\n  /**\n   * Capability can be invoked by a provider to get information about a content CID.\n   */\n  inspect: capability({\n    can: 'admin/upload/inspect',\n    with: ProviderDID,\n    nb: struct({\n      root: Link,\n    }),\n    derives: (child, parent) => {\n      return (\n        and(equalWith(child, parent)) ||\n        and(equal(child.nb.root, parent.nb.root, 'root')) ||\n        ok({})\n      )\n    },\n  }),\n}\n\nexport const store = {\n  /**\n   * Capability can be invoked by a provider to get information an upload shard CID.\n   */\n  inspect: capability({\n    can: 'admin/store/inspect',\n    with: ProviderDID,\n    nb: struct({\n      link: Link,\n    }),\n    derives: (child, parent) => {\n      return (\n        and(equalWith(child, parent)) ||\n        and(equal(child.nb.link, parent.nb.link, 'link')) ||\n        ok({})\n      )\n    },\n  }),\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAEO,MAAM,QAAQ,IAAA,gOAAU,EAAC;IAC9B,KAAK;IACL,MAAM,mLAAW;IACjB,SAAS,iLAAS;AACpB;AAEO,MAAM,SAAS;IACpB;;GAEC,GACD,SAAS,IAAA,gOAAU,EAAC;QAClB,KAAK;QACL,MAAM,mLAAW;QACjB,IAAI,IAAA,wKAAM,EAAC;YACT,MAAM,4JAAI;QACZ;QACA,SAAS,CAAC,OAAO;YACf,OACE,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,OAAO,YACrB,IAAA,2KAAG,EAAC,IAAA,6KAAK,EAAC,MAAM,EAAE,CAAC,IAAI,EAAE,OAAO,EAAE,CAAC,IAAI,EAAE,YACzC,IAAA,0JAAE,EAAC,CAAC;QAER;IACF;AACF;AAEO,MAAM,QAAQ;IACnB;;GAEC,GACD,SAAS,IAAA,gOAAU,EAAC;QAClB,KAAK;QACL,MAAM,mLAAW;QACjB,IAAI,IAAA,wKAAM,EAAC;YACT,MAAM,4JAAI;QACZ;QACA,SAAS,CAAC,OAAO;YACf,OACE,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,OAAO,YACrB,IAAA,2KAAG,EAAC,IAAA,6KAAK,EAAC,MAAM,EAAE,CAAC,IAAI,EAAE,OAAO,EAAE,CAAC,IAAI,EAAE,YACzC,IAAA,0JAAE,EAAC,CAAC;QAER;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 1226, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40web3-storage/capabilities/src/subscription.js"],"sourcesContent":["import { capability, DID, struct, ok, Schema } from '@ucanto/validator'\nimport { AccountDID, equalWith, and, equal } from './utils.js'\n\n// e.g. did:web:web3.storage or did:web:staging.web3.storage\nexport const ProviderDID = DID.match({ method: 'web' })\n\n/**\n * Capability can be invoked by a provider to get information about a subscription.\n */\nexport const get = capability({\n  can: 'subscription/get',\n  with: ProviderDID,\n  nb: struct({\n    subscription: Schema.string(),\n  }),\n  derives: (child, parent) => {\n    return (\n      and(equalWith(child, parent)) ||\n      and(equal(child.nb.subscription, parent.nb.subscription, 'consumer')) ||\n      ok({})\n    )\n  },\n})\n\n/**\n * Capability can be invoked to retrieve the list of subscriptions for an\n * account.\n */\nexport const list = capability({\n  can: 'subscription/list',\n  with: AccountDID,\n  derives: equalWith,\n})\n"],"names":[],"mappings":";;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAGO,MAAM,cAAc,2JAAG,CAAC,KAAK,CAAC;IAAE,QAAQ;AAAM;AAK9C,MAAM,MAAM,IAAA,gOAAU,EAAC;IAC5B,KAAK;IACL,MAAM;IACN,IAAI,IAAA,wKAAM,EAAC;QACT,cAAc,gMAAM,CAAC,MAAM;IAC7B;IACA,SAAS,CAAC,OAAO;QACf,OACE,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,OAAO,YACrB,IAAA,2KAAG,EAAC,IAAA,6KAAK,EAAC,MAAM,EAAE,CAAC,YAAY,EAAE,OAAO,EAAE,CAAC,YAAY,EAAE,gBACzD,IAAA,0JAAE,EAAC,CAAC;IAER;AACF;AAMO,MAAM,OAAO,IAAA,gOAAU,EAAC;IAC7B,KAAK;IACL,MAAM,kLAAU;IAChB,SAAS,iLAAS;AACpB","ignoreList":[0]}},
    {"offset": {"line": 1265, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40web3-storage/capabilities/src/filecoin/lib.js"],"sourcesContent":["import { Schema } from '@ucanto/validator'\n\n/**\n * @see https://github.com/filecoin-project/FIPs/pull/758/files\n */\nconst FR32_SHA2_256_TRUNC254_PADDED_BINARY_TREE = /** @type {const} */ (0x1011)\n/**\n * @see https://github.com/filecoin-project/FIPs/pull/758/files\n */\nconst RAW_CODE = /** @type {const} */ (0x55)\n\nexport const PieceLink = /** @type {import('../types.js').PieceLinkSchema} */ (\n  Schema.link({\n    code: RAW_CODE,\n    version: 1,\n    multihash: {\n      code: FR32_SHA2_256_TRUNC254_PADDED_BINARY_TREE,\n    },\n  })\n)\n"],"names":[],"mappings":";;;;AAAA;AAAA;;AAEA;;CAEC,GACD,MAAM,4CAAkE;AACxE;;CAEC,GACD,MAAM,WAAiC;AAEhC,MAAM,YACX,gMAAM,CAAC,IAAI,CAAC;IACV,MAAM;IACN,SAAS;IACT,WAAW;QACT,MAAM;IACR;AACF","ignoreList":[0]}},
    {"offset": {"line": 1289, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40web3-storage/capabilities/src/filecoin/storefront.js"],"sourcesContent":["/**\n * Filecoin Storefront Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as Storefront from '@web3-storage/capabilities/filecoin/storefront'\n * ```\n *\n * @module\n */\n\nimport { capability, Schema, ok } from '@ucanto/validator'\nimport { PieceLink } from './lib.js'\nimport { equalWith, checkLink, and } from '../utils.js'\n\n/**\n * Top-level capability for Filecoin operations.\n */\nexport const filecoin = capability({\n  can: 'filecoin/*',\n  /**\n   * DID of the space the content is stored in.\n   */\n  with: Schema.did(),\n  derives: equalWith,\n})\n\n/**\n * Capability allowing an agent to _request_ storing a content piece in\n * Filecoin.\n */\nexport const filecoinOffer = capability({\n  can: 'filecoin/offer',\n  /**\n   * DID of the space the content is stored in.\n   */\n  with: Schema.did(),\n  nb: Schema.struct({\n    /**\n     * CID of the content that resulted in Filecoin piece.\n     */\n    content: Schema.link(),\n    /**\n     * CID of the piece.\n     */\n    piece: PieceLink,\n  }),\n  derives: (claim, from) => {\n    return (\n      and(equalWith(claim, from)) ||\n      and(checkLink(claim.nb.content, from.nb.content, 'nb.content')) ||\n      and(checkLink(claim.nb.piece, from.nb.piece, 'nb.piece')) ||\n      ok({})\n    )\n  },\n})\n\n/**\n * Capability allowing a Storefront to signal that an offered piece has been\n * submitted to the filecoin storage pipeline.\n */\nexport const filecoinSubmit = capability({\n  can: 'filecoin/submit',\n  /**\n   * DID of the Storefront.\n   */\n  with: Schema.did(),\n  nb: Schema.struct({\n    /**\n     * CID of the content that resulted in Filecoin piece.\n     */\n    content: Schema.link(),\n    /**\n     * CID of the piece.\n     *\n     * @see https://github.com/filecoin-project/FIPs/pull/758/files\n     */\n    piece: PieceLink,\n  }),\n  derives: (claim, from) => {\n    return (\n      and(equalWith(claim, from)) ||\n      and(checkLink(claim.nb.content, from.nb.content, 'nb.content')) ||\n      and(checkLink(claim.nb.piece, from.nb.piece, 'nb.piece')) ||\n      ok({})\n    )\n  },\n})\n\n/**\n * Capability allowing a Storefront to signal that a submitted piece has been\n * accepted in a Filecoin deal. The receipt contains the proof.\n */\nexport const filecoinAccept = capability({\n  can: 'filecoin/accept',\n  /**\n   * DID of the Storefront.\n   */\n  with: Schema.did(),\n  nb: Schema.struct({\n    /**\n     * CID of the content that resulted in Filecoin piece.\n     */\n    content: Schema.link(),\n    /**\n     * CID of the piece.\n     *\n     * @see https://github.com/filecoin-project/FIPs/pull/758/files\n     */\n    piece: PieceLink,\n  }),\n  derives: (claim, from) => {\n    return (\n      and(equalWith(claim, from)) ||\n      and(checkLink(claim.nb.content, from.nb.content, 'nb.content')) ||\n      and(checkLink(claim.nb.piece, from.nb.piece, 'nb.piece')) ||\n      ok({})\n    )\n  },\n})\n\n/**\n * Capability allowing an agent to _request_ info about a content piece in\n * Filecoin deals.\n */\nexport const filecoinInfo = capability({\n  can: 'filecoin/info',\n  /**\n   * DID of the space the content is stored in.\n   */\n  with: Schema.did(),\n  nb: Schema.struct({\n    /**\n     * CID of the piece.\n     *\n     * @see https://github.com/filecoin-project/FIPs/pull/758/files\n     */\n    piece: PieceLink,\n  }),\n  derives: (claim, from) => {\n    return (\n      and(equalWith(claim, from)) ||\n      and(checkLink(claim.nb.piece, from.nb.piece, 'nb.piece')) ||\n      ok({})\n    )\n  },\n})\n"],"names":[],"mappings":"AAAA;;;;;;;;;CASC;;;;;;;;;;;;AAED;AAAA;AAAA;AAAA;AACA;AACA;;;;AAKO,MAAM,WAAW,IAAA,gOAAU,EAAC;IACjC,KAAK;IACL;;GAEC,GACD,MAAM,gMAAM,CAAC,GAAG;IAChB,SAAS,iLAAS;AACpB;AAMO,MAAM,gBAAgB,IAAA,gOAAU,EAAC;IACtC,KAAK;IACL;;GAEC,GACD,MAAM,gMAAM,CAAC,GAAG;IAChB,IAAI,gMAAM,CAAC,MAAM,CAAC;QAChB;;KAEC,GACD,SAAS,gMAAM,CAAC,IAAI;QACpB;;KAEC,GACD,OAAO,2LAAS;IAClB;IACA,SAAS,CAAC,OAAO;QACf,OACE,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,OAAO,UACrB,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,MAAM,EAAE,CAAC,OAAO,EAAE,KAAK,EAAE,CAAC,OAAO,EAAE,kBACjD,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,MAAM,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,KAAK,EAAE,gBAC7C,IAAA,0JAAE,EAAC,CAAC;IAER;AACF;AAMO,MAAM,iBAAiB,IAAA,gOAAU,EAAC;IACvC,KAAK;IACL;;GAEC,GACD,MAAM,gMAAM,CAAC,GAAG;IAChB,IAAI,gMAAM,CAAC,MAAM,CAAC;QAChB;;KAEC,GACD,SAAS,gMAAM,CAAC,IAAI;QACpB;;;;KAIC,GACD,OAAO,2LAAS;IAClB;IACA,SAAS,CAAC,OAAO;QACf,OACE,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,OAAO,UACrB,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,MAAM,EAAE,CAAC,OAAO,EAAE,KAAK,EAAE,CAAC,OAAO,EAAE,kBACjD,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,MAAM,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,KAAK,EAAE,gBAC7C,IAAA,0JAAE,EAAC,CAAC;IAER;AACF;AAMO,MAAM,iBAAiB,IAAA,gOAAU,EAAC;IACvC,KAAK;IACL;;GAEC,GACD,MAAM,gMAAM,CAAC,GAAG;IAChB,IAAI,gMAAM,CAAC,MAAM,CAAC;QAChB;;KAEC,GACD,SAAS,gMAAM,CAAC,IAAI;QACpB;;;;KAIC,GACD,OAAO,2LAAS;IAClB;IACA,SAAS,CAAC,OAAO;QACf,OACE,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,OAAO,UACrB,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,MAAM,EAAE,CAAC,OAAO,EAAE,KAAK,EAAE,CAAC,OAAO,EAAE,kBACjD,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,MAAM,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,KAAK,EAAE,gBAC7C,IAAA,0JAAE,EAAC,CAAC;IAER;AACF;AAMO,MAAM,eAAe,IAAA,gOAAU,EAAC;IACrC,KAAK;IACL;;GAEC,GACD,MAAM,gMAAM,CAAC,GAAG;IAChB,IAAI,gMAAM,CAAC,MAAM,CAAC;QAChB;;;;KAIC,GACD,OAAO,2LAAS;IAClB;IACA,SAAS,CAAC,OAAO;QACf,OACE,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,OAAO,UACrB,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,MAAM,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,KAAK,EAAE,gBAC7C,IAAA,0JAAE,EAAC,CAAC;IAER;AACF","ignoreList":[0]}},
    {"offset": {"line": 1401, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40web3-storage/capabilities/src/filecoin/index.js"],"sourcesContent":["/**\n * Filecoin Capabilities\n *\n * These capabilities are the entrypoint to the filecoin pipeline and are\n * aliases for the filecoin storefront capabilities.\n *\n * These can be imported directly with:\n * ```js\n * import * as Filecoin from '@web3-storage/capabilities/filecoin'\n * ```\n *\n * @module\n */\n\nexport {\n  filecoinOffer as offer,\n  filecoinSubmit as submit,\n  filecoinAccept as accept,\n  filecoinInfo as info,\n  filecoin as filecoin,\n} from './storefront.js'\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;CAYC;AAED","ignoreList":[0]}},
    {"offset": {"line": 1438, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40web3-storage/capabilities/src/filecoin/aggregator.js"],"sourcesContent":["/**\n * Filecoin Aggregator Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as Aggregator from '@web3-storage/capabilities/filecoin/aggregator'\n * ```\n *\n * @module\n */\n\nimport { capability, Schema, ok } from '@ucanto/validator'\nimport { PieceLink } from './lib.js'\nimport { equal, equalWith, checkLink, and } from '../utils.js'\n\n/**\n * Capability that allows a Storefront to request that a piece be aggregated\n * for inclusion in an upcoming an Filecoin deal.\n */\nexport const pieceOffer = capability({\n  can: 'piece/offer',\n  /**\n   * DID of an authorized Storefront.\n   */\n  with: Schema.did(),\n  nb: Schema.struct({\n    /**\n     * CID of the piece.\n     */\n    piece: PieceLink,\n    /**\n     * Grouping of joining segments into an aggregate.\n     */\n    group: Schema.text(),\n  }),\n  derives: (claim, from) => {\n    return (\n      and(equalWith(claim, from)) ||\n      and(checkLink(claim.nb.piece, from.nb.piece, 'nb.piece')) ||\n      and(equal(claim.nb.group, from.nb.group, 'nb.group')) ||\n      ok({})\n    )\n  },\n})\n\n/**\n * Capability that allows an Aggregator to signal a piece has been accepted\n * or rejected for inclusion in an aggregate.\n */\nexport const pieceAccept = capability({\n  can: 'piece/accept',\n  /**\n   * DID of the Aggregator.\n   */\n  with: Schema.did(),\n  nb: Schema.struct({\n    /**\n     * CID of the piece.\n     *\n     * @see https://github.com/filecoin-project/FIPs/pull/758/files\n     */\n    piece: PieceLink,\n    /**\n     * Grouping of joining segments into an aggregate.\n     */\n    group: Schema.text(),\n  }),\n  derives: (claim, from) => {\n    return (\n      and(equalWith(claim, from)) ||\n      and(checkLink(claim.nb.piece, from.nb.piece, 'nb.piece')) ||\n      and(equal(claim.nb.group, from.nb.group, 'nb.group')) ||\n      ok({})\n    )\n  },\n})\n"],"names":[],"mappings":"AAAA;;;;;;;;;CASC;;;;;;AAED;AAAA;AAAA;AAAA;AACA;AACA;;;;AAMO,MAAM,aAAa,IAAA,gOAAU,EAAC;IACnC,KAAK;IACL;;GAEC,GACD,MAAM,gMAAM,CAAC,GAAG;IAChB,IAAI,gMAAM,CAAC,MAAM,CAAC;QAChB;;KAEC,GACD,OAAO,2LAAS;QAChB;;KAEC,GACD,OAAO,gMAAM,CAAC,IAAI;IACpB;IACA,SAAS,CAAC,OAAO;QACf,OACE,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,OAAO,UACrB,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,MAAM,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,KAAK,EAAE,gBAC7C,IAAA,2KAAG,EAAC,IAAA,6KAAK,EAAC,MAAM,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,KAAK,EAAE,gBACzC,IAAA,0JAAE,EAAC,CAAC;IAER;AACF;AAMO,MAAM,cAAc,IAAA,gOAAU,EAAC;IACpC,KAAK;IACL;;GAEC,GACD,MAAM,gMAAM,CAAC,GAAG;IAChB,IAAI,gMAAM,CAAC,MAAM,CAAC;QAChB;;;;KAIC,GACD,OAAO,2LAAS;QAChB;;KAEC,GACD,OAAO,gMAAM,CAAC,IAAI;IACpB;IACA,SAAS,CAAC,OAAO;QACf,OACE,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,OAAO,UACrB,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,MAAM,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,KAAK,EAAE,gBAC7C,IAAA,2KAAG,EAAC,IAAA,6KAAK,EAAC,MAAM,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,KAAK,EAAE,gBACzC,IAAA,0JAAE,EAAC,CAAC;IAER;AACF","ignoreList":[0]}},
    {"offset": {"line": 1502, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40web3-storage/capabilities/src/filecoin/dealer.js"],"sourcesContent":["/**\n * Filecoin Dealer Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as Dealer from '@web3-storage/capabilities/filecoin/dealer'\n * ```\n *\n * @module\n */\n\nimport { capability, Schema, ok } from '@ucanto/validator'\nimport { PieceLink } from './lib.js'\nimport { equalWith, checkLink, and } from '../utils.js'\n\n/**\n * Capability allowing an Aggregator to request an aggregate to be added to a\n * deal with a Storage Provider.\n */\nexport const aggregateOffer = capability({\n  can: 'aggregate/offer',\n  /**\n   * DID of an authorized Storefront.\n   */\n  with: Schema.did(),\n  nb: Schema.struct({\n    /**\n     * Commitment proof for the aggregate being offered.\n     */\n    aggregate: PieceLink,\n    /**\n     * CID of the DAG-CBOR encoded block with offer details.\n     * Service will queue given offer to be validated and handled.\n     */\n    pieces: Schema.link({ version: 1 }),\n  }),\n  derives: (claim, from) => {\n    return (\n      and(equalWith(claim, from)) ||\n      and(checkLink(claim.nb.aggregate, from.nb.aggregate, 'nb.aggregate')) ||\n      and(checkLink(claim.nb.pieces, from.nb.pieces, 'nb.pieces')) ||\n      ok({})\n    )\n  },\n})\n\n/**\n * Capability that allows a Dealer to signal an aggregate has been accepted\n * for inclusion in a Filecoin deal.\n */\nexport const aggregateAccept = capability({\n  can: 'aggregate/accept',\n  /**\n   * did:key identifier of the broker authority where offer is made available.\n   */\n  with: Schema.did(),\n  nb: Schema.struct({\n    /**\n     * Commitment proof for the aggregate being offered.\n     */\n    aggregate: PieceLink,\n    /**\n     * CID of the DAG-CBOR encoded block with offer details.\n     * Service will queue given offer to be validated and handled.\n     */\n    pieces: Schema.link(),\n  }),\n  derives: (claim, from) => {\n    return (\n      and(equalWith(claim, from)) ||\n      and(checkLink(claim.nb.aggregate, from.nb.aggregate, 'nb.aggregate')) ||\n      and(checkLink(claim.nb.pieces, from.nb.pieces, 'nb.pieces')) ||\n      ok({})\n    )\n  },\n})\n"],"names":[],"mappings":"AAAA;;;;;;;;;CASC;;;;;;AAED;AAAA;AAAA;AAAA;AACA;AACA;;;;AAMO,MAAM,iBAAiB,IAAA,gOAAU,EAAC;IACvC,KAAK;IACL;;GAEC,GACD,MAAM,gMAAM,CAAC,GAAG;IAChB,IAAI,gMAAM,CAAC,MAAM,CAAC;QAChB;;KAEC,GACD,WAAW,2LAAS;QACpB;;;KAGC,GACD,QAAQ,gMAAM,CAAC,IAAI,CAAC;YAAE,SAAS;QAAE;IACnC;IACA,SAAS,CAAC,OAAO;QACf,OACE,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,OAAO,UACrB,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,MAAM,EAAE,CAAC,SAAS,EAAE,KAAK,EAAE,CAAC,SAAS,EAAE,oBACrD,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,MAAM,EAAE,CAAC,MAAM,EAAE,KAAK,EAAE,CAAC,MAAM,EAAE,iBAC/C,IAAA,0JAAE,EAAC,CAAC;IAER;AACF;AAMO,MAAM,kBAAkB,IAAA,gOAAU,EAAC;IACxC,KAAK;IACL;;GAEC,GACD,MAAM,gMAAM,CAAC,GAAG;IAChB,IAAI,gMAAM,CAAC,MAAM,CAAC;QAChB;;KAEC,GACD,WAAW,2LAAS;QACpB;;;KAGC,GACD,QAAQ,gMAAM,CAAC,IAAI;IACrB;IACA,SAAS,CAAC,OAAO;QACf,OACE,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,OAAO,UACrB,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,MAAM,EAAE,CAAC,SAAS,EAAE,KAAK,EAAE,CAAC,SAAS,EAAE,oBACrD,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,MAAM,EAAE,CAAC,MAAM,EAAE,KAAK,EAAE,CAAC,MAAM,EAAE,iBAC/C,IAAA,0JAAE,EAAC,CAAC;IAER;AACF","ignoreList":[0]}},
    {"offset": {"line": 1568, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40web3-storage/capabilities/src/filecoin/deal-tracker.js"],"sourcesContent":["/**\n * Filecoin Deal Tracker Capabilities\n *\n * These can be imported directly with:\n * ```js\n * import * as DealTracker from '@web3-storage/capabilities/filecoin/deal-tracker'\n * ```\n *\n * @module\n */\n\nimport { capability, Schema, ok } from '@ucanto/validator'\nimport { PieceLink } from './lib.js'\nimport { equalWith, checkLink, and } from '../utils.js'\n\n/**\n * Capability allowing a Storefront or Aggregator to obtain deal information\n * for a given aggregate piece.\n */\nexport const dealInfo = capability({\n  can: 'deal/info',\n  /**\n   * DID of the Storefront.\n   */\n  with: Schema.did(),\n  nb: Schema.struct({\n    /**\n     * CID of the piece.\n     *\n     * @see https://github.com/filecoin-project/FIPs/pull/758/files\n     */\n    piece: PieceLink,\n  }),\n  derives: (claim, from) => {\n    return (\n      and(equalWith(claim, from)) ||\n      and(checkLink(claim.nb.piece, from.nb.piece, 'nb.piece')) ||\n      ok({})\n    )\n  },\n})\n"],"names":[],"mappings":"AAAA;;;;;;;;;CASC;;;;AAED;AAAA;AAAA;AAAA;AACA;AACA;;;;AAMO,MAAM,WAAW,IAAA,gOAAU,EAAC;IACjC,KAAK;IACL;;GAEC,GACD,MAAM,gMAAM,CAAC,GAAG;IAChB,IAAI,gMAAM,CAAC,MAAM,CAAC;QAChB;;;;KAIC,GACD,OAAO,2LAAS;IAClB;IACA,SAAS,CAAC,OAAO;QACf,OACE,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,OAAO,UACrB,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,MAAM,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,KAAK,EAAE,gBAC7C,IAAA,0JAAE,EAAC,CAAC;IAER;AACF","ignoreList":[0]}},
    {"offset": {"line": 1610, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40web3-storage/capabilities/src/index/index.js"],"sourcesContent":["/**\n * Index Capabilities.\n *\n * W3 Indexing protocol allows authorized agents to submit verifiable claims\n * about content-addressed data to be published on the InterPlanetary Network\n * Indexer (IPNI), making it publicly queryable.\n *\n * These can be imported directly with:\n * ```js\n * import * as Index from '@web3-storage/capabilities/index'\n * ```\n *\n * @module\n */\nimport { CAR } from '@ucanto/core'\nimport { capability, Schema, ok } from '@ucanto/validator'\nimport { equalWith, SpaceDID, and, equal } from '../utils.js'\n\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derive any `space/index/` prefixed capability for the space identified by the DID\n * in the `with` field.\n */\nexport const index = capability({\n  can: 'space/index/*',\n  /** DID of the space where indexed data is stored. */\n  with: SpaceDID,\n  derives: equalWith,\n})\n\n/**\n * `space/index/add` capability allows an agent to submit verifiable claims\n * about content-addressed data to be published on the InterPlanetary Network\n * Indexer (IPNI), making it publicly queryable.\n */\nexport const add = capability({\n  can: 'space/index/add',\n  /** DID of the space where indexed data is stored. */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /** Content Archive (CAR) containing the `Index`. */\n    index: Schema.link({ code: CAR.code, version: 1 }),\n  }),\n  derives: (claimed, delegated) =>\n    and(equalWith(claimed, delegated)) ||\n    and(equal(claimed.nb.index, delegated.nb.index, 'index')) ||\n    ok({}),\n})\n\n// ⚠️ We export imports here so they are not omitted in generated typedefs\n// @see https://github.com/microsoft/TypeScript/issues/51548\nexport { Schema }\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;CAaC;;;;;;AACD;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;AAOO,MAAM,QAAQ,IAAA,gOAAU,EAAC;IAC9B,KAAK;IACL,mDAAmD,GACnD,MAAM,gLAAQ;IACd,SAAS,iLAAS;AACpB;AAOO,MAAM,MAAM,IAAA,gOAAU,EAAC;IAC5B,KAAK;IACL,mDAAmD,GACnD,MAAM,gLAAQ;IACd,IAAI,gMAAM,CAAC,MAAM,CAAC;QAChB,kDAAkD,GAClD,OAAO,gMAAM,CAAC,IAAI,CAAC;YAAE,MAAM,uLAAG,CAAC,IAAI;YAAE,SAAS;QAAE;IAClD;IACA,SAAS,CAAC,SAAS,YACjB,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,SAAS,eACvB,IAAA,2KAAG,EAAC,IAAA,6KAAK,EAAC,QAAQ,EAAE,CAAC,KAAK,EAAE,UAAU,EAAE,CAAC,KAAK,EAAE,aAChD,IAAA,0JAAE,EAAC,CAAC;AACR","ignoreList":[0]}},
    {"offset": {"line": 1674, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40web3-storage/capabilities/src/plan.js"],"sourcesContent":["import { DID, Schema, capability, ok, struct } from '@ucanto/validator'\nimport { AccountDID, equal, equalWith, and } from './utils.js'\n\n/**\n * Capability can be invoked by an account to get information about\n * the plan it is currently signed up for.\n */\nexport const get = capability({\n  can: 'plan/get',\n  with: AccountDID,\n  derives: (child, parent) => {\n    return and(equalWith(child, parent)) || ok({})\n  },\n})\n\n/**\n * Capability can be invoked by an account to change its billing plan.\n */\nexport const set = capability({\n  can: 'plan/set',\n  with: AccountDID,\n  nb: struct({\n    product: DID,\n  }),\n  derives: (child, parent) => {\n    return (\n      and(equalWith(child, parent)) ||\n      and(equal(child.nb.product, parent.nb.product, 'product')) ||\n      ok({})\n    )\n  },\n})\n\n/**\n * Capability can be invoked by an account to generate a billing admin session.\n *\n * May not be possible with all billing providers - this is designed with\n * https://docs.stripe.com/api/customer_portal/sessions/create in mind.\n */\nexport const createAdminSession = capability({\n  can: 'plan/create-admin-session',\n  with: AccountDID,\n  nb: struct({\n    returnURL: Schema.string(),\n  }),\n  derives: (child, parent) => {\n    return (\n      and(equalWith(child, parent)) ||\n      and(equal(child.nb.returnURL, parent.nb.returnURL, 'returnURL')) ||\n      ok({})\n    )\n  },\n})\n"],"names":[],"mappings":";;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAMO,MAAM,MAAM,IAAA,gOAAU,EAAC;IAC5B,KAAK;IACL,MAAM,kLAAU;IAChB,SAAS,CAAC,OAAO;QACf,OAAO,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,OAAO,YAAY,IAAA,0JAAE,EAAC,CAAC;IAC9C;AACF;AAKO,MAAM,MAAM,IAAA,gOAAU,EAAC;IAC5B,KAAK;IACL,MAAM,kLAAU;IAChB,IAAI,IAAA,wKAAM,EAAC;QACT,SAAS,2JAAG;IACd;IACA,SAAS,CAAC,OAAO;QACf,OACE,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,OAAO,YACrB,IAAA,2KAAG,EAAC,IAAA,6KAAK,EAAC,MAAM,EAAE,CAAC,OAAO,EAAE,OAAO,EAAE,CAAC,OAAO,EAAE,eAC/C,IAAA,0JAAE,EAAC,CAAC;IAER;AACF;AAQO,MAAM,qBAAqB,IAAA,gOAAU,EAAC;IAC3C,KAAK;IACL,MAAM,kLAAU;IAChB,IAAI,IAAA,wKAAM,EAAC;QACT,WAAW,gMAAM,CAAC,MAAM;IAC1B;IACA,SAAS,CAAC,OAAO;QACf,OACE,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,OAAO,YACrB,IAAA,2KAAG,EAAC,IAAA,6KAAK,EAAC,MAAM,EAAE,CAAC,SAAS,EAAE,OAAO,EAAE,CAAC,SAAS,EAAE,iBACnD,IAAA,0JAAE,EAAC,CAAC;IAER;AACF","ignoreList":[0]}},
    {"offset": {"line": 1722, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40web3-storage/capabilities/src/usage.js"],"sourcesContent":["import { capability, ok, Schema } from '@ucanto/validator'\nimport { and, equal, equalWith, SpaceDID } from './utils.js'\n\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * be derived any `usage/` prefixed capability for the (memory) space identified\n * by DID in the `with` field.\n */\nexport const usage = capability({\n  can: 'usage/*',\n  /** DID of the (memory) space where usage is derived. */\n  with: SpaceDID,\n  derives: equalWith,\n})\n\n/**\n * Capability can be invoked by an agent to retrieve usage data for a space in\n * a given period.\n */\nexport const report = capability({\n  can: 'usage/report',\n  with: SpaceDID,\n  nb: Schema.struct({\n    /** Period to retrieve events between. */\n    period: Schema.struct({\n      /** Time in seconds after Unix epoch (inclusive). */\n      from: Schema.integer().greaterThan(-1),\n      /** Time in seconds after Unix epoch (exclusive). */\n      to: Schema.integer().greaterThan(-1),\n    }),\n  }),\n  derives: (child, parent) => {\n    return (\n      and(equalWith(child, parent)) ||\n      and(\n        equal(child.nb.period?.from, parent.nb.period?.from, 'period.from')\n      ) ||\n      and(equal(child.nb.period?.to, parent.nb.period?.to, 'period.to')) ||\n      ok({})\n    )\n  },\n})\n"],"names":[],"mappings":";;;;;;AAAA;AAAA;AAAA;AAAA;AACA;;;AAOO,MAAM,QAAQ,IAAA,gOAAU,EAAC;IAC9B,KAAK;IACL,sDAAsD,GACtD,MAAM,gLAAQ;IACd,SAAS,iLAAS;AACpB;AAMO,MAAM,SAAS,IAAA,gOAAU,EAAC;IAC/B,KAAK;IACL,MAAM,gLAAQ;IACd,IAAI,gMAAM,CAAC,MAAM,CAAC;QAChB,uCAAuC,GACvC,QAAQ,gMAAM,CAAC,MAAM,CAAC;YACpB,kDAAkD,GAClD,MAAM,gMAAM,CAAC,OAAO,GAAG,WAAW,CAAC,CAAC;YACpC,kDAAkD,GAClD,IAAI,gMAAM,CAAC,OAAO,GAAG,WAAW,CAAC,CAAC;QACpC;IACF;IACA,SAAS,CAAC,OAAO;QACf,OACE,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,OAAO,YACrB,IAAA,2KAAG,EACD,IAAA,6KAAK,EAAC,MAAM,EAAE,CAAC,MAAM,EAAE,MAAM,OAAO,EAAE,CAAC,MAAM,EAAE,MAAM,mBAEvD,IAAA,2KAAG,EAAC,IAAA,6KAAK,EAAC,MAAM,EAAE,CAAC,MAAM,EAAE,IAAI,OAAO,EAAE,CAAC,MAAM,EAAE,IAAI,iBACrD,IAAA,0JAAE,EAAC,CAAC;IAER;AACF","ignoreList":[0]}},
    {"offset": {"line": 1757, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40web3-storage/capabilities/src/blob.js"],"sourcesContent":["/**\n * Blob Capabilities.\n *\n * Blob is a fixed size byte array addressed by the multihash.\n * Usually blobs are used to represent set of IPLD blocks at different byte ranges.\n *\n * These can be imported directly with:\n * ```js\n * import * as Blob from '@web3-storage/capabilities/blob'\n * ```\n *\n * @module\n */\nimport { equals } from 'uint8arrays/equals'\nimport { capability, Schema, fail, ok } from '@ucanto/validator'\nimport { equalBlob, equalWith, SpaceDID } from './utils.js'\n\n/**\n * Agent capabilities for Blob protocol\n */\n\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derived any `space/blob/` prefixed capability for the (memory) space identified\n * by DID in the `with` field.\n */\nexport const blob = capability({\n  can: 'space/blob/*',\n  /**\n   * DID of the (memory) space where Blob is intended to\n   * be stored.\n   */\n  with: SpaceDID,\n  derives: equalWith,\n})\n\n/**\n * Blob description for being ingested by the service.\n */\nexport const content = Schema.struct({\n  /**\n   * A multihash digest of the blob payload bytes, uniquely identifying blob.\n   */\n  digest: Schema.bytes(),\n  /**\n   * Number of bytes contained by this blob. Service will provision write target\n   * for this exact size. Attempt to write a larger Blob file will fail.\n   */\n  size: Schema.integer(),\n})\n\n/**\n * `space/blob/add` capability allows agent to store a Blob into a (memory) space\n * identified by did:key in the `with` field. Agent should compute blob multihash\n * and size and provide it under `nb.blob` field, allowing a service to provision\n * a write location for the agent to PUT desired Blob into.\n */\nexport const add = capability({\n  can: 'space/blob/add',\n  /**\n   * DID of the (memory) space where Blob is intended to\n   * be stored.\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * Blob to be added on the space.\n     */\n    blob: content,\n  }),\n  derives: equalBlob,\n})\n\n/**\n * Capability can be used to remove the stored Blob from the (memory)\n * space identified by `with` field.\n */\nexport const remove = capability({\n  can: 'space/blob/remove',\n  /**\n   * DID of the (memory) space where Blob is stored.\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * A multihash digest of the blob payload bytes, uniquely identifying blob.\n     */\n    digest: Schema.bytes(),\n  }),\n  derives: (claimed, delegated) => {\n    if (claimed.with !== delegated.with) {\n      return fail(\n        `Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`\n      )\n    } else if (\n      delegated.nb.digest &&\n      !equals(delegated.nb.digest, claimed.nb.digest)\n    ) {\n      return fail(\n        `Link ${\n          claimed.nb.digest ? `${claimed.nb.digest}` : ''\n        } violates imposed ${delegated.nb.digest} constraint.`\n      )\n    }\n    return ok({})\n  },\n})\n\n/**\n * Capability can be invoked to request a list of stored Blobs in the\n * (memory) space identified by `with` field.\n */\nexport const list = capability({\n  can: 'space/blob/list',\n  /**\n   * DID of the (memory) space where Blobs to be listed are stored.\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * A pointer that can be moved back and forth on the list.\n     * It can be used to paginate a list for instance.\n     */\n    cursor: Schema.string().optional(),\n    /**\n     * Maximum number of items per page.\n     */\n    size: Schema.integer().optional(),\n  }),\n  derives: (claimed, delegated) => {\n    if (claimed.with !== delegated.with) {\n      return fail(\n        `Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`\n      )\n    }\n    return ok({})\n  },\n})\n\n/**\n * Capability can be used to get the stored Blob from the (memory)\n * space identified by `with` field.\n */\nexport const get = capability({\n  can: 'space/blob/get/0/1',\n  /**\n   * DID of the (memory) space where Blob is stored.\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * A multihash digest of the blob payload bytes, uniquely identifying blob.\n     */\n    digest: Schema.bytes(),\n  }),\n  derives: (claimed, delegated) => {\n    if (claimed.with !== delegated.with) {\n      return fail(\n        `Expected 'with: \"${delegated.with}\"' instead got '${claimed.with}'`\n      )\n    } else if (\n      delegated.nb.digest &&\n      !equals(delegated.nb.digest, claimed.nb.digest)\n    ) {\n      return fail(\n        `Link ${\n          claimed.nb.digest ? `${claimed.nb.digest}` : ''\n        } violates imposed ${delegated.nb.digest} constraint.`\n      )\n    }\n    return ok({})\n  },\n})\n\n// ⚠️ We export imports here so they are not omitted in generated typedefs\n// @see https://github.com/microsoft/TypeScript/issues/51548\nexport { Schema }\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1908, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40web3-storage/capabilities/src/web3.storage/blob.js"],"sourcesContent":["import { capability, Schema, Link, ok } from '@ucanto/validator'\nimport { content } from '../blob.js'\nimport {\n  equalBlob,\n  equalWith,\n  SpaceDID,\n  and,\n  equal,\n  checkLink,\n  Await,\n} from '../utils.js'\n\n/**\n * Service capabilities for Blob protocol\n */\n/**\n * Capability can only be delegated (but not invoked) allowing audience to\n * derived any `web3.storage/blob/` prefixed capability for the (memory) space identified\n * by DID in the `with` field.\n */\nexport const blob = capability({\n  can: 'web3.storage/blob/*',\n  /**\n   * DID of the (memory) space where Blob is intended to\n   * be stored.\n   */\n  with: SpaceDID,\n  derives: equalWith,\n})\n\n/**\n * `web3.storage/blob//allocate` capability can be invoked to create a memory\n * address where blob content can be written via HTTP PUT request.\n */\nexport const allocate = capability({\n  can: 'web3.storage/blob/allocate',\n  /**\n   * Provider DID.\n   */\n  with: Schema.did(),\n  nb: Schema.struct({\n    /**\n     * Blob to allocate on the space.\n     */\n    blob: content,\n    /**\n     * The Link for an Add Blob task, that caused an allocation\n     */\n    cause: Link,\n    /**\n     * DID of the user space where allocation takes place\n     */\n    space: SpaceDID,\n  }),\n  derives: (claim, from) => {\n    return (\n      and(equalWith(claim, from)) ||\n      and(equalBlob(claim, from)) ||\n      and(checkLink(claim.nb.cause, from.nb.cause, 'cause')) ||\n      and(equal(claim.nb.space, from.nb.space, 'space')) ||\n      ok({})\n    )\n  },\n})\n\n/**\n * `blob/accept` capability invocation should either succeed when content is\n * delivered on allocated address or fail if no content is allocation expires\n * without content being delivered.\n */\nexport const accept = capability({\n  can: 'web3.storage/blob/accept',\n  /**\n   * Provider DID.\n   */\n  with: Schema.did(),\n  nb: Schema.struct({\n    /**\n     * Blob to accept.\n     */\n    blob: content,\n    /**\n     * Content location commitment time to live, which will be encoded as expiry of the issued location claim.\n     */\n    ttl: Schema.integer().optional(),\n    /**\n     * DID of the user space where allocation took place\n     */\n    space: SpaceDID,\n    /**\n     * This task is blocked on `http/put` receipt available\n     */\n    _put: Await,\n  }),\n  derives: (claim, from) => {\n    return (\n      and(equalWith(claim, from)) ||\n      and(equalBlob(claim, from)) ||\n      and(equal(claim.nb.ttl, from.nb.ttl, 'ttl')) ||\n      and(equal(claim.nb.space, from.nb.space, 'space')) ||\n      ok({})\n    )\n  },\n})\n\n// ⚠️ We export imports here so they are not omitted in generated typedefs\n// @see https://github.com/microsoft/TypeScript/issues/51548\nexport { Schema, Link }\n"],"names":[],"mappings":";;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;AAkBO,MAAM,OAAO,IAAA,gOAAU,EAAC;IAC7B,KAAK;IACL;;;GAGC,GACD,MAAM,gLAAQ;IACd,SAAS,iLAAS;AACpB;AAMO,MAAM,WAAW,IAAA,gOAAU,EAAC;IACjC,KAAK;IACL;;GAEC,GACD,MAAM,gMAAM,CAAC,GAAG;IAChB,IAAI,gMAAM,CAAC,MAAM,CAAC;QAChB;;KAEC,GACD,MAAM,8LAAO;QACb;;KAEC,GACD,OAAO,4JAAI;QACX;;KAEC,GACD,OAAO,gLAAQ;IACjB;IACA,SAAS,CAAC,OAAO;QACf,OACE,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,OAAO,UACrB,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,OAAO,UACrB,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,MAAM,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,KAAK,EAAE,aAC7C,IAAA,2KAAG,EAAC,IAAA,6KAAK,EAAC,MAAM,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,KAAK,EAAE,aACzC,IAAA,0JAAE,EAAC,CAAC;IAER;AACF;AAOO,MAAM,SAAS,IAAA,gOAAU,EAAC;IAC/B,KAAK;IACL;;GAEC,GACD,MAAM,gMAAM,CAAC,GAAG;IAChB,IAAI,gMAAM,CAAC,MAAM,CAAC;QAChB;;KAEC,GACD,MAAM,8LAAO;QACb;;KAEC,GACD,KAAK,gMAAM,CAAC,OAAO,GAAG,QAAQ;QAC9B;;KAEC,GACD,OAAO,gLAAQ;QACf;;KAEC,GACD,MAAM,6KAAK;IACb;IACA,SAAS,CAAC,OAAO;QACf,OACE,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,OAAO,UACrB,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,OAAO,UACrB,IAAA,2KAAG,EAAC,IAAA,6KAAK,EAAC,MAAM,EAAE,CAAC,GAAG,EAAE,KAAK,EAAE,CAAC,GAAG,EAAE,WACrC,IAAA,2KAAG,EAAC,IAAA,6KAAK,EAAC,MAAM,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,CAAC,KAAK,EAAE,aACzC,IAAA,0JAAE,EAAC,CAAC;IAER;AACF","ignoreList":[0]}},
    {"offset": {"line": 2001, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40web3-storage/capabilities/src/http.js"],"sourcesContent":["/**\n * HTTP Capabilities.\n *\n * These can be imported directly with:\n * ```js\n * import * as HTTP from '@web3-storage/capabilities/http'\n * ```\n *\n * @module\n */\nimport { capability, Schema, ok } from '@ucanto/validator'\nimport { content } from './blob.js'\nimport { equal, equalBody, equalWith, SpaceDID, Await, and } from './utils.js'\n\n/**\n * `http/put` capability invocation MAY be performed by any authorized agent on behalf of the subject\n * as long as they have referenced `body` content to do so.\n */\nexport const put = capability({\n  can: 'http/put',\n  /**\n   * DID of the (memory) space where Blob is intended to\n   * be stored.\n   */\n  with: SpaceDID,\n  nb: Schema.struct({\n    /**\n     * Description of body to send (digest/size).\n     */\n    body: content,\n    /**\n     * HTTP(S) location that can receive blob content via HTTP PUT request.\n     */\n    url: Schema.string().or(Await),\n    /**\n     * HTTP headers.\n     */\n    headers: Schema.dictionary({ value: Schema.string() }).or(Await),\n  }),\n  derives: (claim, from) => {\n    return (\n      and(equalWith(claim, from)) ||\n      and(equalBody(claim, from)) ||\n      and(equal(claim.nb.url, from.nb, 'url')) ||\n      and(equal(claim.nb.headers, from.nb, 'headers')) ||\n      ok({})\n    )\n  },\n})\n"],"names":[],"mappings":"AAAA;;;;;;;;;CASC;;;;AACD;AAAA;AAAA;AAAA;AACA;AACA;;;;AAMO,MAAM,MAAM,IAAA,gOAAU,EAAC;IAC5B,KAAK;IACL;;;GAGC,GACD,MAAM,gLAAQ;IACd,IAAI,gMAAM,CAAC,MAAM,CAAC;QAChB;;KAEC,GACD,MAAM,8LAAO;QACb;;KAEC,GACD,KAAK,gMAAM,CAAC,MAAM,GAAG,EAAE,CAAC,6KAAK;QAC7B;;KAEC,GACD,SAAS,gMAAM,CAAC,UAAU,CAAC;YAAE,OAAO,gMAAM,CAAC,MAAM;QAAG,GAAG,EAAE,CAAC,6KAAK;IACjE;IACA,SAAS,CAAC,OAAO;QACf,OACE,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,OAAO,UACrB,IAAA,2KAAG,EAAC,IAAA,iLAAS,EAAC,OAAO,UACrB,IAAA,2KAAG,EAAC,IAAA,6KAAK,EAAC,MAAM,EAAE,CAAC,GAAG,EAAE,KAAK,EAAE,EAAE,WACjC,IAAA,2KAAG,EAAC,IAAA,6KAAK,EAAC,MAAM,EAAE,CAAC,OAAO,EAAE,KAAK,EAAE,EAAE,eACrC,IAAA,0JAAE,EAAC,CAAC;IAER;AACF","ignoreList":[0]}},
    {"offset": {"line": 2050, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40web3-storage/capabilities/src/index.js"],"sourcesContent":["import * as Provider from './provider.js'\nimport * as Space from './space.js'\nimport * as Top from './top.js'\nimport * as Store from './store.js'\nimport * as Upload from './upload.js'\nimport * as Access from './access.js'\nimport * as Utils from './utils.js'\nimport * as Consumer from './consumer.js'\nimport * as Customer from './customer.js'\nimport * as Console from './console.js'\nimport * as RateLimit from './rate-limit.js'\nimport * as Admin from './admin.js'\nimport * as Subscription from './subscription.js'\nimport * as Filecoin from './filecoin/index.js'\nimport * as Storefront from './filecoin/storefront.js'\nimport * as Aggregator from './filecoin/aggregator.js'\nimport * as Dealer from './filecoin/dealer.js'\nimport * as DealTracker from './filecoin/deal-tracker.js'\nimport * as Index from './index/index.js'\nimport * as UCAN from './ucan.js'\nimport * as Plan from './plan.js'\nimport * as Usage from './usage.js'\nimport * as Blob from './blob.js'\nimport * as W3sBlob from './web3.storage/blob.js'\nimport * as HTTP from './http.js'\n\nexport {\n  Access,\n  Provider,\n  Space,\n  Top,\n  Store,\n  Upload,\n  Consumer,\n  Customer,\n  Console,\n  Utils,\n  RateLimit,\n  Subscription,\n  Filecoin,\n  Index,\n  Storefront,\n  Aggregator,\n  Dealer,\n  DealTracker,\n  Admin,\n  UCAN,\n  Plan,\n  Usage,\n  Blob,\n  W3sBlob,\n  HTTP,\n}\n\n/** @type {import('./types.js').ServiceAbility[]} */\nexport const abilitiesAsStrings = [\n  Top.top.can,\n  Provider.add.can,\n  Space.space.can,\n  Space.info.can,\n  Upload.upload.can,\n  Upload.add.can,\n  Upload.get.can,\n  Upload.remove.can,\n  Upload.list.can,\n  Store.store.can,\n  Store.add.can,\n  Store.get.can,\n  Store.remove.can,\n  Store.list.can,\n  Access.access.can,\n  Access.authorize.can,\n  UCAN.attest.can,\n  UCAN.conclude.can,\n  Customer.get.can,\n  Consumer.has.can,\n  Consumer.get.can,\n  Subscription.get.can,\n  Subscription.list.can,\n  RateLimit.add.can,\n  RateLimit.remove.can,\n  RateLimit.list.can,\n  Storefront.filecoinOffer.can,\n  Storefront.filecoinSubmit.can,\n  Storefront.filecoinAccept.can,\n  Storefront.filecoinInfo.can,\n  Aggregator.pieceOffer.can,\n  Aggregator.pieceAccept.can,\n  Dealer.aggregateOffer.can,\n  Dealer.aggregateAccept.can,\n  DealTracker.dealInfo.can,\n  Admin.admin.can,\n  Admin.upload.inspect.can,\n  Admin.store.inspect.can,\n  Plan.get.can,\n  Plan.set.can,\n  Plan.createAdminSession.can,\n  Usage.usage.can,\n  Usage.report.can,\n  Blob.blob.can,\n  Blob.add.can,\n  Blob.remove.can,\n  Blob.list.can,\n  W3sBlob.blob.can,\n  W3sBlob.allocate.can,\n  W3sBlob.accept.can,\n  HTTP.put.can,\n  Index.index.can,\n  Index.add.can,\n]\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BO,MAAM,qBAAqB;IAChC,yKAAO,CAAC,GAAG;IACX,8LAAY,CAAC,GAAG;IAChB,6LAAW,CAAC,GAAG;IACf,4LAAU,CAAC,GAAG;IACd,+LAAa,CAAC,GAAG;IACjB,4LAAU,CAAC,GAAG;IACd,4LAAU,CAAC,GAAG;IACd,+LAAa,CAAC,GAAG;IACjB,6LAAW,CAAC,GAAG;IACf,6LAAW,CAAC,GAAG;IACf,2LAAS,CAAC,GAAG;IACb,2LAAS,CAAC,GAAG;IACb,8LAAY,CAAC,GAAG;IAChB,4LAAU,CAAC,GAAG;IACd,+LAAa,CAAC,GAAG;IACjB,kMAAgB,CAAC,GAAG;IACpB,6KAAW,CAAC,GAAG;IACf,+KAAa,CAAC,GAAG;IACjB,8KAAY,CAAC,GAAG;IAChB,8KAAY,CAAC,GAAG;IAChB,8KAAY,CAAC,GAAG;IAChB,kLAAgB,CAAC,GAAG;IACpB,mLAAiB,CAAC,GAAG;IACrB,mLAAa,CAAC,GAAG;IACjB,sLAAgB,CAAC,GAAG;IACpB,oLAAc,CAAC,GAAG;IAClB,sMAAwB,CAAC,GAAG;IAC5B,uMAAyB,CAAC,GAAG;IAC7B,uMAAyB,CAAC,GAAG;IAC7B,qMAAuB,CAAC,GAAG;IAC3B,mMAAqB,CAAC,GAAG;IACzB,oMAAsB,CAAC,GAAG;IAC1B,mMAAqB,CAAC,GAAG;IACzB,oMAAsB,CAAC,GAAG;IAC1B,sMAAoB,CAAC,GAAG;IACxB,6KAAW,CAAC,GAAG;IACf,8KAAY,CAAC,OAAO,CAAC,GAAG;IACxB,6KAAW,CAAC,OAAO,CAAC,GAAG;IACvB,0KAAQ,CAAC,GAAG;IACZ,0KAAQ,CAAC,GAAG;IACZ,yLAAuB,CAAC,GAAG;IAC3B,6KAAW,CAAC,GAAG;IACf,8KAAY,CAAC,GAAG;IAChB,2LAAS,CAAC,GAAG;IACb,0LAAQ,CAAC,GAAG;IACZ,6LAAW,CAAC,GAAG;IACf,2LAAS,CAAC,GAAG;IACb,8MAAY,CAAC,GAAG;IAChB,kNAAgB,CAAC,GAAG;IACpB,gNAAc,CAAC,GAAG;IAClB,0KAAQ,CAAC,GAAG;IACZ,sMAAW,CAAC,GAAG;IACf,oMAAS,CAAC,GAAG;CACd","ignoreList":[0]}}]
}