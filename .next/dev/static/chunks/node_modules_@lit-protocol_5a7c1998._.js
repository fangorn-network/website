(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/@lit-protocol/misc/src/lib/addresses.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.derivedAddresses = void 0;
exports.publicKeyConvert = publicKeyConvert;
const constants_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/misc/node_modules/@lit-protocol/constants/src/index.js [app-client] (ecmascript)");
const bech32_1 = __turbopack_context__.r("[project]/node_modules/bech32/dist/index.js [app-client] (ecmascript)");
const crypto_1 = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/crypto-browserify/index.js [app-client] (ecmascript)");
const ethers_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-client] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib/utils.js [app-client] (ecmascript)");
/**
 * Converts a public key between compressed and uncompressed formats.
 *
 * @param publicKey - Public key as a Buffer (33 bytes compressed or 65 bytes uncompressed)
 * @param compressed - Boolean flag indicating whether the output should be compressed
 * @returns Converted public key as a Buffer
 */ function publicKeyConvert(publicKey, compressed = true) {
    if (compressed) {
        // Compress the public key (if it's not already compressed)
        if (publicKey.length === 65 && publicKey[0] === 0x04) {
            const x = publicKey.subarray(1, 33);
            const y = publicKey.subarray(33, 65);
            const prefix = y[y.length - 1] % 2 === 0 ? 0x02 : 0x03;
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].concat([
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from([
                    prefix
                ]),
                x
            ]);
        }
    } else {
        // Decompress the public key
        if (publicKey.length === 33 && (publicKey[0] === 0x02 || publicKey[0] === 0x03)) {
            const x = publicKey.subarray(1);
            const y = decompressY(publicKey[0], x);
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].concat([
                __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from([
                    0x04
                ]),
                x,
                y
            ]);
        }
    }
    // Return the original if no conversion is needed
    return publicKey;
}
/**
 * Decompresses the y-coordinate of a compressed public key.
 *
 * @param prefix - The first byte of the compressed public key (0x02 or 0x03)
 * @param x - The x-coordinate of the public key
 * @returns The decompressed y-coordinate as a Buffer
 */ function decompressY(prefix, x) {
    const p = BigInt('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F');
    const a = BigInt('0');
    const b = BigInt('7');
    const xBigInt = BigInt('0x' + x.toString('hex'));
    const rhs = (xBigInt ** 3n + a * xBigInt + b) % p;
    const yBigInt = modSqrt(rhs, p);
    const isEven = yBigInt % 2n === 0n;
    const y = isEven === (prefix === 0x02) ? yBigInt : p - yBigInt;
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(y.toString(16).padStart(64, '0'), 'hex');
}
/**
 * Computes the modular square root of a number.
 *
 * @param a - The number to find the square root of
 * @param p - The modulus
 * @returns The square root modulo p
 */ function modSqrt(a, p) {
    return a ** ((p + 1n) / 4n) % p;
}
/**
 * Derives a Bitcoin address (P2PKH) from a public key.
 *
 * @param ethPubKey - Public key as a hex string (uncompressed or compressed)
 * @returns Bitcoin address as a Base58Check string
 */ function deriveBitcoinAddress(ethPubKey) {
    // Remove the "0x" prefix if it exists and convert to a Buffer
    if (ethPubKey.startsWith('0x')) {
        ethPubKey = ethPubKey.slice(2);
    }
    const pubkeyBuffer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(ethPubKey, 'hex');
    // Perform SHA-256 hashing on the public key
    const sha256Hash = (0, crypto_1.createHash)('sha256').update(pubkeyBuffer).digest();
    // Perform RIPEMD-160 hashing on the result of SHA-256
    const ripemd160Hash = (0, crypto_1.createHash)('ripemd160').update(sha256Hash).digest();
    // Add version byte in front of RIPEMD-160 hash (0x00 for mainnet)
    const versionedPayload = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].concat([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from([
            0x00
        ]),
        ripemd160Hash
    ]);
    // Create a checksum by hashing the versioned payload twice with SHA-256
    const checksum = (0, crypto_1.createHash)('sha256').update((0, crypto_1.createHash)('sha256').update(versionedPayload).digest()).digest().subarray(0, 4);
    // Concatenate the versioned payload and the checksum
    const binaryBitcoinAddress = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].concat([
        versionedPayload,
        checksum
    ]);
    // Encode the result with Base58 to get the final Bitcoin address and return it
    return ethers_1.ethers.utils.base58.encode(binaryBitcoinAddress);
}
/**
 * Derives a Cosmos address from an Ethereum public key.
 *
 * @param ethPubKey - Ethereum public key as a hex string (uncompressed, 130 characters long, or compressed, 66 characters long)
 * @param prefix - Cosmos address prefix (e.g., "cosmos")
 * @returns Cosmos address as a Bech32 string
 */ function deriveCosmosAddress(ethPubKey, prefix = 'cosmos') {
    let pubKeyBuffer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(ethPubKey, 'hex');
    // If the Ethereum public key is uncompressed (130 characters), compress it
    if (pubKeyBuffer.length === 65 && pubKeyBuffer[0] === 0x04) {
        pubKeyBuffer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(publicKeyConvert(pubKeyBuffer, true));
    }
    // Hash the compressed public key with SHA-256
    const sha256Hash = (0, crypto_1.createHash)('sha256').update(pubKeyBuffer).digest();
    // Hash the SHA-256 hash with RIPEMD-160
    const ripemd160Hash = (0, crypto_1.createHash)('ripemd160').update(sha256Hash).digest();
    // Encode the RIPEMD-160 hash with Bech32 and return it
    return bech32_1.bech32.encode(prefix, bech32_1.bech32.toWords(ripemd160Hash));
}
/**
 * Derives multiple blockchain addresses (Ethereum, Bitcoin, and Cosmos) from a given uncompressed eth public key
 * or PKP token ID. If a PKP token ID is provided, it retrieves the public key from the PKP contract.
 *
 * @param params - The parameters for deriving addresses.
 * @param params.publicKey - The Ethereum public key as a hex string (optional). If not provided, pkpTokenId must be provided.
 * @param params.pkpTokenId - The PKP token ID (optional). If not provided, publicKey must be provided.
 * @param params.pkpContractAddress - The PKP contract address (optional). If not provided, a default address is used.
 * @param params.defaultRPCUrl - The default RPC URL for connecting to the Ethereum network.
 * @param params.options - Additional options (optional).
 * @param params.options.cacheContractCall - Whether to cache the contract call result in local storage (default: false).
 *
 * @returns A Promise that resolves to an object containing token information:
 *   @property {string} tokenId - The PKP token ID.
 *   @property {string} publicKey - The Ethereum public key as a hex string.
 *   @property {Buffer} publicKeyBuffer - The buffer representation of the public key.
 *   @property {string} ethAddress - The derived Ethereum address.
 *   @property {string} btcAddress - The derived Bitcoin address.
 *   @property {string} cosmosAddress - The derived Cosmos address.
 *   @property {boolean} isNewPKP - Whether a new PKP was created.
 *
 * @throws {InvalidArgumentException} If the defaultRPCUrl is not provided.
 * @throws {ParamsMissingError} If neither publicKey nor pkpTokenId is provided.
 * @throws {MultiError} If any of the derived addresses (btcAddress, ethAddress, cosmosAddress) are undefined.
 */ const derivedAddresses = async ({ publicKey, pkpTokenId, pkpContractAddress, defaultRPCUrl, options = {
    cacheContractCall: false
} })=>{
    // one of the two must be provided
    if (!publicKey && !pkpTokenId) {
        throw new constants_1.ParamsMissingError({
            info: {
                publicKey,
                pkpTokenId
            }
        }, 'publicKey or pkpTokenId must be provided');
    }
    // if pkpTokenId is provided, we must get the public key from it (in cache or from the contract)
    let isNewPKP = false;
    if (pkpTokenId) {
        // try to get the public key from 'lit-cached-pkps' local storage
        const CACHE_KEY = 'lit-cached-pkps';
        let cachedPkpJSON;
        try {
            const cachedPkp = localStorage.getItem(CACHE_KEY);
            if (cachedPkp) {
                cachedPkpJSON = JSON.parse(cachedPkp);
                publicKey = cachedPkpJSON[pkpTokenId];
            }
        } catch (e) {
            console.error(e);
        }
        if (!publicKey) {
            // Could not get the public key from the cache, so we need to get it from the contract
            if (!defaultRPCUrl || !pkpContractAddress) {
                throw new constants_1.NoWalletException({
                    info: {
                        publicKey,
                        pkpTokenId,
                        pkpContractAddress,
                        defaultRPCUrl
                    }
                }, 'defaultRPCUrl or pkpContractAddress was not provided');
            }
            const provider = new ethers_1.ethers.providers.StaticJsonRpcProvider(defaultRPCUrl);
            const contract = new ethers_1.Contract(pkpContractAddress, [
                'function getPubkey(uint256 tokenId) view returns (bytes memory)'
            ], provider);
            publicKey = await contract['getPubkey'](pkpTokenId);
            isNewPKP = true;
        }
        if (options.cacheContractCall) {
            // trying to store key value pair in local storage
            try {
                const cachedPkp = localStorage.getItem(CACHE_KEY);
                if (cachedPkp) {
                    const cachedPkpJSON = JSON.parse(cachedPkp);
                    cachedPkpJSON[pkpTokenId] = publicKey;
                    localStorage.setItem(CACHE_KEY, JSON.stringify(cachedPkpJSON));
                } else {
                    const cachedPkpJSON = {};
                    cachedPkpJSON[pkpTokenId] = publicKey;
                    localStorage.setItem(CACHE_KEY, JSON.stringify(cachedPkpJSON));
                }
            } catch (e) {
                console.error(e);
            }
        }
    }
    if (!publicKey) {
        throw new constants_1.NoWalletException({
            info: {
                publicKey,
                pkpTokenId,
                pkpContractAddress,
                defaultRPCUrl
            }
        }, 'publicKey was not provided or could not be obtained from the pkpTokenId');
    }
    if (publicKey.startsWith('0x')) {
        publicKey = publicKey.slice(2);
    }
    const pubkeyBuffer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(publicKey, 'hex');
    // get the address from the public key
    const ethAddress = (0, utils_1.computeAddress)(pubkeyBuffer);
    // get the btc address from the public key
    const btcAddress = deriveBitcoinAddress(publicKey);
    // get cosmos address from the public key
    const cosmosAddress = deriveCosmosAddress(publicKey);
    if (!btcAddress || !ethAddress || !cosmosAddress) {
        // push to error reporting service
        const errors = [];
        if (!btcAddress) {
            errors.push(new constants_1.NoWalletException({
                info: {
                    publicKey
                }
            }, 'btcAddress is undefined'));
        }
        if (!ethAddress) {
            errors.push(new constants_1.NoWalletException({
                info: {
                    publicKey
                }
            }, 'ethAddress is undefined'));
        }
        if (!cosmosAddress) {
            errors.push(new constants_1.NoWalletException({
                info: {
                    publicKey
                }
            }, 'cosmosAddress is undefined'));
        }
        throw new constants_1.MultiError(errors);
    }
    return {
        tokenId: pkpTokenId,
        publicKey: `0x${publicKey}`,
        publicKeyBuffer: pubkeyBuffer,
        ethAddress,
        btcAddress,
        cosmosAddress,
        isNewPKP
    };
};
exports.derivedAddresses = derivedAddresses; //# sourceMappingURL=addresses.js.map
}),
"[project]/node_modules/@lit-protocol/misc/src/lib/misc.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.removeHexPrefix = exports.hexPrefixed = exports.defaultMintClaimCallback = exports.genRandomPath = exports.decimalPlaces = exports.isBrowser = exports.isNode = exports.is = exports.numberToHex = exports.sortedObject = exports.checkIfAuthSigRequiresChainParam = exports.checkSchema = exports.checkType = exports.getVarType = exports.logError = exports.logErrorWithRequestId = exports.logWithRequestId = exports.log = exports.getLoggerbyId = exports.bootstrapLogManager = exports.throwRemovedFunctionError = exports.findMostCommonResponse = exports.mostCommonString = exports.printError = exports.setMiscLitConfig = void 0;
exports.isSupportedLitNetwork = isSupportedLitNetwork;
exports.getEnv = getEnv;
exports.sendRequest = sendRequest;
exports.normalizeAndStringify = normalizeAndStringify;
exports.getIpAddress = getIpAddress;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/misc/node_modules/tslib/tslib.es6.js [app-client] (ecmascript)");
const contracts_1 = __turbopack_context__.r("[project]/node_modules/@ethersproject/contracts/lib.esm/index.js [app-client] (ecmascript)");
const providers_1 = __turbopack_context__.r("[project]/node_modules/@ethersproject/providers/lib.esm/index.js [app-client] (ecmascript)");
const ajv_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/@lit-protocol/misc/node_modules/ajv/dist/ajv.js [app-client] (ecmascript)"));
const constants_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/misc/node_modules/@lit-protocol/constants/src/index.js [app-client] (ecmascript)");
const logger_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/logger/src/index.js [app-client] (ecmascript)");
const logBuffer = [];
const ajv = new ajv_1.default();
// Module scoped variable to store the LitNodeClientConfig passed to LitCore
let litConfig;
const setMiscLitConfig = (config)=>{
    litConfig = config;
};
exports.setMiscLitConfig = setMiscLitConfig;
/**
 *
 * Print error message based on Error interface
 *
 * @param { Error } e
 * @returns { void }
 */ const printError = (e)=>{
    console.log('Error Stack', e.stack);
    console.log('Error Name', e.name);
    console.log('Error Message', e.message);
};
exports.printError = printError;
/**
 *
 * Find the element that occurs the most in an array
 *
 * @param { Array<any> } arr
 * @returns { any } the element that appeared the most
 */ const mostCommonString = (arr)=>{
    return arr.sort((a, b)=>arr.filter((v)=>v === a).length - arr.filter((v)=>v === b).length).pop();
};
exports.mostCommonString = mostCommonString;
const findMostCommonResponse = (responses)=>{
    const result = {};
    // Aggregate all values for each key across all responses
    const keys = new Set(responses.flatMap(Object.keys));
    for (const key of keys){
        const values = responses.map((response)=>response[key]);
        // Filter out undefined values before processing
        const filteredValues = values.filter((value)=>value !== undefined && value !== '');
        if (filteredValues.length === 0) {
            result[key] = undefined; // or set a default value if needed
        } else if (typeof filteredValues[0] === 'object' && !Array.isArray(filteredValues[0])) {
            // Recursive case for objects
            result[key] = (0, exports.findMostCommonResponse)(filteredValues);
        } else {
            // Most common element from filtered values
            result[key] = (0, exports.mostCommonString)(filteredValues);
        }
    }
    return result;
};
exports.findMostCommonResponse = findMostCommonResponse;
const throwRemovedFunctionError = (functionName)=>{
    throw new constants_1.RemovedFunctionError({
        info: {
            functionName
        }
    }, `This function "${functionName}" has been removed. Please use the old SDK.`);
};
exports.throwRemovedFunctionError = throwRemovedFunctionError;
const bootstrapLogManager = (id, level = constants_1.LOG_LEVEL.DEBUG, logFormat = 'text', serviceName = 'lit-sdk')=>{
    if (!globalThis.logManager) {
        globalThis.logManager = logger_1.LogManager.Instance;
        globalThis.logManager.withConfig({
            condenseLogs: true
        });
        globalThis.logManager.setLevel(level);
        globalThis.logManager.setLogFormat(logFormat);
        globalThis.logManager.setServiceName(serviceName);
    }
    globalThis.logger = globalThis.logManager.get(id);
};
exports.bootstrapLogManager = bootstrapLogManager;
const getLoggerbyId = (id)=>{
    return globalThis.logManager.get(id);
};
exports.getLoggerbyId = getLoggerbyId;
/**
 *
 * console.log but prepend [Lit-JS-SDK] before the message
 *
 * @param { any } args
 *
 * @returns { void }
 */ const log = (...args)=>{
    if (!globalThis) {
        // there is no globalThis, just print the log
        console.log(...args);
        return;
    }
    // check if config is loaded yet
    if (!litConfig) {
        // config isn't loaded yet, push into buffer
        logBuffer.push(args);
        return;
    }
    // if there are there are logs in buffer, print them first and empty the buffer.
    while(logBuffer.length > 0){
        const log = logBuffer.shift() ?? '';
        globalThis?.logger && globalThis?.logger.debug(...log);
    }
    globalThis?.logger && globalThis?.logger.debug(...args);
};
exports.log = log;
const logWithRequestId = (id, ...args)=>{
    if (!globalThis) {
        // there is no globalThis, just print the log
        console.log(...args);
        return;
    }
    // check if config is loaded yet
    if (!litConfig) {
        // config isn't loaded yet, push into buffer
        logBuffer.push(args);
        return;
    }
    // if there are there are logs in buffer, print them first and empty the buffer.
    while(logBuffer.length > 0){
        const log = logBuffer.shift() ?? '';
        globalThis?.logger && globalThis.logManager.get(globalThis.logger.category, id).debug(...log);
    }
    globalThis?.logger && globalThis.logManager.get(globalThis.logger.category, id).debug(...args);
};
exports.logWithRequestId = logWithRequestId;
const logErrorWithRequestId = (id, ...args)=>{
    if (!globalThis) {
        // there is no globalThis, just print the log
        console.log(...args);
        return;
    }
    // check if config is loaded yet
    if (!litConfig) {
        // config isn't loaded yet, push into buffer
        logBuffer.push(args);
        return;
    }
    // if there are there are logs in buffer, print them first and empty the buffer.
    while(logBuffer.length > 0){
        const log = logBuffer.shift() ?? '';
        globalThis?.logger && globalThis.logManager.get(globalThis.logger.category, id).error(...log);
    }
    globalThis?.logger && globalThis.logManager.get(globalThis.logger.category, id).error(...args);
};
exports.logErrorWithRequestId = logErrorWithRequestId;
const logError = (...args)=>{
    if (!globalThis) {
        // there is no globalThis, just print the log
        console.log(...args);
        return;
    }
    // check if config is loaded yet
    if (!litConfig) {
        // config isn't loaded yet, push into buffer
        logBuffer.push(args);
        return;
    }
    // if there are there are logs in buffer, print them first and empty the buffer.
    while(logBuffer.length > 0){
        const log = logBuffer.shift() ?? '';
        globalThis?.logger && globalThis.logManager.get(globalThis.logger.category).error(...log);
    }
    globalThis?.logger && globalThis.logManager.get(globalThis.logger.category).error(...args);
};
exports.logError = logError;
/**
 *
 * Get the type of a variable, could be an object instance type.
 * eg Uint8Array instance should return 'Uint8Array` as string
 * or simply a `string` or `int` type
 *
 * @param { any } value
 * @returns { string } type
 */ const getVarType = (value)=>{
    return Object.prototype.toString.call(value).slice(8, -1);
};
exports.getVarType = getVarType;
/**
 *
 *  Check if the given value is the given type
 *  If not, throw `invalidParamType` error
 *
 * @property { any } value
 * @property { Array<String> } allowedTypes
 * @property { string } paramName
 * @property { string } functionName
 * @property { boolean } throwOnError
 *
 * @returns { Boolean } true/false
 *
 */ const checkType = ({ value, allowedTypes, paramName, functionName, throwOnError = true })=>{
    // -- validate
    if (!allowedTypes.includes((0, exports.getVarType)(value))) {
        const message = `Expecting ${allowedTypes.join(' or ')} type for parameter named ${paramName} in Lit-JS-SDK function ${functionName}(), but received "${(0, exports.getVarType)(value)}" type instead. value: ${value instanceof Object ? JSON.stringify(value) : value}`;
        if (throwOnError) {
            throw new constants_1.InvalidParamType({
                info: {
                    allowedTypes,
                    value,
                    paramName,
                    functionName
                }
            }, message);
        }
        return false;
    }
    // -- else
    return true;
};
exports.checkType = checkType;
/**
 * Check if the given value complies with the given schema
 * If not, throw `invalidParamType` error
 *
 * @param { any } value
 * @param { JSONSchemaType<any> } schema
 * @param { string } paramName
 * @param { string } functionName
 * @param { boolean } throwOnError
 *
 * @returns { Boolean } true/false
 */ const checkSchema = (value, schema, paramName, functionName, throwOnError = true)=>{
    let validate = schema.$id ? ajv.getSchema(schema.$id) : undefined;
    if (!validate) {
        validate = ajv.compile(schema);
    }
    const validates = validate(value);
    const message = `FAILED schema validation for parameter named ${paramName} in Lit-JS-SDK function ${functionName}(). Value: ${value instanceof Object ? JSON.stringify(value) : value}. Errors: ${JSON.stringify(validate.errors)}`;
    if (!validates) {
        if (throwOnError) {
            throw new constants_1.InvalidParamType({
                info: {
                    value,
                    paramName,
                    functionName
                }
            }, message);
        }
        return false;
    }
    return true;
};
exports.checkSchema = checkSchema;
/**
 *
 * @param { AuthSig } authSig
 * @param { string } chain
 * @param { string } functionName
 *
 * @returns { boolean }
 */ const checkIfAuthSigRequiresChainParam = (authSig, chain, functionName)=>{
    (0, exports.log)('checkIfAuthSigRequiresChainParam');
    for (const key of constants_1.LIT_AUTH_SIG_CHAIN_KEYS){
        if (key in authSig) {
            return true;
        }
    }
    // if we're here, then we need the chain param
    if (!(0, exports.checkType)({
        value: chain,
        allowedTypes: [
            'String'
        ],
        paramName: 'chain',
        functionName
    })) {
        return false;
    }
    return true;
};
exports.checkIfAuthSigRequiresChainParam = checkIfAuthSigRequiresChainParam;
/**
 * TODO: Fix "any"
 * Sort object
 *
 * @param { any } obj
 * @returns { any }
 */ const sortedObject = (obj)=>{
    if (typeof obj !== 'object' || obj === null) {
        return obj;
    }
    if (Array.isArray(obj)) {
        return obj.map(exports.sortedObject);
    }
    const sortedKeys = Object.keys(obj).sort();
    const result = {};
    // NOTE: Use forEach instead of reduce for performance with large objects eg Wasm code
    sortedKeys.forEach((key)=>{
        result[key] = (0, exports.sortedObject)(obj[key]);
    });
    return result;
};
exports.sortedObject = sortedObject;
/**
 *
 * Convert number to hex
 * @param { number } v
 * @return { string } hex value prexied with 0x
 */ const numberToHex = (v)=>{
    return '0x' + v.toString(16);
};
exports.numberToHex = numberToHex;
/**
 *
 *  Check if the given value is the given type
 *  If not, throw `invalidParamType` error
 *
 * @param { any } value
 * @param { string } type
 * @param { string } paramName
 * @param { string } functionName
 * @param { boolean } throwOnError
 * @returns { Boolean } true/false
 */ const is = (value, type, paramName, functionName, throwOnError = true)=>{
    if ((0, exports.getVarType)(value) !== type) {
        const message = `Expecting "${type}" type for parameter named ${paramName} in Lit-JS-SDK function ${functionName}(), but received "${(0, exports.getVarType)(value)}" type instead. value: ${value instanceof Object ? JSON.stringify(value) : value}`;
        if (throwOnError) {
            throw new constants_1.InvalidParamType({
                info: {
                    value,
                    paramName,
                    functionName
                }
            }, message);
        }
        return false;
    }
    return true;
};
exports.is = is;
const isNode = ()=>{
    let isNode = false;
    // @ts-ignore
    if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"] === 'object') {
        // @ts-ignore
        if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].versions === 'object') {
            // @ts-ignore
            if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].versions.node !== 'undefined') {
                isNode = true;
            }
        }
    }
    return isNode;
};
exports.isNode = isNode;
const isBrowser = ()=>{
    return (0, exports.isNode)() === false;
};
exports.isBrowser = isBrowser;
/**
 *
 * Get the number of decimal places in a token
 *
 * @property { string } contractAddress The token contract address
 * @property { string } chain The chain on which the token is deployed
 *
 * @returns { number } The number of decimal places in the token
 */ const decimalPlaces = async ({ contractAddress, chain })=>{
    const rpcUrl = constants_1.LIT_CHAINS[chain].rpcUrls[0];
    const web3 = new providers_1.JsonRpcProvider({
        url: rpcUrl,
        skipFetchSetup: true
    });
    const contract = new contracts_1.Contract(contractAddress, constants_1.ABI_ERC20.abi, web3);
    return await contract['decimals']();
};
exports.decimalPlaces = decimalPlaces;
/**
 *
 * Generate a random path (for testing)
 *
 * @returns { string } The random path
 */ const genRandomPath = ()=>{
    return '/' + Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
};
exports.genRandomPath = genRandomPath;
/**
 * Checks if the given LIT_NETWORK value is supported.
 * @param litNetwork - The Lit Network value to check.
 * @throws {Error} - Throws an error if the Lit Network value is not supported.
 */ function isSupportedLitNetwork(litNetwork) {
    const supportedNetworks = Object.values(constants_1.LIT_NETWORK);
    if (!supportedNetworks.includes(litNetwork)) {
        throw new constants_1.WrongNetworkException({
            info: {
                litNetwork,
                supportedNetworks
            }
        }, `Unsupported LitNetwork! (${supportedNetworks.join('|')}) are supported.`);
    }
}
const defaultMintClaimCallback = async (params, network = constants_1.LIT_NETWORK.DatilDev)=>{
    isSupportedLitNetwork(network);
    const AUTH_CLAIM_PATH = '/auth/claim';
    const relayUrl = params.relayUrl || constants_1.RELAYER_URL_BY_NETWORK[network];
    if (!relayUrl) {
        throw new constants_1.InvalidArgumentException({
            info: {
                network,
                relayUrl
            }
        }, 'No relayUrl provided and no default relayUrl found for network');
    }
    const relayUrlWithPath = relayUrl + AUTH_CLAIM_PATH;
    const response = await fetch(relayUrlWithPath, {
        method: 'POST',
        body: JSON.stringify(params),
        headers: {
            'api-key': params.relayApiKey ? params.relayApiKey : '67e55044-10b1-426f-9247-bb680e5fe0c8_relayer',
            'Content-Type': 'application/json'
        }
    });
    if (response.status < 200 || response.status >= 400) {
        const errResp = await response.json() ?? '';
        const errStmt = `An error occurred requesting "/auth/claim" endpoint ${JSON.stringify(errResp)}`;
        console.warn(errStmt);
        throw new constants_1.NetworkError({
            info: {
                response,
                errResp
            }
        }, `An error occurred requesting "/auth/claim" endpoint`);
    }
    const body = await response.json();
    return body.requestId;
};
exports.defaultMintClaimCallback = defaultMintClaimCallback;
/**
 * Adds a '0x' prefix to a string if it doesn't already have one.
 * @param str - The input string.
 * @returns The input string with a '0x' prefix.
 */ const hexPrefixed = (str)=>{
    if (str.startsWith('0x')) {
        return str;
    }
    return '0x' + str;
};
exports.hexPrefixed = hexPrefixed;
/**
 * Removes the '0x' prefix from a hexadecimal string if it exists.
 *
 * @param str - The input string.
 * @returns The input string with the '0x' prefix removed, if present.
 */ const removeHexPrefix = (str)=>{
    if (str.startsWith('0x')) {
        return str.slice(2);
    }
    return str;
};
exports.removeHexPrefix = removeHexPrefix;
/**
 * getEnv - Determine the debug status based on environment variables or URL query parameters.
 *
 * @function
 * @export
 * @param {Object} [options={}] - Configuration options for determining debug status.
 * @param {string} [options.nodeEnvVar='DEBUG'] - The Node.js environment variable to check.
 * @param {string} [options.urlQueryParam='dev'] - The URL query parameter to check in a browser environment.
 * @param {string} [options.urlQueryValue='debug=true'] - The expected value of the URL query parameter to enable debugging.
 * @param {boolean} [options.defaultValue=false] - The default boolean value to return if no debug conditions are met.
 * @returns {boolean} - True if debug conditions are met, otherwise returns the provided defaultValue.
 *
 * @example
 * // Usage in Node.js environment
 * process.env.DEBUG = 'true';
 * console.log(getEnv()); // Outputs: true
 *
 * @example
 * // Usage in Browser environment with URL: http://example.com?dev=debug=true
 * console.log(getEnv()); // Outputs: true
 */ function getEnv({ nodeEnvVar = 'DEBUG', urlQueryParam = 'dev', urlQueryValue = 'debug=true', defaultValue = false } = {}) {
    // Node.js environment
    if ((0, exports.isNode)()) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].env[nodeEnvVar] === 'true';
    } else if ((0, exports.isBrowser)()) {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get(urlQueryParam) === urlQueryValue;
    }
    // Default
    return defaultValue;
}
function sendRequest(url, req, requestId) {
    return fetch(url, req).then(async (response)=>{
        const isJson = response.headers.get('content-type')?.includes('application/json');
        const data = isJson ? await response.json() : null;
        if (!response.ok) {
            // get error message from body or default to response status
            const error = data || response.status;
            return Promise.reject(error);
        }
        return data;
    }).catch((error)=>{
        (0, exports.logErrorWithRequestId)(requestId, `Something went wrong, internal id for request: lit_${requestId}. Please provide this identifier with any support requests. ${error?.message || error?.details ? `Error is ${error.message} - ${error.details}` : ''}`);
        return Promise.reject(error);
    });
}
/**
 * Attempts to normalize a string by unescaping it until it can be parsed as a JSON object,
 * then stringifies it exactly once. If the input is a regular string that does not represent
 * a JSON object or array, the function will return it as is without modification.
 * This function is designed to handle cases where strings might be excessively escaped due
 * to multiple layers of encoding, ensuring that JSON data is stored in a consistent and
 * predictable format, and regular strings are left unchanged.
 *
 * @param input The potentially excessively escaped string.
 * @return A string that is either the JSON.stringify version of the original JSON object
 *         or the original string if it does not represent a JSON object or array.
 */ function normalizeAndStringify(input) {
    try {
        // Directly return the string if it's not in a JSON format
        if (!input.startsWith('{') && !input.startsWith('[')) {
            return input;
        }
        // Attempt to parse the input as JSON
        const parsed = JSON.parse(input);
        // If parsing succeeds, return the stringified version of the parsed JSON
        return JSON.stringify(parsed);
    } catch (error) {
        // If parsing fails, it might be due to extra escaping
        const unescaped = input.replace(/\\(.)/g, '$1');
        // If unescaping doesn't change the string, return it as is
        if (input === unescaped) {
            return input;
        }
        // Otherwise, recursively call the function with the unescaped string
        return normalizeAndStringify(unescaped);
    }
}
/**
 * Retrieves the IP address associated with a given domain.
 * @param domain - The domain for which to retrieve the IP address.
 * @returns A Promise that resolves to the IP address.
 * @throws If no IP address is found or if the domain name is invalid.
 */ async function getIpAddress(domain) {
    const apiURL = `https://dns.google/resolve?name=${domain}&type=A`;
    try {
        const response = await fetch(apiURL);
        const data = await response.json();
        if (data.Answer && data.Answer.length > 0) {
            return data.Answer[0].data;
        } else {
            throw new constants_1.UnknownError({
                info: {
                    domain,
                    apiURL
                }
            }, 'No IP Address found or bad domain name');
        }
    } catch (error) {
        throw new constants_1.UnknownError({
            info: {
                domain,
                apiURL
            },
            cause: error
        }, 'message' in error ? error.message : String(error));
    }
} //# sourceMappingURL=misc.js.map
}),
"[project]/node_modules/@lit-protocol/misc/src/lib/utils.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isTokenOperator = isTokenOperator;
exports.isValidBooleanExpression = isValidBooleanExpression;
function isTokenOperator(token) {
    const OPERATORS = [
        'and',
        'or'
    ]; // Only permissible boolean operators on the nodes
    return token.hasOwnProperty('operator') && OPERATORS.includes(token.operator);
}
function isValidBooleanExpression(expression) {
    const STATES = {
        START: 'start',
        CONDITION: 'condition',
        OPERATOR: 'operator'
    };
    let currentState = STATES.START;
    for (const token of expression){
        switch(currentState){
            case STATES.START:
            case STATES.OPERATOR:
                if (isTokenOperator(token)) {
                    return false;
                }
                // Nested conditions expression
                if (Array.isArray(token) && !isValidBooleanExpression(token)) {
                    return false;
                }
                currentState = STATES.CONDITION;
                break;
            default:
                if (!isTokenOperator(token)) {
                    return false;
                }
                currentState = STATES.OPERATOR;
        }
    }
    return currentState === STATES.CONDITION;
} //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/@lit-protocol/misc/src/lib/params-validators.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Param Validators is an abstraction of validating params of a function, each validator
 * returns a boolean value indicating whether the validation is passed or not.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.paramsValidators = exports.safeParams = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib/utils.js [app-client] (ecmascript)");
const constants_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/misc/node_modules/@lit-protocol/constants/src/index.js [app-client] (ecmascript)");
const misc_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/misc/src/lib/misc.js [app-client] (ecmascript)");
const utils_2 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/misc/src/lib/utils.js [app-client] (ecmascript)");
const safeParams = ({ functionName, params })=>{
    if (!exports.paramsValidators[functionName]) {
        (0, misc_1.log)(`This function ${functionName} is skipping params safe guarding.`);
        return (0, constants_1.ERight)(undefined);
    }
    const paramValidators = exports.paramsValidators[functionName](params);
    for (const validator of paramValidators){
        const validationResponse = validator.validate();
        if (validationResponse.type === constants_1.EITHER_TYPE.ERROR) {
            return validationResponse;
        }
    }
    return (0, constants_1.ERight)(undefined);
};
exports.safeParams = safeParams;
exports.paramsValidators = {
    // ========== NO AUTH MATERIAL NEEDED FOR CLIENT SIDE ENCRYPTION ==========
    encrypt: (params)=>[
            new AccessControlConditionsValidator('encrypt', params)
        ],
    encryptUint8Array: (params)=>[
            new AccessControlConditionsValidator('encryptUint8Array', params),
            new Uint8ArrayValidator('encryptUint8Array', params.dataToEncrypt)
        ],
    encryptFile: (params)=>[
            new AccessControlConditionsValidator('encryptFile', params),
            new FileValidator('encryptFile', params.file)
        ],
    encryptString: (params)=>[
            new AccessControlConditionsValidator('encryptString', params),
            new StringValidator('encryptString', params.dataToEncrypt, 'dataToEncrypt')
        ],
    encryptToJson: (params)=>[
            new AccessControlConditionsValidator('encryptToJson', params),
            new EncryptToJsonValidator('encryptToJson', params)
        ],
    // ========== REQUIRED AUTH MATERIAL VALIDATORS ==========
    executeJs: (params)=>[
            new AuthMaterialValidator('executeJs', params),
            new ExecuteJsValidator('executeJs', params)
        ],
    decrypt: (params)=>[
            new AccessControlConditionsValidator('decrypt', params),
            new AuthMaterialValidator('decrypt', params, true),
            new StringValidator('decrypt', params.ciphertext, 'ciphertext')
        ],
    decryptFromJson: (params)=>[
            new AuthMaterialValidator('decryptFromJson', params),
            new DecryptFromJsonValidator('decryptFromJson', params.parsedJsonData)
        ]
};
class EncryptToJsonValidator {
    constructor(fnName, params){
        this.fnName = fnName;
        this.params = params;
    }
    validate() {
        const { file, string } = this.params;
        if (string === undefined && file === undefined) return (0, constants_1.ELeft)(new constants_1.InvalidParamType({
            info: {
                param: 'string',
                value: string,
                functionName: this.fnName
            }
        }, 'Either string or file must be provided'));
        if (string !== undefined && file !== undefined) return (0, constants_1.ELeft)(new constants_1.InvalidParamType({
            info: {
                param: 'string',
                value: string,
                functionName: this.fnName
            }
        }, 'Provide only a "string" or "file" to encrypt; you cannot provide both'));
        return (0, constants_1.ERight)(undefined);
    }
}
class DecryptFromJsonValidator {
    constructor(fnName, params){
        this.fnName = fnName;
        this.params = params;
    }
    validate() {
        const validators = [
            new StringValidator(this.fnName, this.params.dataType)
        ];
        for (const validator of validators){
            const validationResponse = validator.validate();
            if (validationResponse.type === constants_1.EITHER_TYPE.ERROR) {
                return validationResponse;
            }
        }
        const { dataType } = this.params;
        if (dataType !== 'string' && dataType !== 'file') return (0, constants_1.ELeft)(new constants_1.InvalidArgumentException({
            info: {
                functionName: this.fnName,
                dataType
            }
        }, `dataType of %s is not valid. Must be 'string' or 'file'.`, dataType));
        return (0, constants_1.ERight)(undefined);
    }
}
class Uint8ArrayValidator {
    constructor(fnName, uint8array, paramName = 'uint8array'){
        this.fnName = fnName;
        this.paramName = paramName;
        this.uint8array = uint8array;
    }
    validate() {
        if (!this.uint8array) {
            return (0, constants_1.ELeft)(new constants_1.InvalidParamType({}, 'uint8array is undefined'));
        }
        if (!(0, misc_1.checkType)({
            value: this.uint8array,
            allowedTypes: [
                'Uint8Array'
            ],
            paramName: this.paramName,
            functionName: this.fnName
        })) return (0, constants_1.ELeft)(new constants_1.InvalidParamType({
            info: {
                param: this.paramName,
                value: this.uint8array,
                functionName: this.fnName
            }
        }, '%s is not a Uint8Array', this.paramName));
        return (0, constants_1.ERight)(undefined);
    }
}
class StringValidator {
    constructor(fnName, str, paramName = 'string', checkIsHex = false){
        this.fnName = fnName;
        this.paramName = paramName;
        this.checkIsHex = checkIsHex;
        this.str = str;
    }
    validate() {
        if (!this.str) {
            return (0, constants_1.ELeft)(new constants_1.InvalidParamType({}, 'str is undefined'));
        }
        if (!(0, misc_1.checkType)({
            value: this.str,
            allowedTypes: [
                'String'
            ],
            paramName: this.paramName,
            functionName: this.fnName
        })) return (0, constants_1.ELeft)(new constants_1.InvalidParamType({
            info: {
                param: this.paramName,
                value: this.str,
                functionName: this.fnName
            }
        }, '%s is not a string', this.paramName));
        if (this.checkIsHex && !(0, utils_1.isHexString)(this.str)) {
            return (0, constants_1.ELeft)(new constants_1.InvalidParamType({
                info: {
                    param: this.paramName,
                    value: this.str,
                    functionName: this.fnName
                }
            }, '%s is not a valid hex string', this.paramName));
        }
        return (0, constants_1.ERight)(undefined);
    }
}
class AuthMethodValidator {
    constructor(fnName, authMethods){
        this.fnName = fnName;
        this.authMethods = authMethods;
    }
    validate() {
        const { authMethods } = this;
        if (authMethods && authMethods.length > 0 && !(0, misc_1.checkType)({
            value: authMethods,
            allowedTypes: [
                'Array'
            ],
            paramName: 'authMethods',
            functionName: this.fnName
        })) return (0, constants_1.ELeft)(new constants_1.InvalidParamType({
            info: {
                param: 'authMethods',
                value: authMethods,
                functionName: this.fnName
            }
        }, 'authMethods is not an array'));
        return (0, constants_1.ERight)(undefined);
    }
}
class ExecuteJsValidator {
    constructor(fnName, params){
        this.fnName = fnName;
        this.params = params;
    }
    validate() {
        const { code, ipfsId } = this.params;
        // -- validate: either 'code' or 'ipfsId' must exists
        if (!code && !ipfsId) {
            return (0, constants_1.ELeft)(new constants_1.ParamsMissingError({
                info: {
                    functionName: this.fnName,
                    params: this.params
                }
            }, 'You must pass either code or ipfsId'));
        }
        // -- validate: 'code' and 'ipfsId' can't exists at the same time
        if (code && ipfsId) {
            return (0, constants_1.ELeft)(new constants_1.ParamsMissingError({
                info: {
                    functionName: this.fnName,
                    params: this.params
                }
            }, "You cannot have both 'code' and 'ipfs' at the same time"));
        }
        return (0, constants_1.ERight)(undefined);
    }
}
class FileValidator {
    constructor(fnName, file){
        this.fnName = fnName;
        this.file = file;
    }
    validate() {
        if (!this.file) {
            return (0, constants_1.ELeft)(new constants_1.InvalidArgumentException({
                info: {
                    functionName: this.fnName,
                    file: this.file
                }
            }, 'You must pass file param'));
        }
        const allowedTypes = [
            'Blob',
            'File',
            'Uint8Array'
        ];
        if (!(0, misc_1.checkType)({
            value: this.file,
            allowedTypes,
            paramName: 'file',
            functionName: this.fnName
        })) return (0, constants_1.ELeft)(new constants_1.InvalidArgumentException({
            info: {
                functionName: this.fnName,
                file: this.file,
                allowedTypes
            }
        }, 'File param is not a valid Blob or File object'));
        return (0, constants_1.ERight)(undefined);
    }
}
class AuthMaterialValidator {
    constructor(fnName, params, checkIfAuthSigRequiresChainParam = false){
        this.fnName = fnName;
        this.authMaterial = params;
        this.checkIfAuthSigRequiresChainParam = checkIfAuthSigRequiresChainParam;
    }
    validate() {
        const { authSig, sessionSigs } = this.authMaterial;
        if (authSig && !(0, misc_1.is)(authSig, 'Object', 'authSig', this.fnName)) return (0, constants_1.ELeft)(new constants_1.InvalidParamType({
            info: {
                param: 'authSig',
                value: authSig,
                functionName: this.fnName
            }
        }, 'authSig is not an object'));
        if (this.checkIfAuthSigRequiresChainParam) {
            if (!this.authMaterial.chain) return (0, constants_1.ELeft)(new constants_1.InvalidArgumentException({
                info: {
                    functionName: this.fnName,
                    chain: this.authMaterial.chain
                }
            }, 'You must pass chain param'));
            if (authSig && !(0, misc_1.checkIfAuthSigRequiresChainParam)(authSig, this.authMaterial.chain, this.fnName)) return (0, constants_1.ELeft)(new constants_1.InvalidParamType({
                info: {
                    param: 'authSig',
                    value: authSig,
                    functionName: this.fnName
                }
            }, 'authSig is not valid'));
        }
        if (sessionSigs && !(0, misc_1.is)(sessionSigs, 'Object', 'sessionSigs', this.fnName)) return (0, constants_1.ELeft)(new constants_1.InvalidParamType({
            info: {
                param: 'sessionSigs',
                value: sessionSigs,
                functionName: this.fnName
            }
        }, 'sessionSigs is not an object'));
        if (!sessionSigs && !authSig) return (0, constants_1.ELeft)(new constants_1.InvalidArgumentException({
            info: {
                functionName: this.fnName,
                sessionSigs,
                authSig
            }
        }, 'You must pass either authSig or sessionSigs'));
        // -- validate: if sessionSig and authSig exists
        if (sessionSigs && authSig) return (0, constants_1.ELeft)(new constants_1.InvalidArgumentException({
            info: {
                functionName: this.fnName,
                sessionSigs,
                authSig
            }
        }, 'You cannot have both authSig and sessionSigs'));
        return (0, constants_1.ERight)(undefined);
    }
}
class AccessControlConditionsValidator {
    constructor(fnName, params){
        this.fnName = fnName;
        this.conditions = params;
    }
    validate() {
        const { accessControlConditions, evmContractConditions, solRpcConditions, unifiedAccessControlConditions } = this.conditions;
        if (accessControlConditions && !(0, misc_1.is)(accessControlConditions, 'Array', 'accessControlConditions', this.fnName)) return (0, constants_1.ELeft)(new constants_1.InvalidParamType({
            info: {
                param: 'accessControlConditions',
                value: accessControlConditions,
                functionName: this.fnName
            }
        }, '%s is not an array', 'accessControlConditions'));
        if (evmContractConditions && !(0, misc_1.is)(evmContractConditions, 'Array', 'evmContractConditions', this.fnName)) return (0, constants_1.ELeft)(new constants_1.InvalidParamType({
            info: {
                param: 'evmContractConditions',
                value: evmContractConditions,
                functionName: this.fnName
            }
        }, '%s is not an array', 'evmContractConditions'));
        if (solRpcConditions && !(0, misc_1.is)(solRpcConditions, 'Array', 'solRpcConditions', this.fnName)) return (0, constants_1.ELeft)(new constants_1.InvalidParamType({
            info: {
                param: 'solRpcConditions',
                value: solRpcConditions,
                functionName: this.fnName
            }
        }, '%s is not an array', 'solRpcConditions'));
        if (unifiedAccessControlConditions && !(0, misc_1.is)(unifiedAccessControlConditions, 'Array', 'unifiedAccessControlConditions', this.fnName)) return (0, constants_1.ELeft)(new constants_1.InvalidParamType({
            info: {
                param: 'unifiedAccessControlConditions',
                value: unifiedAccessControlConditions,
                functionName: this.fnName
            }
        }, '%s is not an array', 'unifiedAccessControlConditions'));
        if (!accessControlConditions && !evmContractConditions && !solRpcConditions && !unifiedAccessControlConditions) return (0, constants_1.ELeft)(new constants_1.InvalidArgumentException({
            info: {
                functionName: this.fnName,
                conditions: this.conditions
            }
        }, 'You must pass either accessControlConditions, evmContractConditions, solRpcConditions or unifiedAccessControlConditions'));
        if (accessControlConditions && !(0, utils_2.isValidBooleanExpression)(accessControlConditions)) return (0, constants_1.ELeft)(new constants_1.InvalidBooleanException({
            info: {
                functionName: this.fnName,
                accessControlConditions
            }
        }, 'Invalid boolean Access Control Conditions'));
        if (evmContractConditions && !(0, utils_2.isValidBooleanExpression)(evmContractConditions)) return (0, constants_1.ELeft)(new constants_1.InvalidBooleanException({
            info: {
                functionName: this.fnName,
                evmContractConditions
            }
        }, 'Invalid boolean EVM Access Control Conditions'));
        if (solRpcConditions && !(0, utils_2.isValidBooleanExpression)(solRpcConditions)) return (0, constants_1.ELeft)(new constants_1.InvalidBooleanException({
            info: {
                functionName: this.fnName,
                solRpcConditions
            }
        }, 'Invalid boolean Solana Access Control Conditions'));
        if (unifiedAccessControlConditions && !(0, utils_2.isValidBooleanExpression)(unifiedAccessControlConditions)) return (0, constants_1.ELeft)(new constants_1.InvalidBooleanException({
            info: {
                functionName: this.fnName,
                unifiedAccessControlConditions
            }
        }, 'Invalid boolean Unified Access Control Conditions'));
        return (0, constants_1.ERight)(undefined);
    }
} //# sourceMappingURL=params-validators.js.map
}),
"[project]/node_modules/@lit-protocol/misc/src/lib/helper/session-sigs-validator.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parseSignedMessage = parseSignedMessage;
exports.validateSessionSig = validateSessionSig;
exports.validateSessionSigs = validateSessionSigs;
// Function to parse a signedMessage string into an object
function parseSignedMessage(signedMessage) {
    const lines = signedMessage.split('\n');
    const parsedData = {};
    let currentKey = null;
    let currentValue = '';
    lines.forEach((line)=>{
        // Match lines with 'Key: Value' pattern
        const keyValueMatch = line.match(/^([^:]+):\s*(.*)$/);
        if (keyValueMatch) {
            // Save the previous key-value pair
            if (currentKey !== null) {
                parsedData[currentKey.trim()] = currentValue.trim();
            }
            // Start a new key-value pair
            currentKey = keyValueMatch[1];
            currentValue = keyValueMatch[2];
        } else if (line.startsWith('- ')) {
            // Handle list items
            const item = line.substring(2).trim();
            if (!parsedData[currentKey]) {
                parsedData[currentKey] = [];
            }
            parsedData[currentKey].push(item);
        } else if (line.trim() === '') {
        // Skip empty lines
        } else {
            // Continuation of the current value
            currentValue += '\n' + line;
        }
    });
    // Save the last key-value pair
    if (currentKey !== null) {
        parsedData[currentKey.trim()] = currentValue.trim();
    }
    // parsedData: {
    //   'localhost wants you to sign in with your Ethereum account': '0x70997970C51812dc3A010C7d01b50e0d17dc79C8',
    //   'This is a test statement.  You can put anything you want here. I further authorize the stated URI to perform the following actions on my behalf': "(1) 'Auth': 'Auth' for 'lit-ratelimitincrease://24529'.",
    //   URI: 'lit:capability:delegation',
    //   Version: '1',
    //   'Chain ID': '1',
    //   Nonce: '0x921dd92f497527857ee8dda62f1805e56c34c99a6b37691b4e56e6fb171a5a70',
    //   'Issued At': '2024-09-19T13:07:33.606Z',
    //   'Expiration Time': '2024-09-26T13:07:33.602Z',
    //   Resources: '',
    //   '- urn': 'recap:eyJhdHQiOnsibGl0LXJhdGVsaW1pdGluY3JlYXNlOi8vMjQ1MjkiOnsiQXV0aC9BdXRoIjpbeyJuZnRfaWQiOlsiMjQ1MjkiXSwidXNlcyI6IjIwMCJ9XX19LCJwcmYiOltdfQ'
    // }
    return parsedData;
}
// Function to validate expiration date
function validateExpiration(expirationTimeStr, context) {
    const errors = [];
    const expirationTime = new Date(expirationTimeStr);
    const currentTime = new Date();
    if (isNaN(expirationTime.getTime())) {
        errors.push(`Invalid Expiration Time format in ${context}: ${expirationTimeStr}`);
    } else if (expirationTime < currentTime) {
        errors.push(`Expired ${context}. Expiration Time: ${expirationTime.toISOString()}`);
    }
    return {
        isValid: errors.length === 0,
        errors
    };
}
// Function to parse and validate capabilities
function parseCapabilities(capabilities) {
    const errors = [];
    capabilities.forEach((capability, index)=>{
        const { signedMessage } = capability;
        // Parse the signedMessage
        const parsedCapabilityMessage = parseSignedMessage(signedMessage);
        capability.parsedSignedMessage = parsedCapabilityMessage;
        // Extract and validate expiration date
        const expirationTimeStr = parsedCapabilityMessage['Expiration Time'];
        if (expirationTimeStr) {
            const validationResult = validateExpiration(expirationTimeStr, `capability ${index}`);
            if (!validationResult.isValid) {
                errors.push(...validationResult.errors);
            }
        } else {
            errors.push(`Expiration Time not found in capability ${index}'s signedMessage.`);
        }
    });
    return {
        isValid: errors.length === 0,
        errors
    };
}
/**
 * Validates the session signature.
 *
 * @param sessionSig - The session signature to validate.
 * @returns The validation result, indicating whether the session signature is valid and any errors encountered during validation.
 */ function validateSessionSig(sessionSig) {
    const errors = [];
    // Parse the main signedMessage
    let parsedSignedMessage;
    try {
        parsedSignedMessage = JSON.parse(sessionSig.signedMessage);
    } catch (error) {
        errors.push('Main signedMessage is not valid JSON.');
        return {
            isValid: false,
            errors
        };
    }
    // Validate capabilities
    const capabilities = parsedSignedMessage.capabilities;
    if (!capabilities) {
        errors.push('Capabilities not found in main signedMessage.');
    } else if (capabilities.length === 0) {
        errors.push('No capabilities found in main signedMessage.');
    } else {
        const capabilitiesValidationResult = parseCapabilities(capabilities);
        if (!capabilitiesValidationResult.isValid) {
            errors.push(...capabilitiesValidationResult.errors);
        }
    }
    // Validate outer expiration
    const outerExpirationTimeStr = parsedSignedMessage['expiration'];
    if (outerExpirationTimeStr) {
        const validationResult = validateExpiration(outerExpirationTimeStr, 'main signedMessage');
        if (!validationResult.isValid) {
            errors.push(...validationResult.errors);
        }
    } else {
        errors.push('Expiration Time not found in outer signedMessage.');
    }
    return {
        isValid: errors.length === 0,
        errors
    };
}
/**
 * Validates the session signatures.
 *
 * @param sessionSigs - The session signatures to validate.
 * @returns The validation result, indicating whether the session signatures are valid and any errors encountered during validation.
 */ function validateSessionSigs(sessionSigs) {
    const errors = [];
    Object.entries(sessionSigs).forEach(([key, sessionSig])=>{
        const validationResult = validateSessionSig(sessionSig);
        if (!validationResult.isValid) {
            errors.push(`Session Sig '${key}': ${validationResult.errors.join(', ')}`);
        }
    });
    return {
        isValid: errors.length === 0,
        errors
    };
} //# sourceMappingURL=session-sigs-validator.js.map
}),
"[project]/node_modules/@lit-protocol/misc/src/lib/helper/session-sigs-reader.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.formatSessionSigs = formatSessionSigs;
const session_sigs_validator_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/misc/src/lib/helper/session-sigs-validator.js [app-client] (ecmascript)");
function formatDuration(start, end) {
    const diff = end.getTime() - start.getTime();
    const days = Math.floor(diff / (1000 * 60 * 60 * 24));
    const hours = Math.floor(diff % (1000 * 60 * 60 * 24) / (1000 * 60 * 60));
    const minutes = Math.floor(diff % (1000 * 60 * 60) / (1000 * 60));
    const seconds = (diff % (1000 * 60) / 1000).toFixed(3);
    let elapsedTime;
    if (days > 0) {
        elapsedTime = `${days} days`;
    } else if (hours > 0) {
        elapsedTime = `${hours} hours, ${minutes} minutes, ${seconds} seconds`;
    } else {
        elapsedTime = `${minutes} minutes, ${seconds} seconds`;
    }
    return elapsedTime;
}
function formatStatus(expirationDate, currentDate) {
    if (expirationDate > currentDate) {
        const timeLeft = formatDuration(currentDate, expirationDate);
        return ` Not expired (valid for ${timeLeft})`;
    } else {
        const timeAgo = formatDuration(expirationDate, currentDate);
        return ` Expired (expired ${timeAgo} ago)`;
    }
}
/**
 * Convert this format:
 * {"lit-ratelimitincrease://25364":{"Auth/Auth":[{"nft_id":["25364"]}]}}
 * to human readable format
 */ function humanReadableAtt(obj, indentLevel = 0) {
    const indent = ' '.repeat(indentLevel * 2);
    let result = '';
    for(const key in obj){
        result += `${indent}* ${key}\n`;
        if (typeof obj[key] === 'object' && !Array.isArray(obj[key])) {
            result += humanReadableAtt(obj[key], indentLevel + 1);
        } else if (Array.isArray(obj[key])) {
            obj[key].forEach((item)=>{
                if (typeof item === 'object') {
                    result += humanReadableAtt(item, indentLevel + 1);
                } else {
                    result += `${indent}  * ${item}\n`;
                }
            });
        } else {
            result += `${indent}  * ${obj[key]}\n`;
        }
    }
    return result;
}
function formatSessionSigs(sessionSigs, currentTime = new Date()) {
    const parsedSigs = JSON.parse(sessionSigs);
    const firstNodeKey = Object.keys(parsedSigs)[0];
    const firstNode = parsedSigs[firstNodeKey];
    let signedMessage;
    try {
        signedMessage = JSON.parse(firstNode.signedMessage);
    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        throw new Error(`Invalid JSON format for signedMessage: ${errorMessage}`);
    }
    const currentDate = new Date(currentTime);
    let result = `The request time is at: ${currentDate.toISOString()}\n`;
    // Outer expiration
    let issuedAt, expiration;
    try {
        issuedAt = new Date(signedMessage.issuedAt);
        expiration = new Date(signedMessage.expiration);
    } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error';
        throw new Error(`Error parsing issuedAt or expiration: ${errorMessage}`);
    }
    result += '* Outer expiration:\n';
    result += `    * Issued at: ${issuedAt.toISOString()}\n`;
    result += `    * Expiration: ${expiration.toISOString()}\n`;
    result += `    * Duration: ${formatDuration(issuedAt, expiration)}\n`;
    result += `    * Status: ${formatStatus(expiration, currentDate)}\n`;
    // Capabilities
    result += '* Capabilities:\n';
    signedMessage.capabilities.forEach((cap, index)=>{
        const capType = cap.derivedVia;
        const parsedCapMessage = (0, session_sigs_validator_1.parseSignedMessage)(cap.signedMessage);
        let attenuation = '';
        try {
            const encodedRecap = parsedCapMessage['- urn']?.split(':')[1];
            const decodedRecap = atob(encodedRecap);
            const jsonRecap = JSON.parse(decodedRecap);
            attenuation = humanReadableAtt(jsonRecap.att, 6);
        } catch (e) {
            // swallow error
            console.log('Error parsing attenuation::', e);
        }
        const capIssuedAt = new Date(parsedCapMessage['Issued At'] || '');
        const capExpiration = new Date(parsedCapMessage['Expiration Time'] || '');
        result += `    * Capability ${index + 1} (${capType}):\n`;
        result += `        * Issued at: ${capIssuedAt.toISOString()}\n`;
        result += `        * Expiration: ${capExpiration.toISOString()}\n`;
        result += `        * Duration: ${formatDuration(capIssuedAt, capExpiration)}\n`;
        result += `        * Status: ${formatStatus(capExpiration, currentDate)}\n`;
        result += `        * Attenuation:\n`;
        result += attenuation;
    });
    return result;
} //# sourceMappingURL=session-sigs-reader.js.map
}),
"[project]/node_modules/@lit-protocol/misc/src/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.formatSessionSigs = exports.validateSessionSigs = exports.validateSessionSig = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/misc/node_modules/tslib/tslib.es6.js [app-client] (ecmascript)");
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/misc/src/lib/addresses.js [app-client] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/misc/src/lib/misc.js [app-client] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/misc/src/lib/params-validators.js [app-client] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/misc/src/lib/utils.js [app-client] (ecmascript)"), exports);
var session_sigs_validator_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/misc/src/lib/helper/session-sigs-validator.js [app-client] (ecmascript)");
Object.defineProperty(exports, "validateSessionSig", {
    enumerable: true,
    get: function() {
        return session_sigs_validator_1.validateSessionSig;
    }
});
Object.defineProperty(exports, "validateSessionSigs", {
    enumerable: true,
    get: function() {
        return session_sigs_validator_1.validateSessionSigs;
    }
});
var session_sigs_reader_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/misc/src/lib/helper/session-sigs-reader.js [app-client] (ecmascript)");
Object.defineProperty(exports, "formatSessionSigs", {
    enumerable: true,
    get: function() {
        return session_sigs_reader_1.formatSessionSigs;
    }
}); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@lit-protocol/misc/node_modules/json-schema-traverse/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var traverse = module.exports = function(schema, opts, cb) {
    // Legacy support for v0.3.1 and earlier.
    if (typeof opts == 'function') {
        cb = opts;
        opts = {};
    }
    cb = opts.cb || cb;
    var pre = typeof cb == 'function' ? cb : cb.pre || function() {};
    var post = cb.post || function() {};
    _traverse(opts, pre, post, schema, '', schema);
};
traverse.keywords = {
    additionalItems: true,
    items: true,
    contains: true,
    additionalProperties: true,
    propertyNames: true,
    not: true,
    if: true,
    then: true,
    else: true
};
traverse.arrayKeywords = {
    items: true,
    allOf: true,
    anyOf: true,
    oneOf: true
};
traverse.propsKeywords = {
    $defs: true,
    definitions: true,
    properties: true,
    patternProperties: true,
    dependencies: true
};
traverse.skipKeywords = {
    default: true,
    enum: true,
    const: true,
    required: true,
    maximum: true,
    minimum: true,
    exclusiveMaximum: true,
    exclusiveMinimum: true,
    multipleOf: true,
    maxLength: true,
    minLength: true,
    pattern: true,
    format: true,
    maxItems: true,
    minItems: true,
    uniqueItems: true,
    maxProperties: true,
    minProperties: true
};
function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for(var key in schema){
            var sch = schema[key];
            if (Array.isArray(sch)) {
                if (key in traverse.arrayKeywords) {
                    for(var i = 0; i < sch.length; i++)_traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
                }
            } else if (key in traverse.propsKeywords) {
                if (sch && typeof sch == 'object') {
                    for(var prop in sch)_traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
                }
            } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
                _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
            }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    }
}
function escapeJsonPtr(str) {
    return str.replace(/~/g, '~0').replace(/\//g, '~1');
}
}),
"[project]/node_modules/@lit-protocol/logger/src/lib/logger.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LogManager = exports.Logger = exports.LogLevel = exports.LOG_LEVEL = void 0;
const constants_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/logger/node_modules/@lit-protocol/constants/src/index.js [app-client] (ecmascript)");
Object.defineProperty(exports, "LOG_LEVEL", {
    enumerable: true,
    get: function() {
        return constants_1.LOG_LEVEL;
    }
});
const utils_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib/utils.js [app-client] (ecmascript)");
var LogLevel;
(function(LogLevel) {
    LogLevel[LogLevel["OFF"] = -1] = "OFF";
    LogLevel[LogLevel["ERROR"] = 0] = "ERROR";
    LogLevel[LogLevel["INFO"] = 1] = "INFO";
    LogLevel[LogLevel["DEBUG"] = 2] = "DEBUG";
    LogLevel[LogLevel["WARN"] = 3] = "WARN";
    LogLevel[LogLevel["FATAL"] = 4] = "FATAL";
    LogLevel[LogLevel["TIMING_START"] = 5] = "TIMING_START";
    LogLevel[LogLevel["TIMING_END"] = 6] = "TIMING_END";
})(LogLevel || (exports.LogLevel = LogLevel = {}));
const colours = {
    reset: '\x1b[0m',
    bright: '\x1b[1m',
    dim: '\x1b[2m',
    underscore: '\x1b[4m',
    blink: '\x1b[5m',
    reverse: '\x1b[7m',
    hidden: '\x1b[8m',
    fg: {
        black: '\x1b[30m',
        red: '\x1b[31m',
        green: '\x1b[32m',
        yellow: '\x1b[33m',
        blue: '\x1b[34m',
        magenta: '\x1b[35m',
        cyan: '\x1b[36m',
        white: '\x1b[37m',
        gray: '\x1b[90m',
        crimson: '\x1b[38m'
    },
    bg: {
        black: '\x1b[40m',
        red: '\x1b[41m',
        green: '\x1b[42m',
        yellow: '\x1b[43m',
        blue: '\x1b[44m',
        magenta: '\x1b[45m',
        cyan: '\x1b[46m',
        white: '\x1b[47m',
        gray: '\x1b[100m',
        crimson: '\x1b[48m'
    }
};
function _convertLoggingLevel(level) {
    switch(level){
        case constants_1.LOG_LEVEL.INFO:
            return `${colours.fg.green}[INFO]${colours.reset}`;
        case constants_1.LOG_LEVEL.DEBUG:
            return `${colours.fg.cyan}[DEBUG]${colours.reset}`;
        case constants_1.LOG_LEVEL.WARN:
            return `${colours.fg.yellow}[WARN]${colours.reset}`;
        case constants_1.LOG_LEVEL.ERROR:
            return `${colours.fg.red}[ERROR]${colours.reset}`;
        case constants_1.LOG_LEVEL.FATAL:
            return `${colours.fg.red}[FATAL]${colours.reset}`;
        case constants_1.LOG_LEVEL.TIMING_START:
            return `${colours.fg.green}[TIME_START]${colours.reset}`;
        case constants_1.LOG_LEVEL.TIMING_END:
            return `${colours.fg.green}[TIME_END]${colours.reset}`;
    }
    return '[UNKNOWN]';
}
function _resolveLoggingHandler(level) {
    switch(level){
        case constants_1.LOG_LEVEL.DEBUG:
            return console.debug;
        case constants_1.LOG_LEVEL.INFO:
            return console.info;
        case constants_1.LOG_LEVEL.ERROR:
            return console.error;
        case constants_1.LOG_LEVEL.WARN:
            return console.warn;
        case constants_1.LOG_LEVEL.FATAL:
            return console.error;
        case constants_1.LOG_LEVEL.TIMING_END:
            return console.timeLog;
        case constants_1.LOG_LEVEL.TIMING_START:
            return console.time;
    }
}
/**
 * Implementation of `JSON.stringify` which removes circular object references
 * @example
 * let circ = {foo: 'bar'};
 * circ.circ = circ; // creates a circular reference
 * _safeStringify(circ) -> {foo: 'bar'}
 * @param obj object to check for circular references
 * @param indent number of indents to include (spaces)
 * @returns obj param without without circular references
 */ function _safeStringify(obj, indent = 2) {
    let cache = [];
    const retVal = JSON.stringify(obj, (_key, value)=>typeof value === 'object' && value !== null ? cache?.includes(value) ? undefined // Duplicate reference found, discard key
         : cache?.push(value) && value // Store value in our collection
         : value, indent);
    cache = null;
    return retVal;
}
class Log {
    constructor(timestamp, message, args, id, category, level){
        this.timestamp = timestamp;
        this.message = message;
        this.args = args;
        this.id = id;
        this.category = category;
        this.level = level;
    }
    toString() {
        let fmtStr = `[Lit-JS-SDK v${constants_1.version}]${_convertLoggingLevel(this.level)} [${this.category}] [id: ${this.id}] ${this.message}`;
        for(let i = 0; i < this.args.length; i++){
            if (typeof this.args[i] === 'object') {
                fmtStr = `${fmtStr} ${_safeStringify(this.args[i])}`;
            } else {
                fmtStr = `${fmtStr} ${this.args[i]}`;
            }
        }
        return fmtStr;
    }
    toArray() {
        const args = [];
        args.push(`[Lit-JS-SDK v${constants_1.version}]`);
        args.push(`[${this.timestamp}]`);
        args.push(_convertLoggingLevel(this.level));
        args.push(`[${this.category}]`);
        this.id && args.push(`${colours.fg.cyan}[id: ${this.id}]${colours.reset}`);
        this.message && args.push(this.message);
        for(let i = 0; i < this.args.length; i++){
            args.push(this.args[i]);
        }
        return args;
    }
    toJSON() {
        return {
            timestamp: this.timestamp,
            message: this.message,
            args: this.args,
            id: this.id,
            category: this.category,
            level: this.level
        };
    }
}
class Logger {
    static createLogger(category, level, id, isParent, config) {
        return new Logger(category, level, id, isParent, config);
    }
    constructor(category, level, id, isParent, config){
        this._logs = [];
        this._logHashes = new Map();
        this._logFormat = 'text';
        this._serviceName = 'lit-sdk';
        this._category = category;
        this._level = level;
        this._id = id;
        this._consoleHandler = _resolveLoggingHandler(this._level);
        this._config = config;
        this._children = new Map();
        this._isParent = isParent;
        this._timestamp = Date.now();
    }
    get id() {
        return this._id;
    }
    get category() {
        return this._category;
    }
    get timestamp() {
        return this._timestamp;
    }
    get Logs() {
        return this._logs;
    }
    set Config(value) {
        this._config = value;
    }
    get Config() {
        return this._config;
    }
    get Children() {
        return this._children;
    }
    setLevel(level) {
        this._level = level;
    }
    setHandler(handler) {
        this._handler = handler;
    }
    info(message = '', ...args) {
        this._log(constants_1.LOG_LEVEL.INFO, message, ...args);
    }
    debug(message = '', ...args) {
        this._log(constants_1.LOG_LEVEL.DEBUG, message, ...args);
    }
    warn(message = '', ...args) {
        this._log(constants_1.LOG_LEVEL.WARN, message, args);
    }
    error(message = '', ...args) {
        this._log(constants_1.LOG_LEVEL.ERROR, message, ...args);
    }
    fatal(message = '', ...args) {
        this._log(constants_1.LOG_LEVEL.FATAL, message, ...args);
    }
    trace(message = '', ...args) {
        this._log(constants_1.LOG_LEVEL.FATAL, message, ...args);
    }
    timeStart(message = '', ...args) {
        this._log(constants_1.LOG_LEVEL.TIMING_START, message, ...args);
    }
    timeEnd(message = '', ...args) {
        this._level < constants_1.LOG_LEVEL.OFF && this._log(constants_1.LOG_LEVEL.TIMING_END, message, ...args);
    }
    _log(level, message = '', ...args) {
        const log = new Log(new Date().toISOString(), message, args, this._id, this._category, level);
        const shouldLog = !this._config?.['condenseLogs'] || !this._checkHash(log);
        const levelCheck = this._level >= level || level === constants_1.LOG_LEVEL.ERROR || level === LogLevel.ERROR;
        if (shouldLog && levelCheck) {
            // Use JSON output if configured
            if (this._logFormat === 'json' || this._logFormat === 'datadog') {
                const jsonLog = this._formatJsonLog(log);
                console.log(JSON.stringify(jsonLog));
            } else {
                // Use traditional array log format
                const arrayLog = log.toArray();
                this._consoleHandler && this._consoleHandler(...arrayLog);
            }
            // Always call custom handler if set
            this._handler && this._handler(log);
            this._addLog(log);
        }
    }
    _checkHash(log) {
        const strippedMessage = this._cleanString(log.message);
        const digest = (0, utils_1.hashMessage)(strippedMessage);
        const hash = digest.toString();
        const item = this._logHashes.get(hash);
        if (item) {
            return true;
        } else {
            this._logHashes.set(hash, true);
            return false;
        }
    }
    _addLog(log) {
        this._logs.push(log);
    // TODO: currently we are not deleting old request id's which over time will fill local storage as the maximum storage size is 10mb
    // we should be deleting keys from the front of the collection of `Object.keys(category)` such that the first keys entered are deleted when we reach a pre defined key threshold
    // this implementation assumes that serialization / deserialization from `localStorage` keeps the same key ordering in each `category` object as we will asssume the array produced from `Object.keys` will always be the same ordering.
    // which then allows us to start at the front of the array and do `delete` operation on each key we wish to delete from the object.
    //log.id && this._addToLocalStorage(log);
    }
    _addToLocalStorage(log) {
        if (globalThis.localStorage) {
            let bucket = globalThis.localStorage.getItem(log.category);
            if (bucket) {
                bucket = JSON.parse(bucket);
                if (!bucket[log.id]) {
                    bucket[log.id] = [];
                }
                bucket[log.id].push(log.toString());
                globalThis.localStorage.setItem(log.category, _safeStringify(bucket));
            } else {
                const bucket = {};
                bucket[log.id] = [
                    log.toString()
                ];
                globalThis.localStorage.setItem(log.category, _safeStringify(bucket));
            }
        }
    }
    /**
     *
     * @param input string which will be cleaned of non utf-8 characters
     * @returns {string} input cleaned of non utf-8 characters
     */ _cleanString(input) {
        let output = '';
        for(let i = 0; i < input.length; i++){
            if (input.charCodeAt(i) <= 127) {
                output += input.charAt(i);
            }
        }
        return output;
    }
    _formatJsonLog(log) {
        const baseLog = {
            timestamp: log.timestamp,
            message: log.message,
            category: log.category,
            id: log.id,
            version: constants_1.version
        };
        if (this._logFormat === 'datadog') {
            // DataDog specific format with severity mapping
            return {
                ...baseLog,
                level: this._mapToDataDogSeverity(log.level),
                service: this._serviceName,
                metadata: {
                    args: log.args,
                    sdk_version: constants_1.version
                }
            };
        } else {
            // Generic JSON format
            return {
                ...baseLog,
                level: this._getLogLevelName(log.level),
                args: log.args
            };
        }
    }
    _mapToDataDogSeverity(level) {
        switch(level){
            case constants_1.LOG_LEVEL.DEBUG:
                return 'debug';
            case constants_1.LOG_LEVEL.INFO:
                return 'info';
            case constants_1.LOG_LEVEL.WARN:
                return 'warning';
            case constants_1.LOG_LEVEL.ERROR:
                return 'error';
            case constants_1.LOG_LEVEL.FATAL:
                return 'critical';
            case constants_1.LOG_LEVEL.TIMING_START:
            case constants_1.LOG_LEVEL.TIMING_END:
                return 'debug';
            default:
                return 'info';
        }
    }
    _getLogLevelName(level) {
        switch(level){
            case constants_1.LOG_LEVEL.DEBUG:
                return 'DEBUG';
            case constants_1.LOG_LEVEL.INFO:
                return 'INFO';
            case constants_1.LOG_LEVEL.WARN:
                return 'WARN';
            case constants_1.LOG_LEVEL.ERROR:
                return 'ERROR';
            case constants_1.LOG_LEVEL.FATAL:
                return 'FATAL';
            case constants_1.LOG_LEVEL.TIMING_START:
                return 'TIMING_START';
            case constants_1.LOG_LEVEL.TIMING_END:
                return 'TIMING_END';
            default:
                return 'UNKNOWN';
        }
    }
    setLogFormat(format) {
        this._logFormat = format;
    }
    setServiceName(serviceName) {
        this._serviceName = serviceName;
    }
}
exports.Logger = Logger;
class LogManager {
    static get Instance() {
        if (!LogManager._instance) {
            LogManager._instance = new LogManager();
        }
        return LogManager._instance;
    }
    static clearInstance() {
        LogManager._instance = undefined;
    }
    constructor(){
        this._level = constants_1.LOG_LEVEL.DEBUG;
        this._logFormat = 'text';
        this._serviceName = 'lit-sdk';
        this._loggers = new Map();
    }
    withConfig(config) {
        this._config = config;
        for (const logger of this._loggers){
            logger[1].Config = config;
        }
    }
    setLevel(level) {
        this._level = level;
        for (const logger of this._loggers){
            logger[1].setLevel(level);
        }
    }
    setHandler(handler) {
        for (const logger of this._loggers){
            logger[1].setHandler(handler);
        }
    }
    setLogFormat(format) {
        this._logFormat = format;
        for (const logger of this._loggers){
            logger[1].setLogFormat(format);
            // Also set format for all children
            for (const child of logger[1].Children){
                child[1].setLogFormat(format);
            }
        }
    }
    setServiceName(serviceName) {
        this._serviceName = serviceName;
        for (const logger of this._loggers){
            logger[1].setServiceName(serviceName);
            // Also set service name for all children
            for (const child of logger[1].Children){
                child[1].setServiceName(serviceName);
            }
        }
    }
    get LoggerIds() {
        const keys = [];
        for (const category of this._loggers.entries()){
            for (const child of category[1].Children){
                keys.push([
                    child[0],
                    child[1].timestamp
                ]);
            }
        }
        return keys.sort((a, b)=>{
            return a[1] - b[1];
        }).map((value)=>{
            return value[0];
        });
    }
    // if a logger is given an id it will persist logs under its logger instance
    get(category, id) {
        let instance = this._loggers.get(category);
        if (!instance && !id) {
            this._loggers.set(category, Logger.createLogger(category, this._level ?? constants_1.LOG_LEVEL.INFO, '', true));
            instance = this._loggers.get(category);
            instance.Config = this._config;
            instance.setLogFormat(this._logFormat);
            instance.setServiceName(this._serviceName);
            return instance;
        }
        if (id) {
            if (!instance) {
                this._loggers.set(category, Logger.createLogger(category, this._level ?? constants_1.LOG_LEVEL.INFO, '', true));
                instance = this._loggers.get(category);
                instance.Config = this._config;
                instance.setLogFormat(this._logFormat);
                instance.setServiceName(this._serviceName);
            }
            const children = instance?.Children;
            let child = children?.get(id);
            if (child) {
                return child;
            }
            children?.set(id, Logger.createLogger(category, this._level ?? constants_1.LOG_LEVEL.INFO, id ?? '', true));
            child = children?.get(id);
            child.Config = this._config;
            child.setLogFormat(this._logFormat);
            child.setServiceName(this._serviceName);
            return children?.get(id);
        // fall through condition for if there is no id for the logger and the category is not yet created.
        // ex: LogManager.Instance.get('foo');
        } else if (!instance) {
            this._loggers.set(category, Logger.createLogger(category, this._level ?? constants_1.LOG_LEVEL.INFO, '', true));
            instance = this._loggers.get(category);
            instance.Config = this._config;
            instance.setLogFormat(this._logFormat);
            instance.setServiceName(this._serviceName);
        }
        return instance;
    }
    getById(id) {
        let logStrs = [];
        for (const category of this._loggers.entries()){
            const logger = category[1].Children.get(id);
            if (logger) {
                const logStr = [];
                for (const log of logger.Logs){
                    logStr.push(log.toString());
                }
                logStrs = logStrs.concat(logStr);
            }
        }
        return logStrs;
    }
    getLogsForId(id) {
        let logsForRequest = this.getById(id);
        if (logsForRequest.length < 1 && globalThis.localStorage) {
            for (const category of this._loggers.keys()){
                const bucketStr = globalThis.localStorage.getItem(category);
                const bucket = JSON.parse(bucketStr);
                if (bucket && bucket[id]) {
                    const logsForId = bucket[id].filter((log)=>log.includes(id));
                    logsForRequest = logsForId.concat(logsForRequest);
                }
            }
        }
        return logsForRequest;
    }
}
exports.LogManager = LogManager; //# sourceMappingURL=logger.js.map
}),
"[project]/node_modules/@lit-protocol/logger/src/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
const tslib_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/logger/node_modules/tslib/tslib.es6.js [app-client] (ecmascript)");
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/logger/src/lib/logger.js [app-client] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@lit-protocol/uint8arrays/src/lib/uint8arrays.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.utf8Decode = utf8Decode;
exports.base64ToUint8Array = base64ToUint8Array;
exports.uint8ArrayToBase64 = uint8ArrayToBase64;
exports.uint8arrayFromString = uint8arrayFromString;
exports.uint8arrayToString = uint8arrayToString;
// /**
// utf8Encode - Encodes a given string into a UTF-8 encoded Uint8Array.
// @param {string} str - The input string to be encoded.
// @returns {Uint8Array} utf8Array - The UTF-8 encoded Uint8Array of the input string.
// */
const constants_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/uint8arrays/node_modules/@lit-protocol/constants/src/index.js [app-client] (ecmascript)");
function utf8Encode(str) {
    // Initialize an empty array to store the UTF-8 encoded dat
    let utf8Array = [];
    // Iterate through the characters of the input string
    for(let i = 0; i < str.length; i++){
        // Get the Unicode character code of the current character
        let charCode = str.charCodeAt(i);
        // If the character code is less than 128 (ASCII range)
        if (charCode < 128) {
            // Directly push the character code into the UTF-8 array
            utf8Array.push(charCode);
        // If the character code is between 128 and 2047 (2-byte sequence)
        } else if (charCode < 2048) {
            // Push the two-byte sequence of the character code into the UTF-8 array
            utf8Array.push(192 | charCode >> 6, 128 | charCode & 63);
        } else if (// Check if the character is a high surrogate (UTF-16)
        (charCode & 0xfc00) === 0xd800 && i + 1 < str.length && (str.charCodeAt(i + 1) & 0xfc00) === 0xdc00) {
            // Combine the high and low surrogate pair into a single UTF-32 code point
            charCode = 0x10000 + ((charCode & 0x03ff) << 10) + (str.charCodeAt(++i) & 0x03ff);
            // Push the four-byte sequence of the character code into the UTF-8 array
            utf8Array.push(240 | charCode >> 18, 128 | charCode >> 12 & 63, 128 | charCode >> 6 & 63, 128 | charCode & 63);
        } else {
            // If the character code is between 2048 and 65535 (3-byte sequence)
            // Push the three-byte sequence of the character code into the UTF-8 array
            utf8Array.push(224 | charCode >> 12, 128 | charCode >> 6 & 63, 128 | charCode & 63);
        }
    }
    return new Uint8Array(utf8Array);
}
// /**
// utf8Decode - Decodes a given UTF-8 encoded Uint8Array into a string.
// @param {Uint8Array} utf8Array - The input UTF-8 encoded Uint8Array to be decoded.
// @returns {string} str - The decoded string from the input UTF-8 encoded Uint8Array.
// */
function utf8Decode(utf8Array) {
    let str = '';
    let i = 0;
    while(i < utf8Array.length){
        let charCode = utf8Array[i++];
        if (charCode < 128) {
            str += String.fromCharCode(charCode);
        } else if (charCode > 191 && charCode < 224) {
            str += String.fromCharCode((charCode & 31) << 6 | utf8Array[i++] & 63);
        } else if (charCode > 239 && charCode < 365) {
            charCode = (charCode & 7) << 18 | (utf8Array[i++] & 63) << 12 | (utf8Array[i++] & 63) << 6 | utf8Array[i++] & 63;
            charCode -= 0x10000;
            str += String.fromCharCode(0xd800 + (charCode >> 10), 0xdc00 + (charCode & 0x3ff));
        } else {
            str += String.fromCharCode((charCode & 15) << 12 | (utf8Array[i++] & 63) << 6 | utf8Array[i++] & 63);
        }
    }
    return str;
}
function base64ToUint8Array(base64Str) {
    const binaryStr = atob(base64Str);
    const len = binaryStr.length;
    const bytes = new Uint8Array(len);
    for(let i = 0; i < len; i++){
        bytes[i] = binaryStr.charCodeAt(i);
    }
    return bytes;
}
function uint8ArrayToBase64(uint8Array) {
    let binaryStr = '';
    for(let i = 0; i < uint8Array.length; i++){
        binaryStr += String.fromCharCode(uint8Array[i]);
    }
    return btoa(binaryStr);
}
function base64UrlPadToBase64(base64UrlPadStr) {
    return base64UrlPadStr.replace('-', '+').replace('_', '/') + '='.repeat((4 - base64UrlPadStr.length % 4) % 4);
}
function base64ToBase64UrlPad(base64Str) {
    return base64Str.replace('+', '-').replace('/', '_').replace(/=+$/, '');
}
function uint8arrayFromString(str, encoding = 'utf8') {
    switch(encoding){
        case 'utf8':
            return utf8Encode(str);
        case 'base16':
            const arr = [];
            for(let i = 0; i < str.length; i += 2){
                arr.push(parseInt(str.slice(i, i + 2), 16));
            }
            return new Uint8Array(arr);
        case 'base64':
            return base64ToUint8Array(str);
        case 'base64url':
        case 'base64urlpad':
            return base64ToUint8Array(base64UrlPadToBase64(str));
        default:
            throw new constants_1.InvalidParamType({
                info: {
                    encoding,
                    str
                }
            }, `Unsupported encoding "${encoding}"`);
    }
}
function uint8arrayToString(uint8array, encoding = 'utf8') {
    let _uint8array = new Uint8Array(uint8array);
    switch(encoding){
        case 'utf8':
            return utf8Decode(_uint8array);
        case 'base16':
            return Array.from(_uint8array).map((byte)=>byte.toString(16).padStart(2, '0')).join('');
        case 'base64':
            return uint8ArrayToBase64(_uint8array);
        case 'base64url':
        case 'base64urlpad':
            return base64ToBase64UrlPad(uint8ArrayToBase64(_uint8array));
        default:
            throw new constants_1.InvalidParamType({
                info: {
                    encoding,
                    _uint8array
                }
            }, `Unsupported encoding "${encoding}"`);
    }
} //# sourceMappingURL=uint8arrays.js.map
}),
"[project]/node_modules/@lit-protocol/uint8arrays/src/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.uint8ArrayToBase64 = exports.uint8arrayToString = exports.uint8arrayFromString = void 0;
const uint8arrays_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/uint8arrays/src/lib/uint8arrays.js [app-client] (ecmascript)");
Object.defineProperty(exports, "uint8arrayFromString", {
    enumerable: true,
    get: function() {
        return uint8arrays_1.uint8arrayFromString;
    }
});
Object.defineProperty(exports, "uint8arrayToString", {
    enumerable: true,
    get: function() {
        return uint8arrays_1.uint8arrayToString;
    }
});
Object.defineProperty(exports, "uint8ArrayToBase64", {
    enumerable: true,
    get: function() {
        return uint8arrays_1.uint8ArrayToBase64;
    }
}); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@lit-protocol/auth-browser/src/lib/chains/cosmos.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.serializeSignDoc = exports.signAndSaveAuthMessage = exports.checkAndSignCosmosAuthMessage = exports.connectCosmosProvider = void 0;
const constants_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/auth-browser/node_modules/@lit-protocol/constants/src/index.js [app-client] (ecmascript)");
const misc_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/misc/src/index.js [app-client] (ecmascript)");
const uint8arrays_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/uint8arrays/src/index.js [app-client] (ecmascript)");
/** ---------- Local Helpers ---------- */ /**
 *
 * Get the COSMOS provider from the browser web3 extension
 *
 * @returns { object || never }
 */ const getProvider = (walletType)=>{
    // -- validate
    switch(walletType){
        case 'keplr':
            if ('keplr' in window) {
                return window?.keplr;
            }
            break;
        case 'leap':
            if ('leap' in window) {
                return window?.leap;
            }
    }
    // no provider found
    throw new constants_1.NoWalletException({
        info: {
            walletType
        }
    }, 'No web3 wallet was found that works with Cosmos. Install a Cosmos wallet or choose another chain');
};
/** ---------- Exports ---------- */ /**
 *
 * Get cosmos provider details
 *
 * @property { string } chain
 */ const connectCosmosProvider = async ({ chain, walletType })=>{
    const chainId = constants_1.LIT_COSMOS_CHAINS[chain].chainId;
    const wallet = getProvider(walletType);
    // Enabling before using the Cosmos wallet is recommended.
    // This method will ask the user whether to allow access if they haven't visited this website.
    // Also, it will request that the user unlock the wallet if the wallet is locked.
    await wallet.enable(chainId);
    const offlineSigner = wallet.getOfflineSigner(chainId);
    // You can get the address/public keys by `getAccounts` method.
    // It can return the array of address/public key.
    // But, currently, Keplr/Leap extension manages only one address/public key pair.
    // TODO: (Check if this is still the case 7 Sep 2022)
    // This line is needed to set the sender address for SigningCosmosClient.
    const accounts = await offlineSigner.getAccounts();
    return {
        provider: wallet,
        account: accounts[0].address,
        chainId
    };
};
exports.connectCosmosProvider = connectCosmosProvider;
/**
 *
 * Check if the cosmos signature is in the local storage already,
 * If not, sign and save the authenticated message
 *
 * @property { string } chain
 * @returns { AuthSig }
 */ const checkAndSignCosmosAuthMessage = async ({ chain, walletType })=>{
    const connectedCosmosProvider = await (0, exports.connectCosmosProvider)({
        chain,
        walletType
    });
    const storageKey = constants_1.LOCAL_STORAGE_KEYS.AUTH_COSMOS_SIGNATURE;
    let authSigString = localStorage.getItem(storageKey);
    // -- if not found in local storage
    if (!authSigString) {
        (0, misc_1.log)('signing auth message because sig is not in local storage');
        await (0, exports.signAndSaveAuthMessage)(connectedCosmosProvider);
        authSigString = localStorage.getItem(storageKey);
    }
    // -- if found in local storage
    let authSig = JSON.parse(authSigString);
    // -- validate
    if (connectedCosmosProvider.account != authSig.address) {
        (0, misc_1.log)('signing auth message because account is not the same as the address in the auth sig');
        await (0, exports.signAndSaveAuthMessage)(connectedCosmosProvider);
        authSigString = localStorage.getItem(storageKey);
        authSig = JSON.parse(authSigString);
    }
    (0, misc_1.log)('authSig', authSig);
    return authSig;
};
exports.checkAndSignCosmosAuthMessage = checkAndSignCosmosAuthMessage;
/**
 *
 * Save and sign the authenticated message
 * @param { CosmosProvider } connectedCosmosProvider
 *
 * @returns { void }
 */ const signAndSaveAuthMessage = async (connectedCosmosProvider)=>{
    const { provider, account, chainId } = connectedCosmosProvider;
    const now = new Date().toISOString();
    const body = constants_1.AUTH_SIGNATURE_BODY.replace('{{timestamp}}', now);
    const signed = await provider.signArbitrary(chainId, account, body);
    //Buffer.from(body).toString("base64");
    const data = (0, uint8arrays_1.uint8arrayToString)((0, uint8arrays_1.uint8arrayFromString)(body, 'utf8'), 'base64');
    const signDoc = {
        chain_id: '',
        account_number: '0',
        sequence: '0',
        fee: {
            gas: '0',
            amount: []
        },
        msgs: [
            {
                type: 'sign/MsgSignData',
                value: {
                    signer: account,
                    data
                }
            }
        ],
        memo: ''
    };
    const encodedSignedMsg = (0, exports.serializeSignDoc)(signDoc);
    const digest = await crypto.subtle.digest('SHA-256', encodedSignedMsg);
    const digest_hex = (0, uint8arrays_1.uint8arrayToString)(new Uint8Array(digest), 'base16');
    const authSig = {
        sig: signed.signature,
        derivedVia: 'cosmos.signArbitrary',
        signedMessage: digest_hex,
        address: account
    };
    localStorage.setItem(constants_1.LOCAL_STORAGE_KEYS.AUTH_COSMOS_SIGNATURE, JSON.stringify(authSig));
};
exports.signAndSaveAuthMessage = signAndSaveAuthMessage;
/**
 *
 * Turn sorted signDoc object into uint8array
 *
 * @param { CosmosSignDoc } signDoc
 * @returns { Uint8Array } serialized string in uint8array
 */ const serializeSignDoc = (signDoc)=>{
    const sorted = JSON.stringify((0, misc_1.sortedObject)(signDoc));
    return (0, uint8arrays_1.uint8arrayFromString)(sorted, 'utf8');
};
exports.serializeSignDoc = serializeSignDoc; //# sourceMappingURL=cosmos.js.map
}),
"[project]/node_modules/@lit-protocol/auth-browser/src/lib/connect-modal/modal.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = void 0;
// @ts-nocheck
// node_modules/micromodal/dist/micromodal.es.js
const constants_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/auth-browser/node_modules/@lit-protocol/constants/src/index.js [app-client] (ecmascript)");
function e(e2, t2) {
    for(var o2 = 0; o2 < t2.length; o2++){
        var n2 = t2[o2];
        n2.enumerable = n2.enumerable || false, n2.configurable = true, 'value' in n2 && (n2.writable = true), Object.defineProperty(e2, n2.key, n2);
    }
}
function t(e2) {
    return function(e3) {
        if (Array.isArray(e3)) return o(e3);
    }(e2) || function(e3) {
        if ('undefined' != typeof Symbol && Symbol.iterator in Object(e3)) return Array.from(e3);
    }(e2) || function(e3, t2) {
        if (!e3) return;
        if ('string' == typeof e3) return o(e3, t2);
        var n2 = Object.prototype.toString.call(e3).slice(8, -1);
        'Object' === n2 && e3.constructor && (n2 = e3.constructor.name);
        if ('Map' === n2 || 'Set' === n2) return Array.from(e3);
        if ('Arguments' === n2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2)) return o(e3, t2);
    }(e2) || function() {
        throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.');
    }();
}
function o(e2, t2) {
    (null == t2 || t2 > e2.length) && (t2 = e2.length);
    for(var o2 = 0, n2 = new Array(t2); o2 < t2; o2++)n2[o2] = e2[o2];
    return n2;
}
var n;
var i;
var a;
var r;
var s;
var l = (n = [
    'a[href]',
    'area[href]',
    'input:not([disabled]):not([type="hidden"]):not([aria-hidden])',
    'select:not([disabled]):not([aria-hidden])',
    'textarea:not([disabled]):not([aria-hidden])',
    'button:not([disabled]):not([aria-hidden])',
    'iframe',
    'object',
    'embed',
    '[contenteditable]',
    '[tabindex]:not([tabindex^="-"])'
], i = function() {
    function o2(e2) {
        var n2 = e2.targetModal, i3 = e2.triggers, a3 = void 0 === i3 ? [] : i3, r3 = e2.onShow, s2 = void 0 === r3 ? function() {} : r3, l2 = e2.onClose, c = void 0 === l2 ? function() {} : l2, d = e2.openTrigger, u = void 0 === d ? 'data-micromodal-trigger' : d, f = e2.closeTrigger, h = void 0 === f ? 'data-micromodal-close' : f, v = e2.openClass, g = void 0 === v ? 'is-open' : v, m = e2.disableScroll, b = void 0 !== m && m, y = e2.disableFocus, p = void 0 !== y && y, w = e2.awaitCloseAnimation, E = void 0 !== w && w, k = e2.awaitOpenAnimation, M = void 0 !== k && k, A = e2.debugMode, C = void 0 !== A && A;
        !function(e3, t2) {
            if (!(e3 instanceof t2)) throw new TypeError('Cannot call a class as a function');
        }(this, o2), this.modal = document.getElementById(n2), this.config = {
            debugMode: C,
            disableScroll: b,
            openTrigger: u,
            closeTrigger: h,
            openClass: g,
            onShow: s2,
            onClose: c,
            awaitCloseAnimation: E,
            awaitOpenAnimation: M,
            disableFocus: p
        }, a3.length > 0 && this.registerTriggers.apply(this, t(a3)), this.onClick = this.onClick.bind(this), this.onKeydown = this.onKeydown.bind(this);
    }
    var i2, a2, r2;
    return i2 = o2, (a2 = [
        {
            key: 'registerTriggers',
            value: function() {
                for(var e2 = this, t2 = arguments.length, o3 = new Array(t2), n2 = 0; n2 < t2; n2++)o3[n2] = arguments[n2];
                o3.filter(Boolean).forEach(function(t3) {
                    t3.addEventListener('click', function(t4) {
                        return e2.showModal(t4);
                    });
                });
            }
        },
        {
            key: 'showModal',
            value: function() {
                var e2 = this, t2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                if (this.activeElement = document.activeElement, this.modal.setAttribute('aria-hidden', 'false'), this.modal.classList.add(this.config.openClass), this.scrollBehaviour('disable'), this.addEventListeners(), this.config.awaitOpenAnimation) {
                    var o3 = function t3() {
                        e2.modal.removeEventListener('animationend', t3, false), e2.setFocusToFirstNode();
                    };
                    this.modal.addEventListener('animationend', o3, false);
                } else this.setFocusToFirstNode();
                this.config.onShow(this.modal, this.activeElement, t2);
            }
        },
        {
            key: 'closeModal',
            value: function() {
                var e2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null, t2 = this.modal;
                if (this.modal.setAttribute('aria-hidden', 'true'), this.removeEventListeners(), this.scrollBehaviour('enable'), this.activeElement && this.activeElement.focus && this.activeElement.focus(), this.config.onClose(this.modal, this.activeElement, e2), this.config.awaitCloseAnimation) {
                    var o3 = this.config.openClass;
                    this.modal.addEventListener('animationend', function e3() {
                        t2.classList.remove(o3), t2.removeEventListener('animationend', e3, false);
                    }, false);
                } else t2.classList.remove(this.config.openClass);
            }
        },
        {
            key: 'closeModalById',
            value: function(e2) {
                this.modal = document.getElementById(e2), this.modal && this.closeModal();
            }
        },
        {
            key: 'scrollBehaviour',
            value: function(e2) {
                if (this.config.disableScroll) {
                    var t2 = document.querySelector('body');
                    switch(e2){
                        case 'enable':
                            Object.assign(t2.style, {
                                overflow: ''
                            });
                            break;
                        case 'disable':
                            Object.assign(t2.style, {
                                overflow: 'hidden'
                            });
                    }
                }
            }
        },
        {
            key: 'addEventListeners',
            value: function() {
                this.modal.addEventListener('touchstart', this.onClick), this.modal.addEventListener('click', this.onClick), document.addEventListener('keydown', this.onKeydown);
            }
        },
        {
            key: 'removeEventListeners',
            value: function() {
                this.modal.removeEventListener('touchstart', this.onClick), this.modal.removeEventListener('click', this.onClick), document.removeEventListener('keydown', this.onKeydown);
            }
        },
        {
            key: 'onClick',
            value: function(e2) {
                (e2.target.hasAttribute(this.config.closeTrigger) || e2.target.parentNode.hasAttribute(this.config.closeTrigger)) && (e2.preventDefault(), e2.stopPropagation(), this.closeModal(e2));
            }
        },
        {
            key: 'onKeydown',
            value: function(e2) {
                27 === e2.keyCode && this.closeModal(e2), 9 === e2.keyCode && this.retainFocus(e2);
            }
        },
        {
            key: 'getFocusableNodes',
            value: function() {
                var e2 = this.modal.querySelectorAll(n);
                return Array.apply(void 0, t(e2));
            }
        },
        {
            key: 'setFocusToFirstNode',
            value: function() {
                var e2 = this;
                if (!this.config.disableFocus) {
                    var t2 = this.getFocusableNodes();
                    if (0 !== t2.length) {
                        var o3 = t2.filter(function(t3) {
                            return !t3.hasAttribute(e2.config.closeTrigger);
                        });
                        o3.length > 0 && o3[0].focus(), 0 === o3.length && t2[0].focus();
                    }
                }
            }
        },
        {
            key: 'retainFocus',
            value: function(e2) {
                var t2 = this.getFocusableNodes();
                if (0 !== t2.length) if (t2 = t2.filter(function(e3) {
                    return null !== e3.offsetParent;
                }), this.modal.contains(document.activeElement)) {
                    var o3 = t2.indexOf(document.activeElement);
                    e2.shiftKey && 0 === o3 && (t2[t2.length - 1].focus(), e2.preventDefault()), !e2.shiftKey && t2.length > 0 && o3 === t2.length - 1 && (t2[0].focus(), e2.preventDefault());
                } else t2[0].focus();
            }
        }
    ]) && e(i2.prototype, a2), r2 && e(i2, r2), o2;
}(), a = null, r = function(e2) {
    if (!document.getElementById(e2)) return console.warn("MicroModal: \u2757Seems like you have missed %c'".concat(e2, "'"), 'background-color: #f8f9fa;color: #50596c;font-weight: bold;', 'ID somewhere in your code. Refer example below to resolve it.'), console.warn('%cExample:', 'background-color: #f8f9fa;color: #50596c;font-weight: bold;', '<div class="modal" id="'.concat(e2, '"></div>')), false;
}, s = function(e2, t2) {
    if (function(e3) {
        e3.length <= 0 && (console.warn("MicroModal: \u2757Please specify at least one %c'micromodal-trigger'", 'background-color: #f8f9fa;color: #50596c;font-weight: bold;', 'data attribute.'), console.warn('%cExample:', 'background-color: #f8f9fa;color: #50596c;font-weight: bold;', '<a href="#" data-micromodal-trigger="my-modal"></a>'));
    }(e2), !t2) return true;
    for(var o2 in t2)r(o2);
    return true;
}, {
    init: function(e2) {
        var o2 = Object.assign({}, {
            openTrigger: 'data-micromodal-trigger'
        }, e2), n2 = t(document.querySelectorAll('['.concat(o2.openTrigger, ']'))), r2 = function(e3, t2) {
            var o3 = [];
            return e3.forEach(function(e4) {
                var n3 = e4.attributes[t2].value;
                void 0 === o3[n3] && (o3[n3] = []), o3[n3].push(e4);
            }), o3;
        }(n2, o2.openTrigger);
        if (true !== o2.debugMode || false !== s(n2, r2)) for(var l2 in r2){
            var c = r2[l2];
            o2.targetModal = l2, o2.triggers = t(c), a = new i(o2);
        }
    },
    show: function(e2, t2) {
        var o2 = t2 || {};
        o2.targetModal = e2, true === o2.debugMode && false === r(e2) || (a && a.removeEventListeners(), (a = new i(o2)).showModal());
    },
    close: function(e2) {
        e2 ? a.closeModalById(e2) : a.closeModal();
    }
});
'undefined' != typeof window && (window.MicroModal = l);
var micromodal_es_default = l;
// esbuilder/lit-connect-modal/src/modal.css
var modal_default = '.modal {\n  font-family: -apple-system,BlinkMacSystemFont,avenir next,avenir,helvetica neue,helvetica,ubuntu,roboto,noto,segoe ui,arial,sans-serif;\n}\n\n.lcm-modal-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background: rgba(0,0,0,0.6);\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  z-index: 12;\n}\n\n.lcm-modal-container {\n  border: 1px solid rgba(129, 89, 217, 1);\n  background-color: #fff;\n  padding: 0 1.5rem;\n  max-width: 500px;\n  max-height: 100vh;\n  border-radius: 0.25rem;\n  overflow-y: auto;\n  box-sizing: border-box;\n}\n\n.lcm-modal-content {\n  margin-top: 2rem;\n  margin-bottom: 2rem;\n  line-height: 1.5;\n  color: rgba(0,0,0,.8);\n}\n\n.lcm-wallet-container {\n  display: flex;\n  align-items: center;\n  margin: 2rem 0.5rem;\n  transition-duration: 0.2s;\n  border-radius: 0.25rem;\n  padding: 2rem;\n  cursor: pointer;\n}\n\n.lcm-wallet-container:hover {\n  background-color: #d4d4d4;\n}\n\n.lcm-wallet-logo {\n  height: 2.5rem;\n  width: 3.75rem;\n  margin-right: 1.5rem;\n}\n\n.lcm-text-column {\n  display: flex;\n  flex-direction: column;\n  align-items: flex-start;\n}\n\n.lcm-wallet-name {\n  font-weight: bold;\n  font-size: 1.2rem;\n  margin: 0;\n}\n\n.lcm-wallet-synopsis {\n  color: #777;\n  font-size: 0.9rem;\n  margin: 0;\n}\n\n\n@keyframes mmfadeIn {\n    from { opacity: 0; }\n      to { opacity: 1; }\n}\n\n@keyframes mmfadeOut {\n    from { opacity: 1; }\n      to { opacity: 0; }\n}\n\n@keyframes mmslideIn {\n  from { transform: translateY(15%); }\n    to { transform: translateY(0); }\n}\n\n@keyframes mmslideOut {\n    from { transform: translateY(0); }\n    to { transform: translateY(-10%); }\n}\n\n.micromodal-slide {\n  display: none;\n}\n\n.micromodal-slide.is-open {\n  display: block;\n}\n\n.micromodal-slide[aria-hidden="false"] .lcm-modal-overlay {\n  animation: mmfadeIn .3s cubic-bezier(0.0, 0.0, 0.2, 1);\n}\n\n.micromodal-slide[aria-hidden="false"] .lcm-modal-container {\n  animation: mmslideIn .3s cubic-bezier(0, 0, .2, 1);\n}\n\n.micromodal-slide[aria-hidden="true"] .lcm-modal-overlay {\n  animation: mmfadeOut .3s cubic-bezier(0.0, 0.0, 0.2, 1);\n}\n\n.micromodal-slide[aria-hidden="true"] .lcm-modal-container {\n  animation: mmslideOut .3s cubic-bezier(0, 0, .2, 1);\n}\n\n.micromodal-slide .lcm-modal-container,\n.micromodal-slide .lcm-modal-overlay {\n  will-change: transform;\n}\n';
// esbuilder/lit-connect-modal/src/logos/metamask.svg
var metamask_default = 'data:image/svg+xml,<svg height="355" viewBox="0 0 397 355" width="397" xmlns="http://www.w3.org/2000/svg"><g fill="none" fill-rule="evenodd" transform="translate(-1 -1)"><path d="m114.622644 327.195472 52.004717 13.810198v-18.05949l4.245283-4.249292h29.716982v21.246459 14.872523h-31.839624l-39.268868-16.997169z" fill="%23cdbdb2"/><path d="m199.528305 327.195472 50.943397 13.810198v-18.05949l4.245283-4.249292h29.716981v21.246459 14.872523h-31.839623l-39.268868-16.997169z" fill="%23cdbdb2" transform="matrix(-1 0 0 1 483.96227 0)"/><path d="m170.872644 287.889523-4.245283 35.056657 5.306604-4.249292h55.18868l6.367925 4.249292-4.245284-35.056657-8.490565-5.311615-42.452832 1.062323z" fill="%23393939"/><path d="m142.216984 50.9915022 25.471698 59.4900858 11.674528 173.158643h41.391511l12.735849-173.158643 23.349056-59.4900858z" fill="%23f89c35"/><path d="m30.7783023 181.657226-29.71698153 86.048161 74.29245393-4.249293h47.7594343v-37.181303l-2.122641-76.487253-10.613208 8.498583z" fill="%23f89d35"/><path d="m87.0283032 191.218134 87.0283028 2.124646-9.551886 44.617563-41.391511-10.623229z" fill="%23d87c30"/><path d="m87.0283032 192.280457 36.0849058 33.994334v33.994334z" fill="%23ea8d3a"/><path d="m123.113209 227.337114 42.452831 10.623229 13.79717 45.679888-9.551886 5.311615-46.698115-27.620398z" fill="%23f89d35"/><path d="m123.113209 261.331448-8.490565 65.864024 56.25-39.305949z" fill="%23eb8f35"/><path d="m174.056606 193.34278 5.306604 90.297451-15.919812-46.211049z" fill="%23ea8e3a"/><path d="m74.2924539 262.393771 48.8207551-1.062323-8.490565 65.864024z" fill="%23d87c30"/><path d="m24.4103777 355.878193 90.2122663-28.682721-40.3301901-64.801701-73.23113313 5.311616z" fill="%23eb8f35"/><path d="m167.688682 110.481588-45.636793 38.243627-35.0235858 42.492919 87.0283028 3.186969z" fill="%23e8821e"/><path d="m114.622644 327.195472 56.25-39.305949-4.245283 33.994334v19.121813l-38.207548-7.43626z" fill="%23dfcec3"/><path d="m229.245286 327.195472 55.18868-39.305949-4.245283 33.994334v19.121813l-38.207548-7.43626z" fill="%23dfcec3" transform="matrix(-1 0 0 1 513.679252 0)"/><path d="m132.665096 212.464593-11.674528 24.433427 41.39151-10.623229z" fill="%23393939" transform="matrix(-1 0 0 1 283.372646 0)"/><path d="m23.349057 1.06232296 144.339625 109.41926504-24.410378-59.4900858z" fill="%23e88f35"/><path d="m23.349057 1.06232296-19.10377392 58.42776294 10.61320772 63.7393781-7.42924541 4.249292 10.61320771 9.560906-8.49056617 7.436261 11.67452847 10.623229-7.4292454 6.373938 16.9811323 21.246459 79.5990577-24.433428c38.915096-31.161473 58.018869-47.096318 57.311322-47.804533-.707548-.708215-48.820756-37.1813036-144.339625-109.41926504z" fill="%238e5a30"/><g transform="matrix(-1 0 0 1 399.056611 0)"><path d="m30.7783023 181.657226-29.71698153 86.048161 74.29245393-4.249293h47.7594343v-37.181303l-2.122641-76.487253-10.613208 8.498583z" fill="%23f89d35"/><path d="m87.0283032 191.218134 87.0283028 2.124646-9.551886 44.617563-41.391511-10.623229z" fill="%23d87c30"/><path d="m87.0283032 192.280457 36.0849058 33.994334v33.994334z" fill="%23ea8d3a"/><path d="m123.113209 227.337114 42.452831 10.623229 13.79717 45.679888-9.551886 5.311615-46.698115-27.620398z" fill="%23f89d35"/><path d="m123.113209 261.331448-8.490565 65.864024 55.18868-38.243626z" fill="%23eb8f35"/><path d="m174.056606 193.34278 5.306604 90.297451-15.919812-46.211049z" fill="%23ea8e3a"/><path d="m74.2924539 262.393771 48.8207551-1.062323-8.490565 65.864024z" fill="%23d87c30"/><path d="m24.4103777 355.878193 90.2122663-28.682721-40.3301901-64.801701-73.23113313 5.311616z" fill="%23eb8f35"/><path d="m167.688682 110.481588-45.636793 38.243627-35.0235858 42.492919 87.0283028 3.186969z" fill="%23e8821e"/><path d="m132.665096 212.464593-11.674528 24.433427 41.39151-10.623229z" fill="%23393939" transform="matrix(-1 0 0 1 283.372646 0)"/><path d="m23.349057 1.06232296 144.339625 109.41926504-24.410378-59.4900858z" fill="%23e88f35"/><path d="m23.349057 1.06232296-19.10377392 58.42776294 10.61320772 63.7393781-7.42924541 4.249292 10.61320771 9.560906-8.49056617 7.436261 11.67452847 10.623229-7.4292454 6.373938 16.9811323 21.246459 79.5990577-24.433428c38.915096-31.161473 58.018869-47.096318 57.311322-47.804533-.707548-.708215-48.820756-37.1813036-144.339625-109.41926504z" fill="%238e5a30"/></g></g></svg>';
// esbuilder/lit-connect-modal/src/logos/coinbase.svg
var coinbase_default = 'data:image/svg+xml,<?xml version="1.0" encoding="utf-8"?>%0A<!-- Generator: Adobe Illustrator 24.0.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->%0A<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"%0A%09 viewBox="0 0 1101.64 196.79" style="enable-background:new 0 0 1101.64 196.79;" xml:space="preserve">%0A<style type="text/css">%0A%09.st0{fill:%230052FF;}%0A</style>%0A<path class="st0" d="M222.34,54.94c-40.02,0-71.29,30.38-71.29,71.05s30.48,70.79,71.29,70.79c40.81,0,71.82-30.64,71.82-71.05%0A%09C294.16,85.58,263.68,54.94,222.34,54.94z M222.61,167.47c-22.79,0-39.49-17.7-39.49-41.47c0-24.04,16.43-41.73,39.22-41.73%0A%09c23.06,0,39.75,17.96,39.75,41.73S245.4,167.47,222.61,167.47z M302.9,85.85h19.88v108.3h31.8V57.58H302.9V85.85z M71.02,84.26%0A%09c16.7,0,29.95,10.3,34.98,25.62h33.66c-6.1-32.75-33.13-54.94-68.37-54.94C31.27,54.94,0,85.32,0,126s30.48,70.79,71.29,70.79%0A%09c34.45,0,62.01-22.19,68.11-55.21H106c-4.77,15.32-18.02,25.89-34.72,25.89c-23.06,0-39.22-17.7-39.22-41.47%0A%09C32.07,101.96,47.97,84.26,71.02,84.26z M907.12,112.79l-23.32-3.43c-11.13-1.58-19.08-5.28-19.08-14%0A%09c0-9.51,10.34-14.26,24.38-14.26c15.37,0,25.18,6.6,27.3,17.43h30.74c-3.45-27.47-24.65-43.58-57.24-43.58%0A%09c-33.66,0-55.92,17.17-55.92,41.47c0,23.24,14.58,36.72,43.99,40.94l23.32,3.43c11.4,1.58,17.76,6.08,17.76,14.53%0A%09c0,10.83-11.13,15.32-26.5,15.32c-18.82,0-29.42-7.66-31.01-19.28h-31.27c2.92,26.68,23.85,45.43,62.01,45.43%0A%09c34.72,0,57.77-15.85,57.77-43.06C950.05,129.43,933.36,116.75,907.12,112.79z M338.68,1.32c-11.66,0-20.41,8.45-20.41,20.07%0A%09s8.74,20.07,20.41,20.07c11.66,0,20.41-8.45,20.41-20.07S350.34,1.32,338.68,1.32z M805.36,104.34c0-29.58-18.02-49.39-56.18-49.39%0A%09c-36.04,0-56.18,18.23-60.16,46.23h31.54c1.59-10.83,10.07-19.81,28.09-19.81c16.17,0,24.12,7.13,24.12,15.85%0A%09c0,11.36-14.58,14.26-32.6,16.11c-24.38,2.64-54.59,11.09-54.59,42.79c0,24.57,18.29,40.41,47.44,40.41%0A%09c22.79,0,37.1-9.51,44.26-24.57c1.06,13.47,11.13,22.19,25.18,22.19h18.55v-28.26h-15.64V104.34z M774.09,138.68%0A%09c0,18.23-15.9,31.7-35.25,31.7c-11.93,0-22-5.02-22-15.58c0-13.47,16.17-17.17,31.01-18.75c14.31-1.32,22.26-4.49,26.24-10.57%0A%09V138.68z M605.28,54.94c-17.76,0-32.6,7.4-43.2,19.81V0h-31.8v194.15h31.27v-17.96c10.6,12.94,25.71,20.6,43.73,20.6%0A%09c38.16,0,67.05-30.11,67.05-70.79S642.91,54.94,605.28,54.94z M600.51,167.47c-22.79,0-39.49-17.7-39.49-41.47%0A%09s16.96-41.73,39.75-41.73c23.06,0,39.22,17.7,39.22,41.73C639.99,149.77,623.3,167.47,600.51,167.47z M454.22,54.94%0A%09c-20.67,0-34.19,8.45-42.14,20.34v-17.7h-31.54v136.56h31.8v-74.22c0-20.87,13.25-35.66,32.86-35.66c18.29,0,29.68,12.94,29.68,31.7%0A%09v78.19h31.8v-80.56C506.69,79.24,488.94,54.94,454.22,54.94z M1101.64,121.51c0-39.09-28.62-66.56-67.05-66.56%0A%09c-40.81,0-70.76,30.64-70.76,71.05c0,42.53,32.07,70.79,71.29,70.79c33.13,0,59.1-19.55,65.72-47.28h-33.13%0A%09c-4.77,12.15-16.43,19.02-32.07,19.02c-20.41,0-35.78-12.68-39.22-34.87h105.21V121.51z M998.28,110.94%0A%09c5.04-19.02,19.35-28.26,35.78-28.26c18.02,0,31.8,10.3,34.98,28.26H998.28z"/>%0A</svg>%0A';
// esbuilder/lit-connect-modal/src/logos/walletconnect.svg
var walletconnect_default = 'data:image/svg+xml,<svg height="246" viewBox="0 0 400 246" width="400" xmlns="http://www.w3.org/2000/svg"><path d="m81.9180572 48.3416816c65.2149658-63.8508884 170.9493158-63.8508884 236.1642788 0l7.848727 7.6845565c3.260748 3.1925442 3.260748 8.3686816 0 11.5612272l-26.848927 26.2873374c-1.630375 1.5962734-4.273733 1.5962734-5.904108 0l-10.800779-10.5748639c-45.495589-44.5439756-119.258514-44.5439756-164.754105 0l-11.566741 11.3248068c-1.630376 1.5962721-4.273735 1.5962721-5.904108 0l-26.8489263-26.2873375c-3.2607483-3.1925456-3.2607483-8.3686829 0-11.5612272zm291.6903948 54.3649934 23.895596 23.395862c3.260732 3.19253 3.260751 8.368636.000041 11.561187l-107.746894 105.494845c-3.260726 3.192568-8.547443 3.192604-11.808214.000083-.000013-.000013-.000029-.000029-.000042-.000043l-76.472191-74.872762c-.815187-.798136-2.136867-.798136-2.952053 0-.000006.000005-.00001.00001-.000015.000014l-76.470562 74.872708c-3.260715 3.192576-8.547434 3.19263-11.808215.000116-.000019-.000018-.000039-.000037-.000059-.000058l-107.74989297-105.496247c-3.26074695-3.192544-3.26074695-8.368682 0-11.561226l23.89563947-23.395823c3.260747-3.1925446 8.5474652-3.1925446 11.8082136 0l76.4733029 74.873809c.815188.798136 2.136866.798136 2.952054 0 .000012-.000012.000023-.000023.000035-.000032l76.469471-74.873777c3.260673-3.1926181 8.547392-3.1927378 11.808214-.000267.000046.000045.000091.00009.000135.000135l76.473203 74.873909c.815186.798135 2.136866.798135 2.952053 0l76.471967-74.872433c3.260748-3.1925458 8.547465-3.1925458 11.808213 0z" fill="%233b99fc"/></svg>';
// esbuilder/lit-connect-modal/src/helpers/walletList.js
var metaMaskSingle = {
    htmlId: 'lcm-metaMask',
    id: 'metamask',
    logo: metamask_default,
    name: 'MetaMask',
    provider: globalThis.ethereum,
    synopsis: 'Connect your MetaMask Wallet',
    checkIfPresent: ()=>{
        if (typeof globalThis.ethereum !== 'undefined' && globalThis.ethereum.isMetaMask) {
            return true;
        } else {
            return false;
        }
    }
};
var coinbaseSingle = {
    htmlId: 'lcm-coinbase',
    id: 'coinbase',
    logo: coinbase_default,
    name: 'Coinbase',
    provider: globalThis.ethereum,
    synopsis: 'Connect your Coinbase Wallet',
    checkIfPresent: ()=>{
        if (typeof globalThis.ethereum !== 'undefined' && globalThis.ethereum.isCoinbaseWallet) {
            return true;
        } else {
            return false;
        }
    }
};
var rawListOfWalletsArray = [
    {
        htmlId: 'lcm-metaMask',
        id: 'metamask',
        logo: metamask_default,
        name: 'MetaMask',
        provider: globalThis.ethereum?.providers?.find((p)=>p.isMetaMask),
        synopsis: 'Connect your MetaMask Wallet',
        checkIfPresent: ()=>{
            return !!globalThis.ethereum?.providers?.find((p)=>p.isMetaMask);
        }
    },
    {
        htmlId: 'lcm-coinbase',
        id: 'coinbase',
        logo: coinbase_default,
        name: 'Coinbase',
        provider: globalThis.ethereum?.providers?.find((p)=>p.isCoinbaseWallet),
        synopsis: 'Connect your Coinbase Wallet',
        checkIfPresent: ()=>{
            return !!globalThis.ethereum?.providers?.find((p)=>p.isCoinbaseWallet);
        }
    },
    {
        htmlId: 'lcm-walletConnect',
        id: 'walletconnect',
        logo: walletconnect_default,
        name: 'WalletConnect',
        provider: null,
        synopsis: 'Scan with WalletConnect to connect'
    }
];
// esbuilder/lit-connect-modal/src/helpers/providerMethods.js
var providerMethods = {
    walletconnect: (providerOptions, id)=>{
        const walletConnectData = providerOptions.walletconnect;
        const walletConnectProvider = walletConnectData.provider;
        return walletConnectProvider;
    }
};
var providerMethods_default = providerMethods;
// esbuilder/lit-connect-modal/src/modal.js
var LitConnectModal = class {
    constructor({ providerOptions }){
        this.dialog = micromodal_es_default;
        this.closeAction = void 0;
        this.parent = document.body;
        this.filteredListOfWalletsArray = [];
        this.providerOptions = providerOptions;
        this._filterListOfWallets();
        this._instantiateLitConnectModal();
        var style = document.createElement('style');
        style.innerHTML = modal_default;
        document.head.appendChild(style);
    }
    getWalletProvider() {
        const currentProvider = localStorage.getItem('lit-web3-provider');
        this.dialog.show('lit-connect-modal');
        return new Promise((resolve, reject)=>{
            if (!!currentProvider) {
                const foundProvider = this.filteredListOfWalletsArray.find((w)=>w.id === currentProvider);
                resolve(foundProvider.provider);
                this._destroy();
                return;
            }
            this.filteredListOfWalletsArray.forEach((w)=>{
                let walletEntry = document.getElementById(w.id);
                walletEntry.addEventListener('click', ()=>{
                    localStorage.setItem('lit-web3-provider', w.id);
                    resolve(w.provider);
                    this._destroy();
                    return;
                });
            });
            this.closeAction.addEventListener('click', ()=>{
                resolve(false);
                this._destroy();
                return;
            });
        });
    }
    _filterListOfWallets() {
        const filteredListOfWalletsArray = [];
        rawListOfWalletsArray.forEach((w)=>{
            if (!!w['checkIfPresent'] && w['checkIfPresent']() === true) {
                filteredListOfWalletsArray.push(w);
            }
        });
        if (filteredListOfWalletsArray.length === 0) {
            if (globalThis.ethereum) {
                if (globalThis.ethereum.isMetaMask) {
                    filteredListOfWalletsArray.push(metaMaskSingle);
                }
                if (globalThis.ethereum.isCoinbaseWallet) {
                    filteredListOfWalletsArray.push(coinbaseSingle);
                }
            }
        }
        if (!!this.providerOptions['walletconnect']) {
            const cloneWalletInfo = rawListOfWalletsArray.find((w)=>w.id === 'walletconnect');
            cloneWalletInfo['provider'] = providerMethods_default['walletconnect'](this.providerOptions, 'walletconnect');
            filteredListOfWalletsArray.push(cloneWalletInfo);
        }
        if (filteredListOfWalletsArray.length === 0) {
            const message = 'No wallets installed or provided.';
            alert(message);
            throw new constants_1.NoWalletException({}, message);
        }
        this.filteredListOfWalletsArray = filteredListOfWalletsArray;
    }
    _instantiateLitConnectModal() {
        const connectModal = document.createElement('div');
        connectModal.setAttribute('id', 'lit-connect-modal-container');
        connectModal.innerHTML = `
        <div class="modal micromodal-slide" id="lit-connect-modal" aria-hidden="true">
            <div class="lcm-modal-overlay" id="lcm-modal-overlay" tabindex="-1" data-micromodal-close>
                <div class="lcm-modal-container" role="dialog" aria-modal="true" aria-labelledby="lit-connect-modal-title">
                    <main class="lcm-modal-content" id="lit-connect-modal-content">
                    </main>
                </div>
            </div>
        </div>
    `;
        this.parent.appendChild(connectModal);
        Object.assign(this, {
            trueButton: document.getElementById('lcm-continue-button'),
            closeAction: document.getElementById('lcm-modal-overlay')
        });
        this._buildListOfWallets();
        this.dialog.init({
            disableScroll: true,
            disableFocus: false,
            awaitOpenAnimation: false,
            awaitCloseAnimation: false,
            debugMode: false
        });
    }
    _buildListOfWallets() {
        const contentContainer = document.getElementById('lit-connect-modal-content');
        let walletListHtml = ``;
        this.filteredListOfWalletsArray.forEach((w)=>{
            walletListHtml += `
        <div class="lcm-wallet-container" id="${w.id}">
          <img class="lcm-wallet-logo"  src='${w.logo}' />
          <div class="lcm-text-column">
            <p class="lcm-wallet-name" >${w.name}</p>
            <p class="lcm-wallet-synopsis" >${w.synopsis}</p>
          </div>
        </div>
      `;
        });
        contentContainer.innerHTML = walletListHtml;
    }
    _destroy() {
        const dialog = document.getElementById('lit-connect-modal-container');
        if (!!dialog) {
            dialog.remove();
        }
    }
};
exports.default = LitConnectModal; //# sourceMappingURL=modal.js.map
}),
"[project]/node_modules/@lit-protocol/auth-browser/src/lib/chains/eth.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.signMessageAsync = exports.signMessage = exports.signAndSaveAuthMessage = exports.checkAndSignEVMAuthMessage = exports.disconnectWeb3 = exports.connectWeb3 = exports.decodeCallResult = exports.encodeCallData = exports.getRPCUrls = exports.getMustResign = exports.getChainId = exports.chainHexIdToChainName = void 0;
exports.isSignedMessageExpired = isSignedMessageExpired;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/auth-browser/node_modules/tslib/tslib.es6.js [app-client] (ecmascript)");
const buffer_1 = __turbopack_context__.r("[project]/node_modules/buffer/index.js [app-client] (ecmascript)");
const depd_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/depd/lib/browser/index.js [app-client] (ecmascript)"));
const bytes_1 = __turbopack_context__.r("[project]/node_modules/@ethersproject/bytes/lib.esm/index.js [app-client] (ecmascript)");
const providers_1 = __turbopack_context__.r("[project]/node_modules/@ethersproject/providers/lib.esm/index.js [app-client] (ecmascript)");
const strings_1 = __turbopack_context__.r("[project]/node_modules/@ethersproject/strings/lib.esm/index.js [app-client] (ecmascript)");
// import WalletConnectProvider from '@walletconnect/ethereum-provider';
const wallet_1 = __turbopack_context__.r("[project]/node_modules/@ethersproject/wallet/lib.esm/index.js [app-client] (ecmascript)");
const ethereum_provider_1 = __turbopack_context__.r("[project]/node_modules/@walletconnect/ethereum-provider/dist/index.es.js [app-client] (ecmascript)");
const ethers_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-client] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib/utils.js [app-client] (ecmascript)");
const siwe_1 = __turbopack_context__.r("[project]/node_modules/siwe/dist/siwe.js [app-client] (ecmascript)");
// @ts-ignore: If importing 'nacl' directly, the built files will use .default instead
const nacl = tslib_1.__importStar(__turbopack_context__.r("[project]/node_modules/tweetnacl/nacl-fast.js [app-client] (ecmascript)"));
const naclUtil = tslib_1.__importStar(__turbopack_context__.r("[project]/node_modules/tweetnacl-util/nacl-util.js [app-client] (ecmascript)"));
// @ts-ignore: If importing 'nacl' directly, the built files will use .default instead
const constants_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/auth-browser/node_modules/@lit-protocol/constants/src/index.js [app-client] (ecmascript)");
const misc_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/misc/src/index.js [app-client] (ecmascript)");
const misc_browser_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/misc-browser/src/index.js [app-client] (ecmascript)");
const modal_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/@lit-protocol/auth-browser/src/lib/connect-modal/modal.js [app-client] (ecmascript)"));
const deprecated = (0, depd_1.default)('lit-js-sdk:auth-browser:index');
if (globalThis && typeof globalThis.Buffer === 'undefined') {
    globalThis.Buffer = buffer_1.Buffer;
}
const WALLET_ERROR = {
    REQUESTED_CHAIN_HAS_NOT_BEEN_ADDED: 4902,
    NO_SUCH_METHOD: -32601
};
/** ---------- Local Helpers ---------- */ let litWCProvider;
/**
 *
 * Convert chain hex id to chain name
 *
 * @param { string } chainHexId
 * @returns { void | string }
 */ const chainHexIdToChainName = (chainHexId)=>{
    // -- setup
    const entries = Object.entries(constants_1.LIT_CHAINS);
    const hexIds = Object.values(constants_1.LIT_CHAINS).map((chain)=>'0x' + chain.chainId.toString(16));
    // -- validate:: must begin with 0x
    if (!chainHexId.startsWith('0x')) {
        throw new constants_1.WrongParamFormat({
            info: {
                param: 'chainHexId',
                value: chainHexId
            }
        }, '%s should begin with "0x"', chainHexId);
    }
    // -- validate:: hex id must be listed in constants
    if (!hexIds.includes(chainHexId)) {
        throw new constants_1.UnsupportedChainException({
            info: {
                chainHexId
            }
        }, `Unsupported chain selected. Please select one of: %s`, Object.keys(constants_1.LIT_CHAINS));
    }
    // -- search
    const chainName = entries.find((data)=>'0x' + data[1].chainId.toString(16) === chainHexId) || null;
    // -- success case
    if (chainName) {
        return chainName[0];
    }
    // -- fail case
    throw new constants_1.UnknownError({
        info: {
            chainHexId
        }
    }, 'Failed to convert %s', chainHexId);
};
exports.chainHexIdToChainName = chainHexIdToChainName;
/**
 * Get chain id of the current network
 * @param { string } chain
 * @param { Web3Provider } web3
 * @returns { Promise<IEither> }
 */ const getChainId = async (chain, web3)=>{
    let resultOrError;
    try {
        const resp = await web3.getNetwork();
        resultOrError = (0, constants_1.ERight)(resp.chainId);
    } catch (e) {
        // couldn't get chainId.  throw the incorrect network error
        (0, misc_1.log)('getNetwork threw an exception', e);
        resultOrError = (0, constants_1.ELeft)(new constants_1.WrongNetworkException({
            info: {
                chain
            }
        }, `Incorrect network selected. Please switch to the %s network in your wallet and try again.`, chain));
    }
    return resultOrError;
};
exports.getChainId = getChainId;
/**
 * Check if the Expiration Time in the signedMessage string is expired.
 * @param { string } signedMessage - The signed message containing the Expiration Time.
 * @returns true if expired, false otherwise.
 */ function isSignedMessageExpired(signedMessage) {
    // Extract the Expiration Time from the signed message.
    const dateStr = signedMessage.split('\n')[9]?.replace('Expiration Time: ', '');
    const expirationTime = new Date(dateStr);
    const currentTime = new Date();
    // Compare the Expiration Time with the current time.
    return currentTime > expirationTime;
}
/**
 *
 * Check if the message must resign
 *
 * @param { AuthSig } authSig
 * @param { any } resources
 *
 * @returns { boolean }
 */ const getMustResign = (authSig, resources)=>{
    let mustResign;
    // if it's not expired, then we don't need to resign
    if (!isSignedMessageExpired(authSig.signedMessage)) {
        return false;
    }
    try {
        const parsedSiwe = new siwe_1.SiweMessage(authSig.signedMessage);
        (0, misc_1.log)('parsedSiwe.resources', parsedSiwe.resources);
        if (JSON.stringify(parsedSiwe.resources) !== JSON.stringify(resources)) {
            (0, misc_1.log)('signing auth message because resources differ from the resources in the auth sig');
            mustResign = true;
        }
        if (parsedSiwe.address !== (0, utils_1.getAddress)(parsedSiwe.address)) {
            (0, misc_1.log)('signing auth message because parsedSig.address is not equal to the same address but checksummed.  This usually means the user had a non-checksummed address saved and so they need to re-sign.');
            mustResign = true;
        }
    } catch (e) {
        (0, misc_1.log)('error parsing siwe sig.  making the user sign again: ', e);
        mustResign = true;
    }
    return mustResign;
};
exports.getMustResign = getMustResign;
/**
 *
 * Get RPC Urls in the correct format
 * need to make it look like this:
   ---
   rpc: {
        1: "https://mainnet.mycustomnode.com",
        3: "https://ropsten.mycustomnode.com",
        100: "https://dai.poa.network",
        // ...
    },
   ---
 *
 * @returns
 */ const getRPCUrls = ()=>{
    const rpcUrls = {};
    const keys = Object.keys(constants_1.LIT_CHAINS);
    for (const chainName of keys){
        const chainId = constants_1.LIT_CHAINS[chainName].chainId;
        const rpcUrl = constants_1.LIT_CHAINS[chainName].rpcUrls[0];
        rpcUrls[chainId.toString()] = rpcUrl;
    }
    return rpcUrls;
};
exports.getRPCUrls = getRPCUrls;
/** ---------- Exports ---------- */ /**
 * @deprecated
 * encodeCallData has been removed.
 *
 * @param { IABIEncode }
 * @returns { string }
 */ exports.encodeCallData = deprecated.function(({ abi, functionName, functionParams })=>{
    throw new constants_1.RemovedFunctionError({}, 'encodeCallData has been removed.');
}, 'encodeCallData has been removed.');
/**
 * @deprecated
 * (ABI) Decode call data
 *
 * @param { IABIDecode }
 * @returns { string }
 */ exports.decodeCallResult = deprecated.function(({ abi, functionName, data })=>{
    const _interface = new ethers_1.ethers.utils.Interface(abi);
    const decoded = _interface.decodeFunctionResult(functionName, data);
    return decoded;
}, 'decodeCallResult will be removed.');
/**
 * @browserOnly
 * Connect to web 3
 *
 * @param { ConnectWeb3 }
 *
 * @return { Promise<ConnectWeb3Result> } web3, account
 */ const connectWeb3 = async ({ chainId = 1, walletConnectProjectId })=>{
    // -- check if it's nodejs
    if ((0, misc_1.isNode)()) {
        (0, misc_1.log)('connectWeb3 is not supported in nodejs.');
        return {
            web3: null,
            account: null
        };
    }
    const rpcUrls = (0, exports.getRPCUrls)();
    let providerOptions = {};
    if (walletConnectProjectId) {
        const wcProvider = await ethereum_provider_1.EthereumProvider.init({
            projectId: walletConnectProjectId,
            chains: [
                chainId
            ],
            showQrModal: true,
            optionalMethods: [
                'eth_sign'
            ],
            rpcMap: rpcUrls
        });
        providerOptions = {
            walletconnect: {
                provider: wcProvider
            }
        };
        if ((0, misc_1.isBrowser)()) {
            litWCProvider = wcProvider;
        }
    }
    (0, misc_1.log)('getting provider via lit connect modal');
    const dialog = new modal_1.default({
        providerOptions
    });
    const provider = await dialog.getWalletProvider();
    (0, misc_1.log)('got provider');
    // @ts-ignore
    const web3 = new providers_1.Web3Provider(provider);
    // trigger metamask popup
    try {
        deprecated('@deprecated soon to be removed. - trying to enable provider.  this will trigger the metamask popup.');
        // @ts-ignore
        await provider.enable();
    } catch (e) {
        (0, misc_1.log)("error enabling provider but swallowed it because it's not important.  most wallets use a different function now to enable the wallet so you can ignore this error, because those other methods will be tried.", e);
    }
    (0, misc_1.log)('listing accounts');
    const accounts = await web3.listAccounts();
    (0, misc_1.log)('accounts', accounts);
    const account = ethers_1.ethers.utils.getAddress(accounts[0]);
    return {
        web3,
        account
    };
};
exports.connectWeb3 = connectWeb3;
/**
 * @browserOnly
 * Delete any saved AuthSigs from local storage. Takes no params and returns
 * nothing. This will also clear out the WalletConnect cache in local storage.
 * We often run this function as a result of the user pressing a "Logout" button.
 *
 * @return { void }
 */ const disconnectWeb3 = ()=>{
    if ((0, misc_1.isNode)()) {
        (0, misc_1.log)('disconnectWeb3 is not supported in nodejs.');
        return;
    }
    // @ts-ignore
    if ((0, misc_1.isBrowser)() && litWCProvider) {
        try {
            litWCProvider.disconnect();
        } catch (err) {
            (0, misc_1.log)('Attempted to disconnect global WalletConnectProvider for lit-connect-modal', err);
        }
    }
    const storage = constants_1.LOCAL_STORAGE_KEYS;
    localStorage.removeItem(storage.AUTH_SIGNATURE);
    localStorage.removeItem(storage.AUTH_SOL_SIGNATURE);
    localStorage.removeItem(storage.AUTH_COSMOS_SIGNATURE);
    localStorage.removeItem(storage.WEB3_PROVIDER);
    localStorage.removeItem(storage.WALLET_SIGNATURE);
};
exports.disconnectWeb3 = disconnectWeb3;
/**
 * @browserOnly
 * Check and sign EVM auth message
 *
 * @param { CheckAndSignAuthParams }
 * @returns
 */ const checkAndSignEVMAuthMessage = async ({ chain, resources, switchChain, expiration, uri, walletConnectProjectId, nonce })=>{
    // -- check if it's nodejs
    if ((0, misc_1.isNode)()) {
        (0, misc_1.log)('checkAndSignEVMAuthMessage is not supported in nodejs.  You can create a SIWE on your own using the SIWE package.');
        return {
            sig: '',
            derivedVia: '',
            signedMessage: '',
            address: ''
        };
    }
    // --- scoped methods ---
    const _throwIncorrectNetworkError = (error)=>{
        if (error.code === WALLET_ERROR.NO_SUCH_METHOD) {
            throw new constants_1.WrongNetworkException({
                info: {
                    chain
                }
            }, `Incorrect network selected. Please switch to the ${chain} network in your wallet and try again.`);
        } else {
            throw error;
        }
    };
    // -- 1. prepare
    const selectedChain = constants_1.LIT_CHAINS[chain];
    const expirationString = expiration ?? getDefaultExpiration();
    const { web3, account } = await (0, exports.connectWeb3)({
        chainId: selectedChain.chainId,
        walletConnectProjectId
    });
    (0, misc_1.log)(`got web3 and account: ${account}`);
    // -- 2. prepare all required variables
    const currentChainIdOrError = await (0, exports.getChainId)(chain, web3);
    const selectedChainId = selectedChain.chainId;
    const selectedChainIdHex = (0, misc_1.numberToHex)(selectedChainId);
    let authSigOrError = (0, misc_browser_1.getStorageItem)(constants_1.LOCAL_STORAGE_KEYS.AUTH_SIGNATURE);
    (0, misc_1.log)('currentChainIdOrError:', currentChainIdOrError);
    (0, misc_1.log)('selectedChainId:', selectedChainId);
    (0, misc_1.log)('selectedChainIdHex:', selectedChainIdHex);
    (0, misc_1.log)('authSigOrError:', authSigOrError);
    // -- 3. check all variables before executing business logic
    if (currentChainIdOrError.type === constants_1.EITHER_TYPE.ERROR) {
        throw new constants_1.UnknownError({
            info: {
                chainId: chain
            },
            cause: currentChainIdOrError.result
        }, 'Unknown error when getting chain id');
    }
    (0, misc_1.log)('chainId from web3', currentChainIdOrError);
    (0, misc_1.log)(`checkAndSignAuthMessage with chainId ${currentChainIdOrError} and chain set to ${chain} and selectedChain is `, selectedChain);
    // -- 4. case: (current chain id is NOT equal to selected chain) AND is set to switch chain
    if (currentChainIdOrError.result !== selectedChainId && switchChain) {
        const provider = web3.provider;
        // -- (case) if able to switch chain id
        try {
            (0, misc_1.log)('trying to switch to chainId', selectedChainIdHex);
            await provider.request({
                method: 'wallet_switchEthereumChain',
                params: [
                    {
                        chainId: selectedChainIdHex
                    }
                ]
            });
        // -- (case) if unable to switch chain
        } catch (switchError) {
            (0, misc_1.log)('error switching to chainId', switchError);
            // -- (error case)
            if (switchError.code === WALLET_ERROR.REQUESTED_CHAIN_HAS_NOT_BEEN_ADDED) {
                try {
                    const data = [
                        {
                            chainId: selectedChainIdHex,
                            chainName: selectedChain.name,
                            nativeCurrency: {
                                name: selectedChain.name,
                                symbol: selectedChain.symbol,
                                decimals: selectedChain.decimals
                            },
                            rpcUrls: selectedChain.rpcUrls,
                            blockExplorerUrls: selectedChain.blockExplorerUrls
                        }
                    ];
                    await provider.request({
                        method: 'wallet_addEthereumChain',
                        params: data
                    });
                } catch (addError) {
                    _throwIncorrectNetworkError(addError);
                }
            } else {
                _throwIncorrectNetworkError(switchError);
            }
        }
        // we may have switched the chain to the selected chain.  set the chainId accordingly
        currentChainIdOrError.result = selectedChain.chainId;
    }
    // -- 5. case: Lit auth signature is NOT in the local storage
    (0, misc_1.log)('checking if sig is in local storage');
    if (authSigOrError.type === constants_1.EITHER_TYPE.ERROR) {
        (0, misc_1.log)('signing auth message because sig is not in local storage');
        try {
            const authSig = await _signAndGetAuth({
                web3,
                account,
                chainId: selectedChain.chainId,
                resources,
                expiration: expirationString,
                uri,
                nonce
            });
            authSigOrError = {
                type: constants_1.EITHER_TYPE.SUCCESS,
                result: JSON.stringify(authSig)
            };
        } catch (e) {
            throw new constants_1.UnknownError({
                info: {
                    account,
                    chainId: selectedChain.chainId,
                    resources,
                    expiration: expirationString,
                    uri,
                    nonce
                },
                cause: e
            }, 'Could not get authenticated message');
        }
        // Log new authSig
        (0, misc_1.log)('5. authSigOrError:', authSigOrError);
    }
    // -- 6. case: Lit auth signature IS in the local storage
    const authSigString = authSigOrError.result;
    let authSig = JSON.parse(authSigString);
    (0, misc_1.log)('6. authSig:', authSig);
    // -- 7. case: when we are NOT on the right wallet address
    if (account.toLowerCase() !== authSig.address.toLowerCase()) {
        (0, misc_1.log)('signing auth message because account is not the same as the address in the auth sig');
        authSig = await _signAndGetAuth({
            web3,
            account,
            chainId: selectedChain.chainId,
            resources,
            expiration: expirationString,
            uri,
            nonce
        });
        (0, misc_1.log)('7. authSig:', authSig);
    // -- 8. case: we are on the right wallet, but need to check the resources of the sig and re-sign if they don't match
    } else {
        const mustResign = (0, exports.getMustResign)(authSig, resources);
        if (mustResign) {
            authSig = await _signAndGetAuth({
                web3,
                account,
                chainId: selectedChain.chainId,
                resources,
                expiration: expirationString,
                uri,
                nonce
            });
        }
        (0, misc_1.log)('8. mustResign:', mustResign);
    }
    // -- 9. finally, if the authSig is expired, re-sign
    // if it's not expired, then we don't need to resign
    const checkAuthSig = (0, misc_1.validateSessionSig)(authSig);
    if (isSignedMessageExpired(authSig.signedMessage) || !checkAuthSig.isValid) {
        if (!checkAuthSig.isValid) {
            (0, misc_1.log)(`Invalid AuthSig: ${checkAuthSig.errors.join(', ')}`);
        }
        (0, misc_1.log)('9. authSig expired!, resigning..');
        authSig = await _signAndGetAuth({
            web3,
            account,
            chainId: selectedChain.chainId,
            resources,
            expiration: expirationString,
            uri,
            nonce
        });
    }
    return authSig;
};
exports.checkAndSignEVMAuthMessage = checkAndSignEVMAuthMessage;
const getDefaultExpiration = ()=>{
    return new Date(Date.now() + 1000 * 60 * 60 * 24).toISOString();
};
const _signAndGetAuth = async ({ web3, account, chainId, resources, expiration, uri, nonce })=>{
    await (0, exports.signAndSaveAuthMessage)({
        web3,
        account,
        chainId,
        resources,
        expiration,
        uri,
        nonce
    });
    const authSigOrError = (0, misc_browser_1.getStorageItem)(constants_1.LOCAL_STORAGE_KEYS.AUTH_SIGNATURE);
    if (authSigOrError.type === 'ERROR') {
        throw new constants_1.LocalStorageItemNotFoundException({
            info: {
                storageKey: constants_1.LOCAL_STORAGE_KEYS.AUTH_SIGNATURE
            }
        }, 'Failed to get authSig from local storage');
    }
    const authSig = typeof authSigOrError.result === 'string' ? JSON.parse(authSigOrError.result) : authSigOrError.result;
    return authSig;
};
/**
 * @browserOnly
 * Sign the auth message with the user's wallet, and store it in localStorage.
 * Called by checkAndSignAuthMessage if the user does not have a signature stored.
 *
 * @param { signAndSaveAuthParams }
 * @returns { AuthSig }
 */ const signAndSaveAuthMessage = async ({ web3, account, chainId, resources, expiration, uri, nonce })=>{
    // check if it's nodejs
    if ((0, misc_1.isNode)()) {
        (0, misc_1.log)('checkAndSignEVMAuthMessage is not supported in nodejs.');
        return {
            sig: '',
            derivedVia: '',
            signedMessage: '',
            address: ''
        };
    }
    // -- 1. prepare 'sign-in with ethereum' message
    const preparedMessage = {
        domain: globalThis.location.host,
        address: (0, utils_1.getAddress)(account),
        version: '1',
        chainId,
        expirationTime: expiration,
        nonce
    };
    if (resources && resources.length > 0) {
        preparedMessage.resources = resources;
    }
    if (uri) {
        preparedMessage.uri = uri;
    } else {
        preparedMessage.uri = globalThis.location.href;
    }
    const message = new siwe_1.SiweMessage(preparedMessage);
    const body = message.prepareMessage();
    const formattedAccount = (0, utils_1.getAddress)(account);
    // -- 2. sign the message
    const signedResult = await (0, exports.signMessage)({
        body,
        web3,
        account: formattedAccount
    });
    // -- 3. prepare auth message
    const authSig = {
        sig: signedResult.signature,
        derivedVia: 'web3.eth.personal.sign',
        signedMessage: body,
        address: signedResult.address
    };
    // -- 4. store auth and a keypair in localstorage for communication with sgx
    if ((0, misc_1.isBrowser)()) {
        localStorage.setItem(constants_1.LOCAL_STORAGE_KEYS.AUTH_SIGNATURE, JSON.stringify(authSig));
    }
    const commsKeyPair = nacl.box.keyPair();
    if ((0, misc_1.isBrowser)()) {
        localStorage.setItem(constants_1.LOCAL_STORAGE_KEYS.KEY_PAIR, JSON.stringify({
            publicKey: naclUtil.encodeBase64(commsKeyPair.publicKey),
            secretKey: naclUtil.encodeBase64(commsKeyPair.secretKey)
        }));
    }
    (0, misc_1.log)(`generated and saved ${constants_1.LOCAL_STORAGE_KEYS.KEY_PAIR}`);
    return authSig;
};
exports.signAndSaveAuthMessage = signAndSaveAuthMessage;
/**
 * @browserOnly
 * Sign Messags
 *
 * @param { SignMessageParams }
 *
 * @returns { Promise<SignedMessage> }
 */ const signMessage = async ({ body, web3, account })=>{
    // check if it's nodejs
    if ((0, misc_1.isNode)()) {
        (0, misc_1.log)('signMessage is not supported in nodejs.');
        return {
            signature: '',
            address: ''
        };
    }
    // -- validate
    if (!web3 || !account) {
        (0, misc_1.log)(`web3: ${web3} OR ${account} not found. Connecting web3..`);
        const res = await (0, exports.connectWeb3)({
            chainId: 1
        });
        web3 = res.web3;
        account = res.account;
    }
    (0, misc_1.log)('pausing...');
    await new Promise((resolve)=>setTimeout(resolve, 500));
    (0, misc_1.log)('signing with ', account);
    const signature = await (0, exports.signMessageAsync)(web3.getSigner(), account, body);
    const address = (0, wallet_1.verifyMessage)(body, signature).toLowerCase();
    (0, misc_1.log)('Signature: ', signature);
    (0, misc_1.log)('recovered address: ', address);
    if (address.toLowerCase() !== account.toLowerCase()) {
        const msg = `ruh roh, the user signed with a different address (${address}) then they're using with web3 (${account}). This will lead to confusion.`;
        alert('Something seems to be wrong with your wallets message signing.  maybe restart your browser or your wallet. Your recovered sig address does not match your web3 account address');
        throw new constants_1.InvalidSignatureError({
            info: {
                address,
                account
            }
        }, msg);
    }
    return {
        signature,
        address
    };
};
exports.signMessage = signMessage;
/**
 * @browserOnly
 * wrapper around signMessage that tries personal_sign first.  this is to fix a
 * bug with walletconnect where just using signMessage was failing
 *
 * @param { any | JsonRpcProvider} signer
 * @param { string } address
 * @param { string } message
 *
 * @returns { Promise<any | JsonRpcSigner> }
 */ const signMessageAsync = async (signer, address, message)=>{
    // check if it's nodejs
    if ((0, misc_1.isNode)()) {
        (0, misc_1.log)('signMessageAsync is not supported in nodejs.');
        return null;
    }
    const messageBytes = (0, strings_1.toUtf8Bytes)(message);
    if (signer instanceof providers_1.JsonRpcSigner) {
        try {
            (0, misc_1.log)('Signing with personal_sign');
            const signature = await signer.provider.send('personal_sign', [
                (0, bytes_1.hexlify)(messageBytes),
                address.toLowerCase()
            ]);
            return signature;
        } catch (e) {
            (0, misc_1.log)('Signing with personal_sign failed, trying signMessage as a fallback');
            if (e.message.includes('personal_sign')) {
                return await signer.signMessage(messageBytes);
            }
            throw e;
        }
    } else {
        (0, misc_1.log)('signing with signMessage');
        return await signer.signMessage(messageBytes);
    }
};
exports.signMessageAsync = signMessageAsync; /**
 *
 * Get the number of decimal places in a token
 *
 * @property { string } contractAddress The token contract address
 * @property { string } chain The chain on which the token is deployed
 *
 * @returns { number } The number of decimal places in the token
 */  // export const decimalPlaces = async ({
 //     contractAddress,
 //     chain,
 // }: {
 //     contractAddress: string;
 //     chain: Chain;
 // }): Promise<number> => {
 //     const rpcUrl = LIT_CHAINS[chain].rpcUrls[0] as string;
 //     const web3 = new JsonRpcProvider(rpcUrl);
 //     const contract = new Contract(
 //         contractAddress,
 //         (ABI_ERC20 as any).abi,
 //         web3
 //     );
 //     return await contract['decimals']();
 // };
 //# sourceMappingURL=eth.js.map
}),
"[project]/node_modules/@lit-protocol/auth-browser/src/lib/chains/sol.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.signAndSaveAuthMessage = exports.checkAndSignSolAuthMessage = exports.connectSolProvider = void 0;
const constants_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/auth-browser/node_modules/@lit-protocol/constants/src/index.js [app-client] (ecmascript)");
const misc_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/misc/src/index.js [app-client] (ecmascript)");
const misc_browser_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/misc-browser/src/index.js [app-client] (ecmascript)");
// import { toString as uint8arrayToString } from 'uint8arrays';
const uint8arrays_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/uint8arrays/src/index.js [app-client] (ecmascript)");
/**
 *
 * Get the Solana provider from the browser web3 extension
 *
 * @returns { object || never }
 */ const getProvider = ()=>{
    let resultOrError;
    // -- validate
    // The Backpack wallet does not inject a solana object into the window, so we need to check for the backpack object as well.
    if ('solana' in window || 'backpack' in window) {
        // only check for the solana object on the window, as keplr does not have the same client interface injected into the window.
        // @ts-ignore
        resultOrError = (0, constants_1.ERight)(window?.solana ?? window?.backpack);
    } else {
        resultOrError = (0, constants_1.ELeft)(new constants_1.NoWalletException({}, 'No web3 wallet was found that works with Solana. Install a Solana wallet or choose another chain'));
    }
    return resultOrError;
};
/**
 *
 * Get Solana provider
 *
 * @returns { Promise<IProvider }
 */ const connectSolProvider = async ()=>{
    const providerOrError = getProvider();
    if (providerOrError.type === 'ERROR') {
        throw new constants_1.UnknownError({
            info: {
                provider: providerOrError.result
            }
        }, 'Failed to get provider');
    }
    const provider = providerOrError.result;
    // No need to reconnect if already connected, some wallets such as Backpack throws an error when doing so.
    if (!provider.isConnected) {
        await provider.connect();
    }
    const account = provider.publicKey.toBase58();
    return {
        provider,
        account
    };
};
exports.connectSolProvider = connectSolProvider;
/**
 *
 * Check and sign solana auth message
 *
 * @returns { AuthSig }
 */ const checkAndSignSolAuthMessage = async ()=>{
    const res = await (0, exports.connectSolProvider)();
    if (!res) {
        (0, misc_1.log)('Failed to connect sol provider');
    }
    const provider = res?.provider;
    const account = res?.account;
    const key = constants_1.LOCAL_STORAGE_KEYS.AUTH_SOL_SIGNATURE;
    let authSigOrError = (0, misc_browser_1.getStorageItem)(key);
    // -- case: if unable to get auth from local storage
    if (authSigOrError.type === constants_1.EITHER_TYPE.ERROR) {
        (0, misc_1.log)('signing auth message because sig is not in local storage');
        await (0, exports.signAndSaveAuthMessage)({
            provider
        });
        // Refetch authSigOrError written in previous line
        authSigOrError = (0, misc_browser_1.getStorageItem)(key);
    }
    //   @ts-ignore
    window.test = authSigOrError;
    let authSig = JSON.parse(authSigOrError.result);
    // -- if the wallet address isn't the same as the address from local storage
    if (account !== authSig.address) {
        (0, misc_1.log)('signing auth message because account is not the same as the address in the auth sig');
        await (0, exports.signAndSaveAuthMessage)({
            provider
        });
        authSigOrError = (0, misc_browser_1.getStorageItem)(key);
        authSig = JSON.parse(authSigOrError.result);
    }
    (0, misc_1.log)('authSig', authSig);
    return authSig;
};
exports.checkAndSignSolAuthMessage = checkAndSignSolAuthMessage;
/**
 *
 * Sign and save auth signature locally (not saved to the nodes)
 *
 * @property { any } provider
 * @return { Promise<AuthSig | undefined> }
 *
 */ const signAndSaveAuthMessage = async ({ provider })=>{
    const now = new Date().toISOString();
    const body = constants_1.AUTH_SIGNATURE_BODY.replace('{{timestamp}}', now);
    //   turn body into Uint8Array
    const data = (0, uint8arrays_1.uint8arrayFromString)(body, 'utf8');
    //   const data = naclUtil.encode(body);
    let payload;
    let derivedVia = 'solana.signMessage';
    // Backpack wallet expects and returns a different payload from signMessage()
    if (provider?.isBackpack) {
        const result = await provider.signMessage(data);
        payload = {
            signature: result
        };
        derivedVia = 'backpack.signMessage';
    } else {
        payload = await provider.signMessage(data, 'utf8');
    }
    const hexSig = (0, uint8arrays_1.uint8arrayToString)(payload.signature, 'base16');
    const authSig = {
        sig: hexSig,
        derivedVia,
        signedMessage: body,
        address: provider.publicKey.toBase58()
    };
    localStorage.setItem(constants_1.LOCAL_STORAGE_KEYS.AUTH_SOL_SIGNATURE, JSON.stringify(authSig));
    return authSig;
};
exports.signAndSaveAuthMessage = signAndSaveAuthMessage; //# sourceMappingURL=sol.js.map
}),
"[project]/node_modules/@lit-protocol/auth-browser/src/lib/auth-browser.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.checkAndSignAuthMessage = void 0;
/**
 * FIXME: SessionSigs are only supported for EVM chains at the moment.  This will be expanded to other chains in the future.
 */ const constants_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/auth-browser/node_modules/@lit-protocol/constants/src/index.js [app-client] (ecmascript)");
const cosmos_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/auth-browser/src/lib/chains/cosmos.js [app-client] (ecmascript)");
const eth_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/auth-browser/src/lib/chains/eth.js [app-client] (ecmascript)");
const sol_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/auth-browser/src/lib/chains/sol.js [app-client] (ecmascript)");
/**
 * SUPPORTED CHAINS: EVM, Solana, Cosmos
 *
 * !! NOTE !!
 * This function is purely used for crafting the authSig for access control conditions & decryption. For SessionSigs, you can pass the `authSig` as `jsParams`
 * or Eth Wallet Auth Method for `signSessionKey` and claiming, but you won't be able to use this to add resource ability requests in the SIWE message. Instead, you should provide your own signer to the authNeededCallback parameter for the getSessionSigs method.
 *
 * Check for an existing cryptographic authentication signature and create one of it does not exist.  This is used to prove ownership of a given crypto wallet address to the Lit nodes.  The result is stored in LocalStorage so the user doesn't have to sign every time they perform an operation.
 *
 * @param { AuthCallbackParams }
 *
 *  @returns { AuthSig } The AuthSig created or retrieved
 */ const checkAndSignAuthMessage = ({ chain, resources, switchChain, expiration, uri, cosmosWalletType, walletConnectProjectId, nonce })=>{
    const chainInfo = constants_1.ALL_LIT_CHAINS[chain];
    // -- validate: if chain info not found
    if (!chainInfo) {
        throw new constants_1.UnsupportedChainException({
            info: {
                chain
            }
        }, `Unsupported chain selected.  Please select one of: %s`, Object.keys(constants_1.ALL_LIT_CHAINS));
    }
    if (!expiration) {
        // set default of 1 week
        expiration = new Date(Date.now() + 1000 * 60 * 60 * 24 * 7).toISOString();
    }
    // -- check and sign auth message based on chain
    if (chainInfo.vmType === constants_1.VMTYPE.EVM) {
        return (0, eth_1.checkAndSignEVMAuthMessage)({
            chain,
            resources,
            switchChain,
            expiration,
            uri,
            walletConnectProjectId,
            nonce
        });
    } else if (chainInfo.vmType === constants_1.VMTYPE.SVM) {
        return (0, sol_1.checkAndSignSolAuthMessage)();
    } else if (chainInfo.vmType === constants_1.VMTYPE.CVM) {
        return (0, cosmos_1.checkAndSignCosmosAuthMessage)({
            chain,
            walletType: cosmosWalletType || 'keplr'
        }); // Keplr is defaulted here, being the Cosmos wallet with the highest market share
    }
    // Else, throw an error
    throw new constants_1.UnsupportedChainException({
        info: {
            chain
        }
    }, `vmType not found for this chain: %s. This should not happen. Unsupported chain selected. Please select one of: %s`, chain, Object.keys(constants_1.ALL_LIT_CHAINS));
};
exports.checkAndSignAuthMessage = checkAndSignAuthMessage; //# sourceMappingURL=auth-browser.js.map
}),
"[project]/node_modules/@lit-protocol/auth-browser/src/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.disconnectWeb3 = exports.solConnect = exports.cosmosConnect = exports.ethConnect = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/auth-browser/node_modules/tslib/tslib.es6.js [app-client] (ecmascript)");
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/auth-browser/src/lib/auth-browser.js [app-client] (ecmascript)"), exports);
// -- all the chains you can connect to
exports.ethConnect = tslib_1.__importStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/auth-browser/src/lib/chains/eth.js [app-client] (ecmascript)"));
exports.cosmosConnect = tslib_1.__importStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/auth-browser/src/lib/chains/cosmos.js [app-client] (ecmascript)"));
exports.solConnect = tslib_1.__importStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/auth-browser/src/lib/chains/sol.js [app-client] (ecmascript)"));
var eth_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/auth-browser/src/lib/chains/eth.js [app-client] (ecmascript)");
Object.defineProperty(exports, "disconnectWeb3", {
    enumerable: true,
    get: function() {
        return eth_1.disconnectWeb3;
    }
}); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@lit-protocol/misc-browser/src/lib/misc-browser.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.injectViewerIFrame = exports.downloadFile = exports.fileToDataUrl = exports.base64StringToBlob = exports.blobToBase64String = exports.removeStorageItem = exports.setStorageItem = exports.getStorageItem = void 0;
const constants_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/misc-browser/node_modules/@lit-protocol/constants/src/index.js [app-client] (ecmascript)");
const uint8arrays_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/uint8arrays/src/index.js [app-client] (ecmascript)");
/**
 *
 * Get the local storage item by key
 *
 * @param { string } key
 */ const getStorageItem = (key)=>{
    let item;
    try {
        item = localStorage.getItem(key);
    } catch (e) {
    // swallowing
    }
    if (!item) {
        return (0, constants_1.ELeft)(new constants_1.LocalStorageItemNotFoundException({
            info: {
                storageKey: key
            }
        }, `Failed to get %s from local storage`, key));
    }
    return (0, constants_1.ERight)(item);
};
exports.getStorageItem = getStorageItem;
/**
 *
 * Set the local storage item by key
 *
 * @param { string } key is the key to set
 * @param { string } value is the value to set
 */ const setStorageItem = (key, value)=>{
    try {
        localStorage.setItem(key, value);
        return (0, constants_1.ERight)(value);
    } catch (e) {
        return (0, constants_1.ELeft)(new constants_1.LocalStorageItemNotSetException({
            info: {
                storageKey: key
            }
        }, `Failed to set %s in local storage`, key));
    }
};
exports.setStorageItem = setStorageItem;
/**
 *
 * Remove the local storage item by key
 *
 * @param { string } key is the key to remove
 * @returns { IEither } Either the key or an error
 */ const removeStorageItem = (key)=>{
    try {
        localStorage.removeItem(key);
        return (0, constants_1.ERight)(key);
    } catch (e) {
        return (0, constants_1.ELeft)(new constants_1.LocalStorageItemNotRemovedException({
            info: {
                storageKey: key
            }
        }, `Failed to remove %s from local storage`, key));
    }
};
exports.removeStorageItem = removeStorageItem;
/**
 * Convert a Blob to a base64urlpad string.  Note: This function returns a promise.
 *
 * @param { Blob | File } blob The Blob or File to turn into a base64 string
 * @returns { Promise<string> } A promise that resolves to the base64 string
 */ const blobToBase64String = async (blob)=>{
    const arrayBuffer = await blob.arrayBuffer();
    const uint8array = new Uint8Array(arrayBuffer);
    return (0, uint8arrays_1.uint8arrayToString)(uint8array, 'base64urlpad');
};
exports.blobToBase64String = blobToBase64String;
/**
 *
 * Convert a base64urlpad string to a Blob.
 * Note: This function DOES NOT return a promise
 *
 * @param { string } base64String The base64 string that to turn into a Blob
 * @returns { Blob }  A blob that contains the decoded base64 data
 */ const base64StringToBlob = (base64String)=>{
    return new Blob([
        (0, uint8arrays_1.uint8arrayFromString)(base64String, 'base64urlpad')
    ]);
};
exports.base64StringToBlob = base64StringToBlob;
/**
 *
 * Convert a file to a data URL, which could then be embedded in a LIT.
 * A data URL is a string representation of a file.
 *
 * @param { File } file The file to turn into a data url
 * @returns { string } The data URL.  This is a string representation that can be used anywhere the original file would be used.
 */ const fileToDataUrl = (file)=>{
    return new Promise((resolve)=>{
        const reader = new FileReader();
        reader.onloadend = ()=>{
            resolve(reader.result);
        };
        reader.readAsDataURL(file);
    });
};
exports.fileToDataUrl = fileToDataUrl;
/**
 *
 * // TEST: downloadFile
 * Download a file in memory to the user's computer
 *
 * @param { Object } params
 * @property { string } filename The name of the file
 * @property { Uint8Array } data The actual file itself as a Uint8Array
 * @property { string } mimetype The mime type of the file
 *
 * @returns { void } The data URL.  This is a string representation that can be used anywhere the original file would be used.
 *
 */ const downloadFile = ({ fileName, data, mimeType })=>{
    const element = document.createElement('a');
    element.setAttribute('href', 'data:' + mimeType + ';base64,' + (0, uint8arrays_1.uint8arrayToString)(data, 'base64'));
    element.setAttribute('download', fileName);
    element.style.display = 'none';
    document.body.appendChild(element);
    element.click();
    document.body.removeChild(element);
};
exports.downloadFile = downloadFile;
/**
 *
 * // TEST: injectViewerIFrame
 * Inject an iFrame into the current page that will display a LIT.
 * This function safely sandboxes the content in the iFrame so that the LIT cannot see cookies or localStorage of the parent website.
 *
 * @param { Object } params
 * @property { string } destinationId The DOM ID of the element to inject the iFrame into
 * @property { string } title The title of the content being displayed
 * @property { string } fileUrl The URL of the content that will be shown in the iFrame
 * @property { string } className An optional DOM class name to add to the iFrame for styling
 *
 * @returns { void }
 */ const injectViewerIFrame = ({ destinationId, title, fileUrl, className })=>{
    if (fileUrl.includes('data:')) {
        // data urls are not safe, refuse to do this
        throw new constants_1.InvalidArgumentException({
            info: {
                fileUrl
            }
        }, 'You can not inject an iFrame with a data url. Try a regular https URL.');
    }
    const url = new URL(fileUrl);
    if (url.host.toLowerCase() === window.location.host.toLowerCase()) {
        throw new constants_1.InvalidArgumentException({
            info: {
                fileUrl
            }
        }, 'You cannot host a LIT on the same domain as the parent webpage. This is because iFrames with the same origin have access to localstorage and cookies in the parent webpage which is unsafe');
    }
    const iframe = Object.assign(document.createElement('iframe'), {
        src: fileUrl,
        title: title,
        sandbox: 'allow-forms allow-scripts allow-popups  allow-modals allow-popups-to-escape-sandbox allow-same-origin',
        loading: 'lazy',
        allow: 'accelerometer; ambient-light-sensor; autoplay; battery; camera; display-capture; encrypted-media; fullscreen; geolocation; gyroscope; layout-animations; legacy-image-formats; magnetometer; microphone; midi; payment; picture-in-picture; publickey-credentials-get; sync-xhr; usb; vr; screen-wake-lock; web-share; xr-spatial-tracking'
    });
    if (className) {
        iframe.className = className;
    }
    document.getElementById(destinationId)?.appendChild(iframe);
};
exports.injectViewerIFrame = injectViewerIFrame; //# sourceMappingURL=misc-browser.js.map
}),
"[project]/node_modules/@lit-protocol/misc-browser/src/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
const tslib_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/misc-browser/node_modules/tslib/tslib.es6.js [app-client] (ecmascript)");
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/misc-browser/src/lib/misc-browser.js [app-client] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/@lit-protocol/auth-helpers/src/lib/models.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
}); //# sourceMappingURL=models.js.map
}),
"[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/@lit-protocol/auth-helpers/src/lib/recap/utils.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getRecapNamespaceAndAbility = getRecapNamespaceAndAbility;
const constants_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/@lit-protocol/constants/src/index.js [app-client] (ecmascript)");
/**
 * Map from a LitAbility to the Recap namespace and ability.
 * @throws Error if the LitAbility is unknown
 */ function getRecapNamespaceAndAbility(litAbility) {
    switch(litAbility){
        case constants_1.LIT_ABILITY.AccessControlConditionDecryption:
            return {
                recapNamespace: constants_1.LIT_NAMESPACE.Threshold,
                recapAbility: constants_1.LIT_RECAP_ABILITY.Decryption
            };
        case constants_1.LIT_ABILITY.AccessControlConditionSigning:
            return {
                recapNamespace: constants_1.LIT_NAMESPACE.Threshold,
                recapAbility: constants_1.LIT_RECAP_ABILITY.Signing
            };
        case constants_1.LIT_ABILITY.PKPSigning:
            return {
                recapNamespace: constants_1.LIT_NAMESPACE.Threshold,
                recapAbility: constants_1.LIT_RECAP_ABILITY.Signing
            };
        case constants_1.LIT_ABILITY.RateLimitIncreaseAuth:
            return {
                recapNamespace: constants_1.LIT_NAMESPACE.Auth,
                recapAbility: constants_1.LIT_RECAP_ABILITY.Auth
            };
        case constants_1.LIT_ABILITY.LitActionExecution:
            return {
                recapNamespace: constants_1.LIT_NAMESPACE.Threshold,
                recapAbility: constants_1.LIT_RECAP_ABILITY.Execution
            };
        default:
            throw new constants_1.InvalidArgumentException({
                info: {
                    litAbility
                }
            }, `Unknown LitAbility`);
    }
} //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/@lit-protocol/auth-helpers/src/lib/siwe/siwe-helper.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.addRecapToSiweMessage = exports.createCapacityCreditsResourceData = void 0;
exports.sanitizeSiweMessage = sanitizeSiweMessage;
/**
 * Sanitizes a SIWE message by unescaping double-escaped newlines and replacing escaped double quotes with single quotes.
 *
 * @param message - The SIWE message to sanitize.
 * @returns The sanitized SIWE message.
 */ function sanitizeSiweMessage(message) {
    let sanitizedMessage = message.replace(/\\\\n/g, '\\n');
    sanitizedMessage = sanitizedMessage.replace(/\\"/g, "'");
    return sanitizedMessage;
}
/**
 * Creates the resource data for a capacity delegation request.
 * @param params - The capacity delegation fields.
 * @returns The capacity delegation request object.
 */ const createCapacityCreditsResourceData = (params)=>{
    return {
        ...params.capacityTokenId ? {
            nft_id: [
                params.capacityTokenId
            ]
        } : {},
        ...params.delegateeAddresses ? {
            delegate_to: params.delegateeAddresses.map((address)=>address.startsWith('0x') ? address.slice(2) : address)
        } : {},
        ...params.uses !== undefined ? {
            uses: params.uses.toString()
        } : {}
    };
};
exports.createCapacityCreditsResourceData = createCapacityCreditsResourceData;
/**
 * Adds recap capabilities to a SiweMessage.
 * @param siweMessage - The SiweMessage to add recap capabilities to.
 * @param resources - An array of LitResourceAbilityRequest objects representing the resources and abilities to add.
 * @param litNodeClient - The LitNodeClient interface
 * @returns The updated SiweMessage with recap capabilities added.
 * @throws An error if the resources array is empty or if litNodeClient is not provided.
 * @throws An error if the generated capabilities fail to verify for any resource and ability.
 */ const addRecapToSiweMessage = async ({ siweMessage, resources, litNodeClient })=>{
    if (!resources || resources.length < 1) {
        throw new Error('resources is required');
    }
    if (!litNodeClient) {
        throw new Error('litNodeClient is required');
    }
    for (const request of resources){
        const recapObject = await litNodeClient.generateSessionCapabilityObjectWithWildcards([
            request.resource
        ]);
        recapObject.addCapabilityForResource(request.resource, request.ability, request.data || null);
        const verified = recapObject.verifyCapabilitiesForResource(request.resource, request.ability);
        if (!verified) {
            throw new Error(`Failed to verify capabilities for resource: "${request.resource}" and ability: "${request.ability}`);
        }
        siweMessage = recapObject.addToSiweMessage(siweMessage);
    }
    return siweMessage;
};
exports.addRecapToSiweMessage = addRecapToSiweMessage; //# sourceMappingURL=siwe-helper.js.map
}),
"[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/@lit-protocol/auth-helpers/src/lib/recap/recap-session-capability-object.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.RecapSessionCapabilityObject = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/tslib/tslib.es6.js [app-client] (ecmascript)");
const constants_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/@lit-protocol/constants/src/index.js [app-client] (ecmascript)");
const depd_1 = tslib_1.__importDefault(__turbopack_context__.r("[project]/node_modules/depd/lib/browser/index.js [app-client] (ecmascript)"));
const siwe_recap_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/siwe-recap/dist/index.cjs [app-client] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/@lit-protocol/auth-helpers/src/lib/recap/utils.js [app-client] (ecmascript)");
const siwe_helper_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/@lit-protocol/auth-helpers/src/lib/siwe/siwe-helper.js [app-client] (ecmascript)");
const deprecated = (0, depd_1.default)('lit-js-sdk:auth-recap:session-capability-object');
class RecapSessionCapabilityObject {
    constructor(att = {}, prf = []){
        this._inner = new siwe_recap_1.Recap(att, prf);
    }
    static decode(encoded) {
        const recap = siwe_recap_1.Recap.decode_urn(encoded);
        return new this(recap.attenuations, recap.proofs.map((cid)=>cid.toString()));
    }
    static extract(siwe) {
        const recap = siwe_recap_1.Recap.extract_and_verify(siwe);
        return new this(recap.attenuations, recap.proofs.map((cid)=>cid.toString()));
    }
    get attenuations() {
        return this._inner.attenuations;
    }
    get proofs() {
        return this._inner.proofs.map((cid)=>cid.toString());
    }
    get statement() {
        return (0, siwe_helper_1.sanitizeSiweMessage)(this._inner.statement);
    }
    addProof(proof) {
        return this._inner.addProof(proof);
    }
    addAttenuation(resource, namespace = '*', name = '*', restriction = {}) {
        return this._inner.addAttenuation(resource, namespace, name, restriction);
    }
    addToSiweMessage(siwe) {
        return this._inner.add_to_siwe_message(siwe);
    }
    encodeAsSiweResource() {
        return this._inner.encode();
    }
    /** LIT specific methods */ addCapabilityForResource(litResource, ability, data = {}) {
        // Validate Lit ability is compatible with the Lit resource.
        if (!litResource.isValidLitAbility(ability)) {
            throw new constants_1.InvalidArgumentException({
                info: {
                    litResource,
                    ability
                }
            }, `The specified Lit resource does not support the specified ability.`);
        }
        const { recapNamespace, recapAbility } = (0, utils_1.getRecapNamespaceAndAbility)(ability);
        if (!data) {
            return this.addAttenuation(litResource.getResourceKey(), recapNamespace, recapAbility);
        }
        return this.addAttenuation(litResource.getResourceKey(), recapNamespace, recapAbility, data);
    }
    verifyCapabilitiesForResource(litResource, ability) {
        // Validate Lit ability is compatible with the Lit resource.
        // The only exception is if there's a wildcard resource key in the session capability object.
        if (!litResource.isValidLitAbility(ability)) {
            return false;
        }
        // Get the attenuations object.
        const attenuations = this.attenuations;
        const { recapNamespace, recapAbility } = (0, utils_1.getRecapNamespaceAndAbility)(ability);
        const recapAbilityToCheckFor = `${recapNamespace}/${recapAbility}`;
        // Find an attenuated resource key to match against.
        const attenuatedResourceKey = this._getResourceKeyToMatchAgainst(litResource);
        if (!attenuations[attenuatedResourceKey]) {
            // No attenuations specified for this resource.
            return false;
        }
        // Check whether the exact Recap namespace/ability pair is present.
        const attenuatedRecapAbilities = Object.keys(attenuations[attenuatedResourceKey]);
        for (const attenuatedRecapAbility of attenuatedRecapAbilities){
            // Return early if the attenuated recap ability is a wildcard.
            if (attenuatedRecapAbility === '*/*') {
                return true;
            }
            if (attenuatedRecapAbility === recapAbilityToCheckFor) {
                return true;
            }
        }
        return false;
    }
    /**
     * Returns the attenuated resource key to match against. This supports matching
     * against a wildcard resource key too.
     *
     * @example If the attenuations object contains the following:
     *
     * ```
     * {
     *   'lit-acc://*': {
     *    '*\/*': {}
     *   }
     * }
     * ```
     *
     * Then, if the provided litResource is 'lit-acc://123', the method will return 'lit-acc://*'.
     */ _getResourceKeyToMatchAgainst(litResource) {
        const attenuatedResourceKeysToMatchAgainst = [
            `${litResource.resourcePrefix}://*`,
            litResource.getResourceKey()
        ];
        for (const attenuatedResourceKeyToMatchAgainst of attenuatedResourceKeysToMatchAgainst){
            if (this.attenuations[attenuatedResourceKeyToMatchAgainst]) {
                return attenuatedResourceKeyToMatchAgainst;
            }
        }
        return '';
    }
    addAllCapabilitiesForResource(litResource) {
        return this.addAttenuation(litResource.getResourceKey(), '*', '*');
    }
}
exports.RecapSessionCapabilityObject = RecapSessionCapabilityObject; //# sourceMappingURL=recap-session-capability-object.js.map
}),
"[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/@lit-protocol/auth-helpers/src/lib/session-capability-object.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.newSessionCapabilityObject = newSessionCapabilityObject;
exports.decode = decode;
exports.extract = extract;
const recap_session_capability_object_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/@lit-protocol/auth-helpers/src/lib/recap/recap-session-capability-object.js [app-client] (ecmascript)");
/**
 *
 * newSessionCapabilityObject is a function that abstracts away the details of
 * creating and verifying a session capability object. For example, it uses
 * the SIWE Recap object to create the capability object, but that detail is
 * hidden from the user.
 *
 * This function serves as an abstraction and router to the
 * underlying implementation of the ISessionCapabilityObject.
 *
 * @param attenuations the attenuations you want to add to the capability object
 * @param proof the proofs you want to add to the capability object
 * @returns a ISessionCapabilityObject
 */ function newSessionCapabilityObject(attenuations = {}, proof = []) {
    return new recap_session_capability_object_1.RecapSessionCapabilityObject(attenuations, proof);
}
function decode(encoded) {
    return recap_session_capability_object_1.RecapSessionCapabilityObject.decode(encoded);
}
function extract(siwe) {
    return recap_session_capability_object_1.RecapSessionCapabilityObject.extract(siwe);
} //# sourceMappingURL=session-capability-object.js.map
}),
"[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/@lit-protocol/auth-helpers/src/lib/utils.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.formatPKPResource = formatPKPResource;
/**
 * Formats the resource ID to a 32-byte hex string.
 *
 * - Takes out '0x' and makes the string 64 characters long.
 * - Adds zeros to make short strings 64 characters.
 * - Doesn't change valid 64-character hex strings.
 * - Returns '*' as is.
 * - Returns the original if it has bad hex characters.
 * - Doesn't change 64-character strings.
 * - Adds zeros to make short hex strings 64 characters.
 * - Returns the original if it partly matches hex.
 * - Throws an error if the string is too long.
 *
 * @param resource The identifier for the resource. This should be the PKP token ID.
 * @returns A 32-byte hex string representing the resource ID.
 * @throws Will throw an error if the input exceeds 64 characters.
 */ function formatPKPResource(resource) {
    // Remove the '0x' prefix if present
    let fixedResource = resource.startsWith('0x') ? resource.slice(2) : resource;
    // Throw an error if the resource length exceeds 64 characters
    if (fixedResource.length > 64) {
        throw new Error('Resource ID exceeds 64 characters (32 bytes) in length.');
    }
    /**
     * The pattern matches any sequence of 6 characters that are
     * either digits (0-9) or letters A-F (both uppercase and lowercase).
     */ const hexRegex = /^[0-9A-Fa-f]+$/;
    // Ensure the resource is a valid hex string and not a wildcard '*'
    if (fixedResource !== '*' && hexRegex.test(fixedResource)) {
        // Pad the resource ID with leading zeros to make it 32 bytes (64 hex characters)
        fixedResource = fixedResource.padStart(64, '0');
    }
    return fixedResource;
} //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/@lit-protocol/auth-helpers/src/lib/resources.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LitActionResource = exports.LitRLIResource = exports.LitPKPResource = exports.LitAccessControlConditionResource = void 0;
exports.parseLitResource = parseLitResource;
const access_control_conditions_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/access-control-conditions/src/index.js [app-client] (ecmascript)");
const constants_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/@lit-protocol/constants/src/index.js [app-client] (ecmascript)");
const uint8arrays_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/uint8arrays/src/index.js [app-client] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/@lit-protocol/auth-helpers/src/lib/utils.js [app-client] (ecmascript)");
class LitResourceBase {
    constructor(resource){
        this.resource = resource;
    }
    getResourceKey() {
        return `${this.resourcePrefix}://${this.resource}`;
    }
    toString() {
        return this.getResourceKey();
    }
}
class LitAccessControlConditionResource extends LitResourceBase {
    /**
     * Creates a new LitAccessControlConditionResource.
     * @param resource The identifier for the resource. This should be the
     * hashed key value of the access control condition.
     */ constructor(resource){
        super(resource);
        this.resourcePrefix = constants_1.LIT_RESOURCE_PREFIX.AccessControlCondition;
    }
    isValidLitAbility(litAbility) {
        return litAbility === constants_1.LIT_ABILITY.AccessControlConditionDecryption || litAbility === constants_1.LIT_ABILITY.AccessControlConditionSigning;
    }
    /**
     * Composes a resource string by hashing access control conditions and appending a data hash.
     *
     * @param {AccessControlConditions} accs - The access control conditions to hash.
     * @param {string} dataToEncryptHash - The hash of the data to encrypt.
     * @returns {Promise<string>} The composed resource string in the format 'hashedAccs/dataToEncryptHash'.
     */ static async generateResourceString(accs, dataToEncryptHash) {
        if (!accs || !dataToEncryptHash) {
            throw new constants_1.InvalidArgumentException({
                info: {
                    accs,
                    dataToEncryptHash
                }
            }, 'Invalid input: Access control conditions and data hash are required.');
        }
        const hashedAccs = await (0, access_control_conditions_1.hashAccessControlConditions)(accs);
        const hashedAccsStr = (0, uint8arrays_1.uint8arrayToString)(new Uint8Array(hashedAccs), 'base16');
        const resourceString = `${hashedAccsStr}/${dataToEncryptHash}`;
        return resourceString;
    }
}
exports.LitAccessControlConditionResource = LitAccessControlConditionResource;
class LitPKPResource extends LitResourceBase {
    /**
     * Creates a new LitPKPResource.
     * @param resource The identifier for the resource. This should be the
     * PKP token ID.
     */ constructor(resource){
        const fixedResource = (0, utils_1.formatPKPResource)(resource);
        super(fixedResource);
        this.resourcePrefix = constants_1.LIT_RESOURCE_PREFIX.PKP;
    }
    isValidLitAbility(litAbility) {
        return litAbility === constants_1.LIT_ABILITY.PKPSigning;
    }
}
exports.LitPKPResource = LitPKPResource;
class LitRLIResource extends LitResourceBase {
    /**
     * Creates a new LitRLIResource.
     * @param resource The identifier for the resource. This should be the
     * RLI token ID.
     */ constructor(resource){
        super(resource);
        this.resourcePrefix = constants_1.LIT_RESOURCE_PREFIX.RLI;
    }
    isValidLitAbility(litAbility) {
        return litAbility === constants_1.LIT_ABILITY.RateLimitIncreaseAuth;
    }
}
exports.LitRLIResource = LitRLIResource;
class LitActionResource extends LitResourceBase {
    /**
     * Creates a new LitActionResource.
     * @param resource The identifier for the resource. This should be the
     * Lit Action IPFS CID.
     */ constructor(resource){
        super(resource);
        this.resourcePrefix = constants_1.LIT_RESOURCE_PREFIX.LitAction;
    }
    isValidLitAbility(litAbility) {
        return litAbility === constants_1.LIT_ABILITY.LitActionExecution;
    }
}
exports.LitActionResource = LitActionResource;
function parseLitResource(resourceKey) {
    if (resourceKey.startsWith(constants_1.LIT_RESOURCE_PREFIX.AccessControlCondition)) {
        return new LitAccessControlConditionResource(resourceKey.substring(`${constants_1.LIT_RESOURCE_PREFIX.AccessControlCondition}://`.length));
    } else if (resourceKey.startsWith(constants_1.LIT_RESOURCE_PREFIX.PKP)) {
        return new LitPKPResource(resourceKey.substring(`${constants_1.LIT_RESOURCE_PREFIX.PKP}://`.length));
    } else if (resourceKey.startsWith(constants_1.LIT_RESOURCE_PREFIX.RLI)) {
        return new LitRLIResource(resourceKey.substring(`${constants_1.LIT_RESOURCE_PREFIX.RLI}://`.length));
    } else if (resourceKey.startsWith(constants_1.LIT_RESOURCE_PREFIX.LitAction)) {
        return new LitActionResource(resourceKey.substring(`${constants_1.LIT_RESOURCE_PREFIX.LitAction}://`.length));
    }
    throw new constants_1.InvalidArgumentException({
        info: {
            resourceKey
        }
    }, `Invalid resource prefix`);
} //# sourceMappingURL=resources.js.map
}),
"[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/@lit-protocol/auth-helpers/src/lib/recap/resource-builder.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ResourceAbilityRequestBuilder = void 0;
const constants_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/@lit-protocol/constants/src/index.js [app-client] (ecmascript)");
const resources_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/@lit-protocol/auth-helpers/src/lib/resources.js [app-client] (ecmascript)");
/**
 * Lit resrouce ability request builder for creating resource ability requests.
 *
 * @example
 * import { ResourceAbilityRequestBuilder } from '@lit-protocol/auth-helpers';

const builder = new ResourceAbilityRequestBuilder();

builder
  .addPKPSigningRequest('*') // PKP Signing
  .addLitActionExecutionRequest('*') // Lit Action Execution
  .addAccessControlConditionSigningRequest('*') // ACC Signing
  .addAccessControlConditionDecryptionRequest('*') // ACC Decryption
  .addRateLimitIncreaseAuthRequest('*'); // RLI Authentication

const requests = builder.build();

 */ class ResourceAbilityRequestBuilder {
    constructor(){
        this.requests = [];
    }
    /**
     * Adds a PKP signing request to the builder.
     * @param resourceId - The ID of the resource.
     * @returns The builder instance.
     */ addPKPSigningRequest(resourceId) {
        this.requests.push({
            resource: new resources_1.LitPKPResource(resourceId),
            ability: constants_1.LIT_ABILITY.PKPSigning
        });
        return this;
    }
    /**
     * Adds a Lit action execution request to the builder.
     * @param resourceId - The ID of the resource.
     * @returns The builder instance.
     */ addLitActionExecutionRequest(resourceId) {
        this.requests.push({
            resource: new resources_1.LitActionResource(resourceId),
            ability: constants_1.LIT_ABILITY.LitActionExecution
        });
        return this;
    }
    /**
     * Adds an access control condition signing request to the builder.
     * @param resourceId - The ID of the resource.
     * @returns The builder instance.
     */ addAccessControlConditionSigningRequest(resourceId) {
        this.requests.push({
            resource: new resources_1.LitAccessControlConditionResource(resourceId),
            ability: constants_1.LIT_ABILITY.AccessControlConditionSigning
        });
        return this;
    }
    /**
     * Adds an access control condition decryption request to the builder.
     * @param resourceId - The ID of the resource.
     * @returns The builder instance.
     */ addAccessControlConditionDecryptionRequest(resourceId) {
        this.requests.push({
            resource: new resources_1.LitAccessControlConditionResource(resourceId),
            ability: constants_1.LIT_ABILITY.AccessControlConditionDecryption
        });
        return this;
    }
    /**
     * Adds a rate limit increase authentication request to the builder.
     * @param resourceId - The ID of the resource.
     * @returns The builder instance.
     */ addRateLimitIncreaseAuthRequest(resourceId) {
        this.requests.push({
            resource: new resources_1.LitRLIResource(resourceId),
            ability: constants_1.LIT_ABILITY.RateLimitIncreaseAuth
        });
        return this;
    }
    /**
     * Builds the array of resource ability requests.
     * @returns The array of resource ability requests.
     */ build() {
        return this.requests;
    }
}
exports.ResourceAbilityRequestBuilder = ResourceAbilityRequestBuilder; //# sourceMappingURL=resource-builder.js.map
}),
"[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/@lit-protocol/auth-helpers/src/lib/siwe/create-siwe-message.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createSiweMessageWithCapacityDelegation = exports.createSiweMessageWithRecaps = exports.createSiweMessage = void 0;
const siwe_1 = __turbopack_context__.r("[project]/node_modules/siwe/dist/siwe.js [app-client] (ecmascript)");
const constants_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/@lit-protocol/constants/src/index.js [app-client] (ecmascript)");
const resources_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/@lit-protocol/auth-helpers/src/lib/resources.js [app-client] (ecmascript)");
const siwe_helper_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/@lit-protocol/auth-helpers/src/lib/siwe/siwe-helper.js [app-client] (ecmascript)");
/**
 * Creates a SIWE
 * @param { BaseSiweMessage } params - The parameters for creating the SIWE message.
 * @returns A promise that resolves to the created SIWE message as a string.
 * @throws An error if the walletAddress parameter is missing.
 */ const createSiweMessage = async (params)=>{
    // -- validations
    if (!params.walletAddress) {
        throw new Error('walletAddress is required');
    }
    const ONE_WEEK_FROM_NOW = new Date(Date.now() + 1000 * 60 * 60 * 24 * 7).toISOString();
    const siweParams = {
        domain: params?.domain ?? 'localhost',
        address: params.walletAddress,
        statement: params?.statement ?? 'This is a test statement.  You can put anything you want here.',
        uri: params?.uri ?? 'https://localhost/login',
        version: params?.version ?? '1',
        chainId: params?.chainId ?? 1,
        nonce: params.nonce,
        expirationTime: params?.expiration ?? ONE_WEEK_FROM_NOW
    };
    let siweMessage = new siwe_1.SiweMessage(siweParams);
    // -- create a message with capacity credits
    if ('dAppOwnerWallet' in params || // required param
    'uses' in params || // optional
    'delegateeAddresses' in params || // optional
    'capacityTokenId' in params // optional
    ) {
        const ccParams = params;
        const capabilities = (0, siwe_helper_1.createCapacityCreditsResourceData)(ccParams);
        params.resources = [
            {
                resource: new resources_1.LitRLIResource(ccParams.capacityTokenId ?? '*'),
                ability: constants_1.LIT_ABILITY.RateLimitIncreaseAuth,
                data: capabilities
            }
        ];
    }
    // -- add recap resources if needed
    if (params.resources) {
        siweMessage = await (0, siwe_helper_1.addRecapToSiweMessage)({
            siweMessage,
            resources: params.resources,
            litNodeClient: params.litNodeClient
        });
    }
    return siweMessage.prepareMessage();
};
exports.createSiweMessage = createSiweMessage;
/**
 * Creates a SIWE message with recaps added to it.
 *
 * @param { WithRecap } params - The parameters for creating the SIWE message with recaps.
 * @returns A Promise that resolves to a string representing the SIWE message.
 */ const createSiweMessageWithRecaps = async (params)=>{
    return (0, exports.createSiweMessage)({
        ...params
    });
};
exports.createSiweMessageWithRecaps = createSiweMessageWithRecaps;
/**
 * Creates a SIWE message with capacity delegation.
 * @param { WithCapacityDelegation } params - The parameters for creating the SIWE message.
 * @returns A Promise that resolves to the created SIWE message.
 * @throws An error if litNodeClient is not provided.
 */ const createSiweMessageWithCapacityDelegation = async (params)=>{
    if (!params.litNodeClient) {
        throw new Error('litNodeClient is required');
    }
    return (0, exports.createSiweMessage)({
        ...params
    });
};
exports.createSiweMessageWithCapacityDelegation = createSiweMessageWithCapacityDelegation; //# sourceMappingURL=create-siwe-message.js.map
}),
"[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/@lit-protocol/auth-helpers/src/lib/generate-auth-sig.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.generateAuthSig = void 0;
const ethers_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-client] (ecmascript)");
/**
 * Generate an AuthSig object using the signer.
 *
 * For more context:
 * We are only using authSig to generate session sigs. In a newer version, we will stop accepting
 * authSig all together from the node and will only accept session sigs. The address being
 * used here will be checksummed.
 *
 * @param signer the signer must have a "signMessage" method
 * @param toSign - the message to sign
 * @param address - (optional) the address of the signer
 * @returns
 */ const generateAuthSig = async ({ signer, toSign, address, algo })=>{
    if (!signer?.signMessage) {
        throw new Error('signer does not have a signMessage method');
    }
    const signature = await signer.signMessage(toSign);
    // If address is not provided, derive it from the signer
    if (!address) {
        address = await signer.getAddress();
    }
    // checksum the address
    address = ethers_1.ethers.utils.getAddress(address);
    // If address is still not available, throw an error
    if (!address) {
        throw new Error('address is required');
    }
    return {
        sig: signature,
        derivedVia: 'web3.eth.personal.sign',
        signedMessage: toSign,
        address: address,
        ...algo && {
            algo
        }
    };
};
exports.generateAuthSig = generateAuthSig; //# sourceMappingURL=generate-auth-sig.js.map
}),
"[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/@lit-protocol/auth-helpers/src/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
const tslib_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/tslib/tslib.es6.js [app-client] (ecmascript)");
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/@lit-protocol/auth-helpers/src/lib/models.js [app-client] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/@lit-protocol/auth-helpers/src/lib/session-capability-object.js [app-client] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/@lit-protocol/auth-helpers/src/lib/resources.js [app-client] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/@lit-protocol/auth-helpers/src/lib/siwe/siwe-helper.js [app-client] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/@lit-protocol/auth-helpers/src/lib/recap/recap-session-capability-object.js [app-client] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/@lit-protocol/auth-helpers/src/lib/recap/resource-builder.js [app-client] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/@lit-protocol/auth-helpers/src/lib/siwe/create-siwe-message.js [app-client] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/@lit-protocol/auth-helpers/src/lib/generate-auth-sig.js [app-client] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/siwe-recap/dist/index.cjs [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod)=>function __require() {
        return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = {
            exports: {}
        }).exports, mod), mod.exports;
    };
var __export = (target, all)=>{
    for(var name in all)__defProp(target, name, {
        get: all[name],
        enumerable: true
    });
};
var __copyProps = (to, from2, except, desc)=>{
    if (from2 && typeof from2 === "object" || typeof from2 === "function") {
        for (let key of __getOwnPropNames(from2))if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
            get: ()=>from2[key],
            enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable
        });
    }
    return to;
};
var __toESM = (mod, isNodeMode, target)=>(target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(// If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
        value: mod,
        enumerable: true
    }) : target, mod));
var __toCommonJS = (mod)=>__copyProps(__defProp({}, "__esModule", {
        value: true
    }), mod);
var __accessCheck = (obj, member, msg)=>{
    if (!member.has(obj)) throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter)=>{
    __accessCheck(obj, member, "read from private field");
    return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value)=>{
    if (member.has(obj)) throw TypeError("Cannot add the same private member more than once");
    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter)=>{
    __accessCheck(obj, member, "write to private field");
    setter ? setter.call(obj, value) : member.set(obj, value);
    return value;
};
// node_modules/canonicalize/lib/canonicalize.js
var require_canonicalize = __commonJS({
    "node_modules/canonicalize/lib/canonicalize.js" (exports, module2) {
        "use strict";
        module2.exports = function serialize2(object) {
            if (typeof object === "number" && isNaN(object)) {
                throw new Error("NaN is not allowed");
            }
            if (typeof object === "number" && !isFinite(object)) {
                throw new Error("Infinity is not allowed");
            }
            if (object === null || typeof object !== "object") {
                return JSON.stringify(object);
            }
            if (object.toJSON instanceof Function) {
                return serialize2(object.toJSON());
            }
            if (Array.isArray(object)) {
                const values2 = object.reduce((t, cv, ci)=>{
                    const comma = ci === 0 ? "" : ",";
                    const value = cv === void 0 || typeof cv === "symbol" ? null : cv;
                    return `${t}${comma}${serialize2(value)}`;
                }, "");
                return `[${values2}]`;
            }
            const values = Object.keys(object).sort().reduce((t, cv)=>{
                if (object[cv] === void 0 || typeof object[cv] === "symbol") {
                    return t;
                }
                const comma = t.length === 0 ? "" : ",";
                return `${t}${comma}${serialize2(cv)}:${serialize2(object[cv])}`;
            }, "");
            return `{${values}}`;
        };
    }
});
// src/index.ts
var src_exports = {};
__export(src_exports, {
    CID: ()=>CID,
    Recap: ()=>Recap,
    checkAtt: ()=>checkAtt,
    decodeRecap: ()=>decodeRecap,
    encodeRecap: ()=>encodeRecap,
    isSorted: ()=>isSorted,
    validAbString: ()=>validAbString,
    validString: ()=>validString
});
module.exports = __toCommonJS(src_exports);
// node_modules/multiformats/vendor/varint.js
var encode_1 = encode;
var MSB = 128;
var REST = 127;
var MSBALL = ~REST;
var INT = Math.pow(2, 31);
function encode(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while(num >= INT){
        out[offset++] = num & 255 | MSB;
        num /= 128;
    }
    while(num & MSBALL){
        out[offset++] = num & 255 | MSB;
        num >>>= 7;
    }
    out[offset] = num | 0;
    encode.bytes = offset - oldOffset + 1;
    return out;
}
var decode = read;
var MSB$1 = 128;
var REST$1 = 127;
function read(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
        if (counter >= l) {
            read.bytes = 0;
            throw new RangeError("Could not decode varint");
        }
        b = buf[counter++];
        res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
        shift += 7;
    }while (b >= MSB$1)
    read.bytes = counter - offset;
    return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function(value) {
    return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
var varint = {
    encode: encode_1,
    decode,
    encodingLength: length
};
var _brrp_varint = varint;
var varint_default = _brrp_varint;
// node_modules/multiformats/src/varint.js
var decode2 = (data, offset = 0)=>{
    const code = varint_default.decode(data, offset);
    return [
        code,
        varint_default.decode.bytes
    ];
};
var encodeTo = (int, target, offset = 0)=>{
    varint_default.encode(int, target, offset);
    return target;
};
var encodingLength = (int)=>{
    return varint_default.encodingLength(int);
};
// node_modules/multiformats/src/bytes.js
var empty = new Uint8Array(0);
var equals = (aa, bb)=>{
    if (aa === bb) return true;
    if (aa.byteLength !== bb.byteLength) {
        return false;
    }
    for(let ii = 0; ii < aa.byteLength; ii++){
        if (aa[ii] !== bb[ii]) {
            return false;
        }
    }
    return true;
};
var coerce = (o)=>{
    if (o instanceof Uint8Array && o.constructor.name === "Uint8Array") return o;
    if (o instanceof ArrayBuffer) return new Uint8Array(o);
    if (ArrayBuffer.isView(o)) {
        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error("Unknown type, must be binary type");
};
// node_modules/multiformats/src/hashes/digest.js
var create = (code, digest)=>{
    const size = digest.byteLength;
    const sizeOffset = encodingLength(code);
    const digestOffset = sizeOffset + encodingLength(size);
    const bytes = new Uint8Array(digestOffset + size);
    encodeTo(code, bytes, 0);
    encodeTo(size, bytes, sizeOffset);
    bytes.set(digest, digestOffset);
    return new Digest(code, size, digest, bytes);
};
var decode3 = (multihash)=>{
    const bytes = coerce(multihash);
    const [code, sizeOffset] = decode2(bytes);
    const [size, digestOffset] = decode2(bytes.subarray(sizeOffset));
    const digest = bytes.subarray(sizeOffset + digestOffset);
    if (digest.byteLength !== size) {
        throw new Error("Incorrect length");
    }
    return new Digest(code, size, digest, bytes);
};
var equals2 = (a, b)=>{
    if (a === b) {
        return true;
    } else {
        const data = /** @type {{code?:unknown, size?:unknown, bytes?:unknown}} */ b;
        return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && equals(a.bytes, data.bytes);
    }
};
var Digest = class {
    /**
   * Creates a multihash digest.
   *
   * @param {Code} code
   * @param {Size} size
   * @param {Uint8Array} digest
   * @param {Uint8Array} bytes
   */ constructor(code, size, digest, bytes){
        this.code = code;
        this.size = size;
        this.digest = digest;
        this.bytes = bytes;
    }
};
// node_modules/multiformats/vendor/base-x.js
function base(ALPHABET, name) {
    if (ALPHABET.length >= 255) {
        throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for(var j = 0; j < BASE_MAP.length; j++){
        BASE_MAP[j] = 255;
    }
    for(var i = 0; i < ALPHABET.length; i++){
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
            throw new TypeError(x + " is ambiguous");
        }
        BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode3(source) {
        if (source instanceof Uint8Array) ;
        else if (ArrayBuffer.isView(source)) {
            source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
            source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
            throw new TypeError("Expected Uint8Array");
        }
        if (source.length === 0) {
            return "";
        }
        var zeroes = 0;
        var length2 = 0;
        var pbegin = 0;
        var pend = source.length;
        while(pbegin !== pend && source[pbegin] === 0){
            pbegin++;
            zeroes++;
        }
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        while(pbegin !== pend){
            var carry = source[pbegin];
            var i2 = 0;
            for(var it1 = size - 1; (carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++){
                carry += 256 * b58[it1] >>> 0;
                b58[it1] = carry % BASE >>> 0;
                carry = carry / BASE >>> 0;
            }
            if (carry !== 0) {
                throw new Error("Non-zero carry");
            }
            length2 = i2;
            pbegin++;
        }
        var it2 = size - length2;
        while(it2 !== size && b58[it2] === 0){
            it2++;
        }
        var str = LEADER.repeat(zeroes);
        for(; it2 < size; ++it2){
            str += ALPHABET.charAt(b58[it2]);
        }
        return str;
    }
    function decodeUnsafe(source) {
        if (typeof source !== "string") {
            throw new TypeError("Expected String");
        }
        if (source.length === 0) {
            return new Uint8Array();
        }
        var psz = 0;
        if (source[psz] === " ") {
            return;
        }
        var zeroes = 0;
        var length2 = 0;
        while(source[psz] === LEADER){
            zeroes++;
            psz++;
        }
        var size = (source.length - psz) * FACTOR + 1 >>> 0;
        var b256 = new Uint8Array(size);
        while(source[psz]){
            var carry = BASE_MAP[source.charCodeAt(psz)];
            if (carry === 255) {
                return;
            }
            var i2 = 0;
            for(var it3 = size - 1; (carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++){
                carry += BASE * b256[it3] >>> 0;
                b256[it3] = carry % 256 >>> 0;
                carry = carry / 256 >>> 0;
            }
            if (carry !== 0) {
                throw new Error("Non-zero carry");
            }
            length2 = i2;
            psz++;
        }
        if (source[psz] === " ") {
            return;
        }
        var it4 = size - length2;
        while(it4 !== size && b256[it4] === 0){
            it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j2 = zeroes;
        while(it4 !== size){
            vch[j2++] = b256[it4++];
        }
        return vch;
    }
    function decode5(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) {
            return buffer;
        }
        throw new Error(`Non-${name} character`);
    }
    return {
        encode: encode3,
        decodeUnsafe,
        decode: decode5
    };
}
var src = base;
var _brrp__multiformats_scope_baseX = src;
var base_x_default = _brrp__multiformats_scope_baseX;
// node_modules/multiformats/src/bases/base.js
var Encoder = class {
    /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   */ constructor(name, prefix, baseEncode){
        this.name = name;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
    }
    /**
   * @param {Uint8Array} bytes
   * @returns {API.Multibase<Prefix>}
   */ encode(bytes) {
        if (bytes instanceof Uint8Array) {
            return `${this.prefix}${this.baseEncode(bytes)}`;
        } else {
            throw Error("Unknown type, must be binary type");
        }
    }
};
var Decoder = class {
    /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(text:string) => Uint8Array} baseDecode
   */ constructor(name, prefix, baseDecode){
        this.name = name;
        this.prefix = prefix;
        if (prefix.codePointAt(0) === void 0) {
            throw new Error("Invalid prefix character");
        }
        this.prefixCodePoint = /** @type {number} */ prefix.codePointAt(0);
        this.baseDecode = baseDecode;
    }
    /**
   * @param {string} text
   */ decode(text) {
        if (typeof text === "string") {
            if (text.codePointAt(0) !== this.prefixCodePoint) {
                throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            }
            return this.baseDecode(text.slice(this.prefix.length));
        } else {
            throw Error("Can only multibase decode strings");
        }
    }
    /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */ or(decoder) {
        return or(this, decoder);
    }
};
var ComposedDecoder = class {
    /**
   * @param {Decoders<Prefix>} decoders
   */ constructor(decoders){
        this.decoders = decoders;
    }
    /**
   * @template {string} OtherPrefix
   * @param {API.UnibaseDecoder<OtherPrefix>|ComposedDecoder<OtherPrefix>} decoder
   * @returns {ComposedDecoder<Prefix|OtherPrefix>}
   */ or(decoder) {
        return or(this, decoder);
    }
    /**
   * @param {string} input
   * @returns {Uint8Array}
   */ decode(input) {
        const prefix = /** @type {Prefix} */ input[0];
        const decoder = this.decoders[prefix];
        if (decoder) {
            return decoder.decode(input);
        } else {
            throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
    }
};
var or = (left, right)=>new ComposedDecoder(/** @type {Decoders<L|R>} */ {
        ...left.decoders || {
            [/** @type API.UnibaseDecoder<L> */ left.prefix]: left
        },
        ...right.decoders || {
            [/** @type API.UnibaseDecoder<R> */ right.prefix]: right
        }
    });
var Codec = class {
    /**
   * @param {Base} name
   * @param {Prefix} prefix
   * @param {(bytes:Uint8Array) => string} baseEncode
   * @param {(text:string) => Uint8Array} baseDecode
   */ constructor(name, prefix, baseEncode, baseDecode){
        this.name = name;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder(name, prefix, baseEncode);
        this.decoder = new Decoder(name, prefix, baseDecode);
    }
    /**
   * @param {Uint8Array} input
   */ encode(input) {
        return this.encoder.encode(input);
    }
    /**
   * @param {string} input
   */ decode(input) {
        return this.decoder.decode(input);
    }
};
var from = ({ name, prefix, encode: encode3, decode: decode5 })=>new Codec(name, prefix, encode3, decode5);
var baseX = ({ prefix, name, alphabet })=>{
    const { encode: encode3, decode: decode5 } = base_x_default(alphabet, name);
    return from({
        prefix,
        name,
        encode: encode3,
        /**
     * @param {string} text
     */ decode: (text)=>coerce(decode5(text))
    });
};
var decode4 = (string, alphabet, bitsPerChar, name)=>{
    const codes = {};
    for(let i = 0; i < alphabet.length; ++i){
        codes[alphabet[i]] = i;
    }
    let end = string.length;
    while(string[end - 1] === "="){
        --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer = 0;
    let written = 0;
    for(let i = 0; i < end; ++i){
        const value = codes[string[i]];
        if (value === void 0) {
            throw new SyntaxError(`Non-${name} character`);
        }
        buffer = buffer << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
            bits -= 8;
            out[written++] = 255 & buffer >> bits;
        }
    }
    if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
        throw new SyntaxError("Unexpected end of data");
    }
    return out;
};
var encode2 = (data, alphabet, bitsPerChar)=>{
    const pad = alphabet[alphabet.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0;
    let buffer = 0;
    for(let i = 0; i < data.length; ++i){
        buffer = buffer << 8 | data[i];
        bits += 8;
        while(bits > bitsPerChar){
            bits -= bitsPerChar;
            out += alphabet[mask & buffer >> bits];
        }
    }
    if (bits) {
        out += alphabet[mask & buffer << bitsPerChar - bits];
    }
    if (pad) {
        while(out.length * bitsPerChar & 7){
            out += "=";
        }
    }
    return out;
};
var rfc4648 = ({ name, prefix, bitsPerChar, alphabet })=>{
    return from({
        prefix,
        name,
        encode (input) {
            return encode2(input, alphabet, bitsPerChar);
        },
        decode (input) {
            return decode4(input, alphabet, bitsPerChar, name);
        }
    });
};
// node_modules/multiformats/src/bases/base58.js
var base58btc = baseX({
    name: "base58btc",
    prefix: "z",
    alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
var base58flickr = baseX({
    name: "base58flickr",
    prefix: "Z",
    alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});
// node_modules/multiformats/src/bases/base32.js
var base32 = rfc4648({
    prefix: "b",
    name: "base32",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567",
    bitsPerChar: 5
});
var base32upper = rfc4648({
    prefix: "B",
    name: "base32upper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    bitsPerChar: 5
});
var base32pad = rfc4648({
    prefix: "c",
    name: "base32pad",
    alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
    bitsPerChar: 5
});
var base32padupper = rfc4648({
    prefix: "C",
    name: "base32padupper",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
    bitsPerChar: 5
});
var base32hex = rfc4648({
    prefix: "v",
    name: "base32hex",
    alphabet: "0123456789abcdefghijklmnopqrstuv",
    bitsPerChar: 5
});
var base32hexupper = rfc4648({
    prefix: "V",
    name: "base32hexupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    bitsPerChar: 5
});
var base32hexpad = rfc4648({
    prefix: "t",
    name: "base32hexpad",
    alphabet: "0123456789abcdefghijklmnopqrstuv=",
    bitsPerChar: 5
});
var base32hexpadupper = rfc4648({
    prefix: "T",
    name: "base32hexpadupper",
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
    bitsPerChar: 5
});
var base32z = rfc4648({
    prefix: "h",
    name: "base32z",
    alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
    bitsPerChar: 5
});
// node_modules/multiformats/src/cid.js
var format = (link, base2)=>{
    const { bytes, version } = link;
    switch(version){
        case 0:
            return toStringV0(bytes, baseCache(link), /** @type {API.MultibaseEncoder<"z">} */ base2 || base58btc.encoder);
        default:
            return toStringV1(bytes, baseCache(link), /** @type {API.MultibaseEncoder<Prefix>} */ base2 || base32.encoder);
    }
};
var cache = /* @__PURE__ */ new WeakMap();
var baseCache = (cid)=>{
    const baseCache2 = cache.get(cid);
    if (baseCache2 == null) {
        const baseCache3 = /* @__PURE__ */ new Map();
        cache.set(cid, baseCache3);
        return baseCache3;
    }
    return baseCache2;
};
var CID = class {
    /**
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} multihash - (Multi)hash of the of the content.
   * @param {Uint8Array} bytes
   *
   */ constructor(version, code, multihash, bytes){
        this.code = code;
        this.version = version;
        this.multihash = multihash;
        this.bytes = bytes;
        this["/"] = bytes;
    }
    /**
   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
   * please either use `CID.asCID(cid)` or switch to new signalling mechanism
   *
   * @deprecated
   */ get asCID() {
        return this;
    }
    // ArrayBufferView
    get byteOffset() {
        return this.bytes.byteOffset;
    }
    // ArrayBufferView
    get byteLength() {
        return this.bytes.byteLength;
    }
    /**
   * @returns {CID<Data, API.DAG_PB, API.SHA_256, 0>}
   */ toV0() {
        switch(this.version){
            case 0:
                {
                    return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ this;
                }
            case 1:
                {
                    const { code, multihash } = this;
                    if (code !== DAG_PB_CODE) {
                        throw new Error("Cannot convert a non dag-pb CID to CIDv0");
                    }
                    if (multihash.code !== SHA_256_CODE) {
                        throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
                    }
                    return /** @type {CID<Data, API.DAG_PB, API.SHA_256, 0>} */ CID.createV0(/** @type {API.MultihashDigest<API.SHA_256>} */ multihash);
                }
            default:
                {
                    throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
                }
        }
    }
    /**
   * @returns {CID<Data, Format, Alg, 1>}
   */ toV1() {
        switch(this.version){
            case 0:
                {
                    const { code, digest } = this.multihash;
                    const multihash = create(code, digest);
                    return /** @type {CID<Data, Format, Alg, 1>} */ CID.createV1(this.code, multihash);
                }
            case 1:
                {
                    return /** @type {CID<Data, Format, Alg, 1>} */ this;
                }
            default:
                {
                    throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
                }
        }
    }
    /**
   * @param {unknown} other
   * @returns {other is CID<Data, Format, Alg, Version>}
   */ equals(other) {
        return CID.equals(this, other);
    }
    /**
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {API.Link<Data, Format, Alg, Version>} self
   * @param {unknown} other
   * @returns {other is CID}
   */ static equals(self, other) {
        const unknown = /** @type {{code?:unknown, version?:unknown, multihash?:unknown}} */ other;
        return unknown && self.code === unknown.code && self.version === unknown.version && equals2(self.multihash, unknown.multihash);
    }
    /**
   * @param {API.MultibaseEncoder<string>} [base]
   * @returns {string}
   */ toString(base2) {
        return format(this, base2);
    }
    toJSON() {
        return {
            "/": format(this)
        };
    }
    link() {
        return this;
    }
    get [Symbol.toStringTag]() {
        return "CID";
    }
    // Legacy
    [Symbol.for("nodejs.util.inspect.custom")]() {
        return `CID(${this.toString()})`;
    }
    /**
   * Takes any input `value` and returns a `CID` instance if it was
   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
   * it will return value back. If `value` is not instance of this CID
   * class, but is compatible CID it will return new instance of this
   * `CID` class. Otherwise returns null.
   *
   * This allows two different incompatible versions of CID library to
   * co-exist and interop as long as binary interface is compatible.
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @template {unknown} U
   * @param {API.Link<Data, Format, Alg, Version>|U} input
   * @returns {CID<Data, Format, Alg, Version>|null}
   */ static asCID(input) {
        if (input == null) {
            return null;
        }
        const value = /** @type {any} */ input;
        if (value instanceof CID) {
            return value;
        } else if (value["/"] != null && value["/"] === value.bytes || value.asCID === value) {
            const { version, code, multihash, bytes } = value;
            return new CID(version, code, /** @type {API.MultihashDigest<Alg>} */ multihash, bytes || encodeCID(version, code, multihash.bytes));
        } else if (value[cidSymbol] === true) {
            const { version, multihash, code } = value;
            const digest = /** @type {API.MultihashDigest<Alg>} */ decode3(multihash);
            return CID.create(version, code, digest);
        } else {
            return null;
        }
    }
    /**
   *
   * @template {unknown} Data
   * @template {number} Format
   * @template {number} Alg
   * @template {API.Version} Version
   * @param {Version} version - Version of the CID
   * @param {Format} code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
   * @param {API.MultihashDigest<Alg>} digest - (Multi)hash of the of the content.
   * @returns {CID<Data, Format, Alg, Version>}
   */ static create(version, code, digest) {
        if (typeof code !== "number") {
            throw new Error("String codecs are no longer supported");
        }
        if (!(digest.bytes instanceof Uint8Array)) {
            throw new Error("Invalid digest");
        }
        switch(version){
            case 0:
                {
                    if (code !== DAG_PB_CODE) {
                        throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
                    } else {
                        return new CID(version, code, digest, digest.bytes);
                    }
                }
            case 1:
                {
                    const bytes = encodeCID(version, code, digest.bytes);
                    return new CID(version, code, digest, bytes);
                }
            default:
                {
                    throw new Error("Invalid version");
                }
        }
    }
    /**
   * Simplified version of `create` for CIDv0.
   *
   * @template {unknown} [T=unknown]
   * @param {API.MultihashDigest<typeof SHA_256_CODE>} digest - Multihash.
   * @returns {CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0>}
   */ static createV0(digest) {
        return CID.create(0, DAG_PB_CODE, digest);
    }
    /**
   * Simplified version of `create` for CIDv1.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @param {Code} code - Content encoding format code.
   * @param {API.MultihashDigest<Alg>} digest - Miltihash of the content.
   * @returns {CID<Data, Code, Alg, 1>}
   */ static createV1(code, digest) {
        return CID.create(1, code, digest);
    }
    /**
   * Decoded a CID from its binary representation. The byte array must contain
   * only the CID with no additional bytes.
   *
   * An error will be thrown if the bytes provided do not contain a valid
   * binary representation of a CID.
   *
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ByteView<API.Link<Data, Code, Alg, Ver>>} bytes
   * @returns {CID<Data, Code, Alg, Ver>}
   */ static decode(bytes) {
        const [cid, remainder] = CID.decodeFirst(bytes);
        if (remainder.length) {
            throw new Error("Incorrect length");
        }
        return cid;
    }
    /**
   * Decoded a CID from its binary representation at the beginning of a byte
   * array.
   *
   * Returns an array with the first element containing the CID and the second
   * element containing the remainder of the original byte array. The remainder
   * will be a zero-length byte array if the provided bytes only contained a
   * binary CID representation.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} bytes
   * @returns {[CID<T, C, A, V>, Uint8Array]}
   */ static decodeFirst(bytes) {
        const specs = CID.inspectBytes(bytes);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
        if (multihashBytes.byteLength !== specs.multihashSize) {
            throw new Error("Incorrect length");
        }
        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
        const digest = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
        const cid = specs.version === 0 ? CID.createV0(/** @type {API.MultihashDigest<API.SHA_256>} */ digest) : CID.createV1(specs.codec, digest);
        return [
            /** @type {CID<T, C, A, V>} */ cid,
            bytes.subarray(specs.size)
        ];
    }
    /**
   * Inspect the initial bytes of a CID to determine its properties.
   *
   * Involves decoding up to 4 varints. Typically this will require only 4 to 6
   * bytes but for larger multicodec code values and larger multihash digest
   * lengths these varints can be quite large. It is recommended that at least
   * 10 bytes be made available in the `initialBytes` argument for a complete
   * inspection.
   *
   * @template {unknown} T
   * @template {number} C
   * @template {number} A
   * @template {API.Version} V
   * @param {API.ByteView<API.Link<T, C, A, V>>} initialBytes
   * @returns {{ version:V, codec:C, multihashCode:A, digestSize:number, multihashSize:number, size:number }}
   */ static inspectBytes(initialBytes) {
        let offset = 0;
        const next = ()=>{
            const [i, length2] = decode2(initialBytes.subarray(offset));
            offset += length2;
            return i;
        };
        let version = /** @type {V} */ next();
        let codec = /** @type {C} */ DAG_PB_CODE;
        if (/** @type {number} */ version === 18) {
            version = /** @type {V} */ 0;
            offset = 0;
        } else {
            codec = /** @type {C} */ next();
        }
        if (version !== 0 && version !== 1) {
            throw new RangeError(`Invalid CID version ${version}`);
        }
        const prefixSize = offset;
        const multihashCode = /** @type {A} */ next();
        const digestSize = next();
        const size = offset + digestSize;
        const multihashSize = size - prefixSize;
        return {
            version,
            codec,
            multihashCode,
            digestSize,
            multihashSize,
            size
        };
    }
    /**
   * Takes cid in a string representation and creates an instance. If `base`
   * decoder is not provided will use a default from the configuration. It will
   * throw an error if encoding of the CID is not compatible with supplied (or
   * a default decoder).
   *
   * @template {string} Prefix
   * @template {unknown} Data
   * @template {number} Code
   * @template {number} Alg
   * @template {API.Version} Ver
   * @param {API.ToString<API.Link<Data, Code, Alg, Ver>, Prefix>} source
   * @param {API.MultibaseDecoder<Prefix>} [base]
   * @returns {CID<Data, Code, Alg, Ver>}
   */ static parse(source, base2) {
        const [prefix, bytes] = parseCIDtoBytes(source, base2);
        const cid = CID.decode(bytes);
        if (cid.version === 0 && source[0] !== "Q") {
            throw Error("Version 0 CID string must not include multibase prefix");
        }
        baseCache(cid).set(prefix, source);
        return cid;
    }
};
var parseCIDtoBytes = (source, base2)=>{
    switch(source[0]){
        case "Q":
            {
                const decoder = base2 || base58btc;
                return [
                    /** @type {Prefix} */ base58btc.prefix,
                    decoder.decode(`${base58btc.prefix}${source}`)
                ];
            }
        case base58btc.prefix:
            {
                const decoder = base2 || base58btc;
                return [
                    /** @type {Prefix} */ base58btc.prefix,
                    decoder.decode(source)
                ];
            }
        case base32.prefix:
            {
                const decoder = base2 || base32;
                return [
                    /** @type {Prefix} */ base32.prefix,
                    decoder.decode(source)
                ];
            }
        default:
            {
                if (base2 == null) {
                    throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
                }
                return [
                    /** @type {Prefix} */ source[0],
                    base2.decode(source)
                ];
            }
    }
};
var toStringV0 = (bytes, cache2, base2)=>{
    const { prefix } = base2;
    if (prefix !== base58btc.prefix) {
        throw Error(`Cannot string encode V0 in ${base2.name} encoding`);
    }
    const cid = cache2.get(prefix);
    if (cid == null) {
        const cid2 = base2.encode(bytes).slice(1);
        cache2.set(prefix, cid2);
        return cid2;
    } else {
        return cid;
    }
};
var toStringV1 = (bytes, cache2, base2)=>{
    const { prefix } = base2;
    const cid = cache2.get(prefix);
    if (cid == null) {
        const cid2 = base2.encode(bytes);
        cache2.set(prefix, cid2);
        return cid2;
    } else {
        return cid;
    }
};
var DAG_PB_CODE = 112;
var SHA_256_CODE = 18;
var encodeCID = (version, code, multihash)=>{
    const codeOffset = encodingLength(version);
    const hashOffset = codeOffset + encodingLength(code);
    const bytes = new Uint8Array(hashOffset + multihash.byteLength);
    encodeTo(version, bytes, 0);
    encodeTo(code, bytes, codeOffset);
    bytes.set(multihash, hashOffset);
    return bytes;
};
var cidSymbol = Symbol.for("@ipld/js-cid/CID");
// node_modules/multiformats/src/bases/base64.js
var base64 = rfc4648({
    prefix: "m",
    name: "base64",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    bitsPerChar: 6
});
var base64pad = rfc4648({
    prefix: "M",
    name: "base64pad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    bitsPerChar: 6
});
var base64url = rfc4648({
    prefix: "u",
    name: "base64url",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    bitsPerChar: 6
});
var base64urlpad = rfc4648({
    prefix: "U",
    name: "base64urlpad",
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
    bitsPerChar: 6
});
// src/utils.ts
var import_canonicalize = __toESM(require_canonicalize(), 1);
var stringRegex = /^[a-zA-Z0-9.*_+-]+$/g;
var abilityStringRegex = /^[a-zA-Z0-9.*_+-]+\/[a-zA-Z0-9.*_+-]+$/g;
var validString = (str)=>str.match(stringRegex) !== null;
var validAbString = (str)=>str.match(abilityStringRegex) !== null;
var encodeRecap = (att, prf)=>base64url.encoder.baseEncode(new TextEncoder().encode((0, import_canonicalize.default)({
        att,
        prf: prf.map((cid)=>cid.toV1().toString(base58btc.encoder))
    })));
var decodeRecap = (recap)=>{
    const { att, prf } = JSON.parse(new TextDecoder().decode(base64url.decoder.baseDecode(recap)));
    if (!(att instanceof Object) || Array.isArray(att)) {
        throw new Error("Invalid attenuation object");
    }
    if (!Array.isArray(prf) || prf.some((cid)=>typeof cid !== "string")) {
        throw new Error("Invalid proof list");
    }
    checkAtt(att);
    if (!isSorted(att)) {
        throw new Error("Attenuation object is not properly sorted");
    }
    return {
        att,
        prf: prf.map((cid)=>CID.parse(cid, base58btc))
    };
};
var checkAtt = (att)=>{
    for (const ob of Object.values(att)){
        if (!(ob instanceof Object)) {
            throw new Error("Invalid attenuation object");
        }
        for (const [ab, nb] of Object.entries(ob)){
            if (!validAbString(ab)) {
                throw new Error(`Invalid ability string: ${ab}`);
            }
            if (!Array.isArray(nb) || nb.some((n)=>!(n instanceof Object) || Array.isArray(n))) {
                throw new Error(`Invalid nota-bene list for ${ab}`);
            }
        }
    }
    return true;
};
var isSorted = (obj)=>{
    if (Array.isArray(obj)) {
        return obj.every(isSorted);
    } else if (obj instanceof Object) {
        const keys = Object.keys(obj);
        return Object.keys(obj).sort().every((v, i)=>v === keys[i]) && Object.values(obj).every(isSorted);
    } else {
        return true;
    }
};
// src/index.ts
var urnRecapPrefix = "urn:recap:";
var _prf, _att;
var _Recap = class {
    /**
   * Constructs a Recap instance
   *
   * @param att - The input attenuation object (default is an empty object {})
   * @param prf - The input proof array (default is an empty array [])
   */ constructor(att = {}, prf = []){
        __privateAdd(this, _prf, void 0);
        __privateAdd(this, _att, void 0);
        checkAtt(att);
        __privateSet(this, _att, att);
        __privateSet(this, _prf, prf.map((cid)=>typeof cid === "string" ? CID.parse(cid) : cid));
    }
    /**
   * Gets the proofs array of the Recap object
   *
   * @returns An Array of CID objects
   */ get proofs() {
        return __privateGet(this, _prf);
    }
    /**
  * Gets the attenuation object of the Recap object
  *
  * @returns An attenuation object (AttObj)
  */ get attenuations() {
        return __privateGet(this, _att);
    }
    /**
   * Calculates the statement field of a SIWE recap-transformed-statement
   *
   * @returns A string representing the statement constructed from the Recap object
   */ get statement() {
        let statement = "I further authorize the stated URI to perform the following actions on my behalf: ";
        let section = 1;
        for (const resource of Object.keys(this.attenuations).sort()){
            const resourceAbilities = Object.keys(this.attenuations[resource]).sort().reduce((acc, cur)=>{
                const [namespace, name] = cur.split("/");
                if (acc[namespace] === void 0) {
                    acc[namespace] = [
                        name
                    ];
                } else {
                    acc[namespace].push(name);
                }
                return acc;
            }, {});
            for (const [namespace, names] of Object.entries(resourceAbilities)){
                statement += `(${section}) '${namespace}': ${names.map((n)=>`'${n}'`).join(", ")} for '${resource}'. `;
                section += 1;
            }
        }
        statement = statement.slice(0, -1);
        return statement;
    }
    /**
   * Adds a new proof to the proofs collection of the Recap object
   *
   * @param cid - A CID (Content Identifier) object or its string representation
   */ addProof(cid) {
        if (typeof cid === "string") {
            __privateGet(this, _prf).push(CID.parse(cid));
        } else {
            __privateGet(this, _prf).push(cid);
        }
    }
    /**
   * Adds a new attenuation to the attenuations object of the Recap object
   *
   * @param resource - The resource URI
   * @param namespace - The ability namespace (default is *)
   * @param name - The ability name (default is *)
   * @param restriction - A JSON object containing restrictions or requirements for the action (default is {})
   */ addAttenuation(resource, namespace = "*", name = "*", restriction = {}) {
        if (!validString(namespace)) {
            throw new Error("Invalid ability namespace");
        }
        if (!validString(name)) {
            throw new Error("Invalid ability name");
        }
        const abString = `${namespace}/${name}`;
        const ex = __privateGet(this, _att)[resource];
        if (ex !== void 0) {
            if (ex[abString] !== void 0) {
                ex[abString].push(restriction);
            } else {
                ex[abString] = [
                    restriction
                ];
            }
        } else {
            __privateGet(this, _att)[resource] = {
                [abString]: [
                    restriction
                ]
            };
        }
    }
    /**
   * Merges another Recap object with the current Recap object
   *
   * @param other - The other Recap object to be merged
   */ merge(other) {
        __privateGet(this, _prf).push(...other.proofs.filter((cid)=>!__privateGet(this, _prf).includes(cid)));
        for (const [resource, abilities] of Object.entries(other.attenuations)){
            if (__privateGet(this, _att)[resource] !== void 0) {
                const ex = __privateGet(this, _att)[resource];
                for (const [ability, restrictions] of Object.entries(abilities)){
                    if (ex[ability] === void 0 || ex[ability].length === 0 || ex[ability].every((r)=>Object.keys(r).length === 0)) {
                        ex[ability] = restrictions;
                    } else {
                        ex[ability].push(...restrictions);
                    }
                }
            } else {
                __privateGet(this, _att)[resource] = abilities;
            }
        }
    }
    /**
   * Decodes a Recap URI into a Recap object
   *
   * @param recap - The input Recap URI string
   * @returns A Recap object decoded from the input Recap URI
   * @throws Will throw an error if the input string is not a valid Recap URI
   */ static decode_urn(recap) {
        if (!recap.startsWith(urnRecapPrefix)) {
            throw new Error("Invalid recap urn");
        }
        const { att, prf } = decodeRecap(recap.slice(urnRecapPrefix.length));
        return new _Recap(att, prf);
    }
    /**
   * Extracts the Recap object from a SiweMessage instance
   *
   * @param siwe - A SiweMessage instance
   * @returns A Recap object extracted from the input SiweMessage
   * @throws Will throw an error if the SiweMessage doesn't have any resources
   */ static extract(siwe) {
        if (siwe.resources === void 0) {
            throw new Error("No resources in SiweMessage");
        }
        const last_index = siwe.resources.length - 1;
        return _Recap.decode_urn(siwe.resources[last_index]);
    }
    /**
   * Extracts and verifies a Recap object from a SiweMessage instance
   *
   * @param siwe - A SiweMessage instance
   * @returns A verified Recap object extracted from the input SiweMessage
   * @throws Will throw an error if the SiweMessage has an invalid statement
   */ static extract_and_verify(siwe) {
        const recap = _Recap.extract(siwe);
        if (siwe.statement === void 0 || !siwe.statement.endsWith(recap.statement)) {
            throw new Error("Invalid statement");
        }
        return recap;
    }
    /**
   * Adds a Recap object to a SiweMessage
   *
   * @param siwe - The input SiweMessage instance to be modified
   * @returns A modified SiweMessage instance with the Recap object added
   */ add_to_siwe_message(siwe) {
        try {
            if (siwe.statement === void 0 || siwe.resources === void 0 || siwe.resources.length === 0) {
                throw new Error("no recap");
            }
            const other = _Recap.extract_and_verify(siwe);
            const previousStatement = other.statement;
            other.merge(this);
            siwe.statement = siwe.statement.slice(0, -previousStatement.length) + other.statement;
            siwe.resources[siwe.resources.length - 1] = other.encode();
            return siwe;
        } catch (e) {
            siwe.statement = siwe.statement === void 0 ? this.statement : siwe.statement + " " + this.statement;
            siwe.resources = siwe.resources === void 0 ? [
                this.encode()
            ] : [
                ...siwe.resources,
                this.encode()
            ];
            return siwe;
        }
    }
    /**
   * Encodes a Recap object into a Recap URI
   *
   * @returns A Recap URI string
   */ encode() {
        return `${urnRecapPrefix}${encodeRecap(__privateGet(this, _att), __privateGet(this, _prf))}`;
    }
};
var Recap = _Recap;
_prf = new WeakMap();
_att = new WeakMap();
}),
"[project]/node_modules/@lit-protocol/access-control-conditions/src/lib/canonicalFormatter.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.canonicalResourceIdFormatter = exports.canonicalCosmosConditionFormatter = exports.canonicalEVMContractConditionFormatter = exports.canonicalAccessControlConditionFormatter = exports.canonicalSolRpcConditionFormatter = exports.canonicalUnifiedAccessControlConditionFormatter = void 0;
const constants_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/access-control-conditions/node_modules/@lit-protocol/constants/src/index.js [app-client] (ecmascript)");
/** ---------- Local Functions ---------- */ /**
 *
 * Get operator param
 *
 * @param { ConditionItem } cond
 * @returns { AccsOperatorParams }
 */ const getOperatorParam = (cond)=>{
    const _cond = cond;
    return {
        operator: _cond.operator
    };
};
/**
 *
 * Canonical ABI Params
 *
 * @param { Array<ABIParams> } params
 * @returns { Array<ABIParams> }
 */ const canonicalAbiParamss = (params)=>{
    return params.map((param)=>({
            name: param.name,
            type: param.type
        }));
};
/**
 *
 * Canonical Unified Access Control Condition Formatter
 *
 * @param { UnifiedAccessControlConditions | ConditionItem } cond
 * @returns { any[] | AccsOperatorParams | any }
 */ const canonicalUnifiedAccessControlConditionFormatter = (cond)=>{
    // -- if it's an array
    if (Array.isArray(cond)) {
        return cond.map((c)=>(0, exports.canonicalUnifiedAccessControlConditionFormatter)(c));
    }
    // -- if there's a `operator` key in the object
    if ('operator' in cond) {
        return getOperatorParam(cond);
    }
    // -- otherwise
    if ('returnValueTest' in cond) {
        const _cond = cond;
        const _conditionType = _cond.conditionType;
        switch(_conditionType){
            case 'solRpc':
                return (0, exports.canonicalSolRpcConditionFormatter)(cond, true);
            case 'evmBasic':
                return (0, exports.canonicalAccessControlConditionFormatter)(cond);
            case 'evmContract':
                return (0, exports.canonicalEVMContractConditionFormatter)(cond);
            case 'cosmos':
                return (0, exports.canonicalCosmosConditionFormatter)(cond);
            default:
                throw new constants_1.InvalidAccessControlConditions({
                    info: {
                        cond
                    }
                }, 'You passed an invalid access control condition that is missing or has a wrong "conditionType"');
        }
    }
    throw new constants_1.InvalidAccessControlConditions({
        info: {
            cond
        }
    }, 'You passed an invalid access control condition');
};
exports.canonicalUnifiedAccessControlConditionFormatter = canonicalUnifiedAccessControlConditionFormatter;
/**
*
* (SOLANA) Canonical Solana RPC Condition Formatter
*
* need to return in the exact format below:
* but make sure we don't include the optional fields:
 ---
  #[derive(Debug, Serialize, Deserialize, Clone)]
  #[serde(rename_all = "camelCase")]
  pub struct SolRpcCondition {
      pub method: String,
      pub params: Vec<serde_json::Value>,
      pub pda_params: Option<Vec<serde_json::Value>>,
      pub pda_interface: Option<SolPdaInterface>,
      pub chain: String,
      pub return_value_test: JsonReturnValueTestV2,
  }

  #[derive(Debug, Serialize, Deserialize, Clone)]
  #[serde(rename_all = "camelCase")]
  pub struct SolPdaInterface {
      pub offset: u64,
      pub fields: serde_json::Value,
  }
  ---
*
* @param { object } cond
* @param { boolean } requireV2Conditions
*
* @returns { any[] | AccsOperatorParams | AccsSOLV2Params | any }
*/ const canonicalSolRpcConditionFormatter = (cond, requireV2Conditions = false)=>{
    // -- if is array
    if (Array.isArray(cond)) {
        return cond.map((c)=>(0, exports.canonicalSolRpcConditionFormatter)(c, requireV2Conditions));
    }
    // -- if there's a `operator` key in the object
    if ('operator' in cond) {
        return getOperatorParam(cond);
    }
    // -- if it has a return value
    if ('returnValueTest' in cond) {
        const { returnValueTest } = cond;
        const canonicalReturnValueTest = {
            // @ts-ignore
            key: returnValueTest.key,
            comparator: returnValueTest.comparator,
            value: returnValueTest.value
        };
        // -- check if this is a sol v1 or v2 condition
        // -- v1 conditions didn't have any pda params or pda interface or pda key
        // -- SOL version 1:: return V2 must have params
        if ('pdaParams' in cond || requireV2Conditions) {
            const _assumedV2Cond = cond;
            if (!('pdaInterface' in _assumedV2Cond) || !('pdaKey' in _assumedV2Cond) || !('offset' in _assumedV2Cond.pdaInterface) || !('fields' in _assumedV2Cond.pdaInterface)) {
                throw new constants_1.InvalidAccessControlConditions({
                    info: {
                        cond
                    }
                }, 'Solana RPC Conditions have changed and there are some new fields you must include in your condition.  Check the docs here: https://developer.litprotocol.com/AccessControlConditions/solRpcConditions');
            }
            // -- else
            const canonicalPdaInterface = {
                offset: _assumedV2Cond.pdaInterface.offset,
                fields: _assumedV2Cond.pdaInterface.fields
            };
            const _solV2Cond = cond;
            const _requiredParams = {
                method: _solV2Cond.method,
                params: _solV2Cond.params,
                pdaParams: _solV2Cond.pdaParams,
                pdaInterface: canonicalPdaInterface,
                pdaKey: _solV2Cond.pdaKey,
                chain: _solV2Cond.chain,
                returnValueTest: canonicalReturnValueTest
            };
            return _requiredParams;
        // -- SOL version 2:: return default params
        } else {
            const _solV1Cond = cond;
            const _requiredParams = {
                // @ts-ignore
                method: _solV1Cond.method,
                // @ts-ignore
                params: _solV1Cond.params,
                chain: _solV1Cond.chain,
                returnValueTest: canonicalReturnValueTest
            };
            return _requiredParams;
        }
    }
    // -- else
    throw new constants_1.InvalidAccessControlConditions({
        info: {
            cond
        }
    }, 'You passed an invalid access control condition');
};
exports.canonicalSolRpcConditionFormatter = canonicalSolRpcConditionFormatter;
/**
*
* (DEFAULT) Canonical Access Control Condition Formatter
*
* need to return in the exact format below:
 ---
  pub struct JsonAccessControlCondition {
    pub contract_address: String,
    pub chain: String,
    pub standard_contract_type: String,
    pub method: String,
    pub parameters: Vec<String>,
    pub return_value_test: JsonReturnValueTest,
  }
  ---
*
* @param { AccsDefaultParams | AccsOperatorParams | AccessControlConditions } cond
*
* @returns { any[] | AccsOperatorParams | AccsDefaultParams | any }
*/ const canonicalAccessControlConditionFormatter = (cond)=>{
    // -- if it's an array
    if (Array.isArray(cond)) {
        return cond.map((c)=>(0, exports.canonicalAccessControlConditionFormatter)(c));
    }
    // -- if there's a `operator` key in the object
    if ('operator' in cond) {
        return getOperatorParam(cond);
    }
    if ('returnValueTest' in cond) {
        const _cond = cond;
        const _return = {
            contractAddress: _cond.contractAddress,
            chain: _cond.chain,
            standardContractType: _cond.standardContractType,
            method: _cond.method,
            parameters: _cond.parameters,
            returnValueTest: {
                comparator: _cond.returnValueTest.comparator,
                value: _cond.returnValueTest.value
            }
        };
        return _return;
    }
    throw new constants_1.InvalidAccessControlConditions({
        info: {
            cond
        }
    }, 'You passed an invalid access control condition');
};
exports.canonicalAccessControlConditionFormatter = canonicalAccessControlConditionFormatter;
/**
*
* (EVM) Canonical EVM Contract Condition Formatter
*
*  need to return in the exact format below:
  ---
  pub struct JsonAccessControlCondition {
      pub contract_address: String,
      pub chain: String,
      pub standard_contract_type: String,
      pub method: String,
      pub parameters: Vec<String>,
      pub return_value_test: JsonReturnValueTest,
  }
  ---
*
* @param { AccsEVMParams | AccsOperatorParams | EvmContractConditions } cond
*
* @returns
*/ const canonicalEVMContractConditionFormatter = (cond)=>{
    // -- if it's an array
    if (Array.isArray(cond)) {
        return cond.map((c)=>(0, exports.canonicalEVMContractConditionFormatter)(c));
    }
    // -- if there's a `operator` key in the object
    if ('operator' in cond) {
        const _cond = cond;
        return {
            operator: _cond.operator
        };
    }
    if ('returnValueTest' in cond) {
        /* abi needs to match:
          pub name: String,
          /// Function input.
          pub inputs: Vec<Param>,
          /// Function output.
          pub outputs: Vec<Param>,
          #[deprecated(note = "The constant attribute was removed in Solidity 0.5.0 and has been \
              replaced with stateMutability. If parsing a JSON AST created with \
              this version or later this value will always be false, which may be wrong.")]
          /// Constant function.
          #[cfg_attr(feature = "full-serde", serde(default))]
          pub constant: bool,
          /// Whether the function reads or modifies blockchain state
          #[cfg_attr(feature = "full-serde", serde(rename = "stateMutability", default))]
          pub state_mutability: StateMutability,
          */ const evmCond = cond;
        const { functionAbi, returnValueTest } = evmCond;
        const canonicalAbi = {
            name: functionAbi.name,
            inputs: canonicalAbiParamss(functionAbi.inputs),
            outputs: canonicalAbiParamss(functionAbi.outputs),
            constant: typeof functionAbi.constant === 'undefined' ? false : functionAbi.constant,
            stateMutability: functionAbi.stateMutability
        };
        const canonicalReturnValueTest = {
            key: returnValueTest.key,
            comparator: returnValueTest.comparator,
            value: returnValueTest.value
        };
        const _return = {
            contractAddress: evmCond.contractAddress,
            functionName: evmCond.functionName,
            functionParams: evmCond.functionParams,
            functionAbi: canonicalAbi,
            chain: evmCond.chain,
            returnValueTest: canonicalReturnValueTest
        };
        return _return;
    }
    throw new constants_1.InvalidAccessControlConditions({
        info: {
            cond
        }
    }, 'You passed an invalid access control condition');
};
exports.canonicalEVMContractConditionFormatter = canonicalEVMContractConditionFormatter;
/**
*
* (COSMOS) Canonical Condition Formmater for Cosmos
*
* need to return in the exact format below:
 ---
  pub struct CosmosCondition {
      pub path: String,
      pub chain: String,
      pub return_value_test: JsonReturnValueTestV2,
  }
 ---
*
*
* @param { ConditionItem } cond
* @returns
*/ const canonicalCosmosConditionFormatter = (cond)=>{
    // -- if it's an array
    if (Array.isArray(cond)) {
        return cond.map((c)=>(0, exports.canonicalCosmosConditionFormatter)(c));
    }
    // -- if there's a `operator` key in the object
    if ('operator' in cond) {
        const _cond = cond;
        return {
            operator: _cond.operator
        };
    }
    if ('returnValueTest' in cond) {
        const _cosmosCond = cond;
        const { returnValueTest } = _cosmosCond;
        const canonicalReturnValueTest = {
            key: returnValueTest.key,
            comparator: returnValueTest.comparator,
            value: returnValueTest.value
        };
        return {
            path: _cosmosCond.path,
            chain: _cosmosCond.chain,
            method: _cosmosCond?.method,
            parameters: _cosmosCond?.parameters,
            returnValueTest: canonicalReturnValueTest
        };
    }
    throw new constants_1.InvalidAccessControlConditions({
        info: {
            cond
        }
    }, 'You passed an invalid access control condition');
};
exports.canonicalCosmosConditionFormatter = canonicalCosmosConditionFormatter;
/**
 *
 * Canonical ResourceId Formatter returning JSON signing resource id
 *
 * @param { JsonSigningResourceId } resId
 *
 * @returns { JsonSigningResourceId }
 *
 */ const canonicalResourceIdFormatter = (resId)=>{
    // need to return in the exact format below:
    return {
        baseUrl: resId.baseUrl,
        path: resId.path,
        orgId: resId.orgId,
        role: resId.role,
        extraData: resId.extraData
    };
};
exports.canonicalResourceIdFormatter = canonicalResourceIdFormatter; //# sourceMappingURL=canonicalFormatter.js.map
}),
"[project]/node_modules/@lit-protocol/access-control-conditions/src/lib/hashing.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.hashSolRpcConditions = exports.hashEVMContractConditions = exports.hashAccessControlConditions = exports.hashResourceIdForSigning = exports.hashResourceId = exports.hashUnifiedAccessControlConditions = void 0;
const constants_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/access-control-conditions/node_modules/@lit-protocol/constants/src/index.js [app-client] (ecmascript)");
const misc_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/misc/src/index.js [app-client] (ecmascript)");
const uint8arrays_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/uint8arrays/src/index.js [app-client] (ecmascript)");
const canonicalFormatter_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/access-control-conditions/src/lib/canonicalFormatter.js [app-client] (ecmascript)");
// Same as:
// const unifiedAccs = [
//   {
//     conditionType: 'evmBasic',
//     contractAddress: '',
//     standardContractType: '',
//     chain: 'ethereum',
//     method: '',
//     parameters: [':userAddress'],
//     returnValueTest: {
//       comparator: '=',
//       value: '0xBD4701851e9C9a22f448860A78872A00Da87899e',
//     },
//   },
//   { operator: 'or' },
//   {
//     conditionType: 'evmBasic',
//     contractAddress: '',
//     standardContractType: '',
//     chain: 'ethereum',
//     method: '',
//     parameters: [':userAddress'],
//     returnValueTest: {
//       comparator: '=',
//       value: '0x93E47A604BA72899a5f8dF986cF26C97AfdaE2A0',
//     },
//   },
// ];
// export const generateUnifiedAccsForRLIDelegation = async (
//   ethAddresses: string[]
// ): Promise<string> => {
//   const unifiedAccs: any[] = [];
//   ethAddresses.forEach((address, index) => {
//     const condition = {
//       conditionType: 'evmBasic',
//       contractAddress: '',
//       standardContractType: '',
//       chain: 'ethereum',
//       method: '',
//       parameters: [':userAddress'],
//       returnValueTest: {
//         comparator: '=',
//         value: address,
//       },
//     };
//     unifiedAccs.push(condition);
//     // Add the operator for all but the last address
//     if (index < ethAddresses.length - 1) {
//       unifiedAccs.push({ operator: 'or' });
//     }
//   });
//   const hash = await hashUnifiedAccessControlConditions(unifiedAccs);
//   return uint8arrayToString(new Uint8Array(hash), 'base16');
// };
/**
 *
 * Hash the unified access control conditions using SHA-256 in a deterministic way.
 *
 * @param { UnifiedAccessControlConditions } unifiedAccessControlConditions - The unified access control conditions to hash.
 * @returns { Promise<ArrayBuffer> } A promise that resolves to an ArrayBuffer that contains the hash
 */ const hashUnifiedAccessControlConditions = (unifiedAccessControlConditions)=>{
    (0, misc_1.log)('unifiedAccessControlConditions:', unifiedAccessControlConditions);
    const conditions = unifiedAccessControlConditions.map((condition)=>{
        return (0, canonicalFormatter_1.canonicalUnifiedAccessControlConditionFormatter)(condition);
    });
    (0, misc_1.log)('conditions:', conditions);
    // check if there's any undefined in the conditions
    const hasUndefined = conditions.some((c)=>c === undefined);
    if (hasUndefined) {
        throw new constants_1.InvalidAccessControlConditions({
            info: {
                conditions
            }
        }, 'Invalid access control conditions');
    }
    if (conditions.length === 0) {
        throw new constants_1.InvalidAccessControlConditions({
            info: {
                conditions
            }
        }, 'No conditions provided');
    }
    const toHash = JSON.stringify(conditions);
    (0, misc_1.log)('Hashing unified access control conditions: ', toHash);
    const encoder = new TextEncoder();
    const data = encoder.encode(toHash);
    return crypto.subtle.digest('SHA-256', data);
};
exports.hashUnifiedAccessControlConditions = hashUnifiedAccessControlConditions;
/**
 *
 * Hash resource id
 *
 * @param { JsonSigningResourceId } resourceId
 *
 * @returns { Promise<ArrayBuffer> }
 *
 */ const hashResourceId = (resourceId)=>{
    const resId = (0, canonicalFormatter_1.canonicalResourceIdFormatter)(resourceId);
    const toHash = JSON.stringify(resId);
    const encoder = new TextEncoder();
    const data = encoder.encode(toHash);
    return crypto.subtle.digest('SHA-256', data);
};
exports.hashResourceId = hashResourceId;
/**
 *
 * Hash resourceId for signing
 *
 * @param { JSONSigningResourceId } resourceId
 *
 * @returns { string } example: "5b36d72f2145af3617e5da2a8a626f9f42e64ed14340622bdfe1a6f0702b9e8d"
 */ const hashResourceIdForSigning = async (resourceId)=>{
    const hashed = await (0, exports.hashResourceId)(resourceId);
    return (0, uint8arrays_1.uint8arrayToString)(new Uint8Array(hashed), 'base16');
};
exports.hashResourceIdForSigning = hashResourceIdForSigning;
/**
 *
 * Hash access control conditions
 *
 * @param { AccessControlConditions } accessControlConditions
 *
 * @returns { Promise<ArrayBuffer> } example: {"data": [83, 176, 31, 130, 12, 130, 232, 109, 126, 76, 216, 4, 184, 166, 246, 134, 130, 34, 30, 235, 125, 247, 111, 212, 62, 231, 119, 200, 202, 171, 86, 40], "type": "Buffer"}
 *
 */ const hashAccessControlConditions = (accessControlConditions)=>{
    const conds = accessControlConditions.map((c)=>(0, canonicalFormatter_1.canonicalAccessControlConditionFormatter)(c));
    const toHash = JSON.stringify(conds);
    (0, misc_1.log)('Hashing access control conditions: ', toHash);
    const encoder = new TextEncoder();
    const data = encoder.encode(toHash);
    return crypto.subtle.digest('SHA-256', data);
};
exports.hashAccessControlConditions = hashAccessControlConditions;
/**
 *
 * Hash EVM access control conditions
 *
 * @param { EvmContractConditions } evmContractConditions
 *
 * @returns { Promise<ArrayBuffer> } {"data": [216, 92, 128, 31, 171, 114, 74, 115, 133, 44, 234, 171, 214, 205, 228, 137, 117, 238, 14, 229, 254, 239, 97, 126, 1, 20, 166, 144, 176, 147, 217, 32], "type": "Buffer"}
 *
 */ const hashEVMContractConditions = (evmContractConditions)=>{
    const conds = evmContractConditions.map((c)=>(0, canonicalFormatter_1.canonicalEVMContractConditionFormatter)(c));
    const toHash = JSON.stringify(conds);
    (0, misc_1.log)('Hashing evm contract conditions: ', toHash);
    const encoder = new TextEncoder();
    const data = encoder.encode(toHash);
    return crypto.subtle.digest('SHA-256', data);
};
exports.hashEVMContractConditions = hashEVMContractConditions;
/**
 *
 * Hash SOL access control conditions
 *
 * @param { SolRpcConditions } solRpcConditions
 *
 * @returns { Promise<ArrayBuffer> }
 *
 */ const hashSolRpcConditions = (solRpcConditions)=>{
    const conds = solRpcConditions.map((c)=>(0, canonicalFormatter_1.canonicalSolRpcConditionFormatter)(c));
    const toHash = JSON.stringify(conds);
    (0, misc_1.log)('Hashing sol rpc conditions: ', toHash);
    const encoder = new TextEncoder();
    const data = encoder.encode(toHash);
    return crypto.subtle.digest('SHA-256', data);
};
exports.hashSolRpcConditions = hashSolRpcConditions; //# sourceMappingURL=hashing.js.map
}),
"[project]/node_modules/@lit-protocol/access-control-conditions/src/lib/humanizer.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.humanizeAccessControlConditions = exports.humanizeUnifiedAccessControlConditions = exports.humanizeCosmosConditions = exports.humanizeSolRpcConditions = exports.humanizeEvmContractConditions = exports.humanizeEvmBasicAccessControlConditions = exports.humanizeComparator = exports.formatAtom = exports.formatSol = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib/utils.js [app-client] (ecmascript)");
const constants_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/access-control-conditions/node_modules/@lit-protocol/constants/src/index.js [app-client] (ecmascript)");
const misc_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/misc/src/index.js [app-client] (ecmascript)");
/**
 *
 * Format SOL number using Ether Units
 *
 * @param { number } amount
 *
 * @returns { string } formatted unit
 *
 */ const formatSol = (amount)=>{
    return (0, utils_1.formatUnits)(amount, 9);
};
exports.formatSol = formatSol;
/**
 *
 * Format Atom number using Ether Units
 *
 * @param { number } amount
 *
 * @returns { string } formatted unit
 *
 */ const formatAtom = (amount)=>{
    return (0, utils_1.formatUnits)(amount, 6);
};
exports.formatAtom = formatAtom;
/**
 *
 * Comparator translator
 *
 * @param { string } comparator
 *
 * @returns { string } humanized version of the comparator
 */ const humanizeComparator = (comparator)=>{
    const list = {
        '>': 'more than',
        '>=': 'at least',
        '=': 'exactly',
        '<': 'less than',
        '<=': 'at most',
        contains: 'contains'
    };
    const selected = list[comparator];
    if (!selected) {
        (0, misc_1.log)(`Unregonized comparator ${comparator}`);
        return;
    }
    return selected;
};
exports.humanizeComparator = humanizeComparator;
/**
 *
 * Humanize EVM basic access control conditions
 *
 * @property { Array<AccsDefaultParams | any> } accessControlConditions
 * @property { Array<any | string> } tokenList
 * @property { string } myWalletAddress
 *
 * @returns
 */ const humanizeEvmBasicAccessControlConditions = async ({ accessControlConditions, tokenList, myWalletAddress })=>{
    (0, misc_1.log)('humanizing evm basic access control conditions');
    (0, misc_1.log)('myWalletAddress', myWalletAddress);
    (0, misc_1.log)('accessControlConditions', accessControlConditions);
    let fixedConditions = accessControlConditions;
    // inject and operator if needed
    // this is done because before we supported operators,
    // we let users specify an entire array of conditions
    // that would be "AND"ed together.  this injects those ANDs
    if (accessControlConditions.length > 1) {
        let containsOperator = false;
        for(let i = 0; i < accessControlConditions.length; i++){
            if ('operator' in accessControlConditions[i]) {
                containsOperator = true;
            }
        }
        if (!containsOperator) {
            fixedConditions = [];
            // insert ANDs between conditions
            for(let i = 0; i < accessControlConditions.length; i++){
                fixedConditions.push(accessControlConditions[i]);
                if (i < accessControlConditions.length - 1) {
                    fixedConditions.push({
                        operator: 'and'
                    });
                }
            }
        }
    }
    // -- execute
    const promises = await Promise.all(fixedConditions.map(async (acc)=>{
        if (Array.isArray(acc)) {
            // this is a group.  recurse.
            const group = await (0, exports.humanizeEvmBasicAccessControlConditions)({
                accessControlConditions: acc,
                tokenList,
                myWalletAddress
            });
            return `( ${group} )`;
        }
        if (acc.operator) {
            if (acc.operator.toLowerCase() === 'and') {
                return ' and ';
            } else if (acc.operator.toLowerCase() === 'or') {
                return ' or ';
            }
        }
        if (acc.standardContractType === 'timestamp' && acc.method === 'eth_getBlockByNumber') {
            return `Latest mined block must be past the unix timestamp ${acc.returnValueTest.value}`;
        } else if (acc.standardContractType === 'MolochDAOv2.1' && acc.method === 'members') {
            // molochDAOv2.1 membership
            return `Is a member of the DAO at ${acc.contractAddress}`;
        } else if (acc.standardContractType === 'ERC1155' && acc.method === 'balanceOf') {
            // erc1155 owns an amount of specific tokens
            return `Owns ${(0, exports.humanizeComparator)(acc.returnValueTest.comparator)} ${acc.returnValueTest.value} of ${acc.contractAddress} tokens with token id ${acc.parameters[1]}`;
        } else if (acc.standardContractType === 'ERC1155' && acc.method === 'balanceOfBatch') {
            // erc1155 owns an amount of specific tokens from a batch of token ids
            return `Owns ${(0, exports.humanizeComparator)(acc.returnValueTest.comparator)} ${acc.returnValueTest.value} of ${acc.contractAddress} tokens with token id ${acc.parameters[1].split(',').join(' or ')}`;
        } else if (acc.standardContractType === 'ERC721' && acc.method === 'ownerOf') {
            // specific erc721
            return `Owner of tokenId ${acc.parameters[0]} from ${acc.contractAddress}`;
        } else if (acc.standardContractType === 'ERC721' && acc.method === 'balanceOf' && acc.contractAddress === '0x22C1f6050E56d2876009903609a2cC3fEf83B415' && acc.returnValueTest.comparator === '>' && acc.returnValueTest.value === '0') {
            // for POAP main contract where the user owns at least 1 poap
            return `Owns any POAP`;
        } else if (acc.standardContractType === 'POAP' && acc.method === 'tokenURI') {
            // owns a POAP
            return `Owner of a ${acc.returnValueTest.value} POAP on ${acc.chain}`;
        } else if (acc.standardContractType === 'POAP' && acc.method === 'eventId') {
            // owns a POAP
            return `Owner of a POAP from event ID ${acc.returnValueTest.value} on ${acc.chain}`;
        } else if (acc.standardContractType === 'CASK' && acc.method === 'getActiveSubscriptionCount') {
            // Cask powered subscription
            return `Cask subscriber to provider ${acc.parameters[1]} for plan ${acc.parameters[2]} on ${acc.chain}`;
        } else if (acc.standardContractType === 'ERC721' && acc.method === 'balanceOf') {
            // any erc721 in collection
            return `Owns ${(0, exports.humanizeComparator)(acc.returnValueTest.comparator)} ${acc.returnValueTest.value} of ${acc.contractAddress} tokens`;
        } else if (acc.standardContractType === 'ERC20' && acc.method === 'balanceOf') {
            let tokenFromList;
            if (tokenList) {
                tokenFromList = tokenList.find((t)=>t.address === acc.contractAddress);
            }
            let decimals, name;
            if (tokenFromList) {
                decimals = tokenFromList.decimals;
                name = tokenFromList.symbol;
            } else {
                try {
                    decimals = await (0, misc_1.decimalPlaces)({
                        contractAddress: acc.contractAddress,
                        chain: acc.chain
                    });
                } catch (e) {
                    console.log(`Failed to get decimals for ${acc.contractAddress}`);
                }
            }
            (0, misc_1.log)('decimals', decimals);
            return `Owns ${(0, exports.humanizeComparator)(acc.returnValueTest.comparator)} ${(0, utils_1.formatUnits)(acc.returnValueTest.value, decimals)} of ${name || acc.contractAddress} tokens`;
        } else if (acc.standardContractType === '' && acc.method === 'eth_getBalance') {
            return `Owns ${(0, exports.humanizeComparator)(acc.returnValueTest.comparator)} ${(0, utils_1.formatEther)(acc.returnValueTest.value)} ETH`;
        } else if (acc.standardContractType === '' && acc.method === '') {
            if (myWalletAddress && acc.returnValueTest.value.toLowerCase() === myWalletAddress.toLowerCase()) {
                return `Controls your wallet (${myWalletAddress})`;
            } else {
                return `Controls wallet with address ${acc.returnValueTest.value}`;
            }
        }
        return 'Oops. something went wrong!';
    }));
    return promises.join('');
};
exports.humanizeEvmBasicAccessControlConditions = humanizeEvmBasicAccessControlConditions;
/**
 *
 * Humanize EVM contract conditions
 *
 * @property { Array<AccsEVMParams> } evmContractConditions
 * @property { Array<any | string> } tokenList
 * @property { string } myWalletAddress
 *
 * @returns { Promise<string> } A promise containing a human readable description of the access control conditions
 *
 */ const humanizeEvmContractConditions = async ({ evmContractConditions, tokenList, myWalletAddress })=>{
    (0, misc_1.log)('humanizing evm contract conditions');
    (0, misc_1.log)('myWalletAddress', myWalletAddress);
    (0, misc_1.log)('evmContractConditions', evmContractConditions);
    const promises = await Promise.all(evmContractConditions.map(async (acc)=>{
        if (Array.isArray(acc)) {
            // this is a group.  recurse.
            const group = await (0, exports.humanizeEvmContractConditions)({
                evmContractConditions: acc,
                tokenList,
                myWalletAddress
            });
            return `( ${group} )`;
        }
        if (acc.operator) {
            if (acc.operator.toLowerCase() === 'and') {
                return ' and ';
            } else if (acc.operator.toLowerCase() === 'or') {
                return ' or ';
            }
        }
        let msg = `${acc.functionName}(${acc.functionParams.join(', ')}) on contract address ${acc.contractAddress} should have a result of ${(0, exports.humanizeComparator)(acc.returnValueTest.comparator)} ${acc.returnValueTest.value}`;
        if (acc.returnValueTest.key !== '') {
            msg += ` for key ${acc.returnValueTest.key}`;
        }
        return msg;
    }));
    return promises.join('');
};
exports.humanizeEvmContractConditions = humanizeEvmContractConditions;
/**
 *
 * Humanize SOL RPC Conditions
 *
 * @property { Array<AccsSOLV2Params> } solRpcConditions
 * @property { Array<any | string> } tokenList
 * @property { string } myWalletAddress
 *
 * @returns { Promise<string> } A promise containing a human readable description of the access control conditions
 *
 */ const humanizeSolRpcConditions = async ({ solRpcConditions, tokenList, myWalletAddress })=>{
    (0, misc_1.log)('humanizing sol rpc conditions');
    (0, misc_1.log)('myWalletAddress', myWalletAddress);
    (0, misc_1.log)('solRpcConditions', solRpcConditions);
    const promises = await Promise.all(solRpcConditions.map(async (acc)=>{
        if (Array.isArray(acc)) {
            // this is a group.  recurse.
            const group = await (0, exports.humanizeSolRpcConditions)({
                solRpcConditions: acc,
                tokenList,
                myWalletAddress
            });
            return `( ${group} )`;
        }
        if (acc.operator) {
            if (acc.operator.toLowerCase() === 'and') {
                return ' and ';
            } else if (acc.operator.toLowerCase() === 'or') {
                return ' or ';
            }
        }
        if (acc.method === 'getBalance') {
            return `Owns ${(0, exports.humanizeComparator)(acc.returnValueTest.comparator)} ${(0, exports.formatSol)(acc.returnValueTest.value)} SOL`;
        } else if (acc.method === '') {
            if (myWalletAddress && acc.returnValueTest.value.toLowerCase() === myWalletAddress.toLowerCase()) {
                return `Controls your wallet (${myWalletAddress})`;
            } else {
                return `Controls wallet with address ${acc.returnValueTest.value}`;
            }
        } else {
            let msg = `Solana RPC method ${acc.method}(${acc.params.join(', ')}) should have a result of ${(0, exports.humanizeComparator)(acc.returnValueTest.comparator)} ${acc.returnValueTest.value}`;
            if (acc.returnValueTest.key !== '') {
                msg += ` for key ${acc.returnValueTest.key}`;
            }
            return msg;
        }
    }));
    return promises.join('');
};
exports.humanizeSolRpcConditions = humanizeSolRpcConditions;
/**
 *
 * Humanize Cosmos Conditions
 *
 * @property { Array<AccsCOSMOSParams> } cosmosConditions
 * @property { Array<any | string> } tokenList
 * @property { string } myWalletAddress
 *
 * @returns { Promise<string> } A promise containing a human readable description of the access control conditions
 *
 */ const humanizeCosmosConditions = async ({ cosmosConditions, tokenList, myWalletAddress })=>{
    (0, misc_1.log)('humanizing cosmos conditions');
    (0, misc_1.log)('myWalletAddress', myWalletAddress);
    (0, misc_1.log)('cosmosConditions', cosmosConditions);
    const promises = await Promise.all(cosmosConditions.map(async (acc)=>{
        if (Array.isArray(acc)) {
            // this is a group.  recurse.
            const group = await (0, exports.humanizeCosmosConditions)({
                cosmosConditions: acc,
                tokenList,
                myWalletAddress
            });
            return `( ${group} )`;
        }
        if (acc.operator) {
            if (acc.operator.toLowerCase() === 'and') {
                return ' and ';
            } else if (acc.operator.toLowerCase() === 'or') {
                return ' or ';
            }
        }
        if (acc.path === '/cosmos/bank/v1beta1/balances/:userAddress') {
            return `Owns ${(0, exports.humanizeComparator)(acc.returnValueTest.comparator)} ${(0, exports.formatAtom)(acc.returnValueTest.value)} ATOM`;
        } else if (acc.path === ':userAddress') {
            if (myWalletAddress && acc.returnValueTest.value.toLowerCase() === myWalletAddress.toLowerCase()) {
                return `Controls your wallet (${myWalletAddress})`;
            } else {
                return `Controls wallet with address ${acc.returnValueTest.value}`;
            }
        } else if (acc.chain === 'kyve' && acc.path === '/kyve/registry/v1beta1/funders_list/0') {
            return `Is a current KYVE funder`;
        } else {
            let msg = `Cosmos RPC request for ${acc.path} should have a result of ${(0, exports.humanizeComparator)(acc.returnValueTest.comparator)} ${acc.returnValueTest.value}`;
            if (acc.returnValueTest.key !== '') {
                msg += ` for key ${acc.returnValueTest.key}`;
            }
            return msg;
        }
    }));
    return promises.join('');
};
exports.humanizeCosmosConditions = humanizeCosmosConditions;
/**
 *
 * Humanize unified access control conditions
 *
 * @property { Array<UnifiedAccessControlConditions> } unifiedAccessControlConditions
 * @property { Array<any | string> } tokenList
 * @property { string } myWalletAddress
 *
 * @returns { Promise<string> } A promise containing a human readable description of the access control conditions
 */ const humanizeUnifiedAccessControlConditions = async ({ unifiedAccessControlConditions, tokenList, myWalletAddress })=>{
    const promises = await Promise.all(unifiedAccessControlConditions.map(async (acc)=>{
        if (Array.isArray(acc)) {
            // this is a group.  recurse.
            const group = await (0, exports.humanizeUnifiedAccessControlConditions)({
                unifiedAccessControlConditions: acc,
                tokenList,
                myWalletAddress
            });
            return `( ${group} )`;
        }
        if (acc.operator) {
            if (acc.operator.toLowerCase() === 'and') {
                return ' and ';
            } else if (acc.operator.toLowerCase() === 'or') {
                return ' or ';
            }
        }
        if (acc.conditionType === 'evmBasic') {
            return (0, exports.humanizeEvmBasicAccessControlConditions)({
                accessControlConditions: [
                    acc
                ],
                tokenList,
                myWalletAddress
            });
        } else if (acc.conditionType === 'evmContract') {
            return (0, exports.humanizeEvmContractConditions)({
                evmContractConditions: [
                    acc
                ],
                tokenList,
                myWalletAddress
            });
        } else if (acc.conditionType === 'solRpc') {
            return (0, exports.humanizeSolRpcConditions)({
                solRpcConditions: [
                    acc
                ],
                tokenList,
                myWalletAddress
            });
        } else if (acc.conditionType === 'cosmos') {
            return (0, exports.humanizeCosmosConditions)({
                cosmosConditions: [
                    acc
                ],
                tokenList,
                myWalletAddress
            });
        } else {
            throw new constants_1.InvalidUnifiedConditionType({
                info: {
                    acc
                }
            }, 'Unrecognized condition type: %s', acc.conditionType);
        }
    }));
    return promises.join('');
};
exports.humanizeUnifiedAccessControlConditions = humanizeUnifiedAccessControlConditions;
/**
 *
 * The human readable name for an access control condition
 *
 * @param { HumanizedAccsProps } params
 *
 * @returns { Promise<string> } A promise containing a human readable description of the access control conditions
 */ const humanizeAccessControlConditions = async ({ accessControlConditions, evmContractConditions, solRpcConditions, unifiedAccessControlConditions, tokenList, myWalletAddress })=>{
    // -- check if each condition exists in linear
    if (accessControlConditions) {
        return (0, exports.humanizeEvmBasicAccessControlConditions)({
            accessControlConditions,
            tokenList,
            myWalletAddress
        });
    } else if (evmContractConditions) {
        return (0, exports.humanizeEvmContractConditions)({
            evmContractConditions,
            tokenList,
            myWalletAddress
        });
    } else if (solRpcConditions) {
        return (0, exports.humanizeSolRpcConditions)({
            solRpcConditions,
            tokenList,
            myWalletAddress
        });
    } else if (unifiedAccessControlConditions) {
        return (0, exports.humanizeUnifiedAccessControlConditions)({
            unifiedAccessControlConditions,
            tokenList,
            myWalletAddress
        });
    }
    // -- undefined
    return;
};
exports.humanizeAccessControlConditions = humanizeAccessControlConditions; //# sourceMappingURL=humanizer.js.map
}),
"[project]/node_modules/@lit-protocol/access-control-conditions/src/lib/validator.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.validateUnifiedAccessControlConditionsSchema = exports.validateSolRpcConditionsSchema = exports.validateEVMContractConditionsSchema = exports.validateAccessControlConditionsSchema = void 0;
const accs_schemas_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/accs-schemas/cjs/index.js [app-client] (ecmascript)");
const constants_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/access-control-conditions/node_modules/@lit-protocol/constants/src/index.js [app-client] (ecmascript)");
const misc_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/misc/src/index.js [app-client] (ecmascript)");
const SCHEMA_NAME_MAP = {
    cosmos: 'LPACC_ATOM',
    evmBasic: 'LPACC_EVM_BASIC',
    evmContract: 'LPACC_EVM_CONTRACT',
    solRpc: 'LPACC_SOL'
};
async function getSchema(accType) {
    try {
        const schemaName = SCHEMA_NAME_MAP[accType];
        return (0, accs_schemas_1.loadSchema)(schemaName);
    } catch (err) {
        throw new constants_1.InvalidArgumentException({
            info: {
                accType
            }
        }, `No schema found for condition type %s`, accType);
    }
}
/**
 * Validates EVM basic access control conditions schema
 * @param { AccessControlConditions } accs
 */ const validateAccessControlConditionsSchema = async (accs)=>{
    for (const acc of accs){
        // conditions can be nested to make boolean expressions
        if (Array.isArray(acc)) {
            await (0, exports.validateAccessControlConditionsSchema)(acc);
            continue;
        }
        if ('operator' in acc) {
            continue;
        }
        (0, misc_1.checkSchema)(acc, await getSchema('evmBasic'), 'accessControlConditions', 'validateAccessControlConditionsSchema');
    }
    return true;
};
exports.validateAccessControlConditionsSchema = validateAccessControlConditionsSchema;
/**
 * Validates EVM contract access control conditions schema
 * @param { EvmContractConditions } accs
 */ const validateEVMContractConditionsSchema = async (accs)=>{
    for (const acc of accs){
        // conditions can be nested to make boolean expressions
        if (Array.isArray(acc)) {
            await (0, exports.validateEVMContractConditionsSchema)(acc);
            continue;
        }
        if ('operator' in acc) {
            continue;
        }
        (0, misc_1.checkSchema)(acc, await getSchema('evmContract'), 'evmContractConditions', 'validateEVMContractConditionsSchema');
    }
    return true;
};
exports.validateEVMContractConditionsSchema = validateEVMContractConditionsSchema;
/**
 * Validates Sol access control conditions schema
 * @param { SolRpcConditions } accs
 */ const validateSolRpcConditionsSchema = async (accs)=>{
    for (const acc of accs){
        // conditions can be nested to make boolean expressions
        if (Array.isArray(acc)) {
            await (0, exports.validateSolRpcConditionsSchema)(acc);
            continue;
        }
        if ('operator' in acc) {
            continue;
        }
        (0, misc_1.checkSchema)(acc, await getSchema('solRpc'), 'solRpcConditions', 'validateSolRpcConditionsSchema');
    }
    return true;
};
exports.validateSolRpcConditionsSchema = validateSolRpcConditionsSchema;
/**
 * Validates unified access control conditions schema
 * @param { UnifiedAccessControlConditions } accs
 */ const validateUnifiedAccessControlConditionsSchema = async (accs)=>{
    for (const acc of accs){
        // conditions can be nested to make boolean expressions
        if (Array.isArray(acc)) {
            await (0, exports.validateUnifiedAccessControlConditionsSchema)(acc);
            continue;
        }
        if ('operator' in acc) {
            continue;
        }
        let schema;
        switch(acc.conditionType){
            case 'evmBasic':
                schema = await getSchema('evmBasic');
                break;
            case 'evmContract':
                schema = await getSchema('evmContract');
                break;
            case 'solRpc':
                schema = await getSchema('solRpc');
                break;
            case 'cosmos':
                schema = await getSchema('cosmos');
                break;
        }
        if (schema) {
            (0, misc_1.checkSchema)(acc, schema, 'accessControlConditions', 'validateUnifiedAccessControlConditionsSchema');
        } else {
            throw new constants_1.InvalidArgumentException({
                info: {
                    acc
                }
            }, `Missing schema to validate condition type %s`, acc.conditionType);
        }
    }
    return true;
};
exports.validateUnifiedAccessControlConditionsSchema = validateUnifiedAccessControlConditionsSchema; //# sourceMappingURL=validator.js.map
}),
"[project]/node_modules/@lit-protocol/access-control-conditions/src/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
const tslib_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/access-control-conditions/node_modules/tslib/tslib.es6.js [app-client] (ecmascript)");
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/access-control-conditions/src/lib/canonicalFormatter.js [app-client] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/access-control-conditions/src/lib/hashing.js [app-client] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/access-control-conditions/src/lib/humanizer.js [app-client] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/access-control-conditions/src/lib/validator.js [app-client] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@lit-protocol/accs-schemas/cjs/generated/LPACC_EVM_ATOM.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* eslint-disable */ /**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
}),
"[project]/node_modules/@lit-protocol/accs-schemas/cjs/generated/LPACC_EVM_BASIC.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* eslint-disable */ /**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
}),
"[project]/node_modules/@lit-protocol/accs-schemas/cjs/generated/LPACC_EVM_CONTRACT.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* eslint-disable */ /**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
}),
"[project]/node_modules/@lit-protocol/accs-schemas/cjs/generated/LPACC_SOL.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/* eslint-disable */ /**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
}),
"[project]/node_modules/@lit-protocol/accs-schemas/cjs/generated/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/accs-schemas/cjs/generated/LPACC_EVM_ATOM.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/accs-schemas/cjs/generated/LPACC_EVM_BASIC.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/accs-schemas/cjs/generated/LPACC_EVM_CONTRACT.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/accs-schemas/cjs/generated/LPACC_SOL.js [app-client] (ecmascript)"), exports);
}),
"[project]/node_modules/@lit-protocol/accs-schemas/cjs/schemas/LPACC_ATOM.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v({"$id":"https://github.com/LIT-Protocol/accs-schemas/blob/main/src/generated/LPACC_EVM_ATOM.ts","title":"LPACC_EVM_ATOM","description":"","type":"object","properties":{"conditionType":{"type":"string","enum":["cosmos"]},"path":{"type":"string"},"chain":{"enum":["cosmos","kyve","evmosCosmos","evmosCosmosTestnet","cheqdMainnet","cheqdTestnet","juno"]},"method":{"type":"string"},"parameters":{"type":"array","items":{"type":"string"}},"returnValueTest":{"type":"object","properties":{"key":{"type":"string"},"comparator":{"enum":["contains","=",">",">=","<","<="]},"value":{"type":"string"}},"required":["key","comparator","value"],"additionalProperties":false}},"required":["path","chain","returnValueTest"],"additionalProperties":false});}),
"[project]/node_modules/@lit-protocol/accs-schemas/cjs/schemas/LPACC_EVM_BASIC.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v({"$id":"https://github.com/LIT-Protocol/accs-schemas/blob/main/src/generated/LPACC_EVM_BASIC.json","title":"LPACC_EVM_BASIC","description":"","type":"object","properties":{"conditionType":{"type":"string","enum":["evmBasic"]},"contractAddress":{"type":"string"},"chain":{"enum":["ethereum","polygon","fantom","xdai","bsc","arbitrum","arbitrumSepolia","avalanche","fuji","harmony","mumbai","goerli","cronos","optimism","celo","aurora","eluvio","alfajores","xdc","evmos","evmosTestnet","bscTestnet","baseGoerli","baseSepolia","moonbeam","moonriver","moonbaseAlpha","filecoin","filecoinCalibrationTestnet","hyperspace","hedera","sepolia","scrollSepolia","scroll","zksync","base","lukso","luksoTestnet","zora","zoraGoerli","zksyncTestnet","lineaGoerli","lineaSepolia","chronicleTestnet","yellowstone","lit","chiado","zkEvm","mantleTestnet","mantle","klaytn","publicGoodsNetwork","optimismGoerli","waevEclipseTestnet","waevEclipseDevnet","verifyTestnet","fuse","campNetwork","vanar","lisk","chilizMainnet","chilizTestnet","skaleTestnet","skale","skaleCalypso","skaleCalypsoTestnet","skaleEuropaTestnet","skaleEuropa","skaleTitanTestnet","skaleTitan","fhenixHelium","fhenixNitrogen","hederaTestnet","bitTorrentTestnet","storyOdyssey","campTestnet","hushedNorthstar","amoy","matchain","coreDao","zkCandySepoliaTestnet","vana","moksha","rootstock","rootstockTestnet","merlin","merlinTestnet","bsquared","bsquaredTestnet","monadTestnet","bitlayer","bitlayerTestnet","bob","5fire","load","0gGalileoTestnet","peaqTestnet","peaqMainnet","sonicMainnet","sonicBlazeTestnet","holeskyTestnet","flowEvmTestnet","flowEvmMainnet","confluxEspaceMainnet","statusNetworkSepolia","0gMainnet","elastosSmartChainMainnet","elastosSmartChainTestnet","elastosIdentityChainMainnet","elastosIdentityChainTestnet","taikoAlethiaMainnet","taikoHeklaTestnet"]},"standardContractType":{"enum":["","ERC20","ERC721","ERC721MetadataName","ERC1155","CASK","Creaton","POAP","timestamp","MolochDAOv2.1","ProofOfHumanity","SIWE","PKPPermissions","LitAction"]},"method":{"type":"string"},"parameters":{"type":"array","items":{"type":"string"}},"returnValueTest":{"type":"object","properties":{"comparator":{"enum":["contains","=",">",">=","<","<="]},"value":{"type":"string"}},"required":["comparator","value"],"additionalProperties":false}},"required":["contractAddress","chain","standardContractType","method","parameters","returnValueTest"],"additionalProperties":false});}),
"[project]/node_modules/@lit-protocol/accs-schemas/cjs/schemas/LPACC_EVM_CONTRACT.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v({"$id":"https://github.com/LIT-Protocol/accs-schemas/blob/main/src/generated/LPACC_EVM_CONTRACT.json","title":"LPACC_EVM_CONTRACT","description":"","type":"object","properties":{"conditionType":{"type":"string","enum":["evmContract"]},"contractAddress":{"type":"string"},"chain":{"enum":["ethereum","polygon","fantom","xdai","bsc","arbitrum","arbitrumSepolia","avalanche","fuji","harmony","mumbai","goerli","cronos","optimism","celo","aurora","eluvio","alfajores","xdc","evmos","hedera","evmosTestnet","bscTestnet","baseGoerli","baseSepolia","moonbeam","moonriver","moonbaseAlpha","filecoin","filecoinCalibrationTestnet","hyperspace","sepolia","scrollSepolia","scroll","zksync","base","lukso","luksoTestnet","zora","zoraGoerli","zksyncTestnet","lineaGoerli","lineaSepolia","chronicleTestnet","yellowstone","lit","chiado","zkEvm","mantleTestnet","mantle","klaytn","publicGoodsNetwork","optimismGoerli","waevEclipseTestnet","waevEclipseDevnet","verifyTestnet","fuse","campNetwork","vanar","lisk","chilizMainnet","chilizTestnet","skaleTestnet","skale","skaleCalypso","skaleCalypsoTestnet","skaleEuropaTestnet","skaleEuropa","skaleTitanTestnet","skaleTitan","fhenixHelium","fhenixNitrogen","hederaTestnet","bitTorrentTestnet","storyOdyssey","campTestnet","hushedNorthstar","amoy","matchain","coreDao","zkCandySepoliaTestnet","vana","moksha","rootstock","rootstockTestnet","merlin","merlinTestnet","bsquared","bsquaredTestnet","monadTestnet","bitlayer","bitlayerTestnet","bob","5fire","load","0gGalileoTestnet","peaqTestnet","peaqMainnet","sonicMainnet","sonicBlazeTestnet","holeskyTestnet","flowEvmTestnet","flowEvmMainnet","confluxEspaceMainnet","statusNetworkSepolia","0gMainnet","elastosSmartChainMainnet","elastosSmartChainTestnet","elastosIdentityChainMainnet","elastosIdentityChainTestnet","taikoAlethiaMainnet","taikoHeklaTestnet"]},"functionName":{"type":"string"},"functionParams":{"type":"array","items":{"type":"string"}},"functionAbi":{"type":"object","properties":{"name":{"type":"string"},"type":{"type":"string"},"stateMutability":{"type":"string"},"constant":{"type":"boolean"},"inputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"type":{"type":"string"},"internalType":{"type":"string"}},"required":["name","type"],"additionalProperties":false}},"outputs":{"type":"array","items":{"type":"object","properties":{"name":{"type":"string"},"type":{"type":"string"},"internalType":{"type":"string"}},"required":["name","type"],"additionalProperties":false}}},"required":["name","stateMutability","inputs","outputs"],"additionalProperties":false},"returnValueTest":{"type":"object","properties":{"key":{"type":"string"},"comparator":{"enum":["contains","=",">",">=","<","<="]},"value":{"type":"string"}},"required":["key","comparator","value"],"additionalProperties":false}},"required":["contractAddress","chain","functionName","functionParams","functionAbi","returnValueTest"],"additionalProperties":false});}),
"[project]/node_modules/@lit-protocol/accs-schemas/cjs/schemas/LPACC_SOL.json (json)", ((__turbopack_context__) => {

__turbopack_context__.v({"$id":"https://github.com/LIT-Protocol/accs-schemas/blob/main/src/generated/LPACC_SOL.json","title":"LPACC_SOL","description":"","type":"object","properties":{"conditionType":{"type":"string","enum":["solRpc"]},"method":{"type":"string"},"params":{"type":"array","items":{"type":"string"}},"pdaParams":{"type":"array","items":{"type":"string"}},"pdaInterface":{"type":"object","properties":{"offset":{"type":"number"},"fields":{"type":"object"}},"required":["offset","fields"],"additionalProperties":false},"pdaKey":{"type":"string"},"chain":{"enum":["solana","solanaDevnet","solanaTestnet"]},"returnValueTest":{"type":"object","properties":{"key":{"type":"string"},"comparator":{"enum":["contains","=",">",">=","<","<="]},"value":{"type":"string"}},"required":["comparator","value","key"],"additionalProperties":false}},"required":["method","params","chain","pdaInterface","pdaKey","returnValueTest"],"additionalProperties":false});}),
"[project]/node_modules/@lit-protocol/accs-schemas/cjs/schemas/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.loadSchema = void 0;
async function loadSchema(schemaName) {
    switch(schemaName){
        case 'LPACC_ATOM':
            return Promise.resolve().then(()=>__importStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/accs-schemas/cjs/schemas/LPACC_ATOM.json (json)")));
        case 'LPACC_EVM_BASIC':
            return Promise.resolve().then(()=>__importStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/accs-schemas/cjs/schemas/LPACC_EVM_BASIC.json (json)")));
        case 'LPACC_EVM_CONTRACT':
            return Promise.resolve().then(()=>__importStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/accs-schemas/cjs/schemas/LPACC_EVM_CONTRACT.json (json)")));
        case 'LPACC_SOL':
            return Promise.resolve().then(()=>__importStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/accs-schemas/cjs/schemas/LPACC_SOL.json (json)")));
        default:
            throw new Error(`Unknown schema: ${schemaName}`);
    }
}
exports.loadSchema = loadSchema;
}),
"[project]/node_modules/@lit-protocol/accs-schemas/cjs/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __createBinding = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = /*TURBOPACK member replacement*/ __turbopack_context__.e && /*TURBOPACK member replacement*/ __turbopack_context__.e.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/accs-schemas/cjs/generated/index.js [app-client] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/accs-schemas/cjs/schemas/index.js [app-client] (ecmascript)"), exports);
}),
"[project]/node_modules/@lit-protocol/nacl/src/lib/nacl.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// @ts-nocheck
// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
// Public domain.
//
// Implementation derived from TweetNaCl version 20140427.
// See for details: http://tweet_nacl.cr.yp.to/
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.nacl = void 0;
var u64 = function(h, l) {
    this.hi = h | 0 >>> 0;
    this.lo = l | 0 >>> 0;
};
var gf = function(init) {
    var i, r = new Float64Array(16);
    if (init) for(i = 0; i < init.length; i++)r[i] = init[i];
    return r;
};
//  Pluggable, initialized in high-level API below.
var randombytes = function() {
    throw new Error('no PRNG');
};
var _0 = new Uint8Array(16);
var _9 = new Uint8Array(32);
_9[0] = 9;
var gf0 = gf(), gf1 = gf([
    1
]), _121665 = gf([
    0xdb41,
    1
]), D = gf([
    0x78a3,
    0x1359,
    0x4dca,
    0x75eb,
    0xd8ab,
    0x4141,
    0x0a4d,
    0x0070,
    0xe898,
    0x7779,
    0x4079,
    0x8cc7,
    0xfe73,
    0x2b6f,
    0x6cee,
    0x5203
]), D2 = gf([
    0xf159,
    0x26b2,
    0x9b94,
    0xebd6,
    0xb156,
    0x8283,
    0x149a,
    0x00e0,
    0xd130,
    0xeef3,
    0x80f2,
    0x198e,
    0xfce7,
    0x56df,
    0xd9dc,
    0x2406
]), X = gf([
    0xd51a,
    0x8f25,
    0x2d60,
    0xc956,
    0xa7b2,
    0x9525,
    0xc760,
    0x692c,
    0xdc5c,
    0xfdd6,
    0xe231,
    0xc0a4,
    0x53fe,
    0xcd6e,
    0x36d3,
    0x2169
]), Y = gf([
    0x6658,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666,
    0x6666
]), I = gf([
    0xa0b0,
    0x4a0e,
    0x1b27,
    0xc4ee,
    0xe478,
    0xad2f,
    0x1806,
    0x2f43,
    0xd7a7,
    0x3dfb,
    0x0099,
    0x2b4d,
    0xdf0b,
    0x4fc1,
    0x2480,
    0x2b83
]);
function L32(x, c) {
    return x << c | x >>> 32 - c;
}
function ld32(x, i) {
    var u = x[i + 3] & 0xff;
    u = u << 8 | x[i + 2] & 0xff;
    u = u << 8 | x[i + 1] & 0xff;
    return u << 8 | x[i + 0] & 0xff;
}
function dl64(x, i) {
    var h = x[i] << 24 | x[i + 1] << 16 | x[i + 2] << 8 | x[i + 3];
    var l = x[i + 4] << 24 | x[i + 5] << 16 | x[i + 6] << 8 | x[i + 7];
    return new u64(h, l);
}
function st32(x, j, u) {
    var i;
    for(i = 0; i < 4; i++){
        x[j + i] = u & 255;
        u >>>= 8;
    }
}
function ts64(x, i, u) {
    x[i] = u.hi >> 24 & 0xff;
    x[i + 1] = u.hi >> 16 & 0xff;
    x[i + 2] = u.hi >> 8 & 0xff;
    x[i + 3] = u.hi & 0xff;
    x[i + 4] = u.lo >> 24 & 0xff;
    x[i + 5] = u.lo >> 16 & 0xff;
    x[i + 6] = u.lo >> 8 & 0xff;
    x[i + 7] = u.lo & 0xff;
}
function vn(x, xi, y, yi, n) {
    var i, d = 0;
    for(i = 0; i < n; i++)d |= x[xi + i] ^ y[yi + i];
    return (1 & d - 1 >>> 8) - 1;
}
function crypto_verify_16(x, xi, y, yi) {
    return vn(x, xi, y, yi, 16);
}
function crypto_verify_32(x, xi, y, yi) {
    return vn(x, xi, y, yi, 32);
}
function core(out, inp, k, c, h) {
    var w = new Uint32Array(16), x = new Uint32Array(16), y = new Uint32Array(16), t = new Uint32Array(4);
    var i, j, m;
    for(i = 0; i < 4; i++){
        x[5 * i] = ld32(c, 4 * i);
        x[1 + i] = ld32(k, 4 * i);
        x[6 + i] = ld32(inp, 4 * i);
        x[11 + i] = ld32(k, 16 + 4 * i);
    }
    for(i = 0; i < 16; i++)y[i] = x[i];
    for(i = 0; i < 20; i++){
        for(j = 0; j < 4; j++){
            for(m = 0; m < 4; m++)t[m] = x[(5 * j + 4 * m) % 16];
            t[1] ^= L32(t[0] + t[3] | 0, 7);
            t[2] ^= L32(t[1] + t[0] | 0, 9);
            t[3] ^= L32(t[2] + t[1] | 0, 13);
            t[0] ^= L32(t[3] + t[2] | 0, 18);
            for(m = 0; m < 4; m++)w[4 * j + (j + m) % 4] = t[m];
        }
        for(m = 0; m < 16; m++)x[m] = w[m];
    }
    if (h) {
        for(i = 0; i < 16; i++)x[i] = x[i] + y[i] | 0;
        for(i = 0; i < 4; i++){
            x[5 * i] = x[5 * i] - ld32(c, 4 * i) | 0;
            x[6 + i] = x[6 + i] - ld32(inp, 4 * i) | 0;
        }
        for(i = 0; i < 4; i++){
            st32(out, 4 * i, x[5 * i]);
            st32(out, 16 + 4 * i, x[6 + i]);
        }
    } else {
        for(i = 0; i < 16; i++)st32(out, 4 * i, x[i] + y[i] | 0);
    }
}
function crypto_core_salsa20(out, inp, k, c) {
    core(out, inp, k, c, false);
    return 0;
}
function crypto_core_hsalsa20(out, inp, k, c) {
    core(out, inp, k, c, true);
    return 0;
}
var sigma = new Uint8Array([
    101,
    120,
    112,
    97,
    110,
    100,
    32,
    51,
    50,
    45,
    98,
    121,
    116,
    101,
    32,
    107
]);
// "expand 32-byte k"
function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
    var z = new Uint8Array(16), x = new Uint8Array(64);
    var u, i;
    if (!b) return 0;
    for(i = 0; i < 16; i++)z[i] = 0;
    for(i = 0; i < 8; i++)z[i] = n[i];
    while(b >= 64){
        crypto_core_salsa20(x, z, k, sigma);
        for(i = 0; i < 64; i++)c[cpos + i] = (m ? m[mpos + i] : 0) ^ x[i];
        u = 1;
        for(i = 8; i < 16; i++){
            u = u + (z[i] & 0xff) | 0;
            z[i] = u & 0xff;
            u >>>= 8;
        }
        b -= 64;
        cpos += 64;
        if (m) mpos += 64;
    }
    if (b > 0) {
        crypto_core_salsa20(x, z, k, sigma);
        for(i = 0; i < b; i++)c[cpos + i] = (m ? m[mpos + i] : 0) ^ x[i];
    }
    return 0;
}
function crypto_stream_salsa20(c, cpos, d, n, k) {
    return crypto_stream_salsa20_xor(c, cpos, null, 0, d, n, k);
}
function crypto_stream(c, cpos, d, n, k) {
    var s = new Uint8Array(32);
    crypto_core_hsalsa20(s, n, k, sigma);
    return crypto_stream_salsa20(c, cpos, d, n.subarray(16), s);
}
function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
    var s = new Uint8Array(32);
    crypto_core_hsalsa20(s, n, k, sigma);
    return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, n.subarray(16), s);
}
function add1305(h, c) {
    var j, u = 0;
    for(j = 0; j < 17; j++){
        u = u + (h[j] + c[j] | 0) | 0;
        h[j] = u & 255;
        u >>>= 8;
    }
}
var minusp = new Uint32Array([
    5,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    252
]);
function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
    var s, i, j, u;
    var x = new Uint32Array(17), r = new Uint32Array(17), h = new Uint32Array(17), c = new Uint32Array(17), g = new Uint32Array(17);
    for(j = 0; j < 17; j++)r[j] = h[j] = 0;
    for(j = 0; j < 16; j++)r[j] = k[j];
    r[3] &= 15;
    r[4] &= 252;
    r[7] &= 15;
    r[8] &= 252;
    r[11] &= 15;
    r[12] &= 252;
    r[15] &= 15;
    while(n > 0){
        for(j = 0; j < 17; j++)c[j] = 0;
        for(j = 0; j < 16 && j < n; ++j)c[j] = m[mpos + j];
        c[j] = 1;
        mpos += j;
        n -= j;
        add1305(h, c);
        for(i = 0; i < 17; i++){
            x[i] = 0;
            for(j = 0; j < 17; j++)x[i] = x[i] + h[j] * (j <= i ? r[i - j] : 320 * r[i + 17 - j] | 0) | 0 | 0;
        }
        for(i = 0; i < 17; i++)h[i] = x[i];
        u = 0;
        for(j = 0; j < 16; j++){
            u = u + h[j] | 0;
            h[j] = u & 255;
            u >>>= 8;
        }
        u = u + h[16] | 0;
        h[16] = u & 3;
        u = 5 * (u >>> 2) | 0;
        for(j = 0; j < 16; j++){
            u = u + h[j] | 0;
            h[j] = u & 255;
            u >>>= 8;
        }
        u = u + h[16] | 0;
        h[16] = u;
    }
    for(j = 0; j < 17; j++)g[j] = h[j];
    add1305(h, minusp);
    s = -(h[16] >>> 7) | 0;
    for(j = 0; j < 17; j++)h[j] ^= s & (g[j] ^ h[j]);
    for(j = 0; j < 16; j++)c[j] = k[j + 16];
    c[16] = 0;
    add1305(h, c);
    for(j = 0; j < 16; j++)out[outpos + j] = h[j];
    return 0;
}
function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
    var x = new Uint8Array(16);
    crypto_onetimeauth(x, 0, m, mpos, n, k);
    return crypto_verify_16(h, hpos, x, 0);
}
function crypto_secretbox(c, m, d, n, k) {
    var i;
    if (d < 32) return -1;
    crypto_stream_xor(c, 0, m, 0, d, n, k);
    crypto_onetimeauth(c, 16, c, 32, d - 32, c);
    for(i = 0; i < 16; i++)c[i] = 0;
    return 0;
}
function crypto_secretbox_open(m, c, d, n, k) {
    var i;
    var x = new Uint8Array(32);
    if (d < 32) return -1;
    crypto_stream(x, 0, 32, n, k);
    if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0) return -1;
    crypto_stream_xor(m, 0, c, 0, d, n, k);
    for(i = 0; i < 32; i++)m[i] = 0;
    return 0;
}
function set25519(r, a) {
    var i;
    for(i = 0; i < 16; i++)r[i] = a[i] | 0;
}
function car25519(o) {
    var c;
    var i;
    for(i = 0; i < 16; i++){
        o[i] += 65536;
        c = Math.floor(o[i] / 65536);
        o[(i + 1) * (i < 15 ? 1 : 0)] += c - 1 + 37 * (c - 1) * (i === 15 ? 1 : 0);
        o[i] -= c * 65536;
    }
}
function sel25519(p, q, b) {
    var t, c = ~(b - 1);
    for(var i = 0; i < 16; i++){
        t = c & (p[i] ^ q[i]);
        p[i] ^= t;
        q[i] ^= t;
    }
}
function pack25519(o, n) {
    var i, j, b;
    var m = gf(), t = gf();
    for(i = 0; i < 16; i++)t[i] = n[i];
    car25519(t);
    car25519(t);
    car25519(t);
    for(j = 0; j < 2; j++){
        m[0] = t[0] - 0xffed;
        for(i = 1; i < 15; i++){
            m[i] = t[i] - 0xffff - (m[i - 1] >> 16 & 1);
            m[i - 1] &= 0xffff;
        }
        m[15] = t[15] - 0x7fff - (m[14] >> 16 & 1);
        b = m[15] >> 16 & 1;
        m[14] &= 0xffff;
        sel25519(t, m, 1 - b);
    }
    for(i = 0; i < 16; i++){
        o[2 * i] = t[i] & 0xff;
        o[2 * i + 1] = t[i] >> 8;
    }
}
function neq25519(a, b) {
    var c = new Uint8Array(32), d = new Uint8Array(32);
    pack25519(c, a);
    pack25519(d, b);
    return crypto_verify_32(c, 0, d, 0);
}
function par25519(a) {
    var d = new Uint8Array(32);
    pack25519(d, a);
    return d[0] & 1;
}
function unpack25519(o, n) {
    var i;
    for(i = 0; i < 16; i++)o[i] = n[2 * i] + (n[2 * i + 1] << 8);
    o[15] &= 0x7fff;
}
function A(o, a, b) {
    var i;
    for(i = 0; i < 16; i++)o[i] = a[i] + b[i] | 0;
}
function Z(o, a, b) {
    var i;
    for(i = 0; i < 16; i++)o[i] = a[i] - b[i] | 0;
}
function M(o, a, b) {
    var i, j, t = new Float64Array(31);
    for(i = 0; i < 31; i++)t[i] = 0;
    for(i = 0; i < 16; i++){
        for(j = 0; j < 16; j++){
            t[i + j] += a[i] * b[j];
        }
    }
    for(i = 0; i < 15; i++){
        t[i] += 38 * t[i + 16];
    }
    for(i = 0; i < 16; i++)o[i] = t[i];
    car25519(o);
    car25519(o);
}
function S(o, a) {
    M(o, a, a);
}
function inv25519(o, i) {
    var c = gf();
    var a;
    for(a = 0; a < 16; a++)c[a] = i[a];
    for(a = 253; a >= 0; a--){
        S(c, c);
        if (a !== 2 && a !== 4) M(c, c, i);
    }
    for(a = 0; a < 16; a++)o[a] = c[a];
}
function pow2523(o, i) {
    var c = gf();
    var a;
    for(a = 0; a < 16; a++)c[a] = i[a];
    for(a = 250; a >= 0; a--){
        S(c, c);
        if (a !== 1) M(c, c, i);
    }
    for(a = 0; a < 16; a++)o[a] = c[a];
}
function crypto_scalarmult(q, n, p) {
    var z = new Uint8Array(32);
    var x = new Float64Array(80), r, i;
    var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
    for(i = 0; i < 31; i++)z[i] = n[i];
    z[31] = n[31] & 127 | 64;
    z[0] &= 248;
    unpack25519(x, p);
    for(i = 0; i < 16; i++){
        b[i] = x[i];
        d[i] = a[i] = c[i] = 0;
    }
    a[0] = d[0] = 1;
    for(i = 254; i >= 0; --i){
        r = z[i >>> 3] >>> (i & 7) & 1;
        sel25519(a, b, r);
        sel25519(c, d, r);
        A(e, a, c);
        Z(a, a, c);
        A(c, b, d);
        Z(b, b, d);
        S(d, e);
        S(f, a);
        M(a, c, a);
        M(c, b, e);
        A(e, a, c);
        Z(a, a, c);
        S(b, a);
        Z(c, d, f);
        M(a, c, _121665);
        A(a, a, d);
        M(c, c, a);
        M(a, d, f);
        M(d, b, x);
        S(b, e);
        sel25519(a, b, r);
        sel25519(c, d, r);
    }
    for(i = 0; i < 16; i++){
        x[i + 16] = a[i];
        x[i + 32] = c[i];
        x[i + 48] = b[i];
        x[i + 64] = d[i];
    }
    var x32 = x.subarray(32);
    var x16 = x.subarray(16);
    inv25519(x32, x32);
    M(x16, x16, x32);
    pack25519(q, x16);
    return 0;
}
function crypto_scalarmult_base(q, n) {
    return crypto_scalarmult(q, n, _9);
}
function crypto_box_keypair(y, x) {
    randombytes(x, 32);
    return crypto_scalarmult_base(y, x);
}
function crypto_box_beforenm(k, y, x) {
    var s = new Uint8Array(32);
    crypto_scalarmult(s, x, y);
    return crypto_core_hsalsa20(k, _0, s, sigma);
}
var crypto_box_afternm = crypto_secretbox;
var crypto_box_open_afternm = crypto_secretbox_open;
function crypto_box(c, m, d, n, y, x) {
    var k = new Uint8Array(32);
    crypto_box_beforenm(k, y, x);
    return crypto_box_afternm(c, m, d, n, k);
}
function crypto_box_open(m, c, d, n, y, x) {
    var k = new Uint8Array(32);
    crypto_box_beforenm(k, y, x);
    return crypto_box_open_afternm(m, c, d, n, k);
}
function add64() {
    var a = 0, b = 0, c = 0, d = 0, m16 = 65535, l, h, i;
    for(i = 0; i < arguments.length; i++){
        l = arguments[i].lo;
        h = arguments[i].hi;
        a += l & m16;
        b += l >>> 16;
        c += h & m16;
        d += h >>> 16;
    }
    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;
    return new u64(c & m16 | d << 16, a & m16 | b << 16);
}
function shr64(x, c) {
    return new u64(x.hi >>> c, x.lo >>> c | x.hi << 32 - c);
}
function xor64() {
    var l = 0, h = 0, i;
    for(i = 0; i < arguments.length; i++){
        l ^= arguments[i].lo;
        h ^= arguments[i].hi;
    }
    return new u64(h, l);
}
function R(x, c) {
    var h, l, c1 = 32 - c;
    if (c < 32) {
        h = x.hi >>> c | x.lo << c1;
        l = x.lo >>> c | x.hi << c1;
    } else if (c < 64) {
        h = x.lo >>> c | x.hi << c1;
        l = x.hi >>> c | x.lo << c1;
    }
    return new u64(h, l);
}
function Ch(x, y, z) {
    var h = x.hi & y.hi ^ ~x.hi & z.hi, l = x.lo & y.lo ^ ~x.lo & z.lo;
    return new u64(h, l);
}
function Maj(x, y, z) {
    var h = x.hi & y.hi ^ x.hi & z.hi ^ y.hi & z.hi, l = x.lo & y.lo ^ x.lo & z.lo ^ y.lo & z.lo;
    return new u64(h, l);
}
function Sigma0(x) {
    return xor64(R(x, 28), R(x, 34), R(x, 39));
}
function Sigma1(x) {
    return xor64(R(x, 14), R(x, 18), R(x, 41));
}
function sigma0(x) {
    return xor64(R(x, 1), R(x, 8), shr64(x, 7));
}
function sigma1(x) {
    return xor64(R(x, 19), R(x, 61), shr64(x, 6));
}
var K = [
    new u64(0x428a2f98, 0xd728ae22),
    new u64(0x71374491, 0x23ef65cd),
    new u64(0xb5c0fbcf, 0xec4d3b2f),
    new u64(0xe9b5dba5, 0x8189dbbc),
    new u64(0x3956c25b, 0xf348b538),
    new u64(0x59f111f1, 0xb605d019),
    new u64(0x923f82a4, 0xaf194f9b),
    new u64(0xab1c5ed5, 0xda6d8118),
    new u64(0xd807aa98, 0xa3030242),
    new u64(0x12835b01, 0x45706fbe),
    new u64(0x243185be, 0x4ee4b28c),
    new u64(0x550c7dc3, 0xd5ffb4e2),
    new u64(0x72be5d74, 0xf27b896f),
    new u64(0x80deb1fe, 0x3b1696b1),
    new u64(0x9bdc06a7, 0x25c71235),
    new u64(0xc19bf174, 0xcf692694),
    new u64(0xe49b69c1, 0x9ef14ad2),
    new u64(0xefbe4786, 0x384f25e3),
    new u64(0x0fc19dc6, 0x8b8cd5b5),
    new u64(0x240ca1cc, 0x77ac9c65),
    new u64(0x2de92c6f, 0x592b0275),
    new u64(0x4a7484aa, 0x6ea6e483),
    new u64(0x5cb0a9dc, 0xbd41fbd4),
    new u64(0x76f988da, 0x831153b5),
    new u64(0x983e5152, 0xee66dfab),
    new u64(0xa831c66d, 0x2db43210),
    new u64(0xb00327c8, 0x98fb213f),
    new u64(0xbf597fc7, 0xbeef0ee4),
    new u64(0xc6e00bf3, 0x3da88fc2),
    new u64(0xd5a79147, 0x930aa725),
    new u64(0x06ca6351, 0xe003826f),
    new u64(0x14292967, 0x0a0e6e70),
    new u64(0x27b70a85, 0x46d22ffc),
    new u64(0x2e1b2138, 0x5c26c926),
    new u64(0x4d2c6dfc, 0x5ac42aed),
    new u64(0x53380d13, 0x9d95b3df),
    new u64(0x650a7354, 0x8baf63de),
    new u64(0x766a0abb, 0x3c77b2a8),
    new u64(0x81c2c92e, 0x47edaee6),
    new u64(0x92722c85, 0x1482353b),
    new u64(0xa2bfe8a1, 0x4cf10364),
    new u64(0xa81a664b, 0xbc423001),
    new u64(0xc24b8b70, 0xd0f89791),
    new u64(0xc76c51a3, 0x0654be30),
    new u64(0xd192e819, 0xd6ef5218),
    new u64(0xd6990624, 0x5565a910),
    new u64(0xf40e3585, 0x5771202a),
    new u64(0x106aa070, 0x32bbd1b8),
    new u64(0x19a4c116, 0xb8d2d0c8),
    new u64(0x1e376c08, 0x5141ab53),
    new u64(0x2748774c, 0xdf8eeb99),
    new u64(0x34b0bcb5, 0xe19b48a8),
    new u64(0x391c0cb3, 0xc5c95a63),
    new u64(0x4ed8aa4a, 0xe3418acb),
    new u64(0x5b9cca4f, 0x7763e373),
    new u64(0x682e6ff3, 0xd6b2b8a3),
    new u64(0x748f82ee, 0x5defb2fc),
    new u64(0x78a5636f, 0x43172f60),
    new u64(0x84c87814, 0xa1f0ab72),
    new u64(0x8cc70208, 0x1a6439ec),
    new u64(0x90befffa, 0x23631e28),
    new u64(0xa4506ceb, 0xde82bde9),
    new u64(0xbef9a3f7, 0xb2c67915),
    new u64(0xc67178f2, 0xe372532b),
    new u64(0xca273ece, 0xea26619c),
    new u64(0xd186b8c7, 0x21c0c207),
    new u64(0xeada7dd6, 0xcde0eb1e),
    new u64(0xf57d4f7f, 0xee6ed178),
    new u64(0x06f067aa, 0x72176fba),
    new u64(0x0a637dc5, 0xa2c898a6),
    new u64(0x113f9804, 0xbef90dae),
    new u64(0x1b710b35, 0x131c471b),
    new u64(0x28db77f5, 0x23047d84),
    new u64(0x32caab7b, 0x40c72493),
    new u64(0x3c9ebe0a, 0x15c9bebc),
    new u64(0x431d67c4, 0x9c100d4c),
    new u64(0x4cc5d4be, 0xcb3e42b6),
    new u64(0x597f299c, 0xfc657e2a),
    new u64(0x5fcb6fab, 0x3ad6faec),
    new u64(0x6c44198c, 0x4a475817)
];
function crypto_hashblocks(x, m, n) {
    var z = [], b = [], a = [], w = [], t, i, j;
    for(i = 0; i < 8; i++)z[i] = a[i] = dl64(x, 8 * i);
    var pos = 0;
    while(n >= 128){
        for(i = 0; i < 16; i++)w[i] = dl64(m, 8 * i + pos);
        for(i = 0; i < 80; i++){
            for(j = 0; j < 8; j++)b[j] = a[j];
            t = add64(a[7], Sigma1(a[4]), Ch(a[4], a[5], a[6]), K[i], w[i % 16]);
            b[7] = add64(t, Sigma0(a[0]), Maj(a[0], a[1], a[2]));
            b[3] = add64(b[3], t);
            for(j = 0; j < 8; j++)a[(j + 1) % 8] = b[j];
            if (i % 16 === 15) {
                for(j = 0; j < 16; j++){
                    w[j] = add64(w[j], w[(j + 9) % 16], sigma0(w[(j + 1) % 16]), sigma1(w[(j + 14) % 16]));
                }
            }
        }
        for(i = 0; i < 8; i++){
            a[i] = add64(a[i], z[i]);
            z[i] = a[i];
        }
        pos += 128;
        n -= 128;
    }
    for(i = 0; i < 8; i++)ts64(x, 8 * i, z[i]);
    return n;
}
var iv = new Uint8Array([
    0x6a,
    0x09,
    0xe6,
    0x67,
    0xf3,
    0xbc,
    0xc9,
    0x08,
    0xbb,
    0x67,
    0xae,
    0x85,
    0x84,
    0xca,
    0xa7,
    0x3b,
    0x3c,
    0x6e,
    0xf3,
    0x72,
    0xfe,
    0x94,
    0xf8,
    0x2b,
    0xa5,
    0x4f,
    0xf5,
    0x3a,
    0x5f,
    0x1d,
    0x36,
    0xf1,
    0x51,
    0x0e,
    0x52,
    0x7f,
    0xad,
    0xe6,
    0x82,
    0xd1,
    0x9b,
    0x05,
    0x68,
    0x8c,
    0x2b,
    0x3e,
    0x6c,
    0x1f,
    0x1f,
    0x83,
    0xd9,
    0xab,
    0xfb,
    0x41,
    0xbd,
    0x6b,
    0x5b,
    0xe0,
    0xcd,
    0x19,
    0x13,
    0x7e,
    0x21,
    0x79
]);
function crypto_hash(out, m, n) {
    var h = new Uint8Array(64), x = new Uint8Array(256);
    var i, b = n;
    for(i = 0; i < 64; i++)h[i] = iv[i];
    crypto_hashblocks(h, m, n);
    n %= 128;
    for(i = 0; i < 256; i++)x[i] = 0;
    for(i = 0; i < n; i++)x[i] = m[b - n + i];
    x[n] = 128;
    n = 256 - 128 * (n < 112 ? 1 : 0);
    x[n - 9] = 0;
    ts64(x, n - 8, new u64(b / 0x20000000 | 0, b << 3));
    crypto_hashblocks(h, x, n);
    for(i = 0; i < 64; i++)out[i] = h[i];
    return 0;
}
function add(p, q) {
    var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
    Z(a, p[1], p[0]);
    Z(t, q[1], q[0]);
    M(a, a, t);
    A(b, p[0], p[1]);
    A(t, q[0], q[1]);
    M(b, b, t);
    M(c, p[3], q[3]);
    M(c, c, D2);
    M(d, p[2], q[2]);
    A(d, d, d);
    Z(e, b, a);
    Z(f, d, c);
    A(g, d, c);
    A(h, b, a);
    M(p[0], e, f);
    M(p[1], h, g);
    M(p[2], g, f);
    M(p[3], e, h);
}
function cswap(p, q, b) {
    var i;
    for(i = 0; i < 4; i++){
        sel25519(p[i], q[i], b);
    }
}
function pack(r, p) {
    var tx = gf(), ty = gf(), zi = gf();
    inv25519(zi, p[2]);
    M(tx, p[0], zi);
    M(ty, p[1], zi);
    pack25519(r, ty);
    r[31] ^= par25519(tx) << 7;
}
function scalarmult(p, q, s) {
    var b, i;
    set25519(p[0], gf0);
    set25519(p[1], gf1);
    set25519(p[2], gf1);
    set25519(p[3], gf0);
    for(i = 255; i >= 0; --i){
        b = s[i / 8 | 0] >> (i & 7) & 1;
        cswap(p, q, b);
        add(q, p);
        add(p, p);
        cswap(p, q, b);
    }
}
function scalarbase(p, s) {
    var q = [
        gf(),
        gf(),
        gf(),
        gf()
    ];
    set25519(q[0], X);
    set25519(q[1], Y);
    set25519(q[2], gf1);
    M(q[3], X, Y);
    scalarmult(p, q, s);
}
function crypto_sign_keypair(pk, sk, seeded) {
    var d = new Uint8Array(64);
    var p = [
        gf(),
        gf(),
        gf(),
        gf()
    ];
    var i;
    if (!seeded) randombytes(sk, 32);
    crypto_hash(d, sk, 32);
    d[0] &= 248;
    d[31] &= 127;
    d[31] |= 64;
    scalarbase(p, d);
    pack(pk, p);
    for(i = 0; i < 32; i++)sk[i + 32] = pk[i];
    return 0;
}
var L = new Float64Array([
    0xed,
    0xd3,
    0xf5,
    0x5c,
    0x1a,
    0x63,
    0x12,
    0x58,
    0xd6,
    0x9c,
    0xf7,
    0xa2,
    0xde,
    0xf9,
    0xde,
    0x14,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0x10
]);
function modL(r, x) {
    var carry, i, j, k;
    for(i = 63; i >= 32; --i){
        carry = 0;
        for(j = i - 32, k = i - 12; j < k; ++j){
            x[j] += carry - 16 * x[i] * L[j - (i - 32)];
            carry = Math.floor((x[j] + 128) / 256);
            x[j] -= carry * 256;
        }
        x[j] += carry;
        x[i] = 0;
    }
    carry = 0;
    for(j = 0; j < 32; j++){
        x[j] += carry - (x[31] >> 4) * L[j];
        carry = x[j] >> 8;
        x[j] &= 255;
    }
    for(j = 0; j < 32; j++)x[j] -= carry * L[j];
    for(i = 0; i < 32; i++){
        x[i + 1] += x[i] >> 8;
        r[i] = x[i] & 255;
    }
}
function reduce(r) {
    var x = new Float64Array(64), i;
    for(i = 0; i < 64; i++)x[i] = r[i];
    for(i = 0; i < 64; i++)r[i] = 0;
    modL(r, x);
}
// Note: difference from C - smlen returned, not passed as argument.
function crypto_sign(sm, m, n, sk) {
    var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
    var i, j, x = new Float64Array(64);
    var p = [
        gf(),
        gf(),
        gf(),
        gf()
    ];
    crypto_hash(d, sk, 32);
    d[0] &= 248;
    d[31] &= 127;
    d[31] |= 64;
    var smlen = n + 64;
    for(i = 0; i < n; i++)sm[64 + i] = m[i];
    for(i = 0; i < 32; i++)sm[32 + i] = d[32 + i];
    crypto_hash(r, sm.subarray(32), n + 32);
    reduce(r);
    scalarbase(p, r);
    pack(sm, p);
    for(i = 32; i < 64; i++)sm[i] = sk[i];
    crypto_hash(h, sm, n + 64);
    reduce(h);
    for(i = 0; i < 64; i++)x[i] = 0;
    for(i = 0; i < 32; i++)x[i] = r[i];
    for(i = 0; i < 32; i++){
        for(j = 0; j < 32; j++){
            x[i + j] += h[i] * d[j];
        }
    }
    modL(sm.subarray(32), x);
    return smlen;
}
function unpackneg(r, p) {
    var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
    set25519(r[2], gf1);
    unpack25519(r[1], p);
    S(num, r[1]);
    M(den, num, D);
    Z(num, num, r[2]);
    A(den, r[2], den);
    S(den2, den);
    S(den4, den2);
    M(den6, den4, den2);
    M(t, den6, num);
    M(t, t, den);
    pow2523(t, t);
    M(t, t, num);
    M(t, t, den);
    M(t, t, den);
    M(r[0], t, den);
    S(chk, r[0]);
    M(chk, chk, den);
    if (neq25519(chk, num)) M(r[0], r[0], I);
    S(chk, r[0]);
    M(chk, chk, den);
    if (neq25519(chk, num)) return -1;
    if (par25519(r[0]) === p[31] >> 7) Z(r[0], gf0, r[0]);
    M(r[3], r[0], r[1]);
    return 0;
}
function crypto_sign_open(m, sm, n, pk) {
    var i;
    var t = new Uint8Array(32), h = new Uint8Array(64);
    var p = [
        gf(),
        gf(),
        gf(),
        gf()
    ], q = [
        gf(),
        gf(),
        gf(),
        gf()
    ];
    if (n < 64) return -1;
    if (unpackneg(q, pk)) return -1;
    for(i = 0; i < n; i++)m[i] = sm[i];
    for(i = 0; i < 32; i++)m[i + 32] = pk[i];
    crypto_hash(h, m, n);
    reduce(h);
    scalarmult(p, q, h);
    scalarbase(q, sm.subarray(32));
    add(p, q);
    pack(t, p);
    n -= 64;
    if (crypto_verify_32(sm, 0, t, 0)) {
        for(i = 0; i < n; i++)m[i] = 0;
        return -1;
    }
    for(i = 0; i < n; i++)m[i] = sm[i + 64];
    return n;
}
var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
var _nacl = {
    lowlevel: {}
};
_nacl.lowlevel = {
    crypto_core_hsalsa20: crypto_core_hsalsa20,
    crypto_stream_xor: crypto_stream_xor,
    crypto_stream: crypto_stream,
    crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,
    crypto_stream_salsa20: crypto_stream_salsa20,
    crypto_onetimeauth: crypto_onetimeauth,
    crypto_onetimeauth_verify: crypto_onetimeauth_verify,
    crypto_verify_16: crypto_verify_16,
    crypto_verify_32: crypto_verify_32,
    crypto_secretbox: crypto_secretbox,
    crypto_secretbox_open: crypto_secretbox_open,
    crypto_scalarmult: crypto_scalarmult,
    crypto_scalarmult_base: crypto_scalarmult_base,
    crypto_box_beforenm: crypto_box_beforenm,
    crypto_box_afternm: crypto_box_afternm,
    crypto_box: crypto_box,
    crypto_box_open: crypto_box_open,
    crypto_box_keypair: crypto_box_keypair,
    crypto_hash: crypto_hash,
    crypto_sign: crypto_sign,
    crypto_sign_keypair: crypto_sign_keypair,
    crypto_sign_open: crypto_sign_open,
    crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,
    crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,
    crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,
    crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,
    crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,
    crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,
    crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,
    crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,
    crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,
    crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,
    crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,
    crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,
    crypto_sign_BYTES: crypto_sign_BYTES,
    crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,
    crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,
    crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,
    crypto_hash_BYTES: crypto_hash_BYTES,
    gf: gf,
    D: D,
    L: L,
    pack25519: pack25519,
    unpack25519: unpack25519,
    M: M,
    A: A,
    S: S,
    Z: Z,
    pow2523: pow2523,
    add: add,
    set25519: set25519,
    modL: modL,
    scalarmult: scalarmult,
    scalarbase: scalarbase
};
/* High-level API */ function checkLengths(k, n) {
    if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');
    if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');
}
function checkBoxLengths(pk, sk) {
    if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');
    if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
}
function checkArrayTypes() {
    for(var i = 0; i < arguments.length; i++){
        if (!(arguments[i] instanceof Uint8Array)) throw new TypeError('unexpected type, use Uint8Array');
    }
}
function cleanup(arr) {
    for(var i = 0; i < arr.length; i++)arr[i] = 0;
}
_nacl.randomBytes = function(n) {
    var b = new Uint8Array(n);
    randombytes(b, n);
    return b;
};
_nacl.secretbox = function(msg, nonce, key) {
    checkArrayTypes(msg, nonce, key);
    checkLengths(key, nonce);
    var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
    var c = new Uint8Array(m.length);
    for(var i = 0; i < msg.length; i++)m[i + crypto_secretbox_ZEROBYTES] = msg[i];
    crypto_secretbox(c, m, m.length, nonce, key);
    return c.subarray(crypto_secretbox_BOXZEROBYTES);
};
_nacl.secretbox.open = function(box, nonce, key) {
    checkArrayTypes(box, nonce, key);
    checkLengths(key, nonce);
    var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
    var m = new Uint8Array(c.length);
    for(var i = 0; i < box.length; i++)c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
    if (c.length < 32) return null;
    if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;
    return m.subarray(crypto_secretbox_ZEROBYTES);
};
_nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
_nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
_nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
_nacl.scalarMult = function(n, p) {
    checkArrayTypes(n, p);
    if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
    if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');
    var q = new Uint8Array(crypto_scalarmult_BYTES);
    crypto_scalarmult(q, n, p);
    return q;
};
_nacl.scalarMult.base = function(n) {
    checkArrayTypes(n);
    if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
    var q = new Uint8Array(crypto_scalarmult_BYTES);
    crypto_scalarmult_base(q, n);
    return q;
};
_nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
_nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
_nacl.box = function(msg, nonce, publicKey, secretKey) {
    var k = _nacl.box.before(publicKey, secretKey);
    return _nacl.secretbox(msg, nonce, k);
};
_nacl.box.before = function(publicKey, secretKey) {
    checkArrayTypes(publicKey, secretKey);
    checkBoxLengths(publicKey, secretKey);
    var k = new Uint8Array(crypto_box_BEFORENMBYTES);
    crypto_box_beforenm(k, publicKey, secretKey);
    return k;
};
_nacl.box.after = _nacl.secretbox;
_nacl.box.open = function(msg, nonce, publicKey, secretKey) {
    var k = _nacl.box.before(publicKey, secretKey);
    return _nacl.secretbox.open(msg, nonce, k);
};
_nacl.box.open.after = _nacl.secretbox.open;
_nacl.box.keyPair = function() {
    var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
    var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
    crypto_box_keypair(pk, sk);
    return {
        publicKey: pk,
        secretKey: sk
    };
};
_nacl.box.keyPair.fromSecretKey = function(secretKey) {
    checkArrayTypes(secretKey);
    if (secretKey.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
    var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
    crypto_scalarmult_base(pk, secretKey);
    return {
        publicKey: pk,
        secretKey: new Uint8Array(secretKey)
    };
};
_nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
_nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
_nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
_nacl.box.nonceLength = crypto_box_NONCEBYTES;
_nacl.box.overheadLength = _nacl.secretbox.overheadLength;
_nacl.sign = function(msg, secretKey) {
    checkArrayTypes(msg, secretKey);
    if (secretKey.length !== crypto_sign_SECRETKEYBYTES) throw new Error('bad secret key size');
    var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
    crypto_sign(signedMsg, msg, msg.length, secretKey);
    return signedMsg;
};
_nacl.sign.open = function(signedMsg, publicKey) {
    checkArrayTypes(signedMsg, publicKey);
    if (publicKey.length !== crypto_sign_PUBLICKEYBYTES) throw new Error('bad public key size');
    var tmp = new Uint8Array(signedMsg.length);
    var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
    if (mlen < 0) return null;
    var m = new Uint8Array(mlen);
    for(var i = 0; i < m.length; i++)m[i] = tmp[i];
    return m;
};
_nacl.sign.detached = function(msg, secretKey) {
    var signedMsg = _nacl.sign(msg, secretKey);
    var sig = new Uint8Array(crypto_sign_BYTES);
    for(var i = 0; i < sig.length; i++)sig[i] = signedMsg[i];
    return sig;
};
_nacl.sign.detached.verify = function(msg, sig, publicKey) {
    checkArrayTypes(msg, sig, publicKey);
    if (sig.length !== crypto_sign_BYTES) throw new Error('bad signature size');
    if (publicKey.length !== crypto_sign_PUBLICKEYBYTES) throw new Error('bad public key size');
    var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
    var m = new Uint8Array(crypto_sign_BYTES + msg.length);
    var i;
    for(i = 0; i < crypto_sign_BYTES; i++)sm[i] = sig[i];
    for(i = 0; i < msg.length; i++)sm[i + crypto_sign_BYTES] = msg[i];
    return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
};
_nacl.sign.keyPair = function() {
    var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
    var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
    crypto_sign_keypair(pk, sk);
    return {
        publicKey: pk,
        secretKey: sk
    };
};
_nacl.sign.keyPair.fromSecretKey = function(secretKey) {
    checkArrayTypes(secretKey);
    if (secretKey.length !== crypto_sign_SECRETKEYBYTES) throw new Error('bad secret key size');
    var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
    for(var i = 0; i < pk.length; i++)pk[i] = secretKey[32 + i];
    return {
        publicKey: pk,
        secretKey: new Uint8Array(secretKey)
    };
};
_nacl.sign.keyPair.fromSeed = function(seed) {
    checkArrayTypes(seed);
    if (seed.length !== crypto_sign_SEEDBYTES) throw new Error('bad seed size');
    var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
    var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
    for(var i = 0; i < 32; i++)sk[i] = seed[i];
    crypto_sign_keypair(pk, sk, true);
    return {
        publicKey: pk,
        secretKey: sk
    };
};
_nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
_nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
_nacl.sign.seedLength = crypto_sign_SEEDBYTES;
_nacl.sign.signatureLength = crypto_sign_BYTES;
_nacl.hash = function(msg) {
    checkArrayTypes(msg);
    var h = new Uint8Array(crypto_hash_BYTES);
    crypto_hash(h, msg, msg.length);
    return h;
};
_nacl.hash.hashLength = crypto_hash_BYTES;
_nacl.verify = function(x, y) {
    checkArrayTypes(x, y);
    // Zero length arguments are considered not equal.
    if (x.length === 0 || y.length === 0) return false;
    if (x.length !== y.length) return false;
    return vn(x, 0, y, 0, x.length) === 0 ? true : false;
};
_nacl.setPRNG = function(fn) {
    randombytes = fn;
};
(function() {
    // Initialize PRNG if environment provides CSPRNG.
    // If not, methods calling randombytes will throw.
    var crypto = typeof self !== 'undefined' ? self.crypto || self.msCrypto : null;
    if (crypto && crypto.getRandomValues) {
        // Browsers.
        var QUOTA = 65536;
        _nacl.setPRNG(function(x, n) {
            var i, v = new Uint8Array(n);
            for(i = 0; i < n; i += QUOTA){
                crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
            }
            for(i = 0; i < n; i++)x[i] = v[i];
            cleanup(v);
        });
    } else if ("TURBOPACK compile-time truthy", 1) {
        crypto = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/crypto-browserify/index.js [app-client] (ecmascript)");
        if (crypto && crypto.randomBytes) {
            _nacl.setPRNG(function(x, n) {
                var i, v = crypto.randomBytes(n);
                for(i = 0; i < n; i++)x[i] = v[i];
                cleanup(v);
            });
        }
    }
})();
exports.nacl = _nacl.default || _nacl; //# sourceMappingURL=nacl.js.map
}),
"[project]/node_modules/@lit-protocol/nacl/src/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
const tslib_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/nacl/node_modules/tslib/tslib.es6.js [app-client] (ecmascript)");
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/nacl/src/lib/nacl.js [app-client] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@lit-protocol/crypto/src/lib/crypto.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.checkSevSnpAttestation = exports.generateSessionKeyPair = exports.computeHDPubKey = exports.combineEcdsaShares = exports.verifySignature = exports.combineSignatureShares = exports.verifyAndDecryptWithSignatureShares = exports.decryptWithSignatureShares = exports.encrypt = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib/utils.js [app-client] (ecmascript)");
const constants_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/crypto/node_modules/@lit-protocol/constants/src/index.js [app-client] (ecmascript)");
const misc_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/misc/src/index.js [app-client] (ecmascript)");
const nacl_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/nacl/src/index.js [app-client] (ecmascript)");
const uint8arrays_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/uint8arrays/src/index.js [app-client] (ecmascript)");
const wasm_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/wasm/src/index.js [app-client] (ecmascript)");
/** ---------- Exports ---------- */ const LIT_CORS_PROXY = `https://cors.litgateway.com`;
/**
 * Encrypt data with a BLS public key.
 * We are using G1 for encryption and G2 for signatures
 *
 * @param publicKeyHex hex-encoded string of the BLS public key to encrypt with
 * @param message Uint8Array of the data to encrypt
 * @param identity Uint8Array of the identity parameter used during encryption
 * @returns base64 encoded string of the ciphertext
 */ const encrypt = async (publicKeyHex, message, identity)=>{
    const publicKey = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(publicKeyHex, 'hex');
    /**
     * Our system uses BLS12-381 on the G1 curve for encryption.
     * However, on the SDK side (this function), we expect the public key
     * to use the G2 curve for signature purposes, hence the switch on public key length.
     *
     * The G2 curve, `Bls12381G2`, is typically associated with signature generation/verification,
     * while G1 is associated with encryption. Here, the length of the public key determines how
     * we handle the encryption and the format of the returned encrypted message.
     */ if (publicKeyHex.replace('0x', '').length !== 96) {
        throw new constants_1.InvalidParamType({
            info: {
                publicKeyHex
            }
        }, `Invalid public key length. Expecting 96 characters, got ${publicKeyHex.replace('0x', '').length} instead.`);
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(await (0, wasm_1.blsEncrypt)('Bls12381G2', publicKey, message, identity)).toString('base64');
};
exports.encrypt = encrypt;
/**
 * Decrypt ciphertext using BLS signature shares.
 *
 * @param ciphertextBase64 base64-encoded string of the ciphertext to decrypt
 * @param shares hex-encoded array of the BLS signature shares
 * @returns Uint8Array of the decrypted data
 */ const decryptWithSignatureShares = async (ciphertextBase64, shares)=>{
    const signature = await doCombineSignatureShares(shares);
    return doDecrypt(ciphertextBase64, signature);
};
exports.decryptWithSignatureShares = decryptWithSignatureShares;
/**
 * Verify and decrypt ciphertext using BLS signature shares.
 *
 * @param publicKeyHex hex-encoded string of the BLS public key to verify with
 * @param identity Uint8Array of the identity parameter used during encryption
 * @param ciphertextBase64 base64-encoded string of the ciphertext to decrypt
 * @param shares hex-encoded array of the BLS signature shares
 * @returns base64-encoded string of the decrypted data
 */ const verifyAndDecryptWithSignatureShares = async (publicKeyHex, identity, ciphertextBase64, shares)=>{
    const publicKey = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(publicKeyHex, 'hex');
    const signature = await doCombineSignatureShares(shares);
    await (0, wasm_1.blsVerify)('Bls12381G2', publicKey, identity, signature);
    return doDecrypt(ciphertextBase64, signature);
};
exports.verifyAndDecryptWithSignatureShares = verifyAndDecryptWithSignatureShares;
/**
 * Combine BLS signature shares.
 *
 * @param shares hex-encoded array of the BLS signature shares
 * @returns hex-encoded string of the combined signature
 */ const combineSignatureShares = async (shares)=>{
    const signature = await doCombineSignatureShares(shares);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(signature).toString('hex');
};
exports.combineSignatureShares = combineSignatureShares;
/**
 * Verify the BLS network signature.
 *
 * @param publicKeyHex hex-encoded string of the BLS public key to verify with.
 * @param message Uint8Array of the message to verify.
 * @param signature Uint8Array of the signature to verify.
 */ const verifySignature = async (publicKeyHex, message, signature)=>{
    const publicKey = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(publicKeyHex, 'hex');
    await (0, wasm_1.blsVerify)('Bls12381G2', publicKey, message, signature);
};
exports.verifySignature = verifySignature;
// export interface EcdsaSignatureShare {
//   sigType: SIGTYPE;
//   signatureShare: string;
//   shareIndex: number; // ignored
//   publicKey: string;
//   dataSigned: string;
//   bigR: string;
//   sigName: string; // ignored
// }
const ecdsaSigntureTypeMap = {
    [constants_1.LIT_CURVE.EcdsaCaitSith]: 'K256',
    [constants_1.LIT_CURVE.EcdsaK256]: 'K256',
    [constants_1.LIT_CURVE.EcdsaCAITSITHP256]: 'P256'
};
/**
 *
 * Combine ECDSA Shares
 *
 * @param { Array<SigShare> } sigShares
 *
 * @returns { any }
 *
 */ const combineEcdsaShares = async (sigShares)=>{
    const validShares = sigShares.filter((share)=>share.signatureShare);
    const anyValidShare = validShares[0];
    if (!anyValidShare) {
        throw new constants_1.NoValidShares({
            info: {
                shares: sigShares
            }
        }, 'No valid shares to combine');
    }
    const variant = ecdsaSigntureTypeMap[anyValidShare.sigType];
    const presignature = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(anyValidShare.bigR, 'hex');
    const signatureShares = validShares.map((share)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(share.signatureShare, 'hex'));
    const [r, s, recId] = await (0, wasm_1.ecdsaCombine)(variant, presignature, signatureShares);
    const publicKey = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(anyValidShare.publicKey, 'hex');
    const messageHash = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(anyValidShare.dataSigned, 'hex');
    await (0, wasm_1.ecdsaVerify)(variant, messageHash, publicKey, [
        r,
        s,
        recId
    ]);
    const signature = (0, utils_1.splitSignature)(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].concat([
        r,
        s,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from([
            recId + 27
        ])
    ]));
    return {
        r: signature.r.slice('0x'.length),
        s: signature.s.slice('0x'.length),
        recid: signature.recoveryParam
    };
};
exports.combineEcdsaShares = combineEcdsaShares;
const computeHDPubKey = async (pubkeys, keyId, sigType)=>{
    const variant = ecdsaSigntureTypeMap[sigType];
    switch(sigType){
        case constants_1.LIT_CURVE.EcdsaCaitSith:
        case constants_1.LIT_CURVE.EcdsaK256:
            // a bit of pre processing to remove characters which will cause our wasm module to reject the values.
            pubkeys = pubkeys.map((value)=>{
                return value.replace('0x', '');
            });
            keyId = keyId.replace('0x', '');
            const preComputedPubkey = await (0, wasm_1.ecdsaDeriveKey)(variant, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(keyId, 'hex'), pubkeys.map((hex)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(hex, 'hex')));
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(preComputedPubkey).toString('hex');
        default:
            throw new constants_1.InvalidParamType({
                info: {
                    sigType
                }
            }, `Non supported signature type`);
    }
};
exports.computeHDPubKey = computeHDPubKey;
/**
 *
 * Generate a session key pair
 *
 * @returns { SessionKeyPair } sessionKeyPair
 */ const generateSessionKeyPair = ()=>{
    const keyPair = nacl_1.nacl.sign.keyPair();
    const sessionKeyPair = {
        publicKey: (0, uint8arrays_1.uint8arrayToString)(keyPair.publicKey, 'base16'),
        secretKey: (0, uint8arrays_1.uint8arrayToString)(keyPair.secretKey, 'base16')
    };
    return sessionKeyPair;
};
exports.generateSessionKeyPair = generateSessionKeyPair;
function doDecrypt(ciphertextBase64, signature) {
    console.log('signature from encrypt op: ', signature);
    const ciphertext = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(ciphertextBase64, 'base64');
    return (0, wasm_1.blsDecrypt)('Bls12381G2', ciphertext, signature);
}
function doCombineSignatureShares(shares) {
    const sigShares = shares.map((s)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(s.ProofOfPossession, 'hex'));
    const signature = (0, wasm_1.blsCombine)('Bls12381G2', sigShares);
    return signature;
}
/**
 * Asynchronously fetches an AMD certification from a specified URL using a CORS proxy.
 * The primary purpose of using a CORS proxy is to avoid being rate-limited by AMD.
 * The function attempts to fetch the AMD cert through a proxy, and if the proxy fetch fails,
 * it retries directly from the original URL.
 *
 * Note: This project is hosted on heroku and uses this codebase: https://github.com/LIT-Protocol/cors-proxy-amd
 *
 * @param url The URL from which to fetch the AMD cert.
 * @returns A Promise that resolves to a Uint8Array containing the AMD certification data.
 * @throws An error detailing HTTP or network issues encountered during the fetch process.
 */ async function getAmdCert(url) {
    const proxyUrl = `${LIT_CORS_PROXY}/${url}`;
    (0, misc_1.log)(`[getAmdCert] Fetching AMD cert using proxy URL ${proxyUrl} to manage CORS restrictions and to avoid being rate limited by AMD.`);
    async function fetchAsUint8Array(targetUrl) {
        const res = await fetch(targetUrl);
        if (!res.ok) {
            throw new constants_1.NetworkError({
                info: {
                    targetUrl
                }
            }, `[getAmdCert] HTTP error! status: ${res.status}`);
        }
        const arrayBuffer = await res.arrayBuffer();
        return new Uint8Array(arrayBuffer);
    }
    try {
        return await fetchAsUint8Array(proxyUrl);
    } catch (e) {
        (0, misc_1.log)(`[getAmdCert] Failed to fetch AMD cert from proxy:`, e);
    }
    // Try direct fetch only if proxy fails
    (0, misc_1.log)('[getAmdCert] Attempting to fetch directly without proxy.');
    try {
        return await fetchAsUint8Array(url);
    } catch (e) {
        (0, misc_1.log)('[getAmdCert] Direct fetch also failed:', e);
        throw e; // Re-throw to signal that both methods failed
    }
}
/**
 *
 * Check the attestation against AMD certs
 *
 * @param { NodeAttestation } attestation The actual attestation object, which includes the signature and report
 * @param { string } challengeHex The challenge we sent
 * @param { string } url The URL we talked to
 *
 * @returns { Promise<undefined> } A promise that throws if the attestation is invalid
 */ const checkSevSnpAttestation = async (attestation, challengeHex, url)=>{
    var _a;
    const noonce = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(attestation.noonce, 'base64');
    const challenge = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(challengeHex, 'hex');
    const data = Object.fromEntries(Object.entries(attestation.data).map(([k, v])=>[
            k,
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(v, 'base64')
        ]));
    const signatures = attestation.signatures.map((s)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(s, 'base64'));
    const report = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(attestation.report, 'base64');
    if (!noonce.equals(challenge)) {
        throw new constants_1.NetworkError({
            info: {
                attestation,
                challengeHex,
                noonce,
                challenge
            }
        }, `Attestation noonce ${noonce} does not match challenge ${challenge}`);
    }
    const parsedUrl = new URL(url);
    const ipWeTalkedTo = parsedUrl.hostname;
    let portWeTalkedTo = parsedUrl.port;
    if (portWeTalkedTo === '') {
        // if we're on HTTP or HTTPS, the port will be empty
        if (url.startsWith('https://')) {
            portWeTalkedTo = '443';
        } else if (url.startsWith('http://')) {
            portWeTalkedTo = '80';
        } else {
            throw new constants_1.NetworkError({
                info: {
                    url
                }
            }, `Unknown port in URL ${url}`);
        }
    }
    const ipAndAddrFromReport = data['EXTERNAL_ADDR'].toString('utf8');
    const ipFromReport = ipAndAddrFromReport.split(':')[0];
    const portFromReport = ipAndAddrFromReport.split(':')[1];
    if (ipWeTalkedTo !== ipFromReport) {
        throw new constants_1.NetworkError({
            info: {
                attestation,
                ipWeTalkedTo,
                ipFromReport
            }
        }, `Attestation external address ${ipFromReport} does not match IP we talked to ${ipWeTalkedTo}`);
    }
    if (portWeTalkedTo !== portFromReport) {
        throw new constants_1.NetworkError({
            info: {
                attestation,
                portWeTalkedTo,
                portFromReport
            }
        }, `Attestation external port ${portFromReport} does not match port we talked to ${portWeTalkedTo}`);
    }
    // get the VCEK certificate
    let vcekCert;
    const vcekUrl = await (0, wasm_1.sevSnpGetVcekUrl)(report);
    // use local storage if we have one available
    if (globalThis.localStorage) {
        (0, misc_1.log)('Using local storage for certificate caching');
        vcekCert = localStorage.getItem(vcekUrl);
        if (vcekCert) {
            vcekCert = (0, uint8arrays_1.uint8arrayFromString)(vcekCert, 'base64');
        } else {
            vcekCert = await getAmdCert(vcekUrl);
            localStorage.setItem(vcekUrl, (0, uint8arrays_1.uint8arrayToString)(vcekCert, 'base64'));
        }
    } else {
        const cache = (_a = globalThis).amdCertStore ?? (_a.amdCertStore = {});
        cache[vcekUrl] ?? (cache[vcekUrl] = await getAmdCert(vcekUrl));
        vcekCert = cache[vcekUrl];
    }
    if (!vcekCert || vcekCert.length === 0 || vcekCert.length < 256) {
        throw new constants_1.UnknownError({
            info: {
                attestation,
                report,
                vcekUrl
            }
        }, 'Unable to retrieve VCEK certificate from AMD');
    }
    // pass base64 encoded report to wasm wrapper
    return (0, wasm_1.sevSnpVerify)(report, data, signatures, challenge, vcekCert);
};
exports.checkSevSnpAttestation = checkSevSnpAttestation; //# sourceMappingURL=crypto.js.map
}),
"[project]/node_modules/@lit-protocol/crypto/src/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
const tslib_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/crypto/node_modules/tslib/tslib.es6.js [app-client] (ecmascript)");
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/crypto/src/lib/crypto.js [app-client] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@lit-protocol/core/src/lib/endpoint-version.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.composeLitUrl = void 0;
/**
 * Compose the Lit URL
 *
 * The schema of the routing can be found in the `constants` package in the `endpoints.ts` file, where you would be able to add new endpoint to the enum,
 * and use that enum in the LIT_ENDPOINT map.
 *
 * @param params
 * @returns the composed URL
 */ const composeLitUrl = (params)=>{
    // check if params.url is a valid URL
    try {
        new URL(params.url);
    } catch (error) {
        throw new Error(`[composeLitUrl] Invalid URL: "${params.url}"`);
    }
    const version = params.endpoint.version;
    return `${params.url}${params.endpoint.path}${version}`;
};
exports.composeLitUrl = composeLitUrl; //# sourceMappingURL=endpoint-version.js.map
}),
"[project]/node_modules/@lit-protocol/core/src/lib/lit-core.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LitCore = void 0;
const ethers_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-client] (ecmascript)");
const eventemitter3_1 = __turbopack_context__.r("[project]/node_modules/eventemitter3/index.js [app-client] (ecmascript)");
const access_control_conditions_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/access-control-conditions/src/index.js [app-client] (ecmascript)");
const constants_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/core/node_modules/@lit-protocol/constants/src/index.js [app-client] (ecmascript)");
const contracts_sdk_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/contracts-sdk/src/index.js [app-client] (ecmascript)");
const crypto_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/crypto/src/index.js [app-client] (ecmascript)");
const misc_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/misc/src/index.js [app-client] (ecmascript)");
const endpoint_version_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/core/src/lib/endpoint-version.js [app-client] (ecmascript)");
// On epoch change, we wait this many seconds for the nodes to update to the new epoch before using the new epoch #
const EPOCH_PROPAGATION_DELAY = 45000;
// This interval is responsible for keeping latest block hash up to date
const BLOCKHASH_SYNC_INTERVAL = 30000;
// When fetching the blockhash from a provider (not lit), we use a 5 minutes old block to ensure the nodes centralized indexer has it
const BLOCKHASH_COUNT_PROVIDER_DELAY = -30; // 30 blocks ago. Eth block are mined every 12s. 30 blocks is 6 minutes, indexer/nodes must have it by now
// Intentionally not including datil-dev here per discussion with Howard
const NETWORKS_REQUIRING_SEV = [
    constants_1.LIT_NETWORK.DatilTest,
    constants_1.LIT_NETWORK.Datil
];
/**
 * Lowest latency, highest score & privacy enabled listed on https://chainlist.org/
 */ const FALLBACK_RPC_URLS = [
    'https://ethereum-rpc.publicnode.com',
    'https://eth.llamarpc.com',
    'https://eth.drpc.org',
    'https://eth.llamarpc.com'
];
class LitCore extends eventemitter3_1.EventEmitter {
    // ========== Constructor ==========
    constructor(config){
        super();
        this.config = {
            alertWhenUnauthorized: false,
            debug: true,
            connectTimeout: 20000,
            checkNodeAttestation: false,
            litNetwork: constants_1.LIT_NETWORK.Custom,
            minNodeCount: 2,
            bootstrapUrls: [],
            nodeProtocol: null
        };
        this.connectedNodes = new Set();
        this.serverKeys = {};
        this.ready = false;
        this.subnetPubKey = null;
        this.networkPubKey = null;
        this.networkPubKeySet = null;
        this.hdRootPubkeys = null;
        this.latestBlockhash = null;
        this.lastBlockHashRetrieved = null;
        this._networkSyncInterval = null;
        this._stakingContract = null;
        this._stakingContractListener = null;
        this._connectingPromise = null;
        this._epochCache = {
            currentNumber: null,
            startTime: null
        };
        this._blockHashUrl = 'https://block-indexer.litgateway.com/get_most_recent_valid_block';
        // ========== Logger utilities ==========
        this.getLogsForRequestId = (id)=>{
            return globalThis.logManager.getLogsForId(id);
        };
        this.getRequestIds = ()=>{
            return globalThis.logManager.LoggerIds;
        };
        /**
         *
         * Set bootstrapUrls to match the network litNetwork unless it's set to custom
         *
         * @returns { void }
         *
         */ this.setCustomBootstrapUrls = ()=>{
            // -- validate
            if (this.config.litNetwork === constants_1.LIT_NETWORK.Custom) return;
            // -- execute
            const hasNetwork = this.config.litNetwork in constants_1.LIT_NETWORKS;
            if (!hasNetwork) {
                // network not found, report error
                throw new constants_1.LitNodeClientBadConfigError({}, 'the litNetwork specified in the LitNodeClient config not found in LIT_NETWORKS');
            }
            this.config.bootstrapUrls = constants_1.LIT_NETWORKS[this.config.litNetwork];
        };
        /**
         * Return the latest blockhash from the nodes
         * @returns { Promise<string> } latest blockhash
         */ this.getLatestBlockhash = async ()=>{
            await this._syncBlockhash();
            if (!this.latestBlockhash) {
                throw new constants_1.InvalidEthBlockhash({}, `latestBlockhash is not available. Received: "%s"`, this.latestBlockhash);
            }
            return this.latestBlockhash;
        };
        this._getProviderWithFallback = async (providerTest)=>{
            for (const url of FALLBACK_RPC_URLS){
                try {
                    const provider = new ethers_1.ethers.providers.JsonRpcProvider({
                        url: url,
                        // https://docs.ethers.org/v5/api/utils/web/#ConnectionInfo
                        timeout: 60000
                    });
                    const testResult = await providerTest(provider); // Check to see if the provider is working
                    return {
                        provider,
                        testResult
                    };
                } catch (error) {
                    (0, misc_1.logError)(`RPC URL failed: ${url}`);
                }
            }
            return null;
        };
        /**
         * Handshake with Node
         *
         * @param { HandshakeWithNode } params
         * @param { string } requestId
         * @returns { Promise<NodeCommandServerKeysResponse> }
         *
         */ this.handshakeWithNode = async (params, requestId)=>{
            // -- get properties from params
            const { url } = params;
            // -- create url with path
            const urlWithPath = (0, endpoint_version_1.composeLitUrl)({
                url,
                endpoint: constants_1.LIT_ENDPOINT.HANDSHAKE
            });
            (0, misc_1.log)(`handshakeWithNode ${urlWithPath}`);
            const data = {
                clientPublicKey: 'test',
                challenge: params.challenge
            };
            return await this.sendCommandToNode({
                url: urlWithPath,
                data,
                requestId
            });
        };
        // ==================== SENDING COMMAND ====================
        /**
         *
         * Send a command to nodes
         *
         * @param { SendNodeCommand }
         *
         * @returns { Promise<any> }
         *
         */ this.sendCommandToNode = async ({ url, data, requestId })=>{
            // FIXME: Replace <any> usage with explicit, strongly typed handlers
            data = {
                ...data,
                epoch: this.currentEpochNumber
            };
            // If there is a `sessionSigs' object in the params remove before sending the request;
            // this line has been added as a catch all to prevent sending with the request
            if (data.sessionSigs) {
                delete data.sessionSigs;
            }
            (0, misc_1.logWithRequestId)(requestId, `sendCommandToNode with url ${url} and data`, data);
            const req = {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    Accept: 'application/json',
                    'X-Lit-SDK-Version': constants_1.version,
                    'X-Lit-SDK-Type': 'Typescript',
                    'X-Request-Id': 'lit_' + requestId
                },
                body: JSON.stringify(data)
            };
            return (0, misc_1.sendRequest)(url, req, requestId);
        };
        /**
         *
         * Get and gather node promises
         *
         * @param { any } callback
         *
         * @returns { Array<Promise<any>> }
         *
         */ this.getNodePromises = (// eslint-disable-next-line @typescript-eslint/no-explicit-any
        callback)=>{
            // FIXME: Replace <any> usage with explicit, strongly typed handlers
            const nodePromises = [];
            for (const url of this.connectedNodes){
                nodePromises.push(callback(url));
            }
            return nodePromises;
        };
        /**
         * Retrieves the session signature for a given URL from the sessionSigs map.
         * Throws an error if sessionSigs is not provided or if the session signature for the URL is not found.
         *
         * @param sessionSigs - The session signatures map.
         * @param url - The URL for which to retrieve the session signature.
         * @returns The session signature for the given URL.
         * @throws An error if sessionSigs is not provided or if the session signature for the URL is not found.
         */ this.getSessionSigByUrl = ({ sessionSigs, url })=>{
            if (!sessionSigs) {
                throw new constants_1.InvalidArgumentException({}, 'You must pass in sessionSigs. Received: %s', sessionSigs);
            }
            const sigToPassToNode = sessionSigs[url];
            if (!sessionSigs[url]) {
                throw new constants_1.InvalidArgumentException({}, 'You passed sessionSigs but we could not find session sig for node %s', url);
            }
            return sigToPassToNode;
        };
        this.validateAccessControlConditionsSchema = async (params)=>{
            // ========== Prepare Params ==========
            const { accessControlConditions, evmContractConditions, solRpcConditions, unifiedAccessControlConditions } = params;
            if (accessControlConditions) {
                await (0, access_control_conditions_1.validateAccessControlConditionsSchema)(accessControlConditions);
            } else if (evmContractConditions) {
                await (0, access_control_conditions_1.validateEVMContractConditionsSchema)(evmContractConditions);
            } else if (solRpcConditions) {
                await (0, access_control_conditions_1.validateSolRpcConditionsSchema)(solRpcConditions);
            } else if (unifiedAccessControlConditions) {
                await (0, access_control_conditions_1.validateUnifiedAccessControlConditionsSchema)(unifiedAccessControlConditions);
            }
            return true;
        };
        /**
         *
         * Get hash of access control conditions
         *
         * @param { MultipleAccessControlConditions } params
         *
         * @returns { Promise<ArrayBuffer | undefined> }
         *
         */ this.getHashedAccessControlConditions = async (params)=>{
            let hashOfConditions;
            // ========== Prepare Params ==========
            const { accessControlConditions, evmContractConditions, solRpcConditions, unifiedAccessControlConditions } = params;
            // ========== Hash ==========
            if (accessControlConditions) {
                hashOfConditions = await (0, access_control_conditions_1.hashAccessControlConditions)(accessControlConditions);
            } else if (evmContractConditions) {
                hashOfConditions = await (0, access_control_conditions_1.hashEVMContractConditions)(evmContractConditions);
            } else if (solRpcConditions) {
                hashOfConditions = await (0, access_control_conditions_1.hashSolRpcConditions)(solRpcConditions);
            } else if (unifiedAccessControlConditions) {
                hashOfConditions = await (0, access_control_conditions_1.hashUnifiedAccessControlConditions)(unifiedAccessControlConditions);
            } else {
                return;
            }
            // ========== Result ==========
            return hashOfConditions;
        };
        /**
         * Handle node promises
         *
         * @param { Array<Promise<any>> } nodePromises
         *
         * @param { string } requestId requestId to be logged in case of error
         * @param { number } minNodeCount number of nodes we need valid results from in order to resolve
         * @returns { Promise<SuccessNodePromises<T> | RejectedNodePromises> }
         */ this.handleNodePromises = async (nodePromises, requestId, minNodeCount)=>{
            async function waitForNSuccessesWithErrors(promises, n) {
                let responses = 0;
                const successes = [];
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const errors = [];
                return new Promise((resolve)=>{
                    promises.forEach((promise)=>{
                        promise.then((result)=>{
                            successes.push(result);
                            if (successes.length >= n) {
                                // If we've got enough successful responses to continue, resolve immediately even if some are pending
                                resolve({
                                    successes,
                                    errors
                                });
                            }
                        }).catch((error)=>{
                            errors.push(error);
                        }).finally(()=>{
                            responses++;
                            if (responses === promises.length) {
                                // In case the total number of successful responses is less than n,
                                // resolve what we have when all promises are settled.
                                resolve({
                                    successes,
                                    errors
                                });
                            }
                        });
                    });
                });
            }
            // -- wait until we've received n responses
            const { successes, errors } = await waitForNSuccessesWithErrors(nodePromises, minNodeCount);
            // console.log(`successes: ${JSON.stringify(successes, null, 2)}`)
            // console.log(`errors: ${JSON.stringify(errors, null, 2)}`)
            // -- case: success (when success responses are more than minNodeCount)
            if (successes.length >= minNodeCount) {
                return {
                    success: true,
                    values: successes
                };
            }
            // TODO Likely a good use case for MultiError
            // -- case: if we're here, then we did not succeed.  time to handle and report errors.
            const mostCommonError = JSON.parse(// eslint-disable-next-line @typescript-eslint/no-explicit-any
            (0, misc_1.mostCommonString)(errors.map((r)=>JSON.stringify(r))));
            (0, misc_1.logErrorWithRequestId)(requestId || '', `most common error: ${JSON.stringify(mostCommonError)}`);
            return {
                success: false,
                error: mostCommonError
            };
        };
        /**
         * Throw node error
         *
         * @param { RejectedNodePromises } res
         * @param { string } requestId
         *
         * @returns { never }
         *
         */ this._throwNodeError = (res, requestId)=>{
            if (res.error) {
                if ((res.error.errorCode && res.error.errorCode === constants_1.LIT_ERROR_CODE.NODE_NOT_AUTHORIZED || res.error.errorCode === 'not_authorized') && this.config.alertWhenUnauthorized) {
                    (0, misc_1.log)('You are not authorized to access this content');
                }
                throw new constants_1.NodeError({
                    info: {
                        requestId,
                        errorCode: res.error.errorCode,
                        message: res.error.message
                    },
                    cause: res.error
                }, 'There was an error getting the signing shares from the nodes. Response from the nodes: %s', JSON.stringify(res));
            } else {
                throw new constants_1.UnknownError({
                    info: {
                        requestId
                    }
                }, `There was an error getting the signing shares from the nodes. Response from the nodes: %s`, JSON.stringify(res));
            }
        };
        /**
         *
         * Get different formats of access control conditions, eg. evm, sol, unified etc.
         *
         * @param { SupportedJsonRequests } params
         *
         * @returns { FormattedMultipleAccs }
         *
         */ this.getFormattedAccessControlConditions = (params)=>{
            // -- prepare params
            const { accessControlConditions, evmContractConditions, solRpcConditions, unifiedAccessControlConditions } = params;
            // -- execute
            let formattedAccessControlConditions;
            let formattedEVMContractConditions;
            let formattedSolRpcConditions;
            let formattedUnifiedAccessControlConditions;
            let error = false;
            if (accessControlConditions) {
                formattedAccessControlConditions = accessControlConditions.map((c)=>(0, access_control_conditions_1.canonicalAccessControlConditionFormatter)(c));
                (0, misc_1.log)('formattedAccessControlConditions', JSON.stringify(formattedAccessControlConditions));
            } else if (evmContractConditions) {
                formattedEVMContractConditions = evmContractConditions.map((c)=>(0, access_control_conditions_1.canonicalEVMContractConditionFormatter)(c));
                (0, misc_1.log)('formattedEVMContractConditions', JSON.stringify(formattedEVMContractConditions));
            } else if (solRpcConditions) {
                // FIXME: ConditionItem is too narrow, or `solRpcConditions` is too wide
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                formattedSolRpcConditions = solRpcConditions.map((c)=>(0, access_control_conditions_1.canonicalSolRpcConditionFormatter)(c));
                (0, misc_1.log)('formattedSolRpcConditions', JSON.stringify(formattedSolRpcConditions));
            } else if (unifiedAccessControlConditions) {
                formattedUnifiedAccessControlConditions = unifiedAccessControlConditions.map((c)=>(0, access_control_conditions_1.canonicalUnifiedAccessControlConditionFormatter)(c));
                (0, misc_1.log)('formattedUnifiedAccessControlConditions', JSON.stringify(formattedUnifiedAccessControlConditions));
            } else {
                error = true;
            }
            return {
                error,
                formattedAccessControlConditions,
                formattedEVMContractConditions,
                formattedSolRpcConditions,
                formattedUnifiedAccessControlConditions
            };
        };
        /**
         * Calculates an HD public key from a given keyId
         * The curve type or signature type is assumed to be k256 unless provided
         * @param keyId
         * @param {LIT_CURVE_VALUES} sigType
         * @returns {string} public key
         */ this.computeHDPubKey = async (keyId, sigType = constants_1.LIT_CURVE.EcdsaCaitSith)=>{
            if (!this.hdRootPubkeys) {
                (0, misc_1.logError)('root public keys not found, have you connected to the nodes?');
                throw new constants_1.LitNodeClientNotReadyError({}, 'root public keys not found, have you connected to the nodes?');
            }
            return await (0, crypto_1.computeHDPubKey)(this.hdRootPubkeys, keyId, sigType);
        };
        if (!(config.litNetwork in constants_1.LIT_NETWORKS)) {
            const validNetworks = Object.keys(constants_1.LIT_NETWORKS).join(', ');
            throw new constants_1.InvalidParamType({}, 'Unsupported network has been provided please use a "litNetwork" option which is supported (%s)', validNetworks);
        }
        // Initialize default config based on litNetwork
        switch(config?.litNetwork){
            // Official networks; default value for `checkNodeAttestation` according to network provided.
            case constants_1.LIT_NETWORK.DatilDev:
                this.config = {
                    ...this.config,
                    checkNodeAttestation: NETWORKS_REQUIRING_SEV.includes(config?.litNetwork),
                    ...config
                };
                break;
            default:
                // `custom`; no opinion about checkNodeAttestation
                this.config = {
                    ...this.config,
                    ...config
                };
        }
        // -- set bootstrapUrls to match the network litNetwork unless it's set to custom
        this.setCustomBootstrapUrls();
        // -- set global variables
        (0, misc_1.setMiscLitConfig)(this.config);
        (0, misc_1.bootstrapLogManager)('core', this.config.debug ? constants_1.LogLevel.DEBUG : constants_1.LogLevel.OFF, this.config.logFormat || 'text', this.config.serviceName || 'lit-sdk');
        // -- configure local storage if not present
        // LitNodeClientNodejs is a base for LitNodeClient
        // First check for if our runtime is node
        // If the user sets a new storage provider we respect it over our default storage
        // If the user sets a new file path, we respect it over the default path.
        if (this.config.storageProvider?.provider) {
            (0, misc_1.log)('localstorage api not found, injecting persistence instance found in config');
            // using Object defineProperty in order to set a property previously defined as readonly.
            // if the user wants to override the storage option explicitly we override.
            Object.defineProperty(globalThis, 'localStorage', {
                value: this.config.storageProvider?.provider
            });
        } else if ((0, misc_1.isNode)() && !globalThis.localStorage && !this.config.storageProvider?.provider) {
            (0, misc_1.log)('Looks like you are running in NodeJS and did not provide a storage provider, your sessions will not be cached');
        }
    }
    /**
     * Retrieves the validator data including staking contract, epoch, minNodeCount, and bootstrapUrls.
     * @returns An object containing the validator data.
     * @throws Error if minNodeCount is not provided, is less than or equal to 0, or if bootstrapUrls are not available.
     */ async _getValidatorData() {
        const { stakingContract, epochInfo, minNodeCount, bootstrapUrls } = await contracts_sdk_1.LitContracts.getConnectionInfo({
            litNetwork: this.config.litNetwork,
            networkContext: this.config.contractContext,
            rpcUrl: this.config.rpcUrl,
            nodeProtocol: this.config.nodeProtocol
        });
        // Validate minNodeCount
        if (!minNodeCount) {
            throw new constants_1.InvalidArgumentException({}, `minNodeCount is %s, which is invalid. Please check your network connection and try again.`, minNodeCount);
        }
        // Validate bootstrapUrls
        if (!Array.isArray(bootstrapUrls) || bootstrapUrls.length <= 0) {
            throw new constants_1.InitError({}, `Failed to get bootstrapUrls for network %s`, this.config.litNetwork);
        }
        (0, misc_1.log)('[_getValidatorData] epochInfo: ', epochInfo);
        (0, misc_1.log)('[_getValidatorData] minNodeCount: ', minNodeCount);
        (0, misc_1.log)('[_getValidatorData] Bootstrap urls: ', bootstrapUrls);
        (0, misc_1.log)('[_getValidatorData] stakingContract: ', stakingContract.address);
        return {
            stakingContract,
            epochInfo,
            minNodeCount,
            bootstrapUrls
        };
    }
    // ========== Scoped Class Helpers ==========
    async _handleStakingContractStateChange(state) {
        try {
            (0, misc_1.log)(`New state detected: "${state}"`);
            if (state === constants_1.STAKING_STATES.Active) {
                const validatorData = await this._getValidatorData();
                // We don't need to handle node urls changing on centralised networks, since their validator sets are static
                if (constants_1.CENTRALISATION_BY_NETWORK[this.config.litNetwork] !== 'centralised') {
                    (0, misc_1.log)('State found to be new validator set locked, checking validator set');
                    const existingNodeUrls = [
                        ...this.config.bootstrapUrls
                    ];
                    const delta = validatorData.bootstrapUrls.filter((item)=>existingNodeUrls.includes(item));
                    // check if the node sets are non-matching and re-connect if they do not.
                    if (delta.length > 1) {
                        /*
                              TODO: This covers *most* cases where a node may come in or out of the active
                              set which we will need to re attest to the execution environments.
                              However, the sdk currently does not know if there is an active network operation pending.
                              Such that the state when the request was sent will now mutate when the response is sent back.
                              The sdk should be able to understand its current execution environment and wait on an active
                              network request to the previous epoch's node set before changing over.
                            */ (0, misc_1.log)('Active validator sets changed, new validators ', delta, 'starting node connection');
                        await this.connect(); // Will update `epochInfo`
                    }
                } else {
                    // In case of centralised networks, we don't run `connect()` flow, so we will manually update epochInfo here
                    this._epochState = await this._fetchCurrentEpochState(validatorData.epochInfo);
                }
            }
        } catch (err) {
            // Ensure that any methods that check `this.ready` throw errors to the caller, and any consumers can check appropriately
            this.ready = false;
            const { message = '' } = err;
            (0, misc_1.logError)('Error while attempting to reconnect to nodes after epoch transition:', message);
            const handshakeError = new Error('Error while attempting to reconnect to nodes after epoch transition:' + message);
            // Signal to any listeners that we've encountered a fatal error
            this.emit('error', handshakeError);
            // Signal to any listeners that we're 'disconnected' from LIT network
            this.emit('disconnected', {
                reason: 'error',
                error: handshakeError
            });
        }
    }
    /**
     * Sets up a listener to detect state changes (new epochs) in the staking contract.
     * When a new epoch is detected, it triggers the `setNewConfig` function to update
     * the client's configuration based on the new state of the network. This ensures
     * that the client's configuration is always in sync with the current state of the
     * staking contract.
     *
     * @returns {Promise<void>} A promise that resolves when the listener is successfully set up.
     */ _listenForNewEpoch() {
        // Check if we've already set up the listener to avoid duplicates
        if (this._stakingContractListener) {
            // Already listening, do nothing
            return;
        }
        if (this._stakingContract) {
            (0, misc_1.log)('listening for state change on staking contract: ', this._stakingContract.address);
            // Stash a function instance, because its identity must be consistent for '.off()' usage to work later
            this._stakingContractListener = (state)=>{
                // Intentionally not return or await; Listeners are _not async_
                this._handleStakingContractStateChange(state);
            };
            this._stakingContract.on('StateChanged', this._stakingContractListener);
        }
    }
    /**
     *  Stops internal listeners/polling that refresh network state and watch for epoch changes.
     *  Removes global objects created internally
     */ async disconnect() {
        this.ready = false;
        this._stopListeningForNewEpoch();
        // this._stopNetworkPolling();
        (0, misc_1.setMiscLitConfig)(undefined);
        this.emit('disconnected', {
            reason: 'disconnect'
        });
    }
    // _stopNetworkPolling() {
    //   if (this._networkSyncInterval) {
    //     clearInterval(this._networkSyncInterval);
    //     this._networkSyncInterval = null;
    //   }
    // }
    _stopListeningForNewEpoch() {
        if (this._stakingContract && this._stakingContractListener) {
            this._stakingContract.off('StateChanged', this._stakingContractListener);
            this._stakingContractListener = null;
        }
    }
    /**
     *
     * Connect to the LIT nodes
     *
     * @returns { Promise } A promise that resolves when the nodes are connected.
     *
     */ async connect() {
        // Ensure that multiple closely timed calls to `connect()` don't result in concurrent connect() operations being run
        if (this._connectingPromise) {
            return this._connectingPromise;
        }
        this._connectingPromise = this._connect();
        await this._connectingPromise.finally(()=>{
            this._connectingPromise = null;
        });
    }
    async _connect() {
        // Initialize a contractContext if we were not given one; this allows interaction against the staking contract
        // to be handled locally from then on
        if (!this.config.contractContext) {
            this.config.contractContext = await contracts_sdk_1.LitContracts.getContractAddresses(this.config.litNetwork, new ethers_1.ethers.providers.StaticJsonRpcProvider({
                url: this.config.rpcUrl || constants_1.RPC_URL_BY_NETWORK[this.config.litNetwork],
                skipFetchSetup: true
            }));
        } else if (!this.config.contractContext.Staking && !this.config.contractContext.resolverAddress) {
            throw new constants_1.InitError({
                info: {
                    contractContext: this.config.contractContext,
                    litNetwork: this.config.litNetwork,
                    rpcUrl: this.config.rpcUrl
                }
            }, 'The provided contractContext was missing the "Staking" contract');
        }
        if (this.config.contractContext) {
            const logAddresses = Object.entries(this.config.contractContext).reduce((output, [key, val])=>{
                // @ts-expect-error since the object hash returned by `getContractAddresses` is `any`, we have no types here
                output[key] = val.address;
                return output;
            }, {});
            if (this.config.litNetwork === constants_1.LIT_NETWORK.Custom) {
                (0, misc_1.log)('using custom contracts: ', logAddresses);
            }
        }
        // Re-use staking contract instance from previous connect() executions that succeeded to improve performance
        const validatorData = await this._getValidatorData();
        this._stakingContract = validatorData.stakingContract;
        this.config.minNodeCount = validatorData.minNodeCount;
        this.config.bootstrapUrls = validatorData.bootstrapUrls;
        this._epochState = await this._fetchCurrentEpochState(validatorData.epochInfo);
        // -- handshake with each node.  Note that if we've previously initialized successfully, but this call fails,
        // core will remain useable but with the existing set of `connectedNodes` and `serverKeys`.
        const { connectedNodes, serverKeys, coreNodeConfig } = await this._runHandshakeWithBootstrapUrls();
        Object.assign(this, {
            ...coreNodeConfig,
            connectedNodes,
            serverKeys
        });
        // this._scheduleNetworkSync();
        this._listenForNewEpoch();
        this.ready = true;
        (0, misc_1.log)(` lit is ready. "litNodeClient" variable is ready to use globally.`);
        (0, misc_1.log)('current network config', {
            networkPubkey: this.networkPubKey,
            networkPubKeySet: this.networkPubKeySet,
            hdRootPubkeys: this.hdRootPubkeys,
            subnetPubkey: this.subnetPubKey,
            latestBlockhash: this.latestBlockhash
        });
        this.emit('connected', true);
        // browser only
        if ((0, misc_1.isBrowser)()) {
            document.dispatchEvent(new Event('lit-ready'));
        }
    }
    async _handshakeAndVerifyNodeAttestation({ url, requestId }) {
        const challenge = this.getRandomHexString(64);
        const handshakeResult = await this.handshakeWithNode({
            url,
            challenge
        }, requestId);
        const keys = {
            serverPubKey: handshakeResult.serverPublicKey,
            subnetPubKey: handshakeResult.subnetPublicKey,
            networkPubKey: handshakeResult.networkPublicKey,
            networkPubKeySet: handshakeResult.networkPublicKeySet,
            hdRootPubkeys: handshakeResult.hdRootPubkeys,
            latestBlockhash: handshakeResult.latestBlockhash
        };
        // Nodes that have just bootstrapped will not have negotiated their keys, yet
        // They will return ERR for those values until they reach consensus
        // Note that if node attestation checks are disabled or checkSevSnpAttestation() succeeds, we will still track the
        // node, even though its keys may be "ERR".
        // Should we really track servers with ERR as keys?
        if (keys.serverPubKey === 'ERR' || keys.subnetPubKey === 'ERR' || keys.networkPubKey === 'ERR' || keys.networkPubKeySet === 'ERR') {
            (0, misc_1.logErrorWithRequestId)(requestId, 'Error connecting to node. Detected "ERR" in keys', url, keys);
        }
        (0, misc_1.log)(`Handshake with ${url} returned keys: `, keys);
        if (!keys.latestBlockhash) {
            (0, misc_1.logErrorWithRequestId)(requestId, `Error getting latest blockhash from the node ${url}.`);
        }
        // We force SEV checks on some networks even if the caller attempts to construct the client with them disabled
        if (this.config.checkNodeAttestation || NETWORKS_REQUIRING_SEV.includes(this.config.litNetwork)) {
            const attestation = handshakeResult.attestation;
            if (!attestation) {
                throw new constants_1.InvalidNodeAttestation({}, `Missing attestation in handshake response from %s`, url);
            }
            // actually verify the attestation by checking the signature against AMD certs
            (0, misc_1.log)('Checking attestation against amd certs...');
            try {
                // ensure we won't try to use a node with an invalid attestation response
                await (0, crypto_1.checkSevSnpAttestation)(attestation, challenge, url);
                (0, misc_1.log)(`Lit Node Attestation verified for ${url}`);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            } catch (e) {
                throw new constants_1.InvalidNodeAttestation({
                    cause: e
                }, `Lit Node Attestation failed verification for %s - %s`, url, e.message);
            }
        } else if (this.config.litNetwork === constants_1.LIT_NETWORK.Custom) {
            (0, misc_1.log)(`Node attestation SEV verification is disabled. You must explicitly set "checkNodeAttestation" to true when using 'custom' network`);
        }
        return keys;
    }
    /** Handshakes with all nodes that are in `bootstrapUrls`
     * @private
     *
     * @returns {Promise<{connectedNodes: Set<string>, serverKeys: {}}>} Returns a set of the urls of nodes that we
     * successfully connected to, an object containing their returned keys, and our 'core' config (most common values for
     * critical values)
     */ async _runHandshakeWithBootstrapUrls() {
        // -- handshake with each node
        const requestId = this._getNewRequestId();
        // track connectedNodes for the new handshake operation
        const connectedNodes = new Set();
        const serverKeys = {};
        let timeoutHandle;
        await Promise.race([
            new Promise((_resolve, reject)=>{
                timeoutHandle = setTimeout(()=>{
                    const msg = `Error: Could not handshake with nodes after timeout of ${this.config.connectTimeout}ms. Could only connect to ${Object.keys(serverKeys).length} of ${this.config.bootstrapUrls.length} nodes. Please check your network connection and try again. Note that you can control this timeout with the connectTimeout config option which takes milliseconds.`;
                    try {
                        throw new constants_1.InitError({}, msg);
                    } catch (e) {
                        (0, misc_1.logErrorWithRequestId)(requestId, e);
                        reject(e);
                    }
                }, this.config.connectTimeout);
            }),
            Promise.all(this.config.bootstrapUrls.map(async (url)=>{
                serverKeys[url] = await this._handshakeAndVerifyNodeAttestation({
                    url,
                    requestId
                });
                connectedNodes.add(url);
            })).finally(()=>{
                clearTimeout(timeoutHandle);
            })
        ]);
        const coreNodeConfig = this._getCoreNodeConfigFromHandshakeResults({
            serverKeys,
            requestId
        });
        return {
            connectedNodes,
            serverKeys,
            coreNodeConfig
        };
    }
    _getCoreNodeConfigFromHandshakeResults({ serverKeys, requestId }) {
        const latestBlockhash = (0, misc_1.mostCommonString)(Object.values(serverKeys).map((keysFromSingleNode)=>keysFromSingleNode.latestBlockhash));
        if (!latestBlockhash) {
            (0, misc_1.logErrorWithRequestId)(requestId, 'Error getting latest blockhash from the nodes.');
            throw new constants_1.InvalidEthBlockhash({
                info: {
                    requestId
                }
            }, `latestBlockhash is not available. Received: "%s"`, latestBlockhash);
        }
        // pick the most common public keys for the subnet and network from the bunch, in case some evil node returned a bad key
        return {
            subnetPubKey: (0, misc_1.mostCommonString)(Object.values(serverKeys).map((keysFromSingleNode)=>keysFromSingleNode.subnetPubKey)),
            networkPubKey: (0, misc_1.mostCommonString)(Object.values(serverKeys).map((keysFromSingleNode)=>keysFromSingleNode.networkPubKey)),
            networkPubKeySet: (0, misc_1.mostCommonString)(Object.values(serverKeys).map((keysFromSingleNode)=>keysFromSingleNode.networkPubKeySet)),
            hdRootPubkeys: (0, misc_1.mostCommonString)(Object.values(serverKeys).map((keysFromSingleNode)=>keysFromSingleNode.hdRootPubkeys)),
            latestBlockhash,
            lastBlockHashRetrieved: Date.now()
        };
    }
    /**
     * Fetches the latest block hash and log any errors that are returned
     * Nodes will accept any blockhash in the last 30 days but use the latest 10 as challenges for webauthn
     * Note: last blockhash from providers might not be propagated to the nodes yet, so we need to use a slightly older one
     * @returns void
     */ async _syncBlockhash() {
        const currentTime = Date.now();
        const blockHashValidityDuration = BLOCKHASH_SYNC_INTERVAL;
        if (this.latestBlockhash && this.lastBlockHashRetrieved && currentTime - this.lastBlockHashRetrieved < blockHashValidityDuration) {
            (0, misc_1.log)('Blockhash is still valid. No need to sync.');
            return;
        }
        (0, misc_1.log)('Syncing state for new blockhash ', 'current blockhash: ', this.latestBlockhash);
        try {
            // This fetches from the lit propagation service so nodes will always have it
            const resp = await fetch(this._blockHashUrl);
            // If the blockhash retrieval failed, throw an error to trigger fallback in catch block
            if (!resp.ok) {
                throw new constants_1.NetworkError({
                    responseResult: resp.ok,
                    responseStatus: resp.status
                }, `Error getting latest blockhash from ${this._blockHashUrl}. Received: "${resp.status}"`);
            }
            const blockHashBody = await resp.json();
            const { blockhash, timestamp } = blockHashBody;
            // If the blockhash retrieval does not have the required fields, throw an error to trigger fallback in catch block
            if (!blockhash || !timestamp) {
                throw new constants_1.NetworkError({
                    responseResult: resp.ok,
                    blockHashBody
                }, `Error getting latest blockhash from block indexer. Received: "${blockHashBody}"`);
            }
            this.latestBlockhash = blockHashBody.blockhash;
            this.lastBlockHashRetrieved = parseInt(timestamp) * 1000;
            (0, misc_1.log)('Done syncing state new blockhash: ', this.latestBlockhash);
        } catch (error) {
            const err = error;
            (0, misc_1.logError)('Error while attempting to fetch new latestBlockhash:', err instanceof Error ? err.message : err.messages, 'Reason: ', err instanceof Error ? err : err.reason);
            (0, misc_1.log)('Attempting to fetch blockhash manually using ethers with fallback RPC URLs...');
            const { testResult } = await this._getProviderWithFallback(// We use a previous block to avoid nodes not having received the latest block yet
            (provider)=>provider.getBlock(BLOCKHASH_COUNT_PROVIDER_DELAY)) || {};
            if (!testResult || !testResult.hash) {
                (0, misc_1.logError)('All fallback RPC URLs failed. Unable to retrieve blockhash.');
                return;
            }
            try {
                this.latestBlockhash = testResult.hash;
                this.lastBlockHashRetrieved = testResult.timestamp;
                (0, misc_1.log)('Successfully retrieved blockhash manually: ', this.latestBlockhash);
            } catch (ethersError) {
                (0, misc_1.logError)('Failed to manually retrieve blockhash using ethers');
            }
        }
    }
    /** Currently, we perform a full sync every 30s, including handshaking with every node
     * However, we also have a state change listener that watches for staking contract state change events, which
     * _should_ be the only time that we need to perform handshakes with every node.
     *
     * However, the current block hash does need to be updated regularly, and we currently update it only when we
     * handshake with every node.
     *
     * We can remove this network sync code entirely if we refactor our code to fetch latest blockhash on-demand.
     * @private
     */ // private _scheduleNetworkSync() {
    //   if (this._networkSyncInterval) {
    //     clearInterval(this._networkSyncInterval);
    //   }
    //   this._networkSyncInterval = setInterval(async () => {
    //     if (
    //       !this.lastBlockHashRetrieved ||
    //       Date.now() - this.lastBlockHashRetrieved >= BLOCKHASH_SYNC_INTERVAL
    //     ) {
    //       await this._syncBlockhash();
    //     }
    //   }, BLOCKHASH_SYNC_INTERVAL);
    // }
    /**
     *
     * Get a new random request ID
     *
     * @returns { string }
     *
     */ _getNewRequestId() {
        return Math.random().toString(16).slice(2);
    }
    /**
     *
     * Get a random hex string for use as an attestation challenge
     *
     * @returns { string }
     */ getRandomHexString(size) {
        return [
            ...Array(size)
        ].map(()=>Math.floor(Math.random() * 16).toString(16)).join('');
    }
    async _fetchCurrentEpochState(epochInfo) {
        if (!this._stakingContract) {
            throw new constants_1.InitError({}, 'Unable to fetch current epoch number; no staking contract configured. Did you forget to `connect()`?');
        }
        if (!epochInfo) {
            (0, misc_1.log)('epochinfo not found. Not a problem, fetching current epoch state from staking contract');
            try {
                const validatorData = await this._getValidatorData();
                epochInfo = validatorData.epochInfo;
            } catch (error) {
                throw new constants_1.UnknownError({}, '[_fetchCurrentEpochNumber] Error getting current epoch number: %s', error);
            }
        }
        // when we transition to the new epoch, we don't store the start time.  but we
        // set the endTime to the current timestamp + epochLength.
        // by reversing this and subtracting epochLength from the endTime, we get the start time
        const startTime = epochInfo.endTime - epochInfo.epochLength;
        return {
            currentNumber: epochInfo.number,
            startTime
        };
    }
    get currentEpochNumber() {
        // if the epoch started less than 15s ago (aka EPOCH_PROPAGATION_DELAY), use the previous epoch number
        // this gives the nodes time to sync with the chain and see the new epoch before we try to use it
        if (this._epochCache.currentNumber && this._epochCache.startTime && Math.floor(Date.now() / 1000) < this._epochCache.startTime + Math.floor(EPOCH_PROPAGATION_DELAY / 1000) && this._epochCache.currentNumber >= 3 // FIXME: Why this check?
        ) {
            return this._epochCache.currentNumber - 1;
        }
        return this._epochCache.currentNumber;
    }
    set _epochState({ currentNumber, startTime }) {
        this._epochCache.currentNumber = currentNumber;
        this._epochCache.startTime = startTime;
    }
    getRandomNodePromise(// eslint-disable-next-line @typescript-eslint/no-explicit-any
    callback) {
        const randomNodeIndex = Math.floor(Math.random() * this.connectedNodes.size);
        const nodeUrlsArr = Array.from(this.connectedNodes);
        return [
            callback(nodeUrlsArr[randomNodeIndex])
        ];
    }
    /**
     * Calculates a Key Id for claiming a pkp based on a user identifier and an app identifier.
     * The key Identifier is an Auth Method Id which scopes the key uniquely to a specific application context.
     * These identifiers are specific to each auth method and will derive the public key portion of a pkp which will be persisted
     * when a key is claimed.
     * | Auth Method | User ID | App ID |
     * |:------------|:--------|:-------|
     * | Google OAuth | token `sub` | token `aud` |
     * | Discord OAuth | user id | client app identifier |
     * | Stytch OTP |token `sub` | token `aud`|
     * | Lit Actions | user defined | ipfs cid |
     * *Note* Lit Action claiming uses a different schema than other auth methods
     *
     * @param {string} userId user identifier for the Key Identifier
     * @param {string} appId app identifier for the Key Identifier
     * @param {boolean} isForActionContext should be set for true if using claiming through actions
     *
     * @returns {string} public key of pkp when claimed
     */ computeHDKeyId(userId, appId, isForActionContext = false) {
        if (!isForActionContext) {
            return ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes(`${userId}:${appId}`));
        } else {
            return ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes(`${appId}:${userId}`));
        }
    }
}
exports.LitCore = LitCore; //# sourceMappingURL=lit-core.js.map
}),
"[project]/node_modules/@lit-protocol/core/src/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
const tslib_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/core/node_modules/tslib/tslib.es6.js [app-client] (ecmascript)");
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/core/src/lib/lit-core.js [app-client] (ecmascript)"), exports);
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/core/src/lib/endpoint-version.js [app-client] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@lit-protocol/lit-node-client-nodejs/src/lib/helpers/encode-code.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.encodeCode = void 0;
const uint8arrays_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/uint8arrays/src/index.js [app-client] (ecmascript)");
/**
 * Encodes the given code string into base64 format.
 *
 * @param code - The code string to be encoded.
 * @returns The encoded code string in base64 format.
 */ const encodeCode = (code)=>{
    const _uint8Array = (0, uint8arrays_1.uint8arrayFromString)(code, 'utf8');
    const encodedJs = (0, uint8arrays_1.uint8arrayToString)(_uint8Array, 'base64');
    return encodedJs;
};
exports.encodeCode = encodeCode; //# sourceMappingURL=encode-code.js.map
}),
"[project]/node_modules/@lit-protocol/lit-node-client-nodejs/src/lib/helpers/get-bls-signatures.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getBlsSignatures = getBlsSignatures;
const misc_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/misc/src/index.js [app-client] (ecmascript)");
/**
 * Get the BLS signatures from the response data.
 * @param responseData - The response data from BLS signature scheme.
 * @returns An array of BLS signatures.
 * @throws Error if no data is provided.
 */ function getBlsSignatures(responseData) {
    if (!responseData) {
        throw new Error('[getBlsSignatures] No data provided');
    }
    const signatureShares = responseData.map((s)=>({
            ProofOfPossession: s.signatureShare.ProofOfPossession
        }));
    (0, misc_1.log)(`[getBlsSignatures] signatureShares:`, signatureShares);
    if (!signatureShares || signatureShares.length <= 0) {
        throw new Error('[getBlsSignatures] No signature shares provided');
    }
    return signatureShares;
// const signedDataList = responseData.map((s) => s.dataSigned);
// log(`[getBlsSignatures] signedDataList:`, signedDataList);
// return signedDataList;
} //# sourceMappingURL=get-bls-signatures.js.map
}),
"[project]/node_modules/@lit-protocol/lit-node-client-nodejs/src/lib/helpers/get-claims.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getClaims = void 0;
const ethers_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-client] (ecmascript)");
/**
 * Retrieves the claims from an array of objects and organizes them into a record.
 * Each claim is associated with its corresponding signatures and derived key ID.
 *
 * @param claims - An array of objects representing the claims.
 * @returns A record where each key represents a claim, and the value is an object containing the claim's signatures and derived key ID.
 */ const getClaims = (claims)=>{
    const keys = Object.keys(claims[0]);
    const signatures = {};
    const claimRes = {};
    for(let i = 0; i < keys.length; i++){
        const claimSet = claims.map((c)=>c[keys[i]]);
        signatures[keys[i]] = [];
        claimSet.map((c)=>{
            const sig = ethers_1.ethers.utils.splitSignature(`0x${c.signature}`);
            const convertedSig = {
                r: sig.r,
                s: sig.s,
                v: sig.v
            };
            signatures[keys[i]].push(convertedSig);
        });
        claimRes[keys[i]] = {
            signatures: signatures[keys[i]],
            derivedKeyId: claimSet[0].derivedKeyId
        };
    }
    return claimRes;
};
exports.getClaims = getClaims; //# sourceMappingURL=get-claims.js.map
}),
"[project]/node_modules/@lit-protocol/lit-node-client-nodejs/src/lib/helpers/get-claims-list.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getClaimsList = void 0;
/**
 * Retrieves a list of claims from the provided response data.
 * @param responseData The response data containing the claims.
 * @returns An array of claims.
 */ const getClaimsList = (responseData)=>{
    const claimsList = responseData.map((r)=>{
        const { claimData } = r;
        if (claimData) {
            for (const key of Object.keys(claimData)){
                for (const subkey of Object.keys(claimData[key])){
                    if (typeof claimData[key][subkey] == 'string') {
                        claimData[key][subkey] = claimData[key][subkey].replaceAll('"', '');
                    }
                }
            }
            return claimData;
        }
        return null;
    }).filter((item)=>item !== null);
    return claimsList;
};
exports.getClaimsList = getClaimsList; //# sourceMappingURL=get-claims-list.js.map
}),
"[project]/node_modules/@lit-protocol/lit-node-client-nodejs/src/lib/helpers/get-signatures.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getSignatures = exports.getFlattenShare = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib/utils.js [app-client] (ecmascript)");
const constants_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/@lit-protocol/constants/src/index.js [app-client] (ecmascript)");
const crypto_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/crypto/src/index.js [app-client] (ecmascript)");
const misc_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/misc/src/index.js [app-client] (ecmascript)");
const getFlattenShare = (share)=>{
    // flatten the signature object so that the properties of the signature are top level
    const flattenObj = Object.values(share).map((item)=>{
        if (item === null || item === undefined) {
            return null;
        }
        const typedItem = item;
        const requiredShareProps = [
            'sigType',
            'dataSigned',
            'signatureShare',
            'shareIndex',
            'bigR',
            'publicKey'
        ];
        const requiredSessionSigsShareProps = [
            ...requiredShareProps,
            'siweMessage'
        ];
        const requiredSignatureShareProps = [
            ...requiredShareProps,
            'sigName'
        ];
        const hasProps = (props)=>{
            return props.every((prop)=>typedItem[prop] !== undefined && typedItem[prop] !== null);
        };
        if (hasProps(requiredSessionSigsShareProps) || hasProps(requiredSignatureShareProps)) {
            const bigR = typedItem.bigR ?? typedItem.bigr;
            typedItem.signatureShare = (typedItem.signatureShare ?? '').replaceAll('"', '');
            typedItem.bigR = (bigR ?? '').replaceAll('"', '');
            typedItem.publicKey = (typedItem.publicKey ?? '').replaceAll('"', '');
            typedItem.dataSigned = (typedItem.dataSigned ?? '').replaceAll('"', '');
            return typedItem;
        }
        return null;
    });
    // removed all null values and should only have one item
    const flattenShare = flattenObj.filter((item)=>item !== null)[0];
    if (flattenShare === null || flattenShare === undefined) {
        return share;
    }
    return flattenShare;
};
exports.getFlattenShare = getFlattenShare;
/**
 * Retrieves and combines signature shares from multiple nodes to generate the final signatures.
 *
 * @template T - The type of the final signatures. For `executeJs` endpoint, it returns as `signature`, and for `pkpSign` endpoint, it returns as `sig`.
 * @param {any} params.networkPubKeySet - The public key set of the network.
 * @param {number} params.minNodeCount - The threshold number of nodes
 * @param {any[]} params.signedData - The array of signature shares from each node.
 * @param {string} [params.requestId=''] - The optional request ID for logging purposes.
 * @returns {T | { signature: SigResponse; sig: SigResponse }} - The final signatures or an object containing the final signatures.
 *
 * @example
 *
 * executeJs: getSignatures<{ signature: SigResponse }>
 * pkpSign: getSignatures<{ sig: SigResponse }>
 */ const getSignatures = async (params)=>{
    const { networkPubKeySet, minNodeCount, signedData, requestId } = params;
    const initialKeys = [
        ...new Set(signedData.flatMap((i)=>Object.keys(i)))
    ];
    // processing signature shares for failed or invalid contents.  mutates the signedData object.
    for (const signatureResponse of signedData){
        for (const sigName of Object.keys(signatureResponse)){
            const requiredFields = [
                'signatureShare'
            ];
            for (const field of requiredFields){
                if (!signatureResponse[sigName][field]) {
                    (0, misc_1.logWithRequestId)(requestId, `invalid field ${field} in signature share: ${sigName}, continuing with share processing`);
                    // destructive operation on the object to remove invalid shares inline, without a new collection.
                    delete signatureResponse[sigName];
                } else {
                    let share = (0, exports.getFlattenShare)(signatureResponse[sigName]);
                    share = {
                        sigType: share.sigType,
                        signatureShare: share.signatureShare,
                        shareIndex: share.shareIndex,
                        bigR: share.bigR,
                        publicKey: share.publicKey,
                        dataSigned: share.dataSigned,
                        sigName: share.sigName ? share.sigName : 'sig'
                    };
                    signatureResponse[sigName] = share;
                }
            }
        }
    }
    const validatedSignedData = signedData;
    // -- prepare
    const signatures = {};
    // get all signature shares names from all node responses.
    // use a set to filter duplicates and copy into an array
    const allKeys = [
        ...new Set(validatedSignedData.flatMap((i)=>Object.keys(i)))
    ];
    if (allKeys.length !== initialKeys.length) {
        throw new constants_1.NoValidShares({}, 'total number of valid signatures does not match requested');
    }
    // -- combine
    for (const key of allKeys){
        // here we use a map filter implementation to find common shares in each node response.
        // we then filter out undefined object from the key access.
        // currently we are unable to know the total signature count requested by the user.
        // but this allows for incomplete sets of signature shares to be aggregated
        // and then checked against threshold
        const shares = validatedSignedData.map((r)=>r[key]).filter((r)=>r !== undefined);
        shares.sort((a, b)=>a.shareIndex - b.shareIndex);
        const sigName = shares[0].sigName;
        (0, misc_1.logWithRequestId)(requestId, `starting signature combine for sig name: ${sigName}`, shares);
        (0, misc_1.logWithRequestId)(requestId, `number of shares for ${sigName}:`, signedData.length);
        (0, misc_1.logWithRequestId)(requestId, `validated length for signature: ${sigName}`, shares.length);
        (0, misc_1.logWithRequestId)(requestId, 'minimum required shares for threshold:', minNodeCount);
        if (shares.length < minNodeCount) {
            (0, misc_1.logErrorWithRequestId)(requestId, `not enough nodes to get the signatures.  Expected ${minNodeCount}, got ${shares.length}`);
            throw new constants_1.NoValidShares({
                info: {
                    requestId,
                    shares: shares.length,
                    minNodeCount
                }
            }, 'The total number of valid signatures shares %s does not meet the threshold of %s', shares.length, minNodeCount);
        }
        const sigType = (0, misc_1.mostCommonString)(shares.map((s)=>s.sigType));
        // -- validate if this.networkPubKeySet is null
        if (networkPubKeySet === null) {
            throw new constants_1.ParamNullError({
                info: {
                    requestId
                }
            }, 'networkPubKeySet cannot be null');
        }
        // -- validate if signature type is ECDSA
        if (sigType !== constants_1.LIT_CURVE.EcdsaCaitSith && sigType !== constants_1.LIT_CURVE.EcdsaK256 && sigType !== constants_1.LIT_CURVE.EcdsaCAITSITHP256) {
            throw new constants_1.UnknownSignatureType({
                info: {
                    requestId,
                    signatureType: sigType
                }
            }, 'signature type is %s which is invalid', sigType);
        }
        const signature = await (0, crypto_1.combineEcdsaShares)(shares);
        if (!signature.r) {
            throw new constants_1.UnknownSignatureError({
                info: {
                    requestId,
                    signature
                }
            }, 'signature could not be combined');
        }
        const encodedSig = (0, utils_1.joinSignature)({
            r: '0x' + signature.r,
            s: '0x' + signature.s,
            recoveryParam: signature.recid
        });
        signatures[key] = {
            ...signature,
            signature: encodedSig,
            publicKey: (0, misc_1.mostCommonString)(shares.map((s)=>s.publicKey)),
            dataSigned: (0, misc_1.mostCommonString)(shares.map((s)=>s.dataSigned))
        };
    }
    return signatures;
};
exports.getSignatures = getSignatures; //# sourceMappingURL=get-signatures.js.map
}),
"[project]/node_modules/@lit-protocol/lit-node-client-nodejs/src/lib/helpers/normalize-array.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.normalizeArray = void 0;
/**
 * Converts an ArrayLike object to a regular array.
 *
 * Context: the nodes will only accept a normal array type as a paramater due to serizalization issues with Uint8Array type. this loop below is to normalize the message to a basic array.
 *
 * @param toSign - The ArrayLike object to be converted.
 * @returns The converted array.
 */ const normalizeArray = (toSign)=>{
    const arr = [];
    // Casting ArrayLike to Uint8Array for better compatibility and avoiding Node-specific types
    const uint8Array = new Uint8Array(toSign);
    for(let i = 0; i < uint8Array.length; i++){
        arr.push(uint8Array[i]);
    }
    return arr;
};
exports.normalizeArray = normalizeArray; //# sourceMappingURL=normalize-array.js.map
}),
"[project]/node_modules/@lit-protocol/lit-node-client-nodejs/src/lib/helpers/normalize-params.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.normalizeJsParams = void 0;
/**
 * Normalize the `jsParams`, convert types before sending to Lit Actions as jsParams, some JS types don't serialize well, so we will convert them before sending to the nodes
 *
 * It converts both
 *
 * @param {any} jsParams - The jsParams you are sending to Lit Action
 *
 *  * @returns { object } The jsParams object, but with any incompatible types automatically converted
 */ const normalizeJsParams = (jsParams)=>{
    for (const key of Object.keys(jsParams)){
        const value = jsParams[key];
        if (ArrayBuffer.isView(value)) {
            // Correctly converting ArrayBuffer view to a standard array
            jsParams[key] = Array.from(new Uint8Array(value.buffer, value.byteOffset, value.byteLength));
        } else if (value instanceof ArrayBuffer) {
            // Correctly converting plain ArrayBuffer to a standard array
            jsParams[key] = Array.from(new Uint8Array(value));
        }
    }
    return jsParams;
};
exports.normalizeJsParams = normalizeJsParams; //# sourceMappingURL=normalize-params.js.map
}),
"[project]/node_modules/@lit-protocol/lit-node-client-nodejs/src/lib/helpers/parse-as-json-or-string.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parseAsJsonOrString = void 0;
const misc_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/misc/src/index.js [app-client] (ecmascript)");
/**
 * Parses a response string into a JS object.
 *
 * @param responseString - The response string to parse.
 * @returns The parsed response object.
 */ const parseAsJsonOrString = (responseString)=>{
    try {
        return JSON.parse(responseString);
    } catch (e) {
        (0, misc_1.log)('[parseResponses] Error parsing response as json.  Swallowing and returning as string.', responseString);
        return responseString;
    }
};
exports.parseAsJsonOrString = parseAsJsonOrString; //# sourceMappingURL=parse-as-json-or-string.js.map
}),
"[project]/node_modules/@lit-protocol/lit-node-client-nodejs/src/lib/helpers/parse-pkp-sign-response.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.parsePkpSignResponse = exports.cleanStringValues = exports.convertKeysToCamelCase = exports.snakeToCamel = void 0;
/**
 * Converts a snake_case string to camelCase.
 * @param s The snake_case string to convert.
 * @returns The camelCase version of the input string.
 *
 * @example
 * snakeToCamel('hello_world') // 'helloWorld'
 */ const snakeToCamel = (s)=>s.replace(/(_\w)/g, (m)=>m[1].toUpperCase());
exports.snakeToCamel = snakeToCamel;
/**
 * Converts the keys of an object from snake_case to camelCase.
 *
 * @param obj - The object whose keys need to be converted.
 * @returns The object with keys converted to camelCase.
 */ const convertKeysToCamelCase = (obj)=>Object.keys(obj).reduce((acc, key)=>({
            ...acc,
            [(0, exports.snakeToCamel)(key)]: obj[key]
        }), {});
exports.convertKeysToCamelCase = convertKeysToCamelCase;
/**
 * Removes double quotes from string values in an object.
 * @param obj - The object to clean string values from.
 * @returns A new object with string values cleaned.
 */ const cleanStringValues = (obj)=>Object.keys(obj).reduce((acc, key)=>({
            ...acc,
            [key]: typeof obj[key] === 'string' ? obj[key].replace(/"/g, '') : obj[key]
        }), {});
exports.cleanStringValues = cleanStringValues;
/**
 * Parses the PKP sign response data and transforms it into a standardised format.
 * @param responseData - The response data containing PKP sign shares.
 * @returns An array of objects with the signature data.
 */ const parsePkpSignResponse = (responseData)=>responseData.map(({ signatureShare })=>{
        // Remove 'result' key if it exists
        delete signatureShare.result;
        const camelCaseShare = (0, exports.convertKeysToCamelCase)(signatureShare);
        const cleanedShare = (0, exports.cleanStringValues)(camelCaseShare);
        // Change 'dataSigned' from 'digest'
        if (cleanedShare.digest) {
            cleanedShare.dataSigned = cleanedShare.digest;
        }
        return {
            signature: cleanedShare
        };
    });
exports.parsePkpSignResponse = parsePkpSignResponse; //# sourceMappingURL=parse-pkp-sign-response.js.map
}),
"[project]/node_modules/@lit-protocol/lit-node-client-nodejs/src/lib/helpers/process-lit-action-response-strategy.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.processLitActionResponseStrategy = void 0;
const misc_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/misc/src/index.js [app-client] (ecmascript)");
/**
 * Finds the most and least common object within an of objects array
 * @param responses any[]
 * @returns an object which contains both the least and most occuring item in the array
 */ const _findFrequency = (responses)=>{
    const sorted = responses.sort((a, b)=>responses.filter((v)=>v === a).length - responses.filter((v)=>v === b).length);
    return {
        min: sorted[0],
        max: sorted[sorted?.length - 1]
    };
};
const processLitActionResponseStrategy = (responses, strategy)=>{
    const executionResponses = responses.map((nodeResp)=>{
        return nodeResp.response;
    });
    const copiedExecutionResponses = executionResponses.map((r)=>{
        return '' + r;
    });
    if (strategy.strategy === 'custom') {
        try {
            if (strategy.customFilter) {
                const customResponseFilterResult = strategy?.customFilter(executionResponses);
                return customResponseFilterResult;
            } else {
                (0, misc_1.logError)('Custom filter specified for response strategy but none found. using most common');
            }
        } catch (e) {
            (0, misc_1.logError)('Error while executing custom response filter, defaulting to most common', e.toString());
        }
    }
    let respFrequency = _findFrequency(copiedExecutionResponses);
    if (strategy?.strategy === 'leastCommon') {
        (0, misc_1.log)('strategy found to be most common, taking most common response from execution results');
        return respFrequency.min;
    } else if (strategy?.strategy === 'mostCommon') {
        (0, misc_1.log)('strategy found to be most common, taking most common response from execution results');
        return respFrequency.max;
    } else {
        (0, misc_1.log)('no strategy found, using least common response object from execution results');
        respFrequency.min;
    }
};
exports.processLitActionResponseStrategy = processLitActionResponseStrategy; //# sourceMappingURL=process-lit-action-response-strategy.js.map
}),
"[project]/node_modules/@lit-protocol/lit-node-client-nodejs/src/lib/helpers/remove-double-quotes.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.removeDoubleQuotes = void 0;
/**
 * Sanitise strings in an object by removing double quotes.
 * - remove quotes from the signed data eg '"walup"' => 'walup'
 * @param obj The object to sanitize
 *
 * @returns The sanitized object
 */ const removeDoubleQuotes = (obj)=>{
    for (const key of Object.keys(obj)){
        const value = obj[key];
        for (const subkey of Object.keys(value)){
            if (typeof value[subkey] === 'string') {
                value[subkey] = value[subkey].replaceAll('"', '');
            }
        }
    }
    return obj;
};
exports.removeDoubleQuotes = removeDoubleQuotes; //# sourceMappingURL=remove-double-quotes.js.map
}),
"[project]/node_modules/@lit-protocol/lit-node-client-nodejs/src/lib/helpers/validate-bls-session-sig.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.blsSessionSigVerify = void 0;
const ethers_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-client] (ecmascript)");
const siwe_1 = __turbopack_context__.r("[project]/node_modules/siwe/dist/siwe.js [app-client] (ecmascript)");
const LIT_SESSION_SIGNED_MESSAGE_PREFIX = 'lit_session:';
/**
 * Verifies a BLS session signature.
 *
 * @param {Function} verifier - A wasm function that takes a public key, message, and signature to verify.
 * @param {string} networkPubKey - The public key of the network.
 * @param {AuthSig} authSig
 * @typedef {Object} AuthSig
 * @property {string} sig - The signature in string format.
 * @property {string} signedMessage - The message that was signed.
 */ const blsSessionSigVerify = async (verifier, networkPubKey, authSig, authSigSiweMessage)=>{
    let sigJson = JSON.parse(authSig.sig);
    // we do not nessesarly need to use ethers here but was a quick way
    // to get verification working.
    const eip191Hash = ethers_1.ethers.utils.hashMessage(authSig.signedMessage);
    const prefixedStr = LIT_SESSION_SIGNED_MESSAGE_PREFIX + eip191Hash.replace('0x', '');
    const prefixedEncoded = ethers_1.ethers.utils.toUtf8Bytes(prefixedStr);
    const shaHashed = ethers_1.ethers.utils.sha256(prefixedEncoded).replace('0x', '');
    const signatureBytes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(sigJson.ProofOfPossession, `hex`);
    /** Check time or now */ const checkTime = new Date();
    if (!authSigSiweMessage.expirationTime || !authSigSiweMessage.issuedAt) {
        throw new Error('Invalid SIWE message. Missing expirationTime or issuedAt.');
    }
    // check timestamp of SIWE
    const expirationDate = new Date(authSigSiweMessage.expirationTime);
    if (checkTime.getTime() >= expirationDate.getTime()) {
        throw new siwe_1.SiweError(siwe_1.SiweErrorType.EXPIRED_MESSAGE, `${checkTime.toISOString()} < ${expirationDate.toISOString()}`, `${checkTime.toISOString()} >= ${expirationDate.toISOString()}`);
    }
    const issuedAt = new Date(authSigSiweMessage.issuedAt);
    if (checkTime.getTime() < issuedAt.getTime()) {
        throw new siwe_1.SiweError(siwe_1.SiweErrorType.NOT_YET_VALID_MESSAGE, `${checkTime.toISOString()} >= ${issuedAt.toISOString()}`, `${checkTime.toISOString()} < ${issuedAt.toISOString()}`);
    }
    await verifier(networkPubKey, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(shaHashed, 'hex'), signatureBytes);
};
exports.blsSessionSigVerify = blsSessionSigVerify; //# sourceMappingURL=validate-bls-session-sig.js.map
}),
"[project]/node_modules/@lit-protocol/lit-node-client-nodejs/src/lib/lit-node-client-nodejs.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LitNodeClientNodeJs = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/tslib/tslib.es6.js [app-client] (ecmascript)");
const transactions_1 = __turbopack_context__.r("[project]/node_modules/@ethersproject/transactions/lib.esm/index.js [app-client] (ecmascript)");
const ethers_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib.esm/index.js [app-client] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/ethers/lib/utils.js [app-client] (ecmascript)");
const siwe_1 = __turbopack_context__.r("[project]/node_modules/siwe/dist/siwe.js [app-client] (ecmascript)");
const Hash = tslib_1.__importStar(__turbopack_context__.r("[project]/node_modules/typestub-ipfs-only-hash/index.js [app-client] (ecmascript)"));
const auth_helpers_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/@lit-protocol/auth-helpers/src/index.js [app-client] (ecmascript)");
const constants_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/@lit-protocol/constants/src/index.js [app-client] (ecmascript)");
const core_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/core/src/index.js [app-client] (ecmascript)");
const crypto_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/crypto/src/index.js [app-client] (ecmascript)");
const misc_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/misc/src/index.js [app-client] (ecmascript)");
const misc_browser_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/misc-browser/src/index.js [app-client] (ecmascript)");
const nacl_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/nacl/src/index.js [app-client] (ecmascript)");
const uint8arrays_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/uint8arrays/src/index.js [app-client] (ecmascript)");
const encode_code_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/src/lib/helpers/encode-code.js [app-client] (ecmascript)");
const get_bls_signatures_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/src/lib/helpers/get-bls-signatures.js [app-client] (ecmascript)");
const get_claims_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/src/lib/helpers/get-claims.js [app-client] (ecmascript)");
const get_claims_list_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/src/lib/helpers/get-claims-list.js [app-client] (ecmascript)");
const get_signatures_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/src/lib/helpers/get-signatures.js [app-client] (ecmascript)");
const normalize_array_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/src/lib/helpers/normalize-array.js [app-client] (ecmascript)");
const normalize_params_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/src/lib/helpers/normalize-params.js [app-client] (ecmascript)");
const parse_as_json_or_string_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/src/lib/helpers/parse-as-json-or-string.js [app-client] (ecmascript)");
const parse_pkp_sign_response_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/src/lib/helpers/parse-pkp-sign-response.js [app-client] (ecmascript)");
const process_lit_action_response_strategy_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/src/lib/helpers/process-lit-action-response-strategy.js [app-client] (ecmascript)");
const remove_double_quotes_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/src/lib/helpers/remove-double-quotes.js [app-client] (ecmascript)");
const validate_bls_session_sig_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/src/lib/helpers/validate-bls-session-sig.js [app-client] (ecmascript)");
class LitNodeClientNodeJs extends core_1.LitCore {
    // ========== Constructor ==========
    constructor(args){
        if (!args) {
            throw new constants_1.ParamsMissingError({}, 'must provide LitNodeClient parameters');
        }
        super(args);
        // ========== Rate Limit NFT ==========
        // TODO: Add support for browser feature/lit-2321-js-sdk-add-browser-support-for-createCapacityDelegationAuthSig
        this.createCapacityDelegationAuthSig = async (params)=>{
            // -- validate
            if (!params.dAppOwnerWallet) {
                throw new constants_1.InvalidParamType({
                    info: {
                        params
                    }
                }, 'dAppOwnerWallet must exist');
            }
            // Useful log for debugging
            if (!params.delegateeAddresses || params.delegateeAddresses.length === 0) {
                (0, misc_1.log)(`[createCapacityDelegationAuthSig] 'delegateeAddresses' is an empty array. It means that no body can use it. However, if the 'delegateeAddresses' field is omitted, It means that the capability will not restrict access based on delegatee list, but it may still enforce other restrictions such as usage limits (uses) and specific NFT IDs (nft_id).`);
            }
            // -- This is the owner address who holds the Capacity Credits NFT token and wants to delegate its
            // usage to a list of delegatee addresses
            const dAppOwnerWalletAddress = ethers_1.ethers.utils.getAddress(await params.dAppOwnerWallet.getAddress());
            // -- if it's not ready yet, then connect
            if (!this.ready) {
                await this.connect();
            }
            const siweMessage = await (0, auth_helpers_1.createSiweMessageWithCapacityDelegation)({
                uri: 'lit:capability:delegation',
                litNodeClient: this,
                walletAddress: dAppOwnerWalletAddress,
                nonce: await this.getLatestBlockhash(),
                expiration: params.expiration,
                domain: params.domain,
                statement: params.statement,
                // -- capacity delegation specific configuration
                uses: params.uses,
                delegateeAddresses: params.delegateeAddresses,
                capacityTokenId: params.capacityTokenId
            });
            const authSig = await (0, auth_helpers_1.generateAuthSig)({
                signer: params.dAppOwnerWallet,
                toSign: siweMessage
            });
            return {
                capacityDelegationAuthSig: authSig
            };
        };
        // ========== Scoped Class Helpers ==========
        /**
         *
         * we need to send jwt params iat (issued at) and exp (expiration) because the nodes may have different wall clock times, the nodes will verify that these params are withing a grace period
         *
         */ this.getJWTParams = ()=>{
            const now = Date.now();
            const iat = Math.floor(now / 1000);
            const exp = iat + 12 * 60 * 60; // 12 hours in seconds
            return {
                iat,
                exp
            };
        };
        // ==================== SESSIONS ====================
        /**
         * Try to get the session key in the local storage,
         * if not, generates one.
         * @return { SessionKeyPair } session key pair
         */ this.getSessionKey = ()=>{
            const storageKey = constants_1.LOCAL_STORAGE_KEYS.SESSION_KEY;
            const storedSessionKeyOrError = (0, misc_browser_1.getStorageItem)(storageKey);
            if (storedSessionKeyOrError.type === constants_1.EITHER_TYPE.ERROR || !storedSessionKeyOrError.result || storedSessionKeyOrError.result === '') {
                console.warn(`Storage key "${storageKey}" is missing. Not a problem. Continue...`);
                // Generate new one
                const newSessionKey = (0, crypto_1.generateSessionKeyPair)();
                // (TRY) to set to local storage
                try {
                    localStorage.setItem(storageKey, JSON.stringify(newSessionKey));
                } catch (e) {
                    (0, misc_1.log)(`[getSessionKey] Localstorage not available.Not a problem. Continue...`);
                }
                return newSessionKey;
            } else {
                return JSON.parse(storedSessionKeyOrError.result);
            }
        };
        // backward compatibility
        this.getExpiration = ()=>{
            return LitNodeClientNodeJs.getExpiration();
        };
        /**
         *
         * Get the signature from local storage, if not, generates one
         *
         */ this.getWalletSig = async ({ authNeededCallback, chain, sessionCapabilityObject, switchChain, expiration, sessionKeyUri, nonce, resourceAbilityRequests, litActionCode, litActionIpfsId, jsParams, sessionKey, domain })=>{
            let walletSig;
            const storageKey = constants_1.LOCAL_STORAGE_KEYS.WALLET_SIGNATURE;
            const storedWalletSigOrError = (0, misc_browser_1.getStorageItem)(storageKey);
            // browser: 2 > 2.1 > 3
            // nodejs: 1. > 1.1
            // -- (TRY) to get it in the local storage
            // -- IF NOT: Generates one
            (0, misc_1.log)(`getWalletSig - flow starts
        storageKey: ${storageKey}
        storedWalletSigOrError: ${JSON.stringify(storedWalletSigOrError)}
    `);
            if (storedWalletSigOrError.type === constants_1.EITHER_TYPE.ERROR || !storedWalletSigOrError.result || storedWalletSigOrError.result == '') {
                (0, misc_1.log)('getWalletSig - flow 1');
                console.warn(`Storage key "${storageKey}" is missing. Not a problem. Continue...`);
                if (authNeededCallback) {
                    (0, misc_1.log)('getWalletSig - flow 1.1');
                    const body = {
                        chain,
                        statement: sessionCapabilityObject?.statement,
                        resources: sessionCapabilityObject ? [
                            sessionCapabilityObject.encodeAsSiweResource()
                        ] : undefined,
                        ...switchChain && {
                            switchChain
                        },
                        expiration,
                        uri: sessionKeyUri,
                        sessionKey: sessionKey,
                        nonce,
                        domain,
                        // for recap
                        ...resourceAbilityRequests && {
                            resourceAbilityRequests
                        },
                        // for lit action custom auth
                        ...litActionCode && {
                            litActionCode
                        },
                        ...litActionIpfsId && {
                            litActionIpfsId
                        },
                        ...jsParams && {
                            jsParams
                        }
                    };
                    (0, misc_1.log)('callback body:', body);
                    walletSig = await authNeededCallback(body);
                } else {
                    (0, misc_1.log)('getWalletSig - flow 1.2');
                    if (!this.defaultAuthCallback) {
                        (0, misc_1.log)('getWalletSig - flow 1.2.1');
                        throw new constants_1.ParamsMissingError({}, 'No authNeededCallback nor default auth callback provided');
                    }
                    (0, misc_1.log)('getWalletSig - flow 1.2.2');
                    walletSig = await this.defaultAuthCallback({
                        chain,
                        statement: sessionCapabilityObject.statement,
                        resources: sessionCapabilityObject ? [
                            sessionCapabilityObject.encodeAsSiweResource()
                        ] : undefined,
                        switchChain,
                        expiration,
                        uri: sessionKeyUri,
                        nonce,
                        domain
                    });
                }
                (0, misc_1.log)('getWalletSig - flow 1.3');
                // (TRY) to set walletSig to local storage
                const storeNewWalletSigOrError = (0, misc_browser_1.setStorageItem)(storageKey, JSON.stringify(walletSig));
                if (storeNewWalletSigOrError.type === 'ERROR') {
                    (0, misc_1.log)('getWalletSig - flow 1.4');
                    console.warn(`Unable to store walletSig in local storage. Not a problem. Continue...`);
                }
            } else {
                (0, misc_1.log)('getWalletSig - flow 2');
                try {
                    walletSig = JSON.parse(storedWalletSigOrError.result);
                    (0, misc_1.log)('getWalletSig - flow 2.1');
                } catch (e) {
                    console.warn('Error parsing walletSig', e);
                    (0, misc_1.log)('getWalletSig - flow 2.2');
                }
            }
            (0, misc_1.log)('getWalletSig - flow 3');
            return walletSig;
        };
        this._authCallbackAndUpdateStorageItem = async ({ authCallbackParams, authCallback })=>{
            let authSig;
            if (authCallback) {
                authSig = await authCallback(authCallbackParams);
            } else {
                if (!this.defaultAuthCallback) {
                    throw new constants_1.ParamsMissingError({}, 'No authCallback nor default auth callback provided');
                }
                authSig = await this.defaultAuthCallback(authCallbackParams);
            }
            // (TRY) to set walletSig to local storage
            const storeNewWalletSigOrError = (0, misc_browser_1.setStorageItem)(constants_1.LOCAL_STORAGE_KEYS.WALLET_SIGNATURE, JSON.stringify(authSig));
            if (storeNewWalletSigOrError.type === constants_1.EITHER_TYPE.SUCCESS) {
                return authSig;
            }
            // Setting local storage failed, try to remove the item key.
            console.warn(`Unable to store walletSig in local storage. Not a problem. Continuing to remove item key...`);
            const removeWalletSigOrError = (0, misc_browser_1.removeStorageItem)(constants_1.LOCAL_STORAGE_KEYS.WALLET_SIGNATURE);
            if (removeWalletSigOrError.type === constants_1.EITHER_TYPE.ERROR) {
                console.warn(`Unable to remove walletSig in local storage. Not a problem. Continuing...`);
            }
            return authSig;
        };
        /**
         *
         * Check if a session key needs to be resigned. These are the scenarios where a session key needs to be resigned:
         * 1. The authSig.sig does not verify successfully against the authSig.signedMessage
         * 2. The authSig.signedMessage.uri does not match the sessionKeyUri
         * 3. The authSig.signedMessage does not contain at least one session capability object
         *
         */ this.checkNeedToResignSessionKey = async ({ authSig, sessionKeyUri, resourceAbilityRequests })=>{
            const authSigSiweMessage = new siwe_1.SiweMessage(authSig.signedMessage);
            // We will either have `ed25519` or `LIT_BLS` as we have deviated from the specification of SIWE and use BLS signatures in some cases
            // Here we need to check the `algo` of the SIWE to confirm we can validate the signature as if we attempt to validate the BLS signature here
            // it will fail. If the  algo is not defined we can assume that it was an EOA wallet signing the message so we can use SIWE.
            if (authSig.algo === `ed25519` || authSig.algo === undefined) {
                try {
                    await authSigSiweMessage.verify({
                        signature: authSig.sig
                    }, {
                        suppressExceptions: false
                    });
                } catch (e) {
                    (0, misc_1.log)(`Error while verifying BLS signature: `, e);
                    return true;
                }
            } else if (authSig.algo === `LIT_BLS`) {
                try {
                    await (0, validate_bls_session_sig_1.blsSessionSigVerify)(crypto_1.verifySignature, this.networkPubKey, authSig, authSigSiweMessage);
                } catch (e) {
                    (0, misc_1.log)(`Error while verifying bls signature: `, e);
                    return true;
                }
            } else {
                throw new constants_1.InvalidSignatureError({
                    info: {
                        authSig,
                        resourceAbilityRequests,
                        sessionKeyUri
                    }
                }, 'Unsupported signature algo for session signature. Expected ed25519 or LIT_BLS received %s', authSig.algo);
            }
            // make sure the sig is for the correct session key
            if (authSigSiweMessage.uri !== sessionKeyUri) {
                (0, misc_1.log)('Need retry because uri does not match');
                return true;
            }
            // make sure the authSig contains at least one resource.
            if (!authSigSiweMessage.resources || authSigSiweMessage.resources.length === 0) {
                (0, misc_1.log)('Need retry because empty resources');
                return true;
            }
            // make sure the authSig contains session capabilities that can be parsed.
            // TODO: we currently only support the first resource being a session capability object.
            const authSigSessionCapabilityObject = (0, auth_helpers_1.decode)(authSigSiweMessage.resources[0]);
            // make sure the authSig session capability object describes capabilities that are equal or greater than
            // the abilities requested against the resources in the resource ability requests.
            for (const resourceAbilityRequest of resourceAbilityRequests){
                if (!authSigSessionCapabilityObject.verifyCapabilitiesForResource(resourceAbilityRequest.resource, resourceAbilityRequest.ability)) {
                    (0, misc_1.log)('Need retry because capabilities do not match', {
                        authSigSessionCapabilityObject,
                        resourceAbilityRequest
                    });
                    return true;
                }
            }
            return false;
        };
        // ==================== API Calls to Nodes ====================
        /**
         *
         * Combine Shares from network public key set and signature shares
         *
         * @param { NodeBlsSigningShare } signatureShares
         *
         * @returns { string } final JWT (convert the sig to base64 and append to the jwt)
         *
         */ this.combineSharesAndGetJWT = async (signatureShares, requestId = '')=>{
            // ========== Shares Validations ==========
            // -- sanity check
            if (!signatureShares.every((val, i, arr)=>val.unsignedJwt === arr[0].unsignedJwt)) {
                const msg = 'Unsigned JWT is not the same from all the nodes.  This means the combined signature will be bad because the nodes signed the wrong things';
                (0, misc_1.logErrorWithRequestId)(requestId, msg);
            }
            // ========== Sorting ==========
            // -- sort the sig shares by share index.  this is important when combining the shares.
            signatureShares.sort((a, b)=>a.shareIndex - b.shareIndex);
            // ========== Combine Shares ==========
            const signature = await (0, crypto_1.combineSignatureShares)(signatureShares.map((s)=>s.signatureShare));
            (0, misc_1.logWithRequestId)(requestId, 'signature is', signature);
            const unsignedJwt = (0, misc_1.mostCommonString)(signatureShares.map((s)=>s.unsignedJwt));
            // ========== Result ==========
            // convert the sig to base64 and append to the jwt
            const finalJwt = `${unsignedJwt}.${(0, uint8arrays_1.uint8arrayToString)((0, uint8arrays_1.uint8arrayFromString)(signature, 'base16'), 'base64urlpad')}`;
            return finalJwt;
        };
        this._decryptWithSignatureShares = (networkPubKey, identityParam, ciphertext, signatureShares)=>{
            const sigShares = signatureShares.map((s)=>s.signatureShare);
            return (0, crypto_1.verifyAndDecryptWithSignatureShares)(networkPubKey, identityParam, ciphertext, sigShares);
        };
        // ========== Promise Handlers ==========
        this.getIpfsId = async ({ str })=>{
            return await Hash.of(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(str));
        };
        /**
         * Run lit action on a single deterministicly selected node. It's important that the nodes use the same deterministic selection algorithm.
         *
         * Lit Action: dataToHash -> IPFS CID
         * QmUjX8MW6StQ7NKNdaS6g4RMkvN5hcgtKmEi8Mca6oX4t3
         *
         * @param { ExecuteJsProps } params
         *
         * @returns { Promise<SuccessNodePromises<T> | RejectedNodePromises> }
         *
         */ this.runOnTargetedNodes = async (params)=>{
            (0, misc_1.log)('running runOnTargetedNodes:', params.targetNodeRange);
            if (!params.targetNodeRange) {
                throw new constants_1.InvalidParamType({
                    info: {
                        params
                    }
                }, 'targetNodeRange is required');
            }
            if (!params.code) {
                throw new constants_1.InvalidParamType({
                    info: {
                        params
                    }
                }, 'code is required');
            }
            // determine which node to run on
            const ipfsId = await this.getIpfsId({
                str: params.code
            });
            // select targetNodeRange number of random index of the bootstrapUrls.length
            const randomSelectedNodeIndexes = [];
            let nodeCounter = 0;
            while(randomSelectedNodeIndexes.length < params.targetNodeRange){
                const str = `${nodeCounter}:${ipfsId.toString()}`;
                const cidBuffer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(str);
                const hash = (0, utils_1.sha256)(cidBuffer);
                const hashAsNumber = ethers_1.BigNumber.from(hash);
                const nodeIndex = hashAsNumber.mod(this.config.bootstrapUrls.length).toNumber();
                (0, misc_1.log)('nodeIndex:', nodeIndex);
                // must be unique & less than bootstrapUrls.length
                if (!randomSelectedNodeIndexes.includes(nodeIndex) && nodeIndex < this.config.bootstrapUrls.length) {
                    randomSelectedNodeIndexes.push(nodeIndex);
                }
                nodeCounter++;
            }
            (0, misc_1.log)('Final Selected Indexes:', randomSelectedNodeIndexes);
            const requestId = this._getNewRequestId();
            const nodePromises = [];
            for(let i = 0; i < randomSelectedNodeIndexes.length; i++){
                // should we mix in the jsParams?  to do this, we need a canonical way to serialize the jsParams object that will be identical in rust.
                // const jsParams = params.jsParams || {};
                // const jsParamsString = JSON.stringify(jsParams);
                const nodeIndex = randomSelectedNodeIndexes[i];
                // FIXME: we are using this.config.bootstrapUrls to pick the selected node, but we
                // should be using something like the list of nodes from the staking contract
                // because the staking nodes can change, and the rust code will use the same list
                const url = this.config.bootstrapUrls[nodeIndex];
                (0, misc_1.log)(`running on node ${nodeIndex} at ${url}`);
                // -- choose the right signature
                const sessionSig = this.getSessionSigByUrl({
                    sessionSigs: params.sessionSigs,
                    url
                });
                const reqBody = {
                    ...params,
                    targetNodeRange: params.targetNodeRange,
                    authSig: sessionSig
                };
                // this return { url: string, data: JsonRequest }
                // const singleNodePromise = this.getJsExecutionShares(url, reqBody, id);
                const singleNodePromise = this.sendCommandToNode({
                    url: url,
                    data: params,
                    requestId: requestId
                });
                nodePromises.push(singleNodePromise);
            }
            return await this.handleNodePromises(nodePromises, requestId, params.targetNodeRange);
        };
        /**
         *
         * Execute JS on the nodes and combine and return any resulting signatures
         *
         * @param { JsonExecutionSdkParams } params
         *
         * @returns { ExecuteJsResponse }
         *
         */ this.executeJs = async (params)=>{
            // ========== Validate Params ==========
            if (!this.ready) {
                const message = '[executeJs] LitNodeClient is not ready. Please call await litNodeClient.connect() first.';
                throw new constants_1.LitNodeClientNotReadyError({}, message);
            }
            const paramsIsSafe = (0, misc_1.safeParams)({
                functionName: 'executeJs',
                params: params
            });
            if (!paramsIsSafe) {
                throw new constants_1.InvalidParamType({
                    info: {
                        params
                    }
                }, 'executeJs params are not valid');
            }
            // validate session sigs
            const checkedSessionSigs = (0, misc_1.validateSessionSigs)(params.sessionSigs);
            if (checkedSessionSigs.isValid === false) {
                throw new constants_1.InvalidSessionSigs({}, `Invalid sessionSigs. Errors: ${checkedSessionSigs.errors}`);
            }
            // Format the params
            let formattedParams = {
                ...params,
                ...params.jsParams && {
                    jsParams: (0, normalize_params_1.normalizeJsParams)(params.jsParams)
                },
                ...params.code && {
                    code: (0, encode_code_1.encodeCode)(params.code)
                }
            };
            // Check if IPFS options are provided and if the code should be fetched from IPFS and overwrite the current code.
            // This will fetch the code from the specified IPFS gateway using the provided ipfsId,
            // and update the params with the fetched code, removing the ipfsId afterward.
            const overwriteCode = params.ipfsOptions?.overwriteCode || constants_1.GLOBAL_OVERWRITE_IPFS_CODE_BY_NETWORK[this.config.litNetwork];
            if (overwriteCode && params.ipfsId) {
                const code = await this._getFallbackIpfsCode(params.ipfsOptions?.gatewayUrl, params.ipfsId);
                formattedParams = {
                    ...params,
                    code: code,
                    ipfsId: undefined
                };
            }
            const requestId = this._getNewRequestId();
            // ========== Get Node Promises ==========
            // Handle promises for commands sent to Lit nodes
            const getNodePromises = async ()=>{
                if (params.useSingleNode) {
                    return this.getRandomNodePromise((url)=>this.executeJsNodeRequest(url, formattedParams, requestId));
                }
                return this.getNodePromises((url)=>this.executeJsNodeRequest(url, formattedParams, requestId));
            };
            const nodePromises = await getNodePromises();
            // -- resolve promises
            const res = await this.handleNodePromises(nodePromises, requestId, params.useSingleNode ? 1 : this.connectedNodes.size);
            // -- case: promises rejected
            if (!res.success) {
                this._throwNodeError(res, requestId);
            }
            // -- case: promises success (TODO: check the keys of "values")
            const responseData = res.values;
            (0, misc_1.logWithRequestId)(requestId, 'executeJs responseData from node : ', JSON.stringify(responseData, null, 2));
            // -- find the responseData that has the most common response
            const mostCommonResponse = (0, misc_1.findMostCommonResponse)(responseData);
            const responseFromStrategy = (0, process_lit_action_response_strategy_1.processLitActionResponseStrategy)(responseData, params.responseStrategy ?? {
                strategy: 'leastCommon'
            });
            mostCommonResponse.response = responseFromStrategy;
            const isSuccess = mostCommonResponse.success;
            const hasSignedData = Object.keys(mostCommonResponse.signedData).length > 0;
            const hasClaimData = Object.keys(mostCommonResponse.claimData).length > 0;
            // -- we must also check for claim responses as a user may have submitted for a claim and signatures must be aggregated before returning
            if (isSuccess && !hasSignedData && !hasClaimData) {
                return mostCommonResponse;
            }
            // -- in the case where we are not signing anything on Lit action and using it as purely serverless function
            if (!hasSignedData && !hasClaimData) {
                return {
                    claims: {},
                    signatures: null,
                    decryptions: [],
                    response: mostCommonResponse.response,
                    logs: mostCommonResponse.logs
                };
            }
            // ========== Extract shares from response data ==========
            // -- 1. combine signed data as a list, and get the signatures from it
            const signedDataList = responseData.map((r)=>{
                return (0, remove_double_quotes_1.removeDoubleQuotes)(r.signedData);
            });
            (0, misc_1.logWithRequestId)(requestId, 'signatures shares to combine: ', signedDataList);
            const signatures = await (0, get_signatures_1.getSignatures)({
                requestId,
                networkPubKeySet: this.networkPubKeySet,
                minNodeCount: params.useSingleNode ? 1 : this.config.minNodeCount,
                signedData: signedDataList
            });
            // -- 2. combine responses as a string, and parse it as JSON if possible
            const parsedResponse = (0, parse_as_json_or_string_1.parseAsJsonOrString)(mostCommonResponse.response);
            // -- 3. combine logs
            const mostCommonLogs = (0, misc_1.mostCommonString)(responseData.map((r)=>r.logs));
            // -- 4. combine claims
            const claimsList = (0, get_claims_list_1.getClaimsList)(responseData);
            const claims = claimsList.length > 0 ? (0, get_claims_1.getClaims)(claimsList) : undefined;
            // ========== Result ==========
            const returnVal = {
                claims,
                signatures,
                // decryptions: [],
                response: parsedResponse,
                logs: mostCommonLogs
            };
            (0, misc_1.log)('returnVal:', returnVal);
            return returnVal;
        };
        /**
         * Generates a promise by sending a command to the Lit node
         *
         * @param url - The URL to send the command to.
         * @param params - The parameters to include in the command.
         * @param requestId - The ID of the request.
         * @returns A promise that resolves with the response from the server.
         */ this.generatePromise = async (url, params, requestId)=>{
            return await this.sendCommandToNode({
                url,
                data: params,
                requestId
            });
        };
        /**
         * Use PKP to sign
         *
         * @param { JsonPkpSignSdkParams } params
         * @param params.toSign - The data to sign
         * @param params.pubKey - The public key to sign with
         * @param params.sessionSigs - The session signatures to use
         * @param params.authMethods - (optional) The auth methods to use
         */ this.pkpSign = async (params)=>{
            // -- validate required params
            const requiredParamKeys = [
                'toSign',
                'pubKey'
            ];
            requiredParamKeys.forEach((key)=>{
                if (!params[key]) {
                    throw new constants_1.ParamNullError({
                        info: {
                            params,
                            key
                        }
                    }, `"%s" cannot be undefined, empty, or null. Please provide a valid value.`, key);
                }
            });
            // -- validate present of accepted auth methods
            if (!params.sessionSigs && (!params.authMethods || params.authMethods.length <= 0)) {
                throw new constants_1.ParamNullError({
                    info: {
                        params
                    }
                }, 'Either sessionSigs or authMethods (length > 0) must be present.');
            }
            const requestId = this._getNewRequestId();
            // validate session sigs
            const checkedSessionSigs = (0, misc_1.validateSessionSigs)(params.sessionSigs);
            if (checkedSessionSigs.isValid === false) {
                throw new constants_1.InvalidSessionSigs({}, `Invalid sessionSigs. Errors: ${checkedSessionSigs.errors}`);
            }
            // ========== Get Node Promises ==========
            // Handle promises for commands sent to Lit nodes
            const nodePromises = this.getNodePromises((url)=>{
                // -- get the session sig from the url key
                const sessionSig = this.getSessionSigByUrl({
                    sessionSigs: params.sessionSigs,
                    url
                });
                const reqBody = {
                    toSign: (0, normalize_array_1.normalizeArray)(params.toSign),
                    pubkey: (0, misc_1.hexPrefixed)(params.pubKey),
                    authSig: sessionSig,
                    // -- optional params
                    ...params.authMethods && params.authMethods.length > 0 && {
                        authMethods: params.authMethods
                    }
                };
                (0, misc_1.logWithRequestId)(requestId, 'reqBody:', reqBody);
                const urlWithPath = (0, core_1.composeLitUrl)({
                    url,
                    endpoint: constants_1.LIT_ENDPOINT.PKP_SIGN
                });
                return this.generatePromise(urlWithPath, reqBody, requestId);
            });
            const res = await this.handleNodePromises(nodePromises, requestId, this.connectedNodes.size);
            // ========== Handle Response ==========
            // -- case: promises rejected
            if (!res.success) {
                this._throwNodeError(res, requestId);
            }
            // -- case: promises success (TODO: check the keys of "values")
            const responseData = res.values;
            (0, misc_1.logWithRequestId)(requestId, 'responseData', JSON.stringify(responseData, null, 2));
            // ========== Extract shares from response data ==========
            // -- 1. combine signed data as a list, and get the signatures from it
            const signedDataList = (0, parse_pkp_sign_response_1.parsePkpSignResponse)(responseData);
            const signatures = await (0, get_signatures_1.getSignatures)({
                requestId,
                networkPubKeySet: this.networkPubKeySet,
                minNodeCount: this.config.minNodeCount,
                signedData: signedDataList
            });
            (0, misc_1.logWithRequestId)(requestId, `signature combination`, signatures);
            return signatures.signature; // only a single signature is ever present, so we just return it.
        };
        /**
         *
         * Encrypt data using the LIT network public key.
         *
         * @param { EncryptSdkParams } params
         * @param params.dataToEncrypt - The data to encrypt
         * @param params.accessControlConditions - (optional) The access control conditions for the data
         * @param params.evmContractConditions - (optional) The EVM contract conditions for the data
         * @param params.solRpcConditions - (optional) The Solidity RPC conditions for the data
         * @param params.unifiedAccessControlConditions - (optional) The unified access control conditions for the data
         *
         * @return { Promise<EncryptResponse> } The encrypted ciphertext and the hash of the data
         *
         * @throws { Error } if the LIT node client is not ready
         * @throws { Error } if the subnetPubKey is null
         */ this.encrypt = async (params)=>{
            // ========== Validate Params ==========
            // -- validate if it's ready
            if (!this.ready) {
                throw new constants_1.LitNodeClientNotReadyError({}, '6 LitNodeClient is not ready.  Please call await litNodeClient.connect() first.');
            }
            // -- validate if this.subnetPubKey is null
            if (!this.subnetPubKey) {
                throw new constants_1.LitNodeClientNotReadyError({}, 'subnetPubKey cannot be null');
            }
            const paramsIsSafe = (0, misc_1.safeParams)({
                functionName: 'encrypt',
                params
            });
            if (!paramsIsSafe) {
                throw new constants_1.InvalidArgumentException({
                    info: {
                        params
                    }
                }, 'You must provide either accessControlConditions or evmContractConditions or solRpcConditions or unifiedAccessControlConditions');
            }
            // ========== Validate Access Control Conditions Schema ==========
            await this.validateAccessControlConditionsSchema(params);
            // ========== Hashing Access Control Conditions =========
            // hash the access control conditions
            const hashOfConditions = await this.getHashedAccessControlConditions(params);
            (0, misc_1.log)('hashOfConditions', hashOfConditions);
            if (!hashOfConditions) {
                throw new constants_1.InvalidArgumentException({
                    info: {
                        params
                    }
                }, 'You must provide either accessControlConditions or evmContractConditions or solRpcConditions or unifiedAccessControlConditions');
            }
            const hashOfConditionsStr = (0, uint8arrays_1.uint8arrayToString)(new Uint8Array(hashOfConditions), 'base16');
            (0, misc_1.log)('hashOfConditionsStr', hashOfConditionsStr);
            // ========== Hashing Private Data ==========
            // hash the private data
            const hashOfPrivateData = await crypto.subtle.digest('SHA-256', params.dataToEncrypt);
            (0, misc_1.log)('hashOfPrivateData', hashOfPrivateData);
            const hashOfPrivateDataStr = (0, uint8arrays_1.uint8arrayToString)(new Uint8Array(hashOfPrivateData), 'base16');
            (0, misc_1.log)('hashOfPrivateDataStr', hashOfPrivateDataStr);
            // ========== Assemble identity parameter ==========
            const identityParam = this._getIdentityParamForEncryption(hashOfConditionsStr, hashOfPrivateDataStr);
            (0, misc_1.log)('identityParam', identityParam);
            // ========== Encrypt ==========
            const ciphertext = await (0, crypto_1.encrypt)(this.subnetPubKey, params.dataToEncrypt, (0, uint8arrays_1.uint8arrayFromString)(identityParam, 'utf8'));
            return {
                ciphertext,
                dataToEncryptHash: hashOfPrivateDataStr
            };
        };
        /**
         *
         * Decrypt ciphertext with the LIT network.
         *
         */ this.decrypt = async (params)=>{
            const { sessionSigs, authSig, chain, ciphertext, dataToEncryptHash } = params;
            // ========== Validate Params ==========
            // -- validate if it's ready
            if (!this.ready) {
                throw new constants_1.LitNodeClientNotReadyError({}, '6 LitNodeClient is not ready.  Please call await litNodeClient.connect() first.');
            }
            // -- validate if this.subnetPubKey is null
            if (!this.subnetPubKey) {
                throw new constants_1.LitNodeClientNotReadyError({}, 'subnetPubKey cannot be null');
            }
            const paramsIsSafe = (0, misc_1.safeParams)({
                functionName: 'decrypt',
                params
            });
            if (!paramsIsSafe) {
                throw new constants_1.InvalidArgumentException({
                    info: {
                        params
                    }
                }, 'Parameter validation failed.');
            }
            // ========== Hashing Access Control Conditions =========
            // hash the access control conditions
            const hashOfConditions = await this.getHashedAccessControlConditions(params);
            (0, misc_1.log)('hashOfConditions', hashOfConditions);
            if (!hashOfConditions) {
                throw new constants_1.InvalidArgumentException({
                    info: {
                        params
                    }
                }, 'You must provide either accessControlConditions or evmContractConditions or solRpcConditions or unifiedAccessControlConditions');
            }
            const hashOfConditionsStr = (0, uint8arrays_1.uint8arrayToString)(new Uint8Array(hashOfConditions), 'base16');
            (0, misc_1.log)('hashOfConditionsStr', hashOfConditionsStr);
            // ========== Formatting Access Control Conditions =========
            const { error, formattedAccessControlConditions, formattedEVMContractConditions, formattedSolRpcConditions, formattedUnifiedAccessControlConditions } = this.getFormattedAccessControlConditions(params);
            if (error) {
                throw new constants_1.InvalidArgumentException({
                    info: {
                        params
                    }
                }, 'You must provide either accessControlConditions or evmContractConditions or solRpcConditions or unifiedAccessControlConditions');
            }
            // ========== Assemble identity parameter ==========
            const identityParam = this._getIdentityParamForEncryption(hashOfConditionsStr, dataToEncryptHash);
            (0, misc_1.log)('identityParam', identityParam);
            // ========== Get Network Signature ==========
            const requestId = this._getNewRequestId();
            const nodePromises = this.getNodePromises((url)=>{
                // -- if session key is available, use it
                const authSigToSend = sessionSigs ? sessionSigs[url] : authSig;
                if (!authSigToSend) {
                    throw new constants_1.InvalidArgumentException({
                        info: {
                            params
                        }
                    }, 'authSig is required');
                }
                const reqBody = {
                    accessControlConditions: formattedAccessControlConditions,
                    evmContractConditions: formattedEVMContractConditions,
                    solRpcConditions: formattedSolRpcConditions,
                    unifiedAccessControlConditions: formattedUnifiedAccessControlConditions,
                    dataToEncryptHash,
                    chain,
                    authSig: authSigToSend,
                    epoch: this.currentEpochNumber
                };
                const urlWithParh = (0, core_1.composeLitUrl)({
                    url,
                    endpoint: constants_1.LIT_ENDPOINT.ENCRYPTION_SIGN
                });
                return this.generatePromise(urlWithParh, reqBody, requestId);
            });
            // -- resolve promises
            const res = await this.handleNodePromises(nodePromises, requestId, this.config.minNodeCount);
            // -- case: promises rejected
            if (!res.success) {
                this._throwNodeError(res, requestId);
            }
            const signatureShares = res.values;
            (0, misc_1.logWithRequestId)(requestId, 'signatureShares', signatureShares);
            // ========== Result ==========
            const decryptedData = await this._decryptWithSignatureShares(this.subnetPubKey, (0, uint8arrays_1.uint8arrayFromString)(identityParam, 'utf8'), ciphertext, signatureShares);
            return {
                decryptedData
            };
        };
        this.getLitResourceForEncryption = async (params)=>{
            // ========== Hashing Access Control Conditions =========
            // hash the access control conditions
            const hashOfConditions = await this.getHashedAccessControlConditions(params);
            (0, misc_1.log)('hashOfConditions', hashOfConditions);
            if (!hashOfConditions) {
                throw new constants_1.InvalidArgumentException({
                    info: {
                        params
                    }
                }, 'You must provide either accessControlConditions or evmContractConditions or solRpcConditions or unifiedAccessControlConditions');
            }
            const hashOfConditionsStr = (0, uint8arrays_1.uint8arrayToString)(new Uint8Array(hashOfConditions), 'base16');
            (0, misc_1.log)('hashOfConditionsStr', hashOfConditionsStr);
            // ========== Hashing Private Data ==========
            // hash the private data
            const hashOfPrivateData = await crypto.subtle.digest('SHA-256', params.dataToEncrypt);
            (0, misc_1.log)('hashOfPrivateData', hashOfPrivateData);
            const hashOfPrivateDataStr = (0, uint8arrays_1.uint8arrayToString)(new Uint8Array(hashOfPrivateData), 'base16');
            (0, misc_1.log)('hashOfPrivateDataStr', hashOfPrivateDataStr);
            return new auth_helpers_1.LitAccessControlConditionResource(`${hashOfConditionsStr}/${hashOfPrivateDataStr}`);
        };
        this._getIdentityParamForEncryption = (hashOfConditionsStr, hashOfPrivateDataStr)=>{
            return new auth_helpers_1.LitAccessControlConditionResource(`${hashOfConditionsStr}/${hashOfPrivateDataStr}`).getResourceKey();
        };
        /** ============================== SESSION ============================== */ /**
         * Sign a session public key using a PKP, which generates an authSig.
         * @returns {Object} An object containing the resulting signature.
         */ this.signSessionKey = async (params)=>{
            (0, misc_1.log)(`[signSessionKey] params:`, params);
            // ========== Validate Params ==========
            // -- validate: If it's NOT ready
            if (!this.ready) {
                throw new constants_1.LitNodeClientNotReadyError({}, '[signSessionKey] ]LitNodeClient is not ready.  Please call await litNodeClient.connect() first.');
            }
            // -- construct SIWE message that will be signed by node to generate an authSig.
            const _expiration = params.expiration || new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString();
            // Try to get it from local storage, if not generates one~
            const sessionKey = params.sessionKey ?? this.getSessionKey();
            const sessionKeyUri = constants_1.LIT_SESSION_KEY_URI + sessionKey.publicKey;
            (0, misc_1.log)(`[signSessionKey] sessionKeyUri is not found in params, generating a new one`, sessionKeyUri);
            if (!sessionKeyUri) {
                throw new constants_1.InvalidParamType({
                    info: {
                        params
                    }
                }, '[signSessionKey] sessionKeyUri is not defined. Please provide a sessionKeyUri or a sessionKey.');
            }
            // Compute the address from the public key if it's provided. Otherwise, the node will compute it.
            const pkpEthAddress = function() {
                // prefix '0x' if it's not already prefixed
                params.pkpPublicKey = (0, misc_1.hexPrefixed)(params.pkpPublicKey);
                if (params.pkpPublicKey) return (0, transactions_1.computeAddress)(params.pkpPublicKey);
                // This will be populated by the node, using dummy value for now.
                return '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2';
            }();
            let siwe_statement = 'Lit Protocol PKP session signature';
            if (params.statement) {
                siwe_statement += ' ' + params.statement;
                (0, misc_1.log)(`[signSessionKey] statement found in params: "${params.statement}"`);
            }
            let siweMessage;
            const siweParams = {
                domain: params?.domain || globalThis.location?.host || 'litprotocol.com',
                walletAddress: pkpEthAddress,
                statement: siwe_statement,
                uri: sessionKeyUri,
                version: '1',
                chainId: params.chainId ?? 1,
                expiration: _expiration,
                nonce: await this.getLatestBlockhash()
            };
            if (params.resourceAbilityRequests) {
                siweMessage = await (0, auth_helpers_1.createSiweMessageWithRecaps)({
                    ...siweParams,
                    resources: params.resourceAbilityRequests,
                    litNodeClient: this
                });
            } else {
                siweMessage = await (0, auth_helpers_1.createSiweMessage)(siweParams);
            }
            // ========== Get Node Promises ==========
            // -- fetch shares from nodes
            const body = {
                sessionKey: sessionKeyUri,
                authMethods: params.authMethods,
                ...params?.pkpPublicKey && {
                    pkpPublicKey: params.pkpPublicKey
                },
                siweMessage: siweMessage,
                curveType: constants_1.LIT_CURVE.BLS,
                // -- custom auths
                ...params?.litActionIpfsId && {
                    litActionIpfsId: params.litActionIpfsId
                },
                ...params?.litActionCode && {
                    code: params.litActionCode
                },
                ...params?.jsParams && {
                    jsParams: params.jsParams
                },
                ...this.currentEpochNumber && {
                    epoch: this.currentEpochNumber
                }
            };
            (0, misc_1.log)(`[signSessionKey] body:`, body);
            const requestId = this._getNewRequestId();
            (0, misc_1.logWithRequestId)(requestId, 'signSessionKey body', body);
            const nodePromises = this.getNodePromises((url)=>{
                const reqBody = body;
                const urlWithPath = (0, core_1.composeLitUrl)({
                    url,
                    endpoint: constants_1.LIT_ENDPOINT.SIGN_SESSION_KEY
                });
                return this.generatePromise(urlWithPath, reqBody, requestId);
            });
            // -- resolve promises
            let res;
            try {
                res = await this.handleNodePromises(nodePromises, requestId, this.config.minNodeCount);
                (0, misc_1.log)('signSessionKey node promises:', res);
            } catch (e) {
                throw new constants_1.UnknownError({
                    info: {
                        requestId
                    },
                    cause: e
                }, 'Error when handling node promises');
            }
            (0, misc_1.logWithRequestId)(requestId, 'handleNodePromises res:', res);
            // -- case: promises rejected
            if (!this._isSuccessNodePromises(res)) {
                this._throwNodeError(res, requestId);
                return {};
            }
            const responseData = res.values;
            (0, misc_1.logWithRequestId)(requestId, '[signSessionKey] responseData', JSON.stringify(responseData, null, 2));
            // ========== Extract shares from response data ==========
            // -- 1. combine signed data as a list, and get the signatures from it
            let curveType = responseData[0]?.curveType;
            if (curveType === 'ECDSA') {
                throw new Error('The ECDSA curve type is not supported in this version. Please use version 6.x.x instead.');
            }
            (0, misc_1.log)(`[signSessionKey] curveType is "${curveType}"`);
            const signedDataList = responseData.map((s)=>s.dataSigned);
            if (signedDataList.length <= 0) {
                const err = `[signSessionKey] signedDataList is empty.`;
                (0, misc_1.log)(err);
                throw new constants_1.InvalidSignatureError({
                    info: {
                        requestId,
                        responseData,
                        signedDataList
                    }
                }, err);
            }
            (0, misc_1.logWithRequestId)(requestId, '[signSessionKey] signedDataList', signedDataList);
            // -- checking if we have enough shares
            const validatedSignedDataList = responseData.map((data)=>{
                // each of this field cannot be empty
                const requiredFields = [
                    'signatureShare',
                    'curveType',
                    'shareIndex',
                    'siweMessage',
                    'dataSigned',
                    'blsRootPubkey',
                    'result'
                ];
                // check if all required fields are present
                for (const field of requiredFields){
                    const key = field;
                    if (data[key] === undefined || data[key] === null || data[key] === '') {
                        (0, misc_1.log)(`[signSessionKey] Invalid signed data. "${field}" is missing. Not a problem, we only need ${this.config.minNodeCount} nodes to sign the session key.`);
                        return null;
                    }
                }
                if (!data.signatureShare.ProofOfPossession) {
                    const err = `[signSessionKey] Invalid signed data. "ProofOfPossession" is missing.`;
                    (0, misc_1.log)(err);
                    throw new constants_1.InvalidSignatureError({
                        info: {
                            requestId,
                            responseData,
                            data
                        }
                    }, err);
                }
                return data;
            }).filter((item)=>item !== null);
            (0, misc_1.logWithRequestId)(requestId, '[signSessionKey] requested length:', signedDataList.length);
            (0, misc_1.logWithRequestId)(requestId, '[signSessionKey] validated length:', validatedSignedDataList.length);
            (0, misc_1.logWithRequestId)(requestId, '[signSessionKey] minimum required length:', this.config.minNodeCount);
            if (validatedSignedDataList.length < this.config.minNodeCount) {
                throw new constants_1.InvalidSignatureError({
                    info: {
                        requestId,
                        responseData,
                        validatedSignedDataList,
                        minNodeCount: this.config.minNodeCount
                    }
                }, `[signSessionKey] not enough nodes signed the session key.  Expected ${this.config.minNodeCount}, got ${validatedSignedDataList.length}`);
            }
            const blsSignedData = validatedSignedDataList;
            const sigType = (0, misc_1.mostCommonString)(blsSignedData.map((s)=>s.curveType));
            (0, misc_1.log)(`[signSessionKey] sigType:`, sigType);
            const signatureShares = (0, get_bls_signatures_1.getBlsSignatures)(blsSignedData);
            (0, misc_1.log)(`[signSessionKey] signatureShares:`, signatureShares);
            const blsCombinedSignature = await (0, crypto_1.combineSignatureShares)(signatureShares);
            (0, misc_1.log)(`[signSessionKey] blsCombinedSignature:`, blsCombinedSignature);
            const publicKey = (0, misc_1.removeHexPrefix)(params.pkpPublicKey);
            (0, misc_1.log)(`[signSessionKey] publicKey:`, publicKey);
            const dataSigned = (0, misc_1.mostCommonString)(blsSignedData.map((s)=>s.dataSigned));
            (0, misc_1.log)(`[signSessionKey] dataSigned:`, dataSigned);
            const mostCommonSiweMessage = (0, misc_1.mostCommonString)(blsSignedData.map((s)=>s.siweMessage));
            (0, misc_1.log)(`[signSessionKey] mostCommonSiweMessage:`, mostCommonSiweMessage);
            const signedMessage = (0, misc_1.normalizeAndStringify)(mostCommonSiweMessage);
            (0, misc_1.log)(`[signSessionKey] signedMessage:`, signedMessage);
            const signSessionKeyRes = {
                authSig: {
                    sig: JSON.stringify({
                        ProofOfPossession: blsCombinedSignature
                    }),
                    algo: 'LIT_BLS',
                    derivedVia: 'lit.bls',
                    signedMessage,
                    address: (0, transactions_1.computeAddress)((0, misc_1.hexPrefixed)(publicKey))
                },
                pkpPublicKey: publicKey
            };
            return signSessionKeyRes;
        };
        this._isSuccessNodePromises = (res)=>{
            return res.success;
        };
        this.getSignSessionKeyShares = async (url, params, requestId)=>{
            (0, misc_1.log)('getSignSessionKeyShares');
            const urlWithPath = (0, core_1.composeLitUrl)({
                url,
                endpoint: constants_1.LIT_ENDPOINT.SIGN_SESSION_KEY
            });
            return await this.sendCommandToNode({
                url: urlWithPath,
                data: params.body,
                requestId
            });
        };
        /**
         *
         * Retrieves or generates sessionSigs (think access token) for accessing Lit Network resources.
         *
         * How this function works on a high level:
         * 1. Generate or retrieve [session keys](https://v6-api-doc-lit-js-sdk.vercel.app/interfaces/types_src.SessionKeyPair.html) (a public and private key pair)
         * 2. Generate or retrieve the [`AuthSig`](https://v6-api-doc-lit-js-sdk.vercel.app/interfaces/types_src.AuthSig.html) that specifies the session [abilities](https://v6-api-doc-lit-js-sdk.vercel.app/enums/auth_helpers_src.LitAbility.html)
         * 3. Sign the specific resources with the session key
         *
         * The process follows these steps:
         * 1. Retrieves or generates a session key pair (Ed25519) for the user's device. The session key is either fetched from local storage or newly created if not found. The key does not expire.
         * 2. Generates an authentication signature (`authSig`) by signing an ERC-5573 "Sign-in with Ethereum" message, which includes resource ability requests, capabilities, expiration, the user's device session public key, and a nonce. The `authSig` is retrieved from local storage, and if it has expired, the user will be prompted to re-sign.
         * 3. Uses the session private key to sign the session public key along with the resource ability requests, capabilities, issuedAt, and expiration details. This creates a device-generated signature.
         * 4. Constructs the session signatures (`sessionSigs`) by including the device-generated signature and the original message. The `sessionSigs` provide access to Lit Network features such as `executeJs` and `pkpSign`.
         *
         * See Sequence Diagram: https://www.plantuml.com/plantuml/uml/VPH1RnCn48Nl_XLFlT1Av00eGkm15QKLWY8K9K9SO-rEar4sjcLFalBl6NjJAuaMRl5utfjlPjQvJsAZx7UziQtuY5-9eWaQufQ3TOAR77cJy407Rka6zlNdHTRouUbIzSEtjiTIBUswg5v_NwMnuAVlA9KKFPN3I0x9qSSj7bqNF3iPykl9c4o9oUSJMuElv2XQ8IHAYRt3bluWM8wuVUpUJwVlFjsP8JUh5B_1DyV2AYdD6DjhLsTQTaYd3W3ad28SGWqM997fG5ZrB9DJqOaALuRwH1TMpik8tIYze-E8OrPKU5I6cMqtem2kCqOhr4vdaRAvtSjcoMkTo68scKu_Vi1EPMfrP_xVtj7sFMaHNg-6GVqk0MW0z18uKdVULTvDWtdqko28b7KktvUB2hKOBd1asU2QgDfTzrj7T4bLPdv6TR0zLwPQKkkZpIRTY4CTMbrBpg_VKuXyi49beUAHqIlirOUrL2zq9JPPdpRR5OMLVQGoGlLcjyRyQNv6MHz4W_fG42W--xWhUfNyOxiLL1USS6lRLeyAkYLNjrkVJuClm_qp5I8Lq0krUw7lwIt2DgY9oiozrjA_Yhy0
         *
         * Note: When generating session signatures for different PKPs or auth methods,
         * be sure to call disconnectWeb3 to clear auth signatures stored in local storage
         *
         * @param { GetSessionSigsProps } params
         *
         * An example of how this function is used can be found in the Lit developer-guides-code repository [here](https://github.com/LIT-Protocol/developer-guides-code/tree/master/session-signatures/getSessionSigs).
         *
         */ this.getSessionSigs = async (params)=>{
            // -- prepare
            // Try to get it from local storage, if not generates one~
            const sessionKey = params.sessionKey ?? this.getSessionKey();
            const sessionKeyUri = this.getSessionKeyUri(sessionKey.publicKey);
            // First get or generate the session capability object for the specified resources.
            const sessionCapabilityObject = params.sessionCapabilityObject ? params.sessionCapabilityObject : await this.generateSessionCapabilityObjectWithWildcards(params.resourceAbilityRequests.map((r)=>r.resource));
            const expiration = params.expiration || LitNodeClientNodeJs.getExpiration();
            // -- (TRY) to get the wallet signature
            let authSig = await this.getWalletSig({
                authNeededCallback: params.authNeededCallback,
                chain: params.chain || 'ethereum',
                sessionCapabilityObject,
                switchChain: params.switchChain,
                expiration: expiration,
                sessionKey: sessionKey,
                sessionKeyUri: sessionKeyUri,
                nonce: await this.getLatestBlockhash(),
                domain: params.domain,
                // -- for recap
                resourceAbilityRequests: params.resourceAbilityRequests,
                // -- optional fields
                ...params.litActionCode && {
                    litActionCode: params.litActionCode
                },
                ...params.litActionIpfsId && {
                    litActionIpfsId: params.litActionIpfsId
                },
                ...params.jsParams && {
                    jsParams: params.jsParams
                }
            });
            const needToResignSessionKey = await this.checkNeedToResignSessionKey({
                authSig,
                sessionKeyUri,
                resourceAbilityRequests: params.resourceAbilityRequests
            });
            // console.log('XXX needToResignSessionKey:', needToResignSessionKey);
            // -- (CHECK) if we need to resign the session key
            if (needToResignSessionKey) {
                (0, misc_1.log)('need to re-sign session key. Signing...');
                authSig = await this._authCallbackAndUpdateStorageItem({
                    authCallback: params.authNeededCallback,
                    authCallbackParams: {
                        chain: params.chain || 'ethereum',
                        statement: sessionCapabilityObject.statement,
                        resources: [
                            sessionCapabilityObject.encodeAsSiweResource()
                        ],
                        switchChain: params.switchChain,
                        expiration,
                        sessionKey: sessionKey,
                        uri: sessionKeyUri,
                        nonce: await this.getLatestBlockhash(),
                        resourceAbilityRequests: params.resourceAbilityRequests,
                        // -- optional fields
                        ...params.litActionCode && {
                            litActionCode: params.litActionCode
                        },
                        ...params.litActionIpfsId && {
                            litActionIpfsId: params.litActionIpfsId
                        },
                        ...params.jsParams && {
                            jsParams: params.jsParams
                        }
                    }
                });
            }
            if (authSig.address === '' || authSig.derivedVia === '' || authSig.sig === '' || authSig.signedMessage === '') {
                throw new constants_1.WalletSignatureNotFoundError({
                    info: {
                        authSig
                    }
                }, 'No wallet signature found');
            }
            // ===== AFTER we have Valid Signed Session Key =====
            // - Let's sign the resources with the session key
            // - 5 minutes is the default expiration for a session signature
            // - Because we can generate a new session sig every time the user wants to access a resource without prompting them to sign with their wallet
            const sessionExpiration = expiration ?? new Date(Date.now() + 1000 * 60 * 5).toISOString();
            const capabilities = params.capacityDelegationAuthSig ? [
                ...params.capabilityAuthSigs ?? [],
                params.capacityDelegationAuthSig,
                authSig
            ] : [
                ...params.capabilityAuthSigs ?? [],
                authSig
            ];
            const signingTemplate = {
                sessionKey: sessionKey.publicKey,
                resourceAbilityRequests: params.resourceAbilityRequests,
                capabilities,
                issuedAt: new Date().toISOString(),
                expiration: sessionExpiration
            };
            const signatures = {};
            if (!this.ready) {
                // If the client isn't ready, `connectedNodes` may be out-of-date, and we should throw an error immediately
                const message = '[executeJs] LitNodeClient is not ready. Please call await litNodeClient.connect() first.';
                throw new constants_1.LitNodeClientNotReadyError({}, message);
            }
            this.connectedNodes.forEach((nodeAddress)=>{
                const toSign = {
                    ...signingTemplate,
                    nodeAddress
                };
                const signedMessage = JSON.stringify(toSign);
                const uint8arrayKey = (0, uint8arrays_1.uint8arrayFromString)(sessionKey.secretKey, 'base16');
                const uint8arrayMessage = (0, uint8arrays_1.uint8arrayFromString)(signedMessage, 'utf8');
                const signature = nacl_1.nacl.sign.detached(uint8arrayMessage, uint8arrayKey);
                signatures[nodeAddress] = {
                    sig: (0, uint8arrays_1.uint8arrayToString)(signature, 'base16'),
                    derivedVia: 'litSessionSignViaNacl',
                    signedMessage: signedMessage,
                    address: sessionKey.publicKey,
                    algo: 'ed25519'
                };
            });
            (0, misc_1.log)('signatures:', signatures);
            try {
                const formattedSessionSigs = (0, misc_1.formatSessionSigs)(JSON.stringify(signatures));
                (0, misc_1.log)(formattedSessionSigs);
            } catch (e) {
                // swallow error
                (0, misc_1.log)('Error formatting session signatures: ', e);
            }
            return signatures;
        };
        /**
         * Retrieves the PKP sessionSigs.
         *
         * @param params - The parameters for retrieving the PKP sessionSigs.
         * @returns A promise that resolves to the PKP sessionSigs.
         * @throws An error if any of the required parameters are missing or if `litActionCode` and `ipfsId` exist at the same time.
         */ this.getPkpSessionSigs = async (params)=>{
            const chain = params?.chain || 'ethereum';
            const pkpSessionSigs = this.getSessionSigs({
                chain,
                ...params,
                authNeededCallback: async (props)=>{
                    // -- validate
                    if (!props.expiration) {
                        throw new constants_1.ParamsMissingError({
                            info: {
                                props
                            }
                        }, '[getPkpSessionSigs/callback] expiration is required');
                    }
                    if (!props.resources) {
                        throw new constants_1.ParamsMissingError({
                            info: {
                                props
                            }
                        }, '[getPkpSessionSigs/callback]resources is required');
                    }
                    if (!props.resourceAbilityRequests) {
                        throw new constants_1.ParamsMissingError({
                            info: {
                                props
                            }
                        }, '[getPkpSessionSigs/callback]resourceAbilityRequests is required');
                    }
                    // lit action code and ipfs id cannot exist at the same time
                    if (props.litActionCode && props.litActionIpfsId) {
                        throw new constants_1.UnsupportedMethodError({
                            info: {
                                props
                            }
                        }, '[getPkpSessionSigs/callback]litActionCode and litActionIpfsId cannot exist at the same time');
                    }
                    // Check if IPFS options are provided and if the code should be fetched from IPFS and overwrite the current code.
                    // This will fetch the code from the specified IPFS gateway using the provided ipfsId,
                    // and update the params with the fetched code, removing the ipfsId afterward.
                    const overwriteCode = params.ipfsOptions?.overwriteCode || constants_1.GLOBAL_OVERWRITE_IPFS_CODE_BY_NETWORK[this.config.litNetwork];
                    if (overwriteCode && props.litActionIpfsId) {
                        const code = await this._getFallbackIpfsCode(params.ipfsOptions?.gatewayUrl, props.litActionIpfsId);
                        props = {
                            ...props,
                            litActionCode: code,
                            litActionIpfsId: undefined
                        };
                    }
                    /**
                     * We must provide an empty array for authMethods even if we are not using any auth methods.
                     * So that the nodes can serialize the request correctly.
                     */ const authMethods = params.authMethods || [];
                    const response = await this.signSessionKey({
                        sessionKey: props.sessionKey,
                        statement: props.statement || 'Some custom statement.',
                        authMethods: [
                            ...authMethods
                        ],
                        pkpPublicKey: params.pkpPublicKey,
                        expiration: props.expiration,
                        resources: props.resources,
                        chainId: 1,
                        domain: props.domain,
                        // -- required fields
                        resourceAbilityRequests: props.resourceAbilityRequests,
                        // -- optional fields
                        ...props.litActionCode && {
                            litActionCode: props.litActionCode
                        },
                        ...props.litActionIpfsId && {
                            litActionIpfsId: props.litActionIpfsId
                        },
                        ...props.jsParams && {
                            jsParams: props.jsParams
                        }
                    });
                    return response.authSig;
                }
            });
            return pkpSessionSigs;
        };
        /**
         * Retrieves session signatures specifically for Lit Actions.
         * Unlike `getPkpSessionSigs`, this function requires either `litActionCode` or `litActionIpfsId`, and `jsParams` must be provided.
         *
         * @param params - The parameters required for retrieving the session signatures.
         * @returns A promise that resolves with the session signatures.
         */ this.getLitActionSessionSigs = async (params)=>{
            // Check if either litActionCode or litActionIpfsId is provided
            if (!params.litActionCode && !params.litActionIpfsId) {
                throw new constants_1.InvalidParamType({
                    info: {
                        params
                    }
                }, 'Either "litActionCode" or "litActionIpfsId" must be provided.');
            }
            // Check if jsParams is provided
            if (!params.jsParams) {
                throw new constants_1.ParamsMissingError({
                    info: {
                        params
                    }
                }, "'jsParams' is required.");
            }
            return this.getPkpSessionSigs(params);
        };
        /**
         *
         * Get Session Key URI eg. lit:session:0x1234
         *
         * @param publicKey is the public key of the session key
         * @returns { string } the session key uri
         */ this.getSessionKeyUri = (publicKey)=>{
            return constants_1.LIT_SESSION_KEY_URI + publicKey;
        };
        if (args !== undefined && args !== null && 'defaultAuthCallback' in args) {
            this.defaultAuthCallback = args.defaultAuthCallback;
        }
    }
    /**
     * Check if a given object is of type SessionKeyPair.
     *
     * @param obj - The object to check.
     * @returns True if the object is of type SessionKeyPair.
     */ isSessionKeyPair(obj) {
        return typeof obj === 'object' && 'publicKey' in obj && 'secretKey' in obj && typeof obj.publicKey === 'string' && typeof obj.secretKey === 'string';
    }
    /**
     * Generates wildcard capability for each of the LIT resources
     * specified.
     * @param litResources is an array of LIT resources
     * @param addAllCapabilities is a boolean that specifies whether to add all capabilities for each resource
     */ static async generateSessionCapabilityObjectWithWildcards(litResources, addAllCapabilities) {
        const sessionCapabilityObject = new auth_helpers_1.RecapSessionCapabilityObject({}, []);
        // disable for now
        const _addAllCapabilities = addAllCapabilities ?? false;
        if (_addAllCapabilities) {
            for (const litResource of litResources){
                sessionCapabilityObject.addAllCapabilitiesForResource(litResource);
            }
        }
        return sessionCapabilityObject;
    }
    // backward compatibility
    async generateSessionCapabilityObjectWithWildcards(litResources) {
        return await LitNodeClientNodeJs.generateSessionCapabilityObjectWithWildcards(litResources);
    }
    // ========== Scoped Business Logics ==========
    /**
     * Retrieves the fallback IPFS code for a given IPFS ID.
     *
     * @param gatewayUrl - the gateway url.
     * @param ipfsId - The IPFS ID.
     * @returns The base64-encoded fallback IPFS code.
     * @throws An error if the code retrieval fails.
     */ async _getFallbackIpfsCode(gatewayUrl, ipfsId) {
        const allGateways = gatewayUrl ? [
            gatewayUrl,
            ...constants_1.FALLBACK_IPFS_GATEWAYS
        ] : constants_1.FALLBACK_IPFS_GATEWAYS;
        (0, misc_1.log)(`Attempting to fetch code for IPFS ID: ${ipfsId} using fallback IPFS gateways`);
        for (const url of allGateways){
            try {
                const response = await fetch(`${url}${ipfsId}`);
                if (!response.ok) {
                    throw new Error(`Failed to fetch code from IPFS gateway ${url}: ${response.status} ${response.statusText}`);
                }
                const code = await response.text();
                const codeBase64 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(code).toString('base64');
                return codeBase64;
            } catch (error) {
                console.error(`Error fetching code from IPFS gateway ${url}`);
            // Continue to the next gateway in the array
            }
        }
        throw new Error('All IPFS gateways failed to fetch the code.');
    }
    async executeJsNodeRequest(url, formattedParams, requestId) {
        // -- choose the right signature
        const sessionSig = this.getSessionSigByUrl({
            sessionSigs: formattedParams.sessionSigs,
            url
        });
        const reqBody = {
            ...formattedParams,
            authSig: sessionSig
        };
        const urlWithPath = (0, core_1.composeLitUrl)({
            url,
            endpoint: constants_1.LIT_ENDPOINT.EXECUTE_JS
        });
        return this.generatePromise(urlWithPath, reqBody, requestId);
    }
    /**
     * Authenticates an Auth Method for claiming a Programmable Key Pair (PKP).
     * A {@link MintCallback} can be defined for custom on chain interactions
     * by default the callback will forward to a relay server for minting on chain.
     * @param {ClaimKeyRequest} params an Auth Method and {@link MintCallback}
     * @returns {Promise<ClaimKeyResponse>}
     */ async claimKeyId(params) {
        if (!this.ready) {
            const message = 'LitNodeClient is not ready.  Please call await litNodeClient.connect() first.';
            throw new constants_1.LitNodeClientNotReadyError({}, message);
        }
        if (params.authMethod.authMethodType == constants_1.AUTH_METHOD_TYPE.WebAuthn) {
            throw new constants_1.LitNodeClientNotReadyError({}, 'Unsupported auth method type. Webauthn, and Lit Actions are not supported for claiming');
        }
        const requestId = this._getNewRequestId();
        const nodePromises = this.getNodePromises((url)=>{
            if (!params.authMethod) {
                throw new constants_1.ParamsMissingError({
                    info: {
                        params
                    }
                }, 'authMethod is required');
            }
            const reqBody = {
                authMethod: params.authMethod
            };
            const urlWithPath = (0, core_1.composeLitUrl)({
                url,
                endpoint: constants_1.LIT_ENDPOINT.PKP_CLAIM
            });
            return this.generatePromise(urlWithPath, reqBody, requestId);
        });
        const responseData = await this.handleNodePromises(nodePromises, requestId, this.connectedNodes.size);
        if (responseData.success) {
            const nodeSignatures = responseData.values.map((r)=>{
                const sig = ethers_1.ethers.utils.splitSignature(`0x${r.signature}`);
                return {
                    r: sig.r,
                    s: sig.s,
                    v: sig.v
                };
            });
            (0, misc_1.logWithRequestId)(requestId, `responseData: ${JSON.stringify(responseData, null, 2)}`);
            const derivedKeyId = responseData.values[0].derivedKeyId;
            const pubkey = await this.computeHDPubKey(derivedKeyId);
            (0, misc_1.logWithRequestId)(requestId, `pubkey ${pubkey} derived from key id ${derivedKeyId}`);
            const relayParams = params;
            let mintTx = '';
            if (params.mintCallback && 'signer' in params) {
                mintTx = await params.mintCallback({
                    derivedKeyId,
                    authMethodType: params.authMethod.authMethodType,
                    signatures: nodeSignatures,
                    pubkey,
                    signer: params.signer,
                    ...relayParams
                }, this.config.litNetwork);
            } else {
                mintTx = await (0, misc_1.defaultMintClaimCallback)({
                    derivedKeyId,
                    authMethodType: params.authMethod.authMethodType,
                    signatures: nodeSignatures,
                    pubkey,
                    ...relayParams
                }, this.config.litNetwork);
            }
            return {
                signatures: nodeSignatures,
                claimedKeyId: derivedKeyId,
                pubkey,
                mintTx
            };
        } else {
            throw new constants_1.UnknownError({
                info: {
                    requestId,
                    responseData
                }
            }, `Claim request has failed. Request trace id: lit_%s`, requestId);
        }
    }
}
exports.LitNodeClientNodeJs = LitNodeClientNodeJs;
/**
 *
 * Get expiration for session default time is 1 day / 24 hours
 *
 */ LitNodeClientNodeJs.getExpiration = ()=>{
    return new Date(Date.now() + 1000 * 60 * 60 * 24).toISOString();
}; //# sourceMappingURL=lit-node-client-nodejs.js.map
}),
"[project]/node_modules/@lit-protocol/lit-node-client-nodejs/src/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.uint8arrayToString = exports.uint8arrayFromString = exports.blobToBase64String = exports.base64StringToBlob = exports.humanizeAccessControlConditions = exports.hashResourceIdForSigning = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/node_modules/tslib/tslib.es6.js [app-client] (ecmascript)");
__turbopack_context__.r("[project]/node_modules/cross-fetch/dist/node-polyfill.js [app-client] (ecmascript)");
// ==================== Exports ====================
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/src/lib/lit-node-client-nodejs.js [app-client] (ecmascript)"), exports);
var access_control_conditions_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/access-control-conditions/src/index.js [app-client] (ecmascript)");
Object.defineProperty(exports, "hashResourceIdForSigning", {
    enumerable: true,
    get: function() {
        return access_control_conditions_1.hashResourceIdForSigning;
    }
});
Object.defineProperty(exports, "humanizeAccessControlConditions", {
    enumerable: true,
    get: function() {
        return access_control_conditions_1.humanizeAccessControlConditions;
    }
});
var misc_browser_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/misc-browser/src/index.js [app-client] (ecmascript)");
Object.defineProperty(exports, "base64StringToBlob", {
    enumerable: true,
    get: function() {
        return misc_browser_1.base64StringToBlob;
    }
});
Object.defineProperty(exports, "blobToBase64String", {
    enumerable: true,
    get: function() {
        return misc_browser_1.blobToBase64String;
    }
});
var uint8arrays_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/uint8arrays/src/index.js [app-client] (ecmascript)");
Object.defineProperty(exports, "uint8arrayFromString", {
    enumerable: true,
    get: function() {
        return uint8arrays_1.uint8arrayFromString;
    }
});
Object.defineProperty(exports, "uint8arrayToString", {
    enumerable: true,
    get: function() {
        return uint8arrays_1.uint8arrayToString;
    }
}); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@lit-protocol/lit-node-client/src/lib/lit-node-client.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.LitNodeClient = void 0;
const auth_browser_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/auth-browser/src/index.js [app-client] (ecmascript)");
const constants_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client/node_modules/@lit-protocol/constants/src/index.js [app-client] (ecmascript)");
const lit_node_client_nodejs_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/src/index.js [app-client] (ecmascript)");
const misc_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/misc/src/index.js [app-client] (ecmascript)");
const misc_browser_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/misc-browser/src/index.js [app-client] (ecmascript)");
/**
 * You can find all these available networks in the `constants` package
 *
 * @example
 *
 * ```
 * import { LIT_NETWORK } from '@lit-protocol/constants';
 *
 * const litNodeClient = new LitNodeClient({
    litNetwork: LIT_NETWORK.DatilTest,
   });
 * ```
 */ class LitNodeClient extends lit_node_client_nodejs_1.LitNodeClientNodeJs {
    constructor(args){
        super({
            ...args,
            defaultAuthCallback: auth_browser_1.checkAndSignAuthMessage
        });
        /**
         *
         * (Browser Only) Get the config from browser local storage and override default config
         *
         * @returns { void }
         *
         */ this._overrideConfigsFromLocalStorage = ()=>{
            if ((0, misc_1.isNode)()) return;
            const storageKey = 'LitNodeClientConfig';
            const storageConfigOrError = (0, misc_browser_1.getStorageItem)(storageKey);
            // -- validate
            if (storageConfigOrError.type === constants_1.EITHER_TYPE.ERROR) {
                (0, misc_1.log)(`Storage key "${storageKey}" is missing. `);
                return;
            }
            // -- execute
            const storageConfig = JSON.parse(storageConfigOrError.result);
            // this.config = override(this.config, storageConfig);
            this.config = {
                ...this.config,
                ...storageConfig
            };
        };
        // -- override configs
        this._overrideConfigsFromLocalStorage();
    }
}
exports.LitNodeClient = LitNodeClient; //# sourceMappingURL=lit-node-client.js.map
}),
"[project]/node_modules/@lit-protocol/lit-node-client/src/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.disconnectWeb3 = exports.ethConnect = exports.checkAndSignAuthMessage = void 0;
const tslib_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client/node_modules/tslib/tslib.es6.js [app-client] (ecmascript)");
// ==================== Exports ====================
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client/src/lib/lit-node-client.js [app-client] (ecmascript)"), exports);
var auth_browser_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/auth-browser/src/index.js [app-client] (ecmascript)");
Object.defineProperty(exports, "checkAndSignAuthMessage", {
    enumerable: true,
    get: function() {
        return auth_browser_1.checkAndSignAuthMessage;
    }
});
Object.defineProperty(exports, "ethConnect", {
    enumerable: true,
    get: function() {
        return auth_browser_1.ethConnect;
    }
});
Object.defineProperty(exports, "disconnectWeb3", {
    enumerable: true,
    get: function() {
        return auth_browser_1.disconnectWeb3;
    }
});
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/lit-node-client-nodejs/src/index.js [app-client] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@lit-protocol/encryption/src/lib/encryption.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.decryptToFile = exports.encryptFile = exports.decryptToString = exports.encryptString = exports.decryptToUint8Array = exports.encryptUint8Array = exports.encryptToJson = void 0;
exports.decryptFromJson = decryptFromJson;
const constants_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/encryption/node_modules/@lit-protocol/constants/src/index.js [app-client] (ecmascript)");
const misc_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/misc/src/index.js [app-client] (ecmascript)");
const uint8arrays_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/uint8arrays/src/index.js [app-client] (ecmascript)");
/**
 * Encrypt a string or file using the LIT network public key and serialise all the metadata required to decrypt
 * i.e. accessControlConditions, evmContractConditions, solRpcConditions, unifiedAccessControlConditions & chain to JSON
 *
 * Useful for encrypting/decrypting data in IPFS or other storage without compressing it in a file.
 *
 * @param params { EncryptToJsonProps } - The params required to encrypt either a file or string and serialise it to JSON
 *
 * @returns { Promise<string> } - JSON serialised string of the encrypted data and associated metadata necessary to decrypt it later
 *
 */ const encryptToJson = async (params)=>{
    const { accessControlConditions, evmContractConditions, solRpcConditions, unifiedAccessControlConditions, chain, string, file, litNodeClient } = params;
    // -- validate
    const paramsIsSafe = (0, misc_1.safeParams)({
        functionName: 'encryptToJson',
        params
    });
    if (paramsIsSafe.type === constants_1.EITHER_TYPE.ERROR) throw new constants_1.InvalidParamType({
        info: {
            params,
            function: 'encryptToJson'
        },
        cause: paramsIsSafe.result
    }, 'Invalid params');
    if (string !== undefined) {
        const { ciphertext, dataToEncryptHash } = await (0, exports.encryptString)({
            ...params,
            dataToEncrypt: string
        }, litNodeClient);
        return JSON.stringify({
            ciphertext,
            dataToEncryptHash,
            accessControlConditions,
            evmContractConditions,
            solRpcConditions,
            unifiedAccessControlConditions,
            chain,
            dataType: 'string'
        });
    } else if (file) {
        const { ciphertext, dataToEncryptHash } = await (0, exports.encryptFile)({
            ...params,
            file
        }, litNodeClient);
        return JSON.stringify({
            ciphertext,
            dataToEncryptHash,
            accessControlConditions,
            evmContractConditions,
            solRpcConditions,
            unifiedAccessControlConditions,
            chain,
            dataType: 'file'
        });
    } else {
        throw new constants_1.InvalidParamType({
            info: {
                params
            }
        }, 'You must provide either "file" or "string"');
    }
};
exports.encryptToJson = encryptToJson;
/**
 *
 * Decrypt & return a previously encrypted string (as a string) or file (as a Uint8Array) using the metadata included
 * in the parsed JSON data
 *
 * @param params { DecryptFromJsonProps } - The params required to decrypt a parsed JSON blob containing appropriate metadata
 *
 * @returns { Promise<string | Uint8Array> } - The decrypted `string` or file (as a `Uint8Array`) depending on `dataType` property in the parsed JSON provided
 *
 */ async function decryptFromJson(params) {
    const { sessionSigs, parsedJsonData, litNodeClient } = params;
    // -- validate
    const paramsIsSafe = (0, misc_1.safeParams)({
        functionName: 'decryptFromJson',
        params
    });
    if (paramsIsSafe.type === constants_1.EITHER_TYPE.ERROR) throw new constants_1.InvalidParamType({
        info: {
            params,
            function: 'decryptFromJson'
        },
        cause: paramsIsSafe.result
    }, 'Invalid params');
    if (parsedJsonData.dataType === 'string') {
        return (0, exports.decryptToString)({
            accessControlConditions: parsedJsonData.accessControlConditions,
            evmContractConditions: parsedJsonData.evmContractConditions,
            solRpcConditions: parsedJsonData.solRpcConditions,
            unifiedAccessControlConditions: parsedJsonData.unifiedAccessControlConditions,
            ciphertext: parsedJsonData.ciphertext,
            dataToEncryptHash: parsedJsonData.dataToEncryptHash,
            chain: parsedJsonData.chain,
            sessionSigs
        }, litNodeClient);
    } else if (parsedJsonData.dataType === 'file') {
        return (0, exports.decryptToFile)({
            accessControlConditions: parsedJsonData.accessControlConditions,
            evmContractConditions: parsedJsonData.evmContractConditions,
            solRpcConditions: parsedJsonData.solRpcConditions,
            unifiedAccessControlConditions: parsedJsonData.unifiedAccessControlConditions,
            ciphertext: parsedJsonData.ciphertext,
            dataToEncryptHash: parsedJsonData.dataToEncryptHash,
            chain: parsedJsonData.chain,
            sessionSigs
        }, litNodeClient);
    } else {
        throw new constants_1.InvalidParamType({
            info: {
                dataType: parsedJsonData.dataType,
                params
            }
        }, 'dataType of %s is not valid. Must be "string" or "file".', parsedJsonData.dataType);
    }
}
// ---------- Local Helpers ----------
/** Encrypt a uint8array. This is used to encrypt any uint8array that is to be locked via the Lit Protocol.
 * @param { EncryptUint8ArrayRequest } params - The params required to encrypt a uint8array
 * @param params.dataToEncrypt - (optional) The uint8array to encrypt
 * @param params.accessControlConditions - (optional) The access control conditions
 * @param params.evmContractConditions - (optional) The EVM contract conditions
 * @param params.solRpcConditions - (optional) The Solana RPC conditions
 * @param params.unifiedAccessControlConditions - The unified access control conditions
 * @param { ILitNodeClient } litNodeClient - The Lit Node Client
 *
 * @returns { Promise<EncryptResponse> } - The encrypted uint8array and the hash of the data that was encrypted
 */ const encryptUint8Array = async (params, litNodeClient)=>{
    // -- validate
    const paramsIsSafe = (0, misc_1.safeParams)({
        functionName: 'encryptUint8Array',
        params
    });
    if (paramsIsSafe.type === constants_1.EITHER_TYPE.ERROR) throw new constants_1.InvalidParamType({
        info: {
            params
        }
    }, 'Invalid params');
    return litNodeClient.encrypt({
        ...params
    });
};
exports.encryptUint8Array = encryptUint8Array;
/**
 * Decrypt a cyphertext into a Uint8Array that was encrypted with the encryptUint8Array function.
 *
 * @param { DecryptRequest } params - The params required to decrypt a string
 * @param { ILitNodeClient } litNodeClient - The Lit Node Client
 *
 * @returns { Promise<Uint8Array> } - The decrypted `Uint8Array`
 */ const decryptToUint8Array = async (params, litNodeClient)=>{
    // -- validate
    const paramsIsSafe = (0, misc_1.safeParams)({
        functionName: 'decrypt',
        params
    });
    if (paramsIsSafe.type === constants_1.EITHER_TYPE.ERROR) throw new constants_1.InvalidParamType({
        info: {
            params,
            function: 'decryptToUint8Array'
        },
        cause: paramsIsSafe.result
    }, 'Invalid params');
    const { decryptedData } = await litNodeClient.decrypt(params);
    return decryptedData;
};
exports.decryptToUint8Array = decryptToUint8Array;
/**
 *
 * Encrypt a string.  This is used to encrypt any string that is to be locked via the Lit Protocol.
 *
 * @param { EncryptStringRequest } params - The params required to encrypt a string
 * @param params.dataToEncrypt - (optional) The string to encrypt
 * @param params.accessControlConditions - (optional) The access control conditions
 * @param params.evmContractConditions - (optional) The EVM contract conditions
 * @param params.solRpcConditions - (optional) The Solana RPC conditions
 * @param params.unifiedAccessControlConditions - The unified access control conditions
 * @param { ILitNodeClient } litNodeClient - The Lit Node Client
 *
 * @returns { Promise<EncryptResponse> } - The encrypted string and the hash of the string
 */ const encryptString = async (params, litNodeClient)=>{
    // -- validate
    const paramsIsSafe = (0, misc_1.safeParams)({
        functionName: 'encryptString',
        params
    });
    if (paramsIsSafe.type === constants_1.EITHER_TYPE.ERROR) throw new constants_1.InvalidParamType({
        info: {
            params,
            function: 'encryptString'
        },
        cause: paramsIsSafe.result
    }, 'Invalid params');
    return litNodeClient.encrypt({
        ...params,
        dataToEncrypt: (0, uint8arrays_1.uint8arrayFromString)(params.dataToEncrypt, 'utf8')
    });
};
exports.encryptString = encryptString;
/**
 *
 * Decrypt ciphertext into a string that was encrypted with the encryptString function.
 *
 * @param { DecryptRequest } params - The params required to decrypt a string
 * @param { ILitNodeClient } litNodeClient - The Lit Node Client

 * @returns { Promise<string> } - The decrypted string
 */ const decryptToString = async (params, litNodeClient)=>{
    // -- validate
    const paramsIsSafe = (0, misc_1.safeParams)({
        functionName: 'decrypt',
        params
    });
    if (paramsIsSafe.type === constants_1.EITHER_TYPE.ERROR) throw new constants_1.InvalidParamType({
        info: {
            params,
            function: 'decryptToString'
        },
        cause: paramsIsSafe.result
    }, 'Invalid params');
    const { decryptedData } = await litNodeClient.decrypt(params);
    return (0, uint8arrays_1.uint8arrayToString)(decryptedData, 'utf8');
};
exports.decryptToString = decryptToString;
/**
 *
 * Encrypt a file without doing any compression or packing.  This is useful for large files.  A 1gb file can be encrypted in only 2 seconds, for example.
 *
 * @param { EncryptFileRequest } params - The params required to encrypt a file
 * @param { ILitNodeClient } litNodeClient - The lit node client to use to encrypt the file
 *
 * @returns { Promise<EncryptResponse> } - The encrypted file and the hash of the file
 */ const encryptFile = async (params, litNodeClient)=>{
    // -- validate
    const paramsIsSafe = (0, misc_1.safeParams)({
        functionName: 'encryptFile',
        params
    });
    if (paramsIsSafe.type === constants_1.EITHER_TYPE.ERROR) throw new constants_1.InvalidParamType({
        info: {
            params,
            function: 'encryptFile'
        },
        cause: paramsIsSafe.result
    }, 'Invalid params');
    // encrypt the file
    const fileAsArrayBuffer = await params.file.arrayBuffer();
    return litNodeClient.encrypt({
        ...params,
        dataToEncrypt: new Uint8Array(fileAsArrayBuffer)
    });
};
exports.encryptFile = encryptFile;
/**
 *
 * Decrypt a file that was encrypted with the encryptFile function, without doing any uncompressing or unpacking.  This is useful for large files.  A 1gb file can be decrypted in only 1 second, for example.
 *
 * @param { DecryptRequest } params - The params required to decrypt a file
 * @param { ILitNodeClient } litNodeClient - The lit node client to use to decrypt the file
 *
 * @returns { Promise<Uint8Array> } - The decrypted file
 */ const decryptToFile = async (params, litNodeClient)=>{
    // -- validate
    const paramsIsSafe = (0, misc_1.safeParams)({
        functionName: 'decrypt',
        params
    });
    if (paramsIsSafe.type === constants_1.EITHER_TYPE.ERROR) throw new constants_1.InvalidParamType({
        info: {
            params,
            function: 'decryptToFile'
        },
        cause: paramsIsSafe.result
    }, 'Invalid params');
    const { decryptedData } = await litNodeClient.decrypt(params);
    return decryptedData;
};
exports.decryptToFile = decryptToFile; //# sourceMappingURL=encryption.js.map
}),
"[project]/node_modules/@lit-protocol/encryption/src/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
const tslib_1 = __turbopack_context__.r("[project]/node_modules/@lit-protocol/encryption/node_modules/tslib/tslib.es6.js [app-client] (ecmascript)");
tslib_1.__exportStar(__turbopack_context__.r("[project]/node_modules/@lit-protocol/encryption/src/lib/encryption.js [app-client] (ecmascript)"), exports); //# sourceMappingURL=index.js.map
}),
]);

//# sourceMappingURL=node_modules_%40lit-protocol_5a7c1998._.js.map