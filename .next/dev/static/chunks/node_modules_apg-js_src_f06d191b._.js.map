{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 3, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/apg-js/src/apg-lib/identifiers.js"],"sourcesContent":["/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module exposes a list of named identifiers, shared across the parser generator\n// and the parsers that are generated.\n\nmodule.exports = {\n  // Identifies the operator type. Used by the generator\n  // to indicate operator types in the grammar object.\n  // Used by the [parser](./parser.html) when interpreting the grammar object.\n  /* the original ABNF operators */\n  ALT: 1 /* alternation */,\n  CAT: 2 /* concatenation */,\n  REP: 3 /* repetition */,\n  RNM: 4 /* rule name */,\n  TRG: 5 /* terminal range */,\n  TBS: 6 /* terminal binary string, case sensitive */,\n  TLS: 7 /* terminal literal string, case insensitive */,\n  /* the super set, SABNF operators */\n  UDT: 11 /* user-defined terminal */,\n  AND: 12 /* positive look ahead */,\n  NOT: 13 /* negative look ahead */,\n  BKR: 14 /* back reference to a previously matched rule name */,\n  BKA: 15 /* positive look behind */,\n  BKN: 16 /* negative look behind */,\n  ABG: 17 /* anchor - begin of string */,\n  AEN: 18 /* anchor - end of string */,\n  // Used by the parser and the user's `RNM` and `UDT` callback functions.\n  // Identifies the parser state as it traverses the parse tree nodes.\n  // - *ACTIVE* - indicates the downward direction through the parse tree node.\n  // - *MATCH* - indicates the upward direction and a phrase, of length \\> 0, has been successfully matched\n  // - *EMPTY* - indicates the upward direction and a phrase, of length = 0, has been successfully matched\n  // - *NOMATCH* - indicates the upward direction and the parser failed to match any phrase at all\n  ACTIVE: 100,\n  MATCH: 101,\n  EMPTY: 102,\n  NOMATCH: 103,\n  // Used by [`AST` translator](./ast.html) (semantic analysis) and the user's callback functions\n  // to indicate the direction of flow through the `AST` nodes.\n  // - *SEM_PRE* - indicates the downward (pre-branch) direction through the `AST` node.\n  // - *SEM_POST* - indicates the upward (post-branch) direction through the `AST` node.\n  SEM_PRE: 200,\n  SEM_POST: 201,\n  // Used by the user's callback functions to indicate to the `AST` translator (semantic analysis) how to proceed.\n  // - *SEM_OK* - normal return value\n  // - *SEM_SKIP* - if a callback function returns this value from the SEM_PRE state,\n  // the translator will skip processing all `AST` nodes in the branch below the current node.\n  // Ignored if returned from the SEM_POST state.\n  SEM_OK: 300,\n  SEM_SKIP: 301,\n  // Used in attribute generation to distinguish the necessary attribute categories.\n  // - *ATTR_N* - non-recursive\n  // - *ATTR_R* - recursive\n  // - *ATTR_MR* - belongs to a mutually-recursive set\n  ATTR_N: 400,\n  ATTR_R: 401,\n  ATTR_MR: 402,\n  // Look around values indicate whether the parser is in look ahead or look behind mode.\n  // Used by the tracing facility to indicate the look around mode in the trace records display.\n  // - *LOOKAROUND_NONE* - the parser is in normal parsing mode\n  // - *LOOKAROUND_AHEAD* - the parse is in look-ahead mode, phrase matching for operator `AND(&)` or `NOT(!)`\n  // - *LOOKAROUND_BEHIND* - the parse is in look-behind mode, phrase matching for operator `BKA(&&)` or `BKN(!!)`\n  LOOKAROUND_NONE: 500,\n  LOOKAROUND_AHEAD: 501,\n  LOOKAROUND_BEHIND: 502,\n  // Back reference rule mode indicators\n  // - *BKR_MODE_UM* - the back reference is using universal mode\n  // - *BKR_MODE_PM* - the back reference is using parent frame mode\n  // - *BKR_MODE_CS* - the back reference is using case-sensitive phrase matching\n  // - *BKR_MODE_CI* - the back reference is using case-insensitive phrase matching\n  BKR_MODE_UM: 601,\n  BKR_MODE_PM: 602,\n  BKR_MODE_CS: 603,\n  BKR_MODE_CI: 604,\n};\n"],"names":[],"mappings":"AAAA;;;uFAGuF,GACvF,sFAAsF;AACtF,sCAAsC;AAEtC,OAAO,OAAO,GAAG;IACf,sDAAsD;IACtD,oDAAoD;IACpD,4EAA4E;IAC5E,+BAA+B,GAC/B,KAAK,EAAE,eAAe;IACtB,KAAK,EAAE,iBAAiB;IACxB,KAAK,EAAE,cAAc;IACrB,KAAK,EAAE,aAAa;IACpB,KAAK,EAAE,kBAAkB;IACzB,KAAK,EAAE,0CAA0C;IACjD,KAAK,EAAE,6CAA6C;IACpD,kCAAkC,GAClC,KAAK,GAAG,yBAAyB;IACjC,KAAK,GAAG,uBAAuB;IAC/B,KAAK,GAAG,uBAAuB;IAC/B,KAAK,GAAG,oDAAoD;IAC5D,KAAK,GAAG,wBAAwB;IAChC,KAAK,GAAG,wBAAwB;IAChC,KAAK,GAAG,4BAA4B;IACpC,KAAK,GAAG,0BAA0B;IAClC,wEAAwE;IACxE,oEAAoE;IACpE,6EAA6E;IAC7E,yGAAyG;IACzG,wGAAwG;IACxG,gGAAgG;IAChG,QAAQ;IACR,OAAO;IACP,OAAO;IACP,SAAS;IACT,+FAA+F;IAC/F,6DAA6D;IAC7D,sFAAsF;IACtF,sFAAsF;IACtF,SAAS;IACT,UAAU;IACV,gHAAgH;IAChH,mCAAmC;IACnC,mFAAmF;IACnF,4FAA4F;IAC5F,+CAA+C;IAC/C,QAAQ;IACR,UAAU;IACV,kFAAkF;IAClF,6BAA6B;IAC7B,yBAAyB;IACzB,oDAAoD;IACpD,QAAQ;IACR,QAAQ;IACR,SAAS;IACT,uFAAuF;IACvF,8FAA8F;IAC9F,6DAA6D;IAC7D,4GAA4G;IAC5G,gHAAgH;IAChH,iBAAiB;IACjB,kBAAkB;IAClB,mBAAmB;IACnB,sCAAsC;IACtC,+DAA+D;IAC/D,kEAAkE;IAClE,+EAA+E;IAC/E,iFAAiF;IACjF,aAAa;IACb,aAAa;IACb,aAAa;IACb,aAAa;AACf","ignoreList":[0]}},
    {"offset": {"line": 78, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/apg-js/src/apg-lib/style.js"],"sourcesContent":["module.exports = {\n\n  // Generated by apglib/style.js \n  CLASS_MONOSPACE: 'apg-mono',\n  CLASS_ACTIVE: 'apg-active',\n  CLASS_EMPTY: 'apg-empty',\n  CLASS_MATCH: 'apg-match',\n  CLASS_NOMATCH: 'apg-nomatch',\n  CLASS_LOOKAHEAD: 'apg-lh-match',\n  CLASS_LOOKBEHIND: 'apg-lb-match',\n  CLASS_REMAINDER: 'apg-remainder',\n  CLASS_CTRLCHAR: 'apg-ctrl-char',\n  CLASS_LINEEND: 'apg-line-end',\n  CLASS_ERROR: 'apg-error',\n  CLASS_PHRASE: 'apg-phrase',\n  CLASS_EMPTYPHRASE: 'apg-empty-phrase',\n  CLASS_STATE: 'apg-state',\n  CLASS_STATS: 'apg-stats',\n  CLASS_TRACE: 'apg-trace',\n  CLASS_GRAMMAR: 'apg-grammar',\n  CLASS_RULES: 'apg-rules',\n  CLASS_RULESLINK: 'apg-rules-link',\n  CLASS_ATTRIBUTES: 'apg-attrs',\n}\n"],"names":[],"mappings":"AAAA,OAAO,OAAO,GAAG;IAEf,gCAAgC;IAChC,iBAAiB;IACjB,cAAc;IACd,aAAa;IACb,aAAa;IACb,eAAe;IACf,iBAAiB;IACjB,kBAAkB;IAClB,iBAAiB;IACjB,gBAAgB;IAChB,eAAe;IACf,aAAa;IACb,cAAc;IACd,mBAAmB;IACnB,aAAa;IACb,aAAa;IACb,aAAa;IACb,eAAe;IACf,aAAa;IACb,iBAAiB;IACjB,kBAAkB;AACpB","ignoreList":[0]}},
    {"offset": {"line": 104, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/apg-js/src/apg-conv-api/transformers.js"],"sourcesContent":["/* eslint-disable prefer-destructuring */\n/* eslint-disable no-plusplus */\n/* eslint-disable no-bitwise */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module contains the actual encoding and decoding algorithms.\n// Throws \"RangeError\" exceptions on characters or bytes out of range for the given encoding.\n\n'use strict;';\n\nconst { Buffer } = require('buffer');\n\n/* decoding error codes */\nconst NON_SHORTEST = 0xfffffffc;\nconst TRAILING = 0xfffffffd;\nconst RANGE = 0xfffffffe;\nconst ILL_FORMED = 0xffffffff;\n\n/* mask[n] = 2**n - 1, ie. mask[n] = n bits on. e.g. mask[6] = %b111111 */\nconst mask = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023];\n\n/* ascii[n] = 'HH', where 0xHH = n, eg. ascii[254] = 'FE' */\nconst ascii = [\n  '00',\n  '01',\n  '02',\n  '03',\n  '04',\n  '05',\n  '06',\n  '07',\n  '08',\n  '09',\n  '0A',\n  '0B',\n  '0C',\n  '0D',\n  '0E',\n  '0F',\n  '10',\n  '11',\n  '12',\n  '13',\n  '14',\n  '15',\n  '16',\n  '17',\n  '18',\n  '19',\n  '1A',\n  '1B',\n  '1C',\n  '1D',\n  '1E',\n  '1F',\n  '20',\n  '21',\n  '22',\n  '23',\n  '24',\n  '25',\n  '26',\n  '27',\n  '28',\n  '29',\n  '2A',\n  '2B',\n  '2C',\n  '2D',\n  '2E',\n  '2F',\n  '30',\n  '31',\n  '32',\n  '33',\n  '34',\n  '35',\n  '36',\n  '37',\n  '38',\n  '39',\n  '3A',\n  '3B',\n  '3C',\n  '3D',\n  '3E',\n  '3F',\n  '40',\n  '41',\n  '42',\n  '43',\n  '44',\n  '45',\n  '46',\n  '47',\n  '48',\n  '49',\n  '4A',\n  '4B',\n  '4C',\n  '4D',\n  '4E',\n  '4F',\n  '50',\n  '51',\n  '52',\n  '53',\n  '54',\n  '55',\n  '56',\n  '57',\n  '58',\n  '59',\n  '5A',\n  '5B',\n  '5C',\n  '5D',\n  '5E',\n  '5F',\n  '60',\n  '61',\n  '62',\n  '63',\n  '64',\n  '65',\n  '66',\n  '67',\n  '68',\n  '69',\n  '6A',\n  '6B',\n  '6C',\n  '6D',\n  '6E',\n  '6F',\n  '70',\n  '71',\n  '72',\n  '73',\n  '74',\n  '75',\n  '76',\n  '77',\n  '78',\n  '79',\n  '7A',\n  '7B',\n  '7C',\n  '7D',\n  '7E',\n  '7F',\n  '80',\n  '81',\n  '82',\n  '83',\n  '84',\n  '85',\n  '86',\n  '87',\n  '88',\n  '89',\n  '8A',\n  '8B',\n  '8C',\n  '8D',\n  '8E',\n  '8F',\n  '90',\n  '91',\n  '92',\n  '93',\n  '94',\n  '95',\n  '96',\n  '97',\n  '98',\n  '99',\n  '9A',\n  '9B',\n  '9C',\n  '9D',\n  '9E',\n  '9F',\n  'A0',\n  'A1',\n  'A2',\n  'A3',\n  'A4',\n  'A5',\n  'A6',\n  'A7',\n  'A8',\n  'A9',\n  'AA',\n  'AB',\n  'AC',\n  'AD',\n  'AE',\n  'AF',\n  'B0',\n  'B1',\n  'B2',\n  'B3',\n  'B4',\n  'B5',\n  'B6',\n  'B7',\n  'B8',\n  'B9',\n  'BA',\n  'BB',\n  'BC',\n  'BD',\n  'BE',\n  'BF',\n  'C0',\n  'C1',\n  'C2',\n  'C3',\n  'C4',\n  'C5',\n  'C6',\n  'C7',\n  'C8',\n  'C9',\n  'CA',\n  'CB',\n  'CC',\n  'CD',\n  'CE',\n  'CF',\n  'D0',\n  'D1',\n  'D2',\n  'D3',\n  'D4',\n  'D5',\n  'D6',\n  'D7',\n  'D8',\n  'D9',\n  'DA',\n  'DB',\n  'DC',\n  'DD',\n  'DE',\n  'DF',\n  'E0',\n  'E1',\n  'E2',\n  'E3',\n  'E4',\n  'E5',\n  'E6',\n  'E7',\n  'E8',\n  'E9',\n  'EA',\n  'EB',\n  'EC',\n  'ED',\n  'EE',\n  'EF',\n  'F0',\n  'F1',\n  'F2',\n  'F3',\n  'F4',\n  'F5',\n  'F6',\n  'F7',\n  'F8',\n  'F9',\n  'FA',\n  'FB',\n  'FC',\n  'FD',\n  'FE',\n  'FF',\n];\n\n/* vector of base 64 characters */\nconst base64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='.split('');\n\n/* vector of base 64 character codes */\nconst base64codes = [];\nbase64chars.forEach((char) => {\n  base64codes.push(char.charCodeAt(0));\n});\n\n// The UTF8 algorithms.\nexports.utf8 = {\n  encode(chars) {\n    const bytes = [];\n    chars.forEach((char) => {\n      if (char >= 0 && char <= 0x7f) {\n        bytes.push(char);\n      } else if (char <= 0x7ff) {\n        bytes.push(0xc0 + ((char >> 6) & mask[5]));\n        bytes.push(0x80 + (char & mask[6]));\n      } else if (char < 0xd800 || (char > 0xdfff && char <= 0xffff)) {\n        bytes.push(0xe0 + ((char >> 12) & mask[4]));\n        bytes.push(0x80 + ((char >> 6) & mask[6]));\n        bytes.push(0x80 + (char & mask[6]));\n      } else if (char >= 0x10000 && char <= 0x10ffff) {\n        const u = (char >> 16) & mask[5];\n        bytes.push(0xf0 + (u >> 2));\n        bytes.push(0x80 + ((u & mask[2]) << 4) + ((char >> 12) & mask[4]));\n        bytes.push(0x80 + ((char >> 6) & mask[6]));\n        bytes.push(0x80 + (char & mask[6]));\n      } else {\n        throw new RangeError(`utf8.encode: character out of range: char: ${char}`);\n      }\n    });\n    return Buffer.from(bytes);\n  },\n  decode(buf, bom) {\n    /* bytes functions return error for non-shortest forms & values out of range */\n    function bytes2(b1, b2) {\n      /* U+0080..U+07FF */\n      /* 00000000 00000yyy yyxxxxxx | 110yyyyy 10xxxxxx */\n      if ((b2 & 0xc0) !== 0x80) {\n        return TRAILING;\n      }\n      const x = ((b1 & mask[5]) << 6) + (b2 & mask[6]);\n      if (x < 0x80) {\n        return NON_SHORTEST;\n      }\n      return x;\n    }\n    function bytes3(b1, b2, b3) {\n      /* U+0800..U+FFFF */\n      /* 00000000 zzzzyyyy yyxxxxxx | 1110zzzz 10yyyyyy 10xxxxxx */\n      if ((b3 & 0xc0) !== 0x80 || (b2 & 0xc0) !== 0x80) {\n        return TRAILING;\n      }\n      const x = ((b1 & mask[4]) << 12) + ((b2 & mask[6]) << 6) + (b3 & mask[6]);\n      if (x < 0x800) {\n        return NON_SHORTEST;\n      }\n      if (x >= 0xd800 && x <= 0xdfff) {\n        return RANGE;\n      }\n      return x;\n    }\n    function bytes4(b1, b2, b3, b4) {\n      /* U+10000..U+10FFFF */\n      /* 000uuuuu zzzzyyyy yyxxxxxx | 11110uuu 10uuzzzz 10yyyyyy 10xxxxxx */\n      if ((b4 & 0xc0) !== 0x80 || (b3 & 0xc0) !== 0x80 || (b2 & 0xc0) !== 0x80) {\n        return TRAILING;\n      }\n      const x =\n        ((((b1 & mask[3]) << 2) + ((b2 >> 4) & mask[2])) << 16) +\n        ((b2 & mask[4]) << 12) +\n        ((b3 & mask[6]) << 6) +\n        (b4 & mask[6]);\n      if (x < 0x10000) {\n        return NON_SHORTEST;\n      }\n      if (x > 0x10ffff) {\n        return RANGE;\n      }\n      return x;\n    }\n    let c;\n    let b1;\n    let i1;\n    let i2;\n    let i3;\n    let inc;\n    const len = buf.length;\n    let i = bom ? 3 : 0;\n    const chars = [];\n    while (i < len) {\n      b1 = buf[i];\n      c = ILL_FORMED;\n      const TRUE = true;\n      while (TRUE) {\n        if (b1 >= 0 && b1 <= 0x7f) {\n          /* U+0000..U+007F 00..7F */\n          c = b1;\n          inc = 1;\n          break;\n        }\n        i1 = i + 1;\n        if (i1 < len && b1 >= 0xc2 && b1 <= 0xdf) {\n          /* U+0080..U+07FF C2..DF 80..BF */\n          c = bytes2(b1, buf[i1]);\n          inc = 2;\n          break;\n        }\n        i2 = i + 2;\n        if (i2 < len && b1 >= 0xe0 && b1 <= 0xef) {\n          /* U+0800..U+FFFF */\n          c = bytes3(b1, buf[i1], buf[i2]);\n          inc = 3;\n          break;\n        }\n        i3 = i + 3;\n        if (i3 < len && b1 >= 0xf0 && b1 <= 0xf4) {\n          /* U+10000..U+10FFFF */\n          c = bytes4(b1, buf[i1], buf[i2], buf[i3]);\n          inc = 4;\n          break;\n        }\n        /* if we fall through to here, it is an ill-formed sequence */\n        break;\n      }\n      if (c > 0x10ffff) {\n        const at = `byte[${i}]`;\n        if (c === ILL_FORMED) {\n          throw new RangeError(`utf8.decode: ill-formed UTF8 byte sequence found at: ${at}`);\n        }\n        if (c === TRAILING) {\n          throw new RangeError(`utf8.decode: illegal trailing byte found at: ${at}`);\n        }\n        if (c === RANGE) {\n          throw new RangeError(`utf8.decode: code point out of range found at: ${at}`);\n        }\n        if (c === NON_SHORTEST) {\n          throw new RangeError(`utf8.decode: non-shortest form found at: ${at}`);\n        }\n        throw new RangeError(`utf8.decode: unrecognized error found at: ${at}`);\n      }\n      chars.push(c);\n      i += inc;\n    }\n    return chars;\n  },\n};\n\n// The UTF16BE algorithms.\nexports.utf16be = {\n  encode(chars) {\n    const bytes = [];\n    let char;\n    let h;\n    let l;\n    for (let i = 0; i < chars.length; i += 1) {\n      char = chars[i];\n      if ((char >= 0 && char <= 0xd7ff) || (char >= 0xe000 && char <= 0xffff)) {\n        bytes.push((char >> 8) & mask[8]);\n        bytes.push(char & mask[8]);\n      } else if (char >= 0x10000 && char <= 0x10ffff) {\n        l = char - 0x10000;\n        h = 0xd800 + (l >> 10);\n        l = 0xdc00 + (l & mask[10]);\n        bytes.push((h >> 8) & mask[8]);\n        bytes.push(h & mask[8]);\n        bytes.push((l >> 8) & mask[8]);\n        bytes.push(l & mask[8]);\n      } else {\n        throw new RangeError(`utf16be.encode: UTF16BE value out of range: char[${i}]: ${char}`);\n      }\n    }\n    return Buffer.from(bytes);\n  },\n  decode(buf, bom) {\n    /* assumes caller has insured that buf is a Buffer of bytes */\n    if (buf.length % 2 > 0) {\n      throw new RangeError(`utf16be.decode: data length must be even multiple of 2: length: ${buf.length}`);\n    }\n    const chars = [];\n    const len = buf.length;\n    let i = bom ? 2 : 0;\n    let j = 0;\n    let c;\n    let inc;\n    let i1;\n    let i3;\n    let high;\n    let low;\n    while (i < len) {\n      const TRUE = true;\n      while (TRUE) {\n        i1 = i + 1;\n        if (i1 < len) {\n          high = (buf[i] << 8) + buf[i1];\n          if (high < 0xd800 || high > 0xdfff) {\n            c = high;\n            inc = 2;\n            break;\n          }\n          i3 = i + 3;\n          if (i3 < len) {\n            low = (buf[i + 2] << 8) + buf[i3];\n            if (high <= 0xdbff && low >= 0xdc00 && low <= 0xdfff) {\n              c = 0x10000 + ((high - 0xd800) << 10) + (low - 0xdc00);\n              inc = 4;\n              break;\n            }\n          }\n        }\n        /* if we fall through to here, it is an ill-formed sequence */\n        throw new RangeError(`utf16be.decode: ill-formed UTF16BE byte sequence found: byte[${i}]`);\n      }\n      chars[j++] = c;\n      i += inc;\n    }\n    return chars;\n  },\n};\n\n// The UTF16LE algorithms.\nexports.utf16le = {\n  encode(chars) {\n    const bytes = [];\n    let char;\n    let h;\n    let l;\n    for (let i = 0; i < chars.length; i += 1) {\n      char = chars[i];\n      if ((char >= 0 && char <= 0xd7ff) || (char >= 0xe000 && char <= 0xffff)) {\n        bytes.push(char & mask[8]);\n        bytes.push((char >> 8) & mask[8]);\n      } else if (char >= 0x10000 && char <= 0x10ffff) {\n        l = char - 0x10000;\n        h = 0xd800 + (l >> 10);\n        l = 0xdc00 + (l & mask[10]);\n        bytes.push(h & mask[8]);\n        bytes.push((h >> 8) & mask[8]);\n        bytes.push(l & mask[8]);\n        bytes.push((l >> 8) & mask[8]);\n      } else {\n        throw new RangeError(`utf16le.encode: UTF16LE value out of range: char[${i}]: ${char}`);\n      }\n    }\n    return Buffer.from(bytes);\n  },\n  decode(buf, bom) {\n    /* assumes caller has insured that buf is a Buffer of bytes */\n    if (buf.length % 2 > 0) {\n      throw new RangeError(`utf16le.decode: data length must be even multiple of 2: length: ${buf.length}`);\n    }\n    const chars = [];\n    const len = buf.length;\n    let i = bom ? 2 : 0;\n    let j = 0;\n    let c;\n    let inc;\n    let i1;\n    let i3;\n    let high;\n    let low;\n    while (i < len) {\n      const TRUE = true;\n      while (TRUE) {\n        i1 = i + 1;\n        if (i1 < len) {\n          high = (buf[i1] << 8) + buf[i];\n          if (high < 0xd800 || high > 0xdfff) {\n            c = high;\n            inc = 2;\n            break;\n          }\n          i3 = i + 3;\n          if (i3 < len) {\n            low = (buf[i3] << 8) + buf[i + 2];\n            if (high <= 0xdbff && low >= 0xdc00 && low <= 0xdfff) {\n              c = 0x10000 + ((high - 0xd800) << 10) + (low - 0xdc00);\n              inc = 4;\n              break;\n            }\n          }\n        }\n        /* if we fall through to here, it is an ill-formed sequence */\n        throw new RangeError(`utf16le.decode: ill-formed UTF16LE byte sequence found: byte[${i}]`);\n      }\n      chars[j++] = c;\n      i += inc;\n    }\n    return chars;\n  },\n};\n\n// The UTF32BE algorithms.\nexports.utf32be = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length * 4);\n    let i = 0;\n    chars.forEach((char) => {\n      if ((char >= 0xd800 && char <= 0xdfff) || char > 0x10ffff) {\n        throw new RangeError(`utf32be.encode: UTF32BE character code out of range: char[${i / 4}]: ${char}`);\n      }\n      buf[i++] = (char >> 24) & mask[8];\n      buf[i++] = (char >> 16) & mask[8];\n      buf[i++] = (char >> 8) & mask[8];\n      buf[i++] = char & mask[8];\n    });\n    return buf;\n  },\n  decode(buf, bom) {\n    /* caller to insure buf is a Buffer of bytes */\n    if (buf.length % 4 > 0) {\n      throw new RangeError(`utf32be.decode: UTF32BE byte length must be even multiple of 4: length: ${buf.length}`);\n    }\n    const chars = [];\n    let i = bom ? 4 : 0;\n    for (; i < buf.length; i += 4) {\n      const char = (buf[i] << 24) + (buf[i + 1] << 16) + (buf[i + 2] << 8) + buf[i + 3];\n      if ((char >= 0xd800 && char <= 0xdfff) || char > 0x10ffff) {\n        throw new RangeError(`utf32be.decode: UTF32BE character code out of range: char[${i / 4}]: ${char}`);\n      }\n      chars.push(char);\n    }\n    return chars;\n  },\n};\n\n// The UTF32LE algorithms.\nexports.utf32le = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length * 4);\n    let i = 0;\n    chars.forEach((char) => {\n      if ((char >= 0xd800 && char <= 0xdfff) || char > 0x10ffff) {\n        throw new RangeError(`utf32le.encode: UTF32LE character code out of range: char[${i / 4}]: ${char}`);\n      }\n      buf[i++] = char & mask[8];\n      buf[i++] = (char >> 8) & mask[8];\n      buf[i++] = (char >> 16) & mask[8];\n      buf[i++] = (char >> 24) & mask[8];\n    });\n    return buf;\n  },\n  decode(buf, bom) {\n    /* caller to insure buf is a Buffer of bytes */\n    if (buf.length % 4 > 0) {\n      throw new RangeError(`utf32be.decode: UTF32LE byte length must be even multiple of 4: length: ${buf.length}`);\n    }\n    const chars = [];\n    let i = bom ? 4 : 0;\n    for (; i < buf.length; i += 4) {\n      const char = (buf[i + 3] << 24) + (buf[i + 2] << 16) + (buf[i + 1] << 8) + buf[i];\n      if ((char >= 0xd800 && char <= 0xdfff) || char > 0x10ffff) {\n        throw new RangeError(`utf32le.encode: UTF32LE character code out of range: char[${i / 4}]: ${char}`);\n      }\n      chars.push(char);\n    }\n    return chars;\n  },\n};\n\n// The UINT7 algorithms. ASCII or 7-bit unsigned integers.\nexports.uint7 = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length);\n    for (let i = 0; i < chars.length; i += 1) {\n      if (chars[i] > 0x7f) {\n        throw new RangeError(`uint7.encode: UINT7 character code out of range: char[${i}]: ${chars[i]}`);\n      }\n      buf[i] = chars[i];\n    }\n    return buf;\n  },\n  decode(buf) {\n    const chars = [];\n    for (let i = 0; i < buf.length; i += 1) {\n      if (buf[i] > 0x7f) {\n        throw new RangeError(`uint7.decode: UINT7 character code out of range: byte[${i}]: ${buf[i]}`);\n      }\n      chars[i] = buf[i];\n    }\n    return chars;\n  },\n};\n\n// The UINT8 algorithms. BINARY, Latin 1 or 8-bit unsigned integers.\nexports.uint8 = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length);\n    for (let i = 0; i < chars.length; i += 1) {\n      if (chars[i] > 0xff) {\n        throw new RangeError(`uint8.encode: UINT8 character code out of range: char[${i}]: ${chars[i]}`);\n      }\n      buf[i] = chars[i];\n    }\n    return buf;\n  },\n  decode(buf) {\n    const chars = [];\n    for (let i = 0; i < buf.length; i += 1) {\n      chars[i] = buf[i];\n    }\n    return chars;\n  },\n};\n\n// The UINT16BE algorithms. Big-endian 16-bit unsigned integers.\nexports.uint16be = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length * 2);\n    let i = 0;\n    chars.forEach((char) => {\n      if (char > 0xffff) {\n        throw new RangeError(`uint16be.encode: UINT16BE character code out of range: char[${i / 2}]: ${char}`);\n      }\n      buf[i++] = (char >> 8) & mask[8];\n      buf[i++] = char & mask[8];\n    });\n    return buf;\n  },\n  decode(buf) {\n    if (buf.length % 2 > 0) {\n      throw new RangeError(`uint16be.decode: UINT16BE byte length must be even multiple of 2: length: ${buf.length}`);\n    }\n    const chars = [];\n    for (let i = 0; i < buf.length; i += 2) {\n      chars.push((buf[i] << 8) + buf[i + 1]);\n    }\n    return chars;\n  },\n};\n\n// The UINT16LE algorithms. Little-endian 16-bit unsigned integers.\nexports.uint16le = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length * 2);\n    let i = 0;\n    chars.forEach((char) => {\n      if (char > 0xffff) {\n        throw new RangeError(`uint16le.encode: UINT16LE character code out of range: char[${i / 2}]: ${char}`);\n      }\n      buf[i++] = char & mask[8];\n      buf[i++] = (char >> 8) & mask[8];\n    });\n    return buf;\n  },\n  decode(buf) {\n    if (buf.length % 2 > 0) {\n      throw new RangeError(`uint16le.decode: UINT16LE byte length must be even multiple of 2: length: ${buf.length}`);\n    }\n    const chars = [];\n    for (let i = 0; i < buf.length; i += 2) {\n      chars.push((buf[i + 1] << 8) + buf[i]);\n    }\n    return chars;\n  },\n};\n\n// The UINT32BE algorithms. Big-endian 32-bit unsigned integers.\nexports.uint32be = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length * 4);\n    let i = 0;\n    chars.forEach((char) => {\n      buf[i++] = (char >> 24) & mask[8];\n      buf[i++] = (char >> 16) & mask[8];\n      buf[i++] = (char >> 8) & mask[8];\n      buf[i++] = char & mask[8];\n    });\n    return buf;\n  },\n  decode(buf) {\n    if (buf.length % 4 > 0) {\n      throw new RangeError(`uint32be.decode: UINT32BE byte length must be even multiple of 4: length: ${buf.length}`);\n    }\n    const chars = [];\n    for (let i = 0; i < buf.length; i += 4) {\n      chars.push((buf[i] << 24) + (buf[i + 1] << 16) + (buf[i + 2] << 8) + buf[i + 3]);\n    }\n    return chars;\n  },\n};\n\n// The UINT32LE algorithms. Little-endian 32-bit unsigned integers.\nexports.uint32le = {\n  encode(chars) {\n    const buf = Buffer.alloc(chars.length * 4);\n    let i = 0;\n    chars.forEach((char) => {\n      buf[i++] = char & mask[8];\n      buf[i++] = (char >> 8) & mask[8];\n      buf[i++] = (char >> 16) & mask[8];\n      buf[i++] = (char >> 24) & mask[8];\n    });\n    return buf;\n  },\n  decode(buf) {\n    /* caller to insure buf is a Buffer of bytes */\n    if (buf.length % 4 > 0) {\n      throw new RangeError(`uint32le.decode: UINT32LE byte length must be even multiple of 4: length: ${buf.length}`);\n    }\n    const chars = [];\n    for (let i = 0; i < buf.length; i += 4) {\n      chars.push((buf[i + 3] << 24) + (buf[i + 2] << 16) + (buf[i + 1] << 8) + buf[i]);\n    }\n    return chars;\n  },\n};\n\n// The STRING algorithms. Converts JavaScript strings to Array of 32-bit integers and vice versa.\n// Uses the node.js Buffer's native \"utf16le\" capabilites.\nexports.string = {\n  encode(chars) {\n    return exports.utf16le.encode(chars).toString('utf16le');\n  },\n  decode(str) {\n    return exports.utf16le.decode(Buffer.from(str, 'utf16le'), 0);\n  },\n};\n\n// The ESCAPED algorithms.\n// Note that ESCAPED format contains only ASCII characters.\n// The characters are always in the form of a Buffer of bytes.\nexports.escaped = {\n  // Encodes an Array of 32-bit integers into ESCAPED format.\n  encode(chars) {\n    const bytes = [];\n    for (let i = 0; i < chars.length; i += 1) {\n      const char = chars[i];\n      if (char === 96) {\n        bytes.push(char);\n        bytes.push(char);\n      } else if (char === 10) {\n        bytes.push(char);\n      } else if (char >= 32 && char <= 126) {\n        bytes.push(char);\n      } else {\n        let str = '';\n        if (char >= 0 && char <= 31) {\n          str += `\\`x${ascii[char]}`;\n        } else if (char >= 127 && char <= 255) {\n          str += `\\`x${ascii[char]}`;\n        } else if (char >= 0x100 && char <= 0xffff) {\n          str += `\\`u${ascii[(char >> 8) & mask[8]]}${ascii[char & mask[8]]}`;\n        } else if (char >= 0x10000 && char <= 0xffffffff) {\n          str += '`u{';\n          const digit = (char >> 24) & mask[8];\n          if (digit > 0) {\n            str += ascii[digit];\n          }\n          str += `${ascii[(char >> 16) & mask[8]] + ascii[(char >> 8) & mask[8]] + ascii[char & mask[8]]}}`;\n        } else {\n          throw new Error('escape.encode(char): char > 0xffffffff not allowed');\n        }\n        const buf = Buffer.from(str);\n        buf.forEach((b) => {\n          bytes.push(b);\n        });\n      }\n    }\n    return Buffer.from(bytes);\n  },\n  // Decodes ESCAPED format from a Buffer of bytes to an Array of 32-bit integers.\n  decode(buf) {\n    function isHex(hex) {\n      if ((hex >= 48 && hex <= 57) || (hex >= 65 && hex <= 70) || (hex >= 97 && hex <= 102)) {\n        return true;\n      }\n      return false;\n    }\n    function getx(i, len, bufArg) {\n      const ret = { char: null, nexti: i + 2, error: true };\n      if (i + 1 < len) {\n        if (isHex(bufArg[i]) && isHex(bufArg[i + 1])) {\n          const str = String.fromCodePoint(bufArg[i], bufArg[i + 1]);\n          ret.char = parseInt(str, 16);\n          if (!Number.isNaN(ret.char)) {\n            ret.error = false;\n          }\n        }\n      }\n      return ret;\n    }\n    function getu(i, len, bufArg) {\n      const ret = { char: null, nexti: i + 4, error: true };\n      if (i + 3 < len) {\n        if (isHex(bufArg[i]) && isHex(bufArg[i + 1]) && isHex(bufArg[i + 2]) && isHex(bufArg[i + 3])) {\n          const str = String.fromCodePoint(bufArg[i], bufArg[i + 1], bufArg[i + 2], bufArg[i + 3]);\n          ret.char = parseInt(str, 16);\n          if (!Number.isNaN(ret.char)) {\n            ret.error = false;\n          }\n        }\n      }\n      return ret;\n    }\n    function getU(i, len, bufArg) {\n      const ret = { char: null, nexti: i + 4, error: true };\n      let str = '';\n      while (i < len && isHex(bufArg[i])) {\n        str += String.fromCodePoint(bufArg[i]);\n        // eslint-disable-next-line no-param-reassign\n        i += 1;\n      }\n      ret.char = parseInt(str, 16);\n      if (bufArg[i] === 125 && !Number.isNaN(ret.char)) {\n        ret.error = false;\n      }\n      ret.nexti = i + 1;\n      return ret;\n    }\n    const chars = [];\n    const len = buf.length;\n    let i1;\n    let ret;\n    let error;\n    let i = 0;\n    while (i < len) {\n      const TRUE = true;\n      while (TRUE) {\n        error = true;\n        if (buf[i] !== 96) {\n          /* unescaped character */\n          chars.push(buf[i]);\n          i += 1;\n          error = false;\n          break;\n        }\n        i1 = i + 1;\n        if (i1 >= len) {\n          break;\n        }\n        if (buf[i1] === 96) {\n          /* escaped grave accent */\n          chars.push(96);\n          i += 2;\n          error = false;\n          break;\n        }\n        if (buf[i1] === 120) {\n          ret = getx(i1 + 1, len, buf);\n          if (ret.error) {\n            break;\n          }\n          /* escaped hex */\n          chars.push(ret.char);\n          i = ret.nexti;\n          error = false;\n          break;\n        }\n        if (buf[i1] === 117) {\n          if (buf[i1 + 1] === 123) {\n            ret = getU(i1 + 2, len, buf);\n            if (ret.error) {\n              break;\n            }\n            /* escaped utf-32 */\n            chars.push(ret.char);\n            i = ret.nexti;\n            error = false;\n            break;\n          }\n          ret = getu(i1 + 1, len, buf);\n          if (ret.error) {\n            break;\n          }\n          /* escaped utf-16 */\n          chars.push(ret.char);\n          i = ret.nexti;\n          error = false;\n          break;\n        }\n        break;\n      }\n      if (error) {\n        throw new Error(`escaped.decode: ill-formed escape sequence at buf[${i}]`);\n      }\n    }\n    return chars;\n  },\n};\n\n// The line end conversion algorigthms.\nconst CR = 13;\nconst LF = 10;\nexports.lineEnds = {\n  crlf(chars) {\n    const lfchars = [];\n    let i = 0;\n    while (i < chars.length) {\n      switch (chars[i]) {\n        case CR:\n          if (i + 1 < chars.length && chars[i + 1] === LF) {\n            i += 2;\n          } else {\n            i += 1;\n          }\n          lfchars.push(CR);\n          lfchars.push(LF);\n          break;\n        case LF:\n          lfchars.push(CR);\n          lfchars.push(LF);\n          i += 1;\n          break;\n        default:\n          lfchars.push(chars[i]);\n          i += 1;\n          break;\n      }\n    }\n    if (lfchars.length > 0 && lfchars[lfchars.length - 1] !== LF) {\n      lfchars.push(CR);\n      lfchars.push(LF);\n    }\n    return lfchars;\n  },\n  lf(chars) {\n    const lfchars = [];\n    let i = 0;\n    while (i < chars.length) {\n      switch (chars[i]) {\n        case CR:\n          if (i + 1 < chars.length && chars[i + 1] === LF) {\n            i += 2;\n          } else {\n            i += 1;\n          }\n          lfchars.push(LF);\n          break;\n        case LF:\n          lfchars.push(LF);\n          i += 1;\n          break;\n        default:\n          lfchars.push(chars[i]);\n          i += 1;\n          break;\n      }\n    }\n    if (lfchars.length > 0 && lfchars[lfchars.length - 1] !== LF) {\n      lfchars.push(LF);\n    }\n    return lfchars;\n  },\n};\n\n// The base 64 algorithms.\nexports.base64 = {\n  encode(buf) {\n    if (buf.length === 0) {\n      return Buffer.alloc(0);\n    }\n    let i;\n    let j;\n    let n;\n    let tail = buf.length % 3;\n    tail = tail > 0 ? 3 - tail : 0;\n    let units = (buf.length + tail) / 3;\n    const base64 = Buffer.alloc(units * 4);\n    if (tail > 0) {\n      units -= 1;\n    }\n    i = 0;\n    j = 0;\n    for (let u = 0; u < units; u += 1) {\n      n = buf[i++] << 16;\n      n += buf[i++] << 8;\n      n += buf[i++];\n      base64[j++] = base64codes[(n >> 18) & mask[6]];\n      base64[j++] = base64codes[(n >> 12) & mask[6]];\n      base64[j++] = base64codes[(n >> 6) & mask[6]];\n      base64[j++] = base64codes[n & mask[6]];\n    }\n    if (tail === 0) {\n      return base64;\n    }\n    if (tail === 1) {\n      n = buf[i++] << 16;\n      n += buf[i] << 8;\n      base64[j++] = base64codes[(n >> 18) & mask[6]];\n      base64[j++] = base64codes[(n >> 12) & mask[6]];\n      base64[j++] = base64codes[(n >> 6) & mask[6]];\n      base64[j] = base64codes[64];\n      return base64;\n    }\n    if (tail === 2) {\n      n = buf[i] << 16;\n      base64[j++] = base64codes[(n >> 18) & mask[6]];\n      base64[j++] = base64codes[(n >> 12) & mask[6]];\n      base64[j++] = base64codes[64];\n      base64[j] = base64codes[64];\n      return base64;\n    }\n    return undefined;\n  },\n  decode(codes) {\n    /* remove white space and ctrl characters, validate & translate characters */\n    function validate(buf) {\n      const chars = [];\n      let tail = 0;\n      for (let i = 0; i < buf.length; i += 1) {\n        const char = buf[i];\n        const TRUE = true;\n        while (TRUE) {\n          if (char === 32 || char === 9 || char === 10 || char === 13) {\n            break;\n          }\n          if (char >= 65 && char <= 90) {\n            chars.push(char - 65);\n            break;\n          }\n          if (char >= 97 && char <= 122) {\n            chars.push(char - 71);\n            break;\n          }\n          if (char >= 48 && char <= 57) {\n            chars.push(char + 4);\n            break;\n          }\n          if (char === 43) {\n            chars.push(62);\n            break;\n          }\n          if (char === 47) {\n            chars.push(63);\n            break;\n          }\n          if (char === 61) {\n            chars.push(64);\n            tail += 1;\n            break;\n          }\n          /* invalid character */\n          throw new RangeError(`base64.decode: invalid character buf[${i}]: ${char}`);\n        }\n      }\n      /* validate length */\n      if (chars.length % 4 > 0) {\n        throw new RangeError(`base64.decode: string length not integral multiple of 4: ${chars.length}`);\n      }\n      /* validate tail */\n      switch (tail) {\n        case 0:\n          break;\n        case 1:\n          if (chars[chars.length - 1] !== 64) {\n            throw new RangeError('base64.decode: one tail character found: not last character');\n          }\n          break;\n        case 2:\n          if (chars[chars.length - 1] !== 64 || chars[chars.length - 2] !== 64) {\n            throw new RangeError('base64.decode: two tail characters found: not last characters');\n          }\n          break;\n        default:\n          throw new RangeError(`base64.decode: more than two tail characters found: ${tail}`);\n      }\n      return { tail, buf: Buffer.from(chars) };\n    }\n\n    if (codes.length === 0) {\n      return Buffer.alloc(0);\n    }\n    const val = validate(codes);\n    const { tail } = val;\n    const base64 = val.buf;\n    let i;\n    let j;\n    let n;\n    let units = base64.length / 4;\n    const buf = Buffer.alloc(units * 3 - tail);\n    if (tail > 0) {\n      units -= 1;\n    }\n    j = 0;\n    i = 0;\n    for (let u = 0; u < units; u += 1) {\n      n = base64[i++] << 18;\n      n += base64[i++] << 12;\n      n += base64[i++] << 6;\n      n += base64[i++];\n      buf[j++] = (n >> 16) & mask[8];\n      buf[j++] = (n >> 8) & mask[8];\n      buf[j++] = n & mask[8];\n    }\n    if (tail === 1) {\n      n = base64[i++] << 18;\n      n += base64[i++] << 12;\n      n += base64[i] << 6;\n      buf[j++] = (n >> 16) & mask[8];\n      buf[j] = (n >> 8) & mask[8];\n    }\n    if (tail === 2) {\n      n = base64[i++] << 18;\n      n += base64[i++] << 12;\n      buf[j] = (n >> 16) & mask[8];\n    }\n    return buf;\n  },\n  // Converts a base 64 Buffer of bytes to a JavaScript string with line breaks.\n  toString(buf) {\n    if (buf.length % 4 > 0) {\n      throw new RangeError(`base64.toString: input buffer length not multiple of 4: ${buf.length}`);\n    }\n    let str = '';\n    let lineLen = 0;\n    function buildLine(c1, c2, c3, c4) {\n      switch (lineLen) {\n        case 76:\n          str += `\\r\\n${c1}${c2}${c3}${c4}`;\n          lineLen = 4;\n          break;\n        case 75:\n          str += `${c1}\\r\\n${c2}${c3}${c4}`;\n          lineLen = 3;\n          break;\n        case 74:\n          str += `${c1 + c2}\\r\\n${c3}${c4}`;\n          lineLen = 2;\n          break;\n        case 73:\n          str += `${c1 + c2 + c3}\\r\\n${c4}`;\n          lineLen = 1;\n          break;\n        default:\n          str += c1 + c2 + c3 + c4;\n          lineLen += 4;\n          break;\n      }\n    }\n    function validate(c) {\n      if (c >= 65 && c <= 90) {\n        return true;\n      }\n      if (c >= 97 && c <= 122) {\n        return true;\n      }\n      if (c >= 48 && c <= 57) {\n        return true;\n      }\n      if (c === 43) {\n        return true;\n      }\n      if (c === 47) {\n        return true;\n      }\n      if (c === 61) {\n        return true;\n      }\n      return false;\n    }\n    for (let i = 0; i < buf.length; i += 4) {\n      for (let j = i; j < i + 4; j += 1) {\n        if (!validate(buf[j])) {\n          throw new RangeError(`base64.toString: buf[${j}]: ${buf[j]} : not valid base64 character code`);\n        }\n      }\n      buildLine(\n        String.fromCharCode(buf[i]),\n        String.fromCharCode(buf[i + 1]),\n        String.fromCharCode(buf[i + 2]),\n        String.fromCharCode(buf[i + 3])\n      );\n    }\n    return str;\n  },\n};\n"],"names":[],"mappings":"AAAA,uCAAuC,GACvC,8BAA8B,GAC9B,6BAA6B,GAC7B;;;uFAGuF,GACvF,oEAAoE;AACpE,6FAA6F;AAI7F,MAAM,EAAE,MAAM,EAAE;AAEhB,wBAAwB,GACxB,MAAM,eAAe;AACrB,MAAM,WAAW;AACjB,MAAM,QAAQ;AACd,MAAM,aAAa;AAEnB,wEAAwE,GACxE,MAAM,OAAO;IAAC;IAAG;IAAG;IAAG;IAAG;IAAI;IAAI;IAAI;IAAK;IAAK;IAAK;CAAK;AAE1D,0DAA0D,GAC1D,MAAM,QAAQ;IACZ;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AAED,gCAAgC,GAChC,MAAM,cAAc,oEAAoE,KAAK,CAAC;AAE9F,qCAAqC,GACrC,MAAM,cAAc,EAAE;AACtB,YAAY,OAAO,CAAC,CAAC;IACnB,YAAY,IAAI,CAAC,KAAK,UAAU,CAAC;AACnC;AAEA,uBAAuB;AACvB,QAAQ,IAAI,GAAG;IACb,QAAO,KAAK;QACV,MAAM,QAAQ,EAAE;QAChB,MAAM,OAAO,CAAC,CAAC;YACb,IAAI,QAAQ,KAAK,QAAQ,MAAM;gBAC7B,MAAM,IAAI,CAAC;YACb,OAAO,IAAI,QAAQ,OAAO;gBACxB,MAAM,IAAI,CAAC,OAAO,CAAC,AAAC,QAAQ,IAAK,IAAI,CAAC,EAAE;gBACxC,MAAM,IAAI,CAAC,OAAO,CAAC,OAAO,IAAI,CAAC,EAAE;YACnC,OAAO,IAAI,OAAO,UAAW,OAAO,UAAU,QAAQ,QAAS;gBAC7D,MAAM,IAAI,CAAC,OAAO,CAAC,AAAC,QAAQ,KAAM,IAAI,CAAC,EAAE;gBACzC,MAAM,IAAI,CAAC,OAAO,CAAC,AAAC,QAAQ,IAAK,IAAI,CAAC,EAAE;gBACxC,MAAM,IAAI,CAAC,OAAO,CAAC,OAAO,IAAI,CAAC,EAAE;YACnC,OAAO,IAAI,QAAQ,WAAW,QAAQ,UAAU;gBAC9C,MAAM,IAAI,AAAC,QAAQ,KAAM,IAAI,CAAC,EAAE;gBAChC,MAAM,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC;gBACzB,MAAM,IAAI,CAAC,OAAO,CAAC,CAAC,IAAI,IAAI,CAAC,EAAE,KAAK,CAAC,IAAI,CAAC,AAAC,QAAQ,KAAM,IAAI,CAAC,EAAE;gBAChE,MAAM,IAAI,CAAC,OAAO,CAAC,AAAC,QAAQ,IAAK,IAAI,CAAC,EAAE;gBACxC,MAAM,IAAI,CAAC,OAAO,CAAC,OAAO,IAAI,CAAC,EAAE;YACnC,OAAO;gBACL,MAAM,IAAI,WAAW,CAAC,2CAA2C,EAAE,MAAM;YAC3E;QACF;QACA,OAAO,OAAO,IAAI,CAAC;IACrB;IACA,QAAO,GAAG,EAAE,GAAG;QACb,6EAA6E,GAC7E,SAAS,OAAO,EAAE,EAAE,EAAE;YACpB,kBAAkB,GAClB,kDAAkD,GAClD,IAAI,CAAC,KAAK,IAAI,MAAM,MAAM;gBACxB,OAAO;YACT;YACA,MAAM,IAAI,CAAC,CAAC,KAAK,IAAI,CAAC,EAAE,KAAK,CAAC,IAAI,CAAC,KAAK,IAAI,CAAC,EAAE;YAC/C,IAAI,IAAI,MAAM;gBACZ,OAAO;YACT;YACA,OAAO;QACT;QACA,SAAS,OAAO,EAAE,EAAE,EAAE,EAAE,EAAE;YACxB,kBAAkB,GAClB,2DAA2D,GAC3D,IAAI,CAAC,KAAK,IAAI,MAAM,QAAQ,CAAC,KAAK,IAAI,MAAM,MAAM;gBAChD,OAAO;YACT;YACA,MAAM,IAAI,CAAC,CAAC,KAAK,IAAI,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC,KAAK,IAAI,CAAC,EAAE,KAAK,CAAC,IAAI,CAAC,KAAK,IAAI,CAAC,EAAE;YACxE,IAAI,IAAI,OAAO;gBACb,OAAO;YACT;YACA,IAAI,KAAK,UAAU,KAAK,QAAQ;gBAC9B,OAAO;YACT;YACA,OAAO;QACT;QACA,SAAS,OAAO,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE;YAC5B,qBAAqB,GACrB,oEAAoE,GACpE,IAAI,CAAC,KAAK,IAAI,MAAM,QAAQ,CAAC,KAAK,IAAI,MAAM,QAAQ,CAAC,KAAK,IAAI,MAAM,MAAM;gBACxE,OAAO;YACT;YACA,MAAM,IACJ,CAAC,AAAC,CAAC,CAAC,KAAK,IAAI,CAAC,EAAE,KAAK,CAAC,IAAI,CAAC,AAAC,MAAM,IAAK,IAAI,CAAC,EAAE,KAAM,EAAE,IACtD,CAAC,CAAC,KAAK,IAAI,CAAC,EAAE,KAAK,EAAE,IACrB,CAAC,CAAC,KAAK,IAAI,CAAC,EAAE,KAAK,CAAC,IACpB,CAAC,KAAK,IAAI,CAAC,EAAE;YACf,IAAI,IAAI,SAAS;gBACf,OAAO;YACT;YACA,IAAI,IAAI,UAAU;gBAChB,OAAO;YACT;YACA,OAAO;QACT;QACA,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,MAAM,MAAM,IAAI,MAAM;QACtB,IAAI,IAAI,MAAM,IAAI;QAClB,MAAM,QAAQ,EAAE;QAChB,MAAO,IAAI,IAAK;YACd,KAAK,GAAG,CAAC,EAAE;YACX,IAAI;YACJ,MAAM,OAAO;YACb,MAAO,KAAM;gBACX,IAAI,MAAM,KAAK,MAAM,MAAM;oBACzB,yBAAyB,GACzB,IAAI;oBACJ,MAAM;oBACN;gBACF;gBACA,KAAK,IAAI;gBACT,IAAI,KAAK,OAAO,MAAM,QAAQ,MAAM,MAAM;oBACxC,gCAAgC,GAChC,IAAI,OAAO,IAAI,GAAG,CAAC,GAAG;oBACtB,MAAM;oBACN;gBACF;gBACA,KAAK,IAAI;gBACT,IAAI,KAAK,OAAO,MAAM,QAAQ,MAAM,MAAM;oBACxC,kBAAkB,GAClB,IAAI,OAAO,IAAI,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,GAAG;oBAC/B,MAAM;oBACN;gBACF;gBACA,KAAK,IAAI;gBACT,IAAI,KAAK,OAAO,MAAM,QAAQ,MAAM,MAAM;oBACxC,qBAAqB,GACrB,IAAI,OAAO,IAAI,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC,GAAG;oBACxC,MAAM;oBACN;gBACF;gBAEA;YACF;YACA,IAAI,IAAI,UAAU;gBAChB,MAAM,KAAK,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;gBACvB,IAAI,MAAM,YAAY;oBACpB,MAAM,IAAI,WAAW,CAAC,qDAAqD,EAAE,IAAI;gBACnF;gBACA,IAAI,MAAM,UAAU;oBAClB,MAAM,IAAI,WAAW,CAAC,6CAA6C,EAAE,IAAI;gBAC3E;gBACA,IAAI,MAAM,OAAO;oBACf,MAAM,IAAI,WAAW,CAAC,+CAA+C,EAAE,IAAI;gBAC7E;gBACA,IAAI,MAAM,cAAc;oBACtB,MAAM,IAAI,WAAW,CAAC,yCAAyC,EAAE,IAAI;gBACvE;gBACA,MAAM,IAAI,WAAW,CAAC,0CAA0C,EAAE,IAAI;YACxE;YACA,MAAM,IAAI,CAAC;YACX,KAAK;QACP;QACA,OAAO;IACT;AACF;AAEA,0BAA0B;AAC1B,QAAQ,OAAO,GAAG;IAChB,QAAO,KAAK;QACV,MAAM,QAAQ,EAAE;QAChB,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,KAAK,EAAG;YACxC,OAAO,KAAK,CAAC,EAAE;YACf,IAAI,AAAC,QAAQ,KAAK,QAAQ,UAAY,QAAQ,UAAU,QAAQ,QAAS;gBACvE,MAAM,IAAI,CAAC,AAAC,QAAQ,IAAK,IAAI,CAAC,EAAE;gBAChC,MAAM,IAAI,CAAC,OAAO,IAAI,CAAC,EAAE;YAC3B,OAAO,IAAI,QAAQ,WAAW,QAAQ,UAAU;gBAC9C,IAAI,OAAO;gBACX,IAAI,SAAS,CAAC,KAAK,EAAE;gBACrB,IAAI,SAAS,CAAC,IAAI,IAAI,CAAC,GAAG;gBAC1B,MAAM,IAAI,CAAC,AAAC,KAAK,IAAK,IAAI,CAAC,EAAE;gBAC7B,MAAM,IAAI,CAAC,IAAI,IAAI,CAAC,EAAE;gBACtB,MAAM,IAAI,CAAC,AAAC,KAAK,IAAK,IAAI,CAAC,EAAE;gBAC7B,MAAM,IAAI,CAAC,IAAI,IAAI,CAAC,EAAE;YACxB,OAAO;gBACL,MAAM,IAAI,WAAW,CAAC,iDAAiD,EAAE,EAAE,GAAG,EAAE,MAAM;YACxF;QACF;QACA,OAAO,OAAO,IAAI,CAAC;IACrB;IACA,QAAO,GAAG,EAAE,GAAG;QACb,4DAA4D,GAC5D,IAAI,IAAI,MAAM,GAAG,IAAI,GAAG;YACtB,MAAM,IAAI,WAAW,CAAC,gEAAgE,EAAE,IAAI,MAAM,EAAE;QACtG;QACA,MAAM,QAAQ,EAAE;QAChB,MAAM,MAAM,IAAI,MAAM;QACtB,IAAI,IAAI,MAAM,IAAI;QAClB,IAAI,IAAI;QACR,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,MAAO,IAAI,IAAK;YACd,MAAM,OAAO;YACb,MAAO,KAAM;gBACX,KAAK,IAAI;gBACT,IAAI,KAAK,KAAK;oBACZ,OAAO,CAAC,GAAG,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,CAAC,GAAG;oBAC9B,IAAI,OAAO,UAAU,OAAO,QAAQ;wBAClC,IAAI;wBACJ,MAAM;wBACN;oBACF;oBACA,KAAK,IAAI;oBACT,IAAI,KAAK,KAAK;wBACZ,MAAM,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,GAAG,CAAC,GAAG;wBACjC,IAAI,QAAQ,UAAU,OAAO,UAAU,OAAO,QAAQ;4BACpD,IAAI,UAAU,CAAC,AAAC,OAAO,UAAW,EAAE,IAAI,CAAC,MAAM,MAAM;4BACrD,MAAM;4BACN;wBACF;oBACF;gBACF;gBACA,4DAA4D,GAC5D,MAAM,IAAI,WAAW,CAAC,6DAA6D,EAAE,EAAE,CAAC,CAAC;YAC3F;YACA,KAAK,CAAC,IAAI,GAAG;YACb,KAAK;QACP;QACA,OAAO;IACT;AACF;AAEA,0BAA0B;AAC1B,QAAQ,OAAO,GAAG;IAChB,QAAO,KAAK;QACV,MAAM,QAAQ,EAAE;QAChB,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,KAAK,EAAG;YACxC,OAAO,KAAK,CAAC,EAAE;YACf,IAAI,AAAC,QAAQ,KAAK,QAAQ,UAAY,QAAQ,UAAU,QAAQ,QAAS;gBACvE,MAAM,IAAI,CAAC,OAAO,IAAI,CAAC,EAAE;gBACzB,MAAM,IAAI,CAAC,AAAC,QAAQ,IAAK,IAAI,CAAC,EAAE;YAClC,OAAO,IAAI,QAAQ,WAAW,QAAQ,UAAU;gBAC9C,IAAI,OAAO;gBACX,IAAI,SAAS,CAAC,KAAK,EAAE;gBACrB,IAAI,SAAS,CAAC,IAAI,IAAI,CAAC,GAAG;gBAC1B,MAAM,IAAI,CAAC,IAAI,IAAI,CAAC,EAAE;gBACtB,MAAM,IAAI,CAAC,AAAC,KAAK,IAAK,IAAI,CAAC,EAAE;gBAC7B,MAAM,IAAI,CAAC,IAAI,IAAI,CAAC,EAAE;gBACtB,MAAM,IAAI,CAAC,AAAC,KAAK,IAAK,IAAI,CAAC,EAAE;YAC/B,OAAO;gBACL,MAAM,IAAI,WAAW,CAAC,iDAAiD,EAAE,EAAE,GAAG,EAAE,MAAM;YACxF;QACF;QACA,OAAO,OAAO,IAAI,CAAC;IACrB;IACA,QAAO,GAAG,EAAE,GAAG;QACb,4DAA4D,GAC5D,IAAI,IAAI,MAAM,GAAG,IAAI,GAAG;YACtB,MAAM,IAAI,WAAW,CAAC,gEAAgE,EAAE,IAAI,MAAM,EAAE;QACtG;QACA,MAAM,QAAQ,EAAE;QAChB,MAAM,MAAM,IAAI,MAAM;QACtB,IAAI,IAAI,MAAM,IAAI;QAClB,IAAI,IAAI;QACR,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,MAAO,IAAI,IAAK;YACd,MAAM,OAAO;YACb,MAAO,KAAM;gBACX,KAAK,IAAI;gBACT,IAAI,KAAK,KAAK;oBACZ,OAAO,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,IAAI,GAAG,CAAC,EAAE;oBAC9B,IAAI,OAAO,UAAU,OAAO,QAAQ;wBAClC,IAAI;wBACJ,MAAM;wBACN;oBACF;oBACA,KAAK,IAAI;oBACT,IAAI,KAAK,KAAK;wBACZ,MAAM,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,IAAI,GAAG,CAAC,IAAI,EAAE;wBACjC,IAAI,QAAQ,UAAU,OAAO,UAAU,OAAO,QAAQ;4BACpD,IAAI,UAAU,CAAC,AAAC,OAAO,UAAW,EAAE,IAAI,CAAC,MAAM,MAAM;4BACrD,MAAM;4BACN;wBACF;oBACF;gBACF;gBACA,4DAA4D,GAC5D,MAAM,IAAI,WAAW,CAAC,6DAA6D,EAAE,EAAE,CAAC,CAAC;YAC3F;YACA,KAAK,CAAC,IAAI,GAAG;YACb,KAAK;QACP;QACA,OAAO;IACT;AACF;AAEA,0BAA0B;AAC1B,QAAQ,OAAO,GAAG;IAChB,QAAO,KAAK;QACV,MAAM,MAAM,OAAO,KAAK,CAAC,MAAM,MAAM,GAAG;QACxC,IAAI,IAAI;QACR,MAAM,OAAO,CAAC,CAAC;YACb,IAAI,AAAC,QAAQ,UAAU,QAAQ,UAAW,OAAO,UAAU;gBACzD,MAAM,IAAI,WAAW,CAAC,0DAA0D,EAAE,IAAI,EAAE,GAAG,EAAE,MAAM;YACrG;YACA,GAAG,CAAC,IAAI,GAAG,AAAC,QAAQ,KAAM,IAAI,CAAC,EAAE;YACjC,GAAG,CAAC,IAAI,GAAG,AAAC,QAAQ,KAAM,IAAI,CAAC,EAAE;YACjC,GAAG,CAAC,IAAI,GAAG,AAAC,QAAQ,IAAK,IAAI,CAAC,EAAE;YAChC,GAAG,CAAC,IAAI,GAAG,OAAO,IAAI,CAAC,EAAE;QAC3B;QACA,OAAO;IACT;IACA,QAAO,GAAG,EAAE,GAAG;QACb,6CAA6C,GAC7C,IAAI,IAAI,MAAM,GAAG,IAAI,GAAG;YACtB,MAAM,IAAI,WAAW,CAAC,wEAAwE,EAAE,IAAI,MAAM,EAAE;QAC9G;QACA,MAAM,QAAQ,EAAE;QAChB,IAAI,IAAI,MAAM,IAAI;QAClB,MAAO,IAAI,IAAI,MAAM,EAAE,KAAK,EAAG;YAC7B,MAAM,OAAO,CAAC,GAAG,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,GAAG,CAAC,IAAI,EAAE;YACjF,IAAI,AAAC,QAAQ,UAAU,QAAQ,UAAW,OAAO,UAAU;gBACzD,MAAM,IAAI,WAAW,CAAC,0DAA0D,EAAE,IAAI,EAAE,GAAG,EAAE,MAAM;YACrG;YACA,MAAM,IAAI,CAAC;QACb;QACA,OAAO;IACT;AACF;AAEA,0BAA0B;AAC1B,QAAQ,OAAO,GAAG;IAChB,QAAO,KAAK;QACV,MAAM,MAAM,OAAO,KAAK,CAAC,MAAM,MAAM,GAAG;QACxC,IAAI,IAAI;QACR,MAAM,OAAO,CAAC,CAAC;YACb,IAAI,AAAC,QAAQ,UAAU,QAAQ,UAAW,OAAO,UAAU;gBACzD,MAAM,IAAI,WAAW,CAAC,0DAA0D,EAAE,IAAI,EAAE,GAAG,EAAE,MAAM;YACrG;YACA,GAAG,CAAC,IAAI,GAAG,OAAO,IAAI,CAAC,EAAE;YACzB,GAAG,CAAC,IAAI,GAAG,AAAC,QAAQ,IAAK,IAAI,CAAC,EAAE;YAChC,GAAG,CAAC,IAAI,GAAG,AAAC,QAAQ,KAAM,IAAI,CAAC,EAAE;YACjC,GAAG,CAAC,IAAI,GAAG,AAAC,QAAQ,KAAM,IAAI,CAAC,EAAE;QACnC;QACA,OAAO;IACT;IACA,QAAO,GAAG,EAAE,GAAG;QACb,6CAA6C,GAC7C,IAAI,IAAI,MAAM,GAAG,IAAI,GAAG;YACtB,MAAM,IAAI,WAAW,CAAC,wEAAwE,EAAE,IAAI,MAAM,EAAE;QAC9G;QACA,MAAM,QAAQ,EAAE;QAChB,IAAI,IAAI,MAAM,IAAI;QAClB,MAAO,IAAI,IAAI,MAAM,EAAE,KAAK,EAAG;YAC7B,MAAM,OAAO,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,GAAG,CAAC,EAAE;YACjF,IAAI,AAAC,QAAQ,UAAU,QAAQ,UAAW,OAAO,UAAU;gBACzD,MAAM,IAAI,WAAW,CAAC,0DAA0D,EAAE,IAAI,EAAE,GAAG,EAAE,MAAM;YACrG;YACA,MAAM,IAAI,CAAC;QACb;QACA,OAAO;IACT;AACF;AAEA,0DAA0D;AAC1D,QAAQ,KAAK,GAAG;IACd,QAAO,KAAK;QACV,MAAM,MAAM,OAAO,KAAK,CAAC,MAAM,MAAM;QACrC,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,KAAK,EAAG;YACxC,IAAI,KAAK,CAAC,EAAE,GAAG,MAAM;gBACnB,MAAM,IAAI,WAAW,CAAC,sDAAsD,EAAE,EAAE,GAAG,EAAE,KAAK,CAAC,EAAE,EAAE;YACjG;YACA,GAAG,CAAC,EAAE,GAAG,KAAK,CAAC,EAAE;QACnB;QACA,OAAO;IACT;IACA,QAAO,GAAG;QACR,MAAM,QAAQ,EAAE;QAChB,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,MAAM,EAAE,KAAK,EAAG;YACtC,IAAI,GAAG,CAAC,EAAE,GAAG,MAAM;gBACjB,MAAM,IAAI,WAAW,CAAC,sDAAsD,EAAE,EAAE,GAAG,EAAE,GAAG,CAAC,EAAE,EAAE;YAC/F;YACA,KAAK,CAAC,EAAE,GAAG,GAAG,CAAC,EAAE;QACnB;QACA,OAAO;IACT;AACF;AAEA,oEAAoE;AACpE,QAAQ,KAAK,GAAG;IACd,QAAO,KAAK;QACV,MAAM,MAAM,OAAO,KAAK,CAAC,MAAM,MAAM;QACrC,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,KAAK,EAAG;YACxC,IAAI,KAAK,CAAC,EAAE,GAAG,MAAM;gBACnB,MAAM,IAAI,WAAW,CAAC,sDAAsD,EAAE,EAAE,GAAG,EAAE,KAAK,CAAC,EAAE,EAAE;YACjG;YACA,GAAG,CAAC,EAAE,GAAG,KAAK,CAAC,EAAE;QACnB;QACA,OAAO;IACT;IACA,QAAO,GAAG;QACR,MAAM,QAAQ,EAAE;QAChB,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,MAAM,EAAE,KAAK,EAAG;YACtC,KAAK,CAAC,EAAE,GAAG,GAAG,CAAC,EAAE;QACnB;QACA,OAAO;IACT;AACF;AAEA,gEAAgE;AAChE,QAAQ,QAAQ,GAAG;IACjB,QAAO,KAAK;QACV,MAAM,MAAM,OAAO,KAAK,CAAC,MAAM,MAAM,GAAG;QACxC,IAAI,IAAI;QACR,MAAM,OAAO,CAAC,CAAC;YACb,IAAI,OAAO,QAAQ;gBACjB,MAAM,IAAI,WAAW,CAAC,4DAA4D,EAAE,IAAI,EAAE,GAAG,EAAE,MAAM;YACvG;YACA,GAAG,CAAC,IAAI,GAAG,AAAC,QAAQ,IAAK,IAAI,CAAC,EAAE;YAChC,GAAG,CAAC,IAAI,GAAG,OAAO,IAAI,CAAC,EAAE;QAC3B;QACA,OAAO;IACT;IACA,QAAO,GAAG;QACR,IAAI,IAAI,MAAM,GAAG,IAAI,GAAG;YACtB,MAAM,IAAI,WAAW,CAAC,0EAA0E,EAAE,IAAI,MAAM,EAAE;QAChH;QACA,MAAM,QAAQ,EAAE;QAChB,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,MAAM,EAAE,KAAK,EAAG;YACtC,MAAM,IAAI,CAAC,CAAC,GAAG,CAAC,EAAE,IAAI,CAAC,IAAI,GAAG,CAAC,IAAI,EAAE;QACvC;QACA,OAAO;IACT;AACF;AAEA,mEAAmE;AACnE,QAAQ,QAAQ,GAAG;IACjB,QAAO,KAAK;QACV,MAAM,MAAM,OAAO,KAAK,CAAC,MAAM,MAAM,GAAG;QACxC,IAAI,IAAI;QACR,MAAM,OAAO,CAAC,CAAC;YACb,IAAI,OAAO,QAAQ;gBACjB,MAAM,IAAI,WAAW,CAAC,4DAA4D,EAAE,IAAI,EAAE,GAAG,EAAE,MAAM;YACvG;YACA,GAAG,CAAC,IAAI,GAAG,OAAO,IAAI,CAAC,EAAE;YACzB,GAAG,CAAC,IAAI,GAAG,AAAC,QAAQ,IAAK,IAAI,CAAC,EAAE;QAClC;QACA,OAAO;IACT;IACA,QAAO,GAAG;QACR,IAAI,IAAI,MAAM,GAAG,IAAI,GAAG;YACtB,MAAM,IAAI,WAAW,CAAC,0EAA0E,EAAE,IAAI,MAAM,EAAE;QAChH;QACA,MAAM,QAAQ,EAAE;QAChB,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,MAAM,EAAE,KAAK,EAAG;YACtC,MAAM,IAAI,CAAC,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,GAAG,CAAC,EAAE;QACvC;QACA,OAAO;IACT;AACF;AAEA,gEAAgE;AAChE,QAAQ,QAAQ,GAAG;IACjB,QAAO,KAAK;QACV,MAAM,MAAM,OAAO,KAAK,CAAC,MAAM,MAAM,GAAG;QACxC,IAAI,IAAI;QACR,MAAM,OAAO,CAAC,CAAC;YACb,GAAG,CAAC,IAAI,GAAG,AAAC,QAAQ,KAAM,IAAI,CAAC,EAAE;YACjC,GAAG,CAAC,IAAI,GAAG,AAAC,QAAQ,KAAM,IAAI,CAAC,EAAE;YACjC,GAAG,CAAC,IAAI,GAAG,AAAC,QAAQ,IAAK,IAAI,CAAC,EAAE;YAChC,GAAG,CAAC,IAAI,GAAG,OAAO,IAAI,CAAC,EAAE;QAC3B;QACA,OAAO;IACT;IACA,QAAO,GAAG;QACR,IAAI,IAAI,MAAM,GAAG,IAAI,GAAG;YACtB,MAAM,IAAI,WAAW,CAAC,0EAA0E,EAAE,IAAI,MAAM,EAAE;QAChH;QACA,MAAM,QAAQ,EAAE;QAChB,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,MAAM,EAAE,KAAK,EAAG;YACtC,MAAM,IAAI,CAAC,CAAC,GAAG,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,GAAG,CAAC,IAAI,EAAE;QACjF;QACA,OAAO;IACT;AACF;AAEA,mEAAmE;AACnE,QAAQ,QAAQ,GAAG;IACjB,QAAO,KAAK;QACV,MAAM,MAAM,OAAO,KAAK,CAAC,MAAM,MAAM,GAAG;QACxC,IAAI,IAAI;QACR,MAAM,OAAO,CAAC,CAAC;YACb,GAAG,CAAC,IAAI,GAAG,OAAO,IAAI,CAAC,EAAE;YACzB,GAAG,CAAC,IAAI,GAAG,AAAC,QAAQ,IAAK,IAAI,CAAC,EAAE;YAChC,GAAG,CAAC,IAAI,GAAG,AAAC,QAAQ,KAAM,IAAI,CAAC,EAAE;YACjC,GAAG,CAAC,IAAI,GAAG,AAAC,QAAQ,KAAM,IAAI,CAAC,EAAE;QACnC;QACA,OAAO;IACT;IACA,QAAO,GAAG;QACR,6CAA6C,GAC7C,IAAI,IAAI,MAAM,GAAG,IAAI,GAAG;YACtB,MAAM,IAAI,WAAW,CAAC,0EAA0E,EAAE,IAAI,MAAM,EAAE;QAChH;QACA,MAAM,QAAQ,EAAE;QAChB,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,MAAM,EAAE,KAAK,EAAG;YACtC,MAAM,IAAI,CAAC,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC,GAAG,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,GAAG,CAAC,EAAE;QACjF;QACA,OAAO;IACT;AACF;AAEA,iGAAiG;AACjG,0DAA0D;AAC1D,QAAQ,MAAM,GAAG;IACf,QAAO,KAAK;QACV,OAAO,QAAQ,OAAO,CAAC,MAAM,CAAC,OAAO,QAAQ,CAAC;IAChD;IACA,QAAO,GAAG;QACR,OAAO,QAAQ,OAAO,CAAC,MAAM,CAAC,OAAO,IAAI,CAAC,KAAK,YAAY;IAC7D;AACF;AAEA,0BAA0B;AAC1B,2DAA2D;AAC3D,8DAA8D;AAC9D,QAAQ,OAAO,GAAG;IAChB,2DAA2D;IAC3D,QAAO,KAAK;QACV,MAAM,QAAQ,EAAE;QAChB,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,KAAK,EAAG;YACxC,MAAM,OAAO,KAAK,CAAC,EAAE;YACrB,IAAI,SAAS,IAAI;gBACf,MAAM,IAAI,CAAC;gBACX,MAAM,IAAI,CAAC;YACb,OAAO,IAAI,SAAS,IAAI;gBACtB,MAAM,IAAI,CAAC;YACb,OAAO,IAAI,QAAQ,MAAM,QAAQ,KAAK;gBACpC,MAAM,IAAI,CAAC;YACb,OAAO;gBACL,IAAI,MAAM;gBACV,IAAI,QAAQ,KAAK,QAAQ,IAAI;oBAC3B,OAAO,CAAC,GAAG,EAAE,KAAK,CAAC,KAAK,EAAE;gBAC5B,OAAO,IAAI,QAAQ,OAAO,QAAQ,KAAK;oBACrC,OAAO,CAAC,GAAG,EAAE,KAAK,CAAC,KAAK,EAAE;gBAC5B,OAAO,IAAI,QAAQ,SAAS,QAAQ,QAAQ;oBAC1C,OAAO,CAAC,GAAG,EAAE,KAAK,CAAC,AAAC,QAAQ,IAAK,IAAI,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,OAAO,IAAI,CAAC,EAAE,CAAC,EAAE;gBACrE,OAAO,IAAI,QAAQ,WAAW,QAAQ,YAAY;oBAChD,OAAO;oBACP,MAAM,QAAQ,AAAC,QAAQ,KAAM,IAAI,CAAC,EAAE;oBACpC,IAAI,QAAQ,GAAG;wBACb,OAAO,KAAK,CAAC,MAAM;oBACrB;oBACA,OAAO,GAAG,KAAK,CAAC,AAAC,QAAQ,KAAM,IAAI,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,AAAC,QAAQ,IAAK,IAAI,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC,OAAO,IAAI,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;gBACnG,OAAO;oBACL,MAAM,IAAI,MAAM;gBAClB;gBACA,MAAM,MAAM,OAAO,IAAI,CAAC;gBACxB,IAAI,OAAO,CAAC,CAAC;oBACX,MAAM,IAAI,CAAC;gBACb;YACF;QACF;QACA,OAAO,OAAO,IAAI,CAAC;IACrB;IACA,gFAAgF;IAChF,QAAO,GAAG;QACR,SAAS,MAAM,GAAG;YAChB,IAAI,AAAC,OAAO,MAAM,OAAO,MAAQ,OAAO,MAAM,OAAO,MAAQ,OAAO,MAAM,OAAO,KAAM;gBACrF,OAAO;YACT;YACA,OAAO;QACT;QACA,SAAS,KAAK,CAAC,EAAE,GAAG,EAAE,MAAM;YAC1B,MAAM,MAAM;gBAAE,MAAM;gBAAM,OAAO,IAAI;gBAAG,OAAO;YAAK;YACpD,IAAI,IAAI,IAAI,KAAK;gBACf,IAAI,MAAM,MAAM,CAAC,EAAE,KAAK,MAAM,MAAM,CAAC,IAAI,EAAE,GAAG;oBAC5C,MAAM,MAAM,OAAO,aAAa,CAAC,MAAM,CAAC,EAAE,EAAE,MAAM,CAAC,IAAI,EAAE;oBACzD,IAAI,IAAI,GAAG,SAAS,KAAK;oBACzB,IAAI,CAAC,OAAO,KAAK,CAAC,IAAI,IAAI,GAAG;wBAC3B,IAAI,KAAK,GAAG;oBACd;gBACF;YACF;YACA,OAAO;QACT;QACA,SAAS,KAAK,CAAC,EAAE,GAAG,EAAE,MAAM;YAC1B,MAAM,MAAM;gBAAE,MAAM;gBAAM,OAAO,IAAI;gBAAG,OAAO;YAAK;YACpD,IAAI,IAAI,IAAI,KAAK;gBACf,IAAI,MAAM,MAAM,CAAC,EAAE,KAAK,MAAM,MAAM,CAAC,IAAI,EAAE,KAAK,MAAM,MAAM,CAAC,IAAI,EAAE,KAAK,MAAM,MAAM,CAAC,IAAI,EAAE,GAAG;oBAC5F,MAAM,MAAM,OAAO,aAAa,CAAC,MAAM,CAAC,EAAE,EAAE,MAAM,CAAC,IAAI,EAAE,EAAE,MAAM,CAAC,IAAI,EAAE,EAAE,MAAM,CAAC,IAAI,EAAE;oBACvF,IAAI,IAAI,GAAG,SAAS,KAAK;oBACzB,IAAI,CAAC,OAAO,KAAK,CAAC,IAAI,IAAI,GAAG;wBAC3B,IAAI,KAAK,GAAG;oBACd;gBACF;YACF;YACA,OAAO;QACT;QACA,SAAS,KAAK,CAAC,EAAE,GAAG,EAAE,MAAM;YAC1B,MAAM,MAAM;gBAAE,MAAM;gBAAM,OAAO,IAAI;gBAAG,OAAO;YAAK;YACpD,IAAI,MAAM;YACV,MAAO,IAAI,OAAO,MAAM,MAAM,CAAC,EAAE,EAAG;gBAClC,OAAO,OAAO,aAAa,CAAC,MAAM,CAAC,EAAE;gBACrC,6CAA6C;gBAC7C,KAAK;YACP;YACA,IAAI,IAAI,GAAG,SAAS,KAAK;YACzB,IAAI,MAAM,CAAC,EAAE,KAAK,OAAO,CAAC,OAAO,KAAK,CAAC,IAAI,IAAI,GAAG;gBAChD,IAAI,KAAK,GAAG;YACd;YACA,IAAI,KAAK,GAAG,IAAI;YAChB,OAAO;QACT;QACA,MAAM,QAAQ,EAAE;QAChB,MAAM,MAAM,IAAI,MAAM;QACtB,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI,IAAI;QACR,MAAO,IAAI,IAAK;YACd,MAAM,OAAO;YACb,MAAO,KAAM;gBACX,QAAQ;gBACR,IAAI,GAAG,CAAC,EAAE,KAAK,IAAI;oBACjB,uBAAuB,GACvB,MAAM,IAAI,CAAC,GAAG,CAAC,EAAE;oBACjB,KAAK;oBACL,QAAQ;oBACR;gBACF;gBACA,KAAK,IAAI;gBACT,IAAI,MAAM,KAAK;oBACb;gBACF;gBACA,IAAI,GAAG,CAAC,GAAG,KAAK,IAAI;oBAClB,wBAAwB,GACxB,MAAM,IAAI,CAAC;oBACX,KAAK;oBACL,QAAQ;oBACR;gBACF;gBACA,IAAI,GAAG,CAAC,GAAG,KAAK,KAAK;oBACnB,MAAM,KAAK,KAAK,GAAG,KAAK;oBACxB,IAAI,IAAI,KAAK,EAAE;wBACb;oBACF;oBACA,eAAe,GACf,MAAM,IAAI,CAAC,IAAI,IAAI;oBACnB,IAAI,IAAI,KAAK;oBACb,QAAQ;oBACR;gBACF;gBACA,IAAI,GAAG,CAAC,GAAG,KAAK,KAAK;oBACnB,IAAI,GAAG,CAAC,KAAK,EAAE,KAAK,KAAK;wBACvB,MAAM,KAAK,KAAK,GAAG,KAAK;wBACxB,IAAI,IAAI,KAAK,EAAE;4BACb;wBACF;wBACA,kBAAkB,GAClB,MAAM,IAAI,CAAC,IAAI,IAAI;wBACnB,IAAI,IAAI,KAAK;wBACb,QAAQ;wBACR;oBACF;oBACA,MAAM,KAAK,KAAK,GAAG,KAAK;oBACxB,IAAI,IAAI,KAAK,EAAE;wBACb;oBACF;oBACA,kBAAkB,GAClB,MAAM,IAAI,CAAC,IAAI,IAAI;oBACnB,IAAI,IAAI,KAAK;oBACb,QAAQ;oBACR;gBACF;gBACA;YACF;YACA,IAAI,OAAO;gBACT,MAAM,IAAI,MAAM,CAAC,kDAAkD,EAAE,EAAE,CAAC,CAAC;YAC3E;QACF;QACA,OAAO;IACT;AACF;AAEA,uCAAuC;AACvC,MAAM,KAAK;AACX,MAAM,KAAK;AACX,QAAQ,QAAQ,GAAG;IACjB,MAAK,KAAK;QACR,MAAM,UAAU,EAAE;QAClB,IAAI,IAAI;QACR,MAAO,IAAI,MAAM,MAAM,CAAE;YACvB,OAAQ,KAAK,CAAC,EAAE;gBACd,KAAK;oBACH,IAAI,IAAI,IAAI,MAAM,MAAM,IAAI,KAAK,CAAC,IAAI,EAAE,KAAK,IAAI;wBAC/C,KAAK;oBACP,OAAO;wBACL,KAAK;oBACP;oBACA,QAAQ,IAAI,CAAC;oBACb,QAAQ,IAAI,CAAC;oBACb;gBACF,KAAK;oBACH,QAAQ,IAAI,CAAC;oBACb,QAAQ,IAAI,CAAC;oBACb,KAAK;oBACL;gBACF;oBACE,QAAQ,IAAI,CAAC,KAAK,CAAC,EAAE;oBACrB,KAAK;oBACL;YACJ;QACF;QACA,IAAI,QAAQ,MAAM,GAAG,KAAK,OAAO,CAAC,QAAQ,MAAM,GAAG,EAAE,KAAK,IAAI;YAC5D,QAAQ,IAAI,CAAC;YACb,QAAQ,IAAI,CAAC;QACf;QACA,OAAO;IACT;IACA,IAAG,KAAK;QACN,MAAM,UAAU,EAAE;QAClB,IAAI,IAAI;QACR,MAAO,IAAI,MAAM,MAAM,CAAE;YACvB,OAAQ,KAAK,CAAC,EAAE;gBACd,KAAK;oBACH,IAAI,IAAI,IAAI,MAAM,MAAM,IAAI,KAAK,CAAC,IAAI,EAAE,KAAK,IAAI;wBAC/C,KAAK;oBACP,OAAO;wBACL,KAAK;oBACP;oBACA,QAAQ,IAAI,CAAC;oBACb;gBACF,KAAK;oBACH,QAAQ,IAAI,CAAC;oBACb,KAAK;oBACL;gBACF;oBACE,QAAQ,IAAI,CAAC,KAAK,CAAC,EAAE;oBACrB,KAAK;oBACL;YACJ;QACF;QACA,IAAI,QAAQ,MAAM,GAAG,KAAK,OAAO,CAAC,QAAQ,MAAM,GAAG,EAAE,KAAK,IAAI;YAC5D,QAAQ,IAAI,CAAC;QACf;QACA,OAAO;IACT;AACF;AAEA,0BAA0B;AAC1B,QAAQ,MAAM,GAAG;IACf,QAAO,GAAG;QACR,IAAI,IAAI,MAAM,KAAK,GAAG;YACpB,OAAO,OAAO,KAAK,CAAC;QACtB;QACA,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI,OAAO,IAAI,MAAM,GAAG;QACxB,OAAO,OAAO,IAAI,IAAI,OAAO;QAC7B,IAAI,QAAQ,CAAC,IAAI,MAAM,GAAG,IAAI,IAAI;QAClC,MAAM,SAAS,OAAO,KAAK,CAAC,QAAQ;QACpC,IAAI,OAAO,GAAG;YACZ,SAAS;QACX;QACA,IAAI;QACJ,IAAI;QACJ,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,KAAK,EAAG;YACjC,IAAI,GAAG,CAAC,IAAI,IAAI;YAChB,KAAK,GAAG,CAAC,IAAI,IAAI;YACjB,KAAK,GAAG,CAAC,IAAI;YACb,MAAM,CAAC,IAAI,GAAG,WAAW,CAAC,AAAC,KAAK,KAAM,IAAI,CAAC,EAAE,CAAC;YAC9C,MAAM,CAAC,IAAI,GAAG,WAAW,CAAC,AAAC,KAAK,KAAM,IAAI,CAAC,EAAE,CAAC;YAC9C,MAAM,CAAC,IAAI,GAAG,WAAW,CAAC,AAAC,KAAK,IAAK,IAAI,CAAC,EAAE,CAAC;YAC7C,MAAM,CAAC,IAAI,GAAG,WAAW,CAAC,IAAI,IAAI,CAAC,EAAE,CAAC;QACxC;QACA,IAAI,SAAS,GAAG;YACd,OAAO;QACT;QACA,IAAI,SAAS,GAAG;YACd,IAAI,GAAG,CAAC,IAAI,IAAI;YAChB,KAAK,GAAG,CAAC,EAAE,IAAI;YACf,MAAM,CAAC,IAAI,GAAG,WAAW,CAAC,AAAC,KAAK,KAAM,IAAI,CAAC,EAAE,CAAC;YAC9C,MAAM,CAAC,IAAI,GAAG,WAAW,CAAC,AAAC,KAAK,KAAM,IAAI,CAAC,EAAE,CAAC;YAC9C,MAAM,CAAC,IAAI,GAAG,WAAW,CAAC,AAAC,KAAK,IAAK,IAAI,CAAC,EAAE,CAAC;YAC7C,MAAM,CAAC,EAAE,GAAG,WAAW,CAAC,GAAG;YAC3B,OAAO;QACT;QACA,IAAI,SAAS,GAAG;YACd,IAAI,GAAG,CAAC,EAAE,IAAI;YACd,MAAM,CAAC,IAAI,GAAG,WAAW,CAAC,AAAC,KAAK,KAAM,IAAI,CAAC,EAAE,CAAC;YAC9C,MAAM,CAAC,IAAI,GAAG,WAAW,CAAC,AAAC,KAAK,KAAM,IAAI,CAAC,EAAE,CAAC;YAC9C,MAAM,CAAC,IAAI,GAAG,WAAW,CAAC,GAAG;YAC7B,MAAM,CAAC,EAAE,GAAG,WAAW,CAAC,GAAG;YAC3B,OAAO;QACT;QACA,OAAO;IACT;IACA,QAAO,KAAK;QACV,2EAA2E,GAC3E,SAAS,SAAS,GAAG;YACnB,MAAM,QAAQ,EAAE;YAChB,IAAI,OAAO;YACX,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,MAAM,EAAE,KAAK,EAAG;gBACtC,MAAM,OAAO,GAAG,CAAC,EAAE;gBACnB,MAAM,OAAO;gBACb,MAAO,KAAM;oBACX,IAAI,SAAS,MAAM,SAAS,KAAK,SAAS,MAAM,SAAS,IAAI;wBAC3D;oBACF;oBACA,IAAI,QAAQ,MAAM,QAAQ,IAAI;wBAC5B,MAAM,IAAI,CAAC,OAAO;wBAClB;oBACF;oBACA,IAAI,QAAQ,MAAM,QAAQ,KAAK;wBAC7B,MAAM,IAAI,CAAC,OAAO;wBAClB;oBACF;oBACA,IAAI,QAAQ,MAAM,QAAQ,IAAI;wBAC5B,MAAM,IAAI,CAAC,OAAO;wBAClB;oBACF;oBACA,IAAI,SAAS,IAAI;wBACf,MAAM,IAAI,CAAC;wBACX;oBACF;oBACA,IAAI,SAAS,IAAI;wBACf,MAAM,IAAI,CAAC;wBACX;oBACF;oBACA,IAAI,SAAS,IAAI;wBACf,MAAM,IAAI,CAAC;wBACX,QAAQ;wBACR;oBACF;oBACA,qBAAqB,GACrB,MAAM,IAAI,WAAW,CAAC,qCAAqC,EAAE,EAAE,GAAG,EAAE,MAAM;gBAC5E;YACF;YACA,mBAAmB,GACnB,IAAI,MAAM,MAAM,GAAG,IAAI,GAAG;gBACxB,MAAM,IAAI,WAAW,CAAC,yDAAyD,EAAE,MAAM,MAAM,EAAE;YACjG;YACA,iBAAiB,GACjB,OAAQ;gBACN,KAAK;oBACH;gBACF,KAAK;oBACH,IAAI,KAAK,CAAC,MAAM,MAAM,GAAG,EAAE,KAAK,IAAI;wBAClC,MAAM,IAAI,WAAW;oBACvB;oBACA;gBACF,KAAK;oBACH,IAAI,KAAK,CAAC,MAAM,MAAM,GAAG,EAAE,KAAK,MAAM,KAAK,CAAC,MAAM,MAAM,GAAG,EAAE,KAAK,IAAI;wBACpE,MAAM,IAAI,WAAW;oBACvB;oBACA;gBACF;oBACE,MAAM,IAAI,WAAW,CAAC,oDAAoD,EAAE,MAAM;YACtF;YACA,OAAO;gBAAE;gBAAM,KAAK,OAAO,IAAI,CAAC;YAAO;QACzC;QAEA,IAAI,MAAM,MAAM,KAAK,GAAG;YACtB,OAAO,OAAO,KAAK,CAAC;QACtB;QACA,MAAM,MAAM,SAAS;QACrB,MAAM,EAAE,IAAI,EAAE,GAAG;QACjB,MAAM,SAAS,IAAI,GAAG;QACtB,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI,QAAQ,OAAO,MAAM,GAAG;QAC5B,MAAM,MAAM,OAAO,KAAK,CAAC,QAAQ,IAAI;QACrC,IAAI,OAAO,GAAG;YACZ,SAAS;QACX;QACA,IAAI;QACJ,IAAI;QACJ,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,KAAK,EAAG;YACjC,IAAI,MAAM,CAAC,IAAI,IAAI;YACnB,KAAK,MAAM,CAAC,IAAI,IAAI;YACpB,KAAK,MAAM,CAAC,IAAI,IAAI;YACpB,KAAK,MAAM,CAAC,IAAI;YAChB,GAAG,CAAC,IAAI,GAAG,AAAC,KAAK,KAAM,IAAI,CAAC,EAAE;YAC9B,GAAG,CAAC,IAAI,GAAG,AAAC,KAAK,IAAK,IAAI,CAAC,EAAE;YAC7B,GAAG,CAAC,IAAI,GAAG,IAAI,IAAI,CAAC,EAAE;QACxB;QACA,IAAI,SAAS,GAAG;YACd,IAAI,MAAM,CAAC,IAAI,IAAI;YACnB,KAAK,MAAM,CAAC,IAAI,IAAI;YACpB,KAAK,MAAM,CAAC,EAAE,IAAI;YAClB,GAAG,CAAC,IAAI,GAAG,AAAC,KAAK,KAAM,IAAI,CAAC,EAAE;YAC9B,GAAG,CAAC,EAAE,GAAG,AAAC,KAAK,IAAK,IAAI,CAAC,EAAE;QAC7B;QACA,IAAI,SAAS,GAAG;YACd,IAAI,MAAM,CAAC,IAAI,IAAI;YACnB,KAAK,MAAM,CAAC,IAAI,IAAI;YACpB,GAAG,CAAC,EAAE,GAAG,AAAC,KAAK,KAAM,IAAI,CAAC,EAAE;QAC9B;QACA,OAAO;IACT;IACA,8EAA8E;IAC9E,UAAS,GAAG;QACV,IAAI,IAAI,MAAM,GAAG,IAAI,GAAG;YACtB,MAAM,IAAI,WAAW,CAAC,wDAAwD,EAAE,IAAI,MAAM,EAAE;QAC9F;QACA,IAAI,MAAM;QACV,IAAI,UAAU;QACd,SAAS,UAAU,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE;YAC/B,OAAQ;gBACN,KAAK;oBACH,OAAO,CAAC,IAAI,EAAE,KAAK,KAAK,KAAK,IAAI;oBACjC,UAAU;oBACV;gBACF,KAAK;oBACH,OAAO,GAAG,GAAG,IAAI,EAAE,KAAK,KAAK,IAAI;oBACjC,UAAU;oBACV;gBACF,KAAK;oBACH,OAAO,GAAG,KAAK,GAAG,IAAI,EAAE,KAAK,IAAI;oBACjC,UAAU;oBACV;gBACF,KAAK;oBACH,OAAO,GAAG,KAAK,KAAK,GAAG,IAAI,EAAE,IAAI;oBACjC,UAAU;oBACV;gBACF;oBACE,OAAO,KAAK,KAAK,KAAK;oBACtB,WAAW;oBACX;YACJ;QACF;QACA,SAAS,SAAS,CAAC;YACjB,IAAI,KAAK,MAAM,KAAK,IAAI;gBACtB,OAAO;YACT;YACA,IAAI,KAAK,MAAM,KAAK,KAAK;gBACvB,OAAO;YACT;YACA,IAAI,KAAK,MAAM,KAAK,IAAI;gBACtB,OAAO;YACT;YACA,IAAI,MAAM,IAAI;gBACZ,OAAO;YACT;YACA,IAAI,MAAM,IAAI;gBACZ,OAAO;YACT;YACA,IAAI,MAAM,IAAI;gBACZ,OAAO;YACT;YACA,OAAO;QACT;QACA,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,MAAM,EAAE,KAAK,EAAG;YACtC,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,GAAG,KAAK,EAAG;gBACjC,IAAI,CAAC,SAAS,GAAG,CAAC,EAAE,GAAG;oBACrB,MAAM,IAAI,WAAW,CAAC,qBAAqB,EAAE,EAAE,GAAG,EAAE,GAAG,CAAC,EAAE,CAAC,kCAAkC,CAAC;gBAChG;YACF;YACA,UACE,OAAO,YAAY,CAAC,GAAG,CAAC,EAAE,GAC1B,OAAO,YAAY,CAAC,GAAG,CAAC,IAAI,EAAE,GAC9B,OAAO,YAAY,CAAC,GAAG,CAAC,IAAI,EAAE,GAC9B,OAAO,YAAY,CAAC,GAAG,CAAC,IAAI,EAAE;QAElC;QACA,OAAO;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 1316, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/apg-js/src/apg-conv-api/converter.js"],"sourcesContent":["/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module exposes the public encoding, decoding and conversion functions.\n// Its private functions provide the disassembling and interpetation of the source and destination encoding types.\n// In the case of Unicode encodings, private functions determine the presence of Byte Order Marks (BOMs), if any.\n//\n// Throws \"TypeError\" exceptions on input errors.\n//\n\n'use strict;';\n\nconst { Buffer } = require('buffer');\n\nconst trans = require('./transformers');\n\n/* types */\nconst UTF8 = 'UTF8';\nconst UTF16 = 'UTF16';\nconst UTF16BE = 'UTF16BE';\nconst UTF16LE = 'UTF16LE';\nconst UTF32 = 'UTF32';\nconst UTF32BE = 'UTF32BE';\nconst UTF32LE = 'UTF32LE';\nconst UINT7 = 'UINT7';\nconst ASCII = 'ASCII';\nconst BINARY = 'BINARY';\nconst UINT8 = 'UINT8';\nconst UINT16 = 'UINT16';\nconst UINT16LE = 'UINT16LE';\nconst UINT16BE = 'UINT16BE';\nconst UINT32 = 'UINT32';\nconst UINT32LE = 'UINT32LE';\nconst UINT32BE = 'UINT32BE';\nconst ESCAPED = 'ESCAPED';\nconst STRING = 'STRING';\n\n/* private functions */\n// Find the UTF8 BOM, if any.\nconst bom8 = function bom8(src) {\n  src.type = UTF8;\n  const buf = src.data;\n  src.bom = 0;\n  if (buf.length >= 3) {\n    if (buf[0] === 0xef && buf[1] === 0xbb && buf[2] === 0xbf) {\n      src.bom = 3;\n    }\n  }\n};\n// Find the UTF16 BOM, if any, and determine the UTF16 type.\n// Defaults to UTF16BE.\n// Throws TypeError exception if BOM does not match the specified type.\nconst bom16 = function bom16(src) {\n  const buf = src.data;\n  src.bom = 0;\n  switch (src.type) {\n    case UTF16:\n      src.type = UTF16BE;\n      if (buf.length >= 2) {\n        if (buf[0] === 0xfe && buf[1] === 0xff) {\n          src.bom = 2;\n        } else if (buf[0] === 0xff && buf[1] === 0xfe) {\n          src.type = UTF16LE;\n          src.bom = 2;\n        }\n      }\n      break;\n    case UTF16BE:\n      src.type = UTF16BE;\n      if (buf.length >= 2) {\n        if (buf[0] === 0xfe && buf[1] === 0xff) {\n          src.bom = 2;\n        } else if (buf[0] === 0xff && buf[1] === 0xfe) {\n          throw new TypeError(`src type: \"${UTF16BE}\" specified but BOM is for \"${UTF16LE}\"`);\n        }\n      }\n      break;\n    case UTF16LE:\n      src.type = UTF16LE;\n      if (buf.length >= 0) {\n        if (buf[0] === 0xfe && buf[1] === 0xff) {\n          throw new TypeError(`src type: \"${UTF16LE}\" specified but BOM is for \"${UTF16BE}\"`);\n        } else if (buf[0] === 0xff && buf[1] === 0xfe) {\n          src.bom = 2;\n        }\n      }\n      break;\n    default:\n      throw new TypeError(`UTF16 BOM: src type \"${src.type}\" unrecognized`);\n  }\n};\n// Find the UTF32 BOM, if any, and determine the UTF32 type.\n// Defaults to UTF32BE.\n// Throws exception if BOM does not match the specified type.\nconst bom32 = function bom32(src) {\n  const buf = src.data;\n  src.bom = 0;\n  switch (src.type) {\n    case UTF32:\n      src.type = UTF32BE;\n      if (buf.length >= 4) {\n        if (buf[0] === 0 && buf[1] === 0 && buf[2] === 0xfe && buf[3] === 0xff) {\n          src.bom = 4;\n        }\n        if (buf[0] === 0xff && buf[1] === 0xfe && buf[2] === 0 && buf[3] === 0) {\n          src.type = UTF32LE;\n          src.bom = 4;\n        }\n      }\n      break;\n    case UTF32BE:\n      src.type = UTF32BE;\n      if (buf.length >= 4) {\n        if (buf[0] === 0 && buf[1] === 0 && buf[2] === 0xfe && buf[3] === 0xff) {\n          src.bom = 4;\n        }\n        if (buf[0] === 0xff && buf[1] === 0xfe && buf[2] === 0 && buf[3] === 0) {\n          throw new TypeError(`src type: ${UTF32BE} specified but BOM is for ${UTF32LE}\"`);\n        }\n      }\n      break;\n    case UTF32LE:\n      src.type = UTF32LE;\n      if (buf.length >= 4) {\n        if (buf[0] === 0 && buf[1] === 0 && buf[2] === 0xfe && buf[3] === 0xff) {\n          throw new TypeError(`src type: \"${UTF32LE}\" specified but BOM is for \"${UTF32BE}\"`);\n        }\n        if (buf[0] === 0xff && buf[1] === 0xfe && buf[2] === 0 && buf[3] === 0) {\n          src.bom = 4;\n        }\n      }\n      break;\n    default:\n      throw new TypeError(`UTF32 BOM: src type \"${src.type}\" unrecognized`);\n  }\n};\n// Validates the source encoding type and matching data.\n// If the BASE64: prefix is present, the base 64 decoding is done here as the initial step.\n// - For type STRING, data must be a JavaScript string.\n// - For type BASE64:*, data may be a string or Buffer.\n// - For all other types, data must be a Buffer.\n// - The BASE64: prefix is not allowed for type STRING.\nconst validateSrc = function validateSrc(type, data) {\n  function getType(typeArg) {\n    const ret = {\n      type: '',\n      base64: false,\n    };\n    const rx = /^(base64:)?([a-zA-Z0-9]+)$/i;\n    const result = rx.exec(typeArg);\n    if (result) {\n      if (result[2]) {\n        ret.type = result[2].toUpperCase();\n      }\n      if (result[1]) {\n        ret.base64 = true;\n      }\n    }\n    return ret;\n  }\n  const ret = getType(type.toUpperCase());\n  if (ret.base64) {\n    /* handle base 64 */\n    if (ret.type === STRING) {\n      throw new TypeError(`type: \"${type} \"BASE64:\" prefix not allowed with type ${STRING}`);\n    }\n    if (Buffer.isBuffer(data)) {\n      ret.data = trans.base64.decode(data);\n    } else if (typeof data === 'string') {\n      const buf = Buffer.from(data, 'ascii');\n      ret.data = trans.base64.decode(buf);\n    } else {\n      throw new TypeError(`type: \"${type} unrecognized data type: typeof(data): ${typeof data}`);\n    }\n  } else {\n    ret.data = data;\n  }\n  switch (ret.type) {\n    case UTF8:\n      bom8(ret);\n      break;\n    case UTF16:\n    case UTF16BE:\n    case UTF16LE:\n      bom16(ret);\n      break;\n    case UTF32:\n    case UTF32BE:\n    case UTF32LE:\n      bom32(ret);\n      break;\n    case UINT16:\n      ret.type = UINT16BE;\n      break;\n    case UINT32:\n      ret.type = UINT32BE;\n      break;\n    case ASCII:\n      ret.type = UINT7;\n      break;\n    case BINARY:\n      ret.type = UINT8;\n      break;\n    case UINT7:\n    case UINT8:\n    case UINT16LE:\n    case UINT16BE:\n    case UINT32LE:\n    case UINT32BE:\n    case STRING:\n    case ESCAPED:\n      break;\n    default:\n      throw new TypeError(`type: \"${type}\" not recognized`);\n  }\n  if (ret.type === STRING) {\n    if (typeof ret.data !== 'string') {\n      throw new TypeError(`type: \"${type}\" but data is not a string`);\n    }\n  } else if (!Buffer.isBuffer(ret.data)) {\n    throw new TypeError(`type: \"${type}\" but data is not a Buffer`);\n  }\n  return ret;\n};\n// Disassembles and validates the destination type.\n// `chars` must be an Array of integers.\n// The :BASE64 suffix is not allowed for type STRING.\nconst validateDst = function validateDst(type, chars) {\n  function getType(typeArg) {\n    let fix;\n    let rem;\n    const ret = {\n      crlf: false,\n      lf: false,\n      base64: false,\n      type: '',\n    };\n    /* prefix, if any */\n    const TRUE = true;\n    while (TRUE) {\n      rem = typeArg;\n      fix = typeArg.slice(0, 5);\n      if (fix === 'CRLF:') {\n        ret.crlf = true;\n        rem = typeArg.slice(5);\n        break;\n      }\n      fix = typeArg.slice(0, 3);\n      if (fix === 'LF:') {\n        ret.lf = true;\n        rem = typeArg.slice(3);\n        break;\n      }\n      break;\n    }\n    /* suffix, if any */\n    fix = rem.split(':');\n    if (fix.length === 1) {\n      // eslint-disable-next-line prefer-destructuring\n      ret.type = fix[0];\n    } else if (fix.length === 2 && fix[1] === 'BASE64') {\n      ret.base64 = true;\n      // eslint-disable-next-line prefer-destructuring\n      ret.type = fix[0];\n    }\n    return ret;\n  }\n  if (!Array.isArray(chars)) {\n    throw new TypeError(`dst chars: not array: \"${typeof chars}`);\n  }\n  if (typeof type !== 'string') {\n    throw new TypeError(`dst type: not string: \"${typeof type}`);\n  }\n  const ret = getType(type.toUpperCase());\n  switch (ret.type) {\n    case UTF8:\n    case UTF16BE:\n    case UTF16LE:\n    case UTF32BE:\n    case UTF32LE:\n    case UINT7:\n    case UINT8:\n    case UINT16LE:\n    case UINT16BE:\n    case UINT32LE:\n    case UINT32BE:\n    case ESCAPED:\n      break;\n    case STRING:\n      if (ret.base64) {\n        throw new TypeError(`\":BASE64\" suffix not allowed with type ${STRING}`);\n      }\n      break;\n    case ASCII:\n      ret.type = UINT7;\n      break;\n    case BINARY:\n      ret.type = UINT8;\n      break;\n    case UTF16:\n      ret.type = UTF16BE;\n      break;\n    case UTF32:\n      ret.type = UTF32BE;\n      break;\n    case UINT16:\n      ret.type = UINT16BE;\n      break;\n    case UINT32:\n      ret.type = UINT32BE;\n      break;\n    default:\n      throw new TypeError(`dst type unrecognized: \"${type}\" : must have form [crlf:|lf:]type[:base64]`);\n  }\n  return ret;\n};\n// Select and call the requested encoding function.\nconst encode = function encode(type, chars) {\n  switch (type) {\n    case UTF8:\n      return trans.utf8.encode(chars);\n    case UTF16BE:\n      return trans.utf16be.encode(chars);\n    case UTF16LE:\n      return trans.utf16le.encode(chars);\n    case UTF32BE:\n      return trans.utf32be.encode(chars);\n    case UTF32LE:\n      return trans.utf32le.encode(chars);\n    case UINT7:\n      return trans.uint7.encode(chars);\n    case UINT8:\n      return trans.uint8.encode(chars);\n    case UINT16BE:\n      return trans.uint16be.encode(chars);\n    case UINT16LE:\n      return trans.uint16le.encode(chars);\n    case UINT32BE:\n      return trans.uint32be.encode(chars);\n    case UINT32LE:\n      return trans.uint32le.encode(chars);\n    case STRING:\n      return trans.string.encode(chars);\n    case ESCAPED:\n      return trans.escaped.encode(chars);\n    default:\n      throw new TypeError(`encode type \"${type}\" not recognized`);\n  }\n};\n// Select and call the requested decoding function.\n// `src` contains BOM information as well as the source type and data.\nconst decode = function decode(src) {\n  switch (src.type) {\n    case UTF8:\n      return trans.utf8.decode(src.data, src.bom);\n    case UTF16LE:\n      return trans.utf16le.decode(src.data, src.bom);\n    case UTF16BE:\n      return trans.utf16be.decode(src.data, src.bom);\n    case UTF32BE:\n      return trans.utf32be.decode(src.data, src.bom);\n    case UTF32LE:\n      return trans.utf32le.decode(src.data, src.bom);\n    case UINT7:\n      return trans.uint7.decode(src.data);\n    case UINT8:\n      return trans.uint8.decode(src.data);\n    case UINT16BE:\n      return trans.uint16be.decode(src.data);\n    case UINT16LE:\n      return trans.uint16le.decode(src.data);\n    case UINT32BE:\n      return trans.uint32be.decode(src.data);\n    case UINT32LE:\n      return trans.uint32le.decode(src.data);\n    case STRING:\n      return trans.string.decode(src.data);\n    case ESCAPED:\n      return trans.escaped.decode(src.data);\n    default:\n      throw new TypeError(`decode type \"${src.type}\" not recognized`);\n  }\n};\n\n// The public decoding function. Returns an array of integers.\nexports.decode = function exportsDecode(type, data) {\n  const src = validateSrc(type, data);\n  return decode(src);\n};\n// The public encoding function. Returns a Buffer-typed byte array.\nexports.encode = function exportsEncode(type, chars) {\n  let c;\n  let buf;\n  const dst = validateDst(type, chars);\n  if (dst.crlf) {\n    /* prefix with CRLF line end conversion, don't contaminate caller's chars array */\n    c = trans.lineEnds.crlf(chars);\n    buf = encode(dst.type, c);\n  } else if (dst.lf) {\n    /* prefix with LF line end conversion, don't contaminate caller's chars array */\n    c = trans.lineEnds.lf(chars);\n    buf = encode(dst.type, c);\n  } else {\n    buf = encode(dst.type, chars);\n  }\n  if (dst.base64) {\n    /* post base 64 encoding */\n    buf = trans.base64.encode(buf);\n  }\n  return buf;\n};\n// Converts data of type `srcType` to data of type `dstType`.\n// `srcData` may be a JavaScript String, or node.js Buffer, depending on the corresponding type.\nconst convert = function convert(srcType, srcData, dstType) {\n  return exports.encode(dstType, exports.decode(srcType, srcData));\n};\nexports.convert = convert;\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1721, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/apg-js/src/apg-lib/emitcss.js"],"sourcesContent":["// This module has been developed programmatically in the `apg-lib` build process.\n// It is used to build web pages programatically on the fly without the need for <script> or <style> tags.\n\nmodule.exports = function emittcss(){\nreturn '/* This file automatically generated by jsonToless() and LESS. */\\n.apg-mono {\\n  font-family: monospace;\\n}\\n.apg-active {\\n  font-weight: bold;\\n  color: #000000;\\n}\\n.apg-match {\\n  font-weight: bold;\\n  color: #264BFF;\\n}\\n.apg-empty {\\n  font-weight: bold;\\n  color: #0fbd0f;\\n}\\n.apg-nomatch {\\n  font-weight: bold;\\n  color: #FF4000;\\n}\\n.apg-lh-match {\\n  font-weight: bold;\\n  color: #1A97BA;\\n}\\n.apg-lb-match {\\n  font-weight: bold;\\n  color: #5F1687;\\n}\\n.apg-remainder {\\n  font-weight: bold;\\n  color: #999999;\\n}\\n.apg-ctrl-char {\\n  font-weight: bolder;\\n  font-style: italic;\\n  font-size: 0.6em;\\n}\\n.apg-line-end {\\n  font-weight: bold;\\n  color: #000000;\\n}\\n.apg-error {\\n  font-weight: bold;\\n  color: #FF4000;\\n}\\n.apg-phrase {\\n  color: #000000;\\n  background-color: #8caae6;\\n}\\n.apg-empty-phrase {\\n  color: #0fbd0f;\\n}\\ntable.apg-state {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: left;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-state th,\\ntable.apg-state td {\\n  text-align: left;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-state th:nth-last-child(2),\\ntable.apg-state td:nth-last-child(2) {\\n  text-align: right;\\n}\\ntable.apg-state caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-stats {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-stats th,\\ntable.apg-stats td {\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-stats caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-trace {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-trace caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-trace th,\\ntable.apg-trace td {\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-trace th:last-child,\\ntable.apg-trace th:nth-last-child(2),\\ntable.apg-trace td:last-child,\\ntable.apg-trace td:nth-last-child(2) {\\n  text-align: left;\\n}\\ntable.apg-grammar {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-grammar caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-grammar th,\\ntable.apg-grammar td {\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-grammar th:last-child,\\ntable.apg-grammar td:last-child {\\n  text-align: left;\\n}\\ntable.apg-rules {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-rules caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-rules th,\\ntable.apg-rules td {\\n  text-align: right;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-rules a {\\n  color: #003399 !important;\\n}\\ntable.apg-rules a:hover {\\n  color: #8caae6 !important;\\n}\\ntable.apg-attrs {\\n  font-family: monospace;\\n  margin-top: 5px;\\n  font-size: 11px;\\n  line-height: 130%;\\n  text-align: center;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-attrs caption {\\n  font-size: 125%;\\n  line-height: 130%;\\n  font-weight: bold;\\n  text-align: left;\\n}\\ntable.apg-attrs th,\\ntable.apg-attrs td {\\n  text-align: center;\\n  border: 1px solid black;\\n  border-collapse: collapse;\\n}\\ntable.apg-attrs th:nth-child(1),\\ntable.apg-attrs th:nth-child(2),\\ntable.apg-attrs th:nth-child(3) {\\n  text-align: right;\\n}\\ntable.apg-attrs td:nth-child(1),\\ntable.apg-attrs td:nth-child(2),\\ntable.apg-attrs td:nth-child(3) {\\n  text-align: right;\\n}\\ntable.apg-attrs a {\\n  color: #003399 !important;\\n}\\ntable.apg-attrs a:hover {\\n  color: #8caae6 !important;\\n}\\n';\n}\n"],"names":[],"mappings":"AAAA,kFAAkF;AAClF,0GAA0G;AAE1G,OAAO,OAAO,GAAG,SAAS;IAC1B,OAAO;AACP","ignoreList":[0]}},
    {"offset": {"line": 1729, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/apg-js/src/apg-lib/utilities.js"],"sourcesContent":["/* eslint-disable func-names */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module exports a variety of utility functions that support\n// [`apg`](https://github.com/ldthomas/apg-js2), [`apg-lib`](https://github.com/ldthomas/apg-js2-lib)\n// and the generated parser applications.\n\nconst style = require('./style');\nconst converter = require('../apg-conv-api/converter');\nconst emitCss = require('./emitcss');\nconst id = require('./identifiers');\n\nconst thisFileName = 'utilities.js: ';\n\n/* translate (implied) phrase beginning character and length to actual first and last character indexes */\n/* used by multiple phrase handling functions */\nconst getBounds = function (length, begArg, len) {\n  let end;\n  let beg = begArg;\n  const TRUE = true;\n  while (TRUE) {\n    if (length <= 0) {\n      beg = 0;\n      end = 0;\n      break;\n    }\n    if (typeof beg !== 'number') {\n      beg = 0;\n      end = length;\n      break;\n    }\n    if (beg >= length) {\n      beg = length;\n      end = length;\n      break;\n    }\n    if (typeof len !== 'number') {\n      end = length;\n      break;\n    }\n    end = beg + len;\n    if (end > length) {\n      end = length;\n      break;\n    }\n    break;\n  }\n  return {\n    beg,\n    end,\n  };\n};\n// Generates a complete, minimal HTML5 page, inserting the user's HTML text on the page.\n// - *html* - the page text in HTML format\n// - *title* - the HTML page `<title>` - defaults to `htmlToPage`.\nexports.htmlToPage = function (html, titleArg) {\n  let title;\n  if (typeof html !== 'string') {\n    throw new Error(`${thisFileName}htmlToPage: input HTML is not a string`);\n  }\n  if (typeof titleArg !== 'string') {\n    title = 'htmlToPage';\n  } else {\n    title = titleArg;\n  }\n  let page = '';\n  page += '<!DOCTYPE html>\\n';\n  page += '<html lang=\"en\">\\n';\n  page += '<head>\\n';\n  page += '<meta charset=\"utf-8\">\\n';\n  page += `<title>${title}</title>\\n`;\n  page += '<style>\\n';\n  page += emitCss();\n  page += '</style>\\n';\n  page += '</head>\\n<body>\\n';\n  page += `<p>${new Date()}</p>\\n`;\n  page += html;\n  page += '</body>\\n</html>\\n';\n  return page;\n};\n// Formats the returned object from `parser.parse()`\n// into an HTML table.\n// ```\n// return {\n//   success : sysData.success,\n//   state : sysData.state,\n//   length : charsLength,\n//   matched : sysData.phraseLength,\n//   maxMatched : maxMatched,\n//   maxTreeDepth : maxTreeDepth,\n//   nodeHits : nodeHits,\n//   inputLength : chars.length,\n//   subBegin : charsBegin,\n//   subEnd : charsEnd,\n//   subLength : charsLength\n// };\n// ```\nexports.parserResultToHtml = function (result, caption) {\n  let cap = null;\n  if (typeof caption === 'string' && caption !== '') {\n    cap = caption;\n  }\n  let success;\n  let state;\n  if (result.success === true) {\n    success = `<span class=\"${style.CLASS_MATCH}\">true</span>`;\n  } else {\n    success = `<span class=\"${style.CLASS_NOMATCH}\">false</span>`;\n  }\n  if (result.state === id.EMPTY) {\n    state = `<span class=\"${style.CLASS_EMPTY}\">EMPTY</span>`;\n  } else if (result.state === id.MATCH) {\n    state = `<span class=\"${style.CLASS_MATCH}\">MATCH</span>`;\n  } else if (result.state === id.NOMATCH) {\n    state = `<span class=\"${style.CLASS_NOMATCH}\">NOMATCH</span>`;\n  } else {\n    state = `<span class=\"${style.CLASS_NOMATCH}\">unrecognized</span>`;\n  }\n  let html = '';\n  html += `<table class=\"${style.CLASS_STATE}\">\\n`;\n  if (cap) {\n    html += `<caption>${cap}</caption>\\n`;\n  }\n  html += '<tr><th>state item</th><th>value</th><th>description</th></tr>\\n';\n  html += `<tr><td>parser success</td><td>${success}</td>\\n`;\n  html += `<td><span class=\"${style.CLASS_MATCH}\">true</span> if the parse succeeded,\\n`;\n  html += ` <span class=\"${style.CLASS_NOMATCH}\">false</span> otherwise`;\n  html += '<br><i>NOTE: for success, entire string must be matched</i></td></tr>\\n';\n  html += `<tr><td>parser state</td><td>${state}</td>\\n`;\n  html += `<td><span class=\"${style.CLASS_EMPTY}\">EMPTY</span>, `;\n  html += `<span class=\"${style.CLASS_MATCH}\">MATCH</span> or \\n`;\n  html += `<span class=\"${style.CLASS_NOMATCH}\">NOMATCH</span></td></tr>\\n`;\n  html += `<tr><td>string length</td><td>${result.length}</td><td>length of the input (sub)string</td></tr>\\n`;\n  html += `<tr><td>matched length</td><td>${result.matched}</td><td>number of input string characters matched</td></tr>\\n`;\n  html += `<tr><td>max matched</td><td>${result.maxMatched}</td><td>maximum number of input string characters matched</td></tr>\\n`;\n  html += `<tr><td>max tree depth</td><td>${result.maxTreeDepth}</td><td>maximum depth of the parse tree reached</td></tr>\\n`;\n  html += `<tr><td>node hits</td><td>${result.nodeHits}</td><td>number of parse tree node hits (opcode function calls)</td></tr>\\n`;\n  html += `<tr><td>input length</td><td>${result.inputLength}</td><td>length of full input string</td></tr>\\n`;\n  html += `<tr><td>sub-string begin</td><td>${result.subBegin}</td><td>sub-string first character index</td></tr>\\n`;\n  html += `<tr><td>sub-string end</td><td>${result.subEnd}</td><td>sub-string end-of-string index</td></tr>\\n`;\n  html += `<tr><td>sub-string length</td><td>${result.subLength}</td><td>sub-string length</td></tr>\\n`;\n  html += '</table>\\n';\n  return html;\n};\n// Translates a sub-array of integer character codes into a string.\n// Very useful in callback functions to translate the matched phrases into strings.\nexports.charsToString = function (chars, phraseIndex, phraseLength) {\n  let beg;\n  let end;\n  if (typeof phraseIndex === 'number') {\n    if (phraseIndex >= chars.length) {\n      return '';\n    }\n    beg = phraseIndex < 0 ? 0 : phraseIndex;\n  } else {\n    beg = 0;\n  }\n  if (typeof phraseLength === 'number') {\n    if (phraseLength <= 0) {\n      return '';\n    }\n    end = phraseLength > chars.length - beg ? chars.length : beg + phraseLength;\n  } else {\n    end = chars.length;\n  }\n  if (beg < end) {\n    return converter.encode('UTF16LE', chars.slice(beg, end)).toString('utf16le');\n  }\n  return '';\n};\n// Translates a string into an array of integer character codes.\nexports.stringToChars = function (string) {\n  return converter.decode('STRING', string);\n};\n// Translates an opcode identifier into a human-readable string.\nexports.opcodeToString = function (type) {\n  let ret = 'unknown';\n  switch (type) {\n    case id.ALT:\n      ret = 'ALT';\n      break;\n    case id.CAT:\n      ret = 'CAT';\n      break;\n    case id.RNM:\n      ret = 'RNM';\n      break;\n    case id.UDT:\n      ret = 'UDT';\n      break;\n    case id.AND:\n      ret = 'AND';\n      break;\n    case id.NOT:\n      ret = 'NOT';\n      break;\n    case id.REP:\n      ret = 'REP';\n      break;\n    case id.TRG:\n      ret = 'TRG';\n      break;\n    case id.TBS:\n      ret = 'TBS';\n      break;\n    case id.TLS:\n      ret = 'TLS';\n      break;\n    case id.BKR:\n      ret = 'BKR';\n      break;\n    case id.BKA:\n      ret = 'BKA';\n      break;\n    case id.BKN:\n      ret = 'BKN';\n      break;\n    case id.ABG:\n      ret = 'ABG';\n      break;\n    case id.AEN:\n      ret = 'AEN';\n      break;\n    default:\n      throw new Error('unrecognized opcode');\n  }\n  return ret;\n};\n// Translates an state identifier into a human-readable string.\nexports.stateToString = function (state) {\n  let ret = 'unknown';\n  switch (state) {\n    case id.ACTIVE:\n      ret = 'ACTIVE';\n      break;\n    case id.MATCH:\n      ret = 'MATCH';\n      break;\n    case id.EMPTY:\n      ret = 'EMPTY';\n      break;\n    case id.NOMATCH:\n      ret = 'NOMATCH';\n      break;\n    default:\n      throw new Error('unrecognized state');\n  }\n  return ret;\n};\n// Array which translates all 128, 7-bit ASCII character codes to their respective HTML format.\nexports.asciiChars = [\n  'NUL',\n  'SOH',\n  'STX',\n  'ETX',\n  'EOT',\n  'ENQ',\n  'ACK',\n  'BEL',\n  'BS',\n  'TAB',\n  'LF',\n  'VT',\n  'FF',\n  'CR',\n  'SO',\n  'SI',\n  'DLE',\n  'DC1',\n  'DC2',\n  'DC3',\n  'DC4',\n  'NAK',\n  'SYN',\n  'ETB',\n  'CAN',\n  'EM',\n  'SUB',\n  'ESC',\n  'FS',\n  'GS',\n  'RS',\n  'US',\n  '&nbsp;',\n  '!',\n  '&#34;',\n  '#',\n  '$',\n  '%',\n  '&#38;',\n  '&#39;',\n  '(',\n  ')',\n  '*',\n  '+',\n  ',',\n  '-',\n  '.',\n  '/',\n  '0',\n  '1',\n  '2',\n  '3',\n  '4',\n  '5',\n  '6',\n  '7',\n  '8',\n  '9',\n  ':',\n  ';',\n  '&#60;',\n  '=',\n  '&#62;',\n  '?',\n  '@',\n  'A',\n  'B',\n  'C',\n  'D',\n  'E',\n  'F',\n  'G',\n  'H',\n  'I',\n  'J',\n  'K',\n  'L',\n  'M',\n  'N',\n  'O',\n  'P',\n  'Q',\n  'R',\n  'S',\n  'T',\n  'U',\n  'V',\n  'W',\n  'X',\n  'Y',\n  'Z',\n  '[',\n  '&#92;',\n  ']',\n  '^',\n  '_',\n  '`',\n  'a',\n  'b',\n  'c',\n  'd',\n  'e',\n  'f',\n  'g',\n  'h',\n  'i',\n  'j',\n  'k',\n  'l',\n  'm',\n  'n',\n  'o',\n  'p',\n  'q',\n  'r',\n  's',\n  't',\n  'u',\n  'v',\n  'w',\n  'x',\n  'y',\n  'z',\n  '{',\n  '|',\n  '}',\n  '~',\n  'DEL',\n];\n// Translates a single character to hexadecimal with leading zeros for 2, 4, or 8 digit display.\nexports.charToHex = function (char) {\n  let ch = char.toString(16).toUpperCase();\n  switch (ch.length) {\n    case 1:\n    case 3:\n    case 7:\n      ch = `0${ch}`;\n      break;\n    case 2:\n    case 6:\n      ch = `00${ch}`;\n      break;\n    case 4:\n      break;\n    case 5:\n      ch = `000${ch}`;\n      break;\n    default:\n      throw new Error('unrecognized option');\n  }\n  return ch;\n};\n// Translates a sub-array of character codes to decimal display format.\nexports.charsToDec = function (chars, beg, len) {\n  let ret = '';\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToDec: input must be an array of integers`);\n  }\n  const bounds = getBounds(chars.length, beg, len);\n  if (bounds.end > bounds.beg) {\n    ret += chars[bounds.beg];\n    for (let i = bounds.beg + 1; i < bounds.end; i += 1) {\n      ret += `,${chars[i]}`;\n    }\n  }\n  return ret;\n};\n// Translates a sub-array of character codes to hexadecimal display format.\nexports.charsToHex = function (chars, beg, len) {\n  let ret = '';\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToHex: input must be an array of integers`);\n  }\n  const bounds = getBounds(chars.length, beg, len);\n  if (bounds.end > bounds.beg) {\n    ret += `\\\\x${exports.charToHex(chars[bounds.beg])}`;\n    for (let i = bounds.beg + 1; i < bounds.end; i += 1) {\n      ret += `,\\\\x${exports.charToHex(chars[i])}`;\n    }\n  }\n  return ret;\n};\nexports.charsToHtmlEntities = function (chars, beg, len) {\n  let ret = '';\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToHex: input must be an array of integers`);\n  }\n  const bounds = getBounds(chars.length, beg, len);\n  if (bounds.end > bounds.beg) {\n    for (let i = bounds.beg; i < bounds.end; i += 1) {\n      ret += `&#x${chars[i].toString(16)};`;\n    }\n  }\n  return ret;\n};\n// Translates a sub-array of character codes to Unicode display format.\nfunction isUnicode(char) {\n  if (char >= 0xd800 && char <= 0xdfff) {\n    return false;\n  }\n  if (char > 0x10ffff) {\n    return false;\n  }\n  return true;\n}\nexports.charsToUnicode = function (chars, beg, len) {\n  let ret = '';\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToUnicode: input must be an array of integers`);\n  }\n  const bounds = getBounds(chars.length, beg, len);\n  if (bounds.end > bounds.beg) {\n    for (let i = bounds.beg; i < bounds.end; i += 1) {\n      if (isUnicode(chars[i])) {\n        ret += `&#${chars[i]};`;\n      } else {\n        ret += ` U+${exports.charToHex(chars[i])}`;\n      }\n    }\n  }\n  return ret;\n};\n// Translates a sub-array of character codes to JavaScript Unicode display format (`\\uXXXX`).\nexports.charsToJsUnicode = function (chars, beg, len) {\n  let ret = '';\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToJsUnicode: input must be an array of integers`);\n  }\n  const bounds = getBounds(chars.length, beg, len);\n  if (bounds.end > bounds.beg) {\n    ret += `\\\\u${exports.charToHex(chars[bounds.beg])}`;\n    for (let i = bounds.beg + 1; i < bounds.end; i += 1) {\n      ret += `,\\\\u${exports.charToHex(chars[i])}`;\n    }\n  }\n  return ret;\n};\n// Translates a sub-array of character codes to printing ASCII character display format.\nexports.charsToAscii = function (chars, beg, len) {\n  let ret = '';\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToAscii: input must be an array of integers`);\n  }\n  const bounds = getBounds(chars.length, beg, len);\n  for (let i = bounds.beg; i < bounds.end; i += 1) {\n    const char = chars[i];\n    if (char >= 32 && char <= 126) {\n      ret += String.fromCharCode(char);\n    } else {\n      ret += `\\\\x${exports.charToHex(char)}`;\n    }\n  }\n  return ret;\n};\n// Translates a sub-array of character codes to HTML display format.\nexports.charsToAsciiHtml = function (chars, beg, len) {\n  if (!Array.isArray(chars)) {\n    throw new Error(`${thisFileName}charsToAsciiHtml: input must be an array of integers`);\n  }\n  let html = '';\n  let char;\n  const bounds = getBounds(chars.length, beg, len);\n  for (let i = bounds.beg; i < bounds.end; i += 1) {\n    char = chars[i];\n    if (char < 32 || char === 127) {\n      /* control characters */\n      html += `<span class=\"${style.CLASS_CTRLCHAR}\">${exports.asciiChars[char]}</span>`;\n    } else if (char > 127) {\n      /* non-ASCII */\n      html += `<span class=\"${style.CLASS_CTRLCHAR}\">U+${exports.charToHex(char)}</span>`;\n    } else {\n      /* printing ASCII, 32 <= char <= 126 */\n      html += exports.asciiChars[char];\n    }\n  }\n  return html;\n};\n// Translates a JavaScript string to HTML display format.\nexports.stringToAsciiHtml = function (str) {\n  const chars = converter.decode('STRING', str);\n  return this.charsToAsciiHtml(chars);\n};\n"],"names":[],"mappings":"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KAAK,GAAG,GAAG;YACT,MAAM;YACN;QACF,KAAK,GAAG,GAAG;YACT,MAAM;YACN;QACF,KAAK,GAAG,GAAG;YACT,MAAM;YACN;QACF,KAAK,GAAG,GAAG;YACT,MAAM;YACN;QACF,KAAK,GAAG,GAAG;YACT,MAAM;YACN;QACF,KAAK,GAAG,GAAG;YACT,MAAM;YACN;QACF,KAAK,GAAG,GAAG;YACT,MAAM;YACN;QACF,KAAK,GAAG,GAAG;YACT,MAAM;YACN;QACF,KAAK,GAAG,GAAG;YACT,MAAM;YACN;QACF,KAAK,GAAG,GAAG;YACT,MAAM;YACN;QACF,KAAK,GAAG,GAAG;YACT,MAAM;YACN;QACF,KAAK,GAAG,GAAG;YACT,MAAM;YACN;QACF;YACE,MAAM,IAAI,MAAM;IACpB;IACA,OAAO;AACT;AACA,+DAA+D;AAC/D,QAAQ,aAAa,GAAG,SAAU,KAAK;IACrC,IAAI,MAAM;IACV,OAAQ;QACN,KAAK,GAAG,MAAM;YACZ,MAAM;YACN;QACF,KAAK,GAAG,KAAK;YACX,MAAM;YACN;QACF,KAAK,GAAG,KAAK;YACX,MAAM;YACN;QACF,KAAK,GAAG,OAAO;YACb,MAAM;YACN;QACF;YACE,MAAM,IAAI,MAAM;IACpB;IACA,OAAO;AACT;AACA,+FAA+F;AAC/F,QAAQ,UAAU,GAAG;IACnB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;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","ignoreList":[0]}},
    {"offset": {"line": 2257, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/apg-js/src/apg-lib/ast.js"],"sourcesContent":["/* eslint-disable guard-for-in */\n/* eslint-disable no-restricted-syntax */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module is used by the parser to build an [Abstract Syntax Tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree) (AST).\n// The AST can be thought of as a subset of the full parse tree.\n// Each node of the AST holds the phrase that was matched at the corresponding, named parse tree node.\n// It is built as the parser successfully matches phrases to the rule names\n// (`RNM` operators) and `UDT`s as it parses an input string.\n// The user controls which `RNM` or `UDT` names to keep on the AST.\n// The user can also associate callback functions with some or all of the retained\n// AST nodes to be used to translate the node phrases. That is, associate semantic\n// actions to the matched phrases.\n// Translating the AST rather that attempting to apply semantic actions during\n// the parsing process, has the advantage that there is no backtracking and that the phrases\n// are known while traversing down tree as will as up.\n//\n// Let `ast` be an `ast.js` object. To identify a node to be kept on the AST:\n// ```\n// ast.callbacks[\"rulename\"] = true; (all nodes default to false)\n// ```\n// To associate a callback function with a node:\n// ```\n// ast.callbacks[\"rulename\"] = fn\n// ```\n// `rulename` is any `RNM` or `UDT` name defined by the associated grammar\n// and `fn` is a user-written callback function.\n// (See [`apg-examples`](https://github.com/ldthomas/apg-js2-examples/tree/master/ast) for examples of how to create an AST,\n// define the nodes and callback functions and attach it to a parser.)\nmodule.exports = function exportsAst() {\n  const id = require('./identifiers');\n  const utils = require('./utilities');\n\n  const thisFileName = 'ast.js: ';\n  const that = this;\n  let rules = null;\n  let udts = null;\n  let chars = null;\n  let nodeCount = 0;\n  const nodesDefined = [];\n  const nodeCallbacks = [];\n  const stack = [];\n  const records = [];\n  this.callbacks = [];\n  this.astObject = 'astObject';\n  /* called by the parser to initialize the AST with the rules, UDTs and the input characters */\n  this.init = function init(rulesIn, udtsIn, charsIn) {\n    stack.length = 0;\n    records.length = 0;\n    nodesDefined.length = 0;\n    nodeCount = 0;\n    rules = rulesIn;\n    udts = udtsIn;\n    chars = charsIn;\n    let i;\n    const list = [];\n    for (i = 0; i < rules.length; i += 1) {\n      list.push(rules[i].lower);\n    }\n    for (i = 0; i < udts.length; i += 1) {\n      list.push(udts[i].lower);\n    }\n    nodeCount = rules.length + udts.length;\n    for (i = 0; i < nodeCount; i += 1) {\n      nodesDefined[i] = false;\n      nodeCallbacks[i] = null;\n    }\n    for (const index in that.callbacks) {\n      const lower = index.toLowerCase();\n      i = list.indexOf(lower);\n      if (i < 0) {\n        throw new Error(`${thisFileName}init: node '${index}' not a rule or udt name`);\n      }\n      if (typeof that.callbacks[index] === 'function') {\n        nodesDefined[i] = true;\n        nodeCallbacks[i] = that.callbacks[index];\n      }\n      if (that.callbacks[index] === true) {\n        nodesDefined[i] = true;\n      }\n    }\n  };\n  /* AST node definitions - called by the parser's `RNM` operator */\n  this.ruleDefined = function ruleDefined(index) {\n    return nodesDefined[index] !== false;\n  };\n  /* AST node definitions - called by the parser's `UDT` operator */\n  this.udtDefined = function udtDefined(index) {\n    return nodesDefined[rules.length + index] !== false;\n  };\n  /* called by the parser's `RNM` & `UDT` operators */\n  /* builds a record for the downward traversal of the node */\n  this.down = function down(callbackIndex, name) {\n    const thisIndex = records.length;\n    stack.push(thisIndex);\n    records.push({\n      name,\n      thisIndex,\n      thatIndex: null,\n      state: id.SEM_PRE,\n      callbackIndex,\n      phraseIndex: null,\n      phraseLength: null,\n      stack: stack.length,\n    });\n    return thisIndex;\n  };\n  /* called by the parser's `RNM` & `UDT` operators */\n  /* builds a record for the upward traversal of the node */\n  this.up = function up(callbackIndex, name, phraseIndex, phraseLength) {\n    const thisIndex = records.length;\n    const thatIndex = stack.pop();\n    records.push({\n      name,\n      thisIndex,\n      thatIndex,\n      state: id.SEM_POST,\n      callbackIndex,\n      phraseIndex,\n      phraseLength,\n      stack: stack.length,\n    });\n    records[thatIndex].thatIndex = thisIndex;\n    records[thatIndex].phraseIndex = phraseIndex;\n    records[thatIndex].phraseLength = phraseLength;\n    return thisIndex;\n  };\n  // Called by the user to translate the AST.\n  // Translate means to associate or apply some semantic action to the\n  // phrases that were syntactically matched to the AST nodes according\n  // to the defining grammar.\n  // ```\n  // data - optional user-defined data\n  //        passed to the callback functions by the translator\n  // ```\n  this.translate = function translate(data) {\n    let ret;\n    let callback;\n    let record;\n    for (let i = 0; i < records.length; i += 1) {\n      record = records[i];\n      callback = nodeCallbacks[record.callbackIndex];\n      if (record.state === id.SEM_PRE) {\n        if (callback !== null) {\n          ret = callback(id.SEM_PRE, chars, record.phraseIndex, record.phraseLength, data);\n          if (ret === id.SEM_SKIP) {\n            i = record.thatIndex;\n          }\n        }\n      } else if (callback !== null) {\n        callback(id.SEM_POST, chars, record.phraseIndex, record.phraseLength, data);\n      }\n    }\n  };\n  /* called by the parser to reset the length of the records array */\n  /* necessary on backtracking */\n  this.setLength = function setLength(length) {\n    records.length = length;\n    if (length > 0) {\n      stack.length = records[length - 1].stack;\n    } else {\n      stack.length = 0;\n    }\n  };\n  /* called by the parser to get the length of the records array */\n  this.getLength = function getLength() {\n    return records.length;\n  };\n  /* helper for XML display */\n  function indent(n) {\n    let ret = '';\n    for (let i = 0; i < n; i += 1) {\n      ret += ' ';\n    }\n    return ret;\n  }\n  // Generate an `XML` version of the AST.\n  // Useful if you want to use a special or favorite XML parser to translate the\n  // AST.\n  // ```\n  // mode - the display mode of the captured phrases\n  //      - default mode is \"ascii\"\n  //      - can be: \"ascii\"\n  //                \"decimal\"\n  //                \"hexadecimal\"\n  //                \"unicode\"\n  // ```\n  this.toXml = function toSml(modeArg) {\n    let display = utils.charsToDec;\n    let caption = 'decimal integer character codes';\n    if (typeof modeArg === 'string' && modeArg.length >= 3) {\n      const mode = modeArg.slice(0, 3).toLowerCase();\n      if (mode === 'asc') {\n        display = utils.charsToAscii;\n        caption = 'ASCII for printing characters, hex for non-printing';\n      } else if (mode === 'hex') {\n        display = utils.charsToHex;\n        caption = 'hexadecimal integer character codes';\n      } else if (mode === 'uni') {\n        display = utils.charsToUnicode;\n        caption = 'Unicode UTF-32 integer character codes';\n      }\n    }\n    let xml = '';\n    let depth = 0;\n    xml += '<?xml version=\"1.0\" encoding=\"utf-8\"?>\\n';\n    xml += `<root nodes=\"${records.length / 2}\" characters=\"${chars.length}\">\\n`;\n    xml += `<!-- input string, ${caption} -->\\n`;\n    xml += indent(depth + 2);\n    xml += display(chars);\n    xml += '\\n';\n    records.forEach((rec) => {\n      if (rec.state === id.SEM_PRE) {\n        depth += 1;\n        xml += indent(depth);\n        xml += `<node name=\"${rec.name}\" index=\"${rec.phraseIndex}\" length=\"${rec.phraseLength}\">\\n`;\n        xml += indent(depth + 2);\n        xml += display(chars, rec.phraseIndex, rec.phraseLength);\n        xml += '\\n';\n      } else {\n        xml += indent(depth);\n        xml += `</node><!-- name=\"${rec.name}\" -->\\n`;\n        depth -= 1;\n      }\n    });\n\n    xml += '</root>\\n';\n    return xml;\n  };\n  /* generate a JavaScript object version of the AST */\n  /* for the phrase-matching engine apg-exp */\n  this.phrases = function phrases() {\n    const obj = {};\n    let i;\n    let record;\n    for (i = 0; i < records.length; i += 1) {\n      record = records[i];\n      if (record.state === id.SEM_PRE) {\n        if (!Array.isArray(obj[record.name])) {\n          obj[record.name] = [];\n        }\n        obj[record.name].push({\n          index: record.phraseIndex,\n          length: record.phraseLength,\n        });\n      }\n    }\n    return obj;\n  };\n};\n"],"names":[],"mappings":"AAAA,+BAA+B,GAC/B,uCAAuC,GACvC;;;uFAGuF,GACvF,kIAAkI;AAClI,gEAAgE;AAChE,sGAAsG;AACtG,2EAA2E;AAC3E,6DAA6D;AAC7D,mEAAmE;AACnE,kFAAkF;AAClF,kFAAkF;AAClF,kCAAkC;AAClC,8EAA8E;AAC9E,4FAA4F;AAC5F,sDAAsD;AACtD,EAAE;AACF,6EAA6E;AAC7E,MAAM;AACN,iEAAiE;AACjE,MAAM;AACN,gDAAgD;AAChD,MAAM;AACN,iCAAiC;AACjC,MAAM;AACN,0EAA0E;AAC1E,gDAAgD;AAChD,4HAA4H;AAC5H,sEAAsE;AACtE,OAAO,OAAO,GAAG,SAAS;IACxB,MAAM;IACN,MAAM;IAEN,MAAM,eAAe;IACrB,MAAM,OAAO,IAAI;IACjB,IAAI,QAAQ;IACZ,IAAI,OAAO;IACX,IAAI,QAAQ;IACZ,IAAI,YAAY;IAChB,MAAM,eAAe,EAAE;IACvB,MAAM,gBAAgB,EAAE;IACxB,MAAM,QAAQ,EAAE;IAChB,MAAM,UAAU,EAAE;IAClB,IAAI,CAAC,SAAS,GAAG,EAAE;IACnB,IAAI,CAAC,SAAS,GAAG;IACjB,4FAA4F,GAC5F,IAAI,CAAC,IAAI,GAAG,SAAS,KAAK,OAAO,EAAE,MAAM,EAAE,OAAO;QAChD,MAAM,MAAM,GAAG;QACf,QAAQ,MAAM,GAAG;QACjB,aAAa,MAAM,GAAG;QACtB,YAAY;QACZ,QAAQ;QACR,OAAO;QACP,QAAQ;QACR,IAAI;QACJ,MAAM,OAAO,EAAE;QACf,IAAK,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,KAAK,EAAG;YACpC,KAAK,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK;QAC1B;QACA,IAAK,IAAI,GAAG,IAAI,KAAK,MAAM,EAAE,KAAK,EAAG;YACnC,KAAK,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK;QACzB;QACA,YAAY,MAAM,MAAM,GAAG,KAAK,MAAM;QACtC,IAAK,IAAI,GAAG,IAAI,WAAW,KAAK,EAAG;YACjC,YAAY,CAAC,EAAE,GAAG;YAClB,aAAa,CAAC,EAAE,GAAG;QACrB;QACA,IAAK,MAAM,SAAS,KAAK,SAAS,CAAE;YAClC,MAAM,QAAQ,MAAM,WAAW;YAC/B,IAAI,KAAK,OAAO,CAAC;YACjB,IAAI,IAAI,GAAG;gBACT,MAAM,IAAI,MAAM,GAAG,aAAa,YAAY,EAAE,MAAM,wBAAwB,CAAC;YAC/E;YACA,IAAI,OAAO,KAAK,SAAS,CAAC,MAAM,KAAK,YAAY;gBAC/C,YAAY,CAAC,EAAE,GAAG;gBAClB,aAAa,CAAC,EAAE,GAAG,KAAK,SAAS,CAAC,MAAM;YAC1C;YACA,IAAI,KAAK,SAAS,CAAC,MAAM,KAAK,MAAM;gBAClC,YAAY,CAAC,EAAE,GAAG;YACpB;QACF;IACF;IACA,gEAAgE,GAChE,IAAI,CAAC,WAAW,GAAG,SAAS,YAAY,KAAK;QAC3C,OAAO,YAAY,CAAC,MAAM,KAAK;IACjC;IACA,gEAAgE,GAChE,IAAI,CAAC,UAAU,GAAG,SAAS,WAAW,KAAK;QACzC,OAAO,YAAY,CAAC,MAAM,MAAM,GAAG,MAAM,KAAK;IAChD;IACA,kDAAkD,GAClD,0DAA0D,GAC1D,IAAI,CAAC,IAAI,GAAG,SAAS,KAAK,aAAa,EAAE,IAAI;QAC3C,MAAM,YAAY,QAAQ,MAAM;QAChC,MAAM,IAAI,CAAC;QACX,QAAQ,IAAI,CAAC;YACX;YACA;YACA,WAAW;YACX,OAAO,GAAG,OAAO;YACjB;YACA,aAAa;YACb,cAAc;YACd,OAAO,MAAM,MAAM;QACrB;QACA,OAAO;IACT;IACA,kDAAkD,GAClD,wDAAwD,GACxD,IAAI,CAAC,EAAE,GAAG,SAAS,GAAG,aAAa,EAAE,IAAI,EAAE,WAAW,EAAE,YAAY;QAClE,MAAM,YAAY,QAAQ,MAAM;QAChC,MAAM,YAAY,MAAM,GAAG;QAC3B,QAAQ,IAAI,CAAC;YACX;YACA;YACA;YACA,OAAO,GAAG,QAAQ;YAClB;YACA;YACA;YACA,OAAO,MAAM,MAAM;QACrB;QACA,OAAO,CAAC,UAAU,CAAC,SAAS,GAAG;QAC/B,OAAO,CAAC,UAAU,CAAC,WAAW,GAAG;QACjC,OAAO,CAAC,UAAU,CAAC,YAAY,GAAG;QAClC,OAAO;IACT;IACA,2CAA2C;IAC3C,oEAAoE;IACpE,qEAAqE;IACrE,2BAA2B;IAC3B,MAAM;IACN,oCAAoC;IACpC,4DAA4D;IAC5D,MAAM;IACN,IAAI,CAAC,SAAS,GAAG,SAAS,UAAU,IAAI;QACtC,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,MAAM,EAAE,KAAK,EAAG;YAC1C,SAAS,OAAO,CAAC,EAAE;YACnB,WAAW,aAAa,CAAC,OAAO,aAAa,CAAC;YAC9C,IAAI,OAAO,KAAK,KAAK,GAAG,OAAO,EAAE;gBAC/B,IAAI,aAAa,MAAM;oBACrB,MAAM,SAAS,GAAG,OAAO,EAAE,OAAO,OAAO,WAAW,EAAE,OAAO,YAAY,EAAE;oBAC3E,IAAI,QAAQ,GAAG,QAAQ,EAAE;wBACvB,IAAI,OAAO,SAAS;oBACtB;gBACF;YACF,OAAO,IAAI,aAAa,MAAM;gBAC5B,SAAS,GAAG,QAAQ,EAAE,OAAO,OAAO,WAAW,EAAE,OAAO,YAAY,EAAE;YACxE;QACF;IACF;IACA,iEAAiE,GACjE,6BAA6B,GAC7B,IAAI,CAAC,SAAS,GAAG,SAAS,UAAU,MAAM;QACxC,QAAQ,MAAM,GAAG;QACjB,IAAI,SAAS,GAAG;YACd,MAAM,MAAM,GAAG,OAAO,CAAC,SAAS,EAAE,CAAC,KAAK;QAC1C,OAAO;YACL,MAAM,MAAM,GAAG;QACjB;IACF;IACA,+DAA+D,GAC/D,IAAI,CAAC,SAAS,GAAG,SAAS;QACxB,OAAO,QAAQ,MAAM;IACvB;IACA,0BAA0B,GAC1B,SAAS,OAAO,CAAC;QACf,IAAI,MAAM;QACV,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,KAAK,EAAG;YAC7B,OAAO;QACT;QACA,OAAO;IACT;IACA,wCAAwC;IACxC,8EAA8E;IAC9E,OAAO;IACP,MAAM;IACN,kDAAkD;IAClD,iCAAiC;IACjC,yBAAyB;IACzB,2BAA2B;IAC3B,+BAA+B;IAC/B,2BAA2B;IAC3B,MAAM;IACN,IAAI,CAAC,KAAK,GAAG,SAAS,MAAM,OAAO;QACjC,IAAI,UAAU,MAAM,UAAU;QAC9B,IAAI,UAAU;QACd,IAAI,OAAO,YAAY,YAAY,QAAQ,MAAM,IAAI,GAAG;YACtD,MAAM,OAAO,QAAQ,KAAK,CAAC,GAAG,GAAG,WAAW;YAC5C,IAAI,SAAS,OAAO;gBAClB,UAAU,MAAM,YAAY;gBAC5B,UAAU;YACZ,OAAO,IAAI,SAAS,OAAO;gBACzB,UAAU,MAAM,UAAU;gBAC1B,UAAU;YACZ,OAAO,IAAI,SAAS,OAAO;gBACzB,UAAU,MAAM,cAAc;gBAC9B,UAAU;YACZ;QACF;QACA,IAAI,MAAM;QACV,IAAI,QAAQ;QACZ,OAAO;QACP,OAAO,CAAC,aAAa,EAAE,QAAQ,MAAM,GAAG,EAAE,cAAc,EAAE,MAAM,MAAM,CAAC,IAAI,CAAC;QAC5E,OAAO,CAAC,mBAAmB,EAAE,QAAQ,MAAM,CAAC;QAC5C,OAAO,OAAO,QAAQ;QACtB,OAAO,QAAQ;QACf,OAAO;QACP,QAAQ,OAAO,CAAC,CAAC;YACf,IAAI,IAAI,KAAK,KAAK,GAAG,OAAO,EAAE;gBAC5B,SAAS;gBACT,OAAO,OAAO;gBACd,OAAO,CAAC,YAAY,EAAE,IAAI,IAAI,CAAC,SAAS,EAAE,IAAI,WAAW,CAAC,UAAU,EAAE,IAAI,YAAY,CAAC,IAAI,CAAC;gBAC5F,OAAO,OAAO,QAAQ;gBACtB,OAAO,QAAQ,OAAO,IAAI,WAAW,EAAE,IAAI,YAAY;gBACvD,OAAO;YACT,OAAO;gBACL,OAAO,OAAO;gBACd,OAAO,CAAC,kBAAkB,EAAE,IAAI,IAAI,CAAC,OAAO,CAAC;gBAC7C,SAAS;YACX;QACF;QAEA,OAAO;QACP,OAAO;IACT;IACA,mDAAmD,GACnD,0CAA0C,GAC1C,IAAI,CAAC,OAAO,GAAG,SAAS;QACtB,MAAM,MAAM,CAAC;QACb,IAAI;QACJ,IAAI;QACJ,IAAK,IAAI,GAAG,IAAI,QAAQ,MAAM,EAAE,KAAK,EAAG;YACtC,SAAS,OAAO,CAAC,EAAE;YACnB,IAAI,OAAO,KAAK,KAAK,GAAG,OAAO,EAAE;gBAC/B,IAAI,CAAC,MAAM,OAAO,CAAC,GAAG,CAAC,OAAO,IAAI,CAAC,GAAG;oBACpC,GAAG,CAAC,OAAO,IAAI,CAAC,GAAG,EAAE;gBACvB;gBACA,GAAG,CAAC,OAAO,IAAI,CAAC,CAAC,IAAI,CAAC;oBACpB,OAAO,OAAO,WAAW;oBACzB,QAAQ,OAAO,YAAY;gBAC7B;YACF;QACF;QACA,OAAO;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 2494, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/apg-js/src/apg-lib/circular-buffer.js"],"sourcesContent":["/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module acts as a \"circular buffer\". It is used to keep track\n// only the last N records in an array of records. If more than N records\n// are saved, each additional record overwrites the previously oldest record.\n// This module deals only with the record indexes and does not save\n// any actual records. It is used by [`trace.js`](./trace.html) for limiting the number of\n// trace records saved.\nmodule.exports = function exportsCircularBuffer() {\n  'use strict;';\n\n  const thisFileName = 'circular-buffer.js: ';\n  let itemIndex = -1;\n  let maxListSize = 0;\n  // Initialize buffer.<br>\n  // *size* is `maxListSize`, the maximum number of records saved before overwriting begins.\n  this.init = function init(size) {\n    if (typeof size !== 'number' || size <= 0) {\n      throw new Error(`${thisFileName}init: circular buffer size must an integer > 0`);\n    }\n    maxListSize = Math.ceil(size);\n    itemIndex = -1;\n  };\n  // Call this to increment the number of records collected.<br>\n  // Returns the array index number to store the next record in.\n  this.increment = function increment() {\n    itemIndex += 1;\n    return (itemIndex + maxListSize) % maxListSize;\n  };\n  // Returns `maxListSize` - the maximum number of records to keep in the buffer.\n  this.maxSize = function maxSize() {\n    return maxListSize;\n  };\n  // Returns the highest number of items saved.<br>\n  // (The number of items is the actual number of records processed\n  // even though only `maxListSize` records are actually retained.)\n  this.items = function items() {\n    return itemIndex + 1;\n  };\n  // Returns the record number associated with this item index.\n  this.getListIndex = function getListIndex(item) {\n    if (itemIndex === -1) {\n      return -1;\n    }\n    if (item < 0 || item > itemIndex) {\n      return -1;\n    }\n    if (itemIndex - item >= maxListSize) {\n      return -1;\n    }\n    return (item + maxListSize) % maxListSize;\n  };\n  // The iterator over the circular buffer.\n  // The user's function, `fn`, will be called with arguments `fn(listIndex, itemIndex)`\n  // where `listIndex` is the saved record index and `itemIndex` is the actual item index.\n  this.forEach = function forEach(fn) {\n    if (itemIndex === -1) {\n      /* no records have been collected */\n      return;\n    }\n    if (itemIndex < maxListSize) {\n      /* fewer than maxListSize records have been collected - number of items = number of records */\n      for (let i = 0; i <= itemIndex; i += 1) {\n        fn(i, i);\n      }\n      return;\n    }\n    /* start with the oldest record saved and finish with the most recent record saved */\n    for (let i = itemIndex - maxListSize + 1; i <= itemIndex; i += 1) {\n      const listIndex = (i + maxListSize) % maxListSize;\n      fn(listIndex, i);\n    }\n  };\n};\n"],"names":[],"mappings":"AAAA;;;uFAGuF,GACvF,oEAAoE;AACpE,yEAAyE;AACzE,6EAA6E;AAC7E,mEAAmE;AACnE,0FAA0F;AAC1F,uBAAuB;AACvB,OAAO,OAAO,GAAG,SAAS;IACxB;IAEA,MAAM,eAAe;IACrB,IAAI,YAAY,CAAC;IACjB,IAAI,cAAc;IAClB,yBAAyB;IACzB,0FAA0F;IAC1F,IAAI,CAAC,IAAI,GAAG,SAAS,KAAK,IAAI;QAC5B,IAAI,OAAO,SAAS,YAAY,QAAQ,GAAG;YACzC,MAAM,IAAI,MAAM,GAAG,aAAa,8CAA8C,CAAC;QACjF;QACA,cAAc,KAAK,IAAI,CAAC;QACxB,YAAY,CAAC;IACf;IACA,8DAA8D;IAC9D,8DAA8D;IAC9D,IAAI,CAAC,SAAS,GAAG,SAAS;QACxB,aAAa;QACb,OAAO,CAAC,YAAY,WAAW,IAAI;IACrC;IACA,+EAA+E;IAC/E,IAAI,CAAC,OAAO,GAAG,SAAS;QACtB,OAAO;IACT;IACA,iDAAiD;IACjD,iEAAiE;IACjE,iEAAiE;IACjE,IAAI,CAAC,KAAK,GAAG,SAAS;QACpB,OAAO,YAAY;IACrB;IACA,6DAA6D;IAC7D,IAAI,CAAC,YAAY,GAAG,SAAS,aAAa,IAAI;QAC5C,IAAI,cAAc,CAAC,GAAG;YACpB,OAAO,CAAC;QACV;QACA,IAAI,OAAO,KAAK,OAAO,WAAW;YAChC,OAAO,CAAC;QACV;QACA,IAAI,YAAY,QAAQ,aAAa;YACnC,OAAO,CAAC;QACV;QACA,OAAO,CAAC,OAAO,WAAW,IAAI;IAChC;IACA,yCAAyC;IACzC,sFAAsF;IACtF,wFAAwF;IACxF,IAAI,CAAC,OAAO,GAAG,SAAS,QAAQ,EAAE;QAChC,IAAI,cAAc,CAAC,GAAG;YACpB,kCAAkC,GAClC;QACF;QACA,IAAI,YAAY,aAAa;YAC3B,4FAA4F,GAC5F,IAAK,IAAI,IAAI,GAAG,KAAK,WAAW,KAAK,EAAG;gBACtC,GAAG,GAAG;YACR;YACA;QACF;QACA,mFAAmF,GACnF,IAAK,IAAI,IAAI,YAAY,cAAc,GAAG,KAAK,WAAW,KAAK,EAAG;YAChE,MAAM,YAAY,CAAC,IAAI,WAAW,IAAI;YACtC,GAAG,WAAW;QAChB;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 2568, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/apg-js/src/apg-lib/parser.js"],"sourcesContent":["/* eslint-disable func-names */\n/* eslint-disable no-restricted-syntax */\n/* eslint-disable new-cap */\n/* eslint-disable guard-for-in */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This is the primary object of `apg-lib`. Calling its `parse()` member function\n// walks the parse tree of opcodes, matching phrases from the input string as it goes.\n// The working code for all of the operators, `ALT`, `CAT`, etc. is in this module.\nmodule.exports = function parser() {\n  const id = require('./identifiers');\n  const utils = require('./utilities');\n\n  const thisFileName = 'parser.js: ';\n  const thisThis = this;\n  let opExecute;\n  this.ast = null;\n  this.stats = null;\n  this.trace = null;\n  this.callbacks = [];\n  let opcodes = null;\n  let chars = null;\n  let charsBegin;\n  let charsLength;\n  let charsEnd;\n  let lookAround;\n  let treeDepth = 0;\n  let maxTreeDepth = 0;\n  let nodeHits = 0;\n  let ruleCallbacks = null;\n  let udtCallbacks = null;\n  let rules = null;\n  let udts = null;\n  let syntaxData = null;\n  let maxMatched = 0;\n  let limitTreeDepth = Infinity;\n  let limitNodeHits = Infinity;\n  // Evaluates any given rule. This can be called from the syntax callback\n  // functions to evaluate any rule in the grammar's rule list. Great caution\n  // should be used. Use of this function will alter the language that the\n  // parser accepts.\n  const evaluateRule = function evaluateRule(ruleIndex, phraseIndex, sysData) {\n    const functionName = `${thisFileName}evaluateRule(): `;\n    if (ruleIndex >= rules.length) {\n      throw new Error(`${functionName}rule index: ${ruleIndex} out of range`);\n    }\n    if (phraseIndex >= charsEnd) {\n      throw new Error(`${functionName}phrase index: ${phraseIndex} out of range`);\n    }\n    const { length } = opcodes;\n    opcodes.push({\n      type: id.RNM,\n      index: ruleIndex,\n    });\n    opExecute(length, phraseIndex, sysData);\n    opcodes.pop();\n  };\n  // Evaluates any given UDT. This can be called from the syntax callback\n  // functions to evaluate any UDT in the grammar's UDT list. Great caution\n  // should be used. Use of this function will alter the language that the\n  // parser accepts.\n  const evaluateUdt = function (udtIndex, phraseIndex, sysData) {\n    const functionName = `${thisFileName}evaluateUdt(): `;\n    if (udtIndex >= udts.length) {\n      throw new Error(`${functionName}udt index: ${udtIndex} out of range`);\n    }\n    if (phraseIndex >= charsEnd) {\n      throw new Error(`${functionName}phrase index: ${phraseIndex} out of range`);\n    }\n    const { length } = opcodes;\n    opcodes.push({\n      type: id.UDT,\n      empty: udts[udtIndex].empty,\n      index: udtIndex,\n    });\n    opExecute(length, phraseIndex, sysData);\n    opcodes.pop();\n  };\n  /* Clears this object of any/all data that has been initialized or added to it. */\n  /* Called by parse() on initialization, allowing this object to be re-used for multiple parsing calls. */\n  const clear = function () {\n    treeDepth = 0;\n    maxTreeDepth = 0;\n    nodeHits = 0;\n    maxMatched = 0;\n    lookAround = [\n      {\n        lookAround: id.LOOKAROUND_NONE,\n        anchor: 0,\n        charsEnd: 0,\n        charsLength: 0,\n      },\n    ];\n    rules = null;\n    udts = null;\n    chars = null;\n    charsBegin = 0;\n    charsLength = 0;\n    charsEnd = 0;\n    ruleCallbacks = null;\n    udtCallbacks = null;\n    syntaxData = null;\n    opcodes = null;\n  };\n  /* object for maintaining a stack of back reference frames */\n  const backRef = function () {\n    const stack = [];\n    const init = function () {\n      const obj = {};\n      rules.forEach((rule) => {\n        if (rule.isBkr) {\n          obj[rule.lower] = null;\n        }\n      });\n      if (udts.length > 0) {\n        udts.forEach((udt) => {\n          if (udt.isBkr) {\n            obj[udt.lower] = null;\n          }\n        });\n      }\n      stack.push(obj);\n    };\n    const copy = function () {\n      const top = stack[stack.length - 1];\n      const obj = {};\n      /* // eslint-disable-next-line no-restricted-syntax */\n      for (const name in top) {\n        obj[name] = top[name];\n      }\n      return obj;\n    };\n    this.push = function push() {\n      stack.push(copy());\n    };\n    this.pop = function pop(lengthArg) {\n      let length = lengthArg;\n      if (!length) {\n        length = stack.length - 1;\n      }\n      if (length < 1 || length > stack.length) {\n        throw new Error(`${thisFileName}backRef.pop(): bad length: ${length}`);\n      }\n      stack.length = length;\n      return stack[stack.length - 1];\n    };\n    this.length = function length() {\n      return stack.length;\n    };\n    this.savePhrase = function savePhrase(name, index, length) {\n      stack[stack.length - 1][name] = {\n        phraseIndex: index,\n        phraseLength: length,\n      };\n    };\n    this.getPhrase = function (name) {\n      return stack[stack.length - 1][name];\n    };\n    /* constructor */\n    init();\n  };\n  // The system data structure that relays system information to and from the rule and UDT callback functions.\n  // - *state* - the state of the parser, ACTIVE, MATCH, EMPTY or NOMATCH (see the `identifiers` object in\n  // [`apg-lib`](https://github.com/ldthomas/apg-js2-lib))\n  // - *phraseLength* - the number of characters matched if the state is MATCHED or EMPTY\n  // - *lookaround* - the top of the stack holds the current look around state,\n  // LOOKAROUND_NONE, LOOKAROUND_AHEAD or LOOKAROUND_BEHIND,\n  // - *uFrame* - the \"universal\" back reference frame.\n  // Holds the last matched phrase for each of the back referenced rules and UDTs.\n  // - *pFrame* - the stack of \"parent\" back reference frames.\n  // Holds the matched phrase from the parent frame of each back referenced rules and UDTs.\n  // - *evaluateRule* - a reference to this object's `evaluateRule()` function.\n  // Can be called from a callback function (use with extreme caution!)\n  // - *evaluateUdt* - a reference to this object's `evaluateUdt()` function.\n  // Can be called from a callback function (use with extreme caution!)\n  const systemData = function systemData() {\n    const thisData = this;\n    this.state = id.ACTIVE;\n    this.phraseLength = 0;\n    this.ruleIndex = 0;\n    this.udtIndex = 0;\n    this.lookAround = lookAround[lookAround.length - 1];\n    this.uFrame = new backRef();\n    this.pFrame = new backRef();\n    this.evaluateRule = evaluateRule;\n    this.evaluateUdt = evaluateUdt;\n    /* refresh the parser state for the next operation */\n    this.refresh = function refresh() {\n      thisData.state = id.ACTIVE;\n      thisData.phraseLength = 0;\n      thisData.lookAround = lookAround[lookAround.length - 1];\n    };\n  };\n  /* some look around helper functions */\n  const lookAroundValue = function lookAroundValue() {\n    return lookAround[lookAround.length - 1];\n  };\n  /* return true if parser is in look around (ahead or behind) state */\n  const inLookAround = function inLookAround() {\n    return lookAround.length > 1;\n  };\n  /* return true if parser is in look behind state */\n  const inLookBehind = function () {\n    return lookAround[lookAround.length - 1].lookAround === id.LOOKAROUND_BEHIND;\n  };\n  /* called by parse() to initialize the AST object, if one has been defined */\n  const initializeAst = function () {\n    const functionName = `${thisFileName}initializeAst(): `;\n    const TRUE = true;\n    while (TRUE) {\n      if (thisThis.ast === undefined) {\n        thisThis.ast = null;\n        break;\n      }\n      if (thisThis.ast === null) {\n        break;\n      }\n      if (thisThis.ast.astObject !== 'astObject') {\n        throw new Error(`${functionName}ast object not recognized`);\n      }\n      break;\n    }\n    if (thisThis.ast !== null) {\n      thisThis.ast.init(rules, udts, chars);\n    }\n  };\n  /* called by parse() to initialize the trace object, if one has been defined */\n  const initializeTrace = function () {\n    const functionName = `${thisFileName}initializeTrace(): `;\n    const TRUE = true;\n    while (TRUE) {\n      if (thisThis.trace === undefined) {\n        thisThis.trace = null;\n        break;\n      }\n      if (thisThis.trace === null) {\n        break;\n      }\n      if (thisThis.trace.traceObject !== 'traceObject') {\n        throw new Error(`${functionName}trace object not recognized`);\n      }\n      break;\n    }\n    if (thisThis.trace !== null) {\n      thisThis.trace.init(rules, udts, chars);\n    }\n  };\n  /* called by parse() to initialize the statistics object, if one has been defined */\n  const initializeStats = function () {\n    const functionName = `${thisFileName}initializeStats(): `;\n    const TRUE = true;\n    while (TRUE) {\n      if (thisThis.stats === undefined) {\n        thisThis.stats = null;\n        break;\n      }\n      if (thisThis.stats === null) {\n        break;\n      }\n      if (thisThis.stats.statsObject !== 'statsObject') {\n        throw new Error(`${functionName}stats object not recognized`);\n      }\n      break;\n    }\n    if (thisThis.stats !== null) {\n      thisThis.stats.init(rules, udts);\n    }\n  };\n  /* called by parse() to initialize the rules & udts from the grammar object */\n  /* (the grammar object generated previously by apg) */\n  const initializeGrammar = function (grammar) {\n    const functionName = `${thisFileName}initializeGrammar(): `;\n    if (!grammar) {\n      throw new Error(`${functionName}grammar object undefined`);\n    }\n    if (grammar.grammarObject !== 'grammarObject') {\n      throw new Error(`${functionName}bad grammar object`);\n    }\n    rules = grammar.rules;\n    udts = grammar.udts;\n  };\n  /* called by parse() to initialize the start rule */\n  const initializeStartRule = function (startRule) {\n    const functionName = `${thisFileName}initializeStartRule(): `;\n    let start = null;\n    if (typeof startRule === 'number') {\n      if (startRule >= rules.length) {\n        throw new Error(`${functionName}start rule index too large: max: ${rules.length}: index: ${startRule}`);\n      }\n      start = startRule;\n    } else if (typeof startRule === 'string') {\n      const lower = startRule.toLowerCase();\n      for (let i = 0; i < rules.length; i += 1) {\n        if (lower === rules[i].lower) {\n          start = rules[i].index;\n          break;\n        }\n      }\n      if (start === null) {\n        throw new Error(`${functionName}start rule name '${startRule}' not recognized`);\n      }\n    } else {\n      throw new Error(`${functionName}type of start rule '${typeof startRule}' not recognized`);\n    }\n    return start;\n  };\n  /* called by parse() to initialize the array of characters codes representing the input string */\n  const initializeInputChars = function initializeInputChars(inputArg, begArg, lenArg) {\n    const functionName = `${thisFileName}initializeInputChars(): `;\n    /* varify and normalize input */\n    let input = inputArg;\n    let beg = begArg;\n    let len = lenArg;\n    if (input === undefined) {\n      throw new Error(`${functionName}input string is undefined`);\n    }\n    if (input === null) {\n      throw new Error(`${functionName}input string is null`);\n    }\n    if (typeof input === 'string') {\n      input = utils.stringToChars(input);\n    } else if (!Array.isArray(input)) {\n      throw new Error(`${functionName}input string is not a string or array`);\n    }\n    if (input.length > 0) {\n      if (typeof input[0] !== 'number') {\n        throw new Error(`${functionName}input string not an array of integers`);\n      }\n    }\n    /* verify and normalize beginning index */\n    if (typeof beg !== 'number') {\n      beg = 0;\n    } else {\n      beg = Math.floor(beg);\n      if (beg < 0 || beg > input.length) {\n        throw new Error(`${functionName}input beginning index out of range: ${beg}`);\n      }\n    }\n    /* verify and normalize input length */\n    if (typeof len !== 'number') {\n      len = input.length - beg;\n    } else {\n      len = Math.floor(len);\n      if (len < 0 || len > input.length - beg) {\n        throw new Error(`${functionName}input length out of range: ${len}`);\n      }\n    }\n    chars = input;\n    charsBegin = beg;\n    charsLength = len;\n    charsEnd = charsBegin + charsLength;\n  };\n  /* called by parse() to initialize the user-written, syntax callback functions, if any */\n  const initializeCallbacks = function () {\n    const functionName = `${thisFileName}initializeCallbacks(): `;\n    let i;\n    ruleCallbacks = [];\n    udtCallbacks = [];\n    for (i = 0; i < rules.length; i += 1) {\n      ruleCallbacks[i] = null;\n    }\n    for (i = 0; i < udts.length; i += 1) {\n      udtCallbacks[i] = null;\n    }\n    let func;\n    const list = [];\n    for (i = 0; i < rules.length; i += 1) {\n      list.push(rules[i].lower);\n    }\n    for (i = 0; i < udts.length; i += 1) {\n      list.push(udts[i].lower);\n    }\n    for (const index in thisThis.callbacks) {\n      i = list.indexOf(index.toLowerCase());\n      if (i < 0) {\n        throw new Error(`${functionName}syntax callback '${index}' not a rule or udt name`);\n      }\n      func = thisThis.callbacks[index];\n      if (!func) {\n        func = null;\n      }\n      if (typeof func === 'function' || func === null) {\n        if (i < rules.length) {\n          ruleCallbacks[i] = func;\n        } else {\n          udtCallbacks[i - rules.length] = func;\n        }\n      } else {\n        throw new Error(\n          `${functionName}syntax callback[${index}] must be function reference or 'false' (false/null/undefined/etc.)`\n        );\n      }\n    }\n    /* make sure all udts have been defined - the parser can't work without them */\n    for (i = 0; i < udts.length; i += 1) {\n      if (udtCallbacks[i] === null) {\n        throw new Error(\n          `${functionName}all UDT callbacks must be defined. UDT callback[${udts[i].lower}] not a function reference`\n        );\n      }\n    }\n  };\n  // Set the maximum parse tree depth allowed. The default is `Infinity`.\n  // A limit is not normally needed, but can be used to protect against an\n  // exponentual or \"catastrophically backtracking\" grammar.\n  // <ul>\n  // <li>\n  // depth - max allowed parse tree depth. An exception is thrown if exceeded.\n  // </li>\n  // </ul>\n  this.setMaxTreeDepth = function (depth) {\n    if (typeof depth !== 'number') {\n      throw new Error(`parser: max tree depth must be integer > 0: ${depth}`);\n    }\n    limitTreeDepth = Math.floor(depth);\n    if (limitTreeDepth <= 0) {\n      throw new Error(`parser: max tree depth must be integer > 0: ${depth}`);\n    }\n  };\n  // Set the maximum number of node hits (parser unit steps or opcode function calls) allowed.\n  // The default is `Infinity`.\n  // A limit is not normally needed, but can be used to protect against an\n  // exponentual or \"catastrophically backtracking\" grammar.\n  // <ul>\n  // <li>\n  // hits - maximum number of node hits or parser unit steps allowed.\n  // An exception thrown if exceeded.\n  // </li>\n  // </ul>\n  this.setMaxNodeHits = function (hits) {\n    if (typeof hits !== 'number') {\n      throw new Error(`parser: max node hits must be integer > 0: ${hits}`);\n    }\n    limitNodeHits = Math.floor(hits);\n    if (limitNodeHits <= 0) {\n      throw new Error(`parser: max node hits must be integer > 0: ${hits}`);\n    }\n  };\n  /* the main parser function */\n  const privateParse = function (grammar, startRuleArg, callbackData) {\n    let success;\n    const functionName = `${thisFileName}parse(): `;\n    initializeGrammar(grammar);\n    const startRule = initializeStartRule(startRuleArg);\n    initializeCallbacks();\n    initializeTrace();\n    initializeStats();\n    initializeAst();\n    const sysData = new systemData();\n    if (!(callbackData === undefined || callbackData === null)) {\n      syntaxData = callbackData;\n    }\n    /* create a dummy opcode for the start rule */\n    opcodes = [\n      {\n        type: id.RNM,\n        index: startRule,\n      },\n    ];\n    /* execute the start rule */\n    opExecute(0, charsBegin, sysData);\n    opcodes = null;\n    /* test and return the sysData */\n    switch (sysData.state) {\n      case id.ACTIVE:\n        throw new Error(`${functionName}final state should never be 'ACTIVE'`);\n      case id.NOMATCH:\n        success = false;\n        break;\n      case id.EMPTY:\n      case id.MATCH:\n        if (sysData.phraseLength === charsLength) {\n          success = true;\n        } else {\n          success = false;\n        }\n        break;\n      default:\n        throw new Error('unrecognized state');\n    }\n    return {\n      success,\n      state: sysData.state,\n      length: charsLength,\n      matched: sysData.phraseLength,\n      maxMatched,\n      maxTreeDepth,\n      nodeHits,\n      inputLength: chars.length,\n      subBegin: charsBegin,\n      subEnd: charsEnd,\n      subLength: charsLength,\n    };\n  };\n\n  // This form allows parsing of a sub-string of the full input string.\n  // <ul>\n  // <li>*inputIndex* - index of the first character in the sub-string</li>\n  // <li>*inputLength* - length of the sub-string</li>\n  // </ul>\n  // All other parameters as for the above function `parse()`.\n  this.parseSubstring = function parseSubstring(grammar, startRule, inputChars, inputIndex, inputLength, callbackData) {\n    clear();\n    initializeInputChars(inputChars, inputIndex, inputLength);\n    return privateParse(grammar, startRule, callbackData);\n  };\n  // This is the main function, called to parse an input string.\n  // <ul>\n  // <li>*grammar* - an instantiated grammar object - the output of `apg` for a\n  // specific SABNF grammar</li>\n  // <li>*startRule* - the rule name or rule index to be used as the root of the\n  // parse tree. This is usually the first rule, index = 0, of the grammar\n  // but can be any rule defined in the above grammar object.</li>\n  // <li>*inputChars* - the input string. Can be a string or an array of integer character codes representing the\n  // string.</li>\n  // <li>*callbackData* - user-defined data object to be passed to the user's\n  // callback functions.\n  // This is not used by the parser in any way, merely passed on to the user.\n  // May be `null` or omitted.</li>\n  // </ul>\n  this.parse = function parse(grammar, startRule, inputChars, callbackData) {\n    clear();\n    initializeInputChars(inputChars, 0, inputChars.length);\n    return privateParse(grammar, startRule, callbackData);\n  };\n  // The `ALT` operator.<br>\n  // Executes its child nodes, from left to right, until it finds a match.\n  // Fails if *all* of its child nodes fail.\n  const opALT = function (opIndex, phraseIndex, sysData) {\n    const op = opcodes[opIndex];\n    for (let i = 0; i < op.children.length; i += 1) {\n      opExecute(op.children[i], phraseIndex, sysData);\n      if (sysData.state !== id.NOMATCH) {\n        break;\n      }\n    }\n  };\n  // The `CAT` operator.<br>\n  // Executes all of its child nodes, from left to right,\n  // concatenating the matched phrases.\n  // Fails if *any* child nodes fail.\n  const opCAT = function (opIndex, phraseIndex, sysData) {\n    let success;\n    let astLength;\n    let catCharIndex;\n    let catPhrase;\n    const op = opcodes[opIndex];\n    const ulen = sysData.uFrame.length();\n    const plen = sysData.pFrame.length();\n    if (thisThis.ast) {\n      astLength = thisThis.ast.getLength();\n    }\n    success = true;\n    catCharIndex = phraseIndex;\n    catPhrase = 0;\n    for (let i = 0; i < op.children.length; i += 1) {\n      opExecute(op.children[i], catCharIndex, sysData);\n      if (sysData.state === id.NOMATCH) {\n        success = false;\n        break;\n      } else {\n        catCharIndex += sysData.phraseLength;\n        catPhrase += sysData.phraseLength;\n      }\n    }\n    if (success) {\n      sysData.state = catPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = catPhrase;\n    } else {\n      sysData.state = id.NOMATCH;\n      sysData.phraseLength = 0;\n      /* reset the back referencing frames on failure */\n      sysData.uFrame.pop(ulen);\n      sysData.pFrame.pop(plen);\n      if (thisThis.ast) {\n        thisThis.ast.setLength(astLength);\n      }\n    }\n  };\n  // The `REP` operator.<br>\n  // Repeatedly executes its single child node,\n  // concatenating each of the matched phrases found.\n  // The number of repetitions executed and its final sysData depends\n  // on its `min` & `max` repetition values.\n  const opREP = function (opIndex, phraseIndex, sysData) {\n    let astLength;\n    let repCharIndex;\n    let repPhrase;\n    let repCount;\n    const op = opcodes[opIndex];\n    if (op.max === 0) {\n      // this is an empty-string acceptor\n      // deprecated: use the TLS empty string operator, \"\", instead\n      sysData.state = id.EMPTY;\n      sysData.phraseLength = 0;\n      return;\n    }\n    repCharIndex = phraseIndex;\n    repPhrase = 0;\n    repCount = 0;\n    const ulen = sysData.uFrame.length();\n    const plen = sysData.pFrame.length();\n    if (thisThis.ast) {\n      astLength = thisThis.ast.getLength();\n    }\n    const TRUE = true;\n    while (TRUE) {\n      if (repCharIndex >= charsEnd) {\n        /* exit on end of input string */\n        break;\n      }\n      opExecute(opIndex + 1, repCharIndex, sysData);\n      if (sysData.state === id.NOMATCH) {\n        /* always end if the child node fails */\n        break;\n      }\n      if (sysData.state === id.EMPTY) {\n        /* REP always succeeds when the child node returns an empty phrase */\n        /* this may not seem obvious, but that's the way it works out */\n        break;\n      }\n      repCount += 1;\n      repPhrase += sysData.phraseLength;\n      repCharIndex += sysData.phraseLength;\n      if (repCount === op.max) {\n        /* end on maxed out reps */\n        break;\n      }\n    }\n    /* evaluate the match count according to the min, max values */\n    if (sysData.state === id.EMPTY) {\n      sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = repPhrase;\n    } else if (repCount >= op.min) {\n      sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = repPhrase;\n    } else {\n      sysData.state = id.NOMATCH;\n      sysData.phraseLength = 0;\n      /* reset the back referencing frames on failure */\n      sysData.uFrame.pop(ulen);\n      sysData.pFrame.pop(plen);\n      if (thisThis.ast) {\n        thisThis.ast.setLength(astLength);\n      }\n    }\n  };\n  // Validate the callback function's returned sysData values.\n  // It's the user's responsibility to get them right\n  // but `RNM` fails if not.\n  const validateRnmCallbackResult = function (rule, sysData, charsLeft, down) {\n    if (sysData.phraseLength > charsLeft) {\n      let str = `${thisFileName}opRNM(${rule.name}): callback function error: `;\n      str += `sysData.phraseLength: ${sysData.phraseLength}`;\n      str += ` must be <= remaining chars: ${charsLeft}`;\n      throw new Error(str);\n    }\n    switch (sysData.state) {\n      case id.ACTIVE:\n        if (down !== true) {\n          throw new Error(\n            `${thisFileName}opRNM(${rule.name}): callback function return error. ACTIVE state not allowed.`\n          );\n        }\n        break;\n      case id.EMPTY:\n        sysData.phraseLength = 0;\n        break;\n      case id.MATCH:\n        if (sysData.phraseLength === 0) {\n          sysData.state = id.EMPTY;\n        }\n        break;\n      case id.NOMATCH:\n        sysData.phraseLength = 0;\n        break;\n      default:\n        throw new Error(\n          `${thisFileName}opRNM(${rule.name}): callback function return error. Unrecognized return state: ${sysData.state}`\n        );\n    }\n  };\n  // The `RNM` operator.<br>\n  // This operator will acts as a root node for a parse tree branch below and\n  // returns the matched phrase to its parent.\n  // However, its larger responsibility is handling user-defined callback functions, back references and `AST` nodes.\n  // Note that the `AST` is a separate object, but `RNM` calls its functions to create its nodes.\n  // See [`ast.js`](./ast.html) for usage.\n  const opRNM = function (opIndex, phraseIndex, sysData) {\n    let astLength;\n    let astDefined;\n    let savedOpcodes;\n    let ulen;\n    let plen;\n    let saveFrame;\n    const op = opcodes[opIndex];\n    const rule = rules[op.index];\n    const callback = ruleCallbacks[rule.index];\n    const notLookAround = !inLookAround();\n    /* ignore AST and back references in lookaround */\n    if (notLookAround) {\n      /* begin AST and back references */\n      astDefined = thisThis.ast && thisThis.ast.ruleDefined(op.index);\n      if (astDefined) {\n        astLength = thisThis.ast.getLength();\n        thisThis.ast.down(op.index, rules[op.index].name);\n      }\n      ulen = sysData.uFrame.length();\n      plen = sysData.pFrame.length();\n      sysData.uFrame.push();\n      sysData.pFrame.push();\n      saveFrame = sysData.pFrame;\n      sysData.pFrame = new backRef();\n    }\n    if (callback === null) {\n      /* no callback - just execute the rule */\n      savedOpcodes = opcodes;\n      opcodes = rule.opcodes;\n      opExecute(0, phraseIndex, sysData);\n      opcodes = savedOpcodes;\n    } else {\n      /* call user's callback */\n      const charsLeft = charsEnd - phraseIndex;\n      sysData.ruleIndex = rule.index;\n      callback(sysData, chars, phraseIndex, syntaxData);\n      validateRnmCallbackResult(rule, sysData, charsLeft, true);\n      if (sysData.state === id.ACTIVE) {\n        savedOpcodes = opcodes;\n        opcodes = rule.opcodes;\n        opExecute(0, phraseIndex, sysData);\n        opcodes = savedOpcodes;\n        sysData.ruleIndex = rule.index;\n        callback(sysData, chars, phraseIndex, syntaxData);\n        validateRnmCallbackResult(rule, sysData, charsLeft, false);\n      } /* implied else clause: just accept the callback sysData - RNM acting as UDT */\n    }\n    if (notLookAround) {\n      /* end AST */\n      if (astDefined) {\n        if (sysData.state === id.NOMATCH) {\n          thisThis.ast.setLength(astLength);\n        } else {\n          thisThis.ast.up(op.index, rule.name, phraseIndex, sysData.phraseLength);\n        }\n      }\n      /* end back reference */\n      sysData.pFrame = saveFrame;\n      if (sysData.state === id.NOMATCH) {\n        sysData.uFrame.pop(ulen);\n        sysData.pFrame.pop(plen);\n      } else if (rule.isBkr) {\n        /* save phrase on both the parent and universal frames */\n        /* BKR operator will decide which to use later */\n        sysData.pFrame.savePhrase(rule.lower, phraseIndex, sysData.phraseLength);\n        sysData.uFrame.savePhrase(rule.lower, phraseIndex, sysData.phraseLength);\n      }\n    }\n  };\n  // Validate the callback function's returned sysData values.\n  // It's the user's responsibility to get it right but `UDT` fails if not.\n  const validateUdtCallbackResult = function (udt, sysData, charsLeft) {\n    if (sysData.phraseLength > charsLeft) {\n      let str = `${thisFileName}opUDT(${udt.name}): callback function error: `;\n      str += `sysData.phraseLength: ${sysData.phraseLength}`;\n      str += ` must be <= remaining chars: ${charsLeft}`;\n      throw new Error(str);\n    }\n    switch (sysData.state) {\n      case id.ACTIVE:\n        throw new Error(`${thisFileName}opUDT(${udt.name}): callback function return error. ACTIVE state not allowed.`);\n      case id.EMPTY:\n        if (udt.empty === false) {\n          throw new Error(`${thisFileName}opUDT(${udt.name}): callback function return error. May not return EMPTY.`);\n        } else {\n          sysData.phraseLength = 0;\n        }\n        break;\n      case id.MATCH:\n        if (sysData.phraseLength === 0) {\n          if (udt.empty === false) {\n            throw new Error(`${thisFileName}opUDT(${udt.name}): callback function return error. May not return EMPTY.`);\n          } else {\n            sysData.state = id.EMPTY;\n          }\n        }\n        break;\n      case id.NOMATCH:\n        sysData.phraseLength = 0;\n        break;\n      default:\n        throw new Error(\n          `${thisFileName}opUDT(${udt.name}): callback function return error. Unrecognized return state: ${sysData.state}`\n        );\n    }\n  };\n  // The `UDT` operator.<br>\n  // Simply calls the user's callback function, but operates like `RNM` with regard to the `AST`\n  // and back referencing.\n  // There is some ambiguity here. `UDT`s act as terminals for phrase recognition but as named rules\n  // for `AST` nodes and back referencing.\n  // See [`ast.js`](./ast.html) for usage.\n  const opUDT = function (opIndex, phraseIndex, sysData) {\n    let astLength;\n    let astIndex;\n    let astDefined;\n    let ulen;\n    let plen;\n    let saveFrame;\n    const op = opcodes[opIndex];\n    const udt = udts[op.index];\n    sysData.UdtIndex = udt.index;\n\n    const notLookAround = !inLookAround();\n    /* ignore AST and back references in lookaround */\n    if (notLookAround) {\n      /* begin AST and back reference */\n      astDefined = thisThis.ast && thisThis.ast.udtDefined(op.index);\n      if (astDefined) {\n        astIndex = rules.length + op.index;\n        astLength = thisThis.ast.getLength();\n        thisThis.ast.down(astIndex, udt.name);\n      }\n      /* NOTE: push and pop of the back reference frame is normally not necessary */\n      /* only in the case that the UDT calls evaluateRule() or evaluateUdt() */\n      ulen = sysData.uFrame.length();\n      plen = sysData.pFrame.length();\n      sysData.uFrame.push();\n      sysData.pFrame.push();\n      saveFrame = sysData.pFrame;\n      sysData.pFrame = new backRef();\n    }\n    /* call the UDT */\n    const charsLeft = charsEnd - phraseIndex;\n    udtCallbacks[op.index](sysData, chars, phraseIndex, syntaxData);\n    validateUdtCallbackResult(udt, sysData, charsLeft);\n    if (notLookAround) {\n      /* end AST */\n      if (astDefined) {\n        if (sysData.state === id.NOMATCH) {\n          thisThis.ast.setLength(astLength);\n        } else {\n          thisThis.ast.up(astIndex, udt.name, phraseIndex, sysData.phraseLength);\n        }\n      }\n      /* end back reference */\n      sysData.pFrame = saveFrame;\n      if (sysData.state === id.NOMATCH) {\n        sysData.uFrame.pop(ulen);\n        sysData.pFrame.pop(plen);\n      } else if (udt.isBkr) {\n        /* save phrase on both the parent and universal frames */\n        /* BKR operator will decide which to use later */\n        sysData.pFrame.savePhrase(udt.lower, phraseIndex, sysData.phraseLength);\n        sysData.uFrame.savePhrase(udt.lower, phraseIndex, sysData.phraseLength);\n      }\n    }\n  };\n  // The `AND` operator.<br>\n  // This is the positive `look ahead` operator.\n  // Executes its single child node, returning the EMPTY state\n  // if it succeedsand NOMATCH if it fails.\n  // *Always* backtracks on any matched phrase and returns EMPTY on success.\n  const opAND = function (opIndex, phraseIndex, sysData) {\n    lookAround.push({\n      lookAround: id.LOOKAROUND_AHEAD,\n      anchor: phraseIndex,\n      charsEnd,\n      charsLength,\n    });\n    charsEnd = chars.length;\n    charsLength = chars.length - charsBegin;\n    opExecute(opIndex + 1, phraseIndex, sysData);\n    const pop = lookAround.pop();\n    charsEnd = pop.charsEnd;\n    charsLength = pop.charsLength;\n    sysData.phraseLength = 0;\n    switch (sysData.state) {\n      case id.EMPTY:\n        sysData.state = id.EMPTY;\n        break;\n      case id.MATCH:\n        sysData.state = id.EMPTY;\n        break;\n      case id.NOMATCH:\n        sysData.state = id.NOMATCH;\n        break;\n      default:\n        throw new Error(`opAND: invalid state ${sysData.state}`);\n    }\n  };\n  // The `NOT` operator.<br>\n  // This is the negative `look ahead` operator.\n  // Executes its single child node, returning the EMPTY state\n  // if it *fails* and NOMATCH if it succeeds.\n  // *Always* backtracks on any matched phrase and returns EMPTY\n  // on success (failure of its child node).\n  const opNOT = function (opIndex, phraseIndex, sysData) {\n    lookAround.push({\n      lookAround: id.LOOKAROUND_AHEAD,\n      anchor: phraseIndex,\n      charsEnd,\n      charsLength,\n    });\n    charsEnd = chars.length;\n    charsLength = chars.length - charsBegin;\n    opExecute(opIndex + 1, phraseIndex, sysData);\n    const pop = lookAround.pop();\n    charsEnd = pop.charsEnd;\n    charsLength = pop.charsLength;\n    sysData.phraseLength = 0;\n    switch (sysData.state) {\n      case id.EMPTY:\n      case id.MATCH:\n        sysData.state = id.NOMATCH;\n        break;\n      case id.NOMATCH:\n        sysData.state = id.EMPTY;\n        break;\n      default:\n        throw new Error(`opNOT: invalid state ${sysData.state}`);\n    }\n  };\n  // The `TRG` operator.<br>\n  // Succeeds if the single first character of the phrase is\n  // within the `min - max` range.\n  const opTRG = function (opIndex, phraseIndex, sysData) {\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    if (phraseIndex < charsEnd) {\n      if (op.min <= chars[phraseIndex] && chars[phraseIndex] <= op.max) {\n        sysData.state = id.MATCH;\n        sysData.phraseLength = 1;\n      }\n    }\n  };\n  // The `TBS` operator.<br>\n  // Matches its pre-defined phrase against the input string.\n  // All characters must match exactly.\n  // Case-sensitive literal strings (`'string'` & `%s\"string\"`) are translated to `TBS`\n  // operators by `apg`.\n  // Phrase length of zero is not allowed.\n  // Empty phrases can only be defined with `TLS` operators.\n  const opTBS = function (opIndex, phraseIndex, sysData) {\n    let i;\n    const op = opcodes[opIndex];\n    const len = op.string.length;\n    sysData.state = id.NOMATCH;\n    if (phraseIndex + len <= charsEnd) {\n      for (i = 0; i < len; i += 1) {\n        if (chars[phraseIndex + i] !== op.string[i]) {\n          return;\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    } /* implied else NOMATCH */\n  };\n  // The `TLS` operator.<br>\n  // Matches its pre-defined phrase against the input string.\n  // A case-insensitive match is attempted for ASCII alphbetical characters.\n  // `TLS` is the only operator that explicitly allows empty phrases.\n  // `apg` will fail for empty `TBS`, case-sensitive strings (`''`) or\n  // zero repetitions (`0*0RuleName` or `0RuleName`).\n  const opTLS = function (opIndex, phraseIndex, sysData) {\n    let i;\n    let code;\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    const len = op.string.length;\n    if (len === 0) {\n      /* EMPTY match allowed for TLS */\n      sysData.state = id.EMPTY;\n      return;\n    }\n    if (phraseIndex + len <= charsEnd) {\n      for (i = 0; i < len; i += 1) {\n        code = chars[phraseIndex + i];\n        if (code >= 65 && code <= 90) {\n          code += 32;\n        }\n        if (code !== op.string[i]) {\n          return;\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    } /* implied else NOMATCH */\n  };\n  // The `ABG` operator.<br>\n  // This is an \"anchor\" for the beginning of the string, similar to the familiar regex `^` anchor.\n  // An anchor matches a position rather than a phrase.\n  // Returns EMPTY if `phraseIndex` is 0, NOMATCH otherwise.\n  const opABG = function (opIndex, phraseIndex, sysData) {\n    sysData.state = id.NOMATCH;\n    sysData.phraseLength = 0;\n    sysData.state = phraseIndex === 0 ? id.EMPTY : id.NOMATCH;\n  };\n  // The `AEN` operator.<br>\n  // This is an \"anchor\" for the end of the string, similar to the familiar regex `$` anchor.\n  // An anchor matches a position rather than a phrase.\n  // Returns EMPTY if `phraseIndex` equals the input string length, NOMATCH otherwise.\n  const opAEN = function (opIndex, phraseIndex, sysData) {\n    sysData.state = id.NOMATCH;\n    sysData.phraseLength = 0;\n    sysData.state = phraseIndex === chars.length ? id.EMPTY : id.NOMATCH;\n  };\n  // The `BKR` operator.<br>\n  // The back reference operator.\n  // Matches the last matched phrase of the named rule or UDT against the input string.\n  // For ASCII alphbetical characters the match may be case sensitive (`%s`) or insensitive (`%i`),\n  // depending on the back reference definition.\n  // For `universal` mode (`%u`) matches the last phrase found anywhere in the grammar.\n  // For `parent frame` mode (`%p`) matches the last phrase found in the parent rule only.\n  const opBKR = function (opIndex, phraseIndex, sysData) {\n    let i;\n    let code;\n    let lmcode;\n    let lower;\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    if (op.index < rules.length) {\n      lower = rules[op.index].lower;\n    } else {\n      lower = udts[op.index - rules.length].lower;\n    }\n    const frame = op.bkrMode === id.BKR_MODE_PM ? sysData.pFrame.getPhrase(lower) : sysData.uFrame.getPhrase(lower);\n    const insensitive = op.bkrCase === id.BKR_MODE_CI;\n    if (frame === null) {\n      return;\n    }\n    const lmIndex = frame.phraseIndex;\n    const len = frame.phraseLength;\n    if (len === 0) {\n      sysData.state = id.EMPTY;\n      return;\n    }\n    if (phraseIndex + len <= charsEnd) {\n      if (insensitive) {\n        /* case-insensitive match */\n        for (i = 0; i < len; i += 1) {\n          code = chars[phraseIndex + i];\n          lmcode = chars[lmIndex + i];\n          if (code >= 65 && code <= 90) {\n            code += 32;\n          }\n          if (lmcode >= 65 && lmcode <= 90) {\n            lmcode += 32;\n          }\n          if (code !== lmcode) {\n            return;\n          }\n        }\n        sysData.state = id.MATCH;\n        sysData.phraseLength = len;\n      } else {\n        /* case-sensitive match */\n        for (i = 0; i < len; i += 1) {\n          code = chars[phraseIndex + i];\n          lmcode = chars[lmIndex + i];\n          if (code !== lmcode) {\n            return;\n          }\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    }\n  };\n  // The `BKA` operator.<br>\n  // This is the positive `look behind` operator.\n  // It's child node is parsed right-to-left.\n  // Returns the EMPTY state if a match is found, NOMATCH otherwise.\n  // Like the look ahead operators, it always backtracks to `phraseIndex`.\n  const opBKA = function (opIndex, phraseIndex, sysData) {\n    lookAround.push({\n      lookAround: id.LOOKAROUND_BEHIND,\n      anchor: phraseIndex,\n    });\n    opExecute(opIndex + 1, phraseIndex, sysData);\n    lookAround.pop();\n    sysData.phraseLength = 0;\n    switch (sysData.state) {\n      case id.EMPTY:\n        sysData.state = id.EMPTY;\n        break;\n      case id.MATCH:\n        sysData.state = id.EMPTY;\n        break;\n      case id.NOMATCH:\n        sysData.state = id.NOMATCH;\n        break;\n      default:\n        throw new Error(`opBKA: invalid state ${sysData.state}`);\n    }\n  };\n  // The `BKN` operator.<br>\n  // This is the negative `look behind` operator.\n  // It's child node is parsed right-to-left.\n  // Returns the EMPTY state if a match is *not* found, NOMATCH otherwise.\n  // Like the look ahead operators, it always backtracks to `phraseIndex`.\n  const opBKN = function (opIndex, phraseIndex, sysData) {\n    // let op;\n    // op = opcodes[opIndex];\n    lookAround.push({\n      lookAround: id.LOOKAROUND_BEHIND,\n      anchor: phraseIndex,\n    });\n    opExecute(opIndex + 1, phraseIndex, sysData);\n    lookAround.pop();\n    sysData.phraseLength = 0;\n    switch (sysData.state) {\n      case id.EMPTY:\n      case id.MATCH:\n        sysData.state = id.NOMATCH;\n        break;\n      case id.NOMATCH:\n        sysData.state = id.EMPTY;\n        break;\n      default:\n        throw new Error(`opBKN: invalid state ${sysData.state}`);\n    }\n  };\n  // The right-to-left `CAT` operator.<br>\n  // Called for `CAT` operators when in look behind mode.\n  // Calls its child nodes from right to left concatenating matched phrases right to left.\n  const opCATBehind = function (opIndex, phraseIndex, sysData) {\n    let success;\n    let astLength;\n    let catCharIndex;\n    let catMatched;\n    const op = opcodes[opIndex];\n    const ulen = sysData.uFrame.length();\n    const plen = sysData.pFrame.length();\n    if (thisThis.ast) {\n      astLength = thisThis.ast.getLength();\n    }\n    success = true;\n    catCharIndex = phraseIndex;\n    catMatched = 0;\n    // catPhrase = 0;\n    for (let i = op.children.length - 1; i >= 0; i -= 1) {\n      opExecute(op.children[i], catCharIndex, sysData);\n      catCharIndex -= sysData.phraseLength;\n      catMatched += sysData.phraseLength;\n      // catPhrase += sysData.phraseLength;\n      if (sysData.state === id.NOMATCH) {\n        success = false;\n        break;\n      }\n    }\n    if (success) {\n      sysData.state = catMatched === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = catMatched;\n    } else {\n      sysData.state = id.NOMATCH;\n      sysData.phraseLength = 0;\n      sysData.uFrame.pop(ulen);\n      sysData.pFrame.pop(plen);\n      if (thisThis.ast) {\n        thisThis.ast.setLength(astLength);\n      }\n    }\n  };\n  // The right-to-left `REP` operator.<br>\n  // Called for `REP` operators in look behind mode.\n  // Makes repeated calls to its child node, concatenating matched phrases right to left.\n  const opREPBehind = function (opIndex, phraseIndex, sysData) {\n    let astLength;\n    let repCharIndex;\n    let repPhrase;\n    let repCount;\n    const op = opcodes[opIndex];\n    repCharIndex = phraseIndex;\n    repPhrase = 0;\n    repCount = 0;\n    const ulen = sysData.uFrame.length();\n    const plen = sysData.pFrame.length();\n    if (thisThis.ast) {\n      astLength = thisThis.ast.getLength();\n    }\n    const TRUE = true;\n    while (TRUE) {\n      if (repCharIndex <= 0) {\n        /* exit on end of input string */\n        break;\n      }\n      opExecute(opIndex + 1, repCharIndex, sysData);\n      if (sysData.state === id.NOMATCH) {\n        /* always end if the child node fails */\n        break;\n      }\n      if (sysData.state === id.EMPTY) {\n        /* REP always succeeds when the child node returns an empty phrase */\n        /* this may not seem obvious, but that's the way it works out */\n        break;\n      }\n      repCount += 1;\n      repPhrase += sysData.phraseLength;\n      repCharIndex -= sysData.phraseLength;\n      if (repCount === op.max) {\n        /* end on maxed out reps */\n        break;\n      }\n    }\n    /* evaluate the match count according to the min, max values */\n    if (sysData.state === id.EMPTY) {\n      sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = repPhrase;\n    } else if (repCount >= op.min) {\n      sysData.state = repPhrase === 0 ? id.EMPTY : id.MATCH;\n      sysData.phraseLength = repPhrase;\n    } else {\n      sysData.state = id.NOMATCH;\n      sysData.phraseLength = 0;\n      sysData.uFrame.pop(ulen);\n      sysData.pFrame.pop(plen);\n      if (thisThis.ast) {\n        thisThis.ast.setLength(astLength);\n      }\n    }\n  };\n  // The right-to-left `TRG` operator.<br>\n  // Called for `TRG` operators in look behind mode.\n  // Matches a single character at `phraseIndex - 1` to the `min` - `max` range.\n  const opTRGBehind = function (opIndex, phraseIndex, sysData) {\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    sysData.phraseLength = 0;\n    if (phraseIndex > 0) {\n      const char = chars[phraseIndex - 1];\n      if (op.min <= char && char <= op.max) {\n        sysData.state = id.MATCH;\n        sysData.phraseLength = 1;\n      }\n    }\n  };\n  // The right-to-left `TBS` operator.<br>\n  // Called for `TBS` operators in look behind mode.\n  // Matches the `TBS` phrase to the left of `phraseIndex`.\n  const opTBSBehind = function (opIndex, phraseIndex, sysData) {\n    let i;\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    const len = op.string.length;\n    const beg = phraseIndex - len;\n    if (beg >= 0) {\n      for (i = 0; i < len; i += 1) {\n        if (chars[beg + i] !== op.string[i]) {\n          return;\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    }\n  };\n  // The right-to-left `TLS` operator.<br>\n  // Called for `TLS` operators in look behind mode.\n  // Matches the `TLS` phrase to the left of `phraseIndex`.\n  const opTLSBehind = function (opIndex, phraseIndex, sysData) {\n    let char;\n    const op = opcodes[opIndex];\n    sysData.state = id.NOMATCH;\n    const len = op.string.length;\n    if (len === 0) {\n      /* EMPTY match allowed for TLS */\n      sysData.state = id.EMPTY;\n      return;\n    }\n    const beg = phraseIndex - len;\n    if (beg >= 0) {\n      for (let i = 0; i < len; i += 1) {\n        char = chars[beg + i];\n        if (char >= 65 && char <= 90) {\n          char += 32;\n        }\n        if (char !== op.string[i]) {\n          return;\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    }\n  };\n  // The right-to-left back reference operator.<br>\n  // Matches the back referenced phrase to the left of `phraseIndex`.\n  const opBKRBehind = function (opIndex, phraseIndex, sysData) {\n    let i;\n    let code;\n    let lmcode;\n    let lower;\n    const op = opcodes[opIndex];\n    /* NOMATCH default */\n    sysData.state = id.NOMATCH;\n    sysData.phraseLength = 0;\n    if (op.index < rules.length) {\n      lower = rules[op.index].lower;\n    } else {\n      lower = udts[op.index - rules.length].lower;\n    }\n    const frame = op.bkrMode === id.BKR_MODE_PM ? sysData.pFrame.getPhrase(lower) : sysData.uFrame.getPhrase(lower);\n    const insensitive = op.bkrCase === id.BKR_MODE_CI;\n    if (frame === null) {\n      return;\n    }\n    const lmIndex = frame.phraseIndex;\n    const len = frame.phraseLength;\n    if (len === 0) {\n      sysData.state = id.EMPTY;\n      sysData.phraseLength = 0;\n      return;\n    }\n    const beg = phraseIndex - len;\n    if (beg >= 0) {\n      if (insensitive) {\n        /* case-insensitive match */\n        for (i = 0; i < len; i += 1) {\n          code = chars[beg + i];\n          lmcode = chars[lmIndex + i];\n          if (code >= 65 && code <= 90) {\n            code += 32;\n          }\n          if (lmcode >= 65 && lmcode <= 90) {\n            lmcode += 32;\n          }\n          if (code !== lmcode) {\n            return;\n          }\n        }\n        sysData.state = id.MATCH;\n        sysData.phraseLength = len;\n      } else {\n        /* case-sensitive match */\n        for (i = 0; i < len; i += 1) {\n          code = chars[beg + i];\n          lmcode = chars[lmIndex + i];\n          if (code !== lmcode) {\n            return;\n          }\n        }\n      }\n      sysData.state = id.MATCH;\n      sysData.phraseLength = len;\n    }\n  };\n  // Generalized execution function.<br>\n  // Having a single, generalized function, allows a single location\n  // for tracing and statistics gathering functions to be called.\n  // Tracing and statistics are handled in separate objects.\n  // However, the parser calls their API to build the object data records.\n  // See [`trace.js`](./trace.html) and [`stats.js`](./stats.html) for their\n  // usage.\n  opExecute = function opExecuteFunc(opIndex, phraseIndex, sysData) {\n    let ret = true;\n    const op = opcodes[opIndex];\n    nodeHits += 1;\n    if (nodeHits > limitNodeHits) {\n      throw new Error(`parser: maximum number of node hits exceeded: ${limitNodeHits}`);\n    }\n    treeDepth += 1;\n    if (treeDepth > maxTreeDepth) {\n      maxTreeDepth = treeDepth;\n      if (maxTreeDepth > limitTreeDepth) {\n        throw new Error(`parser: maximum parse tree depth exceeded: ${limitTreeDepth}`);\n      }\n    }\n    sysData.refresh();\n    if (thisThis.trace !== null) {\n      /* collect the trace record for down the parse tree */\n      const lk = lookAroundValue();\n      thisThis.trace.down(op, sysData.state, phraseIndex, sysData.phraseLength, lk.anchor, lk.lookAround);\n    }\n    if (inLookBehind()) {\n      switch (op.type) {\n        case id.ALT:\n          opALT(opIndex, phraseIndex, sysData);\n          break;\n        case id.CAT:\n          opCATBehind(opIndex, phraseIndex, sysData);\n          break;\n        case id.REP:\n          opREPBehind(opIndex, phraseIndex, sysData);\n          break;\n        case id.RNM:\n          opRNM(opIndex, phraseIndex, sysData);\n          break;\n        case id.UDT:\n          opUDT(opIndex, phraseIndex, sysData);\n          break;\n        case id.AND:\n          opAND(opIndex, phraseIndex, sysData);\n          break;\n        case id.NOT:\n          opNOT(opIndex, phraseIndex, sysData);\n          break;\n        case id.TRG:\n          opTRGBehind(opIndex, phraseIndex, sysData);\n          break;\n        case id.TBS:\n          opTBSBehind(opIndex, phraseIndex, sysData);\n          break;\n        case id.TLS:\n          opTLSBehind(opIndex, phraseIndex, sysData);\n          break;\n        case id.BKR:\n          opBKRBehind(opIndex, phraseIndex, sysData);\n          break;\n        case id.BKA:\n          opBKA(opIndex, phraseIndex, sysData);\n          break;\n        case id.BKN:\n          opBKN(opIndex, phraseIndex, sysData);\n          break;\n        case id.ABG:\n          opABG(opIndex, phraseIndex, sysData);\n          break;\n        case id.AEN:\n          opAEN(opIndex, phraseIndex, sysData);\n          break;\n        default:\n          ret = false;\n          break;\n      }\n    } else {\n      switch (op.type) {\n        case id.ALT:\n          opALT(opIndex, phraseIndex, sysData);\n          break;\n        case id.CAT:\n          opCAT(opIndex, phraseIndex, sysData);\n          break;\n        case id.REP:\n          opREP(opIndex, phraseIndex, sysData);\n          break;\n        case id.RNM:\n          opRNM(opIndex, phraseIndex, sysData);\n          break;\n        case id.UDT:\n          opUDT(opIndex, phraseIndex, sysData);\n          break;\n        case id.AND:\n          opAND(opIndex, phraseIndex, sysData);\n          break;\n        case id.NOT:\n          opNOT(opIndex, phraseIndex, sysData);\n          break;\n        case id.TRG:\n          opTRG(opIndex, phraseIndex, sysData);\n          break;\n        case id.TBS:\n          opTBS(opIndex, phraseIndex, sysData);\n          break;\n        case id.TLS:\n          opTLS(opIndex, phraseIndex, sysData);\n          break;\n        case id.BKR:\n          opBKR(opIndex, phraseIndex, sysData);\n          break;\n        case id.BKA:\n          opBKA(opIndex, phraseIndex, sysData);\n          break;\n        case id.BKN:\n          opBKN(opIndex, phraseIndex, sysData);\n          break;\n        case id.ABG:\n          opABG(opIndex, phraseIndex, sysData);\n          break;\n        case id.AEN:\n          opAEN(opIndex, phraseIndex, sysData);\n          break;\n        default:\n          ret = false;\n          break;\n      }\n    }\n    if (!inLookAround() && phraseIndex + sysData.phraseLength > maxMatched) {\n      maxMatched = phraseIndex + sysData.phraseLength;\n    }\n    if (thisThis.stats !== null) {\n      /* collect the statistics */\n      thisThis.stats.collect(op, sysData);\n    }\n    if (thisThis.trace !== null) {\n      /* collect the trace record for up the parse tree */\n      const lk = lookAroundValue();\n      thisThis.trace.up(op, sysData.state, phraseIndex, sysData.phraseLength, lk.anchor, lk.lookAround);\n    }\n    treeDepth -= 1;\n    return ret;\n  };\n};\n"],"names":[],"mappings":"AAAA,6BAA6B,GAC7B,uCAAuC,GACvC,0BAA0B,GAC1B,+BAA+B,GAC/B;;;uFAGuF,GACvF,iFAAiF;AACjF,sFAAsF;AACtF,mFAAmF;AACnF,OAAO,OAAO,GAAG,SAAS;IACxB,MAAM;IACN,MAAM;IAEN,MAAM,eAAe;IACrB,MAAM,WAAW,IAAI;IACrB,IAAI;IACJ,IAAI,CAAC,GAAG,GAAG;IACX,IAAI,CAAC,KAAK,GAAG;IACb,IAAI,CAAC,KAAK,GAAG;IACb,IAAI,CAAC,SAAS,GAAG,EAAE;IACnB,IAAI,UAAU;IACd,IAAI,QAAQ;IACZ,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,IAAI,YAAY;IAChB,IAAI,eAAe;IACnB,IAAI,WAAW;IACf,IAAI,gBAAgB;IACpB,IAAI,eAAe;IACnB,IAAI,QAAQ;IACZ,IAAI,OAAO;IACX,IAAI,aAAa;IACjB,IAAI,aAAa;IACjB,IAAI,iBAAiB;IACrB,IAAI,gBAAgB;IACpB,wEAAwE;IACxE,2EAA2E;IAC3E,wEAAwE;IACxE,kBAAkB;IAClB,MAAM,eAAe,SAAS,aAAa,SAAS,EAAE,WAAW,EAAE,OAAO;QACxE,MAAM,eAAe,GAAG,aAAa,gBAAgB,CAAC;QACtD,IAAI,aAAa,MAAM,MAAM,EAAE;YAC7B,MAAM,IAAI,MAAM,GAAG,aAAa,YAAY,EAAE,UAAU,aAAa,CAAC;QACxE;QACA,IAAI,eAAe,UAAU;YAC3B,MAAM,IAAI,MAAM,GAAG,aAAa,cAAc,EAAE,YAAY,aAAa,CAAC;QAC5E;QACA,MAAM,EAAE,MAAM,EAAE,GAAG;QACnB,QAAQ,IAAI,CAAC;YACX,MAAM,GAAG,GAAG;YACZ,OAAO;QACT;QACA,UAAU,QAAQ,aAAa;QAC/B,QAAQ,GAAG;IACb;IACA,uEAAuE;IACvE,yEAAyE;IACzE,wEAAwE;IACxE,kBAAkB;IAClB,MAAM,cAAc,SAAU,QAAQ,EAAE,WAAW,EAAE,OAAO;QAC1D,MAAM,eAAe,GAAG,aAAa,eAAe,CAAC;QACrD,IAAI,YAAY,KAAK,MAAM,EAAE;YAC3B,MAAM,IAAI,MAAM,GAAG,aAAa,WAAW,EAAE,SAAS,aAAa,CAAC;QACtE;QACA,IAAI,eAAe,UAAU;YAC3B,MAAM,IAAI,MAAM,GAAG,aAAa,cAAc,EAAE,YAAY,aAAa,CAAC;QAC5E;QACA,MAAM,EAAE,MAAM,EAAE,GAAG;QACnB,QAAQ,IAAI,CAAC;YACX,MAAM,GAAG,GAAG;YACZ,OAAO,IAAI,CAAC,SAAS,CAAC,KAAK;YAC3B,OAAO;QACT;QACA,UAAU,QAAQ,aAAa;QAC/B,QAAQ,GAAG;IACb;IACA,gFAAgF,GAChF,uGAAuG,GACvG,MAAM,QAAQ;QACZ,YAAY;QACZ,eAAe;QACf,WAAW;QACX,aAAa;QACb,aAAa;YACX;gBACE,YAAY,GAAG,eAAe;gBAC9B,QAAQ;gBACR,UAAU;gBACV,aAAa;YACf;SACD;QACD,QAAQ;QACR,OAAO;QACP,QAAQ;QACR,aAAa;QACb,cAAc;QACd,WAAW;QACX,gBAAgB;QAChB,eAAe;QACf,aAAa;QACb,UAAU;IACZ;IACA,2DAA2D,GAC3D,MAAM,UAAU;QACd,MAAM,QAAQ,EAAE;QAChB,MAAM,OAAO;YACX,MAAM,MAAM,CAAC;YACb,MAAM,OAAO,CAAC,CAAC;gBACb,IAAI,KAAK,KAAK,EAAE;oBACd,GAAG,CAAC,KAAK,KAAK,CAAC,GAAG;gBACpB;YACF;YACA,IAAI,KAAK,MAAM,GAAG,GAAG;gBACnB,KAAK,OAAO,CAAC,CAAC;oBACZ,IAAI,IAAI,KAAK,EAAE;wBACb,GAAG,CAAC,IAAI,KAAK,CAAC,GAAG;oBACnB;gBACF;YACF;YACA,MAAM,IAAI,CAAC;QACb;QACA,MAAM,OAAO;YACX,MAAM,MAAM,KAAK,CAAC,MAAM,MAAM,GAAG,EAAE;YACnC,MAAM,MAAM,CAAC;YACb,oDAAoD,GACpD,IAAK,MAAM,QAAQ,IAAK;gBACtB,GAAG,CAAC,KAAK,GAAG,GAAG,CAAC,KAAK;YACvB;YACA,OAAO;QACT;QACA,IAAI,CAAC,IAAI,GAAG,SAAS;YACnB,MAAM,IAAI,CAAC;QACb;QACA,IAAI,CAAC,GAAG,GAAG,SAAS,IAAI,SAAS;YAC/B,IAAI,SAAS;YACb,IAAI,CAAC,QAAQ;gBACX,SAAS,MAAM,MAAM,GAAG;YAC1B;YACA,IAAI,SAAS,KAAK,SAAS,MAAM,MAAM,EAAE;gBACvC,MAAM,IAAI,MAAM,GAAG,aAAa,2BAA2B,EAAE,QAAQ;YACvE;YACA,MAAM,MAAM,GAAG;YACf,OAAO,KAAK,CAAC,MAAM,MAAM,GAAG,EAAE;QAChC;QACA,IAAI,CAAC,MAAM,GAAG,SAAS;YACrB,OAAO,MAAM,MAAM;QACrB;QACA,IAAI,CAAC,UAAU,GAAG,SAAS,WAAW,IAAI,EAAE,KAAK,EAAE,MAAM;YACvD,KAAK,CAAC,MAAM,MAAM,GAAG,EAAE,CAAC,KAAK,GAAG;gBAC9B,aAAa;gBACb,cAAc;YAChB;QACF;QACA,IAAI,CAAC,SAAS,GAAG,SAAU,IAAI;YAC7B,OAAO,KAAK,CAAC,MAAM,MAAM,GAAG,EAAE,CAAC,KAAK;QACtC;QACA,eAAe,GACf;IACF;IACA,4GAA4G;IAC5G,wGAAwG;IACxG,wDAAwD;IACxD,uFAAuF;IACvF,6EAA6E;IAC7E,0DAA0D;IAC1D,qDAAqD;IACrD,gFAAgF;IAChF,4DAA4D;IAC5D,yFAAyF;IACzF,6EAA6E;IAC7E,qEAAqE;IACrE,2EAA2E;IAC3E,qEAAqE;IACrE,MAAM,aAAa,SAAS;QAC1B,MAAM,WAAW,IAAI;QACrB,IAAI,CAAC,KAAK,GAAG,GAAG,MAAM;QACtB,IAAI,CAAC,YAAY,GAAG;QACpB,IAAI,CAAC,SAAS,GAAG;QACjB,IAAI,CAAC,QAAQ,GAAG;QAChB,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC,WAAW,MAAM,GAAG,EAAE;QACnD,IAAI,CAAC,MAAM,GAAG,IAAI;QAClB,IAAI,CAAC,MAAM,GAAG,IAAI;QAClB,IAAI,CAAC,YAAY,GAAG;QACpB,IAAI,CAAC,WAAW,GAAG;QACnB,mDAAmD,GACnD,IAAI,CAAC,OAAO,GAAG,SAAS;YACtB,SAAS,KAAK,GAAG,GAAG,MAAM;YAC1B,SAAS,YAAY,GAAG;YACxB,SAAS,UAAU,GAAG,UAAU,CAAC,WAAW,MAAM,GAAG,EAAE;QACzD;IACF;IACA,qCAAqC,GACrC,MAAM,kBAAkB,SAAS;QAC/B,OAAO,UAAU,CAAC,WAAW,MAAM,GAAG,EAAE;IAC1C;IACA,mEAAmE,GACnE,MAAM,eAAe,SAAS;QAC5B,OAAO,WAAW,MAAM,GAAG;IAC7B;IACA,iDAAiD,GACjD,MAAM,eAAe;QACnB,OAAO,UAAU,CAAC,WAAW,MAAM,GAAG,EAAE,CAAC,UAAU,KAAK,GAAG,iBAAiB;IAC9E;IACA,2EAA2E,GAC3E,MAAM,gBAAgB;QACpB,MAAM,eAAe,GAAG,aAAa,iBAAiB,CAAC;QACvD,MAAM,OAAO;QACb,MAAO,KAAM;YACX,IAAI,SAAS,GAAG,KAAK,WAAW;gBAC9B,SAAS,GAAG,GAAG;gBACf;YACF;YACA,IAAI,SAAS,GAAG,KAAK,MAAM;gBACzB;YACF;YACA,IAAI,SAAS,GAAG,CAAC,SAAS,KAAK,aAAa;gBAC1C,MAAM,IAAI,MAAM,GAAG,aAAa,yBAAyB,CAAC;YAC5D;YACA;QACF;QACA,IAAI,SAAS,GAAG,KAAK,MAAM;YACzB,SAAS,GAAG,CAAC,IAAI,CAAC,OAAO,MAAM;QACjC;IACF;IACA,6EAA6E,GAC7E,MAAM,kBAAkB;QACtB,MAAM,eAAe,GAAG,aAAa,mBAAmB,CAAC;QACzD,MAAM,OAAO;QACb,MAAO,KAAM;YACX,IAAI,SAAS,KAAK,KAAK,WAAW;gBAChC,SAAS,KAAK,GAAG;gBACjB;YACF;YACA,IAAI,SAAS,KAAK,KAAK,MAAM;gBAC3B;YACF;YACA,IAAI,SAAS,KAAK,CAAC,WAAW,KAAK,eAAe;gBAChD,MAAM,IAAI,MAAM,GAAG,aAAa,2BAA2B,CAAC;YAC9D;YACA;QACF;QACA,IAAI,SAAS,KAAK,KAAK,MAAM;YAC3B,SAAS,KAAK,CAAC,IAAI,CAAC,OAAO,MAAM;QACnC;IACF;IACA,kFAAkF,GAClF,MAAM,kBAAkB;QACtB,MAAM,eAAe,GAAG,aAAa,mBAAmB,CAAC;QACzD,MAAM,OAAO;QACb,MAAO,KAAM;YACX,IAAI,SAAS,KAAK,KAAK,WAAW;gBAChC,SAAS,KAAK,GAAG;gBACjB;YACF;YACA,IAAI,SAAS,KAAK,KAAK,MAAM;gBAC3B;YACF;YACA,IAAI,SAAS,KAAK,CAAC,WAAW,KAAK,eAAe;gBAChD,MAAM,IAAI,MAAM,GAAG,aAAa,2BAA2B,CAAC;YAC9D;YACA;QACF;QACA,IAAI,SAAS,KAAK,KAAK,MAAM;YAC3B,SAAS,KAAK,CAAC,IAAI,CAAC,OAAO;QAC7B;IACF;IACA,4EAA4E,GAC5E,oDAAoD,GACpD,MAAM,oBAAoB,SAAU,OAAO;QACzC,MAAM,eAAe,GAAG,aAAa,qBAAqB,CAAC;QAC3D,IAAI,CAAC,SAAS;YACZ,MAAM,IAAI,MAAM,GAAG,aAAa,wBAAwB,CAAC;QAC3D;QACA,IAAI,QAAQ,aAAa,KAAK,iBAAiB;YAC7C,MAAM,IAAI,MAAM,GAAG,aAAa,kBAAkB,CAAC;QACrD;QACA,QAAQ,QAAQ,KAAK;QACrB,OAAO,QAAQ,IAAI;IACrB;IACA,kDAAkD,GAClD,MAAM,sBAAsB,SAAU,SAAS;QAC7C,MAAM,eAAe,GAAG,aAAa,uBAAuB,CAAC;QAC7D,IAAI,QAAQ;QACZ,IAAI,OAAO,cAAc,UAAU;YACjC,IAAI,aAAa,MAAM,MAAM,EAAE;gBAC7B,MAAM,IAAI,MAAM,GAAG,aAAa,iCAAiC,EAAE,MAAM,MAAM,CAAC,SAAS,EAAE,WAAW;YACxG;YACA,QAAQ;QACV,OAAO,IAAI,OAAO,cAAc,UAAU;YACxC,MAAM,QAAQ,UAAU,WAAW;YACnC,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,KAAK,EAAG;gBACxC,IAAI,UAAU,KAAK,CAAC,EAAE,CAAC,KAAK,EAAE;oBAC5B,QAAQ,KAAK,CAAC,EAAE,CAAC,KAAK;oBACtB;gBACF;YACF;YACA,IAAI,UAAU,MAAM;gBAClB,MAAM,IAAI,MAAM,GAAG,aAAa,iBAAiB,EAAE,UAAU,gBAAgB,CAAC;YAChF;QACF,OAAO;YACL,MAAM,IAAI,MAAM,GAAG,aAAa,oBAAoB,EAAE,OAAO,UAAU,gBAAgB,CAAC;QAC1F;QACA,OAAO;IACT;IACA,+FAA+F,GAC/F,MAAM,uBAAuB,SAAS,qBAAqB,QAAQ,EAAE,MAAM,EAAE,MAAM;QACjF,MAAM,eAAe,GAAG,aAAa,wBAAwB,CAAC;QAC9D,8BAA8B,GAC9B,IAAI,QAAQ;QACZ,IAAI,MAAM;QACV,IAAI,MAAM;QACV,IAAI,UAAU,WAAW;YACvB,MAAM,IAAI,MAAM,GAAG,aAAa,yBAAyB,CAAC;QAC5D;QACA,IAAI,UAAU,MAAM;YAClB,MAAM,IAAI,MAAM,GAAG,aAAa,oBAAoB,CAAC;QACvD;QACA,IAAI,OAAO,UAAU,UAAU;YAC7B,QAAQ,MAAM,aAAa,CAAC;QAC9B,OAAO,IAAI,CAAC,MAAM,OAAO,CAAC,QAAQ;YAChC,MAAM,IAAI,MAAM,GAAG,aAAa,qCAAqC,CAAC;QACxE;QACA,IAAI,MAAM,MAAM,GAAG,GAAG;YACpB,IAAI,OAAO,KAAK,CAAC,EAAE,KAAK,UAAU;gBAChC,MAAM,IAAI,MAAM,GAAG,aAAa,qCAAqC,CAAC;YACxE;QACF;QACA,wCAAwC,GACxC,IAAI,OAAO,QAAQ,UAAU;YAC3B,MAAM;QACR,OAAO;YACL,MAAM,KAAK,KAAK,CAAC;YACjB,IAAI,MAAM,KAAK,MAAM,MAAM,MAAM,EAAE;gBACjC,MAAM,IAAI,MAAM,GAAG,aAAa,oCAAoC,EAAE,KAAK;YAC7E;QACF;QACA,qCAAqC,GACrC,IAAI,OAAO,QAAQ,UAAU;YAC3B,MAAM,MAAM,MAAM,GAAG;QACvB,OAAO;YACL,MAAM,KAAK,KAAK,CAAC;YACjB,IAAI,MAAM,KAAK,MAAM,MAAM,MAAM,GAAG,KAAK;gBACvC,MAAM,IAAI,MAAM,GAAG,aAAa,2BAA2B,EAAE,KAAK;YACpE;QACF;QACA,QAAQ;QACR,aAAa;QACb,cAAc;QACd,WAAW,aAAa;IAC1B;IACA,uFAAuF,GACvF,MAAM,sBAAsB;QAC1B,MAAM,eAAe,GAAG,aAAa,uBAAuB,CAAC;QAC7D,IAAI;QACJ,gBAAgB,EAAE;QAClB,eAAe,EAAE;QACjB,IAAK,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,KAAK,EAAG;YACpC,aAAa,CAAC,EAAE,GAAG;QACrB;QACA,IAAK,IAAI,GAAG,IAAI,KAAK,MAAM,EAAE,KAAK,EAAG;YACnC,YAAY,CAAC,EAAE,GAAG;QACpB;QACA,IAAI;QACJ,MAAM,OAAO,EAAE;QACf,IAAK,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,KAAK,EAAG;YACpC,KAAK,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK;QAC1B;QACA,IAAK,IAAI,GAAG,IAAI,KAAK,MAAM,EAAE,KAAK,EAAG;YACnC,KAAK,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK;QACzB;QACA,IAAK,MAAM,SAAS,SAAS,SAAS,CAAE;YACtC,IAAI,KAAK,OAAO,CAAC,MAAM,WAAW;YAClC,IAAI,IAAI,GAAG;gBACT,MAAM,IAAI,MAAM,GAAG,aAAa,iBAAiB,EAAE,MAAM,wBAAwB,CAAC;YACpF;YACA,OAAO,SAAS,SAAS,CAAC,MAAM;YAChC,IAAI,CAAC,MAAM;gBACT,OAAO;YACT;YACA,IAAI,OAAO,SAAS,cAAc,SAAS,MAAM;gBAC/C,IAAI,IAAI,MAAM,MAAM,EAAE;oBACpB,aAAa,CAAC,EAAE,GAAG;gBACrB,OAAO;oBACL,YAAY,CAAC,IAAI,MAAM,MAAM,CAAC,GAAG;gBACnC;YACF,OAAO;gBACL,MAAM,IAAI,MACR,GAAG,aAAa,gBAAgB,EAAE,MAAM,mEAAmE,CAAC;YAEhH;QACF;QACA,6EAA6E,GAC7E,IAAK,IAAI,GAAG,IAAI,KAAK,MAAM,EAAE,KAAK,EAAG;YACnC,IAAI,YAAY,CAAC,EAAE,KAAK,MAAM;gBAC5B,MAAM,IAAI,MACR,GAAG,aAAa,gDAAgD,EAAE,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC,0BAA0B,CAAC;YAE/G;QACF;IACF;IACA,uEAAuE;IACvE,wEAAwE;IACxE,0DAA0D;IAC1D,OAAO;IACP,OAAO;IACP,4EAA4E;IAC5E,QAAQ;IACR,QAAQ;IACR,IAAI,CAAC,eAAe,GAAG,SAAU,KAAK;QACpC,IAAI,OAAO,UAAU,UAAU;YAC7B,MAAM,IAAI,MAAM,CAAC,4CAA4C,EAAE,OAAO;QACxE;QACA,iBAAiB,KAAK,KAAK,CAAC;QAC5B,IAAI,kBAAkB,GAAG;YACvB,MAAM,IAAI,MAAM,CAAC,4CAA4C,EAAE,OAAO;QACxE;IACF;IACA,4FAA4F;IAC5F,6BAA6B;IAC7B,wEAAwE;IACxE,0DAA0D;IAC1D,OAAO;IACP,OAAO;IACP,mEAAmE;IACnE,mCAAmC;IACnC,QAAQ;IACR,QAAQ;IACR,IAAI,CAAC,cAAc,GAAG,SAAU,IAAI;QAClC,IAAI,OAAO,SAAS,UAAU;YAC5B,MAAM,IAAI,MAAM,CAAC,2CAA2C,EAAE,MAAM;QACtE;QACA,gBAAgB,KAAK,KAAK,CAAC;QAC3B,IAAI,iBAAiB,GAAG;YACtB,MAAM,IAAI,MAAM,CAAC,2CAA2C,EAAE,MAAM;QACtE;IACF;IACA,4BAA4B,GAC5B,MAAM,eAAe,SAAU,OAAO,EAAE,YAAY,EAAE,YAAY;QAChE,IAAI;QACJ,MAAM,eAAe,GAAG,aAAa,SAAS,CAAC;QAC/C,kBAAkB;QAClB,MAAM,YAAY,oBAAoB;QACtC;QACA;QACA;QACA;QACA,MAAM,UAAU,IAAI;QACpB,IAAI,CAAC,CAAC,iBAAiB,aAAa,iBAAiB,IAAI,GAAG;YAC1D,aAAa;QACf;QACA,4CAA4C,GAC5C,UAAU;YACR;gBACE,MAAM,GAAG,GAAG;gBACZ,OAAO;YACT;SACD;QACD,0BAA0B,GAC1B,UAAU,GAAG,YAAY;QACzB,UAAU;QACV,+BAA+B,GAC/B,OAAQ,QAAQ,KAAK;YACnB,KAAK,GAAG,MAAM;gBACZ,MAAM,IAAI,MAAM,GAAG,aAAa,oCAAoC,CAAC;YACvE,KAAK,GAAG,OAAO;gBACb,UAAU;gBACV;YACF,KAAK,GAAG,KAAK;YACb,KAAK,GAAG,KAAK;gBACX,IAAI,QAAQ,YAAY,KAAK,aAAa;oBACxC,UAAU;gBACZ,OAAO;oBACL,UAAU;gBACZ;gBACA;YACF;gBACE,MAAM,IAAI,MAAM;QACpB;QACA,OAAO;YACL;YACA,OAAO,QAAQ,KAAK;YACpB,QAAQ;YACR,SAAS,QAAQ,YAAY;YAC7B;YACA;YACA;YACA,aAAa,MAAM,MAAM;YACzB,UAAU;YACV,QAAQ;YACR,WAAW;QACb;IACF;IAEA,qEAAqE;IACrE,OAAO;IACP,yEAAyE;IACzE,oDAAoD;IACpD,QAAQ;IACR,4DAA4D;IAC5D,IAAI,CAAC,cAAc,GAAG,SAAS,eAAe,OAAO,EAAE,SAAS,EAAE,UAAU,EAAE,UAAU,EAAE,WAAW,EAAE,YAAY;QACjH;QACA,qBAAqB,YAAY,YAAY;QAC7C,OAAO,aAAa,SAAS,WAAW;IAC1C;IACA,8DAA8D;IAC9D,OAAO;IACP,6EAA6E;IAC7E,8BAA8B;IAC9B,8EAA8E;IAC9E,wEAAwE;IACxE,gEAAgE;IAChE,+GAA+G;IAC/G,eAAe;IACf,2EAA2E;IAC3E,sBAAsB;IACtB,2EAA2E;IAC3E,iCAAiC;IACjC,QAAQ;IACR,IAAI,CAAC,KAAK,GAAG,SAAS,MAAM,OAAO,EAAE,SAAS,EAAE,UAAU,EAAE,YAAY;QACtE;QACA,qBAAqB,YAAY,GAAG,WAAW,MAAM;QACrD,OAAO,aAAa,SAAS,WAAW;IAC1C;IACA,0BAA0B;IAC1B,wEAAwE;IACxE,0CAA0C;IAC1C,MAAM,QAAQ,SAAU,OAAO,EAAE,WAAW,EAAE,OAAO;QACnD,MAAM,KAAK,OAAO,CAAC,QAAQ;QAC3B,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,QAAQ,CAAC,MAAM,EAAE,KAAK,EAAG;YAC9C,UAAU,GAAG,QAAQ,CAAC,EAAE,EAAE,aAAa;YACvC,IAAI,QAAQ,KAAK,KAAK,GAAG,OAAO,EAAE;gBAChC;YACF;QACF;IACF;IACA,0BAA0B;IAC1B,uDAAuD;IACvD,qCAAqC;IACrC,mCAAmC;IACnC,MAAM,QAAQ,SAAU,OAAO,EAAE,WAAW,EAAE,OAAO;QACnD,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,MAAM,KAAK,OAAO,CAAC,QAAQ;QAC3B,MAAM,OAAO,QAAQ,MAAM,CAAC,MAAM;QAClC,MAAM,OAAO,QAAQ,MAAM,CAAC,MAAM;QAClC,IAAI,SAAS,GAAG,EAAE;YAChB,YAAY,SAAS,GAAG,CAAC,SAAS;QACpC;QACA,UAAU;QACV,eAAe;QACf,YAAY;QACZ,IAAK,IAAI,IAAI,GAAG,IAAI,GAAG,QAAQ,CAAC,MAAM,EAAE,KAAK,EAAG;YAC9C,UAAU,GAAG,QAAQ,CAAC,EAAE,EAAE,cAAc;YACxC,IAAI,QAAQ,KAAK,KAAK,GAAG,OAAO,EAAE;gBAChC,UAAU;gBACV;YACF,OAAO;gBACL,gBAAgB,QAAQ,YAAY;gBACpC,aAAa,QAAQ,YAAY;YACnC;QACF;QACA,IAAI,SAAS;YACX,QAAQ,KAAK,GAAG,cAAc,IAAI,GAAG,KAAK,GAAG,GAAG,KAAK;YACrD,QAAQ,YAAY,GAAG;QACzB,OAAO;YACL,QAAQ,KAAK,GAAG,GAAG,OAAO;YAC1B,QAAQ,YAAY,GAAG;YACvB,gDAAgD,GAChD,QAAQ,MAAM,CAAC,GAAG,CAAC;YACnB,QAAQ,MAAM,CAAC,GAAG,CAAC;YACnB,IAAI,SAAS,GAAG,EAAE;gBAChB,SAAS,GAAG,CAAC,SAAS,CAAC;YACzB;QACF;IACF;IACA,0BAA0B;IAC1B,6CAA6C;IAC7C,mDAAmD;IACnD,mEAAmE;IACnE,0CAA0C;IAC1C,MAAM,QAAQ,SAAU,OAAO,EAAE,WAAW,EAAE,OAAO;QACnD,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,MAAM,KAAK,OAAO,CAAC,QAAQ;QAC3B,IAAI,GAAG,GAAG,KAAK,GAAG;YAChB,mCAAmC;YACnC,6DAA6D;YAC7D,QAAQ,KAAK,GAAG,GAAG,KAAK;YACxB,QAAQ,YAAY,GAAG;YACvB;QACF;QACA,eAAe;QACf,YAAY;QACZ,WAAW;QACX,MAAM,OAAO,QAAQ,MAAM,CAAC,MAAM;QAClC,MAAM,OAAO,QAAQ,MAAM,CAAC,MAAM;QAClC,IAAI,SAAS,GAAG,EAAE;YAChB,YAAY,SAAS,GAAG,CAAC,SAAS;QACpC;QACA,MAAM,OAAO;QACb,MAAO,KAAM;YACX,IAAI,gBAAgB,UAAU;gBAE5B;YACF;YACA,UAAU,UAAU,GAAG,cAAc;YACrC,IAAI,QAAQ,KAAK,KAAK,GAAG,OAAO,EAAE;gBAEhC;YACF;YACA,IAAI,QAAQ,KAAK,KAAK,GAAG,KAAK,EAAE;gBAG9B;YACF;YACA,YAAY;YACZ,aAAa,QAAQ,YAAY;YACjC,gBAAgB,QAAQ,YAAY;YACpC,IAAI,aAAa,GAAG,GAAG,EAAE;gBAEvB;YACF;QACF;QACA,6DAA6D,GAC7D,IAAI,QAAQ,KAAK,KAAK,GAAG,KAAK,EAAE;YAC9B,QAAQ,KAAK,GAAG,cAAc,IAAI,GAAG,KAAK,GAAG,GAAG,KAAK;YACrD,QAAQ,YAAY,GAAG;QACzB,OAAO,IAAI,YAAY,GAAG,GAAG,EAAE;YAC7B,QAAQ,KAAK,GAAG,cAAc,IAAI,GAAG,KAAK,GAAG,GAAG,KAAK;YACrD,QAAQ,YAAY,GAAG;QACzB,OAAO;YACL,QAAQ,KAAK,GAAG,GAAG,OAAO;YAC1B,QAAQ,YAAY,GAAG;YACvB,gDAAgD,GAChD,QAAQ,MAAM,CAAC,GAAG,CAAC;YACnB,QAAQ,MAAM,CAAC,GAAG,CAAC;YACnB,IAAI,SAAS,GAAG,EAAE;gBAChB,SAAS,GAAG,CAAC,SAAS,CAAC;YACzB;QACF;IACF;IACA,4DAA4D;IAC5D,mDAAmD;IACnD,0BAA0B;IAC1B,MAAM,4BAA4B,SAAU,IAAI,EAAE,OAAO,EAAE,SAAS,EAAE,IAAI;QACxE,IAAI,QAAQ,YAAY,GAAG,WAAW;YACpC,IAAI,MAAM,GAAG,aAAa,MAAM,EAAE,KAAK,IAAI,CAAC,4BAA4B,CAAC;YACzE,OAAO,CAAC,sBAAsB,EAAE,QAAQ,YAAY,EAAE;YACtD,OAAO,CAAC,6BAA6B,EAAE,WAAW;YAClD,MAAM,IAAI,MAAM;QAClB;QACA,OAAQ,QAAQ,KAAK;YACnB,KAAK,GAAG,MAAM;gBACZ,IAAI,SAAS,MAAM;oBACjB,MAAM,IAAI,MACR,GAAG,aAAa,MAAM,EAAE,KAAK,IAAI,CAAC,4DAA4D,CAAC;gBAEnG;gBACA;YACF,KAAK,GAAG,KAAK;gBACX,QAAQ,YAAY,GAAG;gBACvB;YACF,KAAK,GAAG,KAAK;gBACX,IAAI,QAAQ,YAAY,KAAK,GAAG;oBAC9B,QAAQ,KAAK,GAAG,GAAG,KAAK;gBAC1B;gBACA;YACF,KAAK,GAAG,OAAO;gBACb,QAAQ,YAAY,GAAG;gBACvB;YACF;gBACE,MAAM,IAAI,MACR,GAAG,aAAa,MAAM,EAAE,KAAK,IAAI,CAAC,8DAA8D,EAAE,QAAQ,KAAK,EAAE;QAEvH;IACF;IACA,0BAA0B;IAC1B,2EAA2E;IAC3E,4CAA4C;IAC5C,mHAAmH;IACnH,+FAA+F;IAC/F,wCAAwC;IACxC,MAAM,QAAQ,SAAU,OAAO,EAAE,WAAW,EAAE,OAAO;QACnD,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,MAAM,KAAK,OAAO,CAAC,QAAQ;QAC3B,MAAM,OAAO,KAAK,CAAC,GAAG,KAAK,CAAC;QAC5B,MAAM,WAAW,aAAa,CAAC,KAAK,KAAK,CAAC;QAC1C,MAAM,gBAAgB,CAAC;QACvB,gDAAgD,GAChD,IAAI,eAAe;YACjB,iCAAiC,GACjC,aAAa,SAAS,GAAG,IAAI,SAAS,GAAG,CAAC,WAAW,CAAC,GAAG,KAAK;YAC9D,IAAI,YAAY;gBACd,YAAY,SAAS,GAAG,CAAC,SAAS;gBAClC,SAAS,GAAG,CAAC,IAAI,CAAC,GAAG,KAAK,EAAE,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC,IAAI;YAClD;YACA,OAAO,QAAQ,MAAM,CAAC,MAAM;YAC5B,OAAO,QAAQ,MAAM,CAAC,MAAM;YAC5B,QAAQ,MAAM,CAAC,IAAI;YACnB,QAAQ,MAAM,CAAC,IAAI;YACnB,YAAY,QAAQ,MAAM;YAC1B,QAAQ,MAAM,GAAG,IAAI;QACvB;QACA,IAAI,aAAa,MAAM;YACrB,uCAAuC,GACvC,eAAe;YACf,UAAU,KAAK,OAAO;YACtB,UAAU,GAAG,aAAa;YAC1B,UAAU;QACZ,OAAO;YACL,wBAAwB,GACxB,MAAM,YAAY,WAAW;YAC7B,QAAQ,SAAS,GAAG,KAAK,KAAK;YAC9B,SAAS,SAAS,OAAO,aAAa;YACtC,0BAA0B,MAAM,SAAS,WAAW;YACpD,IAAI,QAAQ,KAAK,KAAK,GAAG,MAAM,EAAE;gBAC/B,eAAe;gBACf,UAAU,KAAK,OAAO;gBACtB,UAAU,GAAG,aAAa;gBAC1B,UAAU;gBACV,QAAQ,SAAS,GAAG,KAAK,KAAK;gBAC9B,SAAS,SAAS,OAAO,aAAa;gBACtC,0BAA0B,MAAM,SAAS,WAAW;YACtD,EAAE,6EAA6E;QACjF;QACA,IAAI,eAAe;YACjB,WAAW,GACX,IAAI,YAAY;gBACd,IAAI,QAAQ,KAAK,KAAK,GAAG,OAAO,EAAE;oBAChC,SAAS,GAAG,CAAC,SAAS,CAAC;gBACzB,OAAO;oBACL,SAAS,GAAG,CAAC,EAAE,CAAC,GAAG,KAAK,EAAE,KAAK,IAAI,EAAE,aAAa,QAAQ,YAAY;gBACxE;YACF;YACA,sBAAsB,GACtB,QAAQ,MAAM,GAAG;YACjB,IAAI,QAAQ,KAAK,KAAK,GAAG,OAAO,EAAE;gBAChC,QAAQ,MAAM,CAAC,GAAG,CAAC;gBACnB,QAAQ,MAAM,CAAC,GAAG,CAAC;YACrB,OAAO,IAAI,KAAK,KAAK,EAAE;gBACrB,uDAAuD,GACvD,+CAA+C,GAC/C,QAAQ,MAAM,CAAC,UAAU,CAAC,KAAK,KAAK,EAAE,aAAa,QAAQ,YAAY;gBACvE,QAAQ,MAAM,CAAC,UAAU,CAAC,KAAK,KAAK,EAAE,aAAa,QAAQ,YAAY;YACzE;QACF;IACF;IACA,4DAA4D;IAC5D,yEAAyE;IACzE,MAAM,4BAA4B,SAAU,GAAG,EAAE,OAAO,EAAE,SAAS;QACjE,IAAI,QAAQ,YAAY,GAAG,WAAW;YACpC,IAAI,MAAM,GAAG,aAAa,MAAM,EAAE,IAAI,IAAI,CAAC,4BAA4B,CAAC;YACxE,OAAO,CAAC,sBAAsB,EAAE,QAAQ,YAAY,EAAE;YACtD,OAAO,CAAC,6BAA6B,EAAE,WAAW;YAClD,MAAM,IAAI,MAAM;QAClB;QACA,OAAQ,QAAQ,KAAK;YACnB,KAAK,GAAG,MAAM;gBACZ,MAAM,IAAI,MAAM,GAAG,aAAa,MAAM,EAAE,IAAI,IAAI,CAAC,4DAA4D,CAAC;YAChH,KAAK,GAAG,KAAK;gBACX,IAAI,IAAI,KAAK,KAAK,OAAO;oBACvB,MAAM,IAAI,MAAM,GAAG,aAAa,MAAM,EAAE,IAAI,IAAI,CAAC,wDAAwD,CAAC;gBAC5G,OAAO;oBACL,QAAQ,YAAY,GAAG;gBACzB;gBACA;YACF,KAAK,GAAG,KAAK;gBACX,IAAI,QAAQ,YAAY,KAAK,GAAG;oBAC9B,IAAI,IAAI,KAAK,KAAK,OAAO;wBACvB,MAAM,IAAI,MAAM,GAAG,aAAa,MAAM,EAAE,IAAI,IAAI,CAAC,wDAAwD,CAAC;oBAC5G,OAAO;wBACL,QAAQ,KAAK,GAAG,GAAG,KAAK;oBAC1B;gBACF;gBACA;YACF,KAAK,GAAG,OAAO;gBACb,QAAQ,YAAY,GAAG;gBACvB;YACF;gBACE,MAAM,IAAI,MACR,GAAG,aAAa,MAAM,EAAE,IAAI,IAAI,CAAC,8DAA8D,EAAE,QAAQ,KAAK,EAAE;QAEtH;IACF;IACA,0BAA0B;IAC1B,8FAA8F;IAC9F,wBAAwB;IACxB,kGAAkG;IAClG,wCAAwC;IACxC,wCAAwC;IACxC,MAAM,QAAQ,SAAU,OAAO,EAAE,WAAW,EAAE,OAAO;QACnD,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,MAAM,KAAK,OAAO,CAAC,QAAQ;QAC3B,MAAM,MAAM,IAAI,CAAC,GAAG,KAAK,CAAC;QAC1B,QAAQ,QAAQ,GAAG,IAAI,KAAK;QAE5B,MAAM,gBAAgB,CAAC;QACvB,gDAAgD,GAChD,IAAI,eAAe;YACjB,gCAAgC,GAChC,aAAa,SAAS,GAAG,IAAI,SAAS,GAAG,CAAC,UAAU,CAAC,GAAG,KAAK;YAC7D,IAAI,YAAY;gBACd,WAAW,MAAM,MAAM,GAAG,GAAG,KAAK;gBAClC,YAAY,SAAS,GAAG,CAAC,SAAS;gBAClC,SAAS,GAAG,CAAC,IAAI,CAAC,UAAU,IAAI,IAAI;YACtC;YACA,4EAA4E,GAC5E,uEAAuE,GACvE,OAAO,QAAQ,MAAM,CAAC,MAAM;YAC5B,OAAO,QAAQ,MAAM,CAAC,MAAM;YAC5B,QAAQ,MAAM,CAAC,IAAI;YACnB,QAAQ,MAAM,CAAC,IAAI;YACnB,YAAY,QAAQ,MAAM;YAC1B,QAAQ,MAAM,GAAG,IAAI;QACvB;QACA,gBAAgB,GAChB,MAAM,YAAY,WAAW;QAC7B,YAAY,CAAC,GAAG,KAAK,CAAC,CAAC,SAAS,OAAO,aAAa;QACpD,0BAA0B,KAAK,SAAS;QACxC,IAAI,eAAe;YACjB,WAAW,GACX,IAAI,YAAY;gBACd,IAAI,QAAQ,KAAK,KAAK,GAAG,OAAO,EAAE;oBAChC,SAAS,GAAG,CAAC,SAAS,CAAC;gBACzB,OAAO;oBACL,SAAS,GAAG,CAAC,EAAE,CAAC,UAAU,IAAI,IAAI,EAAE,aAAa,QAAQ,YAAY;gBACvE;YACF;YACA,sBAAsB,GACtB,QAAQ,MAAM,GAAG;YACjB,IAAI,QAAQ,KAAK,KAAK,GAAG,OAAO,EAAE;gBAChC,QAAQ,MAAM,CAAC,GAAG,CAAC;gBACnB,QAAQ,MAAM,CAAC,GAAG,CAAC;YACrB,OAAO,IAAI,IAAI,KAAK,EAAE;gBACpB,uDAAuD,GACvD,+CAA+C,GAC/C,QAAQ,MAAM,CAAC,UAAU,CAAC,IAAI,KAAK,EAAE,aAAa,QAAQ,YAAY;gBACtE,QAAQ,MAAM,CAAC,UAAU,CAAC,IAAI,KAAK,EAAE,aAAa,QAAQ,YAAY;YACxE;QACF;IACF;IACA,0BAA0B;IAC1B,8CAA8C;IAC9C,4DAA4D;IAC5D,yCAAyC;IACzC,0EAA0E;IAC1E,MAAM,QAAQ,SAAU,OAAO,EAAE,WAAW,EAAE,OAAO;QACnD,WAAW,IAAI,CAAC;YACd,YAAY,GAAG,gBAAgB;YAC/B,QAAQ;YACR;YACA;QACF;QACA,WAAW,MAAM,MAAM;QACvB,cAAc,MAAM,MAAM,GAAG;QAC7B,UAAU,UAAU,GAAG,aAAa;QACpC,MAAM,MAAM,WAAW,GAAG;QAC1B,WAAW,IAAI,QAAQ;QACvB,cAAc,IAAI,WAAW;QAC7B,QAAQ,YAAY,GAAG;QACvB,OAAQ,QAAQ,KAAK;YACnB,KAAK,GAAG,KAAK;gBACX,QAAQ,KAAK,GAAG,GAAG,KAAK;gBACxB;YACF,KAAK,GAAG,KAAK;gBACX,QAAQ,KAAK,GAAG,GAAG,KAAK;gBACxB;YACF,KAAK,GAAG,OAAO;gBACb,QAAQ,KAAK,GAAG,GAAG,OAAO;gBAC1B;YACF;gBACE,MAAM,IAAI,MAAM,CAAC,qBAAqB,EAAE,QAAQ,KAAK,EAAE;QAC3D;IACF;IACA,0BAA0B;IAC1B,8CAA8C;IAC9C,4DAA4D;IAC5D,4CAA4C;IAC5C,8DAA8D;IAC9D,0CAA0C;IAC1C,MAAM,QAAQ,SAAU,OAAO,EAAE,WAAW,EAAE,OAAO;QACnD,WAAW,IAAI,CAAC;YACd,YAAY,GAAG,gBAAgB;YAC/B,QAAQ;YACR;YACA;QACF;QACA,WAAW,MAAM,MAAM;QACvB,cAAc,MAAM,MAAM,GAAG;QAC7B,UAAU,UAAU,GAAG,aAAa;QACpC,MAAM,MAAM,WAAW,GAAG;QAC1B,WAAW,IAAI,QAAQ;QACvB,cAAc,IAAI,WAAW;QAC7B,QAAQ,YAAY,GAAG;QACvB,OAAQ,QAAQ,KAAK;YACnB,KAAK,GAAG,KAAK;YACb,KAAK,GAAG,KAAK;gBACX,QAAQ,KAAK,GAAG,GAAG,OAAO;gBAC1B;YACF,KAAK,GAAG,OAAO;gBACb,QAAQ,KAAK,GAAG,GAAG,KAAK;gBACxB;YACF;gBACE,MAAM,IAAI,MAAM,CAAC,qBAAqB,EAAE,QAAQ,KAAK,EAAE;QAC3D;IACF;IACA,0BAA0B;IAC1B,0DAA0D;IAC1D,gCAAgC;IAChC,MAAM,QAAQ,SAAU,OAAO,EAAE,WAAW,EAAE,OAAO;QACnD,MAAM,KAAK,OAAO,CAAC,QAAQ;QAC3B,QAAQ,KAAK,GAAG,GAAG,OAAO;QAC1B,IAAI,cAAc,UAAU;YAC1B,IAAI,GAAG,GAAG,IAAI,KAAK,CAAC,YAAY,IAAI,KAAK,CAAC,YAAY,IAAI,GAAG,GAAG,EAAE;gBAChE,QAAQ,KAAK,GAAG,GAAG,KAAK;gBACxB,QAAQ,YAAY,GAAG;YACzB;QACF;IACF;IACA,0BAA0B;IAC1B,2DAA2D;IAC3D,qCAAqC;IACrC,qFAAqF;IACrF,sBAAsB;IACtB,wCAAwC;IACxC,0DAA0D;IAC1D,MAAM,QAAQ,SAAU,OAAO,EAAE,WAAW,EAAE,OAAO;QACnD,IAAI;QACJ,MAAM,KAAK,OAAO,CAAC,QAAQ;QAC3B,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM;QAC5B,QAAQ,KAAK,GAAG,GAAG,OAAO;QAC1B,IAAI,cAAc,OAAO,UAAU;YACjC,IAAK,IAAI,GAAG,IAAI,KAAK,KAAK,EAAG;gBAC3B,IAAI,KAAK,CAAC,cAAc,EAAE,KAAK,GAAG,MAAM,CAAC,EAAE,EAAE;oBAC3C;gBACF;YACF;YACA,QAAQ,KAAK,GAAG,GAAG,KAAK;YACxB,QAAQ,YAAY,GAAG;QACzB,EAAE,wBAAwB;IAC5B;IACA,0BAA0B;IAC1B,2DAA2D;IAC3D,0EAA0E;IAC1E,mEAAmE;IACnE,oEAAoE;IACpE,mDAAmD;IACnD,MAAM,QAAQ,SAAU,OAAO,EAAE,WAAW,EAAE,OAAO;QACnD,IAAI;QACJ,IAAI;QACJ,MAAM,KAAK,OAAO,CAAC,QAAQ;QAC3B,QAAQ,KAAK,GAAG,GAAG,OAAO;QAC1B,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM;QAC5B,IAAI,QAAQ,GAAG;YACb,+BAA+B,GAC/B,QAAQ,KAAK,GAAG,GAAG,KAAK;YACxB;QACF;QACA,IAAI,cAAc,OAAO,UAAU;YACjC,IAAK,IAAI,GAAG,IAAI,KAAK,KAAK,EAAG;gBAC3B,OAAO,KAAK,CAAC,cAAc,EAAE;gBAC7B,IAAI,QAAQ,MAAM,QAAQ,IAAI;oBAC5B,QAAQ;gBACV;gBACA,IAAI,SAAS,GAAG,MAAM,CAAC,EAAE,EAAE;oBACzB;gBACF;YACF;YACA,QAAQ,KAAK,GAAG,GAAG,KAAK;YACxB,QAAQ,YAAY,GAAG;QACzB,EAAE,wBAAwB;IAC5B;IACA,0BAA0B;IAC1B,iGAAiG;IACjG,qDAAqD;IACrD,0DAA0D;IAC1D,MAAM,QAAQ,SAAU,OAAO,EAAE,WAAW,EAAE,OAAO;QACnD,QAAQ,KAAK,GAAG,GAAG,OAAO;QAC1B,QAAQ,YAAY,GAAG;QACvB,QAAQ,KAAK,GAAG,gBAAgB,IAAI,GAAG,KAAK,GAAG,GAAG,OAAO;IAC3D;IACA,0BAA0B;IAC1B,2FAA2F;IAC3F,qDAAqD;IACrD,oFAAoF;IACpF,MAAM,QAAQ,SAAU,OAAO,EAAE,WAAW,EAAE,OAAO;QACnD,QAAQ,KAAK,GAAG,GAAG,OAAO;QAC1B,QAAQ,YAAY,GAAG;QACvB,QAAQ,KAAK,GAAG,gBAAgB,MAAM,MAAM,GAAG,GAAG,KAAK,GAAG,GAAG,OAAO;IACtE;IACA,0BAA0B;IAC1B,+BAA+B;IAC/B,qFAAqF;IACrF,iGAAiG;IACjG,8CAA8C;IAC9C,qFAAqF;IACrF,wFAAwF;IACxF,MAAM,QAAQ,SAAU,OAAO,EAAE,WAAW,EAAE,OAAO;QACnD,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,MAAM,KAAK,OAAO,CAAC,QAAQ;QAC3B,QAAQ,KAAK,GAAG,GAAG,OAAO;QAC1B,IAAI,GAAG,KAAK,GAAG,MAAM,MAAM,EAAE;YAC3B,QAAQ,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC,KAAK;QAC/B,OAAO;YACL,QAAQ,IAAI,CAAC,GAAG,KAAK,GAAG,MAAM,MAAM,CAAC,CAAC,KAAK;QAC7C;QACA,MAAM,QAAQ,GAAG,OAAO,KAAK,GAAG,WAAW,GAAG,QAAQ,MAAM,CAAC,SAAS,CAAC,SAAS,QAAQ,MAAM,CAAC,SAAS,CAAC;QACzG,MAAM,cAAc,GAAG,OAAO,KAAK,GAAG,WAAW;QACjD,IAAI,UAAU,MAAM;YAClB;QACF;QACA,MAAM,UAAU,MAAM,WAAW;QACjC,MAAM,MAAM,MAAM,YAAY;QAC9B,IAAI,QAAQ,GAAG;YACb,QAAQ,KAAK,GAAG,GAAG,KAAK;YACxB;QACF;QACA,IAAI,cAAc,OAAO,UAAU;YACjC,IAAI,aAAa;gBACf,0BAA0B,GAC1B,IAAK,IAAI,GAAG,IAAI,KAAK,KAAK,EAAG;oBAC3B,OAAO,KAAK,CAAC,cAAc,EAAE;oBAC7B,SAAS,KAAK,CAAC,UAAU,EAAE;oBAC3B,IAAI,QAAQ,MAAM,QAAQ,IAAI;wBAC5B,QAAQ;oBACV;oBACA,IAAI,UAAU,MAAM,UAAU,IAAI;wBAChC,UAAU;oBACZ;oBACA,IAAI,SAAS,QAAQ;wBACnB;oBACF;gBACF;gBACA,QAAQ,KAAK,GAAG,GAAG,KAAK;gBACxB,QAAQ,YAAY,GAAG;YACzB,OAAO;gBACL,wBAAwB,GACxB,IAAK,IAAI,GAAG,IAAI,KAAK,KAAK,EAAG;oBAC3B,OAAO,KAAK,CAAC,cAAc,EAAE;oBAC7B,SAAS,KAAK,CAAC,UAAU,EAAE;oBAC3B,IAAI,SAAS,QAAQ;wBACnB;oBACF;gBACF;YACF;YACA,QAAQ,KAAK,GAAG,GAAG,KAAK;YACxB,QAAQ,YAAY,GAAG;QACzB;IACF;IACA,0BAA0B;IAC1B,+CAA+C;IAC/C,2CAA2C;IAC3C,kEAAkE;IAClE,wEAAwE;IACxE,MAAM,QAAQ,SAAU,OAAO,EAAE,WAAW,EAAE,OAAO;QACnD,WAAW,IAAI,CAAC;YACd,YAAY,GAAG,iBAAiB;YAChC,QAAQ;QACV;QACA,UAAU,UAAU,GAAG,aAAa;QACpC,WAAW,GAAG;QACd,QAAQ,YAAY,GAAG;QACvB,OAAQ,QAAQ,KAAK;YACnB,KAAK,GAAG,KAAK;gBACX,QAAQ,KAAK,GAAG,GAAG,KAAK;gBACxB;YACF,KAAK,GAAG,KAAK;gBACX,QAAQ,KAAK,GAAG,GAAG,KAAK;gBACxB;YACF,KAAK,GAAG,OAAO;gBACb,QAAQ,KAAK,GAAG,GAAG,OAAO;gBAC1B;YACF;gBACE,MAAM,IAAI,MAAM,CAAC,qBAAqB,EAAE,QAAQ,KAAK,EAAE;QAC3D;IACF;IACA,0BAA0B;IAC1B,+CAA+C;IAC/C,2CAA2C;IAC3C,wEAAwE;IACxE,wEAAwE;IACxE,MAAM,QAAQ,SAAU,OAAO,EAAE,WAAW,EAAE,OAAO;QACnD,UAAU;QACV,yBAAyB;QACzB,WAAW,IAAI,CAAC;YACd,YAAY,GAAG,iBAAiB;YAChC,QAAQ;QACV;QACA,UAAU,UAAU,GAAG,aAAa;QACpC,WAAW,GAAG;QACd,QAAQ,YAAY,GAAG;QACvB,OAAQ,QAAQ,KAAK;YACnB,KAAK,GAAG,KAAK;YACb,KAAK,GAAG,KAAK;gBACX,QAAQ,KAAK,GAAG,GAAG,OAAO;gBAC1B;YACF,KAAK,GAAG,OAAO;gBACb,QAAQ,KAAK,GAAG,GAAG,KAAK;gBACxB;YACF;gBACE,MAAM,IAAI,MAAM,CAAC,qBAAqB,EAAE,QAAQ,KAAK,EAAE;QAC3D;IACF;IACA,wCAAwC;IACxC,uDAAuD;IACvD,wFAAwF;IACxF,MAAM,cAAc,SAAU,OAAO,EAAE,WAAW,EAAE,OAAO;QACzD,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,MAAM,KAAK,OAAO,CAAC,QAAQ;QAC3B,MAAM,OAAO,QAAQ,MAAM,CAAC,MAAM;QAClC,MAAM,OAAO,QAAQ,MAAM,CAAC,MAAM;QAClC,IAAI,SAAS,GAAG,EAAE;YAChB,YAAY,SAAS,GAAG,CAAC,SAAS;QACpC;QACA,UAAU;QACV,eAAe;QACf,aAAa;QACb,iBAAiB;QACjB,IAAK,IAAI,IAAI,GAAG,QAAQ,CAAC,MAAM,GAAG,GAAG,KAAK,GAAG,KAAK,EAAG;YACnD,UAAU,GAAG,QAAQ,CAAC,EAAE,EAAE,cAAc;YACxC,gBAAgB,QAAQ,YAAY;YACpC,cAAc,QAAQ,YAAY;YAClC,qCAAqC;YACrC,IAAI,QAAQ,KAAK,KAAK,GAAG,OAAO,EAAE;gBAChC,UAAU;gBACV;YACF;QACF;QACA,IAAI,SAAS;YACX,QAAQ,KAAK,GAAG,eAAe,IAAI,GAAG,KAAK,GAAG,GAAG,KAAK;YACtD,QAAQ,YAAY,GAAG;QACzB,OAAO;YACL,QAAQ,KAAK,GAAG,GAAG,OAAO;YAC1B,QAAQ,YAAY,GAAG;YACvB,QAAQ,MAAM,CAAC,GAAG,CAAC;YACnB,QAAQ,MAAM,CAAC,GAAG,CAAC;YACnB,IAAI,SAAS,GAAG,EAAE;gBAChB,SAAS,GAAG,CAAC,SAAS,CAAC;YACzB;QACF;IACF;IACA,wCAAwC;IACxC,kDAAkD;IAClD,uFAAuF;IACvF,MAAM,cAAc,SAAU,OAAO,EAAE,WAAW,EAAE,OAAO;QACzD,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,MAAM,KAAK,OAAO,CAAC,QAAQ;QAC3B,eAAe;QACf,YAAY;QACZ,WAAW;QACX,MAAM,OAAO,QAAQ,MAAM,CAAC,MAAM;QAClC,MAAM,OAAO,QAAQ,MAAM,CAAC,MAAM;QAClC,IAAI,SAAS,GAAG,EAAE;YAChB,YAAY,SAAS,GAAG,CAAC,SAAS;QACpC;QACA,MAAM,OAAO;QACb,MAAO,KAAM;YACX,IAAI,gBAAgB,GAAG;gBAErB;YACF;YACA,UAAU,UAAU,GAAG,cAAc;YACrC,IAAI,QAAQ,KAAK,KAAK,GAAG,OAAO,EAAE;gBAEhC;YACF;YACA,IAAI,QAAQ,KAAK,KAAK,GAAG,KAAK,EAAE;gBAG9B;YACF;YACA,YAAY;YACZ,aAAa,QAAQ,YAAY;YACjC,gBAAgB,QAAQ,YAAY;YACpC,IAAI,aAAa,GAAG,GAAG,EAAE;gBAEvB;YACF;QACF;QACA,6DAA6D,GAC7D,IAAI,QAAQ,KAAK,KAAK,GAAG,KAAK,EAAE;YAC9B,QAAQ,KAAK,GAAG,cAAc,IAAI,GAAG,KAAK,GAAG,GAAG,KAAK;YACrD,QAAQ,YAAY,GAAG;QACzB,OAAO,IAAI,YAAY,GAAG,GAAG,EAAE;YAC7B,QAAQ,KAAK,GAAG,cAAc,IAAI,GAAG,KAAK,GAAG,GAAG,KAAK;YACrD,QAAQ,YAAY,GAAG;QACzB,OAAO;YACL,QAAQ,KAAK,GAAG,GAAG,OAAO;YAC1B,QAAQ,YAAY,GAAG;YACvB,QAAQ,MAAM,CAAC,GAAG,CAAC;YACnB,QAAQ,MAAM,CAAC,GAAG,CAAC;YACnB,IAAI,SAAS,GAAG,EAAE;gBAChB,SAAS,GAAG,CAAC,SAAS,CAAC;YACzB;QACF;IACF;IACA,wCAAwC;IACxC,kDAAkD;IAClD,8EAA8E;IAC9E,MAAM,cAAc,SAAU,OAAO,EAAE,WAAW,EAAE,OAAO;QACzD,MAAM,KAAK,OAAO,CAAC,QAAQ;QAC3B,QAAQ,KAAK,GAAG,GAAG,OAAO;QAC1B,QAAQ,YAAY,GAAG;QACvB,IAAI,cAAc,GAAG;YACnB,MAAM,OAAO,KAAK,CAAC,cAAc,EAAE;YACnC,IAAI,GAAG,GAAG,IAAI,QAAQ,QAAQ,GAAG,GAAG,EAAE;gBACpC,QAAQ,KAAK,GAAG,GAAG,KAAK;gBACxB,QAAQ,YAAY,GAAG;YACzB;QACF;IACF;IACA,wCAAwC;IACxC,kDAAkD;IAClD,yDAAyD;IACzD,MAAM,cAAc,SAAU,OAAO,EAAE,WAAW,EAAE,OAAO;QACzD,IAAI;QACJ,MAAM,KAAK,OAAO,CAAC,QAAQ;QAC3B,QAAQ,KAAK,GAAG,GAAG,OAAO;QAC1B,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM;QAC5B,MAAM,MAAM,cAAc;QAC1B,IAAI,OAAO,GAAG;YACZ,IAAK,IAAI,GAAG,IAAI,KAAK,KAAK,EAAG;gBAC3B,IAAI,KAAK,CAAC,MAAM,EAAE,KAAK,GAAG,MAAM,CAAC,EAAE,EAAE;oBACnC;gBACF;YACF;YACA,QAAQ,KAAK,GAAG,GAAG,KAAK;YACxB,QAAQ,YAAY,GAAG;QACzB;IACF;IACA,wCAAwC;IACxC,kDAAkD;IAClD,yDAAyD;IACzD,MAAM,cAAc,SAAU,OAAO,EAAE,WAAW,EAAE,OAAO;QACzD,IAAI;QACJ,MAAM,KAAK,OAAO,CAAC,QAAQ;QAC3B,QAAQ,KAAK,GAAG,GAAG,OAAO;QAC1B,MAAM,MAAM,GAAG,MAAM,CAAC,MAAM;QAC5B,IAAI,QAAQ,GAAG;YACb,+BAA+B,GAC/B,QAAQ,KAAK,GAAG,GAAG,KAAK;YACxB;QACF;QACA,MAAM,MAAM,cAAc;QAC1B,IAAI,OAAO,GAAG;YACZ,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,KAAK,EAAG;gBAC/B,OAAO,KAAK,CAAC,MAAM,EAAE;gBACrB,IAAI,QAAQ,MAAM,QAAQ,IAAI;oBAC5B,QAAQ;gBACV;gBACA,IAAI,SAAS,GAAG,MAAM,CAAC,EAAE,EAAE;oBACzB;gBACF;YACF;YACA,QAAQ,KAAK,GAAG,GAAG,KAAK;YACxB,QAAQ,YAAY,GAAG;QACzB;IACF;IACA,iDAAiD;IACjD,mEAAmE;IACnE,MAAM,cAAc,SAAU,OAAO,EAAE,WAAW,EAAE,OAAO;QACzD,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,MAAM,KAAK,OAAO,CAAC,QAAQ;QAC3B,mBAAmB,GACnB,QAAQ,KAAK,GAAG,GAAG,OAAO;QAC1B,QAAQ,YAAY,GAAG;QACvB,IAAI,GAAG,KAAK,GAAG,MAAM,MAAM,EAAE;YAC3B,QAAQ,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC,KAAK;QAC/B,OAAO;YACL,QAAQ,IAAI,CAAC,GAAG,KAAK,GAAG,MAAM,MAAM,CAAC,CAAC,KAAK;QAC7C;QACA,MAAM,QAAQ,GAAG,OAAO,KAAK,GAAG,WAAW,GAAG,QAAQ,MAAM,CAAC,SAAS,CAAC,SAAS,QAAQ,MAAM,CAAC,SAAS,CAAC;QACzG,MAAM,cAAc,GAAG,OAAO,KAAK,GAAG,WAAW;QACjD,IAAI,UAAU,MAAM;YAClB;QACF;QACA,MAAM,UAAU,MAAM,WAAW;QACjC,MAAM,MAAM,MAAM,YAAY;QAC9B,IAAI,QAAQ,GAAG;YACb,QAAQ,KAAK,GAAG,GAAG,KAAK;YACxB,QAAQ,YAAY,GAAG;YACvB;QACF;QACA,MAAM,MAAM,cAAc;QAC1B,IAAI,OAAO,GAAG;YACZ,IAAI,aAAa;gBACf,0BAA0B,GAC1B,IAAK,IAAI,GAAG,IAAI,KAAK,KAAK,EAAG;oBAC3B,OAAO,KAAK,CAAC,MAAM,EAAE;oBACrB,SAAS,KAAK,CAAC,UAAU,EAAE;oBAC3B,IAAI,QAAQ,MAAM,QAAQ,IAAI;wBAC5B,QAAQ;oBACV;oBACA,IAAI,UAAU,MAAM,UAAU,IAAI;wBAChC,UAAU;oBACZ;oBACA,IAAI,SAAS,QAAQ;wBACnB;oBACF;gBACF;gBACA,QAAQ,KAAK,GAAG,GAAG,KAAK;gBACxB,QAAQ,YAAY,GAAG;YACzB,OAAO;gBACL,wBAAwB,GACxB,IAAK,IAAI,GAAG,IAAI,KAAK,KAAK,EAAG;oBAC3B,OAAO,KAAK,CAAC,MAAM,EAAE;oBACrB,SAAS,KAAK,CAAC,UAAU,EAAE;oBAC3B,IAAI,SAAS,QAAQ;wBACnB;oBACF;gBACF;YACF;YACA,QAAQ,KAAK,GAAG,GAAG,KAAK;YACxB,QAAQ,YAAY,GAAG;QACzB;IACF;IACA,sCAAsC;IACtC,kEAAkE;IAClE,+DAA+D;IAC/D,0DAA0D;IAC1D,wEAAwE;IACxE,0EAA0E;IAC1E,SAAS;IACT,YAAY,SAAS,cAAc,OAAO,EAAE,WAAW,EAAE,OAAO;QAC9D,IAAI,MAAM;QACV,MAAM,KAAK,OAAO,CAAC,QAAQ;QAC3B,YAAY;QACZ,IAAI,WAAW,eAAe;YAC5B,MAAM,IAAI,MAAM,CAAC,8CAA8C,EAAE,eAAe;QAClF;QACA,aAAa;QACb,IAAI,YAAY,cAAc;YAC5B,eAAe;YACf,IAAI,eAAe,gBAAgB;gBACjC,MAAM,IAAI,MAAM,CAAC,2CAA2C,EAAE,gBAAgB;YAChF;QACF;QACA,QAAQ,OAAO;QACf,IAAI,SAAS,KAAK,KAAK,MAAM;YAC3B,oDAAoD,GACpD,MAAM,KAAK;YACX,SAAS,KAAK,CAAC,IAAI,CAAC,IAAI,QAAQ,KAAK,EAAE,aAAa,QAAQ,YAAY,EAAE,GAAG,MAAM,EAAE,GAAG,UAAU;QACpG;QACA,IAAI,gBAAgB;YAClB,OAAQ,GAAG,IAAI;gBACb,KAAK,GAAG,GAAG;oBACT,MAAM,SAAS,aAAa;oBAC5B;gBACF,KAAK,GAAG,GAAG;oBACT,YAAY,SAAS,aAAa;oBAClC;gBACF,KAAK,GAAG,GAAG;oBACT,YAAY,SAAS,aAAa;oBAClC;gBACF,KAAK,GAAG,GAAG;oBACT,MAAM,SAAS,aAAa;oBAC5B;gBACF,KAAK,GAAG,GAAG;oBACT,MAAM,SAAS,aAAa;oBAC5B;gBACF,KAAK,GAAG,GAAG;oBACT,MAAM,SAAS,aAAa;oBAC5B;gBACF,KAAK,GAAG,GAAG;oBACT,MAAM,SAAS,aAAa;oBAC5B;gBACF,KAAK,GAAG,GAAG;oBACT,YAAY,SAAS,aAAa;oBAClC;gBACF,KAAK,GAAG,GAAG;oBACT,YAAY,SAAS,aAAa;oBAClC;gBACF,KAAK,GAAG,GAAG;oBACT,YAAY,SAAS,aAAa;oBAClC;gBACF,KAAK,GAAG,GAAG;oBACT,YAAY,SAAS,aAAa;oBAClC;gBACF,KAAK,GAAG,GAAG;oBACT,MAAM,SAAS,aAAa;oBAC5B;gBACF,KAAK,GAAG,GAAG;oBACT,MAAM,SAAS,aAAa;oBAC5B;gBACF,KAAK,GAAG,GAAG;oBACT,MAAM,SAAS,aAAa;oBAC5B;gBACF,KAAK,GAAG,GAAG;oBACT,MAAM,SAAS,aAAa;oBAC5B;gBACF;oBACE,MAAM;oBACN;YACJ;QACF,OAAO;YACL,OAAQ,GAAG,IAAI;gBACb,KAAK,GAAG,GAAG;oBACT,MAAM,SAAS,aAAa;oBAC5B;gBACF,KAAK,GAAG,GAAG;oBACT,MAAM,SAAS,aAAa;oBAC5B;gBACF,KAAK,GAAG,GAAG;oBACT,MAAM,SAAS,aAAa;oBAC5B;gBACF,KAAK,GAAG,GAAG;oBACT,MAAM,SAAS,aAAa;oBAC5B;gBACF,KAAK,GAAG,GAAG;oBACT,MAAM,SAAS,aAAa;oBAC5B;gBACF,KAAK,GAAG,GAAG;oBACT,MAAM,SAAS,aAAa;oBAC5B;gBACF,KAAK,GAAG,GAAG;oBACT,MAAM,SAAS,aAAa;oBAC5B;gBACF,KAAK,GAAG,GAAG;oBACT,MAAM,SAAS,aAAa;oBAC5B;gBACF,KAAK,GAAG,GAAG;oBACT,MAAM,SAAS,aAAa;oBAC5B;gBACF,KAAK,GAAG,GAAG;oBACT,MAAM,SAAS,aAAa;oBAC5B;gBACF,KAAK,GAAG,GAAG;oBACT,MAAM,SAAS,aAAa;oBAC5B;gBACF,KAAK,GAAG,GAAG;oBACT,MAAM,SAAS,aAAa;oBAC5B;gBACF,KAAK,GAAG,GAAG;oBACT,MAAM,SAAS,aAAa;oBAC5B;gBACF,KAAK,GAAG,GAAG;oBACT,MAAM,SAAS,aAAa;oBAC5B;gBACF,KAAK,GAAG,GAAG;oBACT,MAAM,SAAS,aAAa;oBAC5B;gBACF;oBACE,MAAM;oBACN;YACJ;QACF;QACA,IAAI,CAAC,kBAAkB,cAAc,QAAQ,YAAY,GAAG,YAAY;YACtE,aAAa,cAAc,QAAQ,YAAY;QACjD;QACA,IAAI,SAAS,KAAK,KAAK,MAAM;YAC3B,0BAA0B,GAC1B,SAAS,KAAK,CAAC,OAAO,CAAC,IAAI;QAC7B;QACA,IAAI,SAAS,KAAK,KAAK,MAAM;YAC3B,kDAAkD,GAClD,MAAM,KAAK;YACX,SAAS,KAAK,CAAC,EAAE,CAAC,IAAI,QAAQ,KAAK,EAAE,aAAa,QAAQ,YAAY,EAAE,GAAG,MAAM,EAAE,GAAG,UAAU;QAClG;QACA,aAAa;QACb,OAAO;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 3979, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/apg-js/src/apg-lib/stats.js"],"sourcesContent":["/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module is the constructor for the statistics gathering object.\n// The statistics are nothing more than keeping a count of the\n// number of times each node in the parse tree is traversed.\n//\n// Counts are collected for each of the individual types of operators.\n// Additionally, counts are collected for each of the individually named\n// `RNM` and `UDT` operators.\nmodule.exports = function statsFunc() {\n  const id = require('./identifiers');\n  const utils = require('./utilities');\n  const style = require('./style');\n\n  const thisFileName = 'stats.js: ';\n  let rules = [];\n  let udts = [];\n  const stats = [];\n  let totals;\n  const ruleStats = [];\n  const udtStats = [];\n  this.statsObject = 'statsObject';\n  const nameId = 'stats';\n  /* `Array.sort()` callback function for sorting `RNM` and `UDT` operators alphabetically by name. */\n  const sortAlpha = function sortAlpha(lhs, rhs) {\n    if (lhs.lower < rhs.lower) {\n      return -1;\n    }\n    if (lhs.lower > rhs.lower) {\n      return 1;\n    }\n    return 0;\n  };\n  /* `Array.sort()` callback function for sorting `RNM` and `UDT` operators by hit count. */\n  const sortHits = function sortHits(lhs, rhs) {\n    if (lhs.total < rhs.total) {\n      return 1;\n    }\n    if (lhs.total > rhs.total) {\n      return -1;\n    }\n    return sortAlpha(lhs, rhs);\n  };\n  /* `Array.sort()` callback function for sorting `RNM` and `UDT` operators by index */\n  /* (in the order in which they appear in the SABNF grammar). */\n  const sortIndex = function sortIndex(lhs, rhs) {\n    if (lhs.index < rhs.index) {\n      return -1;\n    }\n    if (lhs.index > rhs.index) {\n      return 1;\n    }\n    return 0;\n  };\n  const EmptyStat = function EmptyStat() {\n    this.empty = 0;\n    this.match = 0;\n    this.nomatch = 0;\n    this.total = 0;\n  };\n  /* Zero out all stats */\n  const clear = function clear() {\n    stats.length = 0;\n    totals = new EmptyStat();\n    stats[id.ALT] = new EmptyStat();\n    stats[id.CAT] = new EmptyStat();\n    stats[id.REP] = new EmptyStat();\n    stats[id.RNM] = new EmptyStat();\n    stats[id.TRG] = new EmptyStat();\n    stats[id.TBS] = new EmptyStat();\n    stats[id.TLS] = new EmptyStat();\n    stats[id.UDT] = new EmptyStat();\n    stats[id.AND] = new EmptyStat();\n    stats[id.NOT] = new EmptyStat();\n    stats[id.BKR] = new EmptyStat();\n    stats[id.BKA] = new EmptyStat();\n    stats[id.BKN] = new EmptyStat();\n    stats[id.ABG] = new EmptyStat();\n    stats[id.AEN] = new EmptyStat();\n    ruleStats.length = 0;\n    for (let i = 0; i < rules.length; i += 1) {\n      ruleStats.push({\n        empty: 0,\n        match: 0,\n        nomatch: 0,\n        total: 0,\n        name: rules[i].name,\n        lower: rules[i].lower,\n        index: rules[i].index,\n      });\n    }\n    if (udts.length > 0) {\n      udtStats.length = 0;\n      for (let i = 0; i < udts.length; i += 1) {\n        udtStats.push({\n          empty: 0,\n          match: 0,\n          nomatch: 0,\n          total: 0,\n          name: udts[i].name,\n          lower: udts[i].lower,\n          index: udts[i].index,\n        });\n      }\n    }\n  };\n  /* increment the designated operator hit count by one */\n  const incStat = function incStat(stat, state) {\n    stat.total += 1;\n    switch (state) {\n      case id.EMPTY:\n        stat.empty += 1;\n        break;\n      case id.MATCH:\n        stat.match += 1;\n        break;\n      case id.NOMATCH:\n        stat.nomatch += 1;\n        break;\n      default:\n        throw new Error(`${thisFileName}collect(): incStat(): unrecognized state: ${state}`);\n    }\n  };\n  /* helper for toHtml() */\n  const displayRow = function displayRow(name, stat) {\n    let html = '';\n    html += '<tr>';\n    html += `<td class=\"${style.CLASS_ACTIVE}\">${name}</td>`;\n    html += `<td class=\"${style.CLASS_EMPTY}\">${stat.empty}</td>`;\n    html += `<td class=\"${style.CLASS_MATCH}\">${stat.match}</td>`;\n    html += `<td class=\"${style.CLASS_NOMATCH}\">${stat.nomatch}</td>`;\n    html += `<td class=\"${style.CLASS_ACTIVE}\">${stat.total}</td>`;\n    html += '</tr>\\n';\n    return html;\n  };\n  const displayOpsOnly = function displayOpsOnly() {\n    let html = '';\n    html += displayRow('ALT', stats[id.ALT]);\n    html += displayRow('CAT', stats[id.CAT]);\n    html += displayRow('REP', stats[id.REP]);\n    html += displayRow('RNM', stats[id.RNM]);\n    html += displayRow('TRG', stats[id.TRG]);\n    html += displayRow('TBS', stats[id.TBS]);\n    html += displayRow('TLS', stats[id.TLS]);\n    html += displayRow('UDT', stats[id.UDT]);\n    html += displayRow('AND', stats[id.AND]);\n    html += displayRow('NOT', stats[id.NOT]);\n    html += displayRow('BKR', stats[id.BKR]);\n    html += displayRow('BKA', stats[id.BKA]);\n    html += displayRow('BKN', stats[id.BKN]);\n    html += displayRow('ABG', stats[id.ABG]);\n    html += displayRow('AEN', stats[id.AEN]);\n    html += displayRow('totals', totals);\n    return html;\n  };\n  /* helper for toHtml() */\n  const displayRules = function displayRules() {\n    let html = '';\n    html += '<tr><th></th><th></th><th></th><th></th><th></th></tr>\\n';\n    html += '<tr><th>rules</th><th></th><th></th><th></th><th></th></tr>\\n';\n    for (let i = 0; i < rules.length; i += 1) {\n      if (ruleStats[i].total > 0) {\n        html += '<tr>';\n        html += `<td class=\"${style.CLASS_ACTIVE}\">${ruleStats[i].name}</td>`;\n        html += `<td class=\"${style.CLASS_EMPTY}\">${ruleStats[i].empty}</td>`;\n        html += `<td class=\"${style.CLASS_MATCH}\">${ruleStats[i].match}</td>`;\n        html += `<td class=\"${style.CLASS_NOMATCH}\">${ruleStats[i].nomatch}</td>`;\n        html += `<td class=\"${style.CLASS_ACTIVE}\">${ruleStats[i].total}</td>`;\n        html += '</tr>\\n';\n      }\n    }\n    if (udts.length > 0) {\n      html += '<tr><th></th><th></th><th></th><th></th><th></th></tr>\\n';\n      html += '<tr><th>udts</th><th></th><th></th><th></th><th></th></tr>\\n';\n      for (let i = 0; i < udts.length; i += 1) {\n        if (udtStats[i].total > 0) {\n          html += '<tr>';\n          html += `<td class=\"${style.CLASS_ACTIVE}\">${udtStats[i].name}</td>`;\n          html += `<td class=\"${style.CLASS_EMPTY}\">${udtStats[i].empty}</td>`;\n          html += `<td class=\"${style.CLASS_MATCH}\">${udtStats[i].match}</td>`;\n          html += `<td class=\"${style.CLASS_NOMATCH}\">${udtStats[i].nomatch}</td>`;\n          html += `<td class=\"${style.CLASS_ACTIVE}\">${udtStats[i].total}</td>`;\n          html += '</tr>\\n';\n        }\n      }\n    }\n    return html;\n  };\n  /* called only by the parser to validate a stats object */\n  this.validate = function validate(name) {\n    let ret = false;\n    if (typeof name === 'string' && nameId === name) {\n      ret = true;\n    }\n    return ret;\n  };\n  /* no verification of input - only called by parser() */\n  this.init = function init(inputRules, inputUdts) {\n    rules = inputRules;\n    udts = inputUdts;\n    clear();\n  };\n  /* This function is the main interaction with the parser. */\n  /* The parser calls it after each node has been traversed. */\n  this.collect = function collect(op, result) {\n    incStat(totals, result.state, result.phraseLength);\n    incStat(stats[op.type], result.state, result.phraseLength);\n    if (op.type === id.RNM) {\n      incStat(ruleStats[op.index], result.state, result.phraseLength);\n    }\n    if (op.type === id.UDT) {\n      incStat(udtStats[op.index], result.state, result.phraseLength);\n    }\n  };\n  // Display the statistics as an HTML table.\n  // - *type*\n  //   - \"ops\" - (default) display only the total hit counts for all operator types.\n  //   - \"index\" - additionally, display the hit counts for the individual `RNM` and `UDT` operators ordered by index.\n  //   - \"hits\" - additionally, display the hit counts for the individual `RNM` and `UDT` operators by hit count.\n  //   - \"alpha\" - additionally, display the hit counts for the individual `RNM` and `UDT` operators by name alphabetically.\n  // - *caption* - optional caption for the table\n  this.toHtml = function toHtml(type, caption) {\n    let html = '';\n    html += `<table class=\"${style.CLASS_STATS}\">\\n`;\n    if (typeof caption === 'string') {\n      html += `<caption>${caption}</caption>\\n`;\n    }\n    html += `<tr><th class=\"${style.CLASS_ACTIVE}\">ops</th>\\n`;\n    html += `<th class=\"${style.CLASS_EMPTY}\">EMPTY</th>\\n`;\n    html += `<th class=\"${style.CLASS_MATCH}\">MATCH</th>\\n`;\n    html += `<th class=\"${style.CLASS_NOMATCH}\">NOMATCH</th>\\n`;\n    html += `<th class=\"${style.CLASS_ACTIVE}\">totals</th></tr>\\n`;\n    const test = true;\n    while (test) {\n      if (type === undefined) {\n        html += displayOpsOnly();\n        break;\n      }\n      if (type === null) {\n        html += displayOpsOnly();\n        break;\n      }\n      if (type === 'ops') {\n        html += displayOpsOnly();\n        break;\n      }\n      if (type === 'index') {\n        ruleStats.sort(sortIndex);\n        if (udtStats.length > 0) {\n          udtStats.sort(sortIndex);\n        }\n        html += displayOpsOnly();\n        html += displayRules();\n        break;\n      }\n      if (type === 'hits') {\n        ruleStats.sort(sortHits);\n        if (udtStats.length > 0) {\n          udtStats.sort(sortIndex);\n        }\n        html += displayOpsOnly();\n        html += displayRules();\n        break;\n      }\n      if (type === 'alpha') {\n        ruleStats.sort(sortAlpha);\n        if (udtStats.length > 0) {\n          udtStats.sort(sortAlpha);\n        }\n        html += displayOpsOnly();\n        html += displayRules();\n        break;\n      }\n      break;\n    }\n    html += '</table>\\n';\n    return html;\n  };\n  // Display the stats table in a complete HTML5 page.\n  this.toHtmlPage = function toHtmlPage(type, caption, title) {\n    return utils.htmlToPage(this.toHtml(type, caption), title);\n  };\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 4253, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/apg-js/src/apg-lib/trace.js"],"sourcesContent":["/* eslint-disable func-names */\n/* eslint-disable prefer-destructuring */\n/* eslint-disable no-restricted-syntax */\n/* eslint-disable guard-for-in */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module provides a means of tracing the parser through the parse tree as it goes.\n// It is the primary debugging facility for debugging both the SABNF grammar syntax\n// and the input strings that are supposed to be valid grammar sentences.\n// It is also a very informative and educational tool for understanding\n// how a parser actually operates for a given language.\n//\n// Tracing is the process of generating and saving a record of information for each passage\n// of the parser through a parse tree node. And since it traverses each node twice, once down the tree\n// and once coming back up, there are two records for each node.\n// This, obviously, has the potential of generating lots of records.\n// And since these records are normally displayed on a web page\n// it is important to have a means to limit the actual number of records generated to\n// probably no more that a few thousand. This is almost always enough to find any errors.\n// The problem is to get the *right* few thousand records.\n// Therefore, this module has a number of ways of limiting and/or filtering, the number and type of records.\n// Considerable effort has been made to make this filtering of the trace output as simple\n// and intuitive as possible.\n//\n// However, the ability to filter the trace records, or for that matter even understand what they are\n// and the information they contain, does require a minimum amount of understanding of the APG parsing\n// method. The parse tree nodes are all represented by APG operators. They break down into two natural groups.\n// - The `RNM` operators and `UDT` operators are named phrases.\n// These are names chosen by the writer of the SABNF grammar to represent special phrases of interest.\n// - All others collect, concatenate and otherwise manipulate various intermediate phrases along the way.\n//\n// There are separate means of filtering which of these operators in each of these two groups get traced.\n// Let `trace` be an instantiated `trace.js` object.\n// Prior to parsing the string, filtering the rules and UDTs can be defined as follows:\n// ```\n// trace.filter.rules[\"rulename\"] = true;\n//     /* trace rule name \"rulename\" */\n// trace.filter.rules[\"udtname\"]  = true;\n//     /* trace UDT name \"udtname\" */\n// trace.filter.rules[\"<ALL>\"]    = true;\n//     /* trace all rules and UDTs (the default) */\n// trace.filter.rules[\"<NONE>\"]   = true;\n//     /* trace no rules or UDTS */\n// ```\n// If any rule or UDT name other than \"&lt;ALL>\" or \"&lt;NONE>\" is specified, all other names are turned off.\n// Therefore, to be selective of rule names, a filter statement is required for each rule/UDT name desired.\n//\n// Filtering of the other operators follows a similar procedure.\n// ```\n// trace.filter.operators[\"TRG\"] = true;\n//     /* trace the terminal range, TRG, operators */\n// trace.filter.operators[\"CAT\"]  = true;\n//     /* trace the concatenations, CAT, operators */\n// trace.filter.operators[\"<ALL>\"]    = true;\n//     /* trace all operators */\n// trace.filter.operators[\"<NONE>\"]   = true;\n//     /* trace no operators (the default) */\n// ```\n// If any operator name other than \"&lt;ALL>\" or \"&lt;NONE>\" is specified, all other names are turned off.\n// Therefore, to be selective of operator names, a filter statement is required for each name desired.\n//\n// There is, additionally, a means for limiting the total number of filtered or saved trace records.\n// See the function, `setMaxRecords(max)` below. This will result in only the last `max` records being saved.\n//\n// (See [`apg-examples`](https://github.com/ldthomas/apg-js-examples) for examples of using `trace.js`.)\nmodule.exports = function exportTrace() {\n  const utils = require('./utilities');\n  const style = require('./style');\n  const circular = new (require('./circular-buffer'))();\n  const id = require('./identifiers');\n\n  const thisFileName = 'trace.js: ';\n  const that = this;\n  const MODE_HEX = 16;\n  const MODE_DEC = 10;\n  const MODE_ASCII = 8;\n  const MODE_UNICODE = 32;\n  const MAX_PHRASE = 80;\n  const MAX_TLS = 5;\n  const records = [];\n  let maxRecords = 5000;\n  let lastRecord = -1;\n  let filteredRecords = 0;\n  let treeDepth = 0;\n  const recordStack = [];\n  let chars = null;\n  let rules = null;\n  let udts = null;\n  const operatorFilter = [];\n  const ruleFilter = [];\n  /* special trace table phrases */\n  const PHRASE_END = `<span class=\"${style.CLASS_LINEEND}\">&bull;</span>`;\n  const PHRASE_CONTINUE = `<span class=\"${style.CLASS_LINEEND}\">&hellip;</span>`;\n  const PHRASE_EMPTY = `<span class=\"${style.CLASS_EMPTY}\">&#120634;</span>`;\n  /* filter the non-RNM & non-UDT operators */\n  const initOperatorFilter = function () {\n    const setOperators = function (set) {\n      operatorFilter[id.ALT] = set;\n      operatorFilter[id.CAT] = set;\n      operatorFilter[id.REP] = set;\n      operatorFilter[id.TLS] = set;\n      operatorFilter[id.TBS] = set;\n      operatorFilter[id.TRG] = set;\n      operatorFilter[id.AND] = set;\n      operatorFilter[id.NOT] = set;\n      operatorFilter[id.BKR] = set;\n      operatorFilter[id.BKA] = set;\n      operatorFilter[id.BKN] = set;\n      operatorFilter[id.ABG] = set;\n      operatorFilter[id.AEN] = set;\n    };\n    let items = 0;\n    // eslint-disable-next-line no-unused-vars\n    for (const name in that.filter.operators) {\n      items += 1;\n    }\n    if (items === 0) {\n      /* case 1: no operators specified: default: do not trace any operators */\n      setOperators(false);\n      return;\n    }\n    for (const name in that.filter.operators) {\n      const upper = name.toUpperCase();\n      if (upper === '<ALL>') {\n        /* case 2: <all> operators specified: trace all operators ignore all other operator commands */\n        setOperators(true);\n        return;\n      }\n      if (upper === '<NONE>') {\n        /* case 3: <none> operators specified: trace NO operators ignore all other operator commands */\n        setOperators(false);\n        return;\n      }\n    }\n    setOperators(false);\n    for (const name in that.filter.operators) {\n      const upper = name.toUpperCase();\n      /* case 4: one or more individual operators specified: trace 'true' operators only */\n      if (upper === 'ALT') {\n        operatorFilter[id.ALT] = that.filter.operators[name] === true;\n      } else if (upper === 'CAT') {\n        operatorFilter[id.CAT] = that.filter.operators[name] === true;\n      } else if (upper === 'REP') {\n        operatorFilter[id.REP] = that.filter.operators[name] === true;\n      } else if (upper === 'AND') {\n        operatorFilter[id.AND] = that.filter.operators[name] === true;\n      } else if (upper === 'NOT') {\n        operatorFilter[id.NOT] = that.filter.operators[name] === true;\n      } else if (upper === 'TLS') {\n        operatorFilter[id.TLS] = that.filter.operators[name] === true;\n      } else if (upper === 'TBS') {\n        operatorFilter[id.TBS] = that.filter.operators[name] === true;\n      } else if (upper === 'TRG') {\n        operatorFilter[id.TRG] = that.filter.operators[name] === true;\n      } else if (upper === 'BKR') {\n        operatorFilter[id.BKR] = that.filter.operators[name] === true;\n      } else if (upper === 'BKA') {\n        operatorFilter[id.BKA] = that.filter.operators[name] === true;\n      } else if (upper === 'BKN') {\n        operatorFilter[id.BKN] = that.filter.operators[name] === true;\n      } else if (upper === 'ABG') {\n        operatorFilter[id.ABG] = that.filter.operators[name] === true;\n      } else if (upper === 'AEN') {\n        operatorFilter[id.AEN] = that.filter.operators[name] === true;\n      } else {\n        throw new Error(\n          `${thisFileName}initOpratorFilter: '${name}' not a valid operator name.` +\n            ` Must be <all>, <none>, alt, cat, rep, tls, tbs, trg, and, not, bkr, bka or bkn`\n        );\n      }\n    }\n  };\n  /* filter the rule and `UDT` named operators */\n  const initRuleFilter = function () {\n    const setRules = function (set) {\n      operatorFilter[id.RNM] = set;\n      operatorFilter[id.UDT] = set;\n      const count = rules.length + udts.length;\n      ruleFilter.length = 0;\n      for (let i = 0; i < count; i += 1) {\n        ruleFilter.push(set);\n      }\n    };\n    let items;\n    let i;\n    const list = [];\n    for (i = 0; i < rules.length; i += 1) {\n      list.push(rules[i].lower);\n    }\n    for (i = 0; i < udts.length; i += 1) {\n      list.push(udts[i].lower);\n    }\n    ruleFilter.length = 0;\n    items = 0;\n    // eslint-disable-next-line no-unused-vars\n    for (const name in that.filter.rules) {\n      items += 1;\n    }\n    if (items === 0) {\n      /* case 1: default to all rules & udts */\n      setRules(true);\n      return;\n    }\n    for (const name in that.filter.rules) {\n      const lower = name.toLowerCase();\n      if (lower === '<all>') {\n        /* case 2: trace all rules ignore all other rule commands */\n        setRules(true);\n        return;\n      }\n      if (lower === '<none>') {\n        /* case 3: trace no rules */\n        setRules(false);\n        return;\n      }\n    }\n    /* case 4: trace only individually specified rules */\n    setRules(false);\n    operatorFilter[id.RNM] = true;\n    operatorFilter[id.UDT] = true;\n    for (const name in that.filter.rules) {\n      const lower = name.toLowerCase();\n      i = list.indexOf(lower);\n      if (i < 0) {\n        throw new Error(`${thisFileName}initRuleFilter: '${name}' not a valid rule or udt name`);\n      }\n      ruleFilter[i] = that.filter.rules[name] === true;\n    }\n  };\n  /* used by other APG components to verify that they have a valid trace object */\n  this.traceObject = 'traceObject';\n  this.filter = {\n    operators: [],\n    rules: [],\n  };\n  // Set the maximum number of records to keep (default = 5000).\n  // Each record number larger than `maxRecords`\n  // will result in deleting the previously oldest record.\n  // - `max`: maximum number of records to retain (default = 5000)\n  // - `last`: last record number to retain, (default = -1 for (unknown) actual last record)\n  this.setMaxRecords = function (max, last) {\n    lastRecord = -1;\n    if (typeof max === 'number' && max > 0) {\n      maxRecords = Math.ceil(max);\n    } else {\n      maxRecords = 0;\n      return;\n    }\n    if (typeof last === 'number') {\n      lastRecord = Math.floor(last);\n      if (lastRecord < 0) {\n        lastRecord = -1;\n      }\n    }\n  };\n  // Returns `maxRecords` to the caller.\n  this.getMaxRecords = function () {\n    return maxRecords;\n  };\n  // Returns `lastRecord` to the caller.\n  this.getLastRecord = function () {\n    return lastRecord;\n  };\n  /* Called only by the `parser.js` object. No verification of input. */\n  this.init = function (rulesIn, udtsIn, charsIn) {\n    records.length = 0;\n    recordStack.length = 0;\n    filteredRecords = 0;\n    treeDepth = 0;\n    chars = charsIn;\n    rules = rulesIn;\n    udts = udtsIn;\n    initOperatorFilter();\n    initRuleFilter();\n    circular.init(maxRecords);\n  };\n  /* returns true if this records passes through the designated filter, false if the record is to be skipped */\n  const filterOps = function (op) {\n    let ret = false;\n    if (op.type === id.RNM) {\n      if (operatorFilter[op.type] && ruleFilter[op.index]) {\n        ret = true;\n      } else {\n        ret = false;\n      }\n    } else if (op.type === id.UDT) {\n      if (operatorFilter[op.type] && ruleFilter[rules.length + op.index]) {\n        ret = true;\n      } else {\n        ret = false;\n      }\n    } else {\n      ret = operatorFilter[op.type];\n    }\n    return ret;\n  };\n  const filterRecords = function (record) {\n    if (lastRecord === -1) {\n      return true;\n    }\n    if (record <= lastRecord) {\n      return true;\n    }\n    return false;\n  };\n  /* Collect the \"down\" record. */\n  this.down = function (op, state, offset, length, anchor, lookAround) {\n    if (filterRecords(filteredRecords) && filterOps(op)) {\n      recordStack.push(filteredRecords);\n      records[circular.increment()] = {\n        dirUp: false,\n        depth: treeDepth,\n        thisLine: filteredRecords,\n        thatLine: undefined,\n        opcode: op,\n        state,\n        phraseIndex: offset,\n        phraseLength: length,\n        lookAnchor: anchor,\n        lookAround,\n      };\n      filteredRecords += 1;\n      treeDepth += 1;\n    }\n  };\n  /* Collect the \"up\" record. */\n  this.up = function (op, state, offset, length, anchor, lookAround) {\n    if (filterRecords(filteredRecords) && filterOps(op)) {\n      const thisLine = filteredRecords;\n      const thatLine = recordStack.pop();\n      const thatRecord = circular.getListIndex(thatLine);\n      if (thatRecord !== -1) {\n        records[thatRecord].thatLine = thisLine;\n      }\n      treeDepth -= 1;\n      records[circular.increment()] = {\n        dirUp: true,\n        depth: treeDepth,\n        thisLine,\n        thatLine,\n        opcode: op,\n        state,\n        phraseIndex: offset,\n        phraseLength: length,\n        lookAnchor: anchor,\n        lookAround,\n      };\n      filteredRecords += 1;\n    }\n  };\n  /* convert the trace records to a tree of nodes */\n  const toTreeObj = function () {\n    /* private helper functions */\n    function nodeOpcode(node, opcode) {\n      let name;\n      let casetype;\n      let modetype;\n      if (opcode) {\n        node.op = { id: opcode.type, name: utils.opcodeToString(opcode.type) };\n        node.opData = undefined;\n        switch (opcode.type) {\n          case id.RNM:\n            node.opData = rules[opcode.index].name;\n            break;\n          case id.UDT:\n            node.opData = udts[opcode.index].name;\n            break;\n          case id.BKR:\n            if (opcode.index < rules.length) {\n              name = rules[opcode.index].name;\n            } else {\n              name = udts[opcode.index - rules.length].name;\n            }\n            casetype = opcode.bkrCase === id.BKR_MODE_CI ? '%i' : '%s';\n            modetype = opcode.bkrMode === id.BKR_MODE_UM ? '%u' : '%p';\n            node.opData = `\\\\\\\\${casetype}${modetype}${name}`;\n            break;\n          case id.TLS:\n            node.opData = [];\n            for (let i = 0; i < opcode.string.length; i += 1) {\n              node.opData.push(opcode.string[i]);\n            }\n            break;\n          case id.TBS:\n            node.opData = [];\n            for (let i = 0; i < opcode.string.length; i += 1) {\n              node.opData.push(opcode.string[i]);\n            }\n            break;\n          case id.TRG:\n            node.opData = [opcode.min, opcode.max];\n            break;\n          case id.REP:\n            node.opData = [opcode.min, opcode.max];\n            break;\n          default:\n            throw new Error('unrecognized opcode');\n        }\n      } else {\n        node.op = { id: undefined, name: undefined };\n        node.opData = undefined;\n      }\n    }\n    function nodePhrase(state, index, length) {\n      if (state === id.MATCH) {\n        return {\n          index,\n          length,\n        };\n      }\n      if (state === id.NOMATCH) {\n        return {\n          index,\n          length: 0,\n        };\n      }\n      if (state === id.EMPTY) {\n        return {\n          index,\n          length: 0,\n        };\n      }\n      return null;\n    }\n    let nodeId = -1;\n    function nodeDown(parent, record, depth) {\n      const node = {\n        // eslint-disable-next-line no-plusplus\n        id: nodeId++,\n        branch: -1,\n        parent,\n        up: false,\n        down: false,\n        depth,\n        children: [],\n      };\n      if (record) {\n        node.down = true;\n        node.state = { id: record.state, name: utils.stateToString(record.state) };\n        node.phrase = null;\n        nodeOpcode(node, record.opcode);\n      } else {\n        node.state = { id: undefined, name: undefined };\n        node.phrase = nodePhrase();\n        nodeOpcode(node, undefined);\n      }\n      return node;\n    }\n    function nodeUp(node, record) {\n      if (record) {\n        node.up = true;\n        node.state = { id: record.state, name: utils.stateToString(record.state) };\n        node.phrase = nodePhrase(record.state, record.phraseIndex, record.phraseLength);\n        if (!node.down) {\n          nodeOpcode(node, record.opcode);\n        }\n      }\n    }\n    /* walk the final tree: label branches and count leaf nodes */\n    let leafNodes = 0;\n    let depth = -1;\n    let branchCount = 1;\n    function walk(node) {\n      depth += 1;\n      node.branch = branchCount;\n      if (depth > treeDepth) {\n        treeDepth = depth;\n      }\n      if (node.children.length === 0) {\n        leafNodes += 1;\n      } else {\n        for (let i = 0; i < node.children.length; i += 1) {\n          if (i > 0) {\n            branchCount += 1;\n          }\n          node.children[i].leftMost = false;\n          node.children[i].rightMost = false;\n          if (node.leftMost) {\n            node.children[i].leftMost = i === 0;\n          }\n          if (node.rightMost) {\n            node.children[i].rightMost = i === node.children.length - 1;\n          }\n          walk(node.children[i]);\n        }\n      }\n      depth -= 1;\n    }\n    function display(node, offset) {\n      let name;\n      const obj = {};\n      obj.id = node.id;\n      obj.branch = node.branch;\n      obj.leftMost = node.leftMost;\n      obj.rightMost = node.rightMost;\n      name = node.state.name ? node.state.name : 'ACTIVE';\n      obj.state = { id: node.state.id, name };\n      name = node.op.name ? node.op.name : '?';\n      obj.op = { id: node.op.id, name };\n      if (typeof node.opData === 'string') {\n        obj.opData = node.opData;\n      } else if (Array.isArray(node.opData)) {\n        obj.opData = [];\n        for (let i = 0; i < node.opData.length; i += 1) {\n          obj.opData[i] = node.opData[i];\n        }\n      } else {\n        obj.opData = undefined;\n      }\n      if (node.phrase) {\n        obj.phrase = { index: node.phrase.index, length: node.phrase.length };\n      } else {\n        obj.phrase = null;\n      }\n      obj.depth = node.depth;\n      obj.children = [];\n      for (let i = 0; i < node.children.length; i += 1) {\n        const c = i !== node.children.length - 1;\n        obj.children[i] = display(node.children[i], offset, c);\n      }\n      return obj;\n    }\n\n    /* construct the tree beginning here */\n    const branch = [];\n    let root;\n    let node;\n    let parent;\n    let record;\n    let firstRecord = true;\n    /* push a dummy node so the root node will have a non-null parent */\n    const dummy = nodeDown(null, null, -1);\n    branch.push(dummy);\n    node = dummy;\n    circular.forEach((lineIndex) => {\n      record = records[lineIndex];\n      if (firstRecord) {\n        firstRecord = false;\n        if (record.depth > 0) {\n          /* push some dummy nodes to fill in for missing records */\n          const num = record.dirUp ? record.depth + 1 : record.depth;\n          for (let i = 0; i < num; i += 1) {\n            parent = node;\n            node = nodeDown(node, null, i);\n            branch.push(node);\n            parent.children.push(node);\n          }\n        }\n      }\n      if (record.dirUp) {\n        /* handle the next record up */\n        node = branch.pop();\n        nodeUp(node, record);\n        node = branch[branch.length - 1];\n      } else {\n        /* handle the next record down */\n        parent = node;\n        node = nodeDown(node, record, record.depth);\n        branch.push(node);\n        parent.children.push(node);\n      }\n    });\n\n    /* if not at root, walk it up to root */\n    while (branch.length > 1) {\n      node = branch.pop();\n      nodeUp(node, null);\n    }\n    /* maybe redundant or paranoid tests: these should never happen */\n    if (dummy.children.length === 0) {\n      throw new Error('trace.toTree(): parse tree has no nodes');\n    }\n    if (branch.length === 0) {\n      throw new Error('trace.toTree(): integrity check: dummy root node disappeared?');\n    }\n\n    /* if no record for start rule: find the pseudo root node (first dummy node above a real node) */\n    root = dummy.children[0];\n    let prev = root;\n    while (root && !root.down && !root.up) {\n      prev = root;\n      root = root.children[0];\n    }\n    root = prev;\n\n    /* walk the tree of nodes: label brances and count leaves */\n    root.leftMost = true;\n    root.rightMost = true;\n    walk(root);\n    root.branch = 0;\n\n    /* generate the exported object */\n    const obj = {};\n    obj.string = [];\n    for (let i = 0; i < chars.length; i += 1) {\n      obj.string[i] = chars[i];\n    }\n    /* generate the exported rule names */\n    obj.rules = [];\n    for (let i = 0; i < rules.length; i += 1) {\n      obj.rules[i] = rules[i].name;\n    }\n    /* generate the exported UDT names */\n    obj.udts = [];\n    for (let i = 0; i < udts.length; i += 1) {\n      obj.udts[i] = udts[i].name;\n    }\n    /* generate the ids */\n    obj.id = {};\n    obj.id.ALT = { id: id.ALT, name: 'ALT' };\n    obj.id.CAT = { id: id.CAT, name: 'CAT' };\n    obj.id.REP = { id: id.REP, name: 'REP' };\n    obj.id.RNM = { id: id.RNM, name: 'RNM' };\n    obj.id.TLS = { id: id.TLS, name: 'TLS' };\n    obj.id.TBS = { id: id.TBS, name: 'TBS' };\n    obj.id.TRG = { id: id.TRG, name: 'TRG' };\n    obj.id.UDT = { id: id.UDT, name: 'UDT' };\n    obj.id.AND = { id: id.AND, name: 'AND' };\n    obj.id.NOT = { id: id.NOT, name: 'NOT' };\n    obj.id.BKR = { id: id.BKR, name: 'BKR' };\n    obj.id.BKA = { id: id.BKA, name: 'BKA' };\n    obj.id.BKN = { id: id.BKN, name: 'BKN' };\n    obj.id.ABG = { id: id.ABG, name: 'ABG' };\n    obj.id.AEN = { id: id.AEN, name: 'AEN' };\n    obj.id.ACTIVE = { id: id.ACTIVE, name: 'ACTIVE' };\n    obj.id.MATCH = { id: id.MATCH, name: 'MATCH' };\n    obj.id.EMPTY = { id: id.EMPTY, name: 'EMPTY' };\n    obj.id.NOMATCH = { id: id.NOMATCH, name: 'NOMATCH' };\n    /* generate the max tree depth */\n    obj.treeDepth = treeDepth;\n    /* generate the number of leaf nodes (branches) */\n    obj.leafNodes = leafNodes;\n    /* generate the types of the left- and right-most branches */\n    let branchesIncomplete;\n    if (root.down) {\n      if (root.up) {\n        branchesIncomplete = 'none';\n      } else {\n        branchesIncomplete = 'right';\n      }\n    } else if (root.up) {\n      branchesIncomplete = 'left';\n    } else {\n      branchesIncomplete = 'both';\n    }\n    obj.branchesIncomplete = branchesIncomplete;\n    obj.tree = display(root, root.depth, false);\n    return obj;\n  };\n  // Returns the trace records as JSON parse tree object.\n  // - stringify: if `true`, the object is 'stringified' before returning, otherwise, the object itself is returned.\n  this.toTree = function (stringify) {\n    const obj = toTreeObj();\n    if (stringify) {\n      return JSON.stringify(obj);\n    }\n    return obj;\n  };\n  // Translate the trace records to HTML format and create a complete HTML page for browser display.\n  this.toHtmlPage = function (mode, caption, title) {\n    return utils.htmlToPage(this.toHtml(mode, caption), title);\n  };\n\n  /* From here on down, these are just helper functions for `toHtml()`. */\n  const htmlHeader = function (mode, caption) {\n    /* open the page */\n    /* write the HTML5 header with table style */\n    /* open the <table> tag */\n    let modeName;\n    switch (mode) {\n      case MODE_HEX:\n        modeName = 'hexadecimal';\n        break;\n      case MODE_DEC:\n        modeName = 'decimal';\n        break;\n      case MODE_ASCII:\n        modeName = 'ASCII';\n        break;\n      case MODE_UNICODE:\n        modeName = 'UNICODE';\n        break;\n      default:\n        throw new Error(`${thisFileName}htmlHeader: unrecognized mode: ${mode}`);\n    }\n    let header = '';\n    header += `<p>display mode: ${modeName}</p>\\n`;\n    header += `<table class=\"${style.CLASS_TRACE}\">\\n`;\n    if (typeof caption === 'string') {\n      header += `<caption>${caption}</caption>`;\n    }\n    return header;\n  };\n  const htmlFooter = function () {\n    let footer = '';\n    /* close the </table> tag */\n    footer += '</table>\\n';\n    /* display a table legend */\n    footer += `<p class=\"${style.CLASS_MONOSPACE}\">legend:<br>\\n`;\n    footer += '(a)&nbsp;-&nbsp;line number<br>\\n';\n    footer += '(b)&nbsp;-&nbsp;matching line number<br>\\n';\n    footer += '(c)&nbsp;-&nbsp;phrase offset<br>\\n';\n    footer += '(d)&nbsp;-&nbsp;phrase length<br>\\n';\n    footer += '(e)&nbsp;-&nbsp;tree depth<br>\\n';\n    footer += '(f)&nbsp;-&nbsp;operator state<br>\\n';\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_ACTIVE}\">&darr;</span>&nbsp;&nbsp;phrase opened<br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_MATCH}\">&uarr;M</span> phrase matched<br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_EMPTY}\">&uarr;E</span> empty phrase matched<br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_NOMATCH}\">&uarr;N</span> phrase not matched<br>\\n`;\n    footer +=\n      'operator&nbsp;-&nbsp;ALT, CAT, REP, RNM, TRG, TLS, TBS<sup>&dagger;</sup>, UDT, AND, NOT, BKA, BKN, BKR, ABG, AEN<sup>&Dagger;</sup><br>\\n';\n    footer += `phrase&nbsp;&nbsp;&nbsp;-&nbsp;up to ${MAX_PHRASE} characters of the phrase being matched<br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_MATCH}\">matched characters</span><br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_LOOKAHEAD}\">matched characters in look ahead mode</span><br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_LOOKBEHIND}\">matched characters in look behind mode</span><br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_REMAINDER}\">remainder characters(not yet examined by parser)</span><br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class=\"${style.CLASS_CTRLCHAR}\">control characters, TAB, LF, CR, etc. (ASCII mode only)</span><br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${PHRASE_EMPTY} empty string<br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${PHRASE_END} end of input string<br>\\n`;\n    footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${PHRASE_CONTINUE} input string display truncated<br>\\n`;\n    footer += '</p>\\n';\n    footer += `<p class=\"${style.CLASS_MONOSPACE}\">\\n`;\n    footer += '<sup>&dagger;</sup>original ABNF operators:<br>\\n';\n    footer += 'ALT - alternation<br>\\n';\n    footer += 'CAT - concatenation<br>\\n';\n    footer += 'REP - repetition<br>\\n';\n    footer += 'RNM - rule name<br>\\n';\n    footer += 'TRG - terminal range<br>\\n';\n    footer += 'TLS - terminal literal string (case insensitive)<br>\\n';\n    footer += 'TBS - terminal binary string (case sensitive)<br>\\n';\n    footer += '<br>\\n';\n    footer += '<sup>&Dagger;</sup>super set SABNF operators:<br>\\n';\n    footer += 'UDT - user-defined terminal<br>\\n';\n    footer += 'AND - positive look ahead<br>\\n';\n    footer += 'NOT - negative look ahead<br>\\n';\n    footer += 'BKA - positive look behind<br>\\n';\n    footer += 'BKN - negative look behind<br>\\n';\n    footer += 'BKR - back reference<br>\\n';\n    footer += 'ABG - anchor - begin of input string<br>\\n';\n    footer += 'AEN - anchor - end of input string<br>\\n';\n    footer += '</p>\\n';\n    return footer;\n  };\n  this.indent = function (depth) {\n    let html = '';\n    for (let i = 0; i < depth; i += 1) {\n      html += '.';\n    }\n    return html;\n  };\n  /* format the TRG operator */\n  const displayTrg = function (mode, op) {\n    let html = '';\n    if (op.type === id.TRG) {\n      if (mode === MODE_HEX || mode === MODE_UNICODE) {\n        let hex = op.min.toString(16).toUpperCase();\n        if (hex.length % 2 !== 0) {\n          hex = `0${hex}`;\n        }\n        html += mode === MODE_HEX ? '%x' : 'U+';\n        html += hex;\n        hex = op.max.toString(16).toUpperCase();\n        if (hex.length % 2 !== 0) {\n          hex = `0${hex}`;\n        }\n        html += `&ndash;${hex}`;\n      } else {\n        html = `%d${op.min.toString(10)}&ndash;${op.max.toString(10)}`;\n      }\n    }\n    return html;\n  };\n  /* format the REP operator */\n  const displayRep = function (mode, op) {\n    let html = '';\n    if (op.type === id.REP) {\n      if (mode === MODE_HEX) {\n        let hex = op.min.toString(16).toUpperCase();\n        if (hex.length % 2 !== 0) {\n          hex = `0${hex}`;\n        }\n        html = `x${hex}`;\n        if (op.max < Infinity) {\n          hex = op.max.toString(16).toUpperCase();\n          if (hex.length % 2 !== 0) {\n            hex = `0${hex}`;\n          }\n        } else {\n          hex = 'inf';\n        }\n        html += `&ndash;${hex}`;\n      } else if (op.max < Infinity) {\n        html = `${op.min.toString(10)}&ndash;${op.max.toString(10)}`;\n      } else {\n        html = `${op.min.toString(10)}&ndash;inf`;\n      }\n    }\n    return html;\n  };\n  /* format the TBS operator */\n  const displayTbs = function (mode, op) {\n    let html = '';\n    if (op.type === id.TBS) {\n      const len = Math.min(op.string.length, MAX_TLS * 2);\n      if (mode === MODE_HEX || mode === MODE_UNICODE) {\n        html += mode === MODE_HEX ? '%x' : 'U+';\n        for (let i = 0; i < len; i += 1) {\n          let hex;\n          if (i > 0) {\n            html += '.';\n          }\n          hex = op.string[i].toString(16).toUpperCase();\n          if (hex.length % 2 !== 0) {\n            hex = `0${hex}`;\n          }\n          html += hex;\n        }\n      } else {\n        html = '%d';\n        for (let i = 0; i < len; i += 1) {\n          if (i > 0) {\n            html += '.';\n          }\n          html += op.string[i].toString(10);\n        }\n      }\n      if (len < op.string.length) {\n        html += PHRASE_CONTINUE;\n      }\n    }\n    return html;\n  };\n  /* format the TLS operator */\n  const displayTls = function (mode, op) {\n    let html = '';\n    if (op.type === id.TLS) {\n      const len = Math.min(op.string.length, MAX_TLS);\n      if (mode === MODE_HEX || mode === MODE_DEC) {\n        let charu;\n        let charl;\n        let base;\n        if (mode === MODE_HEX) {\n          html = '%x';\n          base = 16;\n        } else {\n          html = '%d';\n          base = 10;\n        }\n        for (let i = 0; i < len; i += 1) {\n          if (i > 0) {\n            html += '.';\n          }\n          charl = op.string[i];\n          if (charl >= 97 && charl <= 122) {\n            charu = charl - 32;\n            html += `${charu.toString(base)}/${charl.toString(base)}`.toUpperCase();\n          } else if (charl >= 65 && charl <= 90) {\n            charu = charl;\n            charl += 32;\n            html += `${charu.toString(base)}/${charl.toString(base)}`.toUpperCase();\n          } else {\n            html += charl.toString(base).toUpperCase();\n          }\n        }\n        if (len < op.string.length) {\n          html += PHRASE_CONTINUE;\n        }\n      } else {\n        html = '\"';\n        for (let i = 0; i < len; i += 1) {\n          html += utils.asciiChars[op.string[i]];\n        }\n        if (len < op.string.length) {\n          html += PHRASE_CONTINUE;\n        }\n        html += '\"';\n      }\n    }\n    return html;\n  };\n  const subPhrase = function (mode, charsArg, index, length, prev) {\n    if (length === 0) {\n      return '';\n    }\n    let phrase = '';\n    const comma = prev ? ',' : '';\n    switch (mode) {\n      case MODE_HEX:\n        phrase = comma + utils.charsToHex(charsArg, index, length);\n        break;\n      case MODE_DEC:\n        if (prev) {\n          return `,${utils.charsToDec(charsArg, index, length)}`;\n        }\n        phrase = comma + utils.charsToDec(charsArg, index, length);\n        break;\n      case MODE_UNICODE:\n        phrase = utils.charsToUnicode(charsArg, index, length);\n        break;\n      case MODE_ASCII:\n      default:\n        phrase = utils.charsToAsciiHtml(charsArg, index, length);\n        break;\n    }\n    return phrase;\n  };\n  /* display phrases matched in look-behind mode */\n  const displayBehind = function (mode, charsArg, state, index, length, anchor) {\n    let html = '';\n    let beg1;\n    let len1;\n    let beg2;\n    let len2;\n    let lastchar = PHRASE_END;\n    const spanBehind = `<span class=\"${style.CLASS_LOOKBEHIND}\">`;\n    const spanRemainder = `<span class=\"${style.CLASS_REMAINDER}\">`;\n    const spanend = '</span>';\n    let prev = false;\n    switch (state) {\n      case id.EMPTY:\n        html += PHRASE_EMPTY;\n      /* // eslint-disable-next-line no-fallthrough */\n      case id.NOMATCH:\n      case id.MATCH:\n      case id.ACTIVE:\n        beg1 = index - length;\n        len1 = anchor - beg1;\n        beg2 = anchor;\n        len2 = charsArg.length - beg2;\n        break;\n      default:\n        throw new Error('unrecognized state');\n    }\n    lastchar = PHRASE_END;\n    if (len1 > MAX_PHRASE) {\n      len1 = MAX_PHRASE;\n      lastchar = PHRASE_CONTINUE;\n      len2 = 0;\n    } else if (len1 + len2 > MAX_PHRASE) {\n      lastchar = PHRASE_CONTINUE;\n      len2 = MAX_PHRASE - len1;\n    }\n    if (len1 > 0) {\n      html += spanBehind;\n      html += subPhrase(mode, charsArg, beg1, len1, prev);\n      html += spanend;\n      prev = true;\n    }\n    if (len2 > 0) {\n      html += spanRemainder;\n      html += subPhrase(mode, charsArg, beg2, len2, prev);\n      html += spanend;\n    }\n    return html + lastchar;\n  };\n  const displayForward = function (mode, charsArg, state, index, length, spanAhead) {\n    let html = '';\n    let beg1;\n    let len1;\n    let beg2;\n    let len2;\n    let lastchar = PHRASE_END;\n    const spanRemainder = `<span class=\"${style.CLASS_REMAINDER}\">`;\n    const spanend = '</span>';\n    let prev = false;\n    switch (state) {\n      case id.EMPTY:\n        html += PHRASE_EMPTY;\n      /* // eslint-disable-next-line no-fallthrough */\n      case id.NOMATCH:\n      case id.ACTIVE:\n        beg1 = index;\n        len1 = 0;\n        beg2 = index;\n        len2 = charsArg.length - beg2;\n        break;\n      case id.MATCH:\n        beg1 = index;\n        len1 = length;\n        beg2 = index + len1;\n        len2 = charsArg.length - beg2;\n        break;\n      default:\n        throw new Error('unrecognized state');\n    }\n    lastchar = PHRASE_END;\n    if (len1 > MAX_PHRASE) {\n      len1 = MAX_PHRASE;\n      lastchar = PHRASE_CONTINUE;\n      len2 = 0;\n    } else if (len1 + len2 > MAX_PHRASE) {\n      lastchar = PHRASE_CONTINUE;\n      len2 = MAX_PHRASE - len1;\n    }\n    if (len1 > 0) {\n      html += spanAhead;\n      html += subPhrase(mode, charsArg, beg1, len1, prev);\n      html += spanend;\n      prev = true;\n    }\n    if (len2 > 0) {\n      html += spanRemainder;\n      html += subPhrase(mode, charsArg, beg2, len2, prev);\n      html += spanend;\n    }\n    return html + lastchar;\n  };\n  /* display phrases matched in look-ahead mode */\n  const displayAhead = function (mode, charsArg, state, index, length) {\n    const spanAhead = `<span class=\"${style.CLASS_LOOKAHEAD}\">`;\n    return displayForward(mode, charsArg, state, index, length, spanAhead);\n  };\n  /* display phrases matched in normal parsing mode */\n  const displayNone = function (mode, charsArg, state, index, length) {\n    const spanAhead = `<span class=\"${style.CLASS_MATCH}\">`;\n    return displayForward(mode, charsArg, state, index, length, spanAhead);\n  };\n  /* Returns the filtered records, formatted as an HTML table. */\n  const htmlTable = function (mode) {\n    if (rules === null) {\n      return '';\n    }\n    let html = '';\n    let thisLine;\n    let thatLine;\n    let lookAhead;\n    let lookBehind;\n    let lookAround;\n    let anchor;\n    html += '<tr><th>(a)</th><th>(b)</th><th>(c)</th><th>(d)</th><th>(e)</th><th>(f)</th>';\n    html += '<th>operator</th><th>phrase</th></tr>\\n';\n    circular.forEach((lineIndex) => {\n      const line = records[lineIndex];\n      thisLine = line.thisLine;\n      thatLine = line.thatLine !== undefined ? line.thatLine : '--';\n      lookAhead = false;\n      lookBehind = false;\n      lookAround = false;\n      if (line.lookAround === id.LOOKAROUND_AHEAD) {\n        lookAhead = true;\n        lookAround = true;\n        anchor = line.lookAnchor;\n      }\n      if (line.opcode.type === id.AND || line.opcode.type === id.NOT) {\n        lookAhead = true;\n        lookAround = true;\n        anchor = line.phraseIndex;\n      }\n      if (line.lookAround === id.LOOKAROUND_BEHIND) {\n        lookBehind = true;\n        lookAround = true;\n        anchor = line.lookAnchor;\n      }\n      if (line.opcode.type === id.BKA || line.opcode.type === id.BKN) {\n        lookBehind = true;\n        lookAround = true;\n        anchor = line.phraseIndex;\n      }\n      html += '<tr>';\n      html += `<td>${thisLine}</td><td>${thatLine}</td>`;\n      html += `<td>${line.phraseIndex}</td>`;\n      html += `<td>${line.phraseLength}</td>`;\n      html += `<td>${line.depth}</td>`;\n      html += '<td>';\n      switch (line.state) {\n        case id.ACTIVE:\n          html += `<span class=\"${style.CLASS_ACTIVE}\">&darr;&nbsp;</span>`;\n          break;\n        case id.MATCH:\n          html += `<span class=\"${style.CLASS_MATCH}\">&uarr;M</span>`;\n          break;\n        case id.NOMATCH:\n          html += `<span class=\"${style.CLASS_NOMATCH}\">&uarr;N</span>`;\n          break;\n        case id.EMPTY:\n          html += `<span class=\"${style.CLASS_EMPTY}\">&uarr;E</span>`;\n          break;\n        default:\n          html += `<span class=\"${style.CLASS_ACTIVE}\">--</span>`;\n          break;\n      }\n      html += '</td>';\n      html += '<td>';\n      html += that.indent(line.depth);\n      if (lookAhead) {\n        html += `<span class=\"${style.CLASS_LOOKAHEAD}\">`;\n      } else if (lookBehind) {\n        html += `<span class=\"${style.CLASS_LOOKBEHIND}\">`;\n      }\n      html += utils.opcodeToString(line.opcode.type);\n      if (line.opcode.type === id.RNM) {\n        html += `(${rules[line.opcode.index].name}) `;\n      }\n      if (line.opcode.type === id.BKR) {\n        const casetype = line.opcode.bkrCase === id.BKR_MODE_CI ? '%i' : '%s';\n        const modetype = line.opcode.bkrMode === id.BKR_MODE_UM ? '%u' : '%p';\n        html += `(\\\\${casetype}${modetype}${rules[line.opcode.index].name}) `;\n      }\n      if (line.opcode.type === id.UDT) {\n        html += `(${udts[line.opcode.index].name}) `;\n      }\n      if (line.opcode.type === id.TRG) {\n        html += `(${displayTrg(mode, line.opcode)}) `;\n      }\n      if (line.opcode.type === id.TBS) {\n        html += `(${displayTbs(mode, line.opcode)}) `;\n      }\n      if (line.opcode.type === id.TLS) {\n        html += `(${displayTls(mode, line.opcode)}) `;\n      }\n      if (line.opcode.type === id.REP) {\n        html += `(${displayRep(mode, line.opcode)}) `;\n      }\n      if (lookAround) {\n        html += '</span>';\n      }\n      html += '</td>';\n      html += '<td>';\n      if (lookBehind) {\n        html += displayBehind(mode, chars, line.state, line.phraseIndex, line.phraseLength, anchor);\n      } else if (lookAhead) {\n        html += displayAhead(mode, chars, line.state, line.phraseIndex, line.phraseLength);\n      } else {\n        html += displayNone(mode, chars, line.state, line.phraseIndex, line.phraseLength);\n      }\n      html += '</td></tr>\\n';\n    });\n    html += '<tr><th>(a)</th><th>(b)</th><th>(c)</th><th>(d)</th><th>(e)</th><th>(f)</th>';\n    html += '<th>operator</th><th>phrase</th></tr>\\n';\n    html += '</table>\\n';\n    return html;\n  };\n  // Translate the trace records to HTML format.\n  // - *modearg* - can be `\"ascii\"`, `\"decimal\"`, `\"hexadecimal\"` or `\"unicode\"`.\n  // Determines the format of the string character code display.\n  // - *caption* - optional caption for the HTML table.\n  this.toHtml = function (modearg, caption) {\n    /* writes the trace records as a table in a complete html page */\n    let mode = MODE_ASCII;\n    if (typeof modearg === 'string' && modearg.length >= 3) {\n      const modein = modearg.toLowerCase().slice(0, 3);\n      if (modein === 'hex') {\n        mode = MODE_HEX;\n      } else if (modein === 'dec') {\n        mode = MODE_DEC;\n      } else if (modein === 'uni') {\n        mode = MODE_UNICODE;\n      }\n    }\n    let html = '';\n    html += htmlHeader(mode, caption);\n    html += htmlTable(mode);\n    html += htmlFooter();\n    return html;\n  };\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5433, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/apg-js/src/apg-lib/node-exports.js"],"sourcesContent":["/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module serves to export all library objects and object constructors with the `require(\"apg-lib\")` statement.\n// For example, to create a new parser in your program,\n// ````\n// let apglib = require(\"../apg-lib/node-exports\");\n// let my-parser = new apglib.parser();\n// ````\nmodule.exports = {\n  ast: require('./ast'),\n  circular: require('./circular-buffer'),\n  ids: require('./identifiers'),\n  parser: require('./parser'),\n  stats: require('./stats'),\n  trace: require('./trace'),\n  utils: require('./utilities'),\n  emitcss: require('./emitcss'),\n  style: require('./style'),\n};\n"],"names":[],"mappings":"AAAA;;;uFAGuF,GACvF,oHAAoH;AACpH,uDAAuD;AACvD,OAAO;AACP,mDAAmD;AACnD,uCAAuC;AACvC,OAAO;AACP,OAAO,OAAO,GAAG;IACf,GAAG;IACH,QAAQ;IACR,GAAG;IACH,MAAM;IACN,KAAK;IACL,KAAK;IACL,KAAK;IACL,OAAO;IACP,KAAK;AACP","ignoreList":[0]}},
    {"offset": {"line": 5456, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/apg-js/src/apg-api/scanner-grammar.js"],"sourcesContent":["// copyright: Copyright (c) 2024 Lowell D. Thomas, all rights reserved<br>\n//   license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)<br>\n//\n// Generated by apg-js, Version 4.4.0 [apg-js](https://github.com/ldthomas/apg-js)\nmodule.exports = function grammar(){\n  // ```\n  // SUMMARY\n  //      rules = 10\n  //       udts = 0\n  //    opcodes = 31\n  //        ---   ABNF original opcodes\n  //        ALT = 5\n  //        CAT = 2\n  //        REP = 4\n  //        RNM = 11\n  //        TLS = 0\n  //        TBS = 4\n  //        TRG = 5\n  //        ---   SABNF superset opcodes\n  //        UDT = 0\n  //        AND = 0\n  //        NOT = 0\n  //        BKA = 0\n  //        BKN = 0\n  //        BKR = 0\n  //        ABG = 0\n  //        AEN = 0\n  // characters = [0 - 4294967295]\n  // ```\n  /* OBJECT IDENTIFIER (for internal parser use) */\n  this.grammarObject = 'grammarObject';\n\n  /* RULES */\n  this.rules = [];\n  this.rules[0] = { name: 'file', lower: 'file', index: 0, isBkr: false };\n  this.rules[1] = { name: 'line', lower: 'line', index: 1, isBkr: false };\n  this.rules[2] = { name: 'line-text', lower: 'line-text', index: 2, isBkr: false };\n  this.rules[3] = { name: 'last-line', lower: 'last-line', index: 3, isBkr: false };\n  this.rules[4] = { name: 'valid', lower: 'valid', index: 4, isBkr: false };\n  this.rules[5] = { name: 'invalid', lower: 'invalid', index: 5, isBkr: false };\n  this.rules[6] = { name: 'end', lower: 'end', index: 6, isBkr: false };\n  this.rules[7] = { name: 'CRLF', lower: 'crlf', index: 7, isBkr: false };\n  this.rules[8] = { name: 'LF', lower: 'lf', index: 8, isBkr: false };\n  this.rules[9] = { name: 'CR', lower: 'cr', index: 9, isBkr: false };\n\n  /* UDTS */\n  this.udts = [];\n\n  /* OPCODES */\n  /* file */\n  this.rules[0].opcodes = [];\n  this.rules[0].opcodes[0] = { type: 2, children: [1,3] };// CAT\n  this.rules[0].opcodes[1] = { type: 3, min: 0, max: Infinity };// REP\n  this.rules[0].opcodes[2] = { type: 4, index: 1 };// RNM(line)\n  this.rules[0].opcodes[3] = { type: 3, min: 0, max: 1 };// REP\n  this.rules[0].opcodes[4] = { type: 4, index: 3 };// RNM(last-line)\n\n  /* line */\n  this.rules[1].opcodes = [];\n  this.rules[1].opcodes[0] = { type: 2, children: [1,2] };// CAT\n  this.rules[1].opcodes[1] = { type: 4, index: 2 };// RNM(line-text)\n  this.rules[1].opcodes[2] = { type: 4, index: 6 };// RNM(end)\n\n  /* line-text */\n  this.rules[2].opcodes = [];\n  this.rules[2].opcodes[0] = { type: 3, min: 0, max: Infinity };// REP\n  this.rules[2].opcodes[1] = { type: 1, children: [2,3] };// ALT\n  this.rules[2].opcodes[2] = { type: 4, index: 4 };// RNM(valid)\n  this.rules[2].opcodes[3] = { type: 4, index: 5 };// RNM(invalid)\n\n  /* last-line */\n  this.rules[3].opcodes = [];\n  this.rules[3].opcodes[0] = { type: 3, min: 1, max: Infinity };// REP\n  this.rules[3].opcodes[1] = { type: 1, children: [2,3] };// ALT\n  this.rules[3].opcodes[2] = { type: 4, index: 4 };// RNM(valid)\n  this.rules[3].opcodes[3] = { type: 4, index: 5 };// RNM(invalid)\n\n  /* valid */\n  this.rules[4].opcodes = [];\n  this.rules[4].opcodes[0] = { type: 1, children: [1,2] };// ALT\n  this.rules[4].opcodes[1] = { type: 5, min: 32, max: 126 };// TRG\n  this.rules[4].opcodes[2] = { type: 6, string: [9] };// TBS\n\n  /* invalid */\n  this.rules[5].opcodes = [];\n  this.rules[5].opcodes[0] = { type: 1, children: [1,2,3,4] };// ALT\n  this.rules[5].opcodes[1] = { type: 5, min: 0, max: 8 };// TRG\n  this.rules[5].opcodes[2] = { type: 5, min: 11, max: 12 };// TRG\n  this.rules[5].opcodes[3] = { type: 5, min: 14, max: 31 };// TRG\n  this.rules[5].opcodes[4] = { type: 5, min: 127, max: 4294967295 };// TRG\n\n  /* end */\n  this.rules[6].opcodes = [];\n  this.rules[6].opcodes[0] = { type: 1, children: [1,2,3] };// ALT\n  this.rules[6].opcodes[1] = { type: 4, index: 7 };// RNM(CRLF)\n  this.rules[6].opcodes[2] = { type: 4, index: 8 };// RNM(LF)\n  this.rules[6].opcodes[3] = { type: 4, index: 9 };// RNM(CR)\n\n  /* CRLF */\n  this.rules[7].opcodes = [];\n  this.rules[7].opcodes[0] = { type: 6, string: [13,10] };// TBS\n\n  /* LF */\n  this.rules[8].opcodes = [];\n  this.rules[8].opcodes[0] = { type: 6, string: [10] };// TBS\n\n  /* CR */\n  this.rules[9].opcodes = [];\n  this.rules[9].opcodes[0] = { type: 6, string: [13] };// TBS\n\n  // The `toString()` function will display the original grammar file(s) that produced these opcodes.\n  this.toString = function toString(){\n    let str = \"\";\n    str += \"file = *line [last-line]\\n\";\n    str += \"line = line-text end\\n\";\n    str += \"line-text = *(valid/invalid)\\n\";\n    str += \"last-line = 1*(valid/invalid)\\n\";\n    str += \"valid = %d32-126 / %d9\\n\";\n    str += \"invalid = %d0-8 / %d11-12 /%d14-31 / %x7f-ffffffff\\n\";\n    str += \"end = CRLF / LF / CR\\n\";\n    str += \"CRLF = %d13.10\\n\";\n    str += \"LF = %d10\\n\";\n    str += \"CR = %d13\\n\";\n    return str;\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 5743, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/apg-js/src/apg-api/scanner-callbacks.js"],"sourcesContent":["/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// These are the AST translation callback functions used by the scanner\n// to analyze the characters and lines.\nconst ids = require('../apg-lib/identifiers');\nconst utils = require('../apg-lib/utilities');\n\nfunction semLine(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.endLength = 0;\n    data.textLength = 0;\n    data.invalidCount = 0;\n  } else {\n    data.lines.push({\n      lineNo: data.lines.length,\n      beginChar: phraseIndex,\n      length: phraseCount,\n      textLength: data.textLength,\n      endType: data.endType,\n      invalidChars: data.invalidCount,\n    });\n  }\n  return ids.SEM_OK;\n}\nfunction semLineText(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.textLength = phraseCount;\n  }\n  return ids.SEM_OK;\n}\nfunction semLastLine(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.endLength = 0;\n    data.textLength = 0;\n    data.invalidCount = 0;\n  } else if (data.strict) {\n    data.lines.push({\n      lineNo: data.lines.length,\n      beginChar: phraseIndex,\n      length: phraseCount,\n      textLength: phraseCount,\n      endType: 'none',\n      invalidChars: data.invalidCount,\n    });\n    data.errors.push({\n      line: data.lineNo,\n      char: phraseIndex + phraseCount,\n      msg: 'no line end on last line - strict ABNF specifies CRLF(\\\\r\\\\n, \\\\x0D\\\\x0A)',\n    });\n  } else {\n    /* add a line ender */\n    chars.push(10);\n    data.lines.push({\n      lineNo: data.lines.length,\n      beginChar: phraseIndex,\n      length: phraseCount + 1,\n      textLength: phraseCount,\n      endType: 'LF',\n      invalidChars: data.invalidCount,\n    });\n  }\n  return ids.SEM_OK;\n}\nfunction semInvalid(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.errors.push({\n      line: data.lineNo,\n      char: phraseIndex,\n      msg: `invalid character found '\\\\x${utils.charToHex(chars[phraseIndex])}'`,\n    });\n  }\n  return ids.SEM_OK;\n}\nfunction semEnd(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_POST) {\n    data.lineNo += 1;\n  }\n  return ids.SEM_OK;\n}\nfunction semLF(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.endType = 'LF';\n    if (data.strict) {\n      data.errors.push({\n        line: data.lineNo,\n        char: phraseIndex,\n        msg: 'line end character LF(\\\\n, \\\\x0A) - strict ABNF specifies CRLF(\\\\r\\\\n, \\\\x0D\\\\x0A)',\n      });\n    }\n  }\n  return ids.SEM_OK;\n}\nfunction semCR(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.endType = 'CR';\n    if (data.strict) {\n      data.errors.push({\n        line: data.lineNo,\n        char: phraseIndex,\n        msg: 'line end character CR(\\\\r, \\\\x0D) - strict ABNF specifies CRLF(\\\\r\\\\n, \\\\x0D\\\\x0A)',\n      });\n    }\n  }\n  return ids.SEM_OK;\n}\nfunction semCRLF(state, chars, phraseIndex, phraseCount, data) {\n  if (state === ids.SEM_PRE) {\n    data.endType = 'CRLF';\n  }\n  return ids.SEM_OK;\n}\nconst callbacks = [];\ncallbacks.line = semLine;\ncallbacks['line-text'] = semLineText;\ncallbacks['last-line'] = semLastLine;\ncallbacks.invalid = semInvalid;\ncallbacks.end = semEnd;\ncallbacks.lf = semLF;\ncallbacks.cr = semCR;\ncallbacks.crlf = semCRLF;\nexports.callbacks = callbacks;\n"],"names":[],"mappings":"AAAA;;;uFAGuF,GACvF,uEAAuE;AACvE,uCAAuC;AACvC,MAAM;AACN,MAAM;AAEN,SAAS,QAAQ,KAAK,EAAE,KAAK,EAAE,WAAW,EAAE,WAAW,EAAE,IAAI;IAC3D,IAAI,UAAU,IAAI,OAAO,EAAE;QACzB,KAAK,SAAS,GAAG;QACjB,KAAK,UAAU,GAAG;QAClB,KAAK,YAAY,GAAG;IACtB,OAAO;QACL,KAAK,KAAK,CAAC,IAAI,CAAC;YACd,QAAQ,KAAK,KAAK,CAAC,MAAM;YACzB,WAAW;YACX,QAAQ;YACR,YAAY,KAAK,UAAU;YAC3B,SAAS,KAAK,OAAO;YACrB,cAAc,KAAK,YAAY;QACjC;IACF;IACA,OAAO,IAAI,MAAM;AACnB;AACA,SAAS,YAAY,KAAK,EAAE,KAAK,EAAE,WAAW,EAAE,WAAW,EAAE,IAAI;IAC/D,IAAI,UAAU,IAAI,OAAO,EAAE;QACzB,KAAK,UAAU,GAAG;IACpB;IACA,OAAO,IAAI,MAAM;AACnB;AACA,SAAS,YAAY,KAAK,EAAE,KAAK,EAAE,WAAW,EAAE,WAAW,EAAE,IAAI;IAC/D,IAAI,UAAU,IAAI,OAAO,EAAE;QACzB,KAAK,SAAS,GAAG;QACjB,KAAK,UAAU,GAAG;QAClB,KAAK,YAAY,GAAG;IACtB,OAAO,IAAI,KAAK,MAAM,EAAE;QACtB,KAAK,KAAK,CAAC,IAAI,CAAC;YACd,QAAQ,KAAK,KAAK,CAAC,MAAM;YACzB,WAAW;YACX,QAAQ;YACR,YAAY;YACZ,SAAS;YACT,cAAc,KAAK,YAAY;QACjC;QACA,KAAK,MAAM,CAAC,IAAI,CAAC;YACf,MAAM,KAAK,MAAM;YACjB,MAAM,cAAc;YACpB,KAAK;QACP;IACF,OAAO;QACL,oBAAoB,GACpB,MAAM,IAAI,CAAC;QACX,KAAK,KAAK,CAAC,IAAI,CAAC;YACd,QAAQ,KAAK,KAAK,CAAC,MAAM;YACzB,WAAW;YACX,QAAQ,cAAc;YACtB,YAAY;YACZ,SAAS;YACT,cAAc,KAAK,YAAY;QACjC;IACF;IACA,OAAO,IAAI,MAAM;AACnB;AACA,SAAS,WAAW,KAAK,EAAE,KAAK,EAAE,WAAW,EAAE,WAAW,EAAE,IAAI;IAC9D,IAAI,UAAU,IAAI,OAAO,EAAE;QACzB,KAAK,MAAM,CAAC,IAAI,CAAC;YACf,MAAM,KAAK,MAAM;YACjB,MAAM;YACN,KAAK,CAAC,4BAA4B,EAAE,MAAM,SAAS,CAAC,KAAK,CAAC,YAAY,EAAE,CAAC,CAAC;QAC5E;IACF;IACA,OAAO,IAAI,MAAM;AACnB;AACA,SAAS,OAAO,KAAK,EAAE,KAAK,EAAE,WAAW,EAAE,WAAW,EAAE,IAAI;IAC1D,IAAI,UAAU,IAAI,QAAQ,EAAE;QAC1B,KAAK,MAAM,IAAI;IACjB;IACA,OAAO,IAAI,MAAM;AACnB;AACA,SAAS,MAAM,KAAK,EAAE,KAAK,EAAE,WAAW,EAAE,WAAW,EAAE,IAAI;IACzD,IAAI,UAAU,IAAI,OAAO,EAAE;QACzB,KAAK,OAAO,GAAG;QACf,IAAI,KAAK,MAAM,EAAE;YACf,KAAK,MAAM,CAAC,IAAI,CAAC;gBACf,MAAM,KAAK,MAAM;gBACjB,MAAM;gBACN,KAAK;YACP;QACF;IACF;IACA,OAAO,IAAI,MAAM;AACnB;AACA,SAAS,MAAM,KAAK,EAAE,KAAK,EAAE,WAAW,EAAE,WAAW,EAAE,IAAI;IACzD,IAAI,UAAU,IAAI,OAAO,EAAE;QACzB,KAAK,OAAO,GAAG;QACf,IAAI,KAAK,MAAM,EAAE;YACf,KAAK,MAAM,CAAC,IAAI,CAAC;gBACf,MAAM,KAAK,MAAM;gBACjB,MAAM;gBACN,KAAK;YACP;QACF;IACF;IACA,OAAO,IAAI,MAAM;AACnB;AACA,SAAS,QAAQ,KAAK,EAAE,KAAK,EAAE,WAAW,EAAE,WAAW,EAAE,IAAI;IAC3D,IAAI,UAAU,IAAI,OAAO,EAAE;QACzB,KAAK,OAAO,GAAG;IACjB;IACA,OAAO,IAAI,MAAM;AACnB;AACA,MAAM,YAAY,EAAE;AACpB,UAAU,IAAI,GAAG;AACjB,SAAS,CAAC,YAAY,GAAG;AACzB,SAAS,CAAC,YAAY,GAAG;AACzB,UAAU,OAAO,GAAG;AACpB,UAAU,GAAG,GAAG;AAChB,UAAU,EAAE,GAAG;AACf,UAAU,EAAE,GAAG;AACf,UAAU,IAAI,GAAG;AACjB,QAAQ,SAAS,GAAG","ignoreList":[0]}},
    {"offset": {"line": 5866, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/apg-js/src/apg-api/scanner.js"],"sourcesContent":["/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module reads the input grammar file and does a preliminary analysis\n// before attempting to parse it into a grammar object.\n// See:<br>\n// `./dist/scanner-grammar.bnf`<br>\n// for the grammar file this parser is based on.\n//\n// It has two primary functions.\n// - verify the character codes - no non-printing ASCII characters\n// - catalog the lines - create an array with a line object for each line.\n// The object carries information about the line number and character length which is used\n// by the parser generator primarily for error reporting.\nmodule.exports = function exfn(chars, errors, strict, trace) {\n  const thisFileName = 'scanner.js: ';\n  const apglib = require('../apg-lib/node-exports');\n  const grammar = new (require('./scanner-grammar'))();\n  const { callbacks } = require('./scanner-callbacks');\n\n  /* Scan the grammar for character code errors and catalog the lines. */\n  const lines = [];\n  // eslint-disable-next-line new-cap\n  const parser = new apglib.parser();\n  // eslint-disable-next-line new-cap\n  parser.ast = new apglib.ast();\n  parser.ast.callbacks = callbacks;\n  if (trace) {\n    if (trace.traceObject !== 'traceObject') {\n      throw new TypeError(`${thisFileName}trace argument is not a trace object`);\n    }\n    parser.trace = trace;\n  }\n\n  /* parse the input SABNF grammar */\n  const test = parser.parse(grammar, 'file', chars);\n  if (test.success !== true) {\n    errors.push({\n      line: 0,\n      char: 0,\n      msg: 'syntax analysis error analyzing input SABNF grammar',\n    });\n    return;\n  }\n  const data = {\n    lines,\n    lineNo: 0,\n    errors,\n    strict: !!strict,\n  };\n\n  /* translate (analyze) the input SABNF grammar */\n  parser.ast.translate(data);\n  // eslint-disable-next-line consistent-return\n  return lines;\n};\n"],"names":[],"mappings":"AAAA;;;uFAGuF,GACvF,2EAA2E;AAC3E,uDAAuD;AACvD,WAAW;AACX,mCAAmC;AACnC,gDAAgD;AAChD,EAAE;AACF,gCAAgC;AAChC,kEAAkE;AAClE,0EAA0E;AAC1E,0FAA0F;AAC1F,yDAAyD;AACzD,OAAO,OAAO,GAAG,SAAS,KAAK,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,KAAK;IACzD,MAAM,eAAe;IACrB,MAAM;IACN,MAAM,UAAU,IAAI,kHAA6B;IACjD,MAAM,EAAE,SAAS,EAAE;IAEnB,qEAAqE,GACrE,MAAM,QAAQ,EAAE;IAChB,mCAAmC;IACnC,MAAM,SAAS,IAAI,OAAO,MAAM;IAChC,mCAAmC;IACnC,OAAO,GAAG,GAAG,IAAI,OAAO,GAAG;IAC3B,OAAO,GAAG,CAAC,SAAS,GAAG;IACvB,IAAI,OAAO;QACT,IAAI,MAAM,WAAW,KAAK,eAAe;YACvC,MAAM,IAAI,UAAU,GAAG,aAAa,oCAAoC,CAAC;QAC3E;QACA,OAAO,KAAK,GAAG;IACjB;IAEA,iCAAiC,GACjC,MAAM,OAAO,OAAO,KAAK,CAAC,SAAS,QAAQ;IAC3C,IAAI,KAAK,OAAO,KAAK,MAAM;QACzB,OAAO,IAAI,CAAC;YACV,MAAM;YACN,MAAM;YACN,KAAK;QACP;QACA;IACF;IACA,MAAM,OAAO;QACX;QACA,QAAQ;QACR;QACA,QAAQ,CAAC,CAAC;IACZ;IAEA,+CAA+C,GAC/C,OAAO,GAAG,CAAC,SAAS,CAAC;IACrB,6CAA6C;IAC7C,OAAO;AACT","ignoreList":[0]}},
    {"offset": {"line": 5919, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/apg-js/src/apg-api/syntax-callbacks.js"],"sourcesContent":["/* eslint-disable func-names */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module has all of the callback functions for the syntax phase of the generation.\n// See:<br>\n// `./dist/abnf-for-sabnf-grammar.bnf`<br>\n// for the grammar file these callback functions are based on.\nmodule.exports = function exfn() {\n  const thisFileName = 'syntax-callbacks.js: ';\n  const apglib = require('../apg-lib/node-exports');\n  const id = apglib.ids;\n  let topAlt;\n  /* syntax, RNM, callback functions */\n  const synFile = function synFile(result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        data.altStack = [];\n        data.repCount = 0;\n        break;\n      case id.EMPTY:\n        data.errors.push({\n          line: 0,\n          char: 0,\n          msg: 'grammar file is empty',\n        });\n        break;\n      case id.MATCH:\n        if (data.ruleCount === 0) {\n          data.errors.push({\n            line: 0,\n            char: 0,\n            msg: 'no rules defined',\n          });\n        }\n        break;\n      case id.NOMATCH:\n        throw new Error(`${thisFileName}synFile: grammar file NOMATCH: design error: should never happen.`);\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  // eslint-disable-next-line func-names\n  const synRule = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        data.altStack.length = 0;\n        topAlt = {\n          groupOpen: null,\n          groupError: false,\n          optionOpen: null,\n          optionError: false,\n          tlsOpen: null,\n          clsOpen: null,\n          prosValOpen: null,\n          basicError: false,\n        };\n        data.altStack.push(topAlt);\n        break;\n      case id.EMPTY:\n        throw new Error(`${thisFileName}synRule: EMPTY: rule cannot be empty`);\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        data.ruleCount += 1;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synRuleError = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, phraseIndex, data.charsLength),\n          char: phraseIndex,\n          msg: 'Unrecognized SABNF line. Invalid rule, comment or blank line.',\n        });\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synRuleNameError = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, phraseIndex, data.charsLength),\n          char: phraseIndex,\n          msg: 'Rule names must be alphanum and begin with alphabetic character.',\n        });\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synDefinedAsError = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, phraseIndex, data.charsLength),\n          char: phraseIndex,\n          msg: \"Expected '=' or '=/'. Not found.\",\n        });\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synAndOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'AND operator(&) found - strict ABNF specified.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synNotOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'NOT operator(!) found - strict ABNF specified.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synBkaOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'Positive look-behind operator(&&) found - strict ABNF specified.',\n          });\n        } else if (data.lite) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'Positive look-behind operator(&&) found - apg-lite specified.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synBknOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'Negative look-behind operator(!!) found - strict ABNF specified.',\n          });\n        } else if (data.lite) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'Negative look-behind operator(!!) found - apg-lite specified.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synAbgOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'Beginning of string anchor(%^) found - strict ABNF specified.',\n          });\n        } else if (data.lite) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'Beginning of string anchor(%^) found - apg-lite specified.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synAenOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'End of string anchor(%$) found - strict ABNF specified.',\n          });\n        } else if (data.lite) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'End of string anchor(%$) found - apg-lite specified.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synBkrOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          const name = apglib.utils.charsToString(chars, phraseIndex, result.phraseLength);\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: `Back reference operator(${name}) found - strict ABNF specified.`,\n          });\n        } else if (data.lite) {\n          const name = apglib.utils.charsToString(chars, phraseIndex, result.phraseLength);\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: `Back reference operator(${name}) found - apg-lite specified.`,\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synUdtOp = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          const name = apglib.utils.charsToString(chars, phraseIndex, result.phraseLength);\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: `UDT operator found(${name}) - strict ABNF specified.`,\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synTlsOpen = function (result, chars, phraseIndex) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        topAlt.tlsOpen = phraseIndex;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synTlsString = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        data.stringTabChar = false;\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.stringTabChar !== false) {\n          data.errors.push({\n            line: data.findLine(data.lines, data.stringTabChar),\n            char: data.stringTabChar,\n            msg: \"Tab character (\\\\t, x09) not allowed in literal string (see 'quoted-string' definition, RFC 7405.)\",\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synStringTab = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        data.stringTabChar = phraseIndex;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synTlsClose = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, topAlt.tlsOpen),\n          char: topAlt.tlsOpen,\n          msg: 'Case-insensitive literal string(\"...\") opened but not closed.',\n        });\n        topAlt.basicError = true;\n        topAlt.tlsOpen = null;\n        break;\n      case id.MATCH:\n        topAlt.tlsOpen = null;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synClsOpen = function (result, chars, phraseIndex) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        topAlt.clsOpen = phraseIndex;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synClsString = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        data.stringTabChar = false;\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.stringTabChar !== false) {\n          data.errors.push({\n            line: data.findLine(data.lines, data.stringTabChar),\n            char: data.stringTabChar,\n            msg: 'Tab character (\\\\t, x09) not allowed in literal string.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synClsClose = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, topAlt.clsOpen),\n          char: topAlt.clsOpen,\n          msg: \"Case-sensitive literal string('...') opened but not closed.\",\n        });\n        topAlt.clsOpen = null;\n        topAlt.basicError = true;\n        break;\n      case id.MATCH:\n        if (data.strict) {\n          data.errors.push({\n            line: data.findLine(data.lines, topAlt.clsOpen),\n            char: topAlt.clsOpen,\n            msg: \"Case-sensitive string operator('...') found - strict ABNF specified.\",\n          });\n        }\n        topAlt.clsOpen = null;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synProsValOpen = function (result, chars, phraseIndex) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        topAlt.prosValOpen = phraseIndex;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synProsValString = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        data.stringTabChar = false;\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (data.stringTabChar !== false) {\n          data.errors.push({\n            line: data.findLine(data.lines, data.stringTabChar),\n            char: data.stringTabChar,\n            msg: 'Tab character (\\\\t, x09) not allowed in prose value string.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synProsValClose = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, topAlt.prosValOpen),\n          char: topAlt.prosValOpen,\n          msg: 'Prose value operator(<...>) opened but not closed.',\n        });\n        topAlt.basicError = true;\n        topAlt.prosValOpen = null;\n        break;\n      case id.MATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, topAlt.prosValOpen),\n          char: topAlt.prosValOpen,\n          msg: 'Prose value operator(<...>) found. The ABNF syntax is valid, but a parser cannot be generated from this grammar.',\n        });\n        topAlt.prosValOpen = null;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synGroupOpen = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        topAlt = {\n          groupOpen: phraseIndex,\n          groupError: false,\n          optionOpen: null,\n          optionError: false,\n          tlsOpen: null,\n          clsOpen: null,\n          prosValOpen: null,\n          basicError: false,\n        };\n        data.altStack.push(topAlt);\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synGroupClose = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, topAlt.groupOpen),\n          char: topAlt.groupOpen,\n          msg: 'Group \"(...)\" opened but not closed.',\n        });\n        topAlt = data.altStack.pop();\n        topAlt.groupError = true;\n        break;\n      case id.MATCH:\n        topAlt = data.altStack.pop();\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synOptionOpen = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        topAlt = {\n          groupOpen: null,\n          groupError: false,\n          optionOpen: phraseIndex,\n          optionError: false,\n          tlsOpen: null,\n          clsOpen: null,\n          prosValOpen: null,\n          basicError: false,\n        };\n        data.altStack.push(topAlt);\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synOptionClose = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, topAlt.optionOpen),\n          char: topAlt.optionOpen,\n          msg: 'Option \"[...]\" opened but not closed.',\n        });\n        topAlt = data.altStack.pop();\n        topAlt.optionError = true;\n        break;\n      case id.MATCH:\n        topAlt = data.altStack.pop();\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synBasicElementError = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (topAlt.basicError === false) {\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: 'Unrecognized SABNF element.',\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synLineEnd = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        if (result.phraseLength === 1 && data.strict) {\n          const end = chars[phraseIndex] === 13 ? 'CR' : 'LF';\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: `Line end '${end}' found - strict ABNF specified, only CRLF allowed.`,\n          });\n        }\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synLineEndError = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        break;\n      case id.MATCH:\n        data.errors.push({\n          line: data.findLine(data.lines, phraseIndex, data.charsLength),\n          char: phraseIndex,\n          msg: 'Unrecognized grammar element or characters.',\n        });\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  const synRepetition = function (result, chars, phraseIndex, data) {\n    switch (result.state) {\n      case id.ACTIVE:\n        break;\n      case id.EMPTY:\n        break;\n      case id.NOMATCH:\n        data.repCount += 1;\n        break;\n      case id.MATCH:\n        data.repCount += 1;\n        break;\n      default:\n        throw new Error(`${thisFileName}synFile: unrecognized case.`);\n    }\n  };\n  // Define the list of callback functions.\n  this.callbacks = [];\n  this.callbacks.andop = synAndOp;\n  this.callbacks.basicelementerr = synBasicElementError;\n  this.callbacks.clsclose = synClsClose;\n  this.callbacks.clsopen = synClsOpen;\n  this.callbacks.clsstring = synClsString;\n  this.callbacks.definedaserror = synDefinedAsError;\n  this.callbacks.file = synFile;\n  this.callbacks.groupclose = synGroupClose;\n  this.callbacks.groupopen = synGroupOpen;\n  this.callbacks.lineenderror = synLineEndError;\n  this.callbacks.lineend = synLineEnd;\n  this.callbacks.notop = synNotOp;\n  this.callbacks.optionclose = synOptionClose;\n  this.callbacks.optionopen = synOptionOpen;\n  this.callbacks.prosvalclose = synProsValClose;\n  this.callbacks.prosvalopen = synProsValOpen;\n  this.callbacks.prosvalstring = synProsValString;\n  this.callbacks.repetition = synRepetition;\n  this.callbacks.rule = synRule;\n  this.callbacks.ruleerror = synRuleError;\n  this.callbacks.rulenameerror = synRuleNameError;\n  this.callbacks.stringtab = synStringTab;\n  this.callbacks.tlsclose = synTlsClose;\n  this.callbacks.tlsopen = synTlsOpen;\n  this.callbacks.tlsstring = synTlsString;\n  this.callbacks.udtop = synUdtOp;\n  this.callbacks.bkaop = synBkaOp;\n  this.callbacks.bknop = synBknOp;\n  this.callbacks.bkrop = synBkrOp;\n  this.callbacks.abgop = synAbgOp;\n  this.callbacks.aenop = synAenOp;\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 6658, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/apg-js/src/apg-api/semantic-callbacks.js"],"sourcesContent":["/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module has all of the AST translation callback functions for the semantic analysis\n// phase of the generator.\n// See:<br>\n// `./dist/abnf-for-sabnf-grammar.bnf`<br>\n// for the grammar file these callback functions are based on.\nmodule.exports = function exfn() {\n  const apglib = require('../apg-lib/node-exports');\n  const id = apglib.ids;\n\n  /* Some helper functions. */\n  const NameList = function NameList() {\n    this.names = [];\n    /* Adds a new rule name object to the list. Returns -1 if the name already exists. */\n    /* Returns the added name object if the name does not already exist. */\n    this.add = function add(name) {\n      let ret = -1;\n      const find = this.get(name);\n      if (find === -1) {\n        ret = {\n          name,\n          lower: name.toLowerCase(),\n          index: this.names.length,\n        };\n        this.names.push(ret);\n      }\n      return ret;\n    };\n    /* Brute-force look up. */\n    this.get = function get(name) {\n      let ret = -1;\n      const lower = name.toLowerCase();\n      for (let i = 0; i < this.names.length; i += 1) {\n        if (this.names[i].lower === lower) {\n          ret = this.names[i];\n          break;\n        }\n      }\n      return ret;\n    };\n  };\n  /* converts text decimal numbers from, e.g. %d99, to an integer */\n  const decnum = function decnum(chars, beg, len) {\n    let num = 0;\n    for (let i = beg; i < beg + len; i += 1) {\n      num = 10 * num + chars[i] - 48;\n    }\n    return num;\n  };\n  /* converts text binary numbers from, e.g. %b10, to an integer */\n  const binnum = function binnum(chars, beg, len) {\n    let num = 0;\n    for (let i = beg; i < beg + len; i += 1) {\n      num = 2 * num + chars[i] - 48;\n    }\n    return num;\n  };\n  /* converts text hexadecimal numbers from, e.g. %xff, to an integer */\n  const hexnum = function hexnum(chars, beg, len) {\n    let num = 0;\n    for (let i = beg; i < beg + len; i += 1) {\n      let digit = chars[i];\n      if (digit >= 48 && digit <= 57) {\n        digit -= 48;\n      } else if (digit >= 65 && digit <= 70) {\n        digit -= 55;\n      } else if (digit >= 97 && digit <= 102) {\n        digit -= 87;\n      } else {\n        throw new Error('hexnum out of range');\n      }\n      num = 16 * num + digit;\n    }\n    return num;\n  };\n\n  // This is the prototype for all semantic analysis callback functions.\n  // ````\n  // state - the translator state\n  //   id.SEM_PRE for downward (pre-branch) traversal of the AST\n  //   id.SEM_POST for upward (post branch) traversal of the AST\n  // chars - the array of character codes for the input string\n  // phraseIndex - index into the chars array to the first\n  //               character of the phrase\n  // phraseCount - the number of characters in the phrase\n  // data - user-defined data passed to the translator\n  //        for use by the callback functions.\n  // @return id.SEM_OK, normal return.\n  //         id.SEM_SKIP in state id.SEM_PRE will\n  //         skip the branch below.\n  //         Any thing else is an error which will\n  //         stop the translation.\n  // ````\n  /*\n  function semCallbackPrototype(state, chars, phraseIndex, phraseCount, data) {\n    let ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n    } else if (state === id.SEM_POST) {\n    }\n    return ret;\n  }\n  */\n  // The AST callback functions.\n  function semFile(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.ruleNames = new NameList();\n      data.udtNames = new NameList();\n      data.rules = [];\n      data.udts = [];\n      data.rulesLineMap = [];\n      data.opcodes = [];\n      data.altStack = [];\n      data.topStack = null;\n      data.topRule = null;\n    } else if (state === id.SEM_POST) {\n      /* validate RNM rule names and set opcode rule index */\n      let nameObj;\n      data.rules.forEach((rule) => {\n        rule.isBkr = false;\n        rule.opcodes.forEach((op) => {\n          if (op.type === id.RNM) {\n            nameObj = data.ruleNames.get(op.index.name);\n            if (nameObj === -1) {\n              data.errors.push({\n                line: data.findLine(data.lines, op.index.phraseIndex, data.charsLength),\n                char: op.index.phraseIndex,\n                msg: `Rule name '${op.index.name}' used but not defined.`,\n              });\n              op.index = -1;\n            } else {\n              op.index = nameObj.index;\n            }\n          }\n        });\n      });\n      /* validate BKR rule names and set opcode rule index */\n      data.udts.forEach((udt) => {\n        udt.isBkr = false;\n      });\n      data.rules.forEach((rule) => {\n        rule.opcodes.forEach((op) => {\n          if (op.type === id.BKR) {\n            rule.hasBkr = true;\n            nameObj = data.ruleNames.get(op.index.name);\n            if (nameObj !== -1) {\n              data.rules[nameObj.index].isBkr = true;\n              op.index = nameObj.index;\n            } else {\n              nameObj = data.udtNames.get(op.index.name);\n              if (nameObj !== -1) {\n                data.udts[nameObj.index].isBkr = true;\n                op.index = data.rules.length + nameObj.index;\n              } else {\n                data.errors.push({\n                  line: data.findLine(data.lines, op.index.phraseIndex, data.charsLength),\n                  char: op.index.phraseIndex,\n                  msg: `Back reference name '${op.index.name}' refers to undefined rule or unamed UDT.`,\n                });\n                op.index = -1;\n              }\n            }\n          }\n        });\n      });\n    }\n    return ret;\n  }\n  function semRule(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.altStack.length = 0;\n      data.topStack = null;\n      data.rulesLineMap.push({\n        line: data.findLine(data.lines, phraseIndex, data.charsLength),\n        char: phraseIndex,\n      });\n    }\n    return ret;\n  }\n  function semRuleLookup(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.ruleName = '';\n      data.definedas = '';\n    } else if (state === id.SEM_POST) {\n      let ruleName;\n      if (data.definedas === '=') {\n        ruleName = data.ruleNames.add(data.ruleName);\n        if (ruleName === -1) {\n          data.definedas = null;\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: `Rule name '${data.ruleName}' previously defined.`,\n          });\n        } else {\n          /* start a new rule */\n          data.topRule = {\n            name: ruleName.name,\n            lower: ruleName.lower,\n            opcodes: [],\n            index: ruleName.index,\n          };\n          data.rules.push(data.topRule);\n          data.opcodes = data.topRule.opcodes;\n        }\n      } else {\n        ruleName = data.ruleNames.get(data.ruleName);\n        if (ruleName === -1) {\n          data.definedas = null;\n          data.errors.push({\n            line: data.findLine(data.lines, phraseIndex, data.charsLength),\n            char: phraseIndex,\n            msg: `Rule name '${data.ruleName}' for incremental alternate not previously defined.`,\n          });\n        } else {\n          data.topRule = data.rules[ruleName.index];\n          data.opcodes = data.topRule.opcodes;\n        }\n      }\n    }\n    return ret;\n  }\n  function semAlternation(state, chars, phraseIndex, phraseCount, data) {\n    let ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      const TRUE = true;\n      while (TRUE) {\n        if (data.definedas === null) {\n          /* rule error - skip opcode generation */\n          ret = id.SEM_SKIP;\n          break;\n        }\n        if (data.topStack === null) {\n          /* top-level ALT */\n          if (data.definedas === '=') {\n            /* \"=\" new rule */\n            data.topStack = {\n              alt: {\n                type: id.ALT,\n                children: [],\n              },\n              cat: null,\n            };\n            data.altStack.push(data.topStack);\n            data.opcodes.push(data.topStack.alt);\n            break;\n          }\n          /* \"=/\" incremental alternate */\n          data.topStack = {\n            alt: data.opcodes[0],\n            cat: null,\n          };\n          data.altStack.push(data.topStack);\n          break;\n        }\n        /* lower-level ALT */\n        data.topStack = {\n          alt: {\n            type: id.ALT,\n            children: [],\n          },\n          cat: null,\n        };\n        data.altStack.push(data.topStack);\n        data.opcodes.push(data.topStack.alt);\n        break;\n      }\n    } else if (state === id.SEM_POST) {\n      data.altStack.pop();\n      if (data.altStack.length > 0) {\n        data.topStack = data.altStack[data.altStack.length - 1];\n      } else {\n        data.topStack = null;\n      }\n    }\n    return ret;\n  }\n  function semConcatenation(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.topStack.alt.children.push(data.opcodes.length);\n      data.topStack.cat = {\n        type: id.CAT,\n        children: [],\n      };\n      data.opcodes.push(data.topStack.cat);\n    } else if (state === id.SEM_POST) {\n      data.topStack.cat = null;\n    }\n    return ret;\n  }\n  function semRepetition(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.topStack.cat.children.push(data.opcodes.length);\n    }\n    return ret;\n  }\n  function semOptionOpen(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.REP,\n        min: 0,\n        max: 1,\n        char: phraseIndex,\n      });\n    }\n    return ret;\n  }\n  function semRuleName(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.ruleName = apglib.utils.charsToString(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semDefined(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.definedas = '=';\n    }\n    return ret;\n  }\n  function semIncAlt(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.definedas = '=/';\n    }\n    return ret;\n  }\n  function semRepOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.min = 0;\n      data.max = Infinity;\n      data.topRep = {\n        type: id.REP,\n        min: 0,\n        max: Infinity,\n      };\n      data.opcodes.push(data.topRep);\n    } else if (state === id.SEM_POST) {\n      if (data.min > data.max) {\n        data.errors.push({\n          line: data.findLine(data.lines, phraseIndex, data.charsLength),\n          char: phraseIndex,\n          msg: `repetition min cannot be greater than max: min: ${data.min}: max: ${data.max}`,\n        });\n      }\n      data.topRep.min = data.min;\n      data.topRep.max = data.max;\n    }\n    return ret;\n  }\n  function semRepMin(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.min = decnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semRepMax(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.max = decnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semRepMinMax(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.max = decnum(chars, phraseIndex, phraseCount);\n      data.min = data.max;\n    }\n    return ret;\n  }\n  function semAndOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.AND,\n      });\n    }\n    return ret;\n  }\n  function semNotOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.NOT,\n      });\n    }\n    return ret;\n  }\n  function semRnmOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.RNM,\n        /* NOTE: this is temporary info, index will be replaced with integer later. */\n        /* Probably not the best coding practice but here you go. */\n        index: {\n          phraseIndex,\n          name: apglib.utils.charsToString(chars, phraseIndex, phraseCount),\n        },\n      });\n    }\n    return ret;\n  }\n  function semAbgOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.ABG,\n      });\n    }\n    return ret;\n  }\n  function semAenOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.AEN,\n      });\n    }\n    return ret;\n  }\n  function semBkaOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.BKA,\n      });\n    }\n    return ret;\n  }\n  function semBknOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.BKN,\n      });\n    }\n    return ret;\n  }\n  function semBkrOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.ci = true; /* default to case insensitive */\n      data.cs = false;\n      data.um = true;\n      data.pm = false;\n    } else if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.BKR,\n        bkrCase: data.cs === true ? id.BKR_MODE_CS : id.BKR_MODE_CI,\n        bkrMode: data.pm === true ? id.BKR_MODE_PM : id.BKR_MODE_UM,\n        /* NOTE: this is temporary info, index will be replaced with integer later. */\n        /* Probably not the best coding practice but here you go. */\n        index: {\n          phraseIndex: data.bkrname.phraseIndex,\n          name: apglib.utils.charsToString(chars, data.bkrname.phraseIndex, data.bkrname.phraseLength),\n        },\n      });\n    }\n    return ret;\n  }\n  function semBkrCi(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.ci = true;\n    }\n    return ret;\n  }\n  function semBkrCs(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.cs = true;\n    }\n    return ret;\n  }\n  function semBkrUm(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.um = true;\n    }\n    return ret;\n  }\n  function semBkrPm(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.pm = true;\n    }\n    return ret;\n  }\n  function semBkrName(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.bkrname = {\n        phraseIndex,\n        phraseLength: phraseCount,\n      };\n    }\n    return ret;\n  }\n  function semUdtEmpty(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      const name = apglib.utils.charsToString(chars, phraseIndex, phraseCount);\n      let udtName = data.udtNames.add(name);\n      if (udtName === -1) {\n        udtName = data.udtNames.get(name);\n        if (udtName === -1) {\n          throw new Error('semUdtEmpty: name look up error');\n        }\n      } else {\n        data.udts.push({\n          name: udtName.name,\n          lower: udtName.lower,\n          index: udtName.index,\n          empty: true,\n        });\n      }\n      data.opcodes.push({\n        type: id.UDT,\n        empty: true,\n        index: udtName.index,\n      });\n    }\n    return ret;\n  }\n  function semUdtNonEmpty(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      const name = apglib.utils.charsToString(chars, phraseIndex, phraseCount);\n      let udtName = data.udtNames.add(name);\n      if (udtName === -1) {\n        udtName = data.udtNames.get(name);\n        if (udtName === -1) {\n          throw new Error('semUdtNonEmpty: name look up error');\n        }\n      } else {\n        data.udts.push({\n          name: udtName.name,\n          lower: udtName.lower,\n          index: udtName.index,\n          empty: false,\n        });\n      }\n      data.opcodes.push({\n        type: id.UDT,\n        empty: false,\n        index: udtName.index,\n        syntax: null,\n        semantic: null,\n      });\n    }\n    return ret;\n  }\n  function semTlsOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.tlscase = true; /* default to case insensitive */\n    }\n    return ret;\n  }\n  function semTlsCase(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      if (phraseCount > 0 && (chars[phraseIndex + 1] === 83 || chars[phraseIndex + 1] === 115)) {\n        data.tlscase = false; /* set to case sensitive */\n      }\n    }\n    return ret;\n  }\n  function semTlsString(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      if (data.tlscase) {\n        const str = chars.slice(phraseIndex, phraseIndex + phraseCount);\n        for (let i = 0; i < str.length; i += 1) {\n          if (str[i] >= 65 && str[i] <= 90) {\n            str[i] += 32;\n          }\n        }\n        data.opcodes.push({\n          type: id.TLS,\n          string: str,\n        });\n      } else {\n        data.opcodes.push({\n          type: id.TBS,\n          string: chars.slice(phraseIndex, phraseIndex + phraseCount),\n        });\n      }\n    }\n    return ret;\n  }\n  function semClsOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      if (phraseCount <= 2) {\n        /* only TLS is allowed to be empty */\n        data.opcodes.push({\n          type: id.TLS,\n          string: [],\n        });\n      } else {\n        data.opcodes.push({\n          type: id.TBS,\n          string: chars.slice(phraseIndex + 1, phraseIndex + phraseCount - 1),\n        });\n      }\n    }\n    return ret;\n  }\n  function semTbsOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.tbsstr = [];\n    } else if (state === id.SEM_POST) {\n      data.opcodes.push({\n        type: id.TBS,\n        string: data.tbsstr,\n      });\n    }\n    return ret;\n  }\n  function semTrgOp(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_PRE) {\n      data.min = 0;\n      data.max = 0;\n    } else if (state === id.SEM_POST) {\n      if (data.min > data.max) {\n        data.errors.push({\n          line: data.findLine(data.lines, phraseIndex, data.charsLength),\n          char: phraseIndex,\n          msg: `TRG, (%dmin-max), min cannot be greater than max: min: ${data.min}: max: ${data.max}`,\n        });\n      }\n      data.opcodes.push({\n        type: id.TRG,\n        min: data.min,\n        max: data.max,\n      });\n    }\n    return ret;\n  }\n  function semDmin(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.min = decnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semDmax(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.max = decnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semBmin(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.min = binnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semBmax(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.max = binnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semXmin(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.min = hexnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semXmax(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.max = hexnum(chars, phraseIndex, phraseCount);\n    }\n    return ret;\n  }\n  function semDstring(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.tbsstr.push(decnum(chars, phraseIndex, phraseCount));\n    }\n    return ret;\n  }\n  function semBstring(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.tbsstr.push(binnum(chars, phraseIndex, phraseCount));\n    }\n    return ret;\n  }\n  function semXstring(state, chars, phraseIndex, phraseCount, data) {\n    const ret = id.SEM_OK;\n    if (state === id.SEM_POST) {\n      data.tbsstr.push(hexnum(chars, phraseIndex, phraseCount));\n    }\n    return ret;\n  }\n  // Define the callback functions to the AST object.\n  this.callbacks = [];\n  this.callbacks.abgop = semAbgOp;\n  this.callbacks.aenop = semAenOp;\n  this.callbacks.alternation = semAlternation;\n  this.callbacks.andop = semAndOp;\n  this.callbacks.bmax = semBmax;\n  this.callbacks.bmin = semBmin;\n  this.callbacks.bkaop = semBkaOp;\n  this.callbacks.bknop = semBknOp;\n  this.callbacks.bkrop = semBkrOp;\n  this.callbacks['bkr-name'] = semBkrName;\n  this.callbacks.bstring = semBstring;\n  this.callbacks.clsop = semClsOp;\n  this.callbacks.ci = semBkrCi;\n  this.callbacks.cs = semBkrCs;\n  this.callbacks.um = semBkrUm;\n  this.callbacks.pm = semBkrPm;\n  this.callbacks.concatenation = semConcatenation;\n  this.callbacks.defined = semDefined;\n  this.callbacks.dmax = semDmax;\n  this.callbacks.dmin = semDmin;\n  this.callbacks.dstring = semDstring;\n  this.callbacks.file = semFile;\n  this.callbacks.incalt = semIncAlt;\n  this.callbacks.notop = semNotOp;\n  this.callbacks.optionopen = semOptionOpen;\n  this.callbacks['rep-max'] = semRepMax;\n  this.callbacks['rep-min'] = semRepMin;\n  this.callbacks['rep-min-max'] = semRepMinMax;\n  this.callbacks.repetition = semRepetition;\n  this.callbacks.repop = semRepOp;\n  this.callbacks.rnmop = semRnmOp;\n  this.callbacks.rule = semRule;\n  this.callbacks.rulelookup = semRuleLookup;\n  this.callbacks.rulename = semRuleName;\n  this.callbacks.tbsop = semTbsOp;\n  this.callbacks.tlscase = semTlsCase;\n  this.callbacks.tlsstring = semTlsString;\n  this.callbacks.tlsop = semTlsOp;\n  this.callbacks.trgop = semTrgOp;\n  this.callbacks['udt-empty'] = semUdtEmpty;\n  this.callbacks['udt-non-empty'] = semUdtNonEmpty;\n  this.callbacks.xmax = semXmax;\n  this.callbacks.xmin = semXmin;\n  this.callbacks.xstring = semXstring;\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 7402, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/apg-js/src/apg-api/sabnf-grammar.js"],"sourcesContent":["// copyright: Copyright (c) 2024 Lowell D. Thomas, all rights reserved<br>\n//   license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)<br>\n//\n// Generated by apg-js, Version 4.4.0 [apg-js](https://github.com/ldthomas/apg-js)\nmodule.exports = function grammar(){\n  // ```\n  // SUMMARY\n  //      rules = 95\n  //       udts = 0\n  //    opcodes = 372\n  //        ---   ABNF original opcodes\n  //        ALT = 43\n  //        CAT = 48\n  //        REP = 34\n  //        RNM = 149\n  //        TLS = 2\n  //        TBS = 61\n  //        TRG = 35\n  //        ---   SABNF superset opcodes\n  //        UDT = 0\n  //        AND = 0\n  //        NOT = 0\n  //        BKA = 0\n  //        BKN = 0\n  //        BKR = 0\n  //        ABG = 0\n  //        AEN = 0\n  // characters = [9 - 126]\n  // ```\n  /* OBJECT IDENTIFIER (for internal parser use) */\n  this.grammarObject = 'grammarObject';\n\n  /* RULES */\n  this.rules = [];\n  this.rules[0] = { name: 'File', lower: 'file', index: 0, isBkr: false };\n  this.rules[1] = { name: 'BlankLine', lower: 'blankline', index: 1, isBkr: false };\n  this.rules[2] = { name: 'Rule', lower: 'rule', index: 2, isBkr: false };\n  this.rules[3] = { name: 'RuleLookup', lower: 'rulelookup', index: 3, isBkr: false };\n  this.rules[4] = { name: 'RuleNameTest', lower: 'rulenametest', index: 4, isBkr: false };\n  this.rules[5] = { name: 'RuleName', lower: 'rulename', index: 5, isBkr: false };\n  this.rules[6] = { name: 'RuleNameError', lower: 'rulenameerror', index: 6, isBkr: false };\n  this.rules[7] = { name: 'DefinedAsTest', lower: 'definedastest', index: 7, isBkr: false };\n  this.rules[8] = { name: 'DefinedAsError', lower: 'definedaserror', index: 8, isBkr: false };\n  this.rules[9] = { name: 'DefinedAs', lower: 'definedas', index: 9, isBkr: false };\n  this.rules[10] = { name: 'Defined', lower: 'defined', index: 10, isBkr: false };\n  this.rules[11] = { name: 'IncAlt', lower: 'incalt', index: 11, isBkr: false };\n  this.rules[12] = { name: 'RuleError', lower: 'ruleerror', index: 12, isBkr: false };\n  this.rules[13] = { name: 'LineEndError', lower: 'lineenderror', index: 13, isBkr: false };\n  this.rules[14] = { name: 'Alternation', lower: 'alternation', index: 14, isBkr: false };\n  this.rules[15] = { name: 'Concatenation', lower: 'concatenation', index: 15, isBkr: false };\n  this.rules[16] = { name: 'Repetition', lower: 'repetition', index: 16, isBkr: false };\n  this.rules[17] = { name: 'Modifier', lower: 'modifier', index: 17, isBkr: false };\n  this.rules[18] = { name: 'Predicate', lower: 'predicate', index: 18, isBkr: false };\n  this.rules[19] = { name: 'BasicElement', lower: 'basicelement', index: 19, isBkr: false };\n  this.rules[20] = { name: 'BasicElementErr', lower: 'basicelementerr', index: 20, isBkr: false };\n  this.rules[21] = { name: 'Group', lower: 'group', index: 21, isBkr: false };\n  this.rules[22] = { name: 'GroupError', lower: 'grouperror', index: 22, isBkr: false };\n  this.rules[23] = { name: 'GroupOpen', lower: 'groupopen', index: 23, isBkr: false };\n  this.rules[24] = { name: 'GroupClose', lower: 'groupclose', index: 24, isBkr: false };\n  this.rules[25] = { name: 'Option', lower: 'option', index: 25, isBkr: false };\n  this.rules[26] = { name: 'OptionError', lower: 'optionerror', index: 26, isBkr: false };\n  this.rules[27] = { name: 'OptionOpen', lower: 'optionopen', index: 27, isBkr: false };\n  this.rules[28] = { name: 'OptionClose', lower: 'optionclose', index: 28, isBkr: false };\n  this.rules[29] = { name: 'RnmOp', lower: 'rnmop', index: 29, isBkr: false };\n  this.rules[30] = { name: 'BkrOp', lower: 'bkrop', index: 30, isBkr: false };\n  this.rules[31] = { name: 'bkrModifier', lower: 'bkrmodifier', index: 31, isBkr: false };\n  this.rules[32] = { name: 'cs', lower: 'cs', index: 32, isBkr: false };\n  this.rules[33] = { name: 'ci', lower: 'ci', index: 33, isBkr: false };\n  this.rules[34] = { name: 'um', lower: 'um', index: 34, isBkr: false };\n  this.rules[35] = { name: 'pm', lower: 'pm', index: 35, isBkr: false };\n  this.rules[36] = { name: 'bkr-name', lower: 'bkr-name', index: 36, isBkr: false };\n  this.rules[37] = { name: 'rname', lower: 'rname', index: 37, isBkr: false };\n  this.rules[38] = { name: 'uname', lower: 'uname', index: 38, isBkr: false };\n  this.rules[39] = { name: 'ename', lower: 'ename', index: 39, isBkr: false };\n  this.rules[40] = { name: 'UdtOp', lower: 'udtop', index: 40, isBkr: false };\n  this.rules[41] = { name: 'udt-non-empty', lower: 'udt-non-empty', index: 41, isBkr: false };\n  this.rules[42] = { name: 'udt-empty', lower: 'udt-empty', index: 42, isBkr: false };\n  this.rules[43] = { name: 'RepOp', lower: 'repop', index: 43, isBkr: false };\n  this.rules[44] = { name: 'AltOp', lower: 'altop', index: 44, isBkr: false };\n  this.rules[45] = { name: 'CatOp', lower: 'catop', index: 45, isBkr: false };\n  this.rules[46] = { name: 'StarOp', lower: 'starop', index: 46, isBkr: false };\n  this.rules[47] = { name: 'AndOp', lower: 'andop', index: 47, isBkr: false };\n  this.rules[48] = { name: 'NotOp', lower: 'notop', index: 48, isBkr: false };\n  this.rules[49] = { name: 'BkaOp', lower: 'bkaop', index: 49, isBkr: false };\n  this.rules[50] = { name: 'BknOp', lower: 'bknop', index: 50, isBkr: false };\n  this.rules[51] = { name: 'AbgOp', lower: 'abgop', index: 51, isBkr: false };\n  this.rules[52] = { name: 'AenOp', lower: 'aenop', index: 52, isBkr: false };\n  this.rules[53] = { name: 'TrgOp', lower: 'trgop', index: 53, isBkr: false };\n  this.rules[54] = { name: 'TbsOp', lower: 'tbsop', index: 54, isBkr: false };\n  this.rules[55] = { name: 'TlsOp', lower: 'tlsop', index: 55, isBkr: false };\n  this.rules[56] = { name: 'TlsCase', lower: 'tlscase', index: 56, isBkr: false };\n  this.rules[57] = { name: 'TlsOpen', lower: 'tlsopen', index: 57, isBkr: false };\n  this.rules[58] = { name: 'TlsClose', lower: 'tlsclose', index: 58, isBkr: false };\n  this.rules[59] = { name: 'TlsString', lower: 'tlsstring', index: 59, isBkr: false };\n  this.rules[60] = { name: 'StringTab', lower: 'stringtab', index: 60, isBkr: false };\n  this.rules[61] = { name: 'ClsOp', lower: 'clsop', index: 61, isBkr: false };\n  this.rules[62] = { name: 'ClsOpen', lower: 'clsopen', index: 62, isBkr: false };\n  this.rules[63] = { name: 'ClsClose', lower: 'clsclose', index: 63, isBkr: false };\n  this.rules[64] = { name: 'ClsString', lower: 'clsstring', index: 64, isBkr: false };\n  this.rules[65] = { name: 'ProsVal', lower: 'prosval', index: 65, isBkr: false };\n  this.rules[66] = { name: 'ProsValOpen', lower: 'prosvalopen', index: 66, isBkr: false };\n  this.rules[67] = { name: 'ProsValString', lower: 'prosvalstring', index: 67, isBkr: false };\n  this.rules[68] = { name: 'ProsValClose', lower: 'prosvalclose', index: 68, isBkr: false };\n  this.rules[69] = { name: 'rep-min', lower: 'rep-min', index: 69, isBkr: false };\n  this.rules[70] = { name: 'rep-min-max', lower: 'rep-min-max', index: 70, isBkr: false };\n  this.rules[71] = { name: 'rep-max', lower: 'rep-max', index: 71, isBkr: false };\n  this.rules[72] = { name: 'rep-num', lower: 'rep-num', index: 72, isBkr: false };\n  this.rules[73] = { name: 'dString', lower: 'dstring', index: 73, isBkr: false };\n  this.rules[74] = { name: 'xString', lower: 'xstring', index: 74, isBkr: false };\n  this.rules[75] = { name: 'bString', lower: 'bstring', index: 75, isBkr: false };\n  this.rules[76] = { name: 'Dec', lower: 'dec', index: 76, isBkr: false };\n  this.rules[77] = { name: 'Hex', lower: 'hex', index: 77, isBkr: false };\n  this.rules[78] = { name: 'Bin', lower: 'bin', index: 78, isBkr: false };\n  this.rules[79] = { name: 'dmin', lower: 'dmin', index: 79, isBkr: false };\n  this.rules[80] = { name: 'dmax', lower: 'dmax', index: 80, isBkr: false };\n  this.rules[81] = { name: 'bmin', lower: 'bmin', index: 81, isBkr: false };\n  this.rules[82] = { name: 'bmax', lower: 'bmax', index: 82, isBkr: false };\n  this.rules[83] = { name: 'xmin', lower: 'xmin', index: 83, isBkr: false };\n  this.rules[84] = { name: 'xmax', lower: 'xmax', index: 84, isBkr: false };\n  this.rules[85] = { name: 'dnum', lower: 'dnum', index: 85, isBkr: false };\n  this.rules[86] = { name: 'bnum', lower: 'bnum', index: 86, isBkr: false };\n  this.rules[87] = { name: 'xnum', lower: 'xnum', index: 87, isBkr: false };\n  this.rules[88] = { name: 'alphanum', lower: 'alphanum', index: 88, isBkr: false };\n  this.rules[89] = { name: 'owsp', lower: 'owsp', index: 89, isBkr: false };\n  this.rules[90] = { name: 'wsp', lower: 'wsp', index: 90, isBkr: false };\n  this.rules[91] = { name: 'space', lower: 'space', index: 91, isBkr: false };\n  this.rules[92] = { name: 'comment', lower: 'comment', index: 92, isBkr: false };\n  this.rules[93] = { name: 'LineEnd', lower: 'lineend', index: 93, isBkr: false };\n  this.rules[94] = { name: 'LineContinue', lower: 'linecontinue', index: 94, isBkr: false };\n\n  /* UDTS */\n  this.udts = [];\n\n  /* OPCODES */\n  /* File */\n  this.rules[0].opcodes = [];\n  this.rules[0].opcodes[0] = { type: 3, min: 0, max: Infinity };// REP\n  this.rules[0].opcodes[1] = { type: 1, children: [2,3,4] };// ALT\n  this.rules[0].opcodes[2] = { type: 4, index: 1 };// RNM(BlankLine)\n  this.rules[0].opcodes[3] = { type: 4, index: 2 };// RNM(Rule)\n  this.rules[0].opcodes[4] = { type: 4, index: 12 };// RNM(RuleError)\n\n  /* BlankLine */\n  this.rules[1].opcodes = [];\n  this.rules[1].opcodes[0] = { type: 2, children: [1,5,7] };// CAT\n  this.rules[1].opcodes[1] = { type: 3, min: 0, max: Infinity };// REP\n  this.rules[1].opcodes[2] = { type: 1, children: [3,4] };// ALT\n  this.rules[1].opcodes[3] = { type: 6, string: [32] };// TBS\n  this.rules[1].opcodes[4] = { type: 6, string: [9] };// TBS\n  this.rules[1].opcodes[5] = { type: 3, min: 0, max: 1 };// REP\n  this.rules[1].opcodes[6] = { type: 4, index: 92 };// RNM(comment)\n  this.rules[1].opcodes[7] = { type: 4, index: 93 };// RNM(LineEnd)\n\n  /* Rule */\n  this.rules[2].opcodes = [];\n  this.rules[2].opcodes[0] = { type: 2, children: [1,2,3,4] };// CAT\n  this.rules[2].opcodes[1] = { type: 4, index: 3 };// RNM(RuleLookup)\n  this.rules[2].opcodes[2] = { type: 4, index: 89 };// RNM(owsp)\n  this.rules[2].opcodes[3] = { type: 4, index: 14 };// RNM(Alternation)\n  this.rules[2].opcodes[4] = { type: 1, children: [5,8] };// ALT\n  this.rules[2].opcodes[5] = { type: 2, children: [6,7] };// CAT\n  this.rules[2].opcodes[6] = { type: 4, index: 89 };// RNM(owsp)\n  this.rules[2].opcodes[7] = { type: 4, index: 93 };// RNM(LineEnd)\n  this.rules[2].opcodes[8] = { type: 2, children: [9,10] };// CAT\n  this.rules[2].opcodes[9] = { type: 4, index: 13 };// RNM(LineEndError)\n  this.rules[2].opcodes[10] = { type: 4, index: 93 };// RNM(LineEnd)\n\n  /* RuleLookup */\n  this.rules[3].opcodes = [];\n  this.rules[3].opcodes[0] = { type: 2, children: [1,2,3] };// CAT\n  this.rules[3].opcodes[1] = { type: 4, index: 4 };// RNM(RuleNameTest)\n  this.rules[3].opcodes[2] = { type: 4, index: 89 };// RNM(owsp)\n  this.rules[3].opcodes[3] = { type: 4, index: 7 };// RNM(DefinedAsTest)\n\n  /* RuleNameTest */\n  this.rules[4].opcodes = [];\n  this.rules[4].opcodes[0] = { type: 1, children: [1,2] };// ALT\n  this.rules[4].opcodes[1] = { type: 4, index: 5 };// RNM(RuleName)\n  this.rules[4].opcodes[2] = { type: 4, index: 6 };// RNM(RuleNameError)\n\n  /* RuleName */\n  this.rules[5].opcodes = [];\n  this.rules[5].opcodes[0] = { type: 4, index: 88 };// RNM(alphanum)\n\n  /* RuleNameError */\n  this.rules[6].opcodes = [];\n  this.rules[6].opcodes[0] = { type: 3, min: 1, max: Infinity };// REP\n  this.rules[6].opcodes[1] = { type: 1, children: [2,3] };// ALT\n  this.rules[6].opcodes[2] = { type: 5, min: 33, max: 60 };// TRG\n  this.rules[6].opcodes[3] = { type: 5, min: 62, max: 126 };// TRG\n\n  /* DefinedAsTest */\n  this.rules[7].opcodes = [];\n  this.rules[7].opcodes[0] = { type: 1, children: [1,2] };// ALT\n  this.rules[7].opcodes[1] = { type: 4, index: 9 };// RNM(DefinedAs)\n  this.rules[7].opcodes[2] = { type: 4, index: 8 };// RNM(DefinedAsError)\n\n  /* DefinedAsError */\n  this.rules[8].opcodes = [];\n  this.rules[8].opcodes[0] = { type: 3, min: 1, max: 2 };// REP\n  this.rules[8].opcodes[1] = { type: 5, min: 33, max: 126 };// TRG\n\n  /* DefinedAs */\n  this.rules[9].opcodes = [];\n  this.rules[9].opcodes[0] = { type: 1, children: [1,2] };// ALT\n  this.rules[9].opcodes[1] = { type: 4, index: 11 };// RNM(IncAlt)\n  this.rules[9].opcodes[2] = { type: 4, index: 10 };// RNM(Defined)\n\n  /* Defined */\n  this.rules[10].opcodes = [];\n  this.rules[10].opcodes[0] = { type: 6, string: [61] };// TBS\n\n  /* IncAlt */\n  this.rules[11].opcodes = [];\n  this.rules[11].opcodes[0] = { type: 6, string: [61,47] };// TBS\n\n  /* RuleError */\n  this.rules[12].opcodes = [];\n  this.rules[12].opcodes[0] = { type: 2, children: [1,6] };// CAT\n  this.rules[12].opcodes[1] = { type: 3, min: 1, max: Infinity };// REP\n  this.rules[12].opcodes[2] = { type: 1, children: [3,4,5] };// ALT\n  this.rules[12].opcodes[3] = { type: 5, min: 32, max: 126 };// TRG\n  this.rules[12].opcodes[4] = { type: 6, string: [9] };// TBS\n  this.rules[12].opcodes[5] = { type: 4, index: 94 };// RNM(LineContinue)\n  this.rules[12].opcodes[6] = { type: 4, index: 93 };// RNM(LineEnd)\n\n  /* LineEndError */\n  this.rules[13].opcodes = [];\n  this.rules[13].opcodes[0] = { type: 3, min: 1, max: Infinity };// REP\n  this.rules[13].opcodes[1] = { type: 1, children: [2,3,4] };// ALT\n  this.rules[13].opcodes[2] = { type: 5, min: 32, max: 126 };// TRG\n  this.rules[13].opcodes[3] = { type: 6, string: [9] };// TBS\n  this.rules[13].opcodes[4] = { type: 4, index: 94 };// RNM(LineContinue)\n\n  /* Alternation */\n  this.rules[14].opcodes = [];\n  this.rules[14].opcodes[0] = { type: 2, children: [1,2] };// CAT\n  this.rules[14].opcodes[1] = { type: 4, index: 15 };// RNM(Concatenation)\n  this.rules[14].opcodes[2] = { type: 3, min: 0, max: Infinity };// REP\n  this.rules[14].opcodes[3] = { type: 2, children: [4,5,6] };// CAT\n  this.rules[14].opcodes[4] = { type: 4, index: 89 };// RNM(owsp)\n  this.rules[14].opcodes[5] = { type: 4, index: 44 };// RNM(AltOp)\n  this.rules[14].opcodes[6] = { type: 4, index: 15 };// RNM(Concatenation)\n\n  /* Concatenation */\n  this.rules[15].opcodes = [];\n  this.rules[15].opcodes[0] = { type: 2, children: [1,2] };// CAT\n  this.rules[15].opcodes[1] = { type: 4, index: 16 };// RNM(Repetition)\n  this.rules[15].opcodes[2] = { type: 3, min: 0, max: Infinity };// REP\n  this.rules[15].opcodes[3] = { type: 2, children: [4,5] };// CAT\n  this.rules[15].opcodes[4] = { type: 4, index: 45 };// RNM(CatOp)\n  this.rules[15].opcodes[5] = { type: 4, index: 16 };// RNM(Repetition)\n\n  /* Repetition */\n  this.rules[16].opcodes = [];\n  this.rules[16].opcodes[0] = { type: 2, children: [1,3] };// CAT\n  this.rules[16].opcodes[1] = { type: 3, min: 0, max: 1 };// REP\n  this.rules[16].opcodes[2] = { type: 4, index: 17 };// RNM(Modifier)\n  this.rules[16].opcodes[3] = { type: 1, children: [4,5,6,7] };// ALT\n  this.rules[16].opcodes[4] = { type: 4, index: 21 };// RNM(Group)\n  this.rules[16].opcodes[5] = { type: 4, index: 25 };// RNM(Option)\n  this.rules[16].opcodes[6] = { type: 4, index: 19 };// RNM(BasicElement)\n  this.rules[16].opcodes[7] = { type: 4, index: 20 };// RNM(BasicElementErr)\n\n  /* Modifier */\n  this.rules[17].opcodes = [];\n  this.rules[17].opcodes[0] = { type: 1, children: [1,5] };// ALT\n  this.rules[17].opcodes[1] = { type: 2, children: [2,3] };// CAT\n  this.rules[17].opcodes[2] = { type: 4, index: 18 };// RNM(Predicate)\n  this.rules[17].opcodes[3] = { type: 3, min: 0, max: 1 };// REP\n  this.rules[17].opcodes[4] = { type: 4, index: 43 };// RNM(RepOp)\n  this.rules[17].opcodes[5] = { type: 4, index: 43 };// RNM(RepOp)\n\n  /* Predicate */\n  this.rules[18].opcodes = [];\n  this.rules[18].opcodes[0] = { type: 1, children: [1,2,3,4] };// ALT\n  this.rules[18].opcodes[1] = { type: 4, index: 49 };// RNM(BkaOp)\n  this.rules[18].opcodes[2] = { type: 4, index: 50 };// RNM(BknOp)\n  this.rules[18].opcodes[3] = { type: 4, index: 47 };// RNM(AndOp)\n  this.rules[18].opcodes[4] = { type: 4, index: 48 };// RNM(NotOp)\n\n  /* BasicElement */\n  this.rules[19].opcodes = [];\n  this.rules[19].opcodes[0] = { type: 1, children: [1,2,3,4,5,6,7,8,9,10] };// ALT\n  this.rules[19].opcodes[1] = { type: 4, index: 40 };// RNM(UdtOp)\n  this.rules[19].opcodes[2] = { type: 4, index: 29 };// RNM(RnmOp)\n  this.rules[19].opcodes[3] = { type: 4, index: 53 };// RNM(TrgOp)\n  this.rules[19].opcodes[4] = { type: 4, index: 54 };// RNM(TbsOp)\n  this.rules[19].opcodes[5] = { type: 4, index: 55 };// RNM(TlsOp)\n  this.rules[19].opcodes[6] = { type: 4, index: 61 };// RNM(ClsOp)\n  this.rules[19].opcodes[7] = { type: 4, index: 30 };// RNM(BkrOp)\n  this.rules[19].opcodes[8] = { type: 4, index: 51 };// RNM(AbgOp)\n  this.rules[19].opcodes[9] = { type: 4, index: 52 };// RNM(AenOp)\n  this.rules[19].opcodes[10] = { type: 4, index: 65 };// RNM(ProsVal)\n\n  /* BasicElementErr */\n  this.rules[20].opcodes = [];\n  this.rules[20].opcodes[0] = { type: 3, min: 1, max: Infinity };// REP\n  this.rules[20].opcodes[1] = { type: 1, children: [2,3,4,5] };// ALT\n  this.rules[20].opcodes[2] = { type: 5, min: 33, max: 40 };// TRG\n  this.rules[20].opcodes[3] = { type: 5, min: 42, max: 46 };// TRG\n  this.rules[20].opcodes[4] = { type: 5, min: 48, max: 92 };// TRG\n  this.rules[20].opcodes[5] = { type: 5, min: 94, max: 126 };// TRG\n\n  /* Group */\n  this.rules[21].opcodes = [];\n  this.rules[21].opcodes[0] = { type: 2, children: [1,2,3] };// CAT\n  this.rules[21].opcodes[1] = { type: 4, index: 23 };// RNM(GroupOpen)\n  this.rules[21].opcodes[2] = { type: 4, index: 14 };// RNM(Alternation)\n  this.rules[21].opcodes[3] = { type: 1, children: [4,5] };// ALT\n  this.rules[21].opcodes[4] = { type: 4, index: 24 };// RNM(GroupClose)\n  this.rules[21].opcodes[5] = { type: 4, index: 22 };// RNM(GroupError)\n\n  /* GroupError */\n  this.rules[22].opcodes = [];\n  this.rules[22].opcodes[0] = { type: 3, min: 1, max: Infinity };// REP\n  this.rules[22].opcodes[1] = { type: 1, children: [2,3,4,5] };// ALT\n  this.rules[22].opcodes[2] = { type: 5, min: 33, max: 40 };// TRG\n  this.rules[22].opcodes[3] = { type: 5, min: 42, max: 46 };// TRG\n  this.rules[22].opcodes[4] = { type: 5, min: 48, max: 92 };// TRG\n  this.rules[22].opcodes[5] = { type: 5, min: 94, max: 126 };// TRG\n\n  /* GroupOpen */\n  this.rules[23].opcodes = [];\n  this.rules[23].opcodes[0] = { type: 2, children: [1,2] };// CAT\n  this.rules[23].opcodes[1] = { type: 6, string: [40] };// TBS\n  this.rules[23].opcodes[2] = { type: 4, index: 89 };// RNM(owsp)\n\n  /* GroupClose */\n  this.rules[24].opcodes = [];\n  this.rules[24].opcodes[0] = { type: 2, children: [1,2] };// CAT\n  this.rules[24].opcodes[1] = { type: 4, index: 89 };// RNM(owsp)\n  this.rules[24].opcodes[2] = { type: 6, string: [41] };// TBS\n\n  /* Option */\n  this.rules[25].opcodes = [];\n  this.rules[25].opcodes[0] = { type: 2, children: [1,2,3] };// CAT\n  this.rules[25].opcodes[1] = { type: 4, index: 27 };// RNM(OptionOpen)\n  this.rules[25].opcodes[2] = { type: 4, index: 14 };// RNM(Alternation)\n  this.rules[25].opcodes[3] = { type: 1, children: [4,5] };// ALT\n  this.rules[25].opcodes[4] = { type: 4, index: 28 };// RNM(OptionClose)\n  this.rules[25].opcodes[5] = { type: 4, index: 26 };// RNM(OptionError)\n\n  /* OptionError */\n  this.rules[26].opcodes = [];\n  this.rules[26].opcodes[0] = { type: 3, min: 1, max: Infinity };// REP\n  this.rules[26].opcodes[1] = { type: 1, children: [2,3,4,5] };// ALT\n  this.rules[26].opcodes[2] = { type: 5, min: 33, max: 40 };// TRG\n  this.rules[26].opcodes[3] = { type: 5, min: 42, max: 46 };// TRG\n  this.rules[26].opcodes[4] = { type: 5, min: 48, max: 92 };// TRG\n  this.rules[26].opcodes[5] = { type: 5, min: 94, max: 126 };// TRG\n\n  /* OptionOpen */\n  this.rules[27].opcodes = [];\n  this.rules[27].opcodes[0] = { type: 2, children: [1,2] };// CAT\n  this.rules[27].opcodes[1] = { type: 6, string: [91] };// TBS\n  this.rules[27].opcodes[2] = { type: 4, index: 89 };// RNM(owsp)\n\n  /* OptionClose */\n  this.rules[28].opcodes = [];\n  this.rules[28].opcodes[0] = { type: 2, children: [1,2] };// CAT\n  this.rules[28].opcodes[1] = { type: 4, index: 89 };// RNM(owsp)\n  this.rules[28].opcodes[2] = { type: 6, string: [93] };// TBS\n\n  /* RnmOp */\n  this.rules[29].opcodes = [];\n  this.rules[29].opcodes[0] = { type: 4, index: 88 };// RNM(alphanum)\n\n  /* BkrOp */\n  this.rules[30].opcodes = [];\n  this.rules[30].opcodes[0] = { type: 2, children: [1,2,4] };// CAT\n  this.rules[30].opcodes[1] = { type: 6, string: [92] };// TBS\n  this.rules[30].opcodes[2] = { type: 3, min: 0, max: 1 };// REP\n  this.rules[30].opcodes[3] = { type: 4, index: 31 };// RNM(bkrModifier)\n  this.rules[30].opcodes[4] = { type: 4, index: 36 };// RNM(bkr-name)\n\n  /* bkrModifier */\n  this.rules[31].opcodes = [];\n  this.rules[31].opcodes[0] = { type: 1, children: [1,7,13,19] };// ALT\n  this.rules[31].opcodes[1] = { type: 2, children: [2,3] };// CAT\n  this.rules[31].opcodes[2] = { type: 4, index: 32 };// RNM(cs)\n  this.rules[31].opcodes[3] = { type: 3, min: 0, max: 1 };// REP\n  this.rules[31].opcodes[4] = { type: 1, children: [5,6] };// ALT\n  this.rules[31].opcodes[5] = { type: 4, index: 34 };// RNM(um)\n  this.rules[31].opcodes[6] = { type: 4, index: 35 };// RNM(pm)\n  this.rules[31].opcodes[7] = { type: 2, children: [8,9] };// CAT\n  this.rules[31].opcodes[8] = { type: 4, index: 33 };// RNM(ci)\n  this.rules[31].opcodes[9] = { type: 3, min: 0, max: 1 };// REP\n  this.rules[31].opcodes[10] = { type: 1, children: [11,12] };// ALT\n  this.rules[31].opcodes[11] = { type: 4, index: 34 };// RNM(um)\n  this.rules[31].opcodes[12] = { type: 4, index: 35 };// RNM(pm)\n  this.rules[31].opcodes[13] = { type: 2, children: [14,15] };// CAT\n  this.rules[31].opcodes[14] = { type: 4, index: 34 };// RNM(um)\n  this.rules[31].opcodes[15] = { type: 3, min: 0, max: 1 };// REP\n  this.rules[31].opcodes[16] = { type: 1, children: [17,18] };// ALT\n  this.rules[31].opcodes[17] = { type: 4, index: 32 };// RNM(cs)\n  this.rules[31].opcodes[18] = { type: 4, index: 33 };// RNM(ci)\n  this.rules[31].opcodes[19] = { type: 2, children: [20,21] };// CAT\n  this.rules[31].opcodes[20] = { type: 4, index: 35 };// RNM(pm)\n  this.rules[31].opcodes[21] = { type: 3, min: 0, max: 1 };// REP\n  this.rules[31].opcodes[22] = { type: 1, children: [23,24] };// ALT\n  this.rules[31].opcodes[23] = { type: 4, index: 32 };// RNM(cs)\n  this.rules[31].opcodes[24] = { type: 4, index: 33 };// RNM(ci)\n\n  /* cs */\n  this.rules[32].opcodes = [];\n  this.rules[32].opcodes[0] = { type: 6, string: [37,115] };// TBS\n\n  /* ci */\n  this.rules[33].opcodes = [];\n  this.rules[33].opcodes[0] = { type: 6, string: [37,105] };// TBS\n\n  /* um */\n  this.rules[34].opcodes = [];\n  this.rules[34].opcodes[0] = { type: 6, string: [37,117] };// TBS\n\n  /* pm */\n  this.rules[35].opcodes = [];\n  this.rules[35].opcodes[0] = { type: 6, string: [37,112] };// TBS\n\n  /* bkr-name */\n  this.rules[36].opcodes = [];\n  this.rules[36].opcodes[0] = { type: 1, children: [1,2,3] };// ALT\n  this.rules[36].opcodes[1] = { type: 4, index: 38 };// RNM(uname)\n  this.rules[36].opcodes[2] = { type: 4, index: 39 };// RNM(ename)\n  this.rules[36].opcodes[3] = { type: 4, index: 37 };// RNM(rname)\n\n  /* rname */\n  this.rules[37].opcodes = [];\n  this.rules[37].opcodes[0] = { type: 4, index: 88 };// RNM(alphanum)\n\n  /* uname */\n  this.rules[38].opcodes = [];\n  this.rules[38].opcodes[0] = { type: 2, children: [1,2] };// CAT\n  this.rules[38].opcodes[1] = { type: 6, string: [117,95] };// TBS\n  this.rules[38].opcodes[2] = { type: 4, index: 88 };// RNM(alphanum)\n\n  /* ename */\n  this.rules[39].opcodes = [];\n  this.rules[39].opcodes[0] = { type: 2, children: [1,2] };// CAT\n  this.rules[39].opcodes[1] = { type: 6, string: [101,95] };// TBS\n  this.rules[39].opcodes[2] = { type: 4, index: 88 };// RNM(alphanum)\n\n  /* UdtOp */\n  this.rules[40].opcodes = [];\n  this.rules[40].opcodes[0] = { type: 1, children: [1,2] };// ALT\n  this.rules[40].opcodes[1] = { type: 4, index: 42 };// RNM(udt-empty)\n  this.rules[40].opcodes[2] = { type: 4, index: 41 };// RNM(udt-non-empty)\n\n  /* udt-non-empty */\n  this.rules[41].opcodes = [];\n  this.rules[41].opcodes[0] = { type: 2, children: [1,2] };// CAT\n  this.rules[41].opcodes[1] = { type: 6, string: [117,95] };// TBS\n  this.rules[41].opcodes[2] = { type: 4, index: 88 };// RNM(alphanum)\n\n  /* udt-empty */\n  this.rules[42].opcodes = [];\n  this.rules[42].opcodes[0] = { type: 2, children: [1,2] };// CAT\n  this.rules[42].opcodes[1] = { type: 6, string: [101,95] };// TBS\n  this.rules[42].opcodes[2] = { type: 4, index: 88 };// RNM(alphanum)\n\n  /* RepOp */\n  this.rules[43].opcodes = [];\n  this.rules[43].opcodes[0] = { type: 1, children: [1,5,8,11,12] };// ALT\n  this.rules[43].opcodes[1] = { type: 2, children: [2,3,4] };// CAT\n  this.rules[43].opcodes[2] = { type: 4, index: 69 };// RNM(rep-min)\n  this.rules[43].opcodes[3] = { type: 4, index: 46 };// RNM(StarOp)\n  this.rules[43].opcodes[4] = { type: 4, index: 71 };// RNM(rep-max)\n  this.rules[43].opcodes[5] = { type: 2, children: [6,7] };// CAT\n  this.rules[43].opcodes[6] = { type: 4, index: 69 };// RNM(rep-min)\n  this.rules[43].opcodes[7] = { type: 4, index: 46 };// RNM(StarOp)\n  this.rules[43].opcodes[8] = { type: 2, children: [9,10] };// CAT\n  this.rules[43].opcodes[9] = { type: 4, index: 46 };// RNM(StarOp)\n  this.rules[43].opcodes[10] = { type: 4, index: 71 };// RNM(rep-max)\n  this.rules[43].opcodes[11] = { type: 4, index: 46 };// RNM(StarOp)\n  this.rules[43].opcodes[12] = { type: 4, index: 70 };// RNM(rep-min-max)\n\n  /* AltOp */\n  this.rules[44].opcodes = [];\n  this.rules[44].opcodes[0] = { type: 2, children: [1,2] };// CAT\n  this.rules[44].opcodes[1] = { type: 6, string: [47] };// TBS\n  this.rules[44].opcodes[2] = { type: 4, index: 89 };// RNM(owsp)\n\n  /* CatOp */\n  this.rules[45].opcodes = [];\n  this.rules[45].opcodes[0] = { type: 4, index: 90 };// RNM(wsp)\n\n  /* StarOp */\n  this.rules[46].opcodes = [];\n  this.rules[46].opcodes[0] = { type: 6, string: [42] };// TBS\n\n  /* AndOp */\n  this.rules[47].opcodes = [];\n  this.rules[47].opcodes[0] = { type: 6, string: [38] };// TBS\n\n  /* NotOp */\n  this.rules[48].opcodes = [];\n  this.rules[48].opcodes[0] = { type: 6, string: [33] };// TBS\n\n  /* BkaOp */\n  this.rules[49].opcodes = [];\n  this.rules[49].opcodes[0] = { type: 6, string: [38,38] };// TBS\n\n  /* BknOp */\n  this.rules[50].opcodes = [];\n  this.rules[50].opcodes[0] = { type: 6, string: [33,33] };// TBS\n\n  /* AbgOp */\n  this.rules[51].opcodes = [];\n  this.rules[51].opcodes[0] = { type: 6, string: [37,94] };// TBS\n\n  /* AenOp */\n  this.rules[52].opcodes = [];\n  this.rules[52].opcodes[0] = { type: 6, string: [37,36] };// TBS\n\n  /* TrgOp */\n  this.rules[53].opcodes = [];\n  this.rules[53].opcodes[0] = { type: 2, children: [1,2] };// CAT\n  this.rules[53].opcodes[1] = { type: 6, string: [37] };// TBS\n  this.rules[53].opcodes[2] = { type: 1, children: [3,8,13] };// ALT\n  this.rules[53].opcodes[3] = { type: 2, children: [4,5,6,7] };// CAT\n  this.rules[53].opcodes[4] = { type: 4, index: 76 };// RNM(Dec)\n  this.rules[53].opcodes[5] = { type: 4, index: 79 };// RNM(dmin)\n  this.rules[53].opcodes[6] = { type: 6, string: [45] };// TBS\n  this.rules[53].opcodes[7] = { type: 4, index: 80 };// RNM(dmax)\n  this.rules[53].opcodes[8] = { type: 2, children: [9,10,11,12] };// CAT\n  this.rules[53].opcodes[9] = { type: 4, index: 77 };// RNM(Hex)\n  this.rules[53].opcodes[10] = { type: 4, index: 83 };// RNM(xmin)\n  this.rules[53].opcodes[11] = { type: 6, string: [45] };// TBS\n  this.rules[53].opcodes[12] = { type: 4, index: 84 };// RNM(xmax)\n  this.rules[53].opcodes[13] = { type: 2, children: [14,15,16,17] };// CAT\n  this.rules[53].opcodes[14] = { type: 4, index: 78 };// RNM(Bin)\n  this.rules[53].opcodes[15] = { type: 4, index: 81 };// RNM(bmin)\n  this.rules[53].opcodes[16] = { type: 6, string: [45] };// TBS\n  this.rules[53].opcodes[17] = { type: 4, index: 82 };// RNM(bmax)\n\n  /* TbsOp */\n  this.rules[54].opcodes = [];\n  this.rules[54].opcodes[0] = { type: 2, children: [1,2] };// CAT\n  this.rules[54].opcodes[1] = { type: 6, string: [37] };// TBS\n  this.rules[54].opcodes[2] = { type: 1, children: [3,10,17] };// ALT\n  this.rules[54].opcodes[3] = { type: 2, children: [4,5,6] };// CAT\n  this.rules[54].opcodes[4] = { type: 4, index: 76 };// RNM(Dec)\n  this.rules[54].opcodes[5] = { type: 4, index: 73 };// RNM(dString)\n  this.rules[54].opcodes[6] = { type: 3, min: 0, max: Infinity };// REP\n  this.rules[54].opcodes[7] = { type: 2, children: [8,9] };// CAT\n  this.rules[54].opcodes[8] = { type: 6, string: [46] };// TBS\n  this.rules[54].opcodes[9] = { type: 4, index: 73 };// RNM(dString)\n  this.rules[54].opcodes[10] = { type: 2, children: [11,12,13] };// CAT\n  this.rules[54].opcodes[11] = { type: 4, index: 77 };// RNM(Hex)\n  this.rules[54].opcodes[12] = { type: 4, index: 74 };// RNM(xString)\n  this.rules[54].opcodes[13] = { type: 3, min: 0, max: Infinity };// REP\n  this.rules[54].opcodes[14] = { type: 2, children: [15,16] };// CAT\n  this.rules[54].opcodes[15] = { type: 6, string: [46] };// TBS\n  this.rules[54].opcodes[16] = { type: 4, index: 74 };// RNM(xString)\n  this.rules[54].opcodes[17] = { type: 2, children: [18,19,20] };// CAT\n  this.rules[54].opcodes[18] = { type: 4, index: 78 };// RNM(Bin)\n  this.rules[54].opcodes[19] = { type: 4, index: 75 };// RNM(bString)\n  this.rules[54].opcodes[20] = { type: 3, min: 0, max: Infinity };// REP\n  this.rules[54].opcodes[21] = { type: 2, children: [22,23] };// CAT\n  this.rules[54].opcodes[22] = { type: 6, string: [46] };// TBS\n  this.rules[54].opcodes[23] = { type: 4, index: 75 };// RNM(bString)\n\n  /* TlsOp */\n  this.rules[55].opcodes = [];\n  this.rules[55].opcodes[0] = { type: 2, children: [1,2,3,4] };// CAT\n  this.rules[55].opcodes[1] = { type: 4, index: 56 };// RNM(TlsCase)\n  this.rules[55].opcodes[2] = { type: 4, index: 57 };// RNM(TlsOpen)\n  this.rules[55].opcodes[3] = { type: 4, index: 59 };// RNM(TlsString)\n  this.rules[55].opcodes[4] = { type: 4, index: 58 };// RNM(TlsClose)\n\n  /* TlsCase */\n  this.rules[56].opcodes = [];\n  this.rules[56].opcodes[0] = { type: 3, min: 0, max: 1 };// REP\n  this.rules[56].opcodes[1] = { type: 1, children: [2,3] };// ALT\n  this.rules[56].opcodes[2] = { type: 7, string: [37,105] };// TLS\n  this.rules[56].opcodes[3] = { type: 7, string: [37,115] };// TLS\n\n  /* TlsOpen */\n  this.rules[57].opcodes = [];\n  this.rules[57].opcodes[0] = { type: 6, string: [34] };// TBS\n\n  /* TlsClose */\n  this.rules[58].opcodes = [];\n  this.rules[58].opcodes[0] = { type: 6, string: [34] };// TBS\n\n  /* TlsString */\n  this.rules[59].opcodes = [];\n  this.rules[59].opcodes[0] = { type: 3, min: 0, max: Infinity };// REP\n  this.rules[59].opcodes[1] = { type: 1, children: [2,3,4] };// ALT\n  this.rules[59].opcodes[2] = { type: 5, min: 32, max: 33 };// TRG\n  this.rules[59].opcodes[3] = { type: 5, min: 35, max: 126 };// TRG\n  this.rules[59].opcodes[4] = { type: 4, index: 60 };// RNM(StringTab)\n\n  /* StringTab */\n  this.rules[60].opcodes = [];\n  this.rules[60].opcodes[0] = { type: 6, string: [9] };// TBS\n\n  /* ClsOp */\n  this.rules[61].opcodes = [];\n  this.rules[61].opcodes[0] = { type: 2, children: [1,2,3] };// CAT\n  this.rules[61].opcodes[1] = { type: 4, index: 62 };// RNM(ClsOpen)\n  this.rules[61].opcodes[2] = { type: 4, index: 64 };// RNM(ClsString)\n  this.rules[61].opcodes[3] = { type: 4, index: 63 };// RNM(ClsClose)\n\n  /* ClsOpen */\n  this.rules[62].opcodes = [];\n  this.rules[62].opcodes[0] = { type: 6, string: [39] };// TBS\n\n  /* ClsClose */\n  this.rules[63].opcodes = [];\n  this.rules[63].opcodes[0] = { type: 6, string: [39] };// TBS\n\n  /* ClsString */\n  this.rules[64].opcodes = [];\n  this.rules[64].opcodes[0] = { type: 3, min: 0, max: Infinity };// REP\n  this.rules[64].opcodes[1] = { type: 1, children: [2,3,4] };// ALT\n  this.rules[64].opcodes[2] = { type: 5, min: 32, max: 38 };// TRG\n  this.rules[64].opcodes[3] = { type: 5, min: 40, max: 126 };// TRG\n  this.rules[64].opcodes[4] = { type: 4, index: 60 };// RNM(StringTab)\n\n  /* ProsVal */\n  this.rules[65].opcodes = [];\n  this.rules[65].opcodes[0] = { type: 2, children: [1,2,3] };// CAT\n  this.rules[65].opcodes[1] = { type: 4, index: 66 };// RNM(ProsValOpen)\n  this.rules[65].opcodes[2] = { type: 4, index: 67 };// RNM(ProsValString)\n  this.rules[65].opcodes[3] = { type: 4, index: 68 };// RNM(ProsValClose)\n\n  /* ProsValOpen */\n  this.rules[66].opcodes = [];\n  this.rules[66].opcodes[0] = { type: 6, string: [60] };// TBS\n\n  /* ProsValString */\n  this.rules[67].opcodes = [];\n  this.rules[67].opcodes[0] = { type: 3, min: 0, max: Infinity };// REP\n  this.rules[67].opcodes[1] = { type: 1, children: [2,3,4] };// ALT\n  this.rules[67].opcodes[2] = { type: 5, min: 32, max: 61 };// TRG\n  this.rules[67].opcodes[3] = { type: 5, min: 63, max: 126 };// TRG\n  this.rules[67].opcodes[4] = { type: 4, index: 60 };// RNM(StringTab)\n\n  /* ProsValClose */\n  this.rules[68].opcodes = [];\n  this.rules[68].opcodes[0] = { type: 6, string: [62] };// TBS\n\n  /* rep-min */\n  this.rules[69].opcodes = [];\n  this.rules[69].opcodes[0] = { type: 4, index: 72 };// RNM(rep-num)\n\n  /* rep-min-max */\n  this.rules[70].opcodes = [];\n  this.rules[70].opcodes[0] = { type: 4, index: 72 };// RNM(rep-num)\n\n  /* rep-max */\n  this.rules[71].opcodes = [];\n  this.rules[71].opcodes[0] = { type: 4, index: 72 };// RNM(rep-num)\n\n  /* rep-num */\n  this.rules[72].opcodes = [];\n  this.rules[72].opcodes[0] = { type: 3, min: 1, max: Infinity };// REP\n  this.rules[72].opcodes[1] = { type: 5, min: 48, max: 57 };// TRG\n\n  /* dString */\n  this.rules[73].opcodes = [];\n  this.rules[73].opcodes[0] = { type: 4, index: 85 };// RNM(dnum)\n\n  /* xString */\n  this.rules[74].opcodes = [];\n  this.rules[74].opcodes[0] = { type: 4, index: 87 };// RNM(xnum)\n\n  /* bString */\n  this.rules[75].opcodes = [];\n  this.rules[75].opcodes[0] = { type: 4, index: 86 };// RNM(bnum)\n\n  /* Dec */\n  this.rules[76].opcodes = [];\n  this.rules[76].opcodes[0] = { type: 1, children: [1,2] };// ALT\n  this.rules[76].opcodes[1] = { type: 6, string: [68] };// TBS\n  this.rules[76].opcodes[2] = { type: 6, string: [100] };// TBS\n\n  /* Hex */\n  this.rules[77].opcodes = [];\n  this.rules[77].opcodes[0] = { type: 1, children: [1,2] };// ALT\n  this.rules[77].opcodes[1] = { type: 6, string: [88] };// TBS\n  this.rules[77].opcodes[2] = { type: 6, string: [120] };// TBS\n\n  /* Bin */\n  this.rules[78].opcodes = [];\n  this.rules[78].opcodes[0] = { type: 1, children: [1,2] };// ALT\n  this.rules[78].opcodes[1] = { type: 6, string: [66] };// TBS\n  this.rules[78].opcodes[2] = { type: 6, string: [98] };// TBS\n\n  /* dmin */\n  this.rules[79].opcodes = [];\n  this.rules[79].opcodes[0] = { type: 4, index: 85 };// RNM(dnum)\n\n  /* dmax */\n  this.rules[80].opcodes = [];\n  this.rules[80].opcodes[0] = { type: 4, index: 85 };// RNM(dnum)\n\n  /* bmin */\n  this.rules[81].opcodes = [];\n  this.rules[81].opcodes[0] = { type: 4, index: 86 };// RNM(bnum)\n\n  /* bmax */\n  this.rules[82].opcodes = [];\n  this.rules[82].opcodes[0] = { type: 4, index: 86 };// RNM(bnum)\n\n  /* xmin */\n  this.rules[83].opcodes = [];\n  this.rules[83].opcodes[0] = { type: 4, index: 87 };// RNM(xnum)\n\n  /* xmax */\n  this.rules[84].opcodes = [];\n  this.rules[84].opcodes[0] = { type: 4, index: 87 };// RNM(xnum)\n\n  /* dnum */\n  this.rules[85].opcodes = [];\n  this.rules[85].opcodes[0] = { type: 3, min: 1, max: Infinity };// REP\n  this.rules[85].opcodes[1] = { type: 5, min: 48, max: 57 };// TRG\n\n  /* bnum */\n  this.rules[86].opcodes = [];\n  this.rules[86].opcodes[0] = { type: 3, min: 1, max: Infinity };// REP\n  this.rules[86].opcodes[1] = { type: 5, min: 48, max: 49 };// TRG\n\n  /* xnum */\n  this.rules[87].opcodes = [];\n  this.rules[87].opcodes[0] = { type: 3, min: 1, max: Infinity };// REP\n  this.rules[87].opcodes[1] = { type: 1, children: [2,3,4] };// ALT\n  this.rules[87].opcodes[2] = { type: 5, min: 48, max: 57 };// TRG\n  this.rules[87].opcodes[3] = { type: 5, min: 65, max: 70 };// TRG\n  this.rules[87].opcodes[4] = { type: 5, min: 97, max: 102 };// TRG\n\n  /* alphanum */\n  this.rules[88].opcodes = [];\n  this.rules[88].opcodes[0] = { type: 2, children: [1,4] };// CAT\n  this.rules[88].opcodes[1] = { type: 1, children: [2,3] };// ALT\n  this.rules[88].opcodes[2] = { type: 5, min: 97, max: 122 };// TRG\n  this.rules[88].opcodes[3] = { type: 5, min: 65, max: 90 };// TRG\n  this.rules[88].opcodes[4] = { type: 3, min: 0, max: Infinity };// REP\n  this.rules[88].opcodes[5] = { type: 1, children: [6,7,8,9] };// ALT\n  this.rules[88].opcodes[6] = { type: 5, min: 97, max: 122 };// TRG\n  this.rules[88].opcodes[7] = { type: 5, min: 65, max: 90 };// TRG\n  this.rules[88].opcodes[8] = { type: 5, min: 48, max: 57 };// TRG\n  this.rules[88].opcodes[9] = { type: 6, string: [45] };// TBS\n\n  /* owsp */\n  this.rules[89].opcodes = [];\n  this.rules[89].opcodes[0] = { type: 3, min: 0, max: Infinity };// REP\n  this.rules[89].opcodes[1] = { type: 4, index: 91 };// RNM(space)\n\n  /* wsp */\n  this.rules[90].opcodes = [];\n  this.rules[90].opcodes[0] = { type: 3, min: 1, max: Infinity };// REP\n  this.rules[90].opcodes[1] = { type: 4, index: 91 };// RNM(space)\n\n  /* space */\n  this.rules[91].opcodes = [];\n  this.rules[91].opcodes[0] = { type: 1, children: [1,2,3,4] };// ALT\n  this.rules[91].opcodes[1] = { type: 6, string: [32] };// TBS\n  this.rules[91].opcodes[2] = { type: 6, string: [9] };// TBS\n  this.rules[91].opcodes[3] = { type: 4, index: 92 };// RNM(comment)\n  this.rules[91].opcodes[4] = { type: 4, index: 94 };// RNM(LineContinue)\n\n  /* comment */\n  this.rules[92].opcodes = [];\n  this.rules[92].opcodes[0] = { type: 2, children: [1,2] };// CAT\n  this.rules[92].opcodes[1] = { type: 6, string: [59] };// TBS\n  this.rules[92].opcodes[2] = { type: 3, min: 0, max: Infinity };// REP\n  this.rules[92].opcodes[3] = { type: 1, children: [4,5] };// ALT\n  this.rules[92].opcodes[4] = { type: 5, min: 32, max: 126 };// TRG\n  this.rules[92].opcodes[5] = { type: 6, string: [9] };// TBS\n\n  /* LineEnd */\n  this.rules[93].opcodes = [];\n  this.rules[93].opcodes[0] = { type: 1, children: [1,2,3] };// ALT\n  this.rules[93].opcodes[1] = { type: 6, string: [13,10] };// TBS\n  this.rules[93].opcodes[2] = { type: 6, string: [10] };// TBS\n  this.rules[93].opcodes[3] = { type: 6, string: [13] };// TBS\n\n  /* LineContinue */\n  this.rules[94].opcodes = [];\n  this.rules[94].opcodes[0] = { type: 2, children: [1,5] };// CAT\n  this.rules[94].opcodes[1] = { type: 1, children: [2,3,4] };// ALT\n  this.rules[94].opcodes[2] = { type: 6, string: [13,10] };// TBS\n  this.rules[94].opcodes[3] = { type: 6, string: [10] };// TBS\n  this.rules[94].opcodes[4] = { type: 6, string: [13] };// TBS\n  this.rules[94].opcodes[5] = { type: 1, children: [6,7] };// ALT\n  this.rules[94].opcodes[6] = { type: 6, string: [32] };// TBS\n  this.rules[94].opcodes[7] = { type: 6, string: [9] };// TBS\n\n  // The `toString()` function will display the original grammar file(s) that produced these opcodes.\n  this.toString = function toString(){\n    let str = \"\";\n    str += \";\\n\";\n    str += \"; ABNF for JavaScript APG 2.0 SABNF\\n\";\n    str += \"; RFC 5234 with some restrictions and additions.\\n\";\n    str += \"; Updated 11/24/2015 for RFC 7405 case-sensitive literal string notation\\n\";\n    str += \";  - accepts %s\\\"string\\\" as a case-sensitive string\\n\";\n    str += \";  - accepts %i\\\"string\\\" as a case-insensitive string\\n\";\n    str += \";  - accepts \\\"string\\\" as a case-insensitive string\\n\";\n    str += \";\\n\";\n    str += \"; Some restrictions:\\n\";\n    str += \";   1. Rules must begin at first character of each line.\\n\";\n    str += \";      Indentations on first rule and rules thereafter are not allowed.\\n\";\n    str += \";   2. Relaxed line endings. CRLF, LF or CR are accepted as valid line ending.\\n\";\n    str += \";   3. Prose values, i.e. <prose value>, are accepted as valid grammar syntax.\\n\";\n    str += \";      However, a working parser cannot be generated from them.\\n\";\n    str += \";\\n\";\n    str += \"; Super set (SABNF) additions:\\n\";\n    str += \";   1. Look-ahead (syntactic predicate) operators are accepted as element prefixes.\\n\";\n    str += \";      & is the positive look-ahead operator, succeeds and backtracks if the look-ahead phrase is found\\n\";\n    str += \";      ! is the negative look-ahead operator, succeeds and backtracks if the look-ahead phrase is NOT found\\n\";\n    str += \";      e.g. &%d13 or &rule or !(A / B)\\n\";\n    str += \";   2. User-Defined Terminals (UDT) of the form, u_name and e_name are accepted.\\n\";\n    str += \";      'name' is alpha followed by alpha/num/hyphen just like a rule name.\\n\";\n    str += \";      u_name may be used as an element but no rule definition is given.\\n\";\n    str += \";      e.g. rule = A / u_myUdt\\n\";\n    str += \";           A = \\\"a\\\"\\n\";\n    str += \";      would be a valid grammar.\\n\";\n    str += \";   3. Case-sensitive, single-quoted strings are accepted.\\n\";\n    str += \";      e.g. 'abc' would be equivalent to %d97.98.99\\n\";\n    str += \";      (kept for backward compatibility, but superseded by %s\\\"abc\\\")  \\n\";\n    str += \"; New 12/26/2015\\n\";\n    str += \";   4. Look-behind operators are accepted as element prefixes.\\n\";\n    str += \";      && is the positive look-behind operator, succeeds and backtracks if the look-behind phrase is found\\n\";\n    str += \";      !! is the negative look-behind operator, succeeds and backtracks if the look-behind phrase is NOT found\\n\";\n    str += \";      e.g. &&%d13 or &&rule or !!(A / B)\\n\";\n    str += \";   5. Back reference operators, i.e. \\\\rulename, are accepted.\\n\";\n    str += \";      A back reference operator acts like a TLS or TBS terminal except that the phrase it attempts\\n\";\n    str += \";      to match is a phrase previously matched by the rule 'rulename'.\\n\";\n    str += \";      There are two modes of previous phrase matching - the parent-frame mode and the universal mode.\\n\";\n    str += \";      In universal mode, \\\\rulename matches the last match to 'rulename' regardless of where it was found.\\n\";\n    str += \";      In parent-frame mode, \\\\rulename matches only the last match found on the parent's frame or parse tree level.\\n\";\n    str += \";      Back reference modifiers can be used to specify case and mode.\\n\";\n    str += \";      \\\\A defaults to case-insensitive and universal mode, e.g. \\\\A === \\\\%i%uA\\n\";\n    str += \";      Modifiers %i and %s determine case-insensitive and case-sensitive mode, respectively.\\n\";\n    str += \";      Modifiers %u and %p determine universal mode and parent frame mode, respectively.\\n\";\n    str += \";      Case and mode modifiers can appear in any order, e.g. \\\\%s%pA === \\\\%p%sA. \\n\";\n    str += \";   7. String begin anchor, ABG(%^) matches the beginning of the input string location.\\n\";\n    str += \";      Returns EMPTY or NOMATCH. Never consumes any characters.\\n\";\n    str += \";   8. String end anchor, AEN(%$) matches the end of the input string location.\\n\";\n    str += \";      Returns EMPTY or NOMATCH. Never consumes any characters.\\n\";\n    str += \";\\n\";\n    str += \"File            = *(BlankLine / Rule / RuleError)\\n\";\n    str += \"BlankLine       = *(%d32/%d9) [comment] LineEnd\\n\";\n    str += \"Rule            = RuleLookup owsp Alternation ((owsp LineEnd)\\n\";\n    str += \"                / (LineEndError LineEnd))\\n\";\n    str += \"RuleLookup      = RuleNameTest owsp DefinedAsTest\\n\";\n    str += \"RuleNameTest    = RuleName/RuleNameError\\n\";\n    str += \"RuleName        = alphanum\\n\";\n    str += \"RuleNameError   = 1*(%d33-60/%d62-126)\\n\";\n    str += \"DefinedAsTest   = DefinedAs / DefinedAsError\\n\";\n    str += \"DefinedAsError  = 1*2%d33-126\\n\";\n    str += \"DefinedAs       = IncAlt / Defined\\n\";\n    str += \"Defined         = %d61\\n\";\n    str += \"IncAlt          = %d61.47\\n\";\n    str += \"RuleError       = 1*(%d32-126 / %d9  / LineContinue) LineEnd\\n\";\n    str += \"LineEndError    = 1*(%d32-126 / %d9  / LineContinue)\\n\";\n    str += \"Alternation     = Concatenation *(owsp AltOp Concatenation)\\n\";\n    str += \"Concatenation   = Repetition *(CatOp Repetition)\\n\";\n    str += \"Repetition      = [Modifier] (Group / Option / BasicElement / BasicElementErr)\\n\";\n    str += \"Modifier        = (Predicate [RepOp])\\n\";\n    str += \"                / RepOp\\n\";\n    str += \"Predicate       = BkaOp\\n\";\n    str += \"                / BknOp\\n\";\n    str += \"                / AndOp\\n\";\n    str += \"                / NotOp\\n\";\n    str += \"BasicElement    = UdtOp\\n\";\n    str += \"                / RnmOp\\n\";\n    str += \"                / TrgOp\\n\";\n    str += \"                / TbsOp\\n\";\n    str += \"                / TlsOp\\n\";\n    str += \"                / ClsOp\\n\";\n    str += \"                / BkrOp\\n\";\n    str += \"                / AbgOp\\n\";\n    str += \"                / AenOp\\n\";\n    str += \"                / ProsVal\\n\";\n    str += \"BasicElementErr = 1*(%d33-40/%d42-46/%d48-92/%d94-126)\\n\";\n    str += \"Group           = GroupOpen  Alternation (GroupClose / GroupError)\\n\";\n    str += \"GroupError      = 1*(%d33-40/%d42-46/%d48-92/%d94-126) ; same as BasicElementErr\\n\";\n    str += \"GroupOpen       = %d40 owsp\\n\";\n    str += \"GroupClose      = owsp %d41\\n\";\n    str += \"Option          = OptionOpen Alternation (OptionClose / OptionError)\\n\";\n    str += \"OptionError     = 1*(%d33-40/%d42-46/%d48-92/%d94-126) ; same as BasicElementErr\\n\";\n    str += \"OptionOpen      = %d91 owsp\\n\";\n    str += \"OptionClose     = owsp %d93\\n\";\n    str += \"RnmOp           = alphanum\\n\";\n    str += \"BkrOp           = %d92 [bkrModifier] bkr-name\\n\";\n    str += \"bkrModifier     = (cs [um / pm]) / (ci [um / pm]) / (um [cs /ci]) / (pm [cs / ci])\\n\";\n    str += \"cs              = '%s'\\n\";\n    str += \"ci              = '%i'\\n\";\n    str += \"um              = '%u'\\n\";\n    str += \"pm              = '%p'\\n\";\n    str += \"bkr-name        = uname / ename / rname\\n\";\n    str += \"rname           = alphanum\\n\";\n    str += \"uname           = %d117.95 alphanum\\n\";\n    str += \"ename           = %d101.95 alphanum\\n\";\n    str += \"UdtOp           = udt-empty\\n\";\n    str += \"                / udt-non-empty\\n\";\n    str += \"udt-non-empty   = %d117.95 alphanum\\n\";\n    str += \"udt-empty       = %d101.95 alphanum\\n\";\n    str += \"RepOp           = (rep-min StarOp rep-max)\\n\";\n    str += \"                / (rep-min StarOp)\\n\";\n    str += \"                / (StarOp rep-max)\\n\";\n    str += \"                / StarOp\\n\";\n    str += \"                / rep-min-max\\n\";\n    str += \"AltOp           = %d47 owsp\\n\";\n    str += \"CatOp           = wsp\\n\";\n    str += \"StarOp          = %d42\\n\";\n    str += \"AndOp           = %d38\\n\";\n    str += \"NotOp           = %d33\\n\";\n    str += \"BkaOp           = %d38.38\\n\";\n    str += \"BknOp           = %d33.33\\n\";\n    str += \"AbgOp           = %d37.94\\n\";\n    str += \"AenOp           = %d37.36\\n\";\n    str += \"TrgOp           = %d37 ((Dec dmin %d45 dmax) / (Hex xmin %d45 xmax) / (Bin bmin %d45 bmax))\\n\";\n    str += \"TbsOp           = %d37 ((Dec dString *(%d46 dString)) / (Hex xString *(%d46 xString)) / (Bin bString *(%d46 bString)))\\n\";\n    str += \"TlsOp           = TlsCase TlsOpen TlsString TlsClose\\n\";\n    str += \"TlsCase         = [\\\"%i\\\" / \\\"%s\\\"]\\n\";\n    str += \"TlsOpen         = %d34\\n\";\n    str += \"TlsClose        = %d34\\n\";\n    str += \"TlsString       = *(%d32-33/%d35-126/StringTab)\\n\";\n    str += \"StringTab       = %d9\\n\";\n    str += \"ClsOp           = ClsOpen ClsString ClsClose\\n\";\n    str += \"ClsOpen         = %d39\\n\";\n    str += \"ClsClose        = %d39\\n\";\n    str += \"ClsString       = *(%d32-38/%d40-126/StringTab)\\n\";\n    str += \"ProsVal         = ProsValOpen ProsValString ProsValClose\\n\";\n    str += \"ProsValOpen     = %d60\\n\";\n    str += \"ProsValString   = *(%d32-61/%d63-126/StringTab)\\n\";\n    str += \"ProsValClose    = %d62\\n\";\n    str += \"rep-min         = rep-num\\n\";\n    str += \"rep-min-max     = rep-num\\n\";\n    str += \"rep-max         = rep-num\\n\";\n    str += \"rep-num         = 1*(%d48-57)\\n\";\n    str += \"dString         = dnum\\n\";\n    str += \"xString         = xnum\\n\";\n    str += \"bString         = bnum\\n\";\n    str += \"Dec             = (%d68/%d100)\\n\";\n    str += \"Hex             = (%d88/%d120)\\n\";\n    str += \"Bin             = (%d66/%d98)\\n\";\n    str += \"dmin            = dnum\\n\";\n    str += \"dmax            = dnum\\n\";\n    str += \"bmin            = bnum\\n\";\n    str += \"bmax            = bnum\\n\";\n    str += \"xmin            = xnum\\n\";\n    str += \"xmax            = xnum\\n\";\n    str += \"dnum            = 1*(%d48-57)\\n\";\n    str += \"bnum            = 1*%d48-49\\n\";\n    str += \"xnum            = 1*(%d48-57 / %d65-70 / %d97-102)\\n\";\n    str += \";\\n\";\n    str += \"; Basics\\n\";\n    str += \"alphanum        = (%d97-122/%d65-90) *(%d97-122/%d65-90/%d48-57/%d45)\\n\";\n    str += \"owsp            = *space\\n\";\n    str += \"wsp             = 1*space\\n\";\n    str += \"space           = %d32\\n\";\n    str += \"                / %d9\\n\";\n    str += \"                / comment\\n\";\n    str += \"                / LineContinue\\n\";\n    str += \"comment         = %d59 *(%d32-126 / %d9)\\n\";\n    str += \"LineEnd         = %d13.10\\n\";\n    str += \"                / %d10\\n\";\n    str += \"                / %d13\\n\";\n    str += \"LineContinue    = (%d13.10 / %d10 / %d13) (%d32 / %d9)\\n\";\n    return str;\n  }\n}\n"],"names":[],"mappings":"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P,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;QACP,OAAO;IACT;AACF","ignoreList":[0]}},
    {"offset": {"line": 10313, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/apg-js/src/apg-api/parser.js"],"sourcesContent":["/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module converts an input SABNF grammar text file into a\n// grammar object that can be used with `apg-lib` in an application parser.\n// **apg** is, in fact itself, an ABNF parser that generates an SABNF parser.\n// It is based on the grammar<br>\n// `./dist/abnf-for-sabnf-grammar.bnf`.<br>\n// In its syntax phase, **apg** analyzes the user's input SABNF grammar for correct syntax, generating an AST as it goes.\n// In its semantic phase, **apg** translates the AST to generate the parser for the input grammar.\nmodule.exports = function exportParser() {\n  const thisFileName = 'parser: ';\n  const ApgLib = require('../apg-lib/node-exports');\n  const id = ApgLib.ids;\n  const syn = new (require('./syntax-callbacks'))();\n  const sem = new (require('./semantic-callbacks'))();\n  const sabnfGrammar = new (require('./sabnf-grammar'))();\n  // eslint-disable-next-line new-cap\n  const parser = new ApgLib.parser();\n  // eslint-disable-next-line new-cap\n  parser.ast = new ApgLib.ast();\n  parser.callbacks = syn.callbacks;\n  parser.ast.callbacks = sem.callbacks;\n\n  /* find the line containing the given character index */\n  const findLine = function findLine(lines, charIndex, charLength) {\n    if (charIndex < 0 || charIndex >= charLength) {\n      /* return error if out of range */\n      return -1;\n    }\n    for (let i = 0; i < lines.length; i += 1) {\n      if (charIndex >= lines[i].beginChar && charIndex < lines[i].beginChar + lines[i].length) {\n        return i;\n      }\n    }\n    /* should never reach here */\n    return -1;\n  };\n  const translateIndex = function translateIndex(map, index) {\n    let ret = -1;\n    if (index < map.length) {\n      for (let i = index; i < map.length; i += 1) {\n        if (map[i] !== null) {\n          ret = map[i];\n          break;\n        }\n      }\n    }\n    return ret;\n  };\n  /* helper function when removing redundant opcodes */\n  const reduceOpcodes = function reduceOpcodes(rules) {\n    rules.forEach((rule) => {\n      const opcodes = [];\n      const map = [];\n      let reducedIndex = 0;\n      rule.opcodes.forEach((op) => {\n        if (op.type === id.ALT && op.children.length === 1) {\n          map.push(null);\n        } else if (op.type === id.CAT && op.children.length === 1) {\n          map.push(null);\n        } else if (op.type === id.REP && op.min === 1 && op.max === 1) {\n          map.push(null);\n        } else {\n          map.push(reducedIndex);\n          opcodes.push(op);\n          reducedIndex += 1;\n        }\n      });\n      map.push(reducedIndex);\n      /* translate original opcode indexes to the reduced set. */\n      opcodes.forEach((op) => {\n        if (op.type === id.ALT || op.type === id.CAT) {\n          for (let i = 0; i < op.children.length; i += 1) {\n            op.children[i] = translateIndex(map, op.children[i]);\n          }\n        }\n      });\n      rule.opcodes = opcodes;\n    });\n  };\n  /* Parse the grammar - the syntax phase. */\n  /* SABNF grammar syntax errors are caught and reported here. */\n  this.syntax = function syntax(chars, lines, errors, strict, lite, trace) {\n    if (trace) {\n      if (trace.traceObject !== 'traceObject') {\n        throw new TypeError(`${thisFileName}trace argument is not a trace object`);\n      }\n      parser.trace = trace;\n    }\n    const data = {};\n    data.errors = errors;\n    data.strict = !!strict;\n    data.lite = !!lite;\n    data.lines = lines;\n    data.findLine = findLine;\n    data.charsLength = chars.length;\n    data.ruleCount = 0;\n    const result = parser.parse(sabnfGrammar, 'file', chars, data);\n    if (!result.success) {\n      errors.push({\n        line: 0,\n        char: 0,\n        msg: 'syntax analysis of input grammar failed',\n      });\n    }\n  };\n  /* Parse the grammar - the semantic phase, translates the AST. */\n  /* SABNF grammar syntax errors are caught and reported here. */\n  this.semantic = function semantic(chars, lines, errors) {\n    const data = {};\n    data.errors = errors;\n    data.lines = lines;\n    data.findLine = findLine;\n    data.charsLength = chars.length;\n    parser.ast.translate(data);\n    if (errors.length) {\n      return null;\n    }\n    /* Remove unneeded operators. */\n    /* ALT operators with a single alternate */\n    /* CAT operators with a single phrase to concatenate */\n    /* REP(1,1) operators (`1*1RuleName` or `1RuleName` is the same as just `RuleName`.) */\n    reduceOpcodes(data.rules);\n    return {\n      rules: data.rules,\n      udts: data.udts,\n      lineMap: data.rulesLineMap,\n    };\n  };\n  // Generate a grammar constructor function.\n  // An object instantiated from this constructor is used with the `apg-lib` `parser()` function.\n  this.generateSource = function generateSource(chars, lines, rules, udts, config) {\n    let source = '';\n    let typescript = false;\n    let lite = false;\n    // config may have multiple grammar object type options in which case\n    // --typescript > --lite  > no options\n    if (config) {\n      if (config.typescript) {\n        typescript = true;\n        lite = false;\n      } else if (config.lite) {\n        typescript = false;\n        lite = true;\n      }\n    }\n    let i;\n    let bkrname;\n    let bkrlower;\n    let opcodeCount = 0;\n    let charCodeMin = Infinity;\n    let charCodeMax = 0;\n    const ruleNames = [];\n    const udtNames = [];\n    let alt = 0;\n    let cat = 0;\n    let rnm = 0;\n    let udt = 0;\n    let rep = 0;\n    let and = 0;\n    let not = 0;\n    let tls = 0;\n    let tbs = 0;\n    let trg = 0;\n    let bkr = 0;\n    let bka = 0;\n    let bkn = 0;\n    let abg = 0;\n    let aen = 0;\n    rules.forEach((rule) => {\n      ruleNames.push(rule.lower);\n      opcodeCount += rule.opcodes.length;\n      rule.opcodes.forEach((op) => {\n        switch (op.type) {\n          case id.ALT:\n            alt += 1;\n            break;\n          case id.CAT:\n            cat += 1;\n            break;\n          case id.RNM:\n            rnm += 1;\n            break;\n          case id.UDT:\n            udt += 1;\n            break;\n          case id.REP:\n            rep += 1;\n            break;\n          case id.AND:\n            and += 1;\n            break;\n          case id.NOT:\n            not += 1;\n            break;\n          case id.BKA:\n            bka += 1;\n            break;\n          case id.BKN:\n            bkn += 1;\n            break;\n          case id.BKR:\n            bkr += 1;\n            break;\n          case id.ABG:\n            abg += 1;\n            break;\n          case id.AEN:\n            aen += 1;\n            break;\n          case id.TLS:\n            tls += 1;\n            for (i = 0; i < op.string.length; i += 1) {\n              if (op.string[i] < charCodeMin) {\n                charCodeMin = op.string[i];\n              }\n              if (op.string[i] > charCodeMax) {\n                charCodeMax = op.string[i];\n              }\n            }\n            break;\n          case id.TBS:\n            tbs += 1;\n            for (i = 0; i < op.string.length; i += 1) {\n              if (op.string[i] < charCodeMin) {\n                charCodeMin = op.string[i];\n              }\n              if (op.string[i] > charCodeMax) {\n                charCodeMax = op.string[i];\n              }\n            }\n            break;\n          case id.TRG:\n            trg += 1;\n            if (op.min < charCodeMin) {\n              charCodeMin = op.min;\n            }\n            if (op.max > charCodeMax) {\n              charCodeMax = op.max;\n            }\n            break;\n          default:\n            throw new Error('generateSource: unrecognized opcode');\n        }\n      });\n    });\n    ruleNames.sort();\n    if (udts.length > 0) {\n      udts.forEach((udtFunc) => {\n        udtNames.push(udtFunc.lower);\n      });\n      udtNames.sort();\n    }\n    source += '// copyright: Copyright (c) 2024 Lowell D. Thomas, all rights reserved<br>\\n';\n    source += '//   license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)<br>\\n';\n    source += '//\\n';\n    source += '// Generated by apg-js, Version 4.4.0 [apg-js](https://github.com/ldthomas/apg-js)\\n';\n    if (config) {\n      if (config.funcName) {\n        source += `const ${config.funcName} = function grammar(){\\n`;\n      } else if (typescript) {\n        source += 'export function grammar(){\\n';\n      } else if (lite) {\n        source += 'export default function grammar(){\\n';\n      } else {\n        source += `module.exports = function grammar(){\\n`;\n      }\n    } else {\n      source += `module.exports = function grammar(){\\n`;\n    }\n    source += '  // ```\\n';\n    source += '  // SUMMARY\\n';\n    source += `  //      rules = ${rules.length}\\n`;\n    source += `  //       udts = ${udts.length}\\n`;\n    source += `  //    opcodes = ${opcodeCount}\\n`;\n    source += '  //        ---   ABNF original opcodes\\n';\n    source += `  //        ALT = ${alt}\\n`;\n    source += `  //        CAT = ${cat}\\n`;\n    source += `  //        REP = ${rep}\\n`;\n    source += `  //        RNM = ${rnm}\\n`;\n    source += `  //        TLS = ${tls}\\n`;\n    source += `  //        TBS = ${tbs}\\n`;\n    source += `  //        TRG = ${trg}\\n`;\n    source += '  //        ---   SABNF superset opcodes\\n';\n    source += `  //        UDT = ${udt}\\n`;\n    source += `  //        AND = ${and}\\n`;\n    source += `  //        NOT = ${not}\\n`;\n    if (!lite) {\n      source += `  //        BKA = ${bka}\\n`;\n      source += `  //        BKN = ${bkn}\\n`;\n      source += `  //        BKR = ${bkr}\\n`;\n      source += `  //        ABG = ${abg}\\n`;\n      source += `  //        AEN = ${aen}\\n`;\n    }\n    source += '  // characters = [';\n    if (tls + tbs + trg === 0) {\n      source += ' none defined ]';\n    } else {\n      source += `${charCodeMin} - ${charCodeMax}]`;\n    }\n    if (udt > 0) {\n      source += ' + user defined';\n    }\n    source += '\\n';\n    source += '  // ```\\n';\n    source += '  /* OBJECT IDENTIFIER (for internal parser use) */\\n';\n    source += \"  this.grammarObject = 'grammarObject';\\n\";\n    source += '\\n';\n    source += '  /* RULES */\\n';\n    source += '  this.rules = [];\\n';\n    rules.forEach((rule, ii) => {\n      let thisRule = '  this.rules[';\n      thisRule += ii;\n      thisRule += \"] = { name: '\";\n      thisRule += rule.name;\n      thisRule += \"', lower: '\";\n      thisRule += rule.lower;\n      thisRule += \"', index: \";\n      thisRule += rule.index;\n      thisRule += ', isBkr: ';\n      thisRule += rule.isBkr;\n      thisRule += ' };\\n';\n      source += thisRule;\n    });\n    source += '\\n';\n    source += '  /* UDTS */\\n';\n    source += '  this.udts = [];\\n';\n    if (udts.length > 0) {\n      udts.forEach((udtFunc, ii) => {\n        let thisUdt = '  this.udts[';\n        thisUdt += ii;\n        thisUdt += \"] = { name: '\";\n        thisUdt += udtFunc.name;\n        thisUdt += \"', lower: '\";\n        thisUdt += udtFunc.lower;\n        thisUdt += \"', index: \";\n        thisUdt += udtFunc.index;\n        thisUdt += ', empty: ';\n        thisUdt += udtFunc.empty;\n        thisUdt += ', isBkr: ';\n        thisUdt += udtFunc.isBkr;\n        thisUdt += ' };\\n';\n        source += thisUdt;\n      });\n    }\n    source += '\\n';\n    source += '  /* OPCODES */\\n';\n    rules.forEach((rule, ruleIndex) => {\n      if (ruleIndex > 0) {\n        source += '\\n';\n      }\n      source += `  /* ${rule.name} */\\n`;\n      source += `  this.rules[${ruleIndex}].opcodes = [];\\n`;\n      rule.opcodes.forEach((op, opIndex) => {\n        let prefix;\n        switch (op.type) {\n          case id.ALT:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${\n              op.type\n            }, children: [${op.children.toString()}] };// ALT\\n`;\n            break;\n          case id.CAT:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${\n              op.type\n            }, children: [${op.children.toString()}] };// CAT\\n`;\n            break;\n          case id.RNM:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${op.type}, index: ${\n              op.index\n            } };// RNM(${rules[op.index].name})\\n`;\n            break;\n          case id.BKR:\n            if (op.index >= rules.length) {\n              bkrname = udts[op.index - rules.length].name;\n              bkrlower = udts[op.index - rules.length].lower;\n            } else {\n              bkrname = rules[op.index].name;\n              bkrlower = rules[op.index].lower;\n            }\n            prefix = '%i';\n            if (op.bkrCase === id.BKR_MODE_CS) {\n              prefix = '%s';\n            }\n            if (op.bkrMode === id.BKR_MODE_UM) {\n              prefix += '%u';\n            } else {\n              prefix += '%p';\n            }\n            bkrname = prefix + bkrname;\n            source +=\n              `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${op.type}, index: ${op.index}, lower: '${bkrlower}'` +\n              `, bkrCase: ${op.bkrCase}, bkrMode: ${op.bkrMode} };// BKR(\\\\${bkrname})\\n`;\n            break;\n          case id.UDT:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${op.type}, empty: ${\n              op.empty\n            }, index: ${op.index} };// UDT(${udts[op.index].name})\\n`;\n            break;\n          case id.REP:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${op.type}, min: ${op.min}, max: ${op.max} };// REP\\n`;\n            break;\n          case id.AND:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${op.type} };// AND\\n`;\n            break;\n          case id.NOT:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${op.type} };// NOT\\n`;\n            break;\n          case id.ABG:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${op.type} };// ABG(%^)\\n`;\n            break;\n          case id.AEN:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${op.type} };// AEN(%$)\\n`;\n            break;\n          case id.BKA:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${op.type} };// BKA\\n`;\n            break;\n          case id.BKN:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${op.type} };// BKN\\n`;\n            break;\n          case id.TLS:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${\n              op.type\n            }, string: [${op.string.toString()}] };// TLS\\n`;\n            break;\n          case id.TBS:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${\n              op.type\n            }, string: [${op.string.toString()}] };// TBS\\n`;\n            break;\n          case id.TRG:\n            source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${op.type}, min: ${op.min}, max: ${op.max} };// TRG\\n`;\n            break;\n          default:\n            throw new Error('parser.js: ~143: unrecognized opcode');\n        }\n      });\n    });\n    source += '\\n';\n    source += '  // The `toString()` function will display the original grammar file(s) that produced these opcodes.\\n';\n    source += '  this.toString = function toString(){\\n';\n    source += '    let str = \"\";\\n';\n    let str;\n    lines.forEach((line) => {\n      const end = line.beginChar + line.length;\n      str = '';\n      source += '    str += \"';\n      for (let ii = line.beginChar; ii < end; ii += 1) {\n        switch (chars[ii]) {\n          case 9:\n            str = ' ';\n            break;\n          case 10:\n            str = '\\\\n';\n            break;\n          case 13:\n            str = '\\\\r';\n            break;\n          case 34:\n            str = '\\\\\"';\n            break;\n          case 92:\n            str = '\\\\\\\\';\n            break;\n          default:\n            str = String.fromCharCode(chars[ii]);\n            break;\n        }\n        source += str;\n      }\n      source += '\";\\n';\n    });\n    source += '    return str;\\n';\n    source += '  }\\n';\n    source += '}\\n';\n    return source;\n  };\n  // Generate a grammar file object.\n  // Returns the same object as instantiating the constructor function returned by<br>\n  // `this.generateSource()`.<br>\n  this.generateObject = function generateObject(stringArg, rules, udts) {\n    const obj = {};\n    const ruleNames = [];\n    const udtNames = [];\n    const string = stringArg.slice(0);\n    obj.grammarObject = 'grammarObject';\n    rules.forEach((rule) => {\n      ruleNames.push(rule.lower);\n    });\n    ruleNames.sort();\n    if (udts.length > 0) {\n      udts.forEach((udtFunc) => {\n        udtNames.push(udtFunc.lower);\n      });\n      udtNames.sort();\n    }\n    obj.callbacks = [];\n    ruleNames.forEach((name) => {\n      obj.callbacks[name] = false;\n    });\n    if (udts.length > 0) {\n      udtNames.forEach((name) => {\n        obj.callbacks[name] = false;\n      });\n    }\n    obj.rules = rules;\n    obj.udts = udts;\n    obj.toString = function toStringFunc() {\n      return string;\n    };\n    return obj;\n  };\n};\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 10801, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/apg-js/src/apg-api/rule-attributes.js"],"sourcesContent":["/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module does the heavy lifting for attribute generation.\nmodule.exports = (function exportRuleAttributes() {\n  const id = require('../apg-lib/identifiers');\n  const thisFile = 'rule-attributes.js';\n  let state = null;\n  function isEmptyOnly(attr) {\n    if (attr.left || attr.nested || attr.right || attr.cyclic) {\n      return false;\n    }\n    return attr.empty;\n  }\n  function isRecursive(attr) {\n    if (attr.left || attr.nested || attr.right || attr.cyclic) {\n      return true;\n    }\n    return false;\n  }\n  function isCatNested(attrs, count) {\n    let i = 0;\n    let j = 0;\n    let k = 0;\n    /* 1. if any child is nested, CAT is nested */\n    for (i = 0; i < count; i += 1) {\n      if (attrs[i].nested) {\n        return true;\n      }\n    }\n    /* 2.) the left-most right recursive child\n               is followed by at least one non-empty child */\n    for (i = 0; i < count; i += 1) {\n      if (attrs[i].right && !attrs[i].leaf) {\n        for (j = i + 1; j < count; j += 1) {\n          if (!isEmptyOnly(attrs[j])) {\n            return true;\n          }\n        }\n      }\n    }\n    /* 3.) the right-most left recursive child\n               is preceded by at least one non-empty child */\n    for (i = count - 1; i >= 0; i -= 1) {\n      if (attrs[i].left && !attrs[i].leaf) {\n        for (j = i - 1; j >= 0; j -= 1) {\n          if (!isEmptyOnly(attrs[j])) {\n            return true;\n          }\n        }\n      }\n    }\n    /* 4. there is at lease one recursive child between\n              the left-most and right-most non-recursive, non-empty children */\n    for (i = 0; i < count; i += 1) {\n      if (!attrs[i].empty && !isRecursive(attrs[i])) {\n        for (j = i + 1; j < count; j += 1) {\n          if (isRecursive(attrs[j])) {\n            for (k = j + 1; k < count; k += 1) {\n              if (!attrs[k].empty && !isRecursive(attrs[k])) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    /* none of the above */\n    return false;\n  }\n  function isCatCyclic(attrs, count) {\n    /* if all children are cyclic, CAT is cyclic */\n    for (let i = 0; i < count; i += 1) {\n      if (!attrs[i].cyclic) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function isCatLeft(attrs, count) {\n    /* if the left-most non-empty is left, CAT is left */\n    for (let i = 0; i < count; i += 1) {\n      if (attrs[i].left) {\n        return true;\n      }\n      if (!attrs[i].empty) {\n        return false;\n      }\n      /* keep looking */\n    }\n    return false; /* all left-most are empty */\n  }\n  function isCatRight(attrs, count) {\n    /* if the right-most non-empty is right, CAT is right */\n    for (let i = count - 1; i >= 0; i -= 1) {\n      if (attrs[i].right) {\n        return true;\n      }\n      if (!attrs[i].empty) {\n        return false;\n      }\n      /* keep looking */\n    }\n    return false;\n  }\n  function isCatEmpty(attrs, count) {\n    /* if all children are empty, CAT is empty */\n    for (let i = 0; i < count; i += 1) {\n      if (!attrs[i].empty) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function isCatFinite(attrs, count) {\n    /* if all children are finite, CAT is finite */\n    for (let i = 0; i < count; i += 1) {\n      if (!attrs[i].finite) {\n        return false;\n      }\n    }\n    return true;\n  }\n  function cat(stateArg, opcodes, opIndex, iAttr) {\n    let i = 0;\n    const opCat = opcodes[opIndex];\n    const count = opCat.children.length;\n\n    /* generate an empty array of child attributes */\n    const childAttrs = [];\n    for (i = 0; i < count; i += 1) {\n      childAttrs.push(stateArg.attrGen());\n    }\n    for (i = 0; i < count; i += 1) {\n      // eslint-disable-next-line no-use-before-define\n      opEval(stateArg, opcodes, opCat.children[i], childAttrs[i]);\n    }\n    iAttr.left = isCatLeft(childAttrs, count);\n    iAttr.right = isCatRight(childAttrs, count);\n    iAttr.nested = isCatNested(childAttrs, count);\n    iAttr.empty = isCatEmpty(childAttrs, count);\n    iAttr.finite = isCatFinite(childAttrs, count);\n    iAttr.cyclic = isCatCyclic(childAttrs, count);\n  }\n  function alt(stateArg, opcodes, opIndex, iAttr) {\n    let i = 0;\n    const opAlt = opcodes[opIndex];\n    const count = opAlt.children.length;\n\n    /* generate an empty array of child attributes */\n    const childAttrs = [];\n    for (i = 0; i < count; i += 1) {\n      childAttrs.push(stateArg.attrGen());\n    }\n    for (i = 0; i < count; i += 1) {\n      // eslint-disable-next-line no-use-before-define\n      opEval(stateArg, opcodes, opAlt.children[i], childAttrs[i]);\n    }\n\n    /* if any child attribute is true, ALT is true */\n    iAttr.left = false;\n    iAttr.right = false;\n    iAttr.nested = false;\n    iAttr.empty = false;\n    iAttr.finite = false;\n    iAttr.cyclic = false;\n    for (i = 0; i < count; i += 1) {\n      if (childAttrs[i].left) {\n        iAttr.left = true;\n      }\n      if (childAttrs[i].nested) {\n        iAttr.nested = true;\n      }\n      if (childAttrs[i].right) {\n        iAttr.right = true;\n      }\n      if (childAttrs[i].empty) {\n        iAttr.empty = true;\n      }\n      if (childAttrs[i].finite) {\n        iAttr.finite = true;\n      }\n      if (childAttrs[i].cyclic) {\n        iAttr.cyclic = true;\n      }\n    }\n  }\n  function bkr(stateArg, opcodes, opIndex, iAttr) {\n    const opBkr = opcodes[opIndex];\n    if (opBkr.index >= stateArg.ruleCount) {\n      /* use UDT values */\n      iAttr.empty = stateArg.udts[opBkr.index - stateArg.ruleCount].empty;\n      iAttr.finite = true;\n    } else {\n      /* use the empty and finite values from the back referenced rule */\n      // eslint-disable-next-line no-use-before-define\n      ruleAttrsEval(stateArg, opBkr.index, iAttr);\n\n      /* however, this is a terminal node like TLS */\n      iAttr.left = false;\n      iAttr.nested = false;\n      iAttr.right = false;\n      iAttr.cyclic = false;\n    }\n  }\n\n  function opEval(stateArg, opcodes, opIndex, iAttr) {\n    stateArg.attrInit(iAttr);\n    const opi = opcodes[opIndex];\n    switch (opi.type) {\n      case id.ALT:\n        alt(stateArg, opcodes, opIndex, iAttr);\n        break;\n      case id.CAT:\n        cat(stateArg, opcodes, opIndex, iAttr);\n        break;\n      case id.REP:\n        opEval(stateArg, opcodes, opIndex + 1, iAttr);\n        if (opi.min === 0) {\n          iAttr.empty = true;\n          iAttr.finite = true;\n        }\n        break;\n      case id.RNM:\n        // eslint-disable-next-line no-use-before-define\n        ruleAttrsEval(stateArg, opcodes[opIndex].index, iAttr);\n        break;\n      case id.BKR:\n        bkr(stateArg, opcodes, opIndex, iAttr);\n        break;\n      case id.AND:\n      case id.NOT:\n      case id.BKA:\n      case id.BKN:\n        opEval(stateArg, opcodes, opIndex + 1, iAttr);\n        iAttr.empty = true;\n        break;\n      case id.TLS:\n        iAttr.empty = !opcodes[opIndex].string.length;\n        iAttr.finite = true;\n        iAttr.cyclic = false;\n        break;\n      case id.TBS:\n      case id.TRG:\n        iAttr.empty = false;\n        iAttr.finite = true;\n        iAttr.cyclic = false;\n        break;\n      case id.UDT:\n        iAttr.empty = opi.empty;\n        iAttr.finite = true;\n        iAttr.cyclic = false;\n        break;\n      case id.ABG:\n      case id.AEN:\n        iAttr.empty = true;\n        iAttr.finite = true;\n        iAttr.cyclic = false;\n        break;\n      default:\n        throw new Error(`unknown opcode type: ${opi}`);\n    }\n  }\n  // The main logic for handling rules that:\n  //  - have already be evaluated\n  //  - have not been evaluated and is the first occurrence on this branch\n  //  - second occurrence on this branch for the start rule\n  //  - second occurrence on this branch for non-start rules\n  function ruleAttrsEval(stateArg, ruleIndex, iAttr) {\n    const attri = stateArg.attrsWorking[ruleIndex];\n    if (attri.isComplete) {\n      /* just use the completed values */\n      stateArg.attrCopy(iAttr, attri);\n    } else if (!attri.isOpen) {\n      /* open the rule and traverse it */\n      attri.isOpen = true;\n      opEval(stateArg, attri.rule.opcodes, 0, iAttr);\n      /* complete this rule's attributes */\n      attri.left = iAttr.left;\n      attri.right = iAttr.right;\n      attri.nested = iAttr.nested;\n      attri.empty = iAttr.empty;\n      attri.finite = iAttr.finite;\n      attri.cyclic = iAttr.cyclic;\n      attri.leaf = false;\n      attri.isOpen = false;\n      attri.isComplete = true;\n    } else if (ruleIndex === stateArg.startRule) {\n      /* use recursive leaf values */\n      if (ruleIndex === stateArg.startRule) {\n        iAttr.left = true;\n        iAttr.right = true;\n        iAttr.cyclic = true;\n        iAttr.leaf = true;\n      }\n    } else {\n      /* non-start rule terminal leaf */\n      iAttr.finite = true;\n    }\n  }\n  // The main driver for the attribute generation.\n  const ruleAttributes = (stateArg) => {\n    state = stateArg;\n    let i = 0;\n    let j = 0;\n    const iAttr = state.attrGen();\n    for (i = 0; i < state.ruleCount; i += 1) {\n      /* initialize working attributes */\n      for (j = 0; j < state.ruleCount; j += 1) {\n        state.attrInit(state.attrsWorking[j]);\n      }\n      state.startRule = i;\n      ruleAttrsEval(state, i, iAttr);\n\n      /* save off the working attributes for this rule */\n      state.attrCopy(state.attrs[i], state.attrsWorking[i]);\n    }\n    state.attributesComplete = true;\n    let attri = null;\n    for (i = 0; i < state.ruleCount; i += 1) {\n      attri = state.attrs[i];\n      if (attri.left || !attri.finite || attri.cyclic) {\n        const temp = state.attrGen(attri.rule);\n        state.attrCopy(temp, attri);\n        state.attrsErrors.push(temp);\n        state.attrsErrorCount += 1;\n      }\n    }\n  };\n  const truth = (val) => (val ? 't' : 'f');\n  const tError = (val) => (val ? 'e' : 'f');\n  const fError = (val) => (val ? 't' : 'e');\n  const showAttr = (seq, index, attr, dep) => {\n    let str = `${seq}:${index}:`;\n    str += `${tError(attr.left)} `;\n    str += `${truth(attr.nested)} `;\n    str += `${truth(attr.right)} `;\n    str += `${tError(attr.cyclic)} `;\n    str += `${fError(attr.finite)} `;\n    str += `${truth(attr.empty)}:`;\n    str += `${state.typeToString(dep.recursiveType)}:`;\n    str += dep.recursiveType === id.ATTR_MR ? dep.groupNumber : '-';\n    str += `:${attr.rule.name}\\n`;\n    return str;\n  };\n\n  const showLegend = () => {\n    let str = 'LEGEND - t=true, f=false, e=error\\n';\n    str += 'sequence:rule index:left nested right cyclic finite empty:type:group number:rule name\\n';\n    return str;\n  };\n  const showAttributeErrors = () => {\n    let attri = null;\n    let depi = null;\n    let str = '';\n    str += 'RULE ATTRIBUTES WITH ERRORS\\n';\n    str += showLegend();\n    if (state.attrsErrorCount) {\n      for (let i = 0; i < state.attrsErrorCount; i += 1) {\n        attri = state.attrsErrors[i];\n        depi = state.ruleDeps[attri.rule.index];\n        str += showAttr(i, attri.rule.index, attri, depi);\n      }\n    } else {\n      str += '<none>\\n';\n    }\n    return str;\n  };\n\n  const show = (type) => {\n    let i = 0;\n    let ii = 0;\n    let attri = null;\n    let depi = null;\n    let str = '';\n    let { ruleIndexes } = state;\n    // let udtIndexes = state.udtIndexes;\n    if (type === 97) {\n      ruleIndexes = state.ruleAlphaIndexes;\n      // udtIndexes = state.udtAlphaIndexes;\n    } else if (type === 116) {\n      ruleIndexes = state.ruleTypeIndexes;\n      // udtIndexes = state.udtAlphaIndexes;\n    }\n    /* show all attributes */\n    for (i = 0; i < state.ruleCount; i += 1) {\n      ii = ruleIndexes[i];\n      attri = state.attrs[ii];\n      depi = state.ruleDeps[ii];\n      str += showAttr(i, ii, attri, depi);\n    }\n    return str;\n  };\n\n  // Display the rule attributes.\n  // - order\n  //      - \"index\" or \"i\", index order (default)\n  //      - \"alpha\" or \"a\", alphabetical order\n  //      - \"type\" or \"t\", ordered by type (alphabetical within each type/group)\n  //      - none of above, index order (default)\n  const showAttributes = (order = 'index') => {\n    if (!state.attributesComplete) {\n      throw new Error(`${thisFile}:showAttributes: attributes not available`);\n    }\n    let str = '';\n    const leader = 'RULE ATTRIBUTES\\n';\n    if (order.charCodeAt(0) === 97) {\n      str += 'alphabetical by rule name\\n';\n      str += leader;\n      str += showLegend();\n      str += show(97);\n    } else if (order.charCodeAt(0) === 116) {\n      str += 'ordered by rule type\\n';\n      str += leader;\n      str += showLegend();\n      str += show(116);\n    } else {\n      str += 'ordered by rule index\\n';\n      str += leader;\n      str += showLegend();\n      str += show();\n    }\n    return str;\n  };\n\n  /* Destructuring assignment - see MDN Web Docs */\n  return { ruleAttributes, showAttributes, showAttributeErrors };\n})();\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 11199, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/apg-js/src/apg-api/rule-dependencies.js"],"sourcesContent":["/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// Determine rule dependencies and types.\n// For each rule, determine which other rules it refers to\n// and which of the other rules refer back to it.\n//\n// Rule types are:\n//  - non-recursive - the rule never refers to itself, even indirectly\n//  - recursive - the rule refers to itself, possibly indirectly\n//  - mutually-recursive - belongs to a group of two or more rules, each of which refers to every other rule in the group, including itself.\nmodule.exports = (() => {\n  const id = require('../apg-lib/identifiers');\n  let state = null; /* keep a global reference to the state for the show functions */\n\n  /* scan the opcodes of the indexed rule and discover which rules it references and which rule refer back to it */\n  const scan = (ruleCount, ruleDeps, index, isScanned) => {\n    let i = 0;\n    let j = 0;\n    const rdi = ruleDeps[index];\n    isScanned[index] = true;\n    const op = rdi.rule.opcodes;\n    for (i = 0; i < op.length; i += 1) {\n      const opi = op[i];\n      if (opi.type === id.RNM) {\n        rdi.refersTo[opi.index] = true;\n        if (!isScanned[opi.index]) {\n          scan(ruleCount, ruleDeps, opi.index, isScanned);\n        }\n        for (j = 0; j < ruleCount; j += 1) {\n          if (ruleDeps[opi.index].refersTo[j]) {\n            rdi.refersTo[j] = true;\n          }\n        }\n      } else if (opi.type === id.UDT) {\n        rdi.refersToUdt[opi.index] = true;\n      } else if (opi.type === id.BKR) {\n        if (opi.index < ruleCount) {\n          rdi.refersTo[opi.index] = true;\n          if (!isScanned[opi.index]) {\n            scan(ruleCount, ruleDeps, opi.index, isScanned);\n          }\n        } else {\n          rdi.refersToUdt[ruleCount - opi.index] = true;\n        }\n      }\n    }\n  };\n  // Determine the rule dependencies, types and mutually recursive groups.\n  const ruleDependencies = (stateArg) => {\n    state = stateArg; /* make it global */\n    let i = 0;\n    let j = 0;\n    let groupCount = 0;\n    let rdi = null;\n    let rdj = null;\n    let newGroup = false;\n    state.dependenciesComplete = false;\n\n    /* make a working array of rule scanned markers */\n    const isScanned = state.falseArray(state.ruleCount);\n\n    /* discover the rule dependencies */\n    for (i = 0; i < state.ruleCount; i += 1) {\n      state.falsifyArray(isScanned);\n      scan(state.ruleCount, state.ruleDeps, i, isScanned);\n    }\n    /* discover all rules referencing each rule */\n    for (i = 0; i < state.ruleCount; i += 1) {\n      for (j = 0; j < state.ruleCount; j += 1) {\n        if (i !== j) {\n          if (state.ruleDeps[j].refersTo[i]) {\n            state.ruleDeps[i].referencedBy[j] = true;\n          }\n        }\n      }\n    }\n    /* find the non-recursive and recursive types */\n    for (i = 0; i < state.ruleCount; i += 1) {\n      state.ruleDeps[i].recursiveType = id.ATTR_N;\n      if (state.ruleDeps[i].refersTo[i]) {\n        state.ruleDeps[i].recursiveType = id.ATTR_R;\n      }\n    }\n\n    /* find the mutually-recursive groups, if any */\n    groupCount = -1;\n    for (i = 0; i < state.ruleCount; i += 1) {\n      rdi = state.ruleDeps[i];\n      if (rdi.recursiveType === id.ATTR_R) {\n        newGroup = true;\n        for (j = 0; j < state.ruleCount; j += 1) {\n          if (i !== j) {\n            rdj = state.ruleDeps[j];\n            if (rdj.recursiveType === id.ATTR_R) {\n              if (rdi.refersTo[j] && rdj.refersTo[i]) {\n                if (newGroup) {\n                  groupCount += 1;\n                  rdi.recursiveType = id.ATTR_MR;\n                  rdi.groupNumber = groupCount;\n                  newGroup = false;\n                }\n                rdj.recursiveType = id.ATTR_MR;\n                rdj.groupNumber = groupCount;\n              }\n            }\n          }\n        }\n      }\n    }\n    state.isMutuallyRecursive = groupCount > -1;\n\n    /* sort the rules/UDTS */\n    state.ruleAlphaIndexes.sort(state.compRulesAlpha);\n    state.ruleTypeIndexes.sort(state.compRulesAlpha);\n    state.ruleTypeIndexes.sort(state.compRulesType);\n    if (state.isMutuallyRecursive) {\n      state.ruleTypeIndexes.sort(state.compRulesGroup);\n    }\n    if (state.udtCount) {\n      state.udtAlphaIndexes.sort(state.compUdtsAlpha);\n    }\n\n    state.dependenciesComplete = true;\n  };\n  const show = (type = null) => {\n    let i = 0;\n    let j = 0;\n    let count = 0;\n    let startSeg = 0;\n    const maxRule = state.ruleCount - 1;\n    const maxUdt = state.udtCount - 1;\n    const lineLength = 100;\n    let str = '';\n    let pre = '';\n    const toArrow = '=> ';\n    const byArrow = '<= ';\n    let first = false;\n    let rdi = null;\n    let { ruleIndexes } = state;\n    let { udtIndexes } = state;\n    if (type === 97) {\n      ruleIndexes = state.ruleAlphaIndexes;\n      udtIndexes = state.udtAlphaIndexes;\n    } else if (type === 116) {\n      ruleIndexes = state.ruleTypeIndexes;\n      udtIndexes = state.udtAlphaIndexes;\n    }\n    for (i = 0; i < state.ruleCount; i += 1) {\n      rdi = state.ruleDeps[ruleIndexes[i]];\n      pre = `${ruleIndexes[i]}:${state.typeToString(rdi.recursiveType)}:`;\n      if (state.isMutuallyRecursive) {\n        pre += rdi.groupNumber > -1 ? rdi.groupNumber : '-';\n        pre += ':';\n      }\n      pre += ' ';\n      str += `${pre + state.rules[ruleIndexes[i]].name}\\n`;\n      first = true;\n      count = 0;\n      startSeg = str.length;\n      str += pre;\n      for (j = 0; j < state.ruleCount; j += 1) {\n        if (rdi.refersTo[ruleIndexes[j]]) {\n          if (first) {\n            str += toArrow;\n            first = false;\n            str += state.ruleDeps[ruleIndexes[j]].rule.name;\n          } else {\n            str += `, ${state.ruleDeps[ruleIndexes[j]].rule.name}`;\n          }\n          count += 1;\n        }\n        if (str.length - startSeg > lineLength && j !== maxRule) {\n          str += `\\n${pre}${toArrow}`;\n          startSeg = str.length;\n        }\n      }\n      if (state.udtCount) {\n        for (j = 0; j < state.udtCount; j += 1) {\n          if (rdi.refersToUdt[udtIndexes[j]]) {\n            if (first) {\n              str += toArrow;\n              first = false;\n              str += state.udts[udtIndexes[j]].name;\n            } else {\n              str += `, ${state.udts[udtIndexes[j]].name}`;\n            }\n            count += 1;\n          }\n          if (str.length - startSeg > lineLength && j !== maxUdt) {\n            str += `\\n${pre}${toArrow}`;\n            startSeg = str.length;\n          }\n        }\n      }\n      if (count === 0) {\n        str += '=> <none>\\n';\n      }\n      if (first === false) {\n        str += '\\n';\n      }\n      first = true;\n      count = 0;\n      startSeg = str.length;\n      str += pre;\n      for (j = 0; j < state.ruleCount; j += 1) {\n        if (rdi.referencedBy[ruleIndexes[j]]) {\n          if (first) {\n            str += byArrow;\n            first = false;\n            str += state.ruleDeps[ruleIndexes[j]].rule.name;\n          } else {\n            str += `, ${state.ruleDeps[ruleIndexes[j]].rule.name}`;\n          }\n          count += 1;\n        }\n        if (str.length - startSeg > lineLength && j !== maxRule) {\n          str += `\\n${pre}${toArrow}`;\n          startSeg = str.length;\n        }\n      }\n      if (count === 0) {\n        str += '<= <none>\\n';\n      }\n      if (first === false) {\n        str += '\\n';\n      }\n      str += '\\n';\n    }\n    return str;\n  };\n  // Display the rule dependencies.\n  // - order\n  //      - \"index\" or \"i\", index order (default)\n  //      - \"alpha\" or \"a\", alphabetical order\n  //      - \"type\" or \"t\", ordered by type (alphabetical within each type/group)\n  //      - none of above, index order (default)\n  const showRuleDependencies = (order = 'index') => {\n    let str = 'RULE DEPENDENCIES(index:type:[group number:])\\n';\n    str += '=> refers to rule names\\n';\n    str += '<= referenced by rule names\\n';\n    if (!state.dependenciesComplete) {\n      return str;\n    }\n\n    if (order.charCodeAt(0) === 97) {\n      str += 'alphabetical by rule name\\n';\n      str += show(97);\n    } else if (order.charCodeAt(0) === 116) {\n      str += 'ordered by rule type\\n';\n      str += show(116);\n    } else {\n      str += 'ordered by rule index\\n';\n      str += show(null);\n    }\n    return str;\n  };\n\n  /* Destructuring assignment - see MDN Web Docs */\n  return { ruleDependencies, showRuleDependencies };\n})();\n"],"names":[],"mappings":"AAAA;;;uFAGuF,GACvF,yCAAyC;AACzC,0DAA0D;AAC1D,iDAAiD;AACjD,EAAE;AACF,kBAAkB;AAClB,sEAAsE;AACtE,gEAAgE;AAChE,4IAA4I;AAC5I,OAAO,OAAO,GAAG,CAAC;IAChB,MAAM;IACN,IAAI,QAAQ,MAAM,+DAA+D;IAEjF,+GAA+G,GAC/G,MAAM,OAAO,CAAC,WAAW,UAAU,OAAO;QACxC,IAAI,IAAI;QACR,IAAI,IAAI;QACR,MAAM,MAAM,QAAQ,CAAC,MAAM;QAC3B,SAAS,CAAC,MAAM,GAAG;QACnB,MAAM,KAAK,IAAI,IAAI,CAAC,OAAO;QAC3B,IAAK,IAAI,GAAG,IAAI,GAAG,MAAM,EAAE,KAAK,EAAG;YACjC,MAAM,MAAM,EAAE,CAAC,EAAE;YACjB,IAAI,IAAI,IAAI,KAAK,GAAG,GAAG,EAAE;gBACvB,IAAI,QAAQ,CAAC,IAAI,KAAK,CAAC,GAAG;gBAC1B,IAAI,CAAC,SAAS,CAAC,IAAI,KAAK,CAAC,EAAE;oBACzB,KAAK,WAAW,UAAU,IAAI,KAAK,EAAE;gBACvC;gBACA,IAAK,IAAI,GAAG,IAAI,WAAW,KAAK,EAAG;oBACjC,IAAI,QAAQ,CAAC,IAAI,KAAK,CAAC,CAAC,QAAQ,CAAC,EAAE,EAAE;wBACnC,IAAI,QAAQ,CAAC,EAAE,GAAG;oBACpB;gBACF;YACF,OAAO,IAAI,IAAI,IAAI,KAAK,GAAG,GAAG,EAAE;gBAC9B,IAAI,WAAW,CAAC,IAAI,KAAK,CAAC,GAAG;YAC/B,OAAO,IAAI,IAAI,IAAI,KAAK,GAAG,GAAG,EAAE;gBAC9B,IAAI,IAAI,KAAK,GAAG,WAAW;oBACzB,IAAI,QAAQ,CAAC,IAAI,KAAK,CAAC,GAAG;oBAC1B,IAAI,CAAC,SAAS,CAAC,IAAI,KAAK,CAAC,EAAE;wBACzB,KAAK,WAAW,UAAU,IAAI,KAAK,EAAE;oBACvC;gBACF,OAAO;oBACL,IAAI,WAAW,CAAC,YAAY,IAAI,KAAK,CAAC,GAAG;gBAC3C;YACF;QACF;IACF;IACA,wEAAwE;IACxE,MAAM,mBAAmB,CAAC;QACxB,QAAQ,UAAU,kBAAkB;QACpC,IAAI,IAAI;QACR,IAAI,IAAI;QACR,IAAI,aAAa;QACjB,IAAI,MAAM;QACV,IAAI,MAAM;QACV,IAAI,WAAW;QACf,MAAM,oBAAoB,GAAG;QAE7B,gDAAgD,GAChD,MAAM,YAAY,MAAM,UAAU,CAAC,MAAM,SAAS;QAElD,kCAAkC,GAClC,IAAK,IAAI,GAAG,IAAI,MAAM,SAAS,EAAE,KAAK,EAAG;YACvC,MAAM,YAAY,CAAC;YACnB,KAAK,MAAM,SAAS,EAAE,MAAM,QAAQ,EAAE,GAAG;QAC3C;QACA,4CAA4C,GAC5C,IAAK,IAAI,GAAG,IAAI,MAAM,SAAS,EAAE,KAAK,EAAG;YACvC,IAAK,IAAI,GAAG,IAAI,MAAM,SAAS,EAAE,KAAK,EAAG;gBACvC,IAAI,MAAM,GAAG;oBACX,IAAI,MAAM,QAAQ,CAAC,EAAE,CAAC,QAAQ,CAAC,EAAE,EAAE;wBACjC,MAAM,QAAQ,CAAC,EAAE,CAAC,YAAY,CAAC,EAAE,GAAG;oBACtC;gBACF;YACF;QACF;QACA,8CAA8C,GAC9C,IAAK,IAAI,GAAG,IAAI,MAAM,SAAS,EAAE,KAAK,EAAG;YACvC,MAAM,QAAQ,CAAC,EAAE,CAAC,aAAa,GAAG,GAAG,MAAM;YAC3C,IAAI,MAAM,QAAQ,CAAC,EAAE,CAAC,QAAQ,CAAC,EAAE,EAAE;gBACjC,MAAM,QAAQ,CAAC,EAAE,CAAC,aAAa,GAAG,GAAG,MAAM;YAC7C;QACF;QAEA,8CAA8C,GAC9C,aAAa,CAAC;QACd,IAAK,IAAI,GAAG,IAAI,MAAM,SAAS,EAAE,KAAK,EAAG;YACvC,MAAM,MAAM,QAAQ,CAAC,EAAE;YACvB,IAAI,IAAI,aAAa,KAAK,GAAG,MAAM,EAAE;gBACnC,WAAW;gBACX,IAAK,IAAI,GAAG,IAAI,MAAM,SAAS,EAAE,KAAK,EAAG;oBACvC,IAAI,MAAM,GAAG;wBACX,MAAM,MAAM,QAAQ,CAAC,EAAE;wBACvB,IAAI,IAAI,aAAa,KAAK,GAAG,MAAM,EAAE;4BACnC,IAAI,IAAI,QAAQ,CAAC,EAAE,IAAI,IAAI,QAAQ,CAAC,EAAE,EAAE;gCACtC,IAAI,UAAU;oCACZ,cAAc;oCACd,IAAI,aAAa,GAAG,GAAG,OAAO;oCAC9B,IAAI,WAAW,GAAG;oCAClB,WAAW;gCACb;gCACA,IAAI,aAAa,GAAG,GAAG,OAAO;gCAC9B,IAAI,WAAW,GAAG;4BACpB;wBACF;oBACF;gBACF;YACF;QACF;QACA,MAAM,mBAAmB,GAAG,aAAa,CAAC;QAE1C,uBAAuB,GACvB,MAAM,gBAAgB,CAAC,IAAI,CAAC,MAAM,cAAc;QAChD,MAAM,eAAe,CAAC,IAAI,CAAC,MAAM,cAAc;QAC/C,MAAM,eAAe,CAAC,IAAI,CAAC,MAAM,aAAa;QAC9C,IAAI,MAAM,mBAAmB,EAAE;YAC7B,MAAM,eAAe,CAAC,IAAI,CAAC,MAAM,cAAc;QACjD;QACA,IAAI,MAAM,QAAQ,EAAE;YAClB,MAAM,eAAe,CAAC,IAAI,CAAC,MAAM,aAAa;QAChD;QAEA,MAAM,oBAAoB,GAAG;IAC/B;IACA,MAAM,OAAO,CAAC,OAAO,IAAI;QACvB,IAAI,IAAI;QACR,IAAI,IAAI;QACR,IAAI,QAAQ;QACZ,IAAI,WAAW;QACf,MAAM,UAAU,MAAM,SAAS,GAAG;QAClC,MAAM,SAAS,MAAM,QAAQ,GAAG;QAChC,MAAM,aAAa;QACnB,IAAI,MAAM;QACV,IAAI,MAAM;QACV,MAAM,UAAU;QAChB,MAAM,UAAU;QAChB,IAAI,QAAQ;QACZ,IAAI,MAAM;QACV,IAAI,EAAE,WAAW,EAAE,GAAG;QACtB,IAAI,EAAE,UAAU,EAAE,GAAG;QACrB,IAAI,SAAS,IAAI;YACf,cAAc,MAAM,gBAAgB;YACpC,aAAa,MAAM,eAAe;QACpC,OAAO,IAAI,SAAS,KAAK;YACvB,cAAc,MAAM,eAAe;YACnC,aAAa,MAAM,eAAe;QACpC;QACA,IAAK,IAAI,GAAG,IAAI,MAAM,SAAS,EAAE,KAAK,EAAG;YACvC,MAAM,MAAM,QAAQ,CAAC,WAAW,CAAC,EAAE,CAAC;YACpC,MAAM,GAAG,WAAW,CAAC,EAAE,CAAC,CAAC,EAAE,MAAM,YAAY,CAAC,IAAI,aAAa,EAAE,CAAC,CAAC;YACnE,IAAI,MAAM,mBAAmB,EAAE;gBAC7B,OAAO,IAAI,WAAW,GAAG,CAAC,IAAI,IAAI,WAAW,GAAG;gBAChD,OAAO;YACT;YACA,OAAO;YACP,OAAO,GAAG,MAAM,MAAM,KAAK,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC;YACpD,QAAQ;YACR,QAAQ;YACR,WAAW,IAAI,MAAM;YACrB,OAAO;YACP,IAAK,IAAI,GAAG,IAAI,MAAM,SAAS,EAAE,KAAK,EAAG;gBACvC,IAAI,IAAI,QAAQ,CAAC,WAAW,CAAC,EAAE,CAAC,EAAE;oBAChC,IAAI,OAAO;wBACT,OAAO;wBACP,QAAQ;wBACR,OAAO,MAAM,QAAQ,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI;oBACjD,OAAO;wBACL,OAAO,CAAC,EAAE,EAAE,MAAM,QAAQ,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE;oBACxD;oBACA,SAAS;gBACX;gBACA,IAAI,IAAI,MAAM,GAAG,WAAW,cAAc,MAAM,SAAS;oBACvD,OAAO,CAAC,EAAE,EAAE,MAAM,SAAS;oBAC3B,WAAW,IAAI,MAAM;gBACvB;YACF;YACA,IAAI,MAAM,QAAQ,EAAE;gBAClB,IAAK,IAAI,GAAG,IAAI,MAAM,QAAQ,EAAE,KAAK,EAAG;oBACtC,IAAI,IAAI,WAAW,CAAC,UAAU,CAAC,EAAE,CAAC,EAAE;wBAClC,IAAI,OAAO;4BACT,OAAO;4BACP,QAAQ;4BACR,OAAO,MAAM,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC,IAAI;wBACvC,OAAO;4BACL,OAAO,CAAC,EAAE,EAAE,MAAM,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC,IAAI,EAAE;wBAC9C;wBACA,SAAS;oBACX;oBACA,IAAI,IAAI,MAAM,GAAG,WAAW,cAAc,MAAM,QAAQ;wBACtD,OAAO,CAAC,EAAE,EAAE,MAAM,SAAS;wBAC3B,WAAW,IAAI,MAAM;oBACvB;gBACF;YACF;YACA,IAAI,UAAU,GAAG;gBACf,OAAO;YACT;YACA,IAAI,UAAU,OAAO;gBACnB,OAAO;YACT;YACA,QAAQ;YACR,QAAQ;YACR,WAAW,IAAI,MAAM;YACrB,OAAO;YACP,IAAK,IAAI,GAAG,IAAI,MAAM,SAAS,EAAE,KAAK,EAAG;gBACvC,IAAI,IAAI,YAAY,CAAC,WAAW,CAAC,EAAE,CAAC,EAAE;oBACpC,IAAI,OAAO;wBACT,OAAO;wBACP,QAAQ;wBACR,OAAO,MAAM,QAAQ,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI;oBACjD,OAAO;wBACL,OAAO,CAAC,EAAE,EAAE,MAAM,QAAQ,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,EAAE;oBACxD;oBACA,SAAS;gBACX;gBACA,IAAI,IAAI,MAAM,GAAG,WAAW,cAAc,MAAM,SAAS;oBACvD,OAAO,CAAC,EAAE,EAAE,MAAM,SAAS;oBAC3B,WAAW,IAAI,MAAM;gBACvB;YACF;YACA,IAAI,UAAU,GAAG;gBACf,OAAO;YACT;YACA,IAAI,UAAU,OAAO;gBACnB,OAAO;YACT;YACA,OAAO;QACT;QACA,OAAO;IACT;IACA,iCAAiC;IACjC,UAAU;IACV,+CAA+C;IAC/C,4CAA4C;IAC5C,8EAA8E;IAC9E,8CAA8C;IAC9C,MAAM,uBAAuB,CAAC,QAAQ,OAAO;QAC3C,IAAI,MAAM;QACV,OAAO;QACP,OAAO;QACP,IAAI,CAAC,MAAM,oBAAoB,EAAE;YAC/B,OAAO;QACT;QAEA,IAAI,MAAM,UAAU,CAAC,OAAO,IAAI;YAC9B,OAAO;YACP,OAAO,KAAK;QACd,OAAO,IAAI,MAAM,UAAU,CAAC,OAAO,KAAK;YACtC,OAAO;YACP,OAAO,KAAK;QACd,OAAO;YACL,OAAO;YACP,OAAO,KAAK;QACd;QACA,OAAO;IACT;IAEA,+CAA+C,GAC/C,OAAO;QAAE;QAAkB;IAAqB;AAClD,CAAC","ignoreList":[0]}},
    {"offset": {"line": 11450, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/apg-js/src/apg-api/attributes.js"],"sourcesContent":["/* eslint-disable class-methods-use-this */\n/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// Attributes Validation\n//\n// It is well known that recursive-descent parsers will fail if a rule is left recursive.\n// Besides left recursion, there are a couple of other fatal attributes that need to be disclosed as well.\n// There are several non-fatal attributes that are of interest also.\n// This module will determine six different attributes listed here with simple examples.\n//\n// **fatal attributes**<br>\n// left recursion<br>\n// S = S \"x\" / \"y\"\n//\n// cyclic<br>\n// S = S\n//\n// infinite<br>\n// S = \"y\" S\n//\n// **non-fatal attributes** (but nice to know)<br>\n// nested recursion<br>\n// S = \"a\" S \"b\" / \"y\"\n//\n// right recursion<br>\n// S = \"x\" S / \"y\"\n//\n// empty string<br>\n// S = \"x\" S / \"\"\n//\n// Note that these are aggregate attributes, in that if the attribute is true it only means that it can be true,\n// not that it will always be true for every input string.\n// In the simple examples above the attributes may be obvious and definite  always true or false.\n// However, for a large grammar with possibly hundreds of rules and parse tree branches,\n// it can be obscure which branches lead to which attributes.\n// Furthermore, different input strings will lead the parser down different branches.\n// One input string may parse perfectly while another will hit a left-recursive branch and bottom out the call stack.\n//\n// It is for this reason that the APG parser generator computes these attributes.\n// When using the API the attributes call is optional but generating a parser without checking the attributes - proceed at your own peril.\n//\n// Additionally, the attribute phase will identify rule dependencies and mutually-recursive groups. For example,\n//\n// S = \"a\" A \"b\" / \"y\"<br>\n// A = \"x\"\n//\n// S is dependent on A but A is not dependent on S.\n//\n// S = \"a\" A \"b\" / \"c\"<br>\n// A = \"x\" S \"y\" / \"z\"\n//\n// S and A are dependent on one another and are mutually recursive.\nmodule.exports = (function exportAttributes() {\n  const id = require('../apg-lib/identifiers');\n  const { ruleAttributes, showAttributes, showAttributeErrors } = require('./rule-attributes');\n  const { ruleDependencies, showRuleDependencies } = require('./rule-dependencies');\n  class State {\n    constructor(rules, udts) {\n      this.rules = rules;\n      this.udts = udts;\n      this.ruleCount = rules.length;\n      this.udtCount = udts.length;\n      this.startRule = 0;\n      this.dependenciesComplete = false;\n      this.attributesComplete = false;\n      this.isMutuallyRecursive = false;\n      this.ruleIndexes = this.indexArray(this.ruleCount);\n      this.ruleAlphaIndexes = this.indexArray(this.ruleCount);\n      this.ruleTypeIndexes = this.indexArray(this.ruleCount);\n      this.udtIndexes = this.indexArray(this.udtCount);\n      this.udtAlphaIndexes = this.indexArray(this.udtCount);\n      this.attrsErrorCount = 0;\n      this.attrs = [];\n      this.attrsErrors = [];\n      this.attrsWorking = [];\n      this.ruleDeps = [];\n      for (let i = 0; i < this.ruleCount; i += 1) {\n        this.attrs.push(this.attrGen(this.rules[i]));\n        this.attrsWorking.push(this.attrGen(this.rules[i]));\n        this.ruleDeps.push(this.rdGen(rules[i], this.ruleCount, this.udtCount));\n      }\n      this.compRulesAlpha = this.compRulesAlpha.bind(this);\n      this.compUdtsAlpha = this.compUdtsAlpha.bind(this);\n      this.compRulesType = this.compRulesType.bind(this);\n      this.compRulesGroup = this.compRulesGroup.bind(this);\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    attrGen(rule) {\n      return {\n        left: false,\n        nested: false,\n        right: false,\n        empty: false,\n        finite: false,\n        cyclic: false,\n        leaf: false,\n        isOpen: false,\n        isComplete: false,\n        rule,\n      };\n    }\n\n    // eslint-disable-next-line class-methods-use-this\n    attrInit(attr) {\n      attr.left = false;\n      attr.nested = false;\n      attr.right = false;\n      attr.empty = false;\n      attr.finite = false;\n      attr.cyclic = false;\n      attr.leaf = false;\n      attr.isOpen = false;\n      attr.isComplete = false;\n    }\n\n    attrCopy(dst, src) {\n      dst.left = src.left;\n      dst.nested = src.nested;\n      dst.right = src.right;\n      dst.empty = src.empty;\n      dst.finite = src.finite;\n      dst.cyclic = src.cyclic;\n      dst.leaf = src.leaf;\n      dst.isOpen = src.isOpen;\n      dst.isComplete = src.isComplete;\n      dst.rule = src.rule;\n    }\n\n    rdGen(rule, ruleCount, udtCount) {\n      const ret = {\n        rule,\n        recursiveType: id.ATTR_N,\n        groupNumber: -1,\n        refersTo: this.falseArray(ruleCount),\n        refersToUdt: this.falseArray(udtCount),\n        referencedBy: this.falseArray(ruleCount),\n      };\n      return ret;\n    }\n\n    typeToString(recursiveType) {\n      switch (recursiveType) {\n        case id.ATTR_N:\n          return ' N';\n        case id.ATTR_R:\n          return ' R';\n        case id.ATTR_MR:\n          return 'MR';\n        default:\n          return 'UNKNOWN';\n      }\n    }\n\n    falseArray(length) {\n      const ret = [];\n      if (length > 0) {\n        for (let i = 0; i < length; i += 1) {\n          ret.push(false);\n        }\n      }\n      return ret;\n    }\n\n    falsifyArray(a) {\n      for (let i = 0; i < a.length; i += 1) {\n        a[i] = false;\n      }\n    }\n\n    indexArray(length) {\n      const ret = [];\n      if (length > 0) {\n        for (let i = 0; i < length; i += 1) {\n          ret.push(i);\n        }\n      }\n      return ret;\n    }\n\n    compRulesAlpha(left, right) {\n      if (this.rules[left].lower < this.rules[right].lower) {\n        return -1;\n      }\n      if (this.rules[left].lower > this.rules[right].lower) {\n        return 1;\n      }\n      return 0;\n    }\n\n    compUdtsAlpha(left, right) {\n      if (this.udts[left].lower < this.udts[right].lower) {\n        return -1;\n      }\n      if (this.udts[left].lower > this.udts[right].lower) {\n        return 1;\n      }\n      return 0;\n    }\n\n    compRulesType(left, right) {\n      if (this.ruleDeps[left].recursiveType < this.ruleDeps[right].recursiveType) {\n        return -1;\n      }\n      if (this.ruleDeps[left].recursiveType > this.ruleDeps[right].recursiveType) {\n        return 1;\n      }\n      return 0;\n    }\n\n    compRulesGroup(left, right) {\n      if (this.ruleDeps[left].recursiveType === id.ATTR_MR && this.ruleDeps[right].recursiveType === id.ATTR_MR) {\n        if (this.ruleDeps[left].groupNumber < this.ruleDeps[right].groupNumber) {\n          return -1;\n        }\n        if (this.ruleDeps[left].groupNumber > this.ruleDeps[right].groupNumber) {\n          return 1;\n        }\n      }\n      return 0;\n    }\n  }\n  // eslint-disable-next-line no-unused-vars\n  const attributes = function attributes(rules = [], udts = [], lineMap = [], errors = []) {\n    // let i = 0;\n    // Initialize the state. The state of the computation get passed around to multiple functions in multiple files.\n    const state = new State(rules, udts);\n\n    // Determine all rule dependencies\n    //  - which rules each rule refers to\n    //  - which rules reference each rule\n    ruleDependencies(state);\n\n    // Determine the attributes for each rule.\n    ruleAttributes(state);\n    if (state.attrsErrorCount) {\n      errors.push({ line: 0, char: 0, msg: `${state.attrsErrorCount} attribute errors` });\n    }\n\n    // Return the number of attribute errors to the caller.\n    return state.attrsErrorCount;\n  };\n\n  /* Destructuring assignment - see MDN Web Docs */\n  return { attributes, showAttributes, showAttributeErrors, showRuleDependencies };\n})();\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 11691, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/apg-js/src/apg-api/show-rules.js"],"sourcesContent":["/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\nmodule.exports = (function exfn() {\n  const thisFileName = 'show-rules.js';\n  // Display the rules.\n  // This function may be called before the attributes calculation.\n  // Sorting is done independently from the attributes.\n  // - order\n  //      - \"index\" or \"i\", index order (default)\n  //      - \"alpha\" or \"a\", alphabetical order\n  //      - none of above, index order (default)\n  const showRules = function showRules(rulesIn = [], udtsIn = [], order = 'index') {\n    const thisFuncName = 'showRules';\n    let alphaArray = [];\n    let udtAlphaArray = [];\n    const indexArray = [];\n    const udtIndexArray = [];\n    const rules = rulesIn;\n    const udts = udtsIn;\n    const ruleCount = rulesIn.length;\n    const udtCount = udtsIn.length;\n    let str = 'RULE/UDT NAMES';\n    let i;\n    function compRulesAlpha(left, right) {\n      if (rules[left].lower < rules[right].lower) {\n        return -1;\n      }\n      if (rules[left].lower > rules[right].lower) {\n        return 1;\n      }\n      return 0;\n    }\n    function compUdtsAlpha(left, right) {\n      if (udts[left].lower < udts[right].lower) {\n        return -1;\n      }\n      if (udts[left].lower > udts[right].lower) {\n        return 1;\n      }\n      return 0;\n    }\n    if (!(Array.isArray(rulesIn) && rulesIn.length)) {\n      throw new Error(`${thisFileName}:${thisFuncName}: rules arg must be array with length > 0`);\n    }\n    if (!Array.isArray(udtsIn)) {\n      throw new Error(`${thisFileName}:${thisFuncName}: udts arg must be array`);\n    }\n\n    for (i = 0; i < ruleCount; i += 1) {\n      indexArray.push(i);\n    }\n    alphaArray = indexArray.slice(0);\n    alphaArray.sort(compRulesAlpha);\n    if (udtCount) {\n      for (i = 0; i < udtCount; i += 1) {\n        udtIndexArray.push(i);\n      }\n      udtAlphaArray = udtIndexArray.slice(0);\n      udtAlphaArray.sort(compUdtsAlpha);\n    }\n    if (order.charCodeAt(0) === 97) {\n      str += ' - alphabetical by rule/UDT name\\n';\n      for (i = 0; i < ruleCount; i += 1) {\n        str += `${i}: ${alphaArray[i]}: ${rules[alphaArray[i]].name}\\n`;\n      }\n      if (udtCount) {\n        for (i = 0; i < udtCount; i += 1) {\n          str += `${i}: ${udtAlphaArray[i]}: ${udts[udtAlphaArray[i]].name}\\n`;\n        }\n      }\n    } else {\n      str += ' - ordered by rule/UDT index\\n';\n      for (i = 0; i < ruleCount; i += 1) {\n        str += `${i}: ${rules[i].name}\\n`;\n      }\n      if (udtCount) {\n        for (i = 0; i < udtCount; i += 1) {\n          str += `${i}: ${udts[i].name}\\n`;\n        }\n      }\n    }\n    return str;\n  };\n  return showRules;\n})();\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 11779, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/apg-js/src/apg-api/api.js"],"sourcesContent":["/*  *************************************************************************************\n *   copyright: Copyright (c) 2021 Lowell D. Thomas, all rights reserved\n *     license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)\n *   ********************************************************************************* */\n// This module is Application Programming Interface (API) for **APG** - the ABNF Parser Generator.\n//\n// *Note on teminology.*\n// APG is a parser generator.\n// However, it really only generates a \"grammar object\" (see below) from the defining SABNF grammar.\n// The generated parser is incomplete at this stage.\n// Remaining, it is the job of the user to develop the generated parser from the grammar object and the **APG** Library (**apg-lib**).\n//\n// The following terminology my help clear up any confusion between the idea of a \"generated parser\" versus a \"generated grammar object\".\n\n// - The generating parser: **APG** is an **APG** parser (yes, there is a circular dependence between **apg-api** and **apg-lib**). We'll call it the generating parser.\n// - The target parser: **APG**'s goal is to generate a parser. We'll call it the target parser.\n// - The target grammar: this is the (ASCII) SABNF grammar defining the target parser.\n// - The target grammar object: **APG** parses the SABNF grammar and generates the JavaScript source for a target grammar object constructor function\n// and/or an actual grammar object.\n// - The final target parser: The user then develops the final target parser using the generated target grammar\n// object and the **APG** parsing library, **apg-lib**.\n// Throws execeptions on fatal errors.\n//\n// src: the input SABNF grammar<br>\n// may be one of:\n// - Buffer of bytes\n// - JavaScript string\n// - Array of integer character codes\nmodule.exports = function api(src) {\n  const { Buffer } = require('buffer');\n  const thisFileName = 'api.js: ';\n  const thisObject = this;\n\n  /* PRIVATE PROPERTIES */\n  const apglib = require('../apg-lib/node-exports');\n  const converter = require('../apg-conv-api/converter');\n  const scanner = require('./scanner');\n  const parser = new (require('./parser'))();\n  const { attributes, showAttributes, showAttributeErrors, showRuleDependencies } = require('./attributes');\n  const showRules = require('./show-rules');\n\n  /* PRIVATE MEMBERS (FUNCTIONS) */\n  /* Convert a phrase (array of character codes) to HTML. */\n  const abnfToHtml = function abnfToHtml(chars, beg, len) {\n    const NORMAL = 0;\n    const CONTROL = 1;\n    const INVALID = 2;\n    const CONTROL_BEG = `<span class=\"${apglib.style.CLASS_CTRLCHAR}\">`;\n    const CONTROL_END = '</span>';\n    const INVALID_BEG = `<span class=\"${apglib.style.CLASS_NOMATCH}\">`;\n    const INVALID_END = '</span>';\n    let end;\n    let html = '';\n    const TRUE = true;\n    while (TRUE) {\n      if (!Array.isArray(chars) || chars.length === 0) {\n        break;\n      }\n      if (typeof beg !== 'number') {\n        throw new Error('abnfToHtml: beg must be type number');\n      }\n      if (beg >= chars.length) {\n        break;\n      }\n      if (typeof len !== 'number' || beg + len >= chars.length) {\n        end = chars.length;\n      } else {\n        end = beg + len;\n      }\n      let state = NORMAL;\n      for (let i = beg; i < end; i += 1) {\n        const ch = chars[i];\n        if (ch >= 32 && ch <= 126) {\n          /* normal - printable ASCII characters */\n          if (state === CONTROL) {\n            html += CONTROL_END;\n            state = NORMAL;\n          } else if (state === INVALID) {\n            html += INVALID_END;\n            state = NORMAL;\n          }\n          /* handle reserved HTML entity characters */\n          switch (ch) {\n            case 32:\n              html += '&nbsp;';\n              break;\n            case 60:\n              html += '&lt;';\n              break;\n            case 62:\n              html += '&gt;';\n              break;\n            case 38:\n              html += '&amp;';\n              break;\n            case 34:\n              html += '&quot;';\n              break;\n            case 39:\n              html += '&#039;';\n              break;\n            case 92:\n              html += '&#092;';\n              break;\n            default:\n              html += String.fromCharCode(ch);\n              break;\n          }\n        } else if (ch === 9 || ch === 10 || ch === 13) {\n          /* control characters */\n          if (state === NORMAL) {\n            html += CONTROL_BEG;\n            state = CONTROL;\n          } else if (state === INVALID) {\n            html += INVALID_END + CONTROL_BEG;\n            state = CONTROL;\n          }\n          if (ch === 9) {\n            html += 'TAB';\n          }\n          if (ch === 10) {\n            html += 'LF';\n          }\n          if (ch === 13) {\n            html += 'CR';\n          }\n        } else {\n          /* invalid characters */\n          if (state === NORMAL) {\n            html += INVALID_BEG;\n            state = INVALID;\n          } else if (state === CONTROL) {\n            html += CONTROL_END + INVALID_BEG;\n            state = INVALID;\n          }\n          /* display character as hexadecimal value */\n          html += `\\\\x${apglib.utils.charToHex(ch)}`;\n        }\n      }\n      if (state === INVALID) {\n        html += INVALID_END;\n      }\n      if (state === CONTROL) {\n        html += CONTROL_END;\n      }\n      break;\n    }\n    return html;\n  };\n  /* Convert a phrase (array of character codes) to ASCII text. */\n  const abnfToAscii = function abnfToAscii(chars, beg, len) {\n    let str = '';\n    for (let i = beg; i < beg + len; i += 1) {\n      const ch = chars[i];\n      if (ch >= 32 && ch <= 126) {\n        str += String.fromCharCode(ch);\n      } else {\n        switch (ch) {\n          case 9:\n            str += '\\\\t';\n            break;\n          case 10:\n            str += '\\\\n';\n            break;\n          case 13:\n            str += '\\\\r';\n            break;\n          default:\n            str += '\\\\unknown';\n            break;\n        }\n      }\n    }\n    return str;\n  };\n  /* translate lines (SABNF grammar) to ASCII text */\n  const linesToAscii = function linesToAscii(lines) {\n    let str = 'Annotated Input Grammar';\n    lines.forEach((val) => {\n      str += '\\n';\n      str += `line no: ${val.lineNo}`;\n      str += ` : char index: ${val.beginChar}`;\n      str += ` : length: ${val.length}`;\n      str += ` : abnf: ${abnfToAscii(thisObject.chars, val.beginChar, val.length)}`;\n    });\n    str += '\\n';\n    return str;\n  };\n  /* translate lines (SABNF grammar) to HTML */\n  const linesToHtml = function linesToHtml(lines) {\n    let html = '';\n    html += `<table class=\"${apglib.style.CLASS_GRAMMAR}\">\\n`;\n    const title = 'Annotated Input Grammar';\n    html += `<caption>${title}</caption>\\n`;\n    html += '<tr>';\n    html += '<th>line<br>no.</th><th>first<br>char</th><th><br>length</th><th><br>text</th>';\n    html += '</tr>\\n';\n    lines.forEach((val) => {\n      html += '<tr>';\n      html += `<td>${val.lineNo}`;\n      html += `</td><td>${val.beginChar}`;\n      html += `</td><td>${val.length}`;\n      html += `</td><td>${abnfToHtml(thisObject.chars, val.beginChar, val.length)}`;\n      html += '</td>';\n      html += '</tr>\\n';\n    });\n\n    html += '</table>\\n';\n    return html;\n  };\n  /* Format the error messages to HTML, for page display. */\n  const errorsToHtml = function errorsToHtml(errors, lines, chars, title) {\n    const [style] = apglib;\n    let html = '';\n    const errorArrow = `<span class=\"${style.CLASS_NOMATCH}\">&raquo;</span>`;\n    html += `<p><table class=\"${style.CLASS_GRAMMAR}\">\\n`;\n    if (title && typeof title === 'string') {\n      html += `<caption>${title}</caption>\\n`;\n    }\n    html += '<tr><th>line<br>no.</th><th>line<br>offset</th><th>error<br>offset</th><th><br>text</th></tr>\\n';\n    errors.forEach((val) => {\n      let line;\n      let relchar;\n      let beg;\n      let end;\n      let text;\n      let prefix = '';\n      let suffix = '';\n      if (lines.length === 0) {\n        text = errorArrow;\n        relchar = 0;\n      } else {\n        line = lines[val.line];\n        beg = line.beginChar;\n        if (val.char > beg) {\n          prefix = abnfToHtml(chars, beg, val.char - beg);\n        }\n        beg = val.char;\n        end = line.beginChar + line.length;\n        if (beg < end) {\n          suffix = abnfToHtml(chars, beg, end - beg);\n        }\n        text = prefix + errorArrow + suffix;\n        relchar = val.char - line.beginChar;\n        html += '<tr>';\n        html += `<td>${val.line}</td><td>${line.beginChar}</td><td>${relchar}</td><td>${text}</td>`;\n        html += '</tr>\\n';\n        html += '<tr>';\n        html += `<td colspan=\"3\"></td><td>&uarr;:&nbsp;${apglib.utils.stringToAsciiHtml(val.msg)}</td>`;\n        html += '</tr>\\n';\n      }\n    });\n    html += '</table></p>\\n';\n    return html;\n  };\n  /* Display an array of errors in ASCII text */\n  const errorsToAscii = function errorsToAscii(errors, lines, chars) {\n    let str;\n    let line;\n    let beg;\n    let len;\n    str = '';\n    errors.forEach((error) => {\n      line = lines[error.line];\n      str += `${line.lineNo}: `;\n      str += `${line.beginChar}: `;\n      str += `${error.char - line.beginChar}: `;\n      beg = line.beginChar;\n      len = error.char - line.beginChar;\n      str += abnfToAscii(chars, beg, len);\n      str += ' >> ';\n      beg = error.char;\n      len = line.beginChar + line.length - error.char;\n      str += abnfToAscii(chars, beg, len);\n      str += '\\n';\n      str += `${line.lineNo}: `;\n      str += `${line.beginChar}: `;\n      str += `${error.char - line.beginChar}: `;\n      str += 'error: ';\n      str += error.msg;\n      str += '\\n';\n    });\n    return str;\n  };\n  let isScanned = false;\n  let isParsed = false;\n  let isTranslated = false;\n  let haveAttributes = false;\n  let attributeErrors = 0;\n  let lineMap;\n\n  /* PUBLIC PROPERTIES */\n  // The input SABNF grammar as a JavaScript string.\n  // this.sabnf;\n  // The input SABNF grammar as an array of character codes.\n  // this.chars;\n  // An array of line objects, defining each line of the input SABNF grammar\n  // - lineNo : the zero-based line number\n  // - beginChar : offset (into `this.chars`) of the first character in the line\n  // - length : the number of characters in the line\n  // - textLength : the number of characters of text in the line, excluding the line ending characters\n  // - endType : \"CRLF\", \"LF\", \"CR\" or \"none\" if the last line has no line ending characters\n  // - invalidChars : `true` if the line contains invalid characters, `false` otherwise\n  // this.lines;\n  // An array of rule names and data.\n  // - name : the rule name\n  // - lower : the rule name in lower case\n  // - index : the index of the rule (ordered by appearance in SABNF grammar)\n  // - isBkr : `true` if this rule has been back referenced, `false` otherwise\n  // - opcodes : array of opcodes for this rule\n  // - attrs : the rule attributes\n  // - ctrl : system data\n  // this.rules;\n  // An array of UDT names and data.\n  // this.udts;\n  // An array of errors, if any.\n  // - line : the line number containing the error\n  // - char : the character offset of the error\n  // - msg : the error message\n  this.errors = [];\n\n  /* CONSTRUCTOR */\n  if (Buffer.isBuffer(src)) {\n    this.chars = converter.decode('BINARY', src);\n  } else if (Array.isArray(src)) {\n    this.chars = src.slice();\n  } else if (typeof src === 'string') {\n    this.chars = converter.decode('STRING', src);\n  } else {\n    throw new Error(`${thisFileName}input source is not a string, byte Buffer or character array`);\n  }\n  this.sabnf = converter.encode('STRING', this.chars);\n\n  /* PUBLIC MEMBERS (FUNCTIONS) */\n  // Scan the input SABNF grammar for invalid characters and catalog the lines via `this.lines`.\n  // - strict : (optional) if `true`, all lines, including the last must end with CRLF (\\r\\n),\n  // if `false` (in any JavaScript sense) then line endings may be any mix of CRLF, LF, CR, or end-of-file.\n  // - trace (*) : (optional) a parser trace object, which will trace the parser that does the scan\n  this.scan = function scan(strict, trace) {\n    this.lines = scanner(this.chars, this.errors, strict, trace);\n    isScanned = true;\n  };\n  // Parse the input SABNF grammar for correct syntax.\n  // - strict : (optional) if `true`, the input grammar must be strict ABNF, conforming to [RFC 5234](https://tools.ietf.org/html/rfc5234)\n  // and [RFC 7405](https://tools.ietf.org/html/rfc7405). No superset features allowed.\n  // - trace (\\*) : (optional) a parser trace object, which will trace the syntax parser\n  //\n  // <i>(*)NOTE: the trace option was used primarily during development.\n  // Error detection and reporting is now fairly robust and tracing should be unnecessary. Use at your own peril.</i>\n  this.parse = function parse(strict, lite, trace) {\n    if (!isScanned) {\n      throw new Error(`${thisFileName}grammar not scanned`);\n    }\n    parser.syntax(this.chars, this.lines, this.errors, strict, lite, trace);\n    isParsed = true;\n  };\n  // Translate the SABNF grammar syntax into the opcodes that will guide the parser for this grammar.\n  this.translate = function translate() {\n    if (!isParsed) {\n      throw new Error(`${thisFileName}grammar not scanned and parsed`);\n    }\n    const ret = parser.semantic(this.chars, this.lines, this.errors);\n    if (this.errors.length === 0) {\n      this.rules = ret.rules;\n      this.udts = ret.udts;\n      lineMap = ret.lineMap;\n      isTranslated = true;\n    }\n  };\n  // Compute the attributes of each rule.\n  this.attributes = function attrs() {\n    if (!isTranslated) {\n      throw new Error(`${thisFileName}grammar not scanned, parsed and translated`);\n    }\n    attributeErrors = attributes(this.rules, this.udts, lineMap, this.errors);\n    haveAttributes = true;\n    return attributeErrors;\n  };\n  // This function will perform the full suite of steps required to generate a parser grammar object\n  // from the input SABNF grammar.\n  this.generate = function generate(strict) {\n    this.lines = scanner(this.chars, this.errors, strict);\n    if (this.errors.length) {\n      return;\n    }\n    parser.syntax(this.chars, this.lines, this.errors, strict);\n    if (this.errors.length) {\n      return;\n    }\n    const ret = parser.semantic(this.chars, this.lines, this.errors);\n    if (this.errors.length) {\n      return;\n    }\n    this.rules = ret.rules;\n    this.udts = ret.udts;\n    lineMap = ret.lineMap;\n\n    attributeErrors = attributes(this.rules, this.udts, lineMap, this.errors);\n    haveAttributes = true;\n  };\n  // Display the rules.\n  // Must scan, parse and translate before calling this function, otherwise there are no rules to display.\n  // - order\n  //      - \"index\" or \"i\", index order (default)\n  //      - \"alpha\" or \"a\", alphabetical order\n  //      - none of above, index order (default)\n  this.displayRules = function displayRules(order = 'index') {\n    if (!isTranslated) {\n      throw new Error(`${thisFileName}grammar not scanned, parsed and translated`);\n    }\n    return showRules(this.rules, this.udts, order);\n  };\n  // Display the rule dependencies.\n  // Must scan, parse, translate and compute attributes before calling this function.\n  // Otherwise the rule dependencies are not known.\n  // - order\n  //      - \"index\" or \"i\", index order (default)\n  //      - \"alpha\" or \"a\", alphabetical order\n  //      - \"type\" or \"t\", ordered by type (alphabetical within each type/group)\n  //      - none of above, index order (default)\n  this.displayRuleDependencies = function displayRuleDependencies(order = 'index') {\n    if (!haveAttributes) {\n      throw new Error(`${thisFileName}no attributes - must be preceeded by call to attributes()`);\n    }\n    return showRuleDependencies(order);\n  };\n  // Display the attributes.\n  // Must scan, parse, translate and compute attributes before calling this function.\n  // - order\n  //      - \"index\" or \"i\", index order (default)\n  //      - \"alpha\" or \"a\", alphabetical order\n  //      - \"type\" or \"t\", ordered by type (alphabetical within each type/group)\n  //      - none of above, type order (default)\n  this.displayAttributes = function displayAttributes(order = 'index') {\n    if (!haveAttributes) {\n      throw new Error(`${thisFileName}no attributes - must be preceeded by call to attributes()`);\n    }\n    if (attributeErrors) {\n      showAttributeErrors(order);\n    }\n    return showAttributes(order);\n  };\n  this.displayAttributeErrors = function displayAttributeErrors() {\n    if (!haveAttributes) {\n      throw new Error(`${thisFileName}no attributes - must be preceeded by call to attributes()`);\n    }\n    return showAttributeErrors();\n  };\n  // Returns a parser grammar object constructor function as a JavaScript string.\n  // This object can then be used to construct a parser.\n  this.toSource = function toSource(config = undefined) {\n    if (!haveAttributes) {\n      throw new Error(`${thisFileName}can't generate parser source - must be preceeded by call to attributes()`);\n    }\n    if (attributeErrors) {\n      throw new Error(`${thisFileName}can't generate parser source - attributes have ${attributeErrors} errors`);\n    }\n    return parser.generateSource(this.chars, this.lines, this.rules, this.udts, config);\n  };\n  // Returns a parser grammar object.\n  // This grammar object may be used by the application to construct a parser.\n  this.toObject = function toObject() {\n    if (!haveAttributes) {\n      throw new Error(`${thisFileName}can't generate parser source - must be preceeded by call to attributes()`);\n    }\n    if (attributeErrors) {\n      throw new Error(`${thisFileName}can't generate parser source - attributes have ${attributeErrors} errors`);\n    }\n    return parser.generateObject(this.sabnf, this.rules, this.udts);\n  };\n  // Display errors in text format, suitable for `console.log()`.\n  this.errorsToAscii = function errorsToAsciiFunc() {\n    return errorsToAscii(this.errors, this.lines, this.chars);\n  };\n  // Display errors in HTML format, suitable for web page display.\n  // (`apg-lib.css` required for proper styling)\n  this.errorsToHtml = function errorsToHtmlFunc(title) {\n    return errorsToHtml(this.errors, this.lines, this.chars, title);\n  };\n  // Generate an annotated the SABNF grammar display in text format.\n  this.linesToAscii = function linesToAsciiFunc() {\n    return linesToAscii(this.lines);\n  };\n  // Generate an annotated the SABNF grammar display in HTML format.\n  // (`apg-lib.css` required for proper styling)\n  this.linesToHtml = function linesToHtmlFunc() {\n    return linesToHtml(this.lines);\n  };\n  // This function was only used by apg.html which has been abandoned.\n  /*\n    this.getAttributesObject = function () {\n        return null;\n    };\n    */\n};\n"],"names":[],"mappings":"AAAA;;;uFAGuF,GACvF,kGAAkG;AAClG,EAAE;AACF,wBAAwB;AACxB,6BAA6B;AAC7B,oGAAoG;AACpG,oDAAoD;AACpD,sIAAsI;AACtI,EAAE;AACF,yIAAyI;AAEzI,wKAAwK;AACxK,gGAAgG;AAChG,sFAAsF;AACtF,qJAAqJ;AACrJ,mCAAmC;AACnC,+GAA+G;AAC/G,uDAAuD;AACvD,sCAAsC;AACtC,EAAE;AACF,mCAAmC;AACnC,iBAAiB;AACjB,oBAAoB;AACpB,sBAAsB;AACtB,qCAAqC;AACrC,OAAO,OAAO,GAAG,SAAS,IAAI,GAAG;IAC/B,MAAM,EAAE,MAAM,EAAE;IAChB,MAAM,eAAe;IACrB,MAAM,aAAa,IAAI;IAEvB,sBAAsB,GACtB,MAAM;IACN,MAAM;IACN,MAAM;IACN,MAAM,SAAS,IAAI,yGAAoB;IACvC,MAAM,EAAE,UAAU,EAAE,cAAc,EAAE,mBAAmB,EAAE,oBAAoB,EAAE;IAC/E,MAAM;IAEN,+BAA+B,GAC/B,wDAAwD,GACxD,MAAM,aAAa,SAAS,WAAW,KAAK,EAAE,GAAG,EAAE,GAAG;QACpD,MAAM,SAAS;QACf,MAAM,UAAU;QAChB,MAAM,UAAU;QAChB,MAAM,cAAc,CAAC,aAAa,EAAE,OAAO,KAAK,CAAC,cAAc,CAAC,EAAE,CAAC;QACnE,MAAM,cAAc;QACpB,MAAM,cAAc,CAAC,aAAa,EAAE,OAAO,KAAK,CAAC,aAAa,CAAC,EAAE,CAAC;QAClE,MAAM,cAAc;QACpB,IAAI;QACJ,IAAI,OAAO;QACX,MAAM,OAAO;QACb,MAAO,KAAM;YACX,IAAI,CAAC,MAAM,OAAO,CAAC,UAAU,MAAM,MAAM,KAAK,GAAG;gBAC/C;YACF;YACA,IAAI,OAAO,QAAQ,UAAU;gBAC3B,MAAM,IAAI,MAAM;YAClB;YACA,IAAI,OAAO,MAAM,MAAM,EAAE;gBACvB;YACF;YACA,IAAI,OAAO,QAAQ,YAAY,MAAM,OAAO,MAAM,MAAM,EAAE;gBACxD,MAAM,MAAM,MAAM;YACpB,OAAO;gBACL,MAAM,MAAM;YACd;YACA,IAAI,QAAQ;YACZ,IAAK,IAAI,IAAI,KAAK,IAAI,KAAK,KAAK,EAAG;gBACjC,MAAM,KAAK,KAAK,CAAC,EAAE;gBACnB,IAAI,MAAM,MAAM,MAAM,KAAK;oBACzB,uCAAuC,GACvC,IAAI,UAAU,SAAS;wBACrB,QAAQ;wBACR,QAAQ;oBACV,OAAO,IAAI,UAAU,SAAS;wBAC5B,QAAQ;wBACR,QAAQ;oBACV;oBACA,0CAA0C,GAC1C,OAAQ;wBACN,KAAK;4BACH,QAAQ;4BACR;wBACF,KAAK;4BACH,QAAQ;4BACR;wBACF,KAAK;4BACH,QAAQ;4BACR;wBACF,KAAK;4BACH,QAAQ;4BACR;wBACF,KAAK;4BACH,QAAQ;4BACR;wBACF,KAAK;4BACH,QAAQ;4BACR;wBACF,KAAK;4BACH,QAAQ;4BACR;wBACF;4BACE,QAAQ,OAAO,YAAY,CAAC;4BAC5B;oBACJ;gBACF,OAAO,IAAI,OAAO,KAAK,OAAO,MAAM,OAAO,IAAI;oBAC7C,sBAAsB,GACtB,IAAI,UAAU,QAAQ;wBACpB,QAAQ;wBACR,QAAQ;oBACV,OAAO,IAAI,UAAU,SAAS;wBAC5B,QAAQ,cAAc;wBACtB,QAAQ;oBACV;oBACA,IAAI,OAAO,GAAG;wBACZ,QAAQ;oBACV;oBACA,IAAI,OAAO,IAAI;wBACb,QAAQ;oBACV;oBACA,IAAI,OAAO,IAAI;wBACb,QAAQ;oBACV;gBACF,OAAO;oBACL,sBAAsB,GACtB,IAAI,UAAU,QAAQ;wBACpB,QAAQ;wBACR,QAAQ;oBACV,OAAO,IAAI,UAAU,SAAS;wBAC5B,QAAQ,cAAc;wBACtB,QAAQ;oBACV;oBACA,0CAA0C,GAC1C,QAAQ,CAAC,GAAG,EAAE,OAAO,KAAK,CAAC,SAAS,CAAC,KAAK;gBAC5C;YACF;YACA,IAAI,UAAU,SAAS;gBACrB,QAAQ;YACV;YACA,IAAI,UAAU,SAAS;gBACrB,QAAQ;YACV;YACA;QACF;QACA,OAAO;IACT;IACA,8DAA8D,GAC9D,MAAM,cAAc,SAAS,YAAY,KAAK,EAAE,GAAG,EAAE,GAAG;QACtD,IAAI,MAAM;QACV,IAAK,IAAI,IAAI,KAAK,IAAI,MAAM,KAAK,KAAK,EAAG;YACvC,MAAM,KAAK,KAAK,CAAC,EAAE;YACnB,IAAI,MAAM,MAAM,MAAM,KAAK;gBACzB,OAAO,OAAO,YAAY,CAAC;YAC7B,OAAO;gBACL,OAAQ;oBACN,KAAK;wBACH,OAAO;wBACP;oBACF,KAAK;wBACH,OAAO;wBACP;oBACF,KAAK;wBACH,OAAO;wBACP;oBACF;wBACE,OAAO;wBACP;gBACJ;YACF;QACF;QACA,OAAO;IACT;IACA,iDAAiD,GACjD,MAAM,eAAe,SAAS,aAAa,KAAK;QAC9C,IAAI,MAAM;QACV,MAAM,OAAO,CAAC,CAAC;YACb,OAAO;YACP,OAAO,CAAC,SAAS,EAAE,IAAI,MAAM,EAAE;YAC/B,OAAO,CAAC,eAAe,EAAE,IAAI,SAAS,EAAE;YACxC,OAAO,CAAC,WAAW,EAAE,IAAI,MAAM,EAAE;YACjC,OAAO,CAAC,SAAS,EAAE,YAAY,WAAW,KAAK,EAAE,IAAI,SAAS,EAAE,IAAI,MAAM,GAAG;QAC/E;QACA,OAAO;QACP,OAAO;IACT;IACA,2CAA2C,GAC3C,MAAM,cAAc,SAAS,YAAY,KAAK;QAC5C,IAAI,OAAO;QACX,QAAQ,CAAC,cAAc,EAAE,OAAO,KAAK,CAAC,aAAa,CAAC,IAAI,CAAC;QACzD,MAAM,QAAQ;QACd,QAAQ,CAAC,SAAS,EAAE,MAAM,YAAY,CAAC;QACvC,QAAQ;QACR,QAAQ;QACR,QAAQ;QACR,MAAM,OAAO,CAAC,CAAC;YACb,QAAQ;YACR,QAAQ,CAAC,IAAI,EAAE,IAAI,MAAM,EAAE;YAC3B,QAAQ,CAAC,SAAS,EAAE,IAAI,SAAS,EAAE;YACnC,QAAQ,CAAC,SAAS,EAAE,IAAI,MAAM,EAAE;YAChC,QAAQ,CAAC,SAAS,EAAE,WAAW,WAAW,KAAK,EAAE,IAAI,SAAS,EAAE,IAAI,MAAM,GAAG;YAC7E,QAAQ;YACR,QAAQ;QACV;QAEA,QAAQ;QACR,OAAO;IACT;IACA,wDAAwD,GACxD,MAAM,eAAe,SAAS,aAAa,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,KAAK;QACpE,MAAM,CAAC,MAAM,GAAG;QAChB,IAAI,OAAO;QACX,MAAM,aAAa,CAAC,aAAa,EAAE,MAAM,aAAa,CAAC,gBAAgB,CAAC;QACxE,QAAQ,CAAC,iBAAiB,EAAE,MAAM,aAAa,CAAC,IAAI,CAAC;QACrD,IAAI,SAAS,OAAO,UAAU,UAAU;YACtC,QAAQ,CAAC,SAAS,EAAE,MAAM,YAAY,CAAC;QACzC;QACA,QAAQ;QACR,OAAO,OAAO,CAAC,CAAC;YACd,IAAI;YACJ,IAAI;YACJ,IAAI;YACJ,IAAI;YACJ,IAAI;YACJ,IAAI,SAAS;YACb,IAAI,SAAS;YACb,IAAI,MAAM,MAAM,KAAK,GAAG;gBACtB,OAAO;gBACP,UAAU;YACZ,OAAO;gBACL,OAAO,KAAK,CAAC,IAAI,IAAI,CAAC;gBACtB,MAAM,KAAK,SAAS;gBACpB,IAAI,IAAI,IAAI,GAAG,KAAK;oBAClB,SAAS,WAAW,OAAO,KAAK,IAAI,IAAI,GAAG;gBAC7C;gBACA,MAAM,IAAI,IAAI;gBACd,MAAM,KAAK,SAAS,GAAG,KAAK,MAAM;gBAClC,IAAI,MAAM,KAAK;oBACb,SAAS,WAAW,OAAO,KAAK,MAAM;gBACxC;gBACA,OAAO,SAAS,aAAa;gBAC7B,UAAU,IAAI,IAAI,GAAG,KAAK,SAAS;gBACnC,QAAQ;gBACR,QAAQ,CAAC,IAAI,EAAE,IAAI,IAAI,CAAC,SAAS,EAAE,KAAK,SAAS,CAAC,SAAS,EAAE,QAAQ,SAAS,EAAE,KAAK,KAAK,CAAC;gBAC3F,QAAQ;gBACR,QAAQ;gBACR,QAAQ,CAAC,sCAAsC,EAAE,OAAO,KAAK,CAAC,iBAAiB,CAAC,IAAI,GAAG,EAAE,KAAK,CAAC;gBAC/F,QAAQ;YACV;QACF;QACA,QAAQ;QACR,OAAO;IACT;IACA,4CAA4C,GAC5C,MAAM,gBAAgB,SAAS,cAAc,MAAM,EAAE,KAAK,EAAE,KAAK;QAC/D,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,IAAI;QACJ,MAAM;QACN,OAAO,OAAO,CAAC,CAAC;YACd,OAAO,KAAK,CAAC,MAAM,IAAI,CAAC;YACxB,OAAO,GAAG,KAAK,MAAM,CAAC,EAAE,CAAC;YACzB,OAAO,GAAG,KAAK,SAAS,CAAC,EAAE,CAAC;YAC5B,OAAO,GAAG,MAAM,IAAI,GAAG,KAAK,SAAS,CAAC,EAAE,CAAC;YACzC,MAAM,KAAK,SAAS;YACpB,MAAM,MAAM,IAAI,GAAG,KAAK,SAAS;YACjC,OAAO,YAAY,OAAO,KAAK;YAC/B,OAAO;YACP,MAAM,MAAM,IAAI;YAChB,MAAM,KAAK,SAAS,GAAG,KAAK,MAAM,GAAG,MAAM,IAAI;YAC/C,OAAO,YAAY,OAAO,KAAK;YAC/B,OAAO;YACP,OAAO,GAAG,KAAK,MAAM,CAAC,EAAE,CAAC;YACzB,OAAO,GAAG,KAAK,SAAS,CAAC,EAAE,CAAC;YAC5B,OAAO,GAAG,MAAM,IAAI,GAAG,KAAK,SAAS,CAAC,EAAE,CAAC;YACzC,OAAO;YACP,OAAO,MAAM,GAAG;YAChB,OAAO;QACT;QACA,OAAO;IACT;IACA,IAAI,YAAY;IAChB,IAAI,WAAW;IACf,IAAI,eAAe;IACnB,IAAI,iBAAiB;IACrB,IAAI,kBAAkB;IACtB,IAAI;IAEJ,qBAAqB,GACrB,kDAAkD;IAClD,cAAc;IACd,0DAA0D;IAC1D,cAAc;IACd,0EAA0E;IAC1E,wCAAwC;IACxC,8EAA8E;IAC9E,kDAAkD;IAClD,oGAAoG;IACpG,0FAA0F;IAC1F,qFAAqF;IACrF,cAAc;IACd,mCAAmC;IACnC,yBAAyB;IACzB,wCAAwC;IACxC,2EAA2E;IAC3E,4EAA4E;IAC5E,6CAA6C;IAC7C,gCAAgC;IAChC,uBAAuB;IACvB,cAAc;IACd,kCAAkC;IAClC,aAAa;IACb,8BAA8B;IAC9B,gDAAgD;IAChD,6CAA6C;IAC7C,4BAA4B;IAC5B,IAAI,CAAC,MAAM,GAAG,EAAE;IAEhB,eAAe,GACf,IAAI,OAAO,QAAQ,CAAC,MAAM;QACxB,IAAI,CAAC,KAAK,GAAG,UAAU,MAAM,CAAC,UAAU;IAC1C,OAAO,IAAI,MAAM,OAAO,CAAC,MAAM;QAC7B,IAAI,CAAC,KAAK,GAAG,IAAI,KAAK;IACxB,OAAO,IAAI,OAAO,QAAQ,UAAU;QAClC,IAAI,CAAC,KAAK,GAAG,UAAU,MAAM,CAAC,UAAU;IAC1C,OAAO;QACL,MAAM,IAAI,MAAM,GAAG,aAAa,4DAA4D,CAAC;IAC/F;IACA,IAAI,CAAC,KAAK,GAAG,UAAU,MAAM,CAAC,UAAU,IAAI,CAAC,KAAK;IAElD,8BAA8B,GAC9B,8FAA8F;IAC9F,4FAA4F;IAC5F,yGAAyG;IACzG,iGAAiG;IACjG,IAAI,CAAC,IAAI,GAAG,SAAS,KAAK,MAAM,EAAE,KAAK;QACrC,IAAI,CAAC,KAAK,GAAG,QAAQ,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,EAAE,QAAQ;QACtD,YAAY;IACd;IACA,oDAAoD;IACpD,wIAAwI;IACxI,qFAAqF;IACrF,sFAAsF;IACtF,EAAE;IACF,sEAAsE;IACtE,mHAAmH;IACnH,IAAI,CAAC,KAAK,GAAG,SAAS,MAAM,MAAM,EAAE,IAAI,EAAE,KAAK;QAC7C,IAAI,CAAC,WAAW;YACd,MAAM,IAAI,MAAM,GAAG,aAAa,mBAAmB,CAAC;QACtD;QACA,OAAO,MAAM,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,EAAE,QAAQ,MAAM;QACjE,WAAW;IACb;IACA,mGAAmG;IACnG,IAAI,CAAC,SAAS,GAAG,SAAS;QACxB,IAAI,CAAC,UAAU;YACb,MAAM,IAAI,MAAM,GAAG,aAAa,8BAA8B,CAAC;QACjE;QACA,MAAM,MAAM,OAAO,QAAQ,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM;QAC/D,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,KAAK,GAAG;YAC5B,IAAI,CAAC,KAAK,GAAG,IAAI,KAAK;YACtB,IAAI,CAAC,IAAI,GAAG,IAAI,IAAI;YACpB,UAAU,IAAI,OAAO;YACrB,eAAe;QACjB;IACF;IACA,uCAAuC;IACvC,IAAI,CAAC,UAAU,GAAG,SAAS;QACzB,IAAI,CAAC,cAAc;YACjB,MAAM,IAAI,MAAM,GAAG,aAAa,0CAA0C,CAAC;QAC7E;QACA,kBAAkB,WAAW,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,IAAI,EAAE,SAAS,IAAI,CAAC,MAAM;QACxE,iBAAiB;QACjB,OAAO;IACT;IACA,kGAAkG;IAClG,gCAAgC;IAChC,IAAI,CAAC,QAAQ,GAAG,SAAS,SAAS,MAAM;QACtC,IAAI,CAAC,KAAK,GAAG,QAAQ,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,EAAE;QAC9C,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE;YACtB;QACF;QACA,OAAO,MAAM,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM,EAAE;QACnD,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE;YACtB;QACF;QACA,MAAM,MAAM,OAAO,QAAQ,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,MAAM;QAC/D,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,EAAE;YACtB;QACF;QACA,IAAI,CAAC,KAAK,GAAG,IAAI,KAAK;QACtB,IAAI,CAAC,IAAI,GAAG,IAAI,IAAI;QACpB,UAAU,IAAI,OAAO;QAErB,kBAAkB,WAAW,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,IAAI,EAAE,SAAS,IAAI,CAAC,MAAM;QACxE,iBAAiB;IACnB;IACA,qBAAqB;IACrB,wGAAwG;IACxG,UAAU;IACV,+CAA+C;IAC/C,4CAA4C;IAC5C,8CAA8C;IAC9C,IAAI,CAAC,YAAY,GAAG,SAAS,aAAa,QAAQ,OAAO;QACvD,IAAI,CAAC,cAAc;YACjB,MAAM,IAAI,MAAM,GAAG,aAAa,0CAA0C,CAAC;QAC7E;QACA,OAAO,UAAU,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,IAAI,EAAE;IAC1C;IACA,iCAAiC;IACjC,mFAAmF;IACnF,iDAAiD;IACjD,UAAU;IACV,+CAA+C;IAC/C,4CAA4C;IAC5C,8EAA8E;IAC9E,8CAA8C;IAC9C,IAAI,CAAC,uBAAuB,GAAG,SAAS,wBAAwB,QAAQ,OAAO;QAC7E,IAAI,CAAC,gBAAgB;YACnB,MAAM,IAAI,MAAM,GAAG,aAAa,yDAAyD,CAAC;QAC5F;QACA,OAAO,qBAAqB;IAC9B;IACA,0BAA0B;IAC1B,mFAAmF;IACnF,UAAU;IACV,+CAA+C;IAC/C,4CAA4C;IAC5C,8EAA8E;IAC9E,6CAA6C;IAC7C,IAAI,CAAC,iBAAiB,GAAG,SAAS,kBAAkB,QAAQ,OAAO;QACjE,IAAI,CAAC,gBAAgB;YACnB,MAAM,IAAI,MAAM,GAAG,aAAa,yDAAyD,CAAC;QAC5F;QACA,IAAI,iBAAiB;YACnB,oBAAoB;QACtB;QACA,OAAO,eAAe;IACxB;IACA,IAAI,CAAC,sBAAsB,GAAG,SAAS;QACrC,IAAI,CAAC,gBAAgB;YACnB,MAAM,IAAI,MAAM,GAAG,aAAa,yDAAyD,CAAC;QAC5F;QACA,OAAO;IACT;IACA,+EAA+E;IAC/E,sDAAsD;IACtD,IAAI,CAAC,QAAQ,GAAG,SAAS,SAAS,SAAS,SAAS;QAClD,IAAI,CAAC,gBAAgB;YACnB,MAAM,IAAI,MAAM,GAAG,aAAa,wEAAwE,CAAC;QAC3G;QACA,IAAI,iBAAiB;YACnB,MAAM,IAAI,MAAM,GAAG,aAAa,+CAA+C,EAAE,gBAAgB,OAAO,CAAC;QAC3G;QACA,OAAO,OAAO,cAAc,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,IAAI,EAAE;IAC9E;IACA,mCAAmC;IACnC,4EAA4E;IAC5E,IAAI,CAAC,QAAQ,GAAG,SAAS;QACvB,IAAI,CAAC,gBAAgB;YACnB,MAAM,IAAI,MAAM,GAAG,aAAa,wEAAwE,CAAC;QAC3G;QACA,IAAI,iBAAiB;YACnB,MAAM,IAAI,MAAM,GAAG,aAAa,+CAA+C,EAAE,gBAAgB,OAAO,CAAC;QAC3G;QACA,OAAO,OAAO,cAAc,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,IAAI;IAChE;IACA,+DAA+D;IAC/D,IAAI,CAAC,aAAa,GAAG,SAAS;QAC5B,OAAO,cAAc,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK;IAC1D;IACA,gEAAgE;IAChE,8CAA8C;IAC9C,IAAI,CAAC,YAAY,GAAG,SAAS,iBAAiB,KAAK;QACjD,OAAO,aAAa,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,KAAK,EAAE;IAC3D;IACA,kEAAkE;IAClE,IAAI,CAAC,YAAY,GAAG,SAAS;QAC3B,OAAO,aAAa,IAAI,CAAC,KAAK;IAChC;IACA,kEAAkE;IAClE,8CAA8C;IAC9C,IAAI,CAAC,WAAW,GAAG,SAAS;QAC1B,OAAO,YAAY,IAAI,CAAC,KAAK;IAC/B;AACA,oEAAoE;AACpE;;;;IAIE,GACJ","ignoreList":[0]}}]
}