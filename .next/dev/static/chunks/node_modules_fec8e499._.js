(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * @license React
 * react-jsx-dev-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
"use strict";
"production" !== ("TURBOPACK compile-time value", "development") && function() {
    function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type) return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch(type){
            case REACT_FRAGMENT_TYPE:
                return "Fragment";
            case REACT_PROFILER_TYPE:
                return "Profiler";
            case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
            case REACT_SUSPENSE_TYPE:
                return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            case REACT_ACTIVITY_TYPE:
                return "Activity";
            case REACT_VIEW_TRANSITION_TYPE:
                return "ViewTransition";
        }
        if ("object" === typeof type) switch("number" === typeof type.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), type.$$typeof){
            case REACT_PORTAL_TYPE:
                return "Portal";
            case REACT_CONTEXT_TYPE:
                return type.displayName || "Context";
            case REACT_CONSUMER_TYPE:
                return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
                var innerType = type.render;
                type = type.displayName;
                type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
                return type;
            case REACT_MEMO_TYPE:
                return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
                innerType = type._payload;
                type = type._init;
                try {
                    return getComponentNameFromType(type(innerType));
                } catch (x) {}
        }
        return null;
    }
    function testStringCoercion(value) {
        return "" + value;
    }
    function checkKeyStringCoercion(value) {
        try {
            testStringCoercion(value);
            var JSCompiler_inline_result = !1;
        } catch (e) {
            JSCompiler_inline_result = !0;
        }
        if (JSCompiler_inline_result) {
            JSCompiler_inline_result = console;
            var JSCompiler_temp_const = JSCompiler_inline_result.error;
            var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
            JSCompiler_temp_const.call(JSCompiler_inline_result, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", JSCompiler_inline_result$jscomp$0);
            return testStringCoercion(value);
        }
    }
    function getTaskName(type) {
        if (type === REACT_FRAGMENT_TYPE) return "<>";
        if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE) return "<...>";
        try {
            var name = getComponentNameFromType(type);
            return name ? "<" + name + ">" : "<...>";
        } catch (x) {
            return "<...>";
        }
    }
    function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
    }
    function UnknownOwner() {
        return Error("react-stack-top-frame");
    }
    function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) return !1;
        }
        return void 0 !== config.key;
    }
    function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
            specialPropKeyWarningShown || (specialPropKeyWarningShown = !0, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", displayName));
        }
        warnAboutAccessingKey.isReactWarning = !0;
        Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: !0
        });
    }
    function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = !0, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
    }
    function ReactElement(type, key, props, owner, debugStack, debugTask) {
        var refProp = props.ref;
        type = {
            $$typeof: REACT_ELEMENT_TYPE,
            type: type,
            key: key,
            props: props,
            _owner: owner
        };
        null !== (void 0 !== refProp ? refProp : null) ? Object.defineProperty(type, "ref", {
            enumerable: !1,
            get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", {
            enumerable: !1,
            value: null
        });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: null
        });
        Object.defineProperty(type, "_debugStack", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugStack
        });
        Object.defineProperty(type, "_debugTask", {
            configurable: !1,
            enumerable: !1,
            writable: !0,
            value: debugTask
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
    }
    function jsxDEVImpl(type, config, maybeKey, isStaticChildren, debugStack, debugTask) {
        var children = config.children;
        if (void 0 !== children) if (isStaticChildren) if (isArrayImpl(children)) {
            for(isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)validateChildKeys(children[isStaticChildren]);
            Object.freeze && Object.freeze(children);
        } else console.error("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
        else validateChildKeys(children);
        if (hasOwnProperty.call(config, "key")) {
            children = getComponentNameFromType(type);
            var keys = Object.keys(config).filter(function(k) {
                return "key" !== k;
            });
            isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
            didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error('A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />', isStaticChildren, children, keys, children), didWarnAboutKeySpread[children + isStaticChildren] = !0);
        }
        children = null;
        void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
        hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
        if ("key" in config) {
            maybeKey = {};
            for(var propName in config)"key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        children && defineKeyPropWarningGetter(maybeKey, "function" === typeof type ? type.displayName || type.name || "Unknown" : type);
        return ReactElement(type, children, maybeKey, getOwner(), debugStack, debugTask);
    }
    function validateChildKeys(node) {
        isValidElement(node) ? node._store && (node._store.validated = 1) : "object" === typeof node && null !== node && node.$$typeof === REACT_LAZY_TYPE && ("fulfilled" === node._payload.status ? isValidElement(node._payload.value) && node._payload.value._store && (node._payload.value._store.validated = 1) : node._store && (node._store.validated = 1));
    }
    function isValidElement(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    var React = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
        return null;
    };
    React = {
        react_stack_bottom_frame: function(callStackForError) {
            return callStackForError();
        }
    };
    var specialPropKeyWarningShown;
    var didWarnAboutElementRef = {};
    var unknownOwnerDebugStack = React.react_stack_bottom_frame.bind(React, UnknownOwner)();
    var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
    var didWarnAboutKeySpread = {};
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.jsxDEV = function(type, config, maybeKey, isStaticChildren) {
        var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        if (trackActualOwner) {
            var previousStackTraceLimit = Error.stackTraceLimit;
            Error.stackTraceLimit = 10;
            var debugStackDEV = Error("react-stack-top-frame");
            Error.stackTraceLimit = previousStackTraceLimit;
        } else debugStackDEV = unknownOwnerDebugStack;
        return jsxDEVImpl(type, config, maybeKey, isStaticChildren, debugStackDEV, trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask);
    };
}();
}),
"[project]/node_modules/next/dist/compiled/react/jsx-dev-runtime.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = /*#__PURE__*/ __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) //TURBOPACK unreachable
;
else {
    module.exports = __turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js [app-client] (ecmascript)");
}
}),
"[project]/node_modules/@ucanto/interface/src/lib.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
}),
"[project]/node_modules/@ipld/dag-ucan/src/ucan.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
}),
"[project]/node_modules/@ipld/dag-ucan/src/utf8.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "decode",
    ()=>decode,
    "decoder",
    ()=>decoder,
    "encode",
    ()=>encode,
    "encoder",
    ()=>encoder
]);
const encoder = new TextEncoder();
const decoder = new TextDecoder();
const encode = (text)=>encoder.encode(text);
const decode = (bytes)=>decoder.decode(bytes);
}),
"[project]/node_modules/@ipld/dag-ucan/src/did.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BLS12381G1",
    ()=>BLS12381G1,
    "BLS12381G2",
    ()=>BLS12381G2,
    "DID_CORE",
    ()=>DID_CORE,
    "ED25519",
    ()=>ED25519,
    "P256",
    ()=>P256,
    "P384",
    ()=>P384,
    "P521",
    ()=>P521,
    "RSA",
    ()=>RSA,
    "SECP256K1",
    ()=>SECP256K1,
    "decode",
    ()=>decode,
    "encode",
    ()=>encode,
    "format",
    ()=>format,
    "from",
    ()=>from,
    "parse",
    ()=>parse
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$ucan$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/ucan.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base58.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/varint.js [app-client] (ecmascript) <export * as varint>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/utf8.js [app-client] (ecmascript)");
;
;
;
;
const DID_PREFIX = "did:";
const DID_PREFIX_SIZE = DID_PREFIX.length;
const DID_KEY_PREFIX = `did:key:`;
const DID_KEY_PREFIX_SIZE = DID_KEY_PREFIX.length;
const ED25519 = 0xed;
const RSA = 0x1205;
const P256 = 0x1200;
const P384 = 0x1201;
const P521 = 0x1202;
const SECP256K1 = 0xe7;
const BLS12381G1 = 0xea;
const BLS12381G2 = 0xeb;
const DID_CORE = 0x0d1d;
const METHOD_OFFSET = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(DID_CORE);
const parse = (did)=>{
    if (!did.startsWith(DID_PREFIX)) {
        throw new RangeError(`Invalid DID "${did}", must start with 'did:'`);
    } else if (did.startsWith(DID_KEY_PREFIX)) {
        const key = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base58btc"].decode(did.slice(DID_KEY_PREFIX_SIZE));
        return decode(key);
    } else {
        const suffix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"](did.slice(DID_PREFIX_SIZE));
        const bytes = new Uint8Array(suffix.byteLength + METHOD_OFFSET);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodeTo(DID_CORE, bytes);
        bytes.set(suffix, METHOD_OFFSET);
        return new DID(bytes);
    }
};
const format = (id)=>id.did();
const from = (principal)=>{
    if (principal instanceof DID) {
        return principal;
    } else if (principal instanceof Uint8Array) {
        return decode(principal);
    } else if (typeof principal === "string") {
        return parse(principal);
    } else {
        return parse(principal.did());
    }
};
const decode = (bytes)=>{
    const [code] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].decode(bytes);
    const { buffer, byteOffset, byteLength } = bytes;
    switch(code){
        case P256:
            if (bytes.length > 35) {
                throw new RangeError(`Only p256-pub compressed is supported.`);
            }
        case ED25519:
        case RSA:
        case P384:
        case P521:
        case BLS12381G1:
        case BLS12381G2:
        case SECP256K1:
            return new DIDKey(buffer, byteOffset, byteLength);
        case DID_CORE:
            return new DID(buffer, byteOffset, byteLength);
        default:
            throw new RangeError(`Unsupported DID encoding, unknown multicode 0x${code.toString(16)}.`);
    }
};
const encode = (principal)=>parse(principal.did());
/**
 * @template {UCAN.DID} ID
 * @implements {UCAN.PrincipalView<ID>}
 * @extends {Uint8Array}
 */ class DID extends Uint8Array {
    /**
   * @returns {ID}
   */ did() {
        const bytes = new Uint8Array(this.buffer, this.byteOffset + METHOD_OFFSET);
        return `did:${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](bytes)}`;
    }
    toJSON() {
        return this.did();
    }
}
/**
 * @implements {UCAN.PrincipalView<UCAN.DID<"key">>}
 * @extends {DID<UCAN.DID<"key">>}
 */ class DIDKey extends DID {
    /**
   * @return {`did:key:${string}`}
   */ did() {
        return `did:key:${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base58btc"].encode(this)}`;
    }
}
}),
"[project]/node_modules/@ipld/dag-ucan/src/signature.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BLS12381G1",
    ()=>BLS12381G1,
    "BLS12381G2",
    ()=>BLS12381G2,
    "EIP191",
    ()=>EIP191,
    "ES256",
    ()=>ES256,
    "ES256K",
    ()=>ES256K,
    "ES384",
    ()=>ES384,
    "ES512",
    ()=>ES512,
    "EdDSA",
    ()=>EdDSA,
    "NON_STANDARD",
    ()=>NON_STANDARD,
    "RS256",
    ()=>RS256,
    "Signature",
    ()=>Signature,
    "create",
    ()=>create,
    "createNamed",
    ()=>createNamed,
    "createNonStandard",
    ()=>createNonStandard,
    "decode",
    ()=>decode,
    "encode",
    ()=>encode,
    "format",
    ()=>format,
    "fromJSON",
    ()=>fromJSON,
    "nameCode",
    ()=>nameCode,
    "parse",
    ()=>parse,
    "toJSON",
    ()=>toJSON,
    "view",
    ()=>view
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$ucan$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/ucan.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/varint.js [app-client] (ecmascript) <export * as varint>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base64.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/utf8.js [app-client] (ecmascript)");
;
;
;
;
const NON_STANDARD = 0xd000;
const ES256K = 0xd0e7;
const BLS12381G1 = 0xd0ea;
const BLS12381G2 = 0xd0eb;
const EdDSA = 0xd0ed;
const ES256 = 0xd01200;
const ES384 = 0xd01201;
const ES512 = 0xd01202;
const RS256 = 0xd01205;
const EIP191 = 0xd191;
/**
 * @param {number} code
 * @returns {string}
 */ const codeName = (code)=>{
    switch(code){
        case ES256K:
            return "ES256K";
        case BLS12381G1:
            return "BLS12381G1";
        case BLS12381G2:
            return "BLS12381G2";
        case EdDSA:
            return "EdDSA";
        case ES256:
            return "ES256";
        case ES384:
            return "ES384";
        case ES512:
            return "ES512";
        case RS256:
            return "RS256";
        case EIP191:
            return "EIP191";
        default:
            throw new RangeError(`Unknown signature algorithm code 0x${code.toString(16)}`);
    }
};
const nameCode = (name)=>{
    switch(name){
        case "ES256K":
            return ES256K;
        case "BLS12381G1":
            return BLS12381G1;
        case "BLS12381G2":
            return BLS12381G2;
        case "EdDSA":
            return EdDSA;
        case "ES256":
            return ES256;
        case "ES384":
            return ES384;
        case "ES512":
            return ES512;
        case "RS256":
            return RS256;
        case "EIP191":
            return EIP191;
        default:
            return NON_STANDARD;
    }
};
class Signature extends Uint8Array {
    get code() {
        const [code] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].decode(this);
        Object.defineProperties(this, {
            code: {
                value: code
            }
        });
        return code;
    }
    get size() {
        const value = size(this);
        Object.defineProperties(this, {
            size: {
                value
            }
        });
        return value;
    }
    get algorithm() {
        const value = algorithm(this);
        Object.defineProperties(this, {
            algorithm: {
                value
            }
        });
        return value;
    }
    get raw() {
        const { buffer, byteOffset, size, code } = this;
        const codeSize = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(code);
        const rawSize = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(size);
        const value = new Uint8Array(buffer, byteOffset + codeSize + rawSize, size);
        Object.defineProperties(this, {
            raw: {
                value
            }
        });
        return value;
    }
    /**
   * Verify that this signature was created by the given key.
   *
   * @param {UCAN.Crypto.Verifier<A>} signer
   * @param {UCAN.ByteView<T>} payload
   */ async verify(signer, payload) {
        try {
            if (await signer.verify(payload, this) === true) {
                return {
                    ok: {}
                };
            } else {
                throw new Error("Invalid signature");
            }
        } catch (cause) {
            return {
                error: cause
            };
        }
    }
    toJSON() {
        return toJSON(this);
    }
}
/**
 * @param {UCAN.Signature} signature
 */ const algorithm = (signature)=>{
    const { code, raw, buffer, byteOffset } = signature;
    if (code === NON_STANDARD) {
        const offset = raw.byteLength + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(code) + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(raw.byteLength);
        const bytes = new Uint8Array(buffer, byteOffset + offset);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](bytes);
    } else {
        return codeName(code);
    }
};
/**
 * @param {UCAN.Signature} signature
 */ const size = (signature)=>{
    const offset = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(signature.code);
    const [size] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].decode(new Uint8Array(signature.buffer, signature.byteOffset + offset));
    return size;
};
const create = (code, raw)=>{
    const _ = codeName(code);
    const codeSize = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(code);
    const rawSize = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(raw.byteLength);
    /** @type {Signature<T, A>} */ const signature = new Signature(codeSize + rawSize + raw.byteLength);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodeTo(code, signature);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodeTo(raw.byteLength, signature, codeSize);
    signature.set(raw, codeSize + rawSize);
    Object.defineProperties(signature, {
        code: {
            value: code
        },
        size: {
            value: raw.byteLength
        }
    });
    return signature;
};
const createNamed = (name, raw)=>{
    const code = nameCode(name);
    return code === NON_STANDARD ? createNonStandard(name, raw) : create(code, raw);
};
const createNonStandard = (name, raw)=>{
    const code = NON_STANDARD;
    const codeSize = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(code);
    const rawSize = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(raw.byteLength);
    const nameBytes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"](name);
    /** @type {Signature<T, typeof NON_STANDARD>} */ const signature = new Signature(codeSize + rawSize + raw.byteLength + nameBytes.byteLength);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodeTo(code, signature);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodeTo(raw.byteLength, signature, codeSize);
    signature.set(raw, codeSize + rawSize);
    signature.set(nameBytes, codeSize + rawSize + raw.byteLength);
    return signature;
};
const view = (bytes)=>new Signature(bytes.buffer, bytes.byteOffset, bytes.byteLength);
const decode = (bytes)=>{
    if (!(bytes instanceof Uint8Array)) {
        throw new TypeError(`Can only decode Uint8Array into a Signature, instead got ${JSON.stringify(bytes)}`);
    }
    /** @type {UCAN.SignatureView<T, A>} */ const signature = view(bytes);
    const { code, algorithm, raw } = signature;
    return signature;
};
const encode = (signature)=>decode(signature);
const format = (signature, base)=>(base || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64url"]).encode(signature);
const parse = (signature, base)=>decode((base || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64url"]).decode(signature));
const toJSON = (signature)=>({
        "/": {
            bytes: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64"].baseEncode(signature)
        }
    });
const fromJSON = (json)=>decode(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64"].baseDecode(json["/"].bytes));
}),
"[project]/node_modules/@ipld/dag-ucan/src/schema.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ParseError",
    ()=>ParseError,
    "asCapability",
    ()=>asCapability,
    "fail",
    ()=>fail,
    "readArray",
    ()=>readArray,
    "readBytes",
    ()=>readBytes,
    "readCapabilities",
    ()=>readCapabilities,
    "readCapability",
    ()=>readCapability,
    "readFact",
    ()=>readFact,
    "readInt",
    ()=>readInt,
    "readJWTPayload",
    ()=>readJWTPayload,
    "readLiteral",
    ()=>readLiteral,
    "readNullable",
    ()=>readNullable,
    "readOptional",
    ()=>readOptional,
    "readOptionalArray",
    ()=>readOptionalArray,
    "readPayload",
    ()=>readPayload,
    "readPrincipal",
    ()=>readPrincipal,
    "readProof",
    ()=>readProof,
    "readSignature",
    ()=>readSignature,
    "readString",
    ()=>readString,
    "readStringPrincipal",
    ()=>readStringPrincipal,
    "readStringProof",
    ()=>readStringProof,
    "readStruct",
    ()=>readStruct,
    "readVersion",
    ()=>readVersion,
    "throw",
    ()=>fail
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$ucan$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/ucan.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/utf8.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/link.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$identity$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/hashes/identity.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/did.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$codecs$2f$raw$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/codecs/raw.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$signature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/signature.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
const readPayload = (data)=>readPayloadWith(data, {
        readPrincipal,
        readProof
    });
const readJWTPayload = (data)=>readPayloadWith(data, {
        readPrincipal: readStringPrincipal,
        readProof: readStringProof
    });
/**
 *
 * @template {UCAN.Capabilities} C
 * @param {Record<string, unknown>|UCAN.Payload<C>} data
 * @param {object} readers
 * @param {(source:unknown, context:string) => UCAN.Principal} readers.readPrincipal
 * @param {(source:unknown, context:string) => UCAN.Link} readers.readProof
 * @returns {UCAN.Payload<C>}
 */ const readPayloadWith = (data, { readPrincipal, readProof })=>({
        iss: readPrincipal(data.iss, "iss"),
        aud: readPrincipal(data.aud, "aud"),
        att: readCapabilities(data.att, "att"),
        prf: readOptionalArray(data.prf, readProof, "prf") || [],
        exp: readNullable(data.exp === Infinity ? null : data.exp, readInt, "exp"),
        nbf: readOptional(data.nbf, readInt, "nbf"),
        fct: readOptionalArray(data.fct, readFact, "fct") || [],
        nnc: readOptional(data.nnc, readString, "nnc")
    });
const readSignature = (source)=>{
    if (source instanceof Uint8Array) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$signature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](source);
    } else {
        throw new TypeError(`Can only decode Uint8Array into a Signature, instead got ${JSON.stringify(source)}`);
    }
};
const readInt = (input, name)=>Number.isInteger(input) ? input : ParseError.throw(`Expected ${name} to be integer, instead got ${JSON.stringify(input)}`);
const readCapability = (input, context)=>readStruct(input, asCapability, context);
const readCapabilities = (input, context)=>readArray(input, readCapability, context);
const asCapability = (input)=>/** @type {C} */ ({
        ...input,
        can: readAbility(input.can),
        with: readResource(input.with)
    });
/**
 * @param {unknown} input
 */ const readAbility = (input)=>typeof input !== "string" ? ParseError.throw(`Capability has invalid 'can: ${JSON.stringify(input)}', value must be a string`) : input.slice(1, -1).includes("/") ? input.toLocaleLowerCase() : input === "*" ? input : ParseError.throw(`Capability has invalid 'can: "${input}"', value must have at least one path segment`);
/**
 * @param {unknown} input
 */ const readResource = (input)=>typeof input !== "string" ? ParseError.throw(`Capability has invalid 'with: ${JSON.stringify(input)}', value must be a string`) : parseURL(input) || ParseError.throw(`Capability has invalid 'with: "${input}"', value must be a valid URI string`);
/**
 * @param {string} input
 */ const parseURL = (input)=>{
    try {
        new URL(input);
        return input;
    } catch (_) {
        return null;
    }
};
const readArray = (input, read, context)=>Array.isArray(input) ? input.map((element, n)=>read(element, `${context}[${n}]`)) : ParseError.throw(`${context} must be an array`);
const readOptionalArray = (input, reader, context)=>input === undefined ? input : readArray(input, reader, context);
const readStruct = (input, reader, context)=>input != null && typeof input === "object" ? reader(input) : ParseError.throw(`${context} must be of type object, instead got ${input}`);
const readFact = (input, context)=>readStruct(input, Object, context);
const readProof = (source, context)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isLink"](source) ? source : fail(`Expected ${context} to be IPLD link, instead got ${JSON.stringify(source)}`);
const readStringProof = (source, context)=>parseProof(readString(source, context));
/**
 * @param {string} source
 * @returns {UCAN.Link}
 */ const parseProof = (source)=>{
    // First we attempt to read proof as CID, if we fail fallback to reading it as
    // an inline proof.
    try {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["parse"](source);
    } catch (error) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["create"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$codecs$2f$raw$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["code"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$identity$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["identity"].digest(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"](source)));
    }
};
const readPrincipal = (input, context)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](readBytes(input, context));
const readStringPrincipal = (source, context)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parse"](readString(source, context));
const readOptional = (source, read, context = "Field")=>source !== undefined ? read(source, context) : undefined;
const readNullable = (source, read, context)=>source === null ? null : read(source, context);
const readString = (source, context = "Field")=>typeof source === "string" ? source : fail(`${context} has invalid value ${source}`);
const readBytes = (source, context)=>source instanceof Uint8Array ? source : fail(`Expected ${context} to be Uint8Array, instead got ${JSON.stringify(source)}`);
const readVersion = (input, context)=>/\d+\.\d+\.\d+/.test(input) ? input : ParseError.throw(`Invalid version '${context}: ${JSON.stringify(input)}'`);
const readLiteral = (input, literal, context)=>input === literal ? literal : ParseError.throw(`Expected ${context} to be a ${JSON.stringify(literal)} instead got ${JSON.stringify(input)}`);
class ParseError extends TypeError {
    get name() {
        return "ParseError";
    }
    /**
   * @param {string} message
   * @returns {never}
   */ static throw(message) {
        throw new this(message);
    }
}
const fail = (reason)=>ParseError.throw(reason);
;
}),
"[project]/node_modules/@ipld/dag-ucan/src/formatter.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "format",
    ()=>format,
    "formatHeader",
    ()=>formatHeader,
    "formatPayload",
    ()=>formatPayload,
    "formatSignPayload",
    ()=>formatSignPayload,
    "formatSignature",
    ()=>formatSignature
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$ucan$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/ucan.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/did.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$json$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-json/src/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base64.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$signature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/signature.js [app-client] (ecmascript)");
;
;
;
;
;
const format = (model)=>{
    const header = formatHeader(model.v, model.s.algorithm);
    const payload = formatPayload(model);
    const signature = formatSignature(model.s);
    return `${header}.${payload}.${signature}`;
};
const formatSignPayload = (payload, version, alg)=>`${formatHeader(version, alg)}.${formatPayload(payload)}`;
const formatHeader = (version, alg)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64url"].baseEncode(encodeHeader(version, alg));
const formatPayload = (data)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64url"].baseEncode(encodePayload(data));
const formatSignature = (signature)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64url"].baseEncode(signature.raw);
/**
 * @param {UCAN.Version} v
 * @param {string} alg
 * @returns {UCAN.ByteView<UCAN.JWTHeader>}
 */ const encodeHeader = (v, alg)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$json$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"]({
        alg,
        ucv: v,
        typ: "JWT"
    });
/**
 * @template {UCAN.Capabilities} C
 * @param {UCAN.Payload<C>} data
 * @returns {UCAN.ByteView<UCAN.JWTPayload<C>>}
 */ const encodePayload = (data)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$json$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"]({
        iss: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["format"](data.iss),
        aud: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["format"](data.aud),
        att: data.att,
        exp: data.exp,
        prf: data.prf.map(encodeProof),
        // leave out optionals and empty fields
        ...data.fct.length > 0 && {
            fct: data.fct
        },
        ...data.nnc && {
            nnc: data.nnc
        },
        ...data.nbf && {
            nbf: data.nbf
        }
    });
/**
 * @param {UCAN.Link} proof
 * @returns {UCAN.ToString<UCAN.Link>}
 */ const encodeProof = (proof)=>proof.toString();
}),
"[project]/node_modules/@ipld/dag-ucan/src/view.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "View",
    ()=>View
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$ucan$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/ucan.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/did.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$json$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-json/src/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/utf8.js [app-client] (ecmascript)");
;
;
;
;
/**
 * @param {unknown} data
 */ const toJSON = (data)=>JSON.parse((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$json$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"])(data)));
class View {
    /**
   * @param {UCAN.UCAN<C>} model
   */ constructor(model){
        /** @readonly */ this.model = model;
    }
    get version() {
        return this.model.v;
    }
    get issuer() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"](this.model.iss);
    }
    get audience() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"](this.model.aud);
    }
    /**
   * @returns {C}
   */ get capabilities() {
        return this.model.att;
    }
    /**
   * @returns {number}
   */ get expiration() {
        const { exp } = this.model;
        return exp === null ? Infinity : exp;
    }
    /**
   * @returns {undefined|number}
   */ get notBefore() {
        return this.model.nbf;
    }
    /**
   * @returns {undefined|string}
   */ get nonce() {
        return this.model.nnc;
    }
    /**
   * @returns {UCAN.Fact[]}
   */ get facts() {
        return this.model.fct;
    }
    /**
   * @returns {UCAN.Link[]}
   */ get proofs() {
        return this.model.prf;
    }
    get signature() {
        return this.model.s;
    }
    // compatibility with UCAN.UCAN
    get jwt() {
        return this.model.jwt;
    }
    get s() {
        return this.model.s;
    }
    get v() {
        return this.model.v;
    }
    get iss() {
        return this.model.iss;
    }
    get aud() {
        return this.model.aud;
    }
    get att() {
        return this.model.att;
    }
    get exp() {
        return this.model.exp;
    }
    get nbf() {
        return this.model.nbf;
    }
    get nnc() {
        return this.model.nnc;
    }
    get fct() {
        return this.model.fct;
    }
    get prf() {
        return this.model.prf;
    }
    /**
   * @returns {UCAN.ToJSON<UCAN.UCAN<C>, UCAN.UCANJSON<this>>}
   */ toJSON() {
        const { v, iss, aud, s, att, prf, exp, fct, nnc, nbf } = this.model;
        return {
            iss,
            aud,
            v,
            s,
            exp,
            ...toJSON({
                att,
                prf,
                ...fct.length > 0 && {
                    fct
                }
            }),
            ...nnc != null && {
                nnc
            },
            ...nbf && {
                nbf
            }
        };
    }
}
}),
"[project]/node_modules/@ipld/dag-ucan/src/codec/cbor.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "code",
    ()=>code,
    "decode",
    ()=>decode,
    "encode",
    ()=>encode,
    "from",
    ()=>from,
    "name",
    ()=>name
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$ucan$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/ucan.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-cbor/src/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/schema.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$formatter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/formatter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$signature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/signature.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$view$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/view.js [app-client] (ecmascript)");
;
;
;
;
;
;
const name = "dag-ucan";
const code = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["code"];
const from = (model)=>new CBORView(model);
const encode = (model)=>{
    const { fct, nnc, nbf, ...payload } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readPayload"])(model);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"]({
        // leave out optionals unless they are set
        ...fct.length > 0 && {
            fct
        },
        ...nnc != null && {
            nnc
        },
        ...nbf && {
            nbf
        },
        ...payload,
        // add version and signature
        v: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVersion"])(model.v, "v"),
        s: encodeSignature(model.s, "s")
    });
};
/**
 * @param {UCAN.Signature} signature
 * @param {string} context
 */ const encodeSignature = (signature, context)=>{
    try {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$signature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"](signature);
    } catch (cause) {
        throw new Error(`Expected signature ${context}, instead got ${JSON.stringify(signature)}`, // @ts-expect-error - types don't know about second arg
        {
            cause
        });
    }
};
const decode = (bytes)=>{
    const model = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](bytes);
    return new CBORView({
        ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readPayload"])(model),
        v: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVersion"])(model.v, "v"),
        s: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readSignature"])(model.s)
    });
};
;
/**
 * @template {UCAN.Capabilities} C
 * @extends {View<C>}
 */ class CBORView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$view$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["View"] {
    /** @type {UCAN.MulticodecCode<typeof code, "CBOR">} */ get code() {
        return code;
    }
    format() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$formatter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["format"])(this.model);
    }
    encode() {
        return encode(this.model);
    }
}
}),
"[project]/node_modules/@ipld/dag-ucan/src/parser.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "parse",
    ()=>parse,
    "parseHeader",
    ()=>parseHeader,
    "parsePayload",
    ()=>parsePayload
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$ucan$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/ucan.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$json$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-json/src/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/schema.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base64.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$signature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/signature.js [app-client] (ecmascript)");
;
;
;
;
;
const parse = (jwt)=>{
    const segments = jwt.split(".");
    const [header, payload, signature] = segments.length === 3 ? segments : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["throw"](`Can't parse UCAN: ${jwt}: Expected JWT format: 3 dot-separated base64url-encoded values.`);
    const { ucv, alg } = parseHeader(header);
    return {
        ...parsePayload(payload),
        v: ucv,
        s: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$signature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createNamed"])(alg, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64url"].baseDecode(signature))
    };
};
const parseHeader = (header)=>{
    const { ucv, alg, typ } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$json$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64url"].baseDecode(header));
    return {
        typ: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readLiteral"](typ, "JWT", "typ"),
        ucv: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVersion"](ucv, "ucv"),
        alg: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readString"](alg, "alg")
    };
};
const parsePayload = (source)=>{
    /** @type {Record<string, unknown>} */ const payload = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$json$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64url"].baseDecode(source));
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readJWTPayload"](payload);
};
}),
"[project]/node_modules/@ipld/dag-ucan/src/codec/jwt.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "decode",
    ()=>decode,
    "encode",
    ()=>encode,
    "format",
    ()=>format,
    "from",
    ()=>from,
    "name",
    ()=>name
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$ucan$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/ucan.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/utf8.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/parser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$codecs$2f$raw$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/codecs/raw.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$view$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/view.js [app-client] (ecmascript)");
;
;
;
;
;
;
const name = "dag-ucan";
const from = (model)=>new JWTView(model);
const decode = (bytes)=>{
    const jwt = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](bytes);
    return new JWTView({
        ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parse"])(jwt),
        jwt
    });
};
const encode = ({ jwt })=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"](jwt);
const format = ({ jwt })=>jwt;
/**
 * @template {UCAN.Capabilities} C
 * @extends {View<C>}
 */ class JWTView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$view$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["View"] {
    /**
   * @param {UCAN.FromJWT<C>} model
   */ constructor(model){
        super(model);
        this.model = model;
    }
    /** @type {UCAN.MulticodecCode<typeof code, "Raw">} */ get code() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$codecs$2f$raw$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["code"];
    }
    format() {
        return format(this.model);
    }
    encode() {
        return encode(this.model);
    }
}
}),
"[project]/node_modules/@ipld/dag-ucan/src/lib.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "VERSION",
    ()=>VERSION,
    "code",
    ()=>code,
    "decode",
    ()=>decode,
    "encode",
    ()=>encode,
    "format",
    ()=>format,
    "isExpired",
    ()=>isExpired,
    "isTooEarly",
    ()=>isTooEarly,
    "issue",
    ()=>issue,
    "link",
    ()=>link,
    "name",
    ()=>name,
    "now",
    ()=>now,
    "parse",
    ()=>parse,
    "verifySignature",
    ()=>verifySignature,
    "write",
    ()=>write
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$ucan$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/ucan.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$cbor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/codec/cbor.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$formatter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/formatter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$jwt$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/codec/jwt.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$codecs$2f$raw$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/codecs/raw.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/utf8.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/schema.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/did.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/parser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$sha2$2d$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/hashes/sha2-browser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/link.js [app-client] (ecmascript) <locals>");
;
;
;
;
;
;
;
;
;
;
;
;
const VERSION = "0.9.1";
const name = "dag-ucan";
const code = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$cbor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["code"];
/**
 * We cast sha256 to workaround typescripts limited inference problem when using
 * sha256 as default. If hasher is omitted type `A` should match sha256.code
 * but TS fails to deduce that.
 * @type {UCAN.MultihashHasher<any>}
 */ const defaultHasher = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$sha2$2d$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sha256"];
const encode = (ucan)=>ucan.jwt ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$jwt$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encode"](ucan) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$cbor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encode"](ucan);
const decode = (bytes)=>{
    try {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$cbor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["decode"](bytes);
    } catch (_) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$jwt$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["decode"](bytes);
    }
};
const link = async (ucan, options)=>{
    const { cid } = await write(ucan, options);
    return cid;
};
const write = async (ucan, { hasher = defaultHasher } = {})=>{
    const [code, bytes] = ucan.jwt ? [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$codecs$2f$raw$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["code"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$jwt$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encode"](ucan)
    ] : [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$cbor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["code"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$cbor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encode"](ucan)
    ];
    const digest = await hasher.digest(bytes);
    return {
        bytes,
        cid: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["create"])(code, digest),
        data: ucan
    };
};
const parse = (jwt)=>{
    const model = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parse"])(jwt);
    // If formatting UCAN produces same jwt string we can use IPLD representation
    // otherwise we need to fallback to raw representation. This decision will
    // affect how we `encode` the UCAN.
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$formatter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["format"](model) === jwt ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$cbor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["from"](model) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$jwt$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["from"]({
        ...model,
        jwt: jwt
    });
};
const format = (ucan)=>ucan.jwt ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$jwt$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["format"](ucan) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$formatter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["format"](ucan);
const issue = async ({ issuer, audience, capabilities, lifetimeInSeconds = 30, expiration = now() + lifetimeInSeconds, notBefore, facts = [], proofs = [], nonce })=>{
    const v = VERSION;
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readPayload"])({
        iss: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parse"])(issuer.did()),
        aud: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parse"])(audience.did()),
        att: capabilities,
        fct: facts,
        exp: expiration,
        nbf: notBefore,
        prf: proofs,
        nnc: nonce
    });
    const payload = encodeSignaturePayload(data, v, issuer.signatureAlgorithm);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$cbor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["from"]({
        ...data,
        v,
        s: await issuer.sign(payload)
    });
};
/**
 *
 * @param {UCAN.Payload} payload
 * @param {UCAN.Version} version
 * @param {string} algorithm
 * @returns
 */ const encodeSignaturePayload = (payload, version, algorithm)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$formatter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["formatSignPayload"])(payload, version, algorithm));
const verifySignature = (ucan, verifier)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["format"])(ucan.issuer) === verifier.did() && verifier.verify(encodeSignaturePayload(ucan.model, ucan.model.v, ucan.signature.algorithm), ucan.signature);
const isExpired = (ucan)=>ucan.expiration <= now();
const isTooEarly = (ucan)=>ucan.notBefore != null && now() <= ucan.notBefore;
const now = ()=>Math.floor(Date.now() / 1000);
}),
"[project]/node_modules/@ipld/dag-ucan/src/signature.js [app-client] (ecmascript) <export * as Signature>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Signature",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$signature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$signature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/signature.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@ipld/dag-ucan/src/lib.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "VERSION",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["VERSION"],
    "code",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["code"],
    "decode",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["decode"],
    "encode",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encode"],
    "format",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["format"],
    "isExpired",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isExpired"],
    "isTooEarly",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isTooEarly"],
    "issue",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["issue"],
    "link",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["link"],
    "name",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["name"],
    "now",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["now"],
    "parse",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["parse"],
    "verifySignature",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["verifySignature"],
    "write",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["write"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/lib.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$ucan$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/ucan.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@ipld/dag-ucan/src/lib.js [app-client] (ecmascript) <export * as UCAN>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "UCAN",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/lib.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@ipld/dag-ucan/src/did.js [app-client] (ecmascript) <export * as DID>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DID",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/did.js [app-client] (ecmascript)");
}),
"[project]/node_modules/multiformats/dist/src/bytes.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "coerce",
    ()=>coerce,
    "empty",
    ()=>empty,
    "equals",
    ()=>equals,
    "fromHex",
    ()=>fromHex,
    "fromString",
    ()=>fromString,
    "isBinary",
    ()=>isBinary,
    "toHex",
    ()=>toHex,
    "toString",
    ()=>toString
]);
const empty = new Uint8Array(0);
function toHex(d) {
    return d.reduce((hex, byte)=>hex + byte.toString(16).padStart(2, '0'), '');
}
function fromHex(hex) {
    const hexes = hex.match(/../g);
    return hexes != null ? new Uint8Array(hexes.map((b)=>parseInt(b, 16))) : empty;
}
function equals(aa, bb) {
    if (aa === bb) {
        return true;
    }
    if (aa.byteLength !== bb.byteLength) {
        return false;
    }
    for(let ii = 0; ii < aa.byteLength; ii++){
        if (aa[ii] !== bb[ii]) {
            return false;
        }
    }
    return true;
}
function coerce(o) {
    if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') {
        return o;
    }
    if (o instanceof ArrayBuffer) {
        return new Uint8Array(o);
    }
    if (ArrayBuffer.isView(o)) {
        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
    }
    throw new Error('Unknown type, must be binary type');
}
function isBinary(o) {
    return o instanceof ArrayBuffer || ArrayBuffer.isView(o);
}
function fromString(str) {
    return new TextEncoder().encode(str);
}
function toString(b) {
    return new TextDecoder().decode(b);
} //# sourceMappingURL=bytes.js.map
}),
"[project]/node_modules/multiformats/dist/src/vendor/base-x.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* eslint-disable */ // base-x encoding / decoding
// Copyright (c) 2018 base-x contributors
// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)
// Distributed under the MIT software license, see the accompanying
// file LICENSE or http://www.opensource.org/licenses/mit-license.php.
/**
 * @param {string} ALPHABET
 * @param {any} name
 */ __turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
function base(ALPHABET, name) {
    if (ALPHABET.length >= 255) {
        throw new TypeError('Alphabet too long');
    }
    var BASE_MAP = new Uint8Array(256);
    for(var j = 0; j < BASE_MAP.length; j++){
        BASE_MAP[j] = 255;
    }
    for(var i = 0; i < ALPHABET.length; i++){
        var x = ALPHABET.charAt(i);
        var xc = x.charCodeAt(0);
        if (BASE_MAP[xc] !== 255) {
            throw new TypeError(x + ' is ambiguous');
        }
        BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up
    var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up
    /**
     * @param {any[] | Iterable<number>} source
     */ function encode(source) {
        // @ts-ignore
        if (source instanceof Uint8Array) ;
        else if (ArrayBuffer.isView(source)) {
            source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
        } else if (Array.isArray(source)) {
            source = Uint8Array.from(source);
        }
        if (!(source instanceof Uint8Array)) {
            throw new TypeError('Expected Uint8Array');
        }
        if (source.length === 0) {
            return '';
        }
        // Skip & count leading zeroes.
        var zeroes = 0;
        var length = 0;
        var pbegin = 0;
        var pend = source.length;
        while(pbegin !== pend && source[pbegin] === 0){
            pbegin++;
            zeroes++;
        }
        // Allocate enough space in big-endian base58 representation.
        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
        var b58 = new Uint8Array(size);
        // Process the bytes.
        while(pbegin !== pend){
            var carry = source[pbegin];
            // Apply "b58 = b58 * 256 + ch".
            var i = 0;
            for(var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++){
                carry += 256 * b58[it1] >>> 0;
                b58[it1] = carry % BASE >>> 0;
                carry = carry / BASE >>> 0;
            }
            if (carry !== 0) {
                throw new Error('Non-zero carry');
            }
            length = i;
            pbegin++;
        }
        // Skip leading zeroes in base58 result.
        var it2 = size - length;
        while(it2 !== size && b58[it2] === 0){
            it2++;
        }
        // Translate the result into a string.
        var str = LEADER.repeat(zeroes);
        for(; it2 < size; ++it2){
            str += ALPHABET.charAt(b58[it2]);
        }
        return str;
    }
    /**
     * @param {string | string[]} source
     */ function decodeUnsafe(source) {
        if (typeof source !== 'string') {
            throw new TypeError('Expected String');
        }
        if (source.length === 0) {
            return new Uint8Array();
        }
        var psz = 0;
        // Skip leading spaces.
        if (source[psz] === ' ') {
            return;
        }
        // Skip and count leading '1's.
        var zeroes = 0;
        var length = 0;
        while(source[psz] === LEADER){
            zeroes++;
            psz++;
        }
        // Allocate enough space in big-endian base256 representation.
        var size = (source.length - psz) * FACTOR + 1 >>> 0; // log(58) / log(256), rounded up.
        var b256 = new Uint8Array(size);
        // Process the characters.
        while(source[psz]){
            // Decode character
            var carry = BASE_MAP[source.charCodeAt(psz)];
            // Invalid character
            if (carry === 255) {
                return;
            }
            var i = 0;
            for(var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++){
                carry += BASE * b256[it3] >>> 0;
                b256[it3] = carry % 256 >>> 0;
                carry = carry / 256 >>> 0;
            }
            if (carry !== 0) {
                throw new Error('Non-zero carry');
            }
            length = i;
            psz++;
        }
        // Skip trailing spaces.
        if (source[psz] === ' ') {
            return;
        }
        // Skip leading zeroes in b256.
        var it4 = size - length;
        while(it4 !== size && b256[it4] === 0){
            it4++;
        }
        var vch = new Uint8Array(zeroes + (size - it4));
        var j = zeroes;
        while(it4 !== size){
            vch[j++] = b256[it4++];
        }
        return vch;
    }
    /**
     * @param {string | string[]} string
     */ function decode(string) {
        var buffer = decodeUnsafe(string);
        if (buffer) {
            return buffer;
        }
        throw new Error(`Non-${name} character`);
    }
    return {
        encode: encode,
        decodeUnsafe: decodeUnsafe,
        decode: decode
    };
}
var src = base;
var _brrp__multiformats_scope_baseX = src;
const __TURBOPACK__default__export__ = _brrp__multiformats_scope_baseX;
 //# sourceMappingURL=base-x.js.map
}),
"[project]/node_modules/multiformats/dist/src/bases/base.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Codec",
    ()=>Codec,
    "baseX",
    ()=>baseX,
    "from",
    ()=>from,
    "or",
    ()=>or,
    "rfc4648",
    ()=>rfc4648
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bytes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$vendor$2f$base$2d$x$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/vendor/base-x.js [app-client] (ecmascript)");
;
;
/**
 * Class represents both BaseEncoder and MultibaseEncoder meaning it
 * can be used to encode to multibase or base encode without multibase
 * prefix.
 */ class Encoder {
    name;
    prefix;
    baseEncode;
    constructor(name, prefix, baseEncode){
        this.name = name;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
    }
    encode(bytes) {
        if (bytes instanceof Uint8Array) {
            return `${this.prefix}${this.baseEncode(bytes)}`;
        } else {
            throw Error('Unknown type, must be binary type');
        }
    }
}
/**
 * Class represents both BaseDecoder and MultibaseDecoder so it could be used
 * to decode multibases (with matching prefix) or just base decode strings
 * with corresponding base encoding.
 */ class Decoder {
    name;
    prefix;
    baseDecode;
    prefixCodePoint;
    constructor(name, prefix, baseDecode){
        this.name = name;
        this.prefix = prefix;
        const prefixCodePoint = prefix.codePointAt(0);
        /* c8 ignore next 3 */ if (prefixCodePoint === undefined) {
            throw new Error('Invalid prefix character');
        }
        this.prefixCodePoint = prefixCodePoint;
        this.baseDecode = baseDecode;
    }
    decode(text) {
        if (typeof text === 'string') {
            if (text.codePointAt(0) !== this.prefixCodePoint) {
                throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            }
            return this.baseDecode(text.slice(this.prefix.length));
        } else {
            throw Error('Can only multibase decode strings');
        }
    }
    or(decoder) {
        return or(this, decoder);
    }
}
class ComposedDecoder {
    decoders;
    constructor(decoders){
        this.decoders = decoders;
    }
    or(decoder) {
        return or(this, decoder);
    }
    decode(input) {
        const prefix = input[0];
        const decoder = this.decoders[prefix];
        if (decoder != null) {
            return decoder.decode(input);
        } else {
            throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
    }
}
function or(left, right) {
    return new ComposedDecoder({
        ...left.decoders ?? {
            [left.prefix]: left
        },
        ...right.decoders ?? {
            [right.prefix]: right
        }
    });
}
class Codec {
    name;
    prefix;
    baseEncode;
    baseDecode;
    encoder;
    decoder;
    constructor(name, prefix, baseEncode, baseDecode){
        this.name = name;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder(name, prefix, baseEncode);
        this.decoder = new Decoder(name, prefix, baseDecode);
    }
    encode(input) {
        return this.encoder.encode(input);
    }
    decode(input) {
        return this.decoder.decode(input);
    }
}
function from({ name, prefix, encode, decode }) {
    return new Codec(name, prefix, encode, decode);
}
function baseX({ name, prefix, alphabet }) {
    const { encode, decode } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$vendor$2f$base$2d$x$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])(alphabet, name);
    return from({
        prefix,
        name,
        encode,
        decode: (text)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coerce"])(decode(text))
    });
}
function decode(string, alphabetIdx, bitsPerChar, name) {
    // Count the padding bytes:
    let end = string.length;
    while(string[end - 1] === '='){
        --end;
    }
    // Allocate the output:
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    // Parse the data:
    let bits = 0; // Number of bits currently in the buffer
    let buffer = 0; // Bits waiting to be written out, MSB first
    let written = 0; // Next byte to write
    for(let i = 0; i < end; ++i){
        // Read one character from the string:
        const value = alphabetIdx[string[i]];
        if (value === undefined) {
            throw new SyntaxError(`Non-${name} character`);
        }
        // Append the bits to the buffer:
        buffer = buffer << bitsPerChar | value;
        bits += bitsPerChar;
        // Write out some bits if the buffer has a byte's worth:
        if (bits >= 8) {
            bits -= 8;
            out[written++] = 0xff & buffer >> bits;
        }
    }
    // Verify that we have received just enough bits:
    if (bits >= bitsPerChar || (0xff & buffer << 8 - bits) !== 0) {
        throw new SyntaxError('Unexpected end of data');
    }
    return out;
}
function encode(data, alphabet, bitsPerChar) {
    const pad = alphabet[alphabet.length - 1] === '=';
    const mask = (1 << bitsPerChar) - 1;
    let out = '';
    let bits = 0; // Number of bits currently in the buffer
    let buffer = 0; // Bits waiting to be written out, MSB first
    for(let i = 0; i < data.length; ++i){
        // Slurp data into the buffer:
        buffer = buffer << 8 | data[i];
        bits += 8;
        // Write out as much as we can:
        while(bits > bitsPerChar){
            bits -= bitsPerChar;
            out += alphabet[mask & buffer >> bits];
        }
    }
    // Partial character:
    if (bits !== 0) {
        out += alphabet[mask & buffer << bitsPerChar - bits];
    }
    // Add padding characters until we hit a byte boundary:
    if (pad) {
        while((out.length * bitsPerChar & 7) !== 0){
            out += '=';
        }
    }
    return out;
}
function createAlphabetIdx(alphabet) {
    // Build the character lookup table:
    const alphabetIdx = {};
    for(let i = 0; i < alphabet.length; ++i){
        alphabetIdx[alphabet[i]] = i;
    }
    return alphabetIdx;
}
function rfc4648({ name, prefix, bitsPerChar, alphabet }) {
    const alphabetIdx = createAlphabetIdx(alphabet);
    return from({
        prefix,
        name,
        encode (input) {
            return encode(input, alphabet, bitsPerChar);
        },
        decode (input) {
            return decode(input, alphabetIdx, bitsPerChar, name);
        }
    });
} //# sourceMappingURL=base.js.map
}),
"[project]/node_modules/multiformats/dist/src/bases/base32.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "base32",
    ()=>base32,
    "base32hex",
    ()=>base32hex,
    "base32hexpad",
    ()=>base32hexpad,
    "base32hexpadupper",
    ()=>base32hexpadupper,
    "base32hexupper",
    ()=>base32hexupper,
    "base32pad",
    ()=>base32pad,
    "base32padupper",
    ()=>base32padupper,
    "base32upper",
    ()=>base32upper,
    "base32z",
    ()=>base32z
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base.js [app-client] (ecmascript)");
;
const base32 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'b',
    name: 'base32',
    alphabet: 'abcdefghijklmnopqrstuvwxyz234567',
    bitsPerChar: 5
});
const base32upper = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'B',
    name: 'base32upper',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',
    bitsPerChar: 5
});
const base32pad = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'c',
    name: 'base32pad',
    alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',
    bitsPerChar: 5
});
const base32padupper = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'C',
    name: 'base32padupper',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',
    bitsPerChar: 5
});
const base32hex = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'v',
    name: 'base32hex',
    alphabet: '0123456789abcdefghijklmnopqrstuv',
    bitsPerChar: 5
});
const base32hexupper = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'V',
    name: 'base32hexupper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',
    bitsPerChar: 5
});
const base32hexpad = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 't',
    name: 'base32hexpad',
    alphabet: '0123456789abcdefghijklmnopqrstuv=',
    bitsPerChar: 5
});
const base32hexpadupper = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'T',
    name: 'base32hexpadupper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',
    bitsPerChar: 5
});
const base32z = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'h',
    name: 'base32z',
    alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',
    bitsPerChar: 5
}); //# sourceMappingURL=base32.js.map
}),
"[project]/node_modules/multiformats/dist/src/bases/base36.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "base36",
    ()=>base36,
    "base36upper",
    ()=>base36upper
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base.js [app-client] (ecmascript)");
;
const base36 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["baseX"])({
    prefix: 'k',
    name: 'base36',
    alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'
});
const base36upper = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["baseX"])({
    prefix: 'K',
    name: 'base36upper',
    alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
}); //# sourceMappingURL=base36.js.map
}),
"[project]/node_modules/multiformats/dist/src/bases/base58.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "base58btc",
    ()=>base58btc,
    "base58flickr",
    ()=>base58flickr
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base.js [app-client] (ecmascript)");
;
const base58btc = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["baseX"])({
    name: 'base58btc',
    prefix: 'z',
    alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
});
const base58flickr = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["baseX"])({
    name: 'base58flickr',
    prefix: 'Z',
    alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'
}); //# sourceMappingURL=base58.js.map
}),
"[project]/node_modules/multiformats/dist/src/vendor/varint.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* eslint-disable */ __turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var encode_1 = encode;
var MSB = 0x80, REST = 0x7F, MSBALL = ~REST, INT = Math.pow(2, 31);
/**
 * @param {number} num
 * @param {number[]} out
 * @param {number} offset
 */ function encode(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while(num >= INT){
        out[offset++] = num & 0xFF | MSB;
        num /= 128;
    }
    while(num & MSBALL){
        out[offset++] = num & 0xFF | MSB;
        num >>>= 7;
    }
    out[offset] = num | 0;
    // @ts-ignore
    encode.bytes = offset - oldOffset + 1;
    return out;
}
var decode = read;
var MSB$1 = 0x80, REST$1 = 0x7F;
/**
 * @param {string | any[]} buf
 * @param {number} offset
 */ function read(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
        if (counter >= l) {
            // @ts-ignore
            read.bytes = 0;
            throw new RangeError('Could not decode varint');
        }
        b = buf[counter++];
        res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
        shift += 7;
    }while (b >= MSB$1)
    // @ts-ignore
    read.bytes = counter - offset;
    return res;
}
var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
var length = function(/** @type {number} */ value) {
    return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
var varint = {
    encode: encode_1,
    decode: decode,
    encodingLength: length
};
var _brrp_varint = varint;
const __TURBOPACK__default__export__ = _brrp_varint;
 //# sourceMappingURL=varint.js.map
}),
"[project]/node_modules/multiformats/dist/src/varint.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "decode",
    ()=>decode,
    "encodeTo",
    ()=>encodeTo,
    "encodingLength",
    ()=>encodingLength
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$vendor$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/vendor/varint.js [app-client] (ecmascript)");
;
function decode(data, offset = 0) {
    const code = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$vendor$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].decode(data, offset);
    return [
        code,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$vendor$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].decode.bytes
    ];
}
function encodeTo(int, target, offset = 0) {
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$vendor$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].encode(int, target, offset);
    return target;
}
function encodingLength(int) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$vendor$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].encodingLength(int);
} //# sourceMappingURL=varint.js.map
}),
"[project]/node_modules/multiformats/dist/src/hashes/digest.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Digest",
    ()=>Digest,
    "create",
    ()=>create,
    "decode",
    ()=>decode,
    "equals",
    ()=>equals,
    "hasCode",
    ()=>hasCode
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bytes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/varint.js [app-client] (ecmascript)");
;
;
function create(code, digest) {
    const size = digest.byteLength;
    const sizeOffset = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodingLength"](code);
    const digestOffset = sizeOffset + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodingLength"](size);
    const bytes = new Uint8Array(digestOffset + size);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeTo"](code, bytes, 0);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeTo"](size, bytes, sizeOffset);
    bytes.set(digest, digestOffset);
    return new Digest(code, size, digest, bytes);
}
function decode(multihash) {
    const bytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coerce"])(multihash);
    const [code, sizeOffset] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](bytes);
    const [size, digestOffset] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](bytes.subarray(sizeOffset));
    const digest = bytes.subarray(sizeOffset + digestOffset);
    if (digest.byteLength !== size) {
        throw new Error('Incorrect length');
    }
    return new Digest(code, size, digest, bytes);
}
function equals(a, b) {
    if (a === b) {
        return true;
    } else {
        const data = b;
        return a.code === data.code && a.size === data.size && data.bytes instanceof Uint8Array && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["equals"])(a.bytes, data.bytes);
    }
}
class Digest {
    code;
    size;
    digest;
    bytes;
    /**
     * Creates a multihash digest.
     */ constructor(code, size, digest, bytes){
        this.code = code;
        this.size = size;
        this.digest = digest;
        this.bytes = bytes;
    }
}
function hasCode(digest, code) {
    return digest.code === code;
} //# sourceMappingURL=digest.js.map
}),
"[project]/node_modules/multiformats/dist/src/link/interface.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
;
 //# sourceMappingURL=interface.js.map
}),
"[project]/node_modules/multiformats/dist/src/cid.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CID",
    ()=>CID,
    "format",
    ()=>format,
    "fromJSON",
    ()=>fromJSON,
    "toJSON",
    ()=>toJSON
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base32.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base36$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base36.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base58.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bytes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/hashes/digest.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/varint.js [app-client] (ecmascript)");
// This way TS will also expose all the types from module
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2f$interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/link/interface.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
function format(link, base) {
    const { bytes, version } = link;
    switch(version){
        case 0:
            return toStringV0(bytes, baseCache(link), base ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base58btc"].encoder);
        default:
            return toStringV1(bytes, baseCache(link), base ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base32"].encoder);
    }
}
function toJSON(link) {
    return {
        '/': format(link)
    };
}
function fromJSON(json) {
    return CID.parse(json['/']);
}
const cache = new WeakMap();
function baseCache(cid) {
    const baseCache = cache.get(cid);
    if (baseCache == null) {
        const baseCache = new Map();
        cache.set(cid, baseCache);
        return baseCache;
    }
    return baseCache;
}
class CID {
    code;
    version;
    multihash;
    bytes;
    '/';
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param multihash - (Multi)hash of the of the content.
     */ constructor(version, code, multihash, bytes){
        this.code = code;
        this.version = version;
        this.multihash = multihash;
        this.bytes = bytes;
        // flag to serializers that this is a CID and
        // should be treated specially
        this['/'] = bytes;
    }
    /**
     * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`
     * please either use `CID.asCID(cid)` or switch to new signalling mechanism
     *
     * @deprecated
     */ get asCID() {
        return this;
    }
    // ArrayBufferView
    get byteOffset() {
        return this.bytes.byteOffset;
    }
    // ArrayBufferView
    get byteLength() {
        return this.bytes.byteLength;
    }
    toV0() {
        switch(this.version){
            case 0:
                {
                    return this;
                }
            case 1:
                {
                    const { code, multihash } = this;
                    if (code !== DAG_PB_CODE) {
                        throw new Error('Cannot convert a non dag-pb CID to CIDv0');
                    }
                    // sha2-256
                    if (multihash.code !== SHA_256_CODE) {
                        throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0');
                    }
                    return CID.createV0(multihash);
                }
            default:
                {
                    throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
                }
        }
    }
    toV1() {
        switch(this.version){
            case 0:
                {
                    const { code, digest } = this.multihash;
                    const multihash = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"](code, digest);
                    return CID.createV1(this.code, multihash);
                }
            case 1:
                {
                    return this;
                }
            default:
                {
                    throw Error(`Can not convert CID version ${this.version} to version 1. This is a bug please report`);
                }
        }
    }
    equals(other) {
        return CID.equals(this, other);
    }
    static equals(self, other) {
        const unknown = other;
        return unknown != null && self.code === unknown.code && self.version === unknown.version && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["equals"](self.multihash, unknown.multihash);
    }
    toString(base) {
        return format(this, base);
    }
    toJSON() {
        return {
            '/': format(this)
        };
    }
    link() {
        return this;
    }
    [Symbol.toStringTag] = 'CID';
    // Legacy
    [Symbol.for('nodejs.util.inspect.custom')]() {
        return `CID(${this.toString()})`;
    }
    /**
     * Takes any input `value` and returns a `CID` instance if it was
     * a `CID` otherwise returns `null`. If `value` is instanceof `CID`
     * it will return value back. If `value` is not instance of this CID
     * class, but is compatible CID it will return new instance of this
     * `CID` class. Otherwise returns null.
     *
     * This allows two different incompatible versions of CID library to
     * co-exist and interop as long as binary interface is compatible.
     */ static asCID(input) {
        if (input == null) {
            return null;
        }
        const value = input;
        if (value instanceof CID) {
            // If value is instance of CID then we're all set.
            return value;
        } else if (value['/'] != null && value['/'] === value.bytes || value.asCID === value) {
            // If value isn't instance of this CID class but `this.asCID === this` or
            // `value['/'] === value.bytes` is true it is CID instance coming from a
            // different implementation (diff version or duplicate). In that case we
            // rebase it to this `CID` implementation so caller is guaranteed to get
            // instance with expected API.
            const { version, code, multihash, bytes } = value;
            return new CID(version, code, multihash, bytes ?? encodeCID(version, code, multihash.bytes));
        } else if (value[cidSymbol] === true) {
            // If value is a CID from older implementation that used to be tagged via
            // symbol we still rebase it to the this `CID` implementation by
            // delegating that to a constructor.
            const { version, multihash, code } = value;
            const digest = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](multihash);
            return CID.create(version, code, digest);
        } else {
            // Otherwise value is not a CID (or an incompatible version of it) in
            // which case we return `null`.
            return null;
        }
    }
    /**
     * @param version - Version of the CID
     * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv
     * @param digest - (Multi)hash of the of the content.
     */ static create(version, code, digest) {
        if (typeof code !== 'number') {
            throw new Error('String codecs are no longer supported');
        }
        if (!(digest.bytes instanceof Uint8Array)) {
            throw new Error('Invalid digest');
        }
        switch(version){
            case 0:
                {
                    if (code !== DAG_PB_CODE) {
                        throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
                    } else {
                        return new CID(version, code, digest, digest.bytes);
                    }
                }
            case 1:
                {
                    const bytes = encodeCID(version, code, digest.bytes);
                    return new CID(version, code, digest, bytes);
                }
            default:
                {
                    throw new Error('Invalid version');
                }
        }
    }
    /**
     * Simplified version of `create` for CIDv0.
     */ static createV0(digest) {
        return CID.create(0, DAG_PB_CODE, digest);
    }
    /**
     * Simplified version of `create` for CIDv1.
     *
     * @param code - Content encoding format code.
     * @param digest - Multihash of the content.
     */ static createV1(code, digest) {
        return CID.create(1, code, digest);
    }
    /**
     * Decoded a CID from its binary representation. The byte array must contain
     * only the CID with no additional bytes.
     *
     * An error will be thrown if the bytes provided do not contain a valid
     * binary representation of a CID.
     */ static decode(bytes) {
        const [cid, remainder] = CID.decodeFirst(bytes);
        if (remainder.length !== 0) {
            throw new Error('Incorrect length');
        }
        return cid;
    }
    /**
     * Decoded a CID from its binary representation at the beginning of a byte
     * array.
     *
     * Returns an array with the first element containing the CID and the second
     * element containing the remainder of the original byte array. The remainder
     * will be a zero-length byte array if the provided bytes only contained a
     * binary CID representation.
     */ static decodeFirst(bytes) {
        const specs = CID.inspectBytes(bytes);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coerce"])(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
        if (multihashBytes.byteLength !== specs.multihashSize) {
            throw new Error('Incorrect length');
        }
        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
        const digest = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Digest"](specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
        const cid = specs.version === 0 ? CID.createV0(digest) : CID.createV1(specs.codec, digest);
        return [
            cid,
            bytes.subarray(specs.size)
        ];
    }
    /**
     * Inspect the initial bytes of a CID to determine its properties.
     *
     * Involves decoding up to 4 varints. Typically this will require only 4 to 6
     * bytes but for larger multicodec code values and larger multihash digest
     * lengths these varints can be quite large. It is recommended that at least
     * 10 bytes be made available in the `initialBytes` argument for a complete
     * inspection.
     */ static inspectBytes(initialBytes) {
        let offset = 0;
        const next = ()=>{
            const [i, length] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](initialBytes.subarray(offset));
            offset += length;
            return i;
        };
        let version = next();
        let codec = DAG_PB_CODE;
        if (version === 18) {
            // CIDv0
            version = 0;
            offset = 0;
        } else {
            codec = next();
        }
        if (version !== 0 && version !== 1) {
            throw new RangeError(`Invalid CID version ${version}`);
        }
        const prefixSize = offset;
        const multihashCode = next(); // multihash code
        const digestSize = next(); // multihash length
        const size = offset + digestSize;
        const multihashSize = size - prefixSize;
        return {
            version,
            codec,
            multihashCode,
            digestSize,
            multihashSize,
            size
        };
    }
    /**
     * Takes cid in a string representation and creates an instance. If `base`
     * decoder is not provided will use a default from the configuration. It will
     * throw an error if encoding of the CID is not compatible with supplied (or
     * a default decoder).
     */ static parse(source, base) {
        const [prefix, bytes] = parseCIDtoBytes(source, base);
        const cid = CID.decode(bytes);
        if (cid.version === 0 && source[0] !== 'Q') {
            throw Error('Version 0 CID string must not include multibase prefix');
        }
        // Cache string representation to avoid computing it on `this.toString()`
        baseCache(cid).set(prefix, source);
        return cid;
    }
}
function parseCIDtoBytes(source, base) {
    switch(source[0]){
        // CIDv0 is parsed differently
        case 'Q':
            {
                const decoder = base ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base58btc"];
                return [
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base58btc"].prefix,
                    decoder.decode(`${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base58btc"].prefix}${source}`)
                ];
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base58btc"].prefix:
            {
                const decoder = base ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base58btc"];
                return [
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base58btc"].prefix,
                    decoder.decode(source)
                ];
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base32"].prefix:
            {
                const decoder = base ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base32"];
                return [
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base32"].prefix,
                    decoder.decode(source)
                ];
            }
        case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base36$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base36"].prefix:
            {
                const decoder = base ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base36$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base36"];
                return [
                    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base36$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base36"].prefix,
                    decoder.decode(source)
                ];
            }
        default:
            {
                if (base == null) {
                    throw Error('To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided');
                }
                return [
                    source[0],
                    base.decode(source)
                ];
            }
    }
}
function toStringV0(bytes, cache, base) {
    const { prefix } = base;
    if (prefix !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base58btc"].prefix) {
        throw Error(`Cannot string encode V0 in ${base.name} encoding`);
    }
    const cid = cache.get(prefix);
    if (cid == null) {
        const cid = base.encode(bytes).slice(1);
        cache.set(prefix, cid);
        return cid;
    } else {
        return cid;
    }
}
function toStringV1(bytes, cache, base) {
    const { prefix } = base;
    const cid = cache.get(prefix);
    if (cid == null) {
        const cid = base.encode(bytes);
        cache.set(prefix, cid);
        return cid;
    } else {
        return cid;
    }
}
const DAG_PB_CODE = 0x70;
const SHA_256_CODE = 0x12;
function encodeCID(version, code, multihash) {
    const codeOffset = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodingLength"](version);
    const hashOffset = codeOffset + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodingLength"](code);
    const bytes = new Uint8Array(hashOffset + multihash.byteLength);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeTo"](version, bytes, 0);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeTo"](code, bytes, codeOffset);
    bytes.set(multihash, hashOffset);
    return bytes;
}
const cidSymbol = Symbol.for('@ipld/js-cid/CID'); //# sourceMappingURL=cid.js.map
}),
"[project]/node_modules/multiformats/dist/src/link.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "create",
    ()=>create,
    "createLegacy",
    ()=>createLegacy,
    "decode",
    ()=>decode,
    "isLink",
    ()=>isLink,
    "parse",
    ()=>parse
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/cid.js [app-client] (ecmascript) <locals>");
// This way TS will also expose all the types from module
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2f$interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/link/interface.js [app-client] (ecmascript)");
;
;
const DAG_PB_CODE = 0x70;
// eslint-disable-next-line
const SHA_256_CODE = 0x12;
function createLegacy(digest) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].create(0, DAG_PB_CODE, digest);
}
function create(code, digest) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].create(1, code, digest);
}
function isLink(value) {
    if (value == null) {
        return false;
    }
    const withSlash = value;
    if (withSlash['/'] != null && withSlash['/'] === withSlash.bytes) {
        return true;
    }
    const withAsCID = value;
    if (withAsCID.asCID === value) {
        return true;
    }
    return false;
}
function parse(source, base) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].parse(source, base);
}
;
function decode(bytes) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].decode(bytes);
} //# sourceMappingURL=link.js.map
}),
"[project]/node_modules/multiformats/dist/src/hashes/identity.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "identity",
    ()=>identity
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bytes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/hashes/digest.js [app-client] (ecmascript)");
;
;
const code = 0x0;
const name = 'identity';
const encode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coerce"];
function digest(input, options) {
    if (options?.truncate != null && options.truncate !== input.byteLength) {
        if (options.truncate < 0 || options.truncate > input.byteLength) {
            throw new Error(`Invalid truncate option, must be less than or equal to ${input.byteLength}`);
        }
        input = input.subarray(0, options.truncate);
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"](code, encode(input));
}
const identity = {
    code,
    name,
    encode,
    digest
}; //# sourceMappingURL=identity.js.map
}),
"[project]/node_modules/multiformats/dist/src/hashes/hasher.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Hasher",
    ()=>Hasher,
    "from",
    ()=>from
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/hashes/digest.js [app-client] (ecmascript)");
;
const DEFAULT_MIN_DIGEST_LENGTH = 20;
function from({ name, code, encode, minDigestLength, maxDigestLength }) {
    return new Hasher(name, code, encode, minDigestLength, maxDigestLength);
}
class Hasher {
    name;
    code;
    encode;
    minDigestLength;
    maxDigestLength;
    constructor(name, code, encode, minDigestLength, maxDigestLength){
        this.name = name;
        this.code = code;
        this.encode = encode;
        this.minDigestLength = minDigestLength ?? DEFAULT_MIN_DIGEST_LENGTH;
        this.maxDigestLength = maxDigestLength;
    }
    digest(input, options) {
        if (options?.truncate != null) {
            if (options.truncate < this.minDigestLength) {
                throw new Error(`Invalid truncate option, must be greater than or equal to ${this.minDigestLength}`);
            }
            if (this.maxDigestLength != null && options.truncate > this.maxDigestLength) {
                throw new Error(`Invalid truncate option, must be less than or equal to ${this.maxDigestLength}`);
            }
        }
        if (input instanceof Uint8Array) {
            const result = this.encode(input);
            if (result instanceof Uint8Array) {
                return createDigest(result, this.code, options?.truncate);
            }
            return result.then((digest)=>createDigest(digest, this.code, options?.truncate));
        } else {
            throw Error('Unknown type, must be binary type');
        /* c8 ignore next 1 */ }
    }
}
/**
 * Create a Digest from the passed uint8array and code, optionally truncating it
 * first.
 */ function createDigest(digest, code, truncate) {
    if (truncate != null && truncate !== digest.byteLength) {
        if (truncate > digest.byteLength) {
            throw new Error(`Invalid truncate option, must be less than or equal to ${digest.byteLength}`);
        }
        digest = digest.subarray(0, truncate);
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"](code, digest);
} //# sourceMappingURL=hasher.js.map
}),
"[project]/node_modules/multiformats/dist/src/bases/interface.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Base encoders / decoders just base encode / decode between binary and
// textual representation. They are unaware of multibase.
__turbopack_context__.s([]);
;
 //# sourceMappingURL=interface.js.map
}),
"[project]/node_modules/multiformats/dist/src/hashes/interface.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// # Multihash
__turbopack_context__.s([]);
;
 //# sourceMappingURL=interface.js.map
}),
"[project]/node_modules/multiformats/dist/src/codecs/interface.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
;
 //# sourceMappingURL=interface.js.map
}),
"[project]/node_modules/multiformats/dist/src/block/interface.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
;
 //# sourceMappingURL=interface.js.map
}),
"[project]/node_modules/multiformats/dist/src/interface.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/interface.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/hashes/interface.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$codecs$2f$interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/codecs/interface.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2f$interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/link/interface.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$block$2f$interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/block/interface.js [app-client] (ecmascript)"); //# sourceMappingURL=interface.js.map
;
;
;
;
;
}),
"[project]/node_modules/multiformats/dist/src/index.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

/**
 * @packageDocumentation
 *
 * This library defines common interfaces and low level building blocks for various interrelated multiformat technologies (multicodec, multihash, multibase, and CID). They can be used to implement custom base encoders / decoders / codecs, codec encoders /decoders and multihash hashers that comply to the interface that layers above assume.
 *
 * This library provides implementations for most basics and many others can be found in linked repositories.
 *
 * ```TypeScript
 * import { CID } from 'multiformats/cid'
 * import * as json from 'multiformats/codecs/json'
 * import { sha256 } from 'multiformats/hashes/sha2'
 *
 * const bytes = json.encode({ hello: 'world' })
 *
 * const hash = await sha256.digest(bytes)
 * const cid = CID.create(1, json.code, hash)
 * //> CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)
 * ```
 *
 * ## Creating Blocks
 *
 * ```TypeScript
 * import * as Block from 'multiformats/block'
 * import * as codec from '@ipld/dag-cbor'
 * import { sha256 as hasher } from 'multiformats/hashes/sha2'
 *
 * const value = { hello: 'world' }
 *
 * // encode a block
 * let block = await Block.encode({ value, codec, hasher })
 *
 * block.value // { hello: 'world' }
 * block.bytes // Uint8Array
 * block.cid   // CID() w/ sha2-256 hash address and dag-cbor codec
 *
 * // you can also decode blocks from their binary state
 * block = await Block.decode({ bytes: block.bytes, codec, hasher })
 *
 * // if you have the cid you can also verify the hash on decode
 * block = await Block.create({ bytes: block.bytes, cid: block.cid, codec, hasher })
 * ```
 *
 * ## Multibase Encoders / Decoders / Codecs
 *
 * CIDs can be serialized to string representation using multibase encoders that implement [`MultibaseEncoder`](https://github.com/multiformats/js-multiformats/blob/master/src/bases/interface.ts) interface. This library provides quite a few implementations that can be imported:
 *
 * ```TypeScript
 * import { base64 } from "multiformats/bases/base64"
 * cid.toString(base64.encoder)
 * //> 'mAYAEEiCTojlxqRTl6svwqNJRVM2jCcPBxy+7mRTUfGDzy2gViA'
 * ```
 *
 * Parsing CID string serialized CIDs requires multibase decoder that implements [`MultibaseDecoder`](https://github.com/multiformats/js-multiformats/blob/master/src/bases/interface.ts) interface. This library provides a decoder for every encoder it provides:
 *
 * ```TypeScript
 * CID.parse('mAYAEEiCTojlxqRTl6svwqNJRVM2jCcPBxy+7mRTUfGDzy2gViA', base64.decoder)
 * //> CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)
 * ```
 *
 * Dual of multibase encoder & decoder is defined as multibase codec and it exposes
 * them as `encoder` and `decoder` properties. For added convenience codecs also
 * implement `MultibaseEncoder` and `MultibaseDecoder` interfaces so they could be
 * used as either or both:
 *
 * ```TypeScript
 * cid.toString(base64)
 * CID.parse(cid.toString(base64), base64)
 * ```
 *
 * **Note:** CID implementation comes bundled with `base32` and `base58btc`
 * multibase codecs so that CIDs can be base serialized to (version specific)
 * default base encoding and parsed without having to supply base encoders/decoders:
 *
 * ```TypeScript
 * const v1 = CID.parse('bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea')
 * v1.toString()
 * //> 'bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea'
 *
 * const v0 = CID.parse('QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n')
 * v0.toString()
 * //> 'QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n'
 * v0.toV1().toString()
 * //> 'bafybeihdwdcefgh4dqkjv67uzcmw7ojee6xedzdetojuzjevtenxquvyku'
 * ```
 *
 * ## Multicodec Encoders / Decoders / Codecs
 *
 * This library defines [`BlockEncoder`, `BlockDecoder` and `BlockCodec` interfaces](https://github.com/multiformats/js-multiformats/blob/master/src/codecs/interface.ts).
 * Codec implementations should conform to the `BlockCodec` interface which implements both `BlockEncoder` and `BlockDecoder`.
 * Here is an example implementation of JSON `BlockCodec`.
 *
 * ```TypeScript
 * export const { name, code, encode, decode } = {
 *   name: 'json',
 *   code: 0x0200,
 *   encode: json => new TextEncoder().encode(JSON.stringify(json)),
 *   decode: bytes => JSON.parse(new TextDecoder().decode(bytes))
 * }
 * ```
 *
 * ## Multihash Hashers
 *
 * This library defines [`MultihashHasher` and `MultihashDigest` interfaces](https://github.com/multiformats/js-multiformats/blob/master/src/hashes/interface.ts) and convinient function for implementing them:
 *
 * ```TypeScript
 * import * as hasher from 'multiformats/hashes/hasher'
 *
 * const sha256 = hasher.from({
 *   // As per multiformats table
 *   // https://github.com/multiformats/multicodec/blob/master/table.csv#L9
 *   name: 'sha2-256',
 *   code: 0x12,
 *
 *   encode: (input) => new Uint8Array(crypto.createHash('sha256').update(input).digest())
 * })
 *
 * const hash = await sha256.digest(json.encode({ hello: 'world' }))
 * CID.create(1, json.code, hash)
 *
 * //> CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)
 * ```
 *
 * ## Traversal
 *
 * This library contains higher-order functions for traversing graphs of data easily.
 *
 * `walk()` walks through the links in each block of a DAG calling a user-supplied loader function for each one, in depth-first order with no duplicate block visits. The loader should return a `Block` object and can be used to inspect and collect block ordering for a full DAG walk. The loader should `throw` on error, and return `null` if a block should be skipped by `walk()`.
 *
 * ```TypeScript
 * import { walk } from 'multiformats/traversal'
 * import * as Block from 'multiformats/block'
 * import * as codec from 'multiformats/codecs/json'
 * import { sha256 as hasher } from 'multiformats/hashes/sha2'
 *
 * // build a DAG (a single block for this simple example)
 * const value = { hello: 'world' }
 * const block = await Block.encode({ value, codec, hasher })
 * const { cid } = block
 * console.log(cid)
 * //> CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)
 *
 * // create a loader function that also collects CIDs of blocks in
 * // their traversal order
 * const load = (cid, blocks) => async (cid) => {
 *   // fetch a block using its cid
 *   // e.g.: const block = await fetchBlockByCID(cid)
 *   blocks.push(cid)
 *   return block
 * }
 *
 * // collect blocks in this DAG starting from the root `cid`
 * const blocks = []
 * await walk({ cid, load: load(cid, blocks) })
 *
 * console.log(blocks)
 * //> [CID(bagaaierasords4njcts6vs7qvdjfcvgnume4hqohf65zsfguprqphs3icwea)]
 * ```
 *
 * ## Legacy interface
 *
 * [`blockcodec-to-ipld-format`](https://github.com/ipld/js-blockcodec-to-ipld-format) converts a multiformats [`BlockCodec`](https://github.com/multiformats/js-multiformats/blob/master/src/codecs/interface.ts#L21) into an
 * [`interface-ipld-format`](https://github.com/ipld/interface-ipld-format) for use with the [`ipld`](https://github.com/ipld/ipld) package. This can help bridge IPLD codecs implemented using the structure and interfaces defined here to existing code that assumes, or requires `interface-ipld-format`. This bridge also includes the relevant TypeScript definitions.
 *
 * ## Implementations
 *
 * By default, no base encodings (other than base32 & base58btc), hash functions,
 * or codec implementations are exposed by `multiformats`, you need to
 * import the ones you need yourself.
 *
 * ### Multibase codecs
 *
 * | bases                                                         | import                      | repo                                                                                              |
 * | ------------------------------------------------------------- | --------------------------- | ------------------------------------------------------------------------------------------------- |
 * | `base16`                                                      | `multiformats/bases/base16` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) |
 * | `base32`, `base32pad`, `base32hex`, `base32hexpad`, `base32z` | `multiformats/bases/base32` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) |
 * | `base64`, `base64pad`, `base64url`, `base64urlpad`            | `multiformats/bases/base64` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) |
 * | `base58btc`, `base58flick4`                                   | `multiformats/bases/base58` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) |
 *
 * Other (less useful) bases implemented in [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/bases) include: `base2`, `base8`, `base10`, `base36` and `base256emoji`.
 *
 * ### Multihash hashers
 *
 * | hashes                                                                                                                          | import                         | repo                                                                                                               |
 * | ------------------------------------------------------------------------------------------------------------------------------- | ------------------------------ | ------------------------------------------------------------------------------------------------------------------ |
 * | `sha2-256`, `sha2-512`                                                                                                          | `multiformats/hashes/sha2`     | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/src/hashes)             |
 * | `sha3-224`, `sha3-256`, `sha3-384`,`sha3-512`, `shake-128`, `shake-256`, `keccak-224`, `keccak-256`, `keccak-384`, `keccak-512` | `@multiformats/sha3`           | [multiformats/js-sha3](https://github.com/multiformats/js-sha3)                                                    |
 * | `identity`                                                                                                                      | `multiformats/hashes/identity` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/src/hashes/identity.js) |
 * | `murmur3-128`, `murmur3-32`                                                                                                     | `@multiformats/murmur3`        | [multiformats/js-murmur3](https://github.com/multiformats/js-murmur3)                                              |
 * | `blake2b-*`, `blake2s-*`                                                                                                        | `@multiformats/blake2`         | [multiformats/js-blake2](https://github.com/multiformats/js-blake2)                                                |
 *
 * ### IPLD codecs (multicodec)
 *
 * | codec      | import                     | repo                                                                                                   |
 * | ---------- | -------------------------- | ------------------------------------------------------------------------------------------------------ |
 * | `raw`      | `multiformats/codecs/raw`  | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/src/codecs) |
 * | `json`     | `multiformats/codecs/json` | [multiformats/js-multiformats](https://github.com/multiformats/js-multiformats/tree/master/src/codecs) |
 * | `dag-cbor` | `@ipld/dag-cbor`           | [ipld/js-dag-cbor](https://github.com/ipld/js-dag-cbor)                                                |
 * | `dag-json` | `@ipld/dag-json`           | [ipld/js-dag-json](https://github.com/ipld/js-dag-json)                                                |
 * | `dag-pb`   | `@ipld/dag-pb`             | [ipld/js-dag-pb](https://github.com/ipld/js-dag-pb)                                                    |
 * | `dag-jose` | `dag-jose`                 | [ceramicnetwork/js-dag-jose](https://github.com/ceramicnetwork/js-dag-jose)                            |
 */ __turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bytes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/cid.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/hashes/digest.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$hasher$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/hashes/hasher.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/varint.js [app-client] (ecmascript)");
// This way TS will also expose all the types from module
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/interface.js [app-client] (ecmascript) <locals>");
;
;
;
;
;
;
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/multiformats/dist/src/varint.js [app-client] (ecmascript) <export * as varint>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "varint",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/varint.js [app-client] (ecmascript)");
}),
"[project]/node_modules/multiformats/dist/src/codecs/raw.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "code",
    ()=>code,
    "decode",
    ()=>decode,
    "encode",
    ()=>encode,
    "name",
    ()=>name
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bytes.js [app-client] (ecmascript)");
;
const name = 'raw';
const code = 0x55;
function encode(node) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coerce"])(node);
}
function decode(data) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["coerce"])(data);
} //# sourceMappingURL=raw.js.map
}),
"[project]/node_modules/multiformats/dist/src/bases/base64.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "base64",
    ()=>base64,
    "base64pad",
    ()=>base64pad,
    "base64url",
    ()=>base64url,
    "base64urlpad",
    ()=>base64urlpad
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base.js [app-client] (ecmascript)");
;
const base64 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'm',
    name: 'base64',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',
    bitsPerChar: 6
});
const base64pad = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'M',
    name: 'base64pad',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
    bitsPerChar: 6
});
const base64url = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'u',
    name: 'base64url',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',
    bitsPerChar: 6
});
const base64urlpad = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'U',
    name: 'base64urlpad',
    alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',
    bitsPerChar: 6
}); //# sourceMappingURL=base64.js.map
}),
"[project]/node_modules/multiformats/dist/src/hashes/sha2-browser.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* global crypto */ __turbopack_context__.s([
    "sha256",
    ()=>sha256,
    "sha512",
    ()=>sha512
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$hasher$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/hashes/hasher.js [app-client] (ecmascript)");
;
function sha(name) {
    return async (data)=>new Uint8Array(await crypto.subtle.digest(name, data));
}
const sha256 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$hasher$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"])({
    name: 'sha2-256',
    code: 0x12,
    encode: sha('SHA-256')
});
const sha512 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$hasher$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"])({
    name: 'sha2-512',
    code: 0x13,
    encode: sha('SHA-512')
}); //# sourceMappingURL=sha2-browser.js.map
}),
"[project]/node_modules/multiformats/dist/src/link.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "create",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["create"],
    "createLegacy",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createLegacy"],
    "decode",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["decode"],
    "format",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["format"],
    "fromJSON",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromJSON"],
    "isLink",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isLink"],
    "parse",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["parse"],
    "toJSON",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["toJSON"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/link.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/cid.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2f$interface$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/link/interface.js [app-client] (ecmascript)");
}),
"[project]/node_modules/multiformats/dist/src/bases/base10.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "base10",
    ()=>base10
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base.js [app-client] (ecmascript)");
;
const base10 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["baseX"])({
    prefix: '9',
    name: 'base10',
    alphabet: '0123456789'
}); //# sourceMappingURL=base10.js.map
}),
"[project]/node_modules/multiformats/dist/src/bases/base16.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "base16",
    ()=>base16,
    "base16upper",
    ()=>base16upper
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base.js [app-client] (ecmascript)");
;
const base16 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'f',
    name: 'base16',
    alphabet: '0123456789abcdef',
    bitsPerChar: 4
});
const base16upper = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: 'F',
    name: 'base16upper',
    alphabet: '0123456789ABCDEF',
    bitsPerChar: 4
}); //# sourceMappingURL=base16.js.map
}),
"[project]/node_modules/multiformats/dist/src/bases/base2.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "base2",
    ()=>base2
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base.js [app-client] (ecmascript)");
;
const base2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: '0',
    name: 'base2',
    alphabet: '01',
    bitsPerChar: 1
}); //# sourceMappingURL=base2.js.map
}),
"[project]/node_modules/multiformats/dist/src/bases/base256emoji.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "base256emoji",
    ()=>base256emoji
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base.js [app-client] (ecmascript)");
;
const alphabet = Array.from('');
const alphabetBytesToChars = alphabet.reduce((p, c, i)=>{
    p[i] = c;
    return p;
}, []);
const alphabetCharsToBytes = alphabet.reduce((p, c, i)=>{
    const codePoint = c.codePointAt(0);
    if (codePoint == null) {
        throw new Error(`Invalid character: ${c}`);
    }
    p[codePoint] = i;
    return p;
}, []);
function encode(data) {
    return data.reduce((p, c)=>{
        p += alphabetBytesToChars[c];
        return p;
    }, '');
}
function decode(str) {
    const byts = [];
    for (const char of str){
        const codePoint = char.codePointAt(0);
        if (codePoint == null) {
            throw new Error(`Invalid character: ${char}`);
        }
        const byt = alphabetCharsToBytes[codePoint];
        if (byt == null) {
            throw new Error(`Non-base256emoji character: ${char}`);
        }
        byts.push(byt);
    }
    return new Uint8Array(byts);
}
const base256emoji = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"])({
    prefix: '',
    name: 'base256emoji',
    encode,
    decode
}); //# sourceMappingURL=base256emoji.js.map
}),
"[project]/node_modules/multiformats/dist/src/bases/base8.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "base8",
    ()=>base8
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base.js [app-client] (ecmascript)");
;
const base8 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rfc4648"])({
    prefix: '7',
    name: 'base8',
    alphabet: '01234567',
    bitsPerChar: 3
}); //# sourceMappingURL=base8.js.map
}),
"[project]/node_modules/multiformats/dist/src/bases/identity.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "identity",
    ()=>identity
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bytes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base.js [app-client] (ecmascript)");
;
;
const identity = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"])({
    prefix: '\x00',
    name: 'identity',
    encode: (buf)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toString"])(buf),
    decode: (str)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromString"])(str)
}); //# sourceMappingURL=identity.js.map
}),
"[project]/node_modules/multiformats/dist/src/codecs/json.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "code",
    ()=>code,
    "decode",
    ()=>decode,
    "encode",
    ()=>encode,
    "name",
    ()=>name
]);
const textEncoder = new TextEncoder();
const textDecoder = new TextDecoder();
const name = 'json';
const code = 0x0200;
function encode(node) {
    return textEncoder.encode(JSON.stringify(node));
}
function decode(data) {
    return JSON.parse(textDecoder.decode(data));
} //# sourceMappingURL=json.js.map
}),
"[project]/node_modules/multiformats/dist/src/hashes/hasher.js [app-client] (ecmascript) <export * as hasher>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "hasher",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$hasher$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$hasher$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/hashes/hasher.js [app-client] (ecmascript)");
}),
"[project]/node_modules/multiformats/dist/src/hashes/digest.js [app-client] (ecmascript) <export * as digest>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "digest",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/hashes/digest.js [app-client] (ecmascript)");
}),
"[project]/node_modules/multiformats/dist/src/bytes.js [app-client] (ecmascript) <export * as bytes>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "bytes",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bytes.js [app-client] (ecmascript)");
}),
"[project]/node_modules/multiformats/dist/src/basics.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "bases",
    ()=>bases,
    "codecs",
    ()=>codecs,
    "hashes",
    ()=>hashes
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base10$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base10.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base16$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base16.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base2.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base256emoji$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base256emoji.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base32.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base36$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base36.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base58.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base64.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base8.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$identity$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/identity.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$codecs$2f$json$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/codecs/json.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$codecs$2f$raw$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/codecs/raw.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$identity$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/hashes/identity.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$sha2$2d$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/hashes/sha2-browser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/cid.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$hasher$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__hasher$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/hashes/hasher.js [app-client] (ecmascript) <export * as hasher>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__digest$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/hashes/digest.js [app-client] (ecmascript) <export * as digest>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/varint.js [app-client] (ecmascript) <export * as varint>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__bytes$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bytes.js [app-client] (ecmascript) <export * as bytes>");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
const bases = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$identity$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base10$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base16$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base36$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base256emoji$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__
};
const hashes = {
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$sha2$2d$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$identity$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__
};
const codecs = {
    raw: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$codecs$2f$raw$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    json: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$codecs$2f$json$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__
};
;
 //# sourceMappingURL=basics.js.map
}),
"[project]/node_modules/multiformats/dist/src/block.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Block",
    ()=>Block,
    "create",
    ()=>create,
    "createUnsafe",
    ()=>createUnsafe,
    "decode",
    ()=>decode,
    "encode",
    ()=>encode
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__bytes$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bytes.js [app-client] (ecmascript) <export * as bytes>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/cid.js [app-client] (ecmascript) <locals>");
;
function readonly({ enumerable = true, configurable = false } = {}) {
    return {
        enumerable,
        configurable,
        writable: false
    };
}
function* linksWithin(path, value) {
    if (value != null && typeof value === 'object') {
        if (Array.isArray(value)) {
            for (const [index, element] of value.entries()){
                const elementPath = [
                    ...path,
                    index
                ];
                const cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].asCID(element);
                if (cid != null) {
                    yield [
                        elementPath.join('/'),
                        cid
                    ];
                } else if (typeof element === 'object') {
                    yield* links(element, elementPath);
                }
            }
        } else {
            const cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].asCID(value);
            if (cid != null) {
                yield [
                    path.join('/'),
                    cid
                ];
            } else {
                yield* links(value, path);
            }
        }
    }
}
function* links(source, base) {
    if (source == null || source instanceof Uint8Array) {
        return;
    }
    const cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].asCID(source);
    if (cid != null) {
        yield [
            base.join('/'),
            cid
        ];
    }
    for (const [key, value] of Object.entries(source)){
        const path = [
            ...base,
            key
        ];
        yield* linksWithin(path, value);
    }
}
function* treeWithin(path, value) {
    if (Array.isArray(value)) {
        for (const [index, element] of value.entries()){
            const elementPath = [
                ...path,
                index
            ];
            yield elementPath.join('/');
            if (typeof element === 'object' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].asCID(element) == null) {
                yield* tree(element, elementPath);
            }
        }
    } else {
        yield* tree(value, path);
    }
}
function* tree(source, base) {
    if (source == null || typeof source !== 'object') {
        return;
    }
    for (const [key, value] of Object.entries(source)){
        const path = [
            ...base,
            key
        ];
        yield path.join('/');
        if (value != null && !(value instanceof Uint8Array) && typeof value === 'object' && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].asCID(value) == null) {
            yield* treeWithin(path, value);
        }
    }
}
function get(source, path) {
    let node = source;
    for (const [index, key] of path.entries()){
        node = node[key];
        if (node == null) {
            throw new Error(`Object has no property at ${path.slice(0, index + 1).map((part)=>`[${JSON.stringify(part)}]`).join('')}`);
        }
        const cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].asCID(node);
        if (cid != null) {
            return {
                value: cid,
                remaining: path.slice(index + 1).join('/')
            };
        }
    }
    return {
        value: node
    };
}
class Block {
    cid;
    bytes;
    value;
    asBlock;
    constructor({ cid, bytes, value }){
        if (cid == null || bytes == null || typeof value === 'undefined') {
            throw new Error('Missing required argument');
        }
        this.cid = cid;
        this.bytes = bytes;
        this.value = value;
        this.asBlock = this;
        // Mark all the properties immutable
        Object.defineProperties(this, {
            cid: readonly(),
            bytes: readonly(),
            value: readonly(),
            asBlock: readonly()
        });
    }
    links() {
        return links(this.value, []);
    }
    tree() {
        return tree(this.value, []);
    }
    get(path = '/') {
        return get(this.value, path.split('/').filter(Boolean));
    }
}
async function encode({ value, codec, hasher }) {
    if (typeof value === 'undefined') {
        throw new Error('Missing required argument "value"');
    }
    if (codec == null || hasher == null) {
        throw new Error('Missing required argument: codec or hasher');
    }
    const bytes = codec.encode(value);
    const hash = await hasher.digest(bytes);
    const cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].create(1, codec.code, hash);
    return new Block({
        value,
        bytes,
        cid
    });
}
async function decode({ bytes, codec, hasher }) {
    if (bytes == null) {
        throw new Error('Missing required argument "bytes"');
    }
    if (codec == null || hasher == null) {
        throw new Error('Missing required argument: codec or hasher');
    }
    const value = codec.decode(bytes);
    const hash = await hasher.digest(bytes);
    const cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].create(1, codec.code, hash);
    return new Block({
        value,
        bytes,
        cid
    });
}
function createUnsafe({ bytes, cid, value: maybeValue, codec }) {
    const value = maybeValue !== undefined ? maybeValue : codec?.decode(bytes);
    if (value === undefined) {
        throw new Error('Missing required argument, must either provide "value" or "codec"');
    }
    return new Block({
        cid: cid,
        bytes,
        value
    });
}
async function create({ bytes, cid, hasher, codec }) {
    if (bytes == null) {
        throw new Error('Missing required argument "bytes"');
    }
    if (hasher == null) {
        throw new Error('Missing required argument "hasher"');
    }
    const value = codec.decode(bytes);
    const hash = await hasher.digest(bytes);
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__bytes$3e$__["bytes"].equals(cid.multihash.bytes, hash.bytes)) {
        throw new Error('CID hash does not match bytes');
    }
    return createUnsafe({
        bytes,
        cid,
        value,
        codec
    });
} //# sourceMappingURL=block.js.map
}),
"[project]/node_modules/@ipld/dag-cbor/src/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "code",
    ()=>code,
    "decode",
    ()=>decode,
    "decodeOptions",
    ()=>decodeOptions,
    "encode",
    ()=>encode,
    "encodeOptions",
    ()=>encodeOptions,
    "name",
    ()=>name,
    "toByteView",
    ()=>toByteView
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$cborg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/cborg/cborg.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$encode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cborg/lib/encode.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$decode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cborg/lib/decode.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cborg/lib/token.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/cid.js [app-client] (ecmascript) <locals>");
;
;
// https://github.com/ipfs/go-ipfs/issues/3570#issuecomment-273931692
const CID_CBOR_TAG = 42;
function toByteView(buf) {
    if (buf instanceof ArrayBuffer) {
        return new Uint8Array(buf, 0, buf.byteLength);
    }
    return buf;
}
/**
 * cidEncoder will receive all Objects during encode, it needs to filter out
 * anything that's not a CID and return `null` for that so it's encoded as
 * normal.
 *
 * @param {any} obj
 * @returns {cborg.Token[]|null}
 */ function cidEncoder(obj) {
    if (obj.asCID !== obj && obj['/'] !== obj.bytes) {
        return null // any other kind of object
        ;
    }
    const cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].asCID(obj);
    /* c8 ignore next 4 */ // very unlikely case, and it'll probably throw a recursion error in cborg
    if (!cid) {
        return null;
    }
    const bytes = new Uint8Array(cid.bytes.byteLength + 1);
    bytes.set(cid.bytes, 1); // prefix is 0x00, for historical reasons
    return [
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].tag, CID_CBOR_TAG),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].bytes, bytes)
    ];
}
// eslint-disable-next-line jsdoc/require-returns-check
/**
 * Intercept all `undefined` values from an object walk and reject the entire
 * object if we find one.
 *
 * @returns {null}
 */ function undefinedEncoder() {
    throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded');
}
/**
 * Intercept all `number` values from an object walk and reject the entire
 * object if we find something that doesn't fit the IPLD data model (NaN &
 * Infinity).
 *
 * @param {number} num
 * @returns {null}
 */ function numberEncoder(num) {
    if (Number.isNaN(num)) {
        throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded');
    }
    if (num === Infinity || num === -Infinity) {
        throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded');
    }
    return null;
}
/**
 * @param {Map<any, any>} map
 * @returns {null}
 */ function mapEncoder(map) {
    for (const key of map.keys()){
        if (typeof key !== 'string' || key.length === 0) {
            throw new Error('Non-string Map keys are not supported by the IPLD Data Model and cannot be encoded');
        }
    }
    return null;
}
const _encodeOptions = {
    float64: true,
    typeEncoders: {
        Map: mapEncoder,
        Object: cidEncoder,
        undefined: undefinedEncoder,
        number: numberEncoder
    }
};
const encodeOptions = {
    ..._encodeOptions,
    typeEncoders: {
        ..._encodeOptions.typeEncoders
    }
};
/**
 * @param {Uint8Array} bytes
 * @returns {CID}
 */ function cidDecoder(bytes) {
    if (bytes[0] !== 0) {
        throw new Error('Invalid CID for CBOR tag 42; expected leading 0x00');
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].decode(bytes.subarray(1)) // ignore leading 0x00
    ;
}
const _decodeOptions = {
    allowIndefinite: false,
    coerceUndefinedToNull: true,
    allowNaN: false,
    allowInfinity: false,
    allowBigInt: true,
    // safe-integer range, which may surprise users
    strict: true,
    useMaps: false,
    rejectDuplicateMapKeys: true,
    /** @type {import('cborg').TagDecoder[]} */ tags: []
};
_decodeOptions.tags[CID_CBOR_TAG] = cidDecoder;
const decodeOptions = {
    ..._decodeOptions,
    tags: _decodeOptions.tags.slice()
};
const name = 'dag-cbor';
const code = 0x71;
const encode = (node)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$encode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"](node, _encodeOptions);
const decode = (data)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$decode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](toByteView(data), _decodeOptions);
}),
"[project]/node_modules/@ipld/dag-json/src/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* eslint max-depth: ["error", 7] */ __turbopack_context__.s([
    "code",
    ()=>code,
    "decode",
    ()=>decode,
    "encode",
    ()=>encode,
    "format",
    ()=>format,
    "name",
    ()=>name,
    "parse",
    ()=>parse,
    "stringify",
    ()=>format
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$cborg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/cborg/cborg.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cborg/lib/token.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$json$2f$json$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/cborg/lib/json/json.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$json$2f$decode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cborg/lib/json/decode.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$json$2f$encode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cborg/lib/json/encode.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/cid.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base64.js [app-client] (ecmascript)");
;
;
;
;
/**
 * @template T
 * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView
 */ /**
 * @template T
 * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView
 */ /**
 * @template T
 * @typedef {import('multiformats').ToString<T>} ToString
 */ /**
 * @typedef {import('cborg/interface').DecodeTokenizer} DecodeTokenizer
 */ /**
 * @template T
 * @param {ByteView<T> | ArrayBufferView<T>} buf
 * @returns {ByteView<T>}
 */ function toByteView(buf) {
    if (buf instanceof ArrayBuffer) {
        return new Uint8Array(buf, 0, buf.byteLength);
    }
    return buf;
}
/**
 * cidEncoder will receive all Objects during encode, it needs to filter out
 * anything that's not a CID and return `null` for that so it's encoded as
 * normal. Encoding a CID means replacing it with a `{"/":"<CidString>}`
 * object as per the DAG-JSON spec.
 *
 * @param {any} obj
 * @returns {Token[]|null}
 */ function cidEncoder(obj) {
    if (obj.asCID !== obj && obj['/'] !== obj.bytes) {
        return null // any other kind of object
        ;
    }
    const cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].asCID(obj);
    /* c8 ignore next 4 */ // very unlikely case, and it'll probably throw a recursion error in cborg
    if (!cid) {
        return null;
    }
    const cidString = cid.toString();
    return [
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].map, Infinity, 1),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].string, '/', 1),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].string, cidString, cidString.length),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].break, undefined, 1)
    ];
}
/**
 * bytesEncoder will receive all Uint8Arrays (and friends) during encode, it
 * needs to replace it with a `{"/":{"bytes":"Base64ByteString"}}` object as
 * per the DAG-JSON spec.
 *
 * @param {Uint8Array} bytes
 * @returns {Token[]|null}
 */ function bytesEncoder(bytes) {
    const bytesString = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64"].encode(bytes).slice(1) // no mbase prefix
    ;
    return [
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].map, Infinity, 1),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].string, '/', 1),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].map, Infinity, 1),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].string, 'bytes', 5),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].string, bytesString, bytesString.length),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].break, undefined, 1),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].break, undefined, 1)
    ];
}
/**
 * taBytesEncoder wraps bytesEncoder() but for the more exotic typed arrays so
 * that we access the underlying ArrayBuffer data
 *
 * @param {Int8Array|Uint16Array|Int16Array|Uint32Array|Int32Array|Float32Array|Float64Array|Uint8ClampedArray|BigInt64Array|BigUint64Array} obj
 * @returns {Token[]|null}
 */ function taBytesEncoder(obj) {
    return bytesEncoder(new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
}
/**
 * abBytesEncoder wraps bytesEncoder() but for plain ArrayBuffers
 *
 * @param {ArrayBuffer} ab
 * @returns {Token[]|null}
 */ function abBytesEncoder(ab) {
    return bytesEncoder(new Uint8Array(ab));
}
// eslint-disable-next-line jsdoc/require-returns-check
/**
 * Intercept all `undefined` values from an object walk and reject the entire
 * object if we find one.
 *
 * @returns {null}
 */ function undefinedEncoder() {
    throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded');
}
/**
 * Intercept all `number` values from an object walk and reject the entire
 * object if we find something that doesn't fit the IPLD data model (NaN &
 * Infinity).
 *
 * @param {number} num
 * @returns {null}
 */ function numberEncoder(num) {
    if (Number.isNaN(num)) {
        throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded');
    }
    if (num === Infinity || num === -Infinity) {
        throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded');
    }
    return null // process with standard number encoder
    ;
}
const encodeOptions = {
    typeEncoders: {
        Object: cidEncoder,
        Buffer: bytesEncoder,
        Uint8Array: bytesEncoder,
        Int8Array: taBytesEncoder,
        Uint16Array: taBytesEncoder,
        Int16Array: taBytesEncoder,
        Uint32Array: taBytesEncoder,
        Int32Array: taBytesEncoder,
        Float32Array: taBytesEncoder,
        Float64Array: taBytesEncoder,
        Uint8ClampedArray: taBytesEncoder,
        BigInt64Array: taBytesEncoder,
        BigUint64Array: taBytesEncoder,
        DataView: taBytesEncoder,
        ArrayBuffer: abBytesEncoder,
        undefined: undefinedEncoder,
        number: numberEncoder
    }
};
/**
 * @implements {DecodeTokenizer}
 */ class DagJsonTokenizer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$json$2f$decode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tokenizer"] {
    /**
   * @param {Uint8Array} data
   * @param {object} [options]
   */ constructor(data, options){
        super(data, options);
        /** @type {Token[]} */ this.tokenBuffer = [];
    }
    /**
   * @returns {boolean}
   */ done() {
        return this.tokenBuffer.length === 0 && super.done();
    }
    /**
   * @returns {Token}
   */ _next() {
        if (this.tokenBuffer.length > 0) {
            // @ts-ignore https://github.com/Microsoft/TypeScript/issues/30406
            return this.tokenBuffer.pop();
        }
        return super.next();
    }
    /**
   * Implements rules outlined in https://github.com/ipld/specs/pull/356
   *
   * @returns {Token}
   */ next() {
        const token = this._next();
        if (token.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].map) {
            const keyToken = this._next();
            if (keyToken.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].string && keyToken.value === '/') {
                const valueToken = this._next();
                if (valueToken.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].string) {
                    const breakToken = this._next() // swallow the end-of-map token
                    ;
                    if (breakToken.type !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].break) {
                        throw new Error('Invalid encoded CID form');
                    }
                    this.tokenBuffer.push(valueToken); // CID.parse will pick this up after our tag token
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].tag, 42, 0);
                }
                if (valueToken.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].map) {
                    const innerKeyToken = this._next();
                    if (innerKeyToken.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].string && innerKeyToken.value === 'bytes') {
                        const innerValueToken = this._next();
                        if (innerValueToken.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].string) {
                            for(let i = 0; i < 2; i++){
                                const breakToken = this._next() // swallow two end-of-map tokens
                                ;
                                if (breakToken.type !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].break) {
                                    throw new Error('Invalid encoded Bytes form');
                                }
                            }
                            const bytes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64"].decode(`m${innerValueToken.value}`);
                            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].bytes, bytes, innerValueToken.value.length);
                        }
                        this.tokenBuffer.push(innerValueToken); // bail
                    }
                    this.tokenBuffer.push(innerKeyToken); // bail
                }
                this.tokenBuffer.push(valueToken); // bail
            }
            this.tokenBuffer.push(keyToken); // bail
        }
        return token;
    }
}
const decodeOptions = {
    allowIndefinite: false,
    allowUndefined: false,
    allowNaN: false,
    allowInfinity: false,
    allowBigInt: true,
    // safe-integer range, which may surprise users
    strict: true,
    useMaps: false,
    rejectDuplicateMapKeys: true,
    /** @type {import('cborg').TagDecoder[]} */ tags: []
};
// we're going to get TAG(42)STRING("bafy...") from the tokenizer so we only need
// to deal with the STRING("bafy...") at this point
decodeOptions.tags[42] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].parse;
const name = 'dag-json';
const code = 0x0129;
const encode = (node)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$json$2f$encode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"](node, encodeOptions);
const decode = (data)=>{
    const buf = toByteView(data);
    // the tokenizer is stateful so we need a single instance of it
    const options = Object.assign(decodeOptions, {
        tokenizer: new DagJsonTokenizer(buf, decodeOptions)
    });
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$json$2f$decode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](buf, options);
};
const format = (node)=>utf8Decoder.decode(encode(node));
;
const utf8Decoder = new TextDecoder();
const parse = (data)=>decode(utf8Encoder.encode(data));
const utf8Encoder = new TextEncoder();
}),
"[project]/node_modules/varint/encode.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = encode;
var MSB = 0x80, REST = 0x7F, MSBALL = ~REST, INT = Math.pow(2, 31);
function encode(num, out, offset) {
    if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
        encode.bytes = 0;
        throw new RangeError('Could not encode varint');
    }
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while(num >= INT){
        out[offset++] = num & 0xFF | MSB;
        num /= 128;
    }
    while(num & MSBALL){
        out[offset++] = num & 0xFF | MSB;
        num >>>= 7;
    }
    out[offset] = num | 0;
    encode.bytes = offset - oldOffset + 1;
    return out;
}
}),
"[project]/node_modules/varint/decode.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = read;
var MSB = 0x80, REST = 0x7F;
function read(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
        if (counter >= l || shift > 49) {
            read.bytes = 0;
            throw new RangeError('Could not decode varint');
        }
        b = buf[counter++];
        res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
        shift += 7;
    }while (b >= MSB)
    read.bytes = counter - offset;
    return res;
}
}),
"[project]/node_modules/varint/length.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

var N1 = Math.pow(2, 7);
var N2 = Math.pow(2, 14);
var N3 = Math.pow(2, 21);
var N4 = Math.pow(2, 28);
var N5 = Math.pow(2, 35);
var N6 = Math.pow(2, 42);
var N7 = Math.pow(2, 49);
var N8 = Math.pow(2, 56);
var N9 = Math.pow(2, 63);
module.exports = function(value) {
    return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
};
}),
"[project]/node_modules/varint/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = {
    encode: __turbopack_context__.r("[project]/node_modules/varint/encode.js [app-client] (ecmascript)"),
    decode: __turbopack_context__.r("[project]/node_modules/varint/decode.js [app-client] (ecmascript)"),
    encodingLength: __turbopack_context__.r("[project]/node_modules/varint/length.js [app-client] (ecmascript)")
};
}),
"[project]/node_modules/@ipld/car/src/decoder-common.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CIDV0_BYTES",
    ()=>CIDV0_BYTES,
    "V2_HEADER_LENGTH",
    ()=>V2_HEADER_LENGTH,
    "decodeV2Header",
    ()=>decodeV2Header,
    "decodeVarint",
    ()=>decodeVarint,
    "getMultihashLength",
    ()=>getMultihashLength
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/varint/index.js [app-client] (ecmascript)");
;
const CIDV0_BYTES = {
    SHA2_256: 0x12,
    LENGTH: 0x20,
    DAG_PB: 0x70
};
const V2_HEADER_LENGTH = /* characteristics */ 16 /* v1 offset */  + 8 /* v1 size */  + 8 /* index offset */  + 8;
function decodeVarint(bytes, seeker) {
    if (!bytes.length) {
        throw new Error('Unexpected end of data');
    }
    const i = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].decode(bytes);
    seeker.seek(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].decode.bytes);
    return i;
}
function decodeV2Header(bytes) {
    const dv = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    let offset = 0;
    const header = {
        version: 2,
        /** @type {[bigint, bigint]} */ characteristics: [
            dv.getBigUint64(offset, true),
            dv.getBigUint64(offset += 8, true)
        ],
        dataOffset: Number(dv.getBigUint64(offset += 8, true)),
        dataSize: Number(dv.getBigUint64(offset += 8, true)),
        indexOffset: Number(dv.getBigUint64(offset += 8, true))
    };
    return header;
}
function getMultihashLength(bytes) {
    // | code | length | .... |
    // where both code and length are varints, so we have to decode
    // them first before we can know total length
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].decode(bytes); // code
    const codeLength = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].decode.bytes;
    const length = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].decode(bytes.subarray(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].decode.bytes));
    const lengthLength = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].decode.bytes;
    const mhLength = codeLength + lengthLength + length;
    return mhLength;
}
}),
"[project]/node_modules/@ipld/car/src/header-validator.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* eslint-disable jsdoc/check-indentation, max-depth */ /**
 * Auto-generated with @ipld/schema@v4.2.0 at Thu Sep 14 2023 from IPLD Schema:
 *
 * # CarV1HeaderOrV2Pragma is a more relaxed form, and can parse {version:x} where
 * # roots are optional. This is typically useful for the {verison:2} CARv2
 * # pragma.
 *
 * type CarV1HeaderOrV2Pragma struct {
 *   roots optional [&Any]
 *   # roots is _not_ optional for CarV1 but we defer that check within code to
 *   # gracefully handle the V2 case where it's just {version:X}
 *   version Int
 * }
 *
 * # CarV1Header is the strict form of the header, and requires roots to be
 * # present. This is compatible with the CARv1 specification.
 *
 * # type CarV1Header struct {
 * #   roots [&Any]
 * #   version Int
 * # }
 *
 */ __turbopack_context__.s([
    "CarV1HeaderOrV2Pragma",
    ()=>CarV1HeaderOrV2Pragma
]);
const Kinds = {
    Null: /**
         * @param obj
         * @returns {undefined|null}
         */ (/** @type {any} */ obj)=>obj === null ? obj : undefined,
    Int: /**
        * @param obj
        * @returns {undefined|number}
        */ (/** @type {any} */ obj)=>Number.isInteger(obj) ? obj : undefined,
    Float: /**
          * @param obj
          * @returns {undefined|number}
          */ (/** @type {any} */ obj)=>typeof obj === 'number' && Number.isFinite(obj) ? obj : undefined,
    String: /**
           * @param obj
           * @returns {undefined|string}
           */ (/** @type {any} */ obj)=>typeof obj === 'string' ? obj : undefined,
    Bool: /**
         * @param obj
         * @returns {undefined|boolean}
         */ (/** @type {any} */ obj)=>typeof obj === 'boolean' ? obj : undefined,
    Bytes: /**
          * @param obj
          * @returns {undefined|Uint8Array}
          */ (/** @type {any} */ obj)=>obj instanceof Uint8Array ? obj : undefined,
    Link: /**
         * @param obj
         * @returns {undefined|object}
         */ (/** @type {any} */ obj)=>obj !== null && typeof obj === 'object' && obj.asCID === obj ? obj : undefined,
    List: /**
         * @param obj
         * @returns {undefined|Array<any>}
         */ (/** @type {any} */ obj)=>Array.isArray(obj) ? obj : undefined,
    Map: /**
        * @param obj
        * @returns {undefined|object}
        */ (/** @type {any} */ obj)=>obj !== null && typeof obj === 'object' && obj.asCID !== obj && !Array.isArray(obj) && !(obj instanceof Uint8Array) ? obj : undefined
};
/** @type {{ [k in string]: (obj:any)=>undefined|any}} */ const Types = {
    'CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)': Kinds.Link,
    'CarV1HeaderOrV2Pragma > roots (anon)': /**
                                           * @param obj
                                           * @returns {undefined|any}
                                           */ (/** @type {any} */ obj)=>{
        if (Kinds.List(obj) === undefined) {
            return undefined;
        }
        for(let i = 0; i < obj.length; i++){
            let v = obj[i];
            v = Types['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v);
            if (v === undefined) {
                return undefined;
            }
            if (v !== obj[i]) {
                const ret = obj.slice(0, i);
                for(let j = i; j < obj.length; j++){
                    let v = obj[j];
                    v = Types['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v);
                    if (v === undefined) {
                        return undefined;
                    }
                    ret.push(v);
                }
                return ret;
            }
        }
        return obj;
    },
    Int: Kinds.Int,
    CarV1HeaderOrV2Pragma: /**
                          * @param obj
                          * @returns {undefined|any}
                          */ (/** @type {any} */ obj)=>{
        if (Kinds.Map(obj) === undefined) {
            return undefined;
        }
        const entries = Object.entries(obj);
        /** @type {{[k in string]: any}} */ let ret = obj;
        let requiredCount = 1;
        for(let i = 0; i < entries.length; i++){
            const [key, value] = entries[i];
            switch(key){
                case 'roots':
                    {
                        const v = Types['CarV1HeaderOrV2Pragma > roots (anon)'](obj[key]);
                        if (v === undefined) {
                            return undefined;
                        }
                        if (v !== value || ret !== obj) {
                            if (ret === obj) {
                                /** @type {{[k in string]: any}} */ ret = {};
                                for(let j = 0; j < i; j++){
                                    ret[entries[j][0]] = entries[j][1];
                                }
                            }
                            ret.roots = v;
                        }
                    }
                    break;
                case 'version':
                    {
                        requiredCount--;
                        const v = Types.Int(obj[key]);
                        if (v === undefined) {
                            return undefined;
                        }
                        if (v !== value || ret !== obj) {
                            if (ret === obj) {
                                /** @type {{[k in string]: any}} */ ret = {};
                                for(let j = 0; j < i; j++){
                                    ret[entries[j][0]] = entries[j][1];
                                }
                            }
                            ret.version = v;
                        }
                    }
                    break;
                default:
                    return undefined;
            }
        }
        if (requiredCount > 0) {
            return undefined;
        }
        return ret;
    }
};
/** @type {{ [k in string]: (obj:any)=>undefined|any}} */ const Reprs = {
    'CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)': Kinds.Link,
    'CarV1HeaderOrV2Pragma > roots (anon)': /**
                                           * @param obj
                                           * @returns {undefined|any}
                                           */ (/** @type {any} */ obj)=>{
        if (Kinds.List(obj) === undefined) {
            return undefined;
        }
        for(let i = 0; i < obj.length; i++){
            let v = obj[i];
            v = Reprs['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v);
            if (v === undefined) {
                return undefined;
            }
            if (v !== obj[i]) {
                const ret = obj.slice(0, i);
                for(let j = i; j < obj.length; j++){
                    let v = obj[j];
                    v = Reprs['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v);
                    if (v === undefined) {
                        return undefined;
                    }
                    ret.push(v);
                }
                return ret;
            }
        }
        return obj;
    },
    Int: Kinds.Int,
    CarV1HeaderOrV2Pragma: /**
                          * @param obj
                          * @returns {undefined|any}
                          */ (/** @type {any} */ obj)=>{
        if (Kinds.Map(obj) === undefined) {
            return undefined;
        }
        const entries = Object.entries(obj);
        /** @type {{[k in string]: any}} */ let ret = obj;
        let requiredCount = 1;
        for(let i = 0; i < entries.length; i++){
            const [key, value] = entries[i];
            switch(key){
                case 'roots':
                    {
                        const v = Reprs['CarV1HeaderOrV2Pragma > roots (anon)'](value);
                        if (v === undefined) {
                            return undefined;
                        }
                        if (v !== value || ret !== obj) {
                            if (ret === obj) {
                                /** @type {{[k in string]: any}} */ ret = {};
                                for(let j = 0; j < i; j++){
                                    ret[entries[j][0]] = entries[j][1];
                                }
                            }
                            ret.roots = v;
                        }
                    }
                    break;
                case 'version':
                    {
                        requiredCount--;
                        const v = Reprs.Int(value);
                        if (v === undefined) {
                            return undefined;
                        }
                        if (v !== value || ret !== obj) {
                            if (ret === obj) {
                                /** @type {{[k in string]: any}} */ ret = {};
                                for(let j = 0; j < i; j++){
                                    ret[entries[j][0]] = entries[j][1];
                                }
                            }
                            ret.version = v;
                        }
                    }
                    break;
                default:
                    return undefined;
            }
        }
        if (requiredCount > 0) {
            return undefined;
        }
        return ret;
    }
};
const CarV1HeaderOrV2Pragma = {
    toTyped: Types.CarV1HeaderOrV2Pragma,
    toRepresentation: Reprs.CarV1HeaderOrV2Pragma
};
}),
"[project]/node_modules/@ipld/car/src/buffer-decoder.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "bytesReader",
    ()=>bytesReader,
    "fromBytes",
    ()=>fromBytes,
    "limitReader",
    ()=>limitReader,
    "readBlockHead",
    ()=>readBlockHead,
    "readHeader",
    ()=>readHeader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-cbor/src/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/cid.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/hashes/digest.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/decoder-common.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$header$2d$validator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/header-validator.js [app-client] (ecmascript)");
;
;
;
;
;
function readHeader(reader, strictVersion) {
    const length = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeVarint"])(reader.upTo(8), reader);
    if (length === 0) {
        throw new Error('Invalid CAR header (zero length)');
    }
    const header = reader.exactly(length, true);
    const block = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])(header);
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$header$2d$validator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CarV1HeaderOrV2Pragma"].toTyped(block) === undefined) {
        throw new Error('Invalid CAR header format');
    }
    if (block.version !== 1 && block.version !== 2 || strictVersion !== undefined && block.version !== strictVersion) {
        throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== undefined ? ` (expected ${strictVersion})` : ''}`);
    }
    if (block.version === 1) {
        // CarV1HeaderOrV2Pragma makes roots optional, let's make it mandatory
        if (!Array.isArray(block.roots)) {
            throw new Error('Invalid CAR header format');
        }
        return block;
    }
    // version 2
    if (block.roots !== undefined) {
        throw new Error('Invalid CAR header format');
    }
    const v2Header = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeV2Header"])(reader.exactly(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["V2_HEADER_LENGTH"], true));
    reader.seek(v2Header.dataOffset - reader.pos);
    const v1Header = readHeader(reader, 1);
    return Object.assign(v1Header, v2Header);
}
/**
 * Reads CID sync
 *
 * @param {BytesBufferReader} reader
 * @returns {CID}
 */ function readCid(reader) {
    const first = reader.exactly(2, false);
    if (first[0] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CIDV0_BYTES"].SHA2_256 && first[1] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CIDV0_BYTES"].LENGTH) {
        // cidv0 32-byte sha2-256
        const bytes = reader.exactly(34, true);
        const multihash = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](bytes);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].create(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CIDV0_BYTES"].DAG_PB, multihash);
    }
    const version = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeVarint"])(reader.upTo(8), reader);
    if (version !== 1) {
        throw new Error(`Unexpected CID version (${version})`);
    }
    const codec = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeVarint"])(reader.upTo(8), reader);
    const bytes = reader.exactly((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getMultihashLength"])(reader.upTo(8)), true);
    const multihash = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](bytes);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].create(version, codec, multihash);
}
function readBlockHead(reader) {
    // length includes a CID + Binary, where CID has a variable length
    // we have to deal with
    const start = reader.pos;
    let length = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeVarint"])(reader.upTo(8), reader);
    if (length === 0) {
        throw new Error('Invalid CAR section (zero length)');
    }
    length += reader.pos - start;
    const cid = readCid(reader);
    const blockLength = length - Number(reader.pos - start) // subtract CID length
    ;
    return {
        cid,
        length,
        blockLength
    };
}
function fromBytes(bytes) {
    let reader = bytesReader(bytes);
    const header = readHeader(reader);
    if (header.version === 2) {
        const v1length = reader.pos - header.dataOffset;
        reader = limitReader(reader, header.dataSize - v1length);
    }
    const blocks = [];
    while(reader.upTo(8).length > 0){
        const { cid, blockLength } = readBlockHead(reader);
        blocks.push({
            cid,
            bytes: reader.exactly(blockLength, true)
        });
    }
    return {
        header,
        blocks
    };
}
function bytesReader(bytes) {
    let pos = 0;
    /** @type {BytesBufferReader} */ return {
        upTo (length) {
            return bytes.subarray(pos, pos + Math.min(length, bytes.length - pos));
        },
        exactly (length, seek = false) {
            if (length > bytes.length - pos) {
                throw new Error('Unexpected end of data');
            }
            const out = bytes.subarray(pos, pos + length);
            if (seek) {
                pos += length;
            }
            return out;
        },
        seek (length) {
            pos += length;
        },
        get pos () {
            return pos;
        }
    };
}
function limitReader(reader, byteLimit) {
    let bytesRead = 0;
    /** @type {BytesBufferReader} */ return {
        upTo (length) {
            let bytes = reader.upTo(length);
            if (bytes.length + bytesRead > byteLimit) {
                bytes = bytes.subarray(0, byteLimit - bytesRead);
            }
            return bytes;
        },
        exactly (length, seek = false) {
            const bytes = reader.exactly(length, seek);
            if (bytes.length + bytesRead > byteLimit) {
                throw new Error('Unexpected end of data');
            }
            if (seek) {
                bytesRead += length;
            }
            return bytes;
        },
        seek (length) {
            bytesRead += length;
            reader.seek(length);
        },
        get pos () {
            return reader.pos;
        }
    };
}
}),
"[project]/node_modules/@ipld/car/src/buffer-reader-browser.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CarBufferReader",
    ()=>CarBufferReader,
    "__browser",
    ()=>__browser
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$buffer$2d$decoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/buffer-decoder.js [app-client] (ecmascript)");
;
class CarBufferReader {
    /**
   * @constructs CarBufferReader
   * @param {CarHeader|CarV2Header} header
   * @param {Block[]} blocks
   */ constructor(header, blocks){
        this._header = header;
        this._blocks = blocks;
        this._cids = undefined;
    }
    /**
   * @property {number} version of the CAR
   * @memberof CarBufferReader
   * @instance
   */ get version() {
        return this._header.version;
    }
    /**
   * Get the list of roots defined by the CAR referenced by this reader. May be
   * zero or more `CID`s.
   *
   * @function
   * @memberof CarBufferReader
   * @instance
   * @returns {CID[]}
   */ getRoots() {
        return this._header.roots;
    }
    /**
   * Check whether a given `CID` exists within the CAR referenced by this
   * reader.
   *
   * @function
   * @memberof CarBufferReader
   * @instance
   * @param {CID} key
   * @returns {boolean}
   */ has(key) {
        return this._blocks.some((b)=>b.cid.equals(key));
    }
    /**
   * Fetch a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) from the CAR
   * referenced by this reader matching the provided `CID`. In the case where
   * the provided `CID` doesn't exist within the CAR, `undefined` will be
   * returned.
   *
   * @function
   * @memberof CarBufferReader
   * @instance
   * @param {CID} key
   * @returns {Block | undefined}
   */ get(key) {
        return this._blocks.find((b)=>b.cid.equals(key));
    }
    /**
   * Returns a `Block[]` of the `Block`s (`{ cid:CID, bytes:Uint8Array }` pairs) contained within
   * the CAR referenced by this reader.
   *
   * @function
   * @memberof CarBufferReader
   * @instance
   * @returns {Block[]}
   */ blocks() {
        return this._blocks;
    }
    /**
   * Returns a `CID[]` of the `CID`s contained within the CAR referenced by this reader.
   *
   * @function
   * @memberof CarBufferReader
   * @instance
   * @returns {CID[]}
   */ cids() {
        if (!this._cids) {
            this._cids = this._blocks.map((b)=>b.cid);
        }
        return this._cids;
    }
    /**
   * Instantiate a {@link CarBufferReader} from a `Uint8Array` blob. This performs a
   * decode fully in memory and maintains the decoded state in memory for full
   * access to the data via the `CarReader` API.
   *
   * @static
   * @memberof CarBufferReader
   * @param {Uint8Array} bytes
   * @returns {CarBufferReader}
   */ static fromBytes(bytes) {
        if (!(bytes instanceof Uint8Array)) {
            throw new TypeError('fromBytes() requires a Uint8Array');
        }
        const { header, blocks } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$buffer$2d$decoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromBytes"](bytes);
        return new CarBufferReader(header, blocks);
    }
}
const __browser = true;
}),
"[project]/node_modules/@ipld/car/src/buffer-writer.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "addBlock",
    ()=>addBlock,
    "addRoot",
    ()=>addRoot,
    "blockLength",
    ()=>blockLength,
    "calculateHeaderLength",
    ()=>calculateHeaderLength,
    "close",
    ()=>close,
    "createWriter",
    ()=>createWriter,
    "estimateHeaderLength",
    ()=>estimateHeaderLength,
    "headerLength",
    ()=>headerLength,
    "resizeHeader",
    ()=>resizeHeader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-cbor/src/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$cborg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/cborg/cborg.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cborg/lib/token.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$length$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cborg/lib/length.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/varint/index.js [app-client] (ecmascript)");
;
;
;
;
/**
 * @typedef {import('./api.js').CID} CID
 * @typedef {import('./api.js').Block} Block
 * @typedef {import('./api.js').CarBufferWriter} Writer
 * @typedef {import('./api.js').CarBufferWriterOptions} Options
 * @typedef {import('./coding.js').CarEncoder} CarEncoder
 */ /**
 * A simple CAR writer that writes to a pre-allocated buffer.
 *
 * @class
 * @name CarBufferWriter
 * @implements {Writer}
 */ class CarBufferWriter {
    /**
   * @param {Uint8Array} bytes
   * @param {number} headerSize
   */ constructor(bytes, headerSize){
        /** @readonly */ this.bytes = bytes;
        this.byteOffset = headerSize;
        /**
     * @readonly
     * @type {CID[]}
     */ this.roots = [];
        this.headerSize = headerSize;
    }
    /**
   * Add a root to this writer, to be used to create a header when the CAR is
   * finalized with {@link CarBufferWriter.close `close()`}
   *
   * @param {CID} root
   * @param {{resize?:boolean}} [options]
   * @returns {CarBufferWriter}
   */ addRoot(root, options) {
        addRoot(this, root, options);
        return this;
    }
    /**
   * Write a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) to the archive.
   * Throws if there is not enough capacity.
   *
   * @param {Block} block - A `{ cid:CID, bytes:Uint8Array }` pair.
   * @returns {CarBufferWriter}
   */ write(block) {
        addBlock(this, block);
        return this;
    }
    /**
   * Finalize the CAR and return it as a `Uint8Array`.
   *
   * @param {object} [options]
   * @param {boolean} [options.resize]
   * @returns {Uint8Array}
   */ close(options) {
        return close(this, options);
    }
}
const addRoot = (writer, root, options = {})=>{
    const { resize = false } = options;
    const { bytes, headerSize, byteOffset, roots } = writer;
    writer.roots.push(root);
    const size = headerLength(writer);
    // If there is not enough space for the new root
    if (size > headerSize) {
        // Check if we root would fit if we were to resize the head.
        if (size - headerSize + byteOffset < bytes.byteLength) {
            // If resize is enabled resize head
            if (resize) {
                resizeHeader(writer, size);
            // otherwise remove head and throw an error suggesting to resize
            } else {
                roots.pop();
                throw new RangeError(`Header of size ${headerSize} has no capacity for new root ${root}.
  However there is a space in the buffer and you could call addRoot(root, { resize: root }) to resize header to make a space for this root.`);
            }
        // If head would not fit even with resize pop new root and throw error
        } else {
            roots.pop();
            throw new RangeError(`Buffer has no capacity for a new root ${root}`);
        }
    }
};
const blockLength = ({ cid, bytes })=>{
    const size = cid.bytes.byteLength + bytes.byteLength;
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].encodingLength(size) + size;
};
const addBlock = (writer, { cid, bytes })=>{
    const byteLength = cid.bytes.byteLength + bytes.byteLength;
    const size = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].encode(byteLength);
    if (writer.byteOffset + size.length + byteLength > writer.bytes.byteLength) {
        throw new RangeError('Buffer has no capacity for this block');
    } else {
        writeBytes(writer, size);
        writeBytes(writer, cid.bytes);
        writeBytes(writer, bytes);
    }
};
const close = (writer, options = {})=>{
    const { resize = false } = options;
    const { roots, bytes, byteOffset, headerSize } = writer;
    const headerBytes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"]({
        version: 1,
        roots
    });
    const varintBytes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].encode(headerBytes.length);
    const size = varintBytes.length + headerBytes.byteLength;
    const offset = headerSize - size;
    // If header size estimate was accurate we just write header and return
    // view into buffer.
    if (offset === 0) {
        writeHeader(writer, varintBytes, headerBytes);
        return bytes.subarray(0, byteOffset);
    // If header was overestimated and `{resize: true}` is passed resize header
    } else if (resize) {
        resizeHeader(writer, size);
        writeHeader(writer, varintBytes, headerBytes);
        return bytes.subarray(0, writer.byteOffset);
    } else {
        throw new RangeError(`Header size was overestimated.
You can use close({ resize: true }) to resize header`);
    }
};
const resizeHeader = (writer, byteLength)=>{
    const { bytes, headerSize } = writer;
    // Move data section to a new offset
    bytes.set(bytes.subarray(headerSize, writer.byteOffset), byteLength);
    // Update header size & byteOffset
    writer.byteOffset += byteLength - headerSize;
    writer.headerSize = byteLength;
};
/**
 * @param {CarBufferWriter} writer
 * @param {number[]|Uint8Array} bytes
 */ const writeBytes = (writer, bytes)=>{
    writer.bytes.set(bytes, writer.byteOffset);
    writer.byteOffset += bytes.length;
};
/**
 * @param {{bytes:Uint8Array}} writer
 * @param {number[]} varint
 * @param {Uint8Array} header
 */ const writeHeader = ({ bytes }, varint, header)=>{
    bytes.set(varint);
    bytes.set(header, varint.length);
};
const headerPreludeTokens = [
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].map, 2),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].string, 'version'),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].uint, 1),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].string, 'roots')
];
const CID_TAG = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].tag, 42);
const calculateHeaderLength = (rootLengths)=>{
    const tokens = [
        ...headerPreludeTokens
    ];
    tokens.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].array, rootLengths.length));
    for (const rootLength of rootLengths){
        tokens.push(CID_TAG);
        tokens.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].bytes, {
            length: rootLength + 1
        }));
    }
    const length = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$length$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["tokensToLength"])(tokens) // no options needed here because we have simple tokens
    ;
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].encodingLength(length) + length;
};
const headerLength = ({ roots })=>calculateHeaderLength(roots.map((cid)=>cid.bytes.byteLength));
const estimateHeaderLength = (rootCount, rootByteLength = 36)=>calculateHeaderLength(new Array(rootCount).fill(rootByteLength));
const createWriter = (buffer, options = {})=>{
    const { roots = [], byteOffset = 0, byteLength = buffer.byteLength, headerSize = headerLength({
        roots
    }) } = options;
    const bytes = new Uint8Array(buffer, byteOffset, byteLength);
    const writer = new CarBufferWriter(bytes, headerSize);
    for (const root of roots){
        writer.addRoot(root);
    }
    return writer;
};
}),
"[project]/node_modules/@ipld/car/src/indexed-reader-browser.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CarIndexedReader",
    ()=>CarIndexedReader,
    "__browser",
    ()=>__browser
]);
class CarIndexedReader {
    static async fromFile() {
        throw new Error('Unsupported in this environment');
    }
}
const __browser = true;
}),
"[project]/node_modules/@ipld/car/src/decoder.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "asyncIterableReader",
    ()=>asyncIterableReader,
    "bytesReader",
    ()=>bytesReader,
    "chunkReader",
    ()=>chunkReader,
    "createDecoder",
    ()=>createDecoder,
    "limitReader",
    ()=>limitReader,
    "readBlockHead",
    ()=>readBlockHead,
    "readHeader",
    ()=>readHeader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-cbor/src/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/cid.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/hashes/digest.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/decoder-common.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$header$2d$validator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/header-validator.js [app-client] (ecmascript)");
;
;
;
;
;
async function readHeader(reader, strictVersion) {
    const length = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeVarint"])(await reader.upTo(8), reader);
    if (length === 0) {
        throw new Error('Invalid CAR header (zero length)');
    }
    const header = await reader.exactly(length, true);
    const block = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])(header);
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$header$2d$validator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CarV1HeaderOrV2Pragma"].toTyped(block) === undefined) {
        throw new Error('Invalid CAR header format');
    }
    if (block.version !== 1 && block.version !== 2 || strictVersion !== undefined && block.version !== strictVersion) {
        throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== undefined ? ` (expected ${strictVersion})` : ''}`);
    }
    if (block.version === 1) {
        // CarV1HeaderOrV2Pragma makes roots optional, let's make it mandatory
        if (!Array.isArray(block.roots)) {
            throw new Error('Invalid CAR header format');
        }
        return block;
    }
    // version 2
    if (block.roots !== undefined) {
        throw new Error('Invalid CAR header format');
    }
    const v2Header = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeV2Header"])(await reader.exactly(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["V2_HEADER_LENGTH"], true));
    reader.seek(v2Header.dataOffset - reader.pos);
    const v1Header = await readHeader(reader, 1);
    return Object.assign(v1Header, v2Header);
}
/**
 * @param {BytesReader} reader
 * @returns {Promise<CID>}
 */ async function readCid(reader) {
    const first = await reader.exactly(2, false);
    if (first[0] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CIDV0_BYTES"].SHA2_256 && first[1] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CIDV0_BYTES"].LENGTH) {
        // cidv0 32-byte sha2-256
        const bytes = await reader.exactly(34, true);
        const multihash = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](bytes);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].create(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CIDV0_BYTES"].DAG_PB, multihash);
    }
    const version = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeVarint"])(await reader.upTo(8), reader);
    if (version !== 1) {
        throw new Error(`Unexpected CID version (${version})`);
    }
    const codec = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeVarint"])(await reader.upTo(8), reader);
    const bytes = await reader.exactly((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getMultihashLength"])(await reader.upTo(8)), true);
    const multihash = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](bytes);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].create(version, codec, multihash);
}
async function readBlockHead(reader) {
    // length includes a CID + Binary, where CID has a variable length
    // we have to deal with
    const start = reader.pos;
    let length = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeVarint"])(await reader.upTo(8), reader);
    if (length === 0) {
        throw new Error('Invalid CAR section (zero length)');
    }
    length += reader.pos - start;
    const cid = await readCid(reader);
    const blockLength = length - Number(reader.pos - start) // subtract CID length
    ;
    return {
        cid,
        length,
        blockLength
    };
}
/**
 * @param {BytesReader} reader
 * @returns {Promise<Block>}
 */ async function readBlock(reader) {
    const { cid, blockLength } = await readBlockHead(reader);
    const bytes = await reader.exactly(blockLength, true);
    return {
        bytes,
        cid
    };
}
/**
 * @param {BytesReader} reader
 * @returns {Promise<BlockIndex>}
 */ async function readBlockIndex(reader) {
    const offset = reader.pos;
    const { cid, length, blockLength } = await readBlockHead(reader);
    const index = {
        cid,
        length,
        blockLength,
        offset,
        blockOffset: reader.pos
    };
    reader.seek(index.blockLength);
    return index;
}
function createDecoder(reader) {
    const headerPromise = (async ()=>{
        const header = await readHeader(reader);
        if (header.version === 2) {
            const v1length = reader.pos - header.dataOffset;
            reader = limitReader(reader, header.dataSize - v1length);
        }
        return header;
    })();
    return {
        header: ()=>headerPromise,
        async *blocks () {
            await headerPromise;
            while((await reader.upTo(8)).length > 0){
                yield await readBlock(reader);
            }
        },
        async *blocksIndex () {
            await headerPromise;
            while((await reader.upTo(8)).length > 0){
                yield await readBlockIndex(reader);
            }
        }
    };
}
function bytesReader(bytes) {
    let pos = 0;
    /** @type {BytesReader} */ return {
        async upTo (length) {
            const out = bytes.subarray(pos, pos + Math.min(length, bytes.length - pos));
            return out;
        },
        async exactly (length, seek = false) {
            if (length > bytes.length - pos) {
                throw new Error('Unexpected end of data');
            }
            const out = bytes.subarray(pos, pos + length);
            if (seek) {
                pos += length;
            }
            return out;
        },
        seek (length) {
            pos += length;
        },
        get pos () {
            return pos;
        }
    };
}
function chunkReader(readChunk /*, closer */ ) {
    let pos = 0;
    let have = 0;
    let offset = 0;
    let currentChunk = new Uint8Array(0);
    const read = async (/** @type {number} */ length)=>{
        have = currentChunk.length - offset;
        const bufa = [
            currentChunk.subarray(offset)
        ];
        while(have < length){
            const chunk = await readChunk();
            if (chunk == null) {
                break;
            }
            /* c8 ignore next 8 */ // undo this ignore ^ when we have a fd implementation that can seek()
            if (have < 0) {
                /* c8 ignore next 4 */ // toohard to test the else
                if (chunk.length > have) {
                    bufa.push(chunk.subarray(-have));
                } // else discard
            } else {
                bufa.push(chunk);
            }
            have += chunk.length;
        }
        currentChunk = new Uint8Array(bufa.reduce((p, c)=>p + c.length, 0));
        let off = 0;
        for (const b of bufa){
            currentChunk.set(b, off);
            off += b.length;
        }
        offset = 0;
    };
    /** @type {BytesReader} */ return {
        async upTo (length) {
            if (currentChunk.length - offset < length) {
                await read(length);
            }
            return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length));
        },
        async exactly (length, seek = false) {
            if (currentChunk.length - offset < length) {
                await read(length);
            }
            if (currentChunk.length - offset < length) {
                throw new Error('Unexpected end of data');
            }
            const out = currentChunk.subarray(offset, offset + length);
            if (seek) {
                pos += length;
                offset += length;
            }
            return out;
        },
        seek (length) {
            pos += length;
            offset += length;
        },
        get pos () {
            return pos;
        }
    };
}
function asyncIterableReader(asyncIterable) {
    const iterator = asyncIterable[Symbol.asyncIterator]();
    async function readChunk() {
        const next = await iterator.next();
        if (next.done) {
            return null;
        }
        return next.value;
    }
    return chunkReader(readChunk);
}
function limitReader(reader, byteLimit) {
    let bytesRead = 0;
    /** @type {BytesReader} */ return {
        async upTo (length) {
            let bytes = await reader.upTo(length);
            if (bytes.length + bytesRead > byteLimit) {
                bytes = bytes.subarray(0, byteLimit - bytesRead);
            }
            return bytes;
        },
        async exactly (length, seek = false) {
            const bytes = await reader.exactly(length, seek);
            if (bytes.length + bytesRead > byteLimit) {
                throw new Error('Unexpected end of data');
            }
            if (seek) {
                bytesRead += length;
            }
            return bytes;
        },
        seek (length) {
            bytesRead += length;
            reader.seek(length);
        },
        get pos () {
            return reader.pos;
        }
    };
}
}),
"[project]/node_modules/@ipld/car/src/indexer.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CarIndexer",
    ()=>CarIndexer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/decoder.js [app-client] (ecmascript)");
;
class CarIndexer {
    /**
   * @param {number} version
   * @param {CID[]} roots
   * @param {AsyncGenerator<BlockIndex>} iterator
   */ constructor(version, roots, iterator){
        this._version = version;
        this._roots = roots;
        this._iterator = iterator;
    }
    get version() {
        return this._version;
    }
    /**
   * Get the list of roots defined by the CAR referenced by this indexer. May be
   * zero or more `CID`s.
   *
   * @function
   * @memberof CarIndexer
   * @instance
   * @async
   * @returns {Promise<CID[]>}
   */ async getRoots() {
        return this._roots;
    }
    /**
   * @returns {AsyncIterator<BlockIndex>}
   */ [Symbol.asyncIterator]() {
        return this._iterator;
    }
    /**
   * Instantiate a {@link CarIndexer} from a `Uint8Array` blob. Only the header
   * is decoded initially, the remainder is processed and emitted via the
   * iterator as it is consumed.
   *
   * @async
   * @static
   * @memberof CarIndexer
   * @param {Uint8Array} bytes
   * @returns {Promise<CarIndexer>}
   */ static async fromBytes(bytes) {
        if (!(bytes instanceof Uint8Array)) {
            throw new TypeError('fromBytes() requires a Uint8Array');
        }
        return decodeIndexerComplete((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bytesReader"])(bytes));
    }
    /**
   * Instantiate a {@link CarIndexer} from a `AsyncIterable<Uint8Array>`,
   * such as a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).
   * is decoded initially, the remainder is processed and emitted via the
   * iterator as it is consumed.
   *
   * @async
   * @static
   * @memberof CarIndexer
   * @param {AsyncIterable<Uint8Array>} asyncIterable
   * @returns {Promise<CarIndexer>}
   */ static async fromIterable(asyncIterable) {
        if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === 'function')) {
            throw new TypeError('fromIterable() requires an async iterable');
        }
        return decodeIndexerComplete((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asyncIterableReader"])(asyncIterable));
    }
}
/**
 * @private
 * @param {BytesReader} reader
 * @returns {Promise<CarIndexer>}
 */ async function decodeIndexerComplete(reader) {
    const decoder = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDecoder"])(reader);
    const { version, roots } = await decoder.header();
    return new CarIndexer(version, roots, decoder.blocksIndex());
}
}),
"[project]/node_modules/@ipld/car/src/iterator.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CarBlockIterator",
    ()=>CarBlockIterator,
    "CarCIDIterator",
    ()=>CarCIDIterator,
    "CarIteratorBase",
    ()=>CarIteratorBase
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/decoder.js [app-client] (ecmascript)");
;
class CarIteratorBase {
    /**
   * @param {number} version
   * @param {CID[]} roots
   * @param {AsyncIterable<Block>|void} iterable
   */ constructor(version, roots, iterable){
        this._version = version;
        this._roots = roots;
        this._iterable = iterable;
        this._decoded = false;
    }
    get version() {
        return this._version;
    }
    /**
   * @returns {Promise<CID[]>}
   */ async getRoots() {
        return this._roots;
    }
}
class CarBlockIterator extends CarIteratorBase {
    // inherited method
    /**
   * Get the list of roots defined by the CAR referenced by this iterator. May be
   * zero or more `CID`s.
   *
   * @function getRoots
   * @memberof CarBlockIterator
   * @instance
   * @async
   * @returns {Promise<CID[]>}
   */ /**
   * @returns {AsyncIterator<Block>}
   */ [Symbol.asyncIterator]() {
        if (this._decoded) {
            throw new Error('Cannot decode more than once');
        }
        /* c8 ignore next 3 */ if (!this._iterable) {
            throw new Error('Block iterable not found');
        }
        this._decoded = true;
        return this._iterable[Symbol.asyncIterator]();
    }
    /**
   * Instantiate a {@link CarBlockIterator} from a `Uint8Array` blob. Rather
   * than decoding the entire byte array prior to returning the iterator, as in
   * {@link CarReader.fromBytes}, only the header is decoded and the remainder
   * of the CAR is parsed as the `Block`s as yielded.
   *
   * @async
   * @static
   * @memberof CarBlockIterator
   * @param {Uint8Array} bytes
   * @returns {Promise<CarBlockIterator>}
   */ static async fromBytes(bytes) {
        const { version, roots, iterator } = await fromBytes(bytes);
        return new CarBlockIterator(version, roots, iterator);
    }
    /**
   * Instantiate a {@link CarBlockIterator} from a `AsyncIterable<Uint8Array>`,
   * such as a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).
   * Rather than decoding the entire byte array prior to returning the iterator,
   * as in {@link CarReader.fromIterable}, only the header is decoded and the
   * remainder of the CAR is parsed as the `Block`s as yielded.
   *
   * @async
   * @static
   * @param {AsyncIterable<Uint8Array>} asyncIterable
   * @returns {Promise<CarBlockIterator>}
   */ static async fromIterable(asyncIterable) {
        const { version, roots, iterator } = await fromIterable(asyncIterable);
        return new CarBlockIterator(version, roots, iterator);
    }
}
class CarCIDIterator extends CarIteratorBase {
    // inherited method
    /**
   * Get the list of roots defined by the CAR referenced by this iterator. May be
   * zero or more `CID`s.
   *
   * @function getRoots
   * @memberof CarCIDIterator
   * @instance
   * @async
   * @returns {Promise<CID[]>}
   */ /**
   * @returns {AsyncIterator<CID>}
   */ [Symbol.asyncIterator]() {
        if (this._decoded) {
            throw new Error('Cannot decode more than once');
        }
        /* c8 ignore next 3 */ if (!this._iterable) {
            throw new Error('Block iterable not found');
        }
        this._decoded = true;
        const iterable = this._iterable[Symbol.asyncIterator]();
        return {
            async next () {
                const next = await iterable.next();
                if (next.done) {
                    return next;
                }
                return {
                    done: false,
                    value: next.value.cid
                };
            }
        };
    }
    /**
   * Instantiate a {@link CarCIDIterator} from a `Uint8Array` blob. Rather
   * than decoding the entire byte array prior to returning the iterator, as in
   * {@link CarReader.fromBytes}, only the header is decoded and the remainder
   * of the CAR is parsed as the `CID`s as yielded.
   *
   * @async
   * @static
   * @memberof CarCIDIterator
   * @param {Uint8Array} bytes
   * @returns {Promise<CarCIDIterator>}
   */ static async fromBytes(bytes) {
        const { version, roots, iterator } = await fromBytes(bytes);
        return new CarCIDIterator(version, roots, iterator);
    }
    /**
   * Instantiate a {@link CarCIDIterator} from a `AsyncIterable<Uint8Array>`,
   * such as a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).
   * Rather than decoding the entire byte array prior to returning the iterator,
   * as in {@link CarReader.fromIterable}, only the header is decoded and the
   * remainder of the CAR is parsed as the `CID`s as yielded.
   *
   * @async
   * @static
   * @memberof CarCIDIterator
   * @param {AsyncIterable<Uint8Array>} asyncIterable
   * @returns {Promise<CarCIDIterator>}
   */ static async fromIterable(asyncIterable) {
        const { version, roots, iterator } = await fromIterable(asyncIterable);
        return new CarCIDIterator(version, roots, iterator);
    }
}
/**
 * @param {Uint8Array} bytes
 * @returns {Promise<{ version:number, roots:CID[], iterator:AsyncIterable<Block>}>}
 */ async function fromBytes(bytes) {
    if (!(bytes instanceof Uint8Array)) {
        throw new TypeError('fromBytes() requires a Uint8Array');
    }
    return decodeIterator((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bytesReader"])(bytes));
}
/**
 * @param {AsyncIterable<Uint8Array>} asyncIterable
 * @returns {Promise<{ version:number, roots:CID[], iterator:AsyncIterable<Block>}>}
 */ async function fromIterable(asyncIterable) {
    if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === 'function')) {
        throw new TypeError('fromIterable() requires an async iterable');
    }
    return decodeIterator((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asyncIterableReader"])(asyncIterable));
}
/**
 * @private
 * @param {BytesReader} reader
 * @returns {Promise<{ version:number, roots:CID[], iterator:AsyncIterable<Block>}>}
 */ async function decodeIterator(reader) {
    const decoder = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDecoder"])(reader);
    const { version, roots } = await decoder.header();
    return {
        version,
        roots,
        iterator: decoder.blocks()
    };
}
}),
"[project]/node_modules/@ipld/car/src/reader-browser.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CarReader",
    ()=>CarReader,
    "__browser",
    ()=>__browser,
    "decodeReaderComplete",
    ()=>decodeReaderComplete
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/decoder.js [app-client] (ecmascript)");
;
class CarReader {
    /**
   * @constructs CarReader
   * @param {CarHeader|CarV2Header} header
   * @param {Block[]} blocks
   */ constructor(header, blocks){
        this._header = header;
        this._blocks = blocks;
        this._keys = blocks.map((b)=>b.cid.toString());
    }
    /**
   * @property
   * @memberof CarReader
   * @instance
   */ get version() {
        return this._header.version;
    }
    /**
   * Get the list of roots defined by the CAR referenced by this reader. May be
   * zero or more `CID`s.
   *
   * @function
   * @memberof CarReader
   * @instance
   * @async
   * @returns {Promise<CID[]>}
   */ async getRoots() {
        return this._header.roots;
    }
    /**
   * Check whether a given `CID` exists within the CAR referenced by this
   * reader.
   *
   * @function
   * @memberof CarReader
   * @instance
   * @async
   * @param {CID} key
   * @returns {Promise<boolean>}
   */ async has(key) {
        return this._keys.indexOf(key.toString()) > -1;
    }
    /**
   * Fetch a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) from the CAR
   * referenced by this reader matching the provided `CID`. In the case where
   * the provided `CID` doesn't exist within the CAR, `undefined` will be
   * returned.
   *
   * @function
   * @memberof CarReader
   * @instance
   * @async
   * @param {CID} key
   * @returns {Promise<Block | undefined>}
   */ async get(key) {
        const index = this._keys.indexOf(key.toString());
        return index > -1 ? this._blocks[index] : undefined;
    }
    /**
   * Returns a `BlockIterator` (`AsyncIterable<Block>`) that iterates over all
   * of the `Block`s (`{ cid:CID, bytes:Uint8Array }` pairs) contained within
   * the CAR referenced by this reader.
   *
   * @function
   * @memberof CarReader
   * @instance
   * @async
   * @generator
   * @returns {AsyncGenerator<Block>}
   */ async *blocks() {
        for (const block of this._blocks){
            yield block;
        }
    }
    /**
   * Returns a `CIDIterator` (`AsyncIterable<CID>`) that iterates over all of
   * the `CID`s contained within the CAR referenced by this reader.
   *
   * @function
   * @memberof CarReader
   * @instance
   * @async
   * @generator
   * @returns {AsyncGenerator<CID>}
   */ async *cids() {
        for (const block of this._blocks){
            yield block.cid;
        }
    }
    /**
   * Instantiate a {@link CarReader} from a `Uint8Array` blob. This performs a
   * decode fully in memory and maintains the decoded state in memory for full
   * access to the data via the `CarReader` API.
   *
   * @async
   * @static
   * @memberof CarReader
   * @param {Uint8Array} bytes
   * @returns {Promise<CarReader>}
   */ static async fromBytes(bytes) {
        if (!(bytes instanceof Uint8Array)) {
            throw new TypeError('fromBytes() requires a Uint8Array');
        }
        return decodeReaderComplete((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bytesReader"])(bytes));
    }
    /**
   * Instantiate a {@link CarReader} from a `AsyncIterable<Uint8Array>`, such as
   * a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).
   * This performs a decode fully in memory and maintains the decoded state in
   * memory for full access to the data via the `CarReader` API.
   *
   * Care should be taken for large archives; this API may not be appropriate
   * where memory is a concern or the archive is potentially larger than the
   * amount of memory that the runtime can handle.
   *
   * @async
   * @static
   * @memberof CarReader
   * @param {AsyncIterable<Uint8Array>} asyncIterable
   * @returns {Promise<CarReader>}
   */ static async fromIterable(asyncIterable) {
        if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === 'function')) {
            throw new TypeError('fromIterable() requires an async iterable');
        }
        return decodeReaderComplete((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asyncIterableReader"])(asyncIterable));
    }
}
async function decodeReaderComplete(reader) {
    const decoder = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDecoder"])(reader);
    const header = await decoder.header();
    const blocks = [];
    for await (const block of decoder.blocks()){
        blocks.push(block);
    }
    return new CarReader(header, blocks);
}
const __browser = true;
}),
"[project]/node_modules/@ipld/car/src/encoder.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createEncoder",
    ()=>createEncoder,
    "createHeader",
    ()=>createHeader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-cbor/src/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/varint/index.js [app-client] (ecmascript)");
;
;
/**
 * @typedef {import('multiformats').CID} CID
 * @typedef {import('./api.js').Block} Block
 * @typedef {import('./coding.js').CarEncoder} CarEncoder
 * @typedef {import('./coding.js').IteratorChannel_Writer<Uint8Array>} IteratorChannel_Writer
 */ const CAR_V1_VERSION = 1;
function createHeader(roots) {
    const headerBytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"])({
        version: CAR_V1_VERSION,
        roots
    });
    const varintBytes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].encode(headerBytes.length);
    const header = new Uint8Array(varintBytes.length + headerBytes.length);
    header.set(varintBytes, 0);
    header.set(headerBytes, varintBytes.length);
    return header;
}
/**
 * @param {IteratorChannel_Writer} writer
 * @returns {CarEncoder}
 */ function createEncoder(writer) {
    // none of this is wrapped in a mutex, that needs to happen above this to
    // avoid overwrites
    return {
        /**
     * @param {CID[]} roots
     * @returns {Promise<void>}
     */ async setRoots (roots) {
            const bytes = createHeader(roots);
            await writer.write(bytes);
        },
        /**
     * @param {Block} block
     * @returns {Promise<void>}
     */ async writeBlock (block) {
            const { cid, bytes } = block;
            await writer.write(new Uint8Array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].encode(cid.bytes.length + bytes.length)));
            await writer.write(cid.bytes);
            if (bytes.length) {
                // zero-length blocks are valid, but it'd be safer if we didn't write them
                await writer.write(bytes);
            }
        },
        /**
     * @returns {Promise<void>}
     */ async close () {
            await writer.end();
        },
        /**
     * @returns {number}
     */ version () {
            return CAR_V1_VERSION;
        }
    };
}
;
}),
"[project]/node_modules/@ipld/car/src/iterator-channel.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @template {any} T
 * @typedef {import('./coding.js').IteratorChannel<T>} IteratorChannel
 */ __turbopack_context__.s([
    "create",
    ()=>create
]);
function noop() {}
function create() {
    /** @type {T[]} */ const chunkQueue = [];
    /** @type {Promise<void> | null} */ let drainer = null;
    let drainerResolver = noop;
    let ended = false;
    /** @type {Promise<IteratorResult<T>> | null} */ let outWait = null;
    let outWaitResolver = noop;
    const makeDrainer = ()=>{
        if (!drainer) {
            drainer = new Promise((resolve)=>{
                drainerResolver = ()=>{
                    drainer = null;
                    drainerResolver = noop;
                    resolve();
                };
            });
        }
        return drainer;
    };
    /**
   * @returns {IteratorChannel<T>}
   */ const writer = {
        /**
     * @param {T} chunk
     * @returns {Promise<void>}
     */ write (chunk) {
            chunkQueue.push(chunk);
            const drainer = makeDrainer();
            outWaitResolver();
            return drainer;
        },
        async end () {
            ended = true;
            const drainer = makeDrainer();
            outWaitResolver();
            await drainer;
        }
    };
    /** @type {AsyncIterator<T>} */ const iterator = {
        /** @returns {Promise<IteratorResult<T>>} */ async next () {
            const chunk = chunkQueue.shift();
            if (chunk) {
                if (chunkQueue.length === 0) {
                    drainerResolver();
                }
                return {
                    done: false,
                    value: chunk
                };
            }
            if (ended) {
                drainerResolver();
                return {
                    done: true,
                    value: undefined
                };
            }
            if (!outWait) {
                outWait = new Promise((resolve)=>{
                    outWaitResolver = ()=>{
                        outWait = null;
                        outWaitResolver = noop;
                        return resolve(iterator.next());
                    };
                });
            }
            return outWait;
        }
    };
    return {
        writer,
        iterator
    };
}
}),
"[project]/node_modules/@ipld/car/src/writer-browser.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CarWriter",
    ()=>CarWriter,
    "CarWriterOut",
    ()=>CarWriterOut,
    "__browser",
    ()=>__browser
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/cid.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/decoder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$encoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/encoder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$iterator$2d$channel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/iterator-channel.js [app-client] (ecmascript)");
;
;
;
;
class CarWriter {
    /**
   * @param {CID[]} roots
   * @param {CarEncoder} encoder
   */ constructor(roots, encoder){
        this._encoder = encoder;
        /** @type {Promise<void>} */ this._mutex = encoder.setRoots(roots);
        this._ended = false;
    }
    /**
   * Write a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) to the archive.
   *
   * @function
   * @memberof CarWriter
   * @instance
   * @async
   * @param {Block} block - A `{ cid:CID, bytes:Uint8Array }` pair.
   * @returns {Promise<void>} The returned promise will only resolve once the
   * bytes this block generates are written to the `out` iterable.
   */ async put(block) {
        if (!(block.bytes instanceof Uint8Array) || !block.cid) {
            throw new TypeError('Can only write {cid, bytes} objects');
        }
        if (this._ended) {
            throw new Error('Already closed');
        }
        const cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].asCID(block.cid);
        if (!cid) {
            throw new TypeError('Can only write {cid, bytes} objects');
        }
        this._mutex = this._mutex.then(()=>this._encoder.writeBlock({
                cid,
                bytes: block.bytes
            }));
        return this._mutex;
    }
    /**
   * Finalise the CAR archive and signal that the `out` iterable should end once
   * any remaining bytes are written.
   *
   * @function
   * @memberof CarWriter
   * @instance
   * @async
   * @returns {Promise<void>}
   */ async close() {
        if (this._ended) {
            throw new Error('Already closed');
        }
        await this._mutex;
        this._ended = true;
        return this._encoder.close();
    }
    /**
   * Returns the version number of the CAR file being written
   *
   * @returns {number}
   */ version() {
        return this._encoder.version();
    }
    /**
   * Create a new CAR writer "channel" which consists of a
   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair.
   *
   * @async
   * @static
   * @memberof CarWriter
   * @param {CID[] | CID | void} roots
   * @returns {WriterChannel} The channel takes the form of
   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }`.
   */ static create(roots) {
        roots = toRoots(roots);
        const { encoder, iterator } = encodeWriter();
        const writer = new CarWriter(roots, encoder);
        const out = new CarWriterOut(iterator);
        return {
            writer,
            out
        };
    }
    /**
   * Create a new CAR appender "channel" which consists of a
   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair.
   * This appender does not consider roots and does not produce a CAR header.
   * It is designed to append blocks to an _existing_ CAR archive. It is
   * expected that `out` will be concatenated onto the end of an existing
   * archive that already has a properly formatted header.
   *
   * @async
   * @static
   * @memberof CarWriter
   * @returns {WriterChannel} The channel takes the form of
   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }`.
   */ static createAppender() {
        const { encoder, iterator } = encodeWriter();
        encoder.setRoots = ()=>Promise.resolve();
        const writer = new CarWriter([], encoder);
        const out = new CarWriterOut(iterator);
        return {
            writer,
            out
        };
    }
    /**
   * Update the list of roots in the header of an existing CAR as represented
   * in a Uint8Array.
   *
   * This operation is an _overwrite_, the total length of the CAR will not be
   * modified. A rejection will occur if the new header will not be the same
   * length as the existing header, in which case the CAR will not be modified.
   * It is the responsibility of the user to ensure that the roots being
   * replaced encode as the same length as the new roots.
   *
   * The byte array passed in an argument will be modified and also returned
   * upon successful modification.
   *
   * @async
   * @static
   * @memberof CarWriter
   * @param {Uint8Array} bytes
   * @param {CID[]} roots - A new list of roots to replace the existing list in
   * the CAR header. The new header must take up the same number of bytes as the
   * existing header, so the roots should collectively be the same byte length
   * as the existing roots.
   * @returns {Promise<Uint8Array>}
   */ static async updateRootsInBytes(bytes, roots) {
        const reader = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bytesReader"])(bytes);
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readHeader"])(reader);
        const newHeader = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$encoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createHeader"])(roots);
        if (Number(reader.pos) !== newHeader.length) {
            throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${reader.pos} bytes, new header is ${newHeader.length} bytes)`);
        }
        bytes.set(newHeader, 0);
        return bytes;
    }
}
class CarWriterOut {
    /**
   * @param {AsyncIterator<Uint8Array>} iterator
   */ constructor(iterator){
        this._iterator = iterator;
    }
    [Symbol.asyncIterator]() {
        if (this._iterating) {
            throw new Error('Multiple iterator not supported');
        }
        this._iterating = true;
        return this._iterator;
    }
}
function encodeWriter() {
    /** @type {IteratorChannel} */ const iw = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$iterator$2d$channel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])();
    const { writer, iterator } = iw;
    const encoder = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$encoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createEncoder"])(writer);
    return {
        encoder,
        iterator
    };
}
/**
 * @private
 * @param {CID[] | CID | void} roots
 * @returns {CID[]}
 */ function toRoots(roots) {
    if (roots === undefined) {
        return [];
    }
    if (!Array.isArray(roots)) {
        const cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].asCID(roots);
        if (!cid) {
            throw new TypeError('roots must be a single CID or an array of CIDs');
        }
        return [
            cid
        ];
    }
    const _roots = [];
    for (const root of roots){
        const _root = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].asCID(root);
        if (!_root) {
            throw new TypeError('roots must be a single CID or an array of CIDs');
        }
        _roots.push(_root);
    }
    return _roots;
}
const __browser = true;
}),
"[project]/node_modules/@ipld/car/src/index-browser.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$buffer$2d$reader$2d$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/buffer-reader-browser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$buffer$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/buffer-writer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$indexed$2d$reader$2d$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/indexed-reader-browser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$indexer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/indexer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$iterator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/iterator.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$reader$2d$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/reader-browser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$writer$2d$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/writer-browser.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
}),
"[project]/node_modules/@ucanto/client/src/connection.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "connect",
    ()=>connect,
    "execute",
    ()=>execute
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$interface$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/interface/src/lib.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/lib.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$signature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Signature$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/signature.js [app-client] (ecmascript) <export * as Signature>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$message$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Message$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/message.js [app-client] (ecmascript) <export * as Message>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$receipt$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Receipt$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/receipt.js [app-client] (ecmascript) <export * as Receipt>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$sha2$2d$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/hashes/sha2-browser.js [app-client] (ecmascript)");
;
;
const connect = (options)=>new Connection(options);
/**
 * @template {Record<string, any>} T
 * @implements {API.ConnectionView<T>}
 */ class Connection {
    /**
   * @param {API.ConnectionOptions<T>} options
   */ constructor(options){
        this.id = options.id;
        this.options = options;
        this.codec = options.codec;
        this.channel = options.channel;
        this.hasher = options.hasher || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$sha2$2d$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sha256"];
    }
    /**
   * Execute invocations.
   *
   * @template {API.Capability} C
   * @template {API.Tuple<API.ServiceInvocation<C, T>>} I
   * @param {I} invocations
   * @returns {Promise<API.InferReceipts<I, T>>}
   */ async execute(...invocations) {
        return execute(invocations, this);
    }
}
const execute = async (invocations, connection)=>{
    const input = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$message$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Message$3e$__["Message"].build({
        invocations
    });
    const request = await connection.codec.encode(input, connection);
    const response = await connection.channel.request(request);
    // We may fail to decode the response if content type is not supported
    // or if data was corrupted. We do not want to throw in such case however,
    // because client will get an Error object as opposed to a receipt, to retain
    // consistent client API with two kinds of errors we encode caught error as
    // a receipts per workflow invocation.
    try {
        const output = await connection.codec.decode(response);
        const receipts = input.invocationLinks.map((link)=>output.get(link));
        return receipts;
    } catch (error) {
        // No third party code is run during decode and we know
        // we only throw an Error
        const { message, name = 'Error', ...cause } = error;
        const receipts = [];
        for await (const ran of input.invocationLinks){
            const receipt = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$receipt$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Receipt$3e$__["Receipt"].issue({
                ran,
                result: {
                    error: {
                        ...cause,
                        name,
                        message
                    }
                },
                // @ts-expect-error - we can not really sign a receipt without having
                // an access to a signer which client does not have. In the future
                // we will change client API requiring a signer to be passed in but
                // for now we just use a dummy signer.
                issuer: {
                    did () {
                        return connection.id.did();
                    },
                    sign () {
                        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$signature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Signature$3e$__["Signature"].createNonStandard('', new Uint8Array());
                    }
                }
            });
            receipts.push(receipt);
        }
        return receipts;
    }
};
}),
"[project]/node_modules/@ucanto/client/src/lib.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "delegate",
    ()=>delegate
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$client$2f$src$2f$connection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/client/src/connection.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$interface$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/interface/src/lib.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/lib.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$delegation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Delegation$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/delegation.js [app-client] (ecmascript) <export * as Delegation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$invocation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/invocation.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/schema.js [app-client] (ecmascript) <export * as Schema>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$dag$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__DAG$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/dag.js [app-client] (ecmascript) <export * as DAG>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/result.js [app-client] (ecmascript)");
;
;
;
const delegate = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$delegation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Delegation$3e$__["Delegation"].delegate;
;
}),
"[project]/node_modules/@ucanto/transport/src/car/request.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "contentType",
    ()=>contentType,
    "decode",
    ()=>decode,
    "encode",
    ()=>encode
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$interface$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/interface/src/lib.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/lib.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__CAR$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/car.js [app-client] (ecmascript) <export * as CAR>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$message$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Message$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/message.js [app-client] (ecmascript) <export * as Message>");
;
;
;
const contentType = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__CAR$3e$__["CAR"].contentType;
const HEADERS = Object.freeze({
    'content-type': contentType,
    // We will signal that we want to receive a CAR file in the response
    accept: contentType
});
const encode = (message, options)=>{
    const blocks = new Map();
    for (const block of message.iterateIPLDBlocks()){
        blocks.set(`${block.cid}`, block);
    }
    /**
   * Cast to Uint8Array to remove phantom type set by the
   * CAR encoder which is too specific.
   *
   * @type {Uint8Array}
   */ const body = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__CAR$3e$__["CAR"].encode({
        roots: [
            message.root
        ],
        blocks
    });
    return {
        headers: options?.headers || {
            ...HEADERS
        },
        body
    };
};
const decode = async ({ headers, body })=>{
    const { roots, blocks } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__CAR$3e$__["CAR"].decode(body);
    const message = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$message$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Message$3e$__["Message"].view({
        root: roots[0].cid,
        store: blocks
    });
    return message;
};
}),
"[project]/node_modules/@ucanto/transport/src/car/request.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "codec",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__CAR$3e$__["CAR"],
    "contentType",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2f$request$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["contentType"],
    "decode",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2f$request$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["decode"],
    "encode",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2f$request$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encode"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2f$request$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/car/request.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__CAR$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/car.js [app-client] (ecmascript) <export * as CAR>");
}),
"[project]/node_modules/@ucanto/transport/src/car/response.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "contentType",
    ()=>contentType,
    "decode",
    ()=>decode,
    "encode",
    ()=>encode
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$interface$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/interface/src/lib.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/lib.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__CAR$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/car.js [app-client] (ecmascript) <export * as CAR>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$message$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Message$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/message.js [app-client] (ecmascript) <export * as Message>");
;
;
;
const contentType = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__CAR$3e$__["CAR"].contentType;
const HEADERS = Object.freeze({
    'content-type': contentType
});
const encode = (message, options)=>{
    const blocks = new Map();
    for (const block of message.iterateIPLDBlocks()){
        blocks.set(`${block.cid}`, block);
    }
    /**
   * Cast to Uint8Array to remove phantom type set by the
   * CAR encoder which is too specific.
   *
   * @type {Uint8Array}
   */ const body = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__CAR$3e$__["CAR"].encode({
        roots: [
            message.root
        ],
        blocks
    });
    return {
        headers: {
            ...HEADERS
        },
        body
    };
};
const decode = async ({ headers, body })=>{
    const { roots, blocks } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__CAR$3e$__["CAR"].decode(body);
    const message = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$message$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Message$3e$__["Message"].view({
        root: roots[0].cid,
        store: blocks
    });
    return message;
};
}),
"[project]/node_modules/@ucanto/transport/src/car/response.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "codec",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__CAR$3e$__["CAR"],
    "contentType",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2f$response$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["contentType"],
    "decode",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2f$response$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["decode"],
    "encode",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2f$response$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encode"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2f$response$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/car/response.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__CAR$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/car.js [app-client] (ecmascript) <export * as CAR>");
}),
"[project]/node_modules/@ucanto/transport/src/codec.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "formatAcceptHeader",
    ()=>formatAcceptHeader,
    "formatMediaType",
    ()=>formatMediaType,
    "inbound",
    ()=>inbound,
    "outbound",
    ()=>outbound,
    "parseAcceptHeader",
    ()=>parseAcceptHeader,
    "parseMediaType",
    ()=>parseMediaType
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$interface$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/interface/src/lib.js [app-client] (ecmascript)");
;
const inbound = (source)=>new Inbound(source);
/**
 * @implements {API.InboundCodec}
 */ class Inbound {
    /**
   * @param {API.HTTPRequest} request
   * @returns {API.Result<API.InboundAcceptCodec, API.HTTPError>} transport
   */ accept({ headers }) {
        const contentType = headers['content-type'] || headers['Content-Type'];
        const decoder = this.decoders[contentType];
        if (!decoder) {
            return {
                error: {
                    status: 415,
                    message: `The server cannot process the request because the payload format is not supported. Please check the content-type header and try again with a supported media type.`,
                    headers: {
                        accept: Object.keys(this.decoders).join(', ')
                    }
                }
            };
        }
        const accept = parseAcceptHeader(headers.accept || headers.Accept || '*/*');
        for (const { category, type } of accept){
            for (const encoder of this.encoders){
                const select = (category === '*' || category === encoder.category) && (type === '*' || type === encoder.type);
                if (select) {
                    return {
                        ok: {
                            ...encoder,
                            decoder
                        }
                    };
                }
            }
        }
        return {
            error: {
                status: 406,
                message: `The requested resource cannot be served in the requested content type. Please specify a supported content type using the Accept header.`,
                headers: {
                    accept: formatAcceptHeader(Object.values(this.encoders))
                }
            }
        };
    }
    /**
   * @param {object} source
   * @param {Record<string, API.Transport.RequestDecoder>} source.decoders
   * @param {Record<string, API.Transport.ResponseEncoder>} source.encoders
   */ constructor({ decoders = {}, encoders = {} }){
        this.decoders = decoders;
        if (Object.keys(decoders).length === 0) {
            throw new Error('At least one decoder MUST be provided');
        }
        // We sort the encoders by preference, so that we can pick the most
        // preferred one when client accepts multiple content types.
        this.encoders = Object.entries(encoders).map(([mediaType, encoder])=>{
            return {
                ...parseMediaType(mediaType),
                encoder
            };
        }).sort((a, b)=>b.preference - a.preference);
        if (this.encoders.length === 0) {
            throw new Error('At least one encoder MUST be provided');
        }
    }
}
const outbound = (source)=>new Outbound(source);
/**
 * @implements {API.OutboundCodec}
 */ class Outbound {
    /**
   * @param {object} source
   * @param {Record<string, API.Transport.RequestEncoder>} source.encoders
   * @param {Record<string, API.Transport.ResponseDecoder>} source.decoders
   */ constructor({ decoders = {}, encoders = {} }){
        this.decoders = decoders;
        if (Object.keys(decoders).length === 0) {
            throw new Error('At least one decoder MUST be provided');
        }
        // We sort the encoders by preference, so that we can pick the most
        // preferred one when client accepts multiple content types.
        this.encoders = Object.entries(encoders).map(([mediaType, encoder])=>{
            return {
                ...parseMediaType(mediaType),
                encoder
            };
        }).sort((a, b)=>b.preference - a.preference);
        this.acceptType = formatAcceptHeader(this.encoders);
        if (this.encoders.length === 0) {
            throw new Error('At least one encoder MUST be provided');
        }
        this.encoder = this.encoders[0].encoder;
    }
    /**
   * @template {API.AgentMessage} Message
   * @param {Message} message
   */ encode(message) {
        return this.encoder.encode(message, {
            accept: this.acceptType
        });
    }
    /**
   * @template {API.AgentMessage} Message
   * @param {API.HTTPResponse<Message>} response
   * @returns {API.Await<Message>}
   */ decode(response) {
        const { headers } = response;
        const contentType = headers['content-type'] || headers['Content-Type'];
        const decoder = this.decoders[contentType] || this.decoders['*/*'];
        switch(response.status){
            case 415:
            case 406:
                throw Object.assign(new RangeError(new TextDecoder().decode(response.body)), {
                    status: response.status,
                    headers: response.headers
                });
        }
        if (!decoder) {
            throw Object.assign(TypeError(`Can not decode response with content-type '${contentType}' because no matching transport decoder is configured.`), {
                error: true
            });
        }
        return decoder.decode(response);
    }
}
const parseMediaType = (source)=>{
    const [mediaType = '*/*', mediaRange = ''] = source.trim().split(';');
    const [category = '*', type = '*'] = mediaType.split('/');
    const params = new URLSearchParams(mediaRange);
    const preference = parseFloat(params.get('q') || '0');
    return {
        category,
        type,
        /* c8 ignore next */ preference: isNaN(preference) ? 0 : preference
    };
};
const formatMediaType = ({ category, type, preference })=>`${category}/${type}${preference ? `;q=${preference}` : ''}`;
const parseAcceptHeader = (source)=>source.split(',').map(parseMediaType).sort((a, b)=>b.preference - a.preference);
const formatAcceptHeader = (source)=>source.map(formatMediaType).join(', ');
}),
"[project]/node_modules/@ucanto/transport/src/car.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "contentType",
    ()=>contentType,
    "inbound",
    ()=>inbound,
    "outbound",
    ()=>outbound
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/lib.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__CAR$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/car.js [app-client] (ecmascript) <export * as CAR>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2f$request$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/car/request.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2f$request$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/car/request.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2f$response$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/car/response.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2f$response$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/car/response.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$codec$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/codec.js [app-client] (ecmascript)");
;
;
;
;
;
const contentType = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__CAR$3e$__["CAR"].contentType;
const inbound = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$codec$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["inbound"]({
    decoders: {
        [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2f$request$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.contentType]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2f$request$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__
    },
    encoders: {
        [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2f$response$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.contentType]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2f$response$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__
    }
});
const outbound = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$codec$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["outbound"]({
    encoders: {
        [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2f$request$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.contentType]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2f$request$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__
    },
    decoders: {
        [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2f$response$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.contentType]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2f$response$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__
    }
});
}),
"[project]/node_modules/@ucanto/transport/src/http.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "open",
    ()=>open
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$interface$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/interface/src/lib.js [app-client] (ecmascript)");
;
const open = ({ url, method = 'POST', fetch, headers })=>{
    /* c8 ignore next 9 */ if (!fetch) {
        if (typeof globalThis.fetch !== 'undefined') {
            fetch = globalThis.fetch.bind(globalThis);
        } else {
            throw new TypeError(`ucanto HTTP transport got undefined \`fetch\`. Try passing in a \`fetch\` implementation explicitly.`);
        }
    }
    return new Channel({
        url,
        method,
        fetch,
        headers
    });
};
/**
 * @template {Record<string, any>} S
 * @implements {API.Channel<S>}
 */ class Channel {
    /**
   * @param {object} options
   * @param {URL} options.url
   * @param {Fetcher} options.fetch
   * @param {string} [options.method]
   * @param {Record<string, string>} [options.headers]
   */ constructor({ url, fetch, method, headers }){
        this.fetch = fetch;
        this.method = method;
        this.url = url;
        this.headers = headers;
    }
    /**
   * @template {API.Tuple<API.ServiceInvocation<API.Capability, S>>} I
   * @param {API.HTTPRequest<API.AgentMessage<{ In: API.InferInvocations<I>, Out: API.Tuple<API.Receipt> }>>} request
   * @returns {Promise<API.HTTPResponse<API.AgentMessage<{ Out: API.InferReceipts<I, S>, In: API.Tuple<API.Invocation> }>>>}
   */ async request({ headers, body }) {
        const response = await this.fetch(this.url.href, {
            headers: {
                ...this.headers,
                ...headers
            },
            body,
            method: this.method
        });
        const buffer = response.ok ? await response.arrayBuffer() : HTTPError.throw(`HTTP Request failed. ${this.method} ${this.url.href}  ${response.status}`, response);
        return {
            headers: response.headers.entries ? Object.fromEntries(response.headers.entries()) : /* c8 ignore next */ {},
            body: new Uint8Array(buffer)
        };
    }
}
/**
 * @typedef {{
 * status?: number
 * statusText?: string
 * url?: string
 * }} Options
 */ class HTTPError extends Error {
    /**
   * @param {string} message
   * @param {Options} options
   * @returns {never}
   */ static throw(message, options) {
        throw new this(message, options);
    }
    /**
   * @param {string} message
   * @param {Options} options
   */ constructor(message, { url, status = 500, statusText = 'Server error' }){
        super(message);
        /** @type {'HTTPError'} */ this.name = 'HTTPError';
        this.url = url;
        this.status = status;
        this.statusText = statusText;
    }
}
}),
"[project]/node_modules/@ucanto/transport/src/utf8.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "decode",
    ()=>decode,
    "decoder",
    ()=>decoder,
    "encode",
    ()=>encode,
    "encoder",
    ()=>encoder
]);
const encoder = new TextEncoder();
const decoder = new TextDecoder();
const encode = (text)=>encoder.encode(text);
const decode = (bytes)=>decoder.decode(bytes);
}),
"[project]/node_modules/@ucanto/transport/src/car/request.js [app-client] (ecmascript) <export * as request>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "request",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2f$request$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2f$request$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/car/request.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@ucanto/transport/src/car/response.js [app-client] (ecmascript) <export * as response>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "response",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2f$response$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2f$response$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/car/response.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@ucanto/transport/src/legacy/response.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "contentType",
    ()=>contentType,
    "encode",
    ()=>encode
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$interface$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/interface/src/lib.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$cbor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/cbor.js [app-client] (ecmascript) <locals>");
;
;
const contentType = 'application/cbor';
const HEADERS = Object.freeze({
    'content-type': contentType
});
const encode = (message, options)=>{
    const legacyResults = [];
    for (const receipt of message.receipts.values()){
        const result = receipt.out;
        if (result.ok) {
            legacyResults.push(result.ok);
        } else {
            legacyResults.push({
                ...result.error,
                error: true
            });
        }
    }
    /** @type {Uint8Array} */ const body = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$cbor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encode"](legacyResults);
    return {
        headers: HEADERS,
        body
    };
};
}),
"[project]/node_modules/@ucanto/transport/src/legacy/request.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "contentType",
    ()=>contentType,
    "decode",
    ()=>decode
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/car.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$interface$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/interface/src/lib.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/lib.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$invocation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Invocation$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/invocation.js [app-client] (ecmascript) <export * as Invocation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$message$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Message$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/message.js [app-client] (ecmascript) <export * as Message>");
;
;
;
const contentType = 'application/car';
const decode = async ({ body })=>{
    const { roots, blocks } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](body);
    /** @type {API.IssuedInvocation[]} */ const run = [];
    for (const { cid } of roots){
        // We don't have a way to know if the root matches a ucan link.
        const invocation = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$invocation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Invocation$3e$__["Invocation"].view({
            root: cid,
            blocks
        });
        run.push(invocation);
    }
    const message = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$message$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Message$3e$__["Message"].build({
        invocations: run
    });
    return message;
};
}),
"[project]/node_modules/@ucanto/transport/src/legacy.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "contentType",
    ()=>contentType,
    "inbound",
    ()=>inbound
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$codec$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/codec.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/car.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2f$request$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__request$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/car/request.js [app-client] (ecmascript) <export * as request>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2f$response$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__response$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/car/response.js [app-client] (ecmascript) <export * as response>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$legacy$2f$response$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/legacy/response.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$legacy$2f$request$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/legacy/request.js [app-client] (ecmascript)");
;
;
;
;
const { contentType } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$legacy$2f$request$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__;
;
const inbound = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$codec$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["inbound"]({
    decoders: {
        [contentType]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$legacy$2f$request$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
        [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["contentType"]]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2f$request$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__request$3e$__["request"]
    },
    encoders: {
        // Here we configure encoders such that if accept header is `*/*` (which is
        // the default if omitted) we will encode the response in CBOR. If
        // `application/vnd.ipld.car` is set we will encode the response in current
        // format.
        // Here we exploit the fact that legacy clients do not send an accept header
        // and therefore will get response in legacy format. New clients on the other
        // hand will send `application/vnd.ipld.car` and consequently get response
        // in current format.
        '*/*;q=0.1': __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$legacy$2f$response$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
        [__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["contentType"]]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2f$response$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__response$3e$__["response"]
    }
});
}),
"[project]/node_modules/@ucanto/transport/src/lib.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

// top level exports
__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/car.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$http$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/http.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$utf8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/utf8.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$legacy$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/legacy.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$codec$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/codec.js [app-client] (ecmascript)");
;
;
;
;
;
;
}),
"[project]/node_modules/@ucanto/transport/src/car.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "codec",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__CAR$3e$__["CAR"],
    "contentType",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["contentType"],
    "inbound",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["inbound"],
    "outbound",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["outbound"],
    "request",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2f$request$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    "response",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2f$response$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/car.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__CAR$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/car.js [app-client] (ecmascript) <export * as CAR>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2f$request$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/car/request.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2f$response$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/car/response.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@ucanto/transport/src/car.js [app-client] (ecmascript) <export * as CAR>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CAR",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/car.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@ucanto/transport/src/http.js [app-client] (ecmascript) <export * as HTTP>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "HTTP",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$http$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$http$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/http.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@ucanto/validator/src/util.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @template {string|boolean|number|[unknown, ...unknown[]]} T
 * @param {T} value
 * @returns {T}
 */ __turbopack_context__.s([
    "combine",
    ()=>combine,
    "entries",
    ()=>entries,
    "intersection",
    ()=>intersection,
    "the",
    ()=>the
]);
const the = (value)=>value;
const entries = (object)=>Object.entries(object);
const combine = ([first, ...rest])=>{
    const results = first.map((value)=>[
            value
        ]);
    for (const values of rest){
        const tuples = results.splice(0);
        for (const value of values){
            for (const tuple of tuples){
                results.push([
                    ...tuple,
                    value
                ]);
            }
        }
    }
    return results;
};
const intersection = (left, right)=>{
    const [result, other] = left.length < right.length ? [
        new Set(left),
        new Set(right)
    ] : [
        new Set(right),
        new Set(left)
    ];
    for (const item of result){
        if (!other.has(item)) {
            result.delete(item);
        }
    }
    return [
        ...result
    ];
};
}),
"[project]/node_modules/@ucanto/validator/src/error.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DIDKeyResolutionError",
    ()=>DIDKeyResolutionError,
    "DelegationError",
    ()=>DelegationError,
    "EscalatedCapability",
    ()=>EscalatedCapability,
    "Expired",
    ()=>Expired,
    "InvalidSignature",
    ()=>InvalidSignature,
    "MalformedCapability",
    ()=>MalformedCapability,
    "NotValidBefore",
    ()=>NotValidBefore,
    "PrincipalAlignmentError",
    ()=>PrincipalAlignmentError,
    "Revoked",
    ()=>Revoked,
    "SessionEscalation",
    ()=>SessionEscalation,
    "Unauthorized",
    ()=>Unauthorized,
    "UnavailableProof",
    ()=>UnavailableProof,
    "UnknownCapability",
    ()=>UnknownCapability,
    "indent",
    ()=>indent,
    "li",
    ()=>li
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$interface$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/interface/src/lib.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/validator/src/util.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$link$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/link.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/link.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/result.js [app-client] (ecmascript)");
;
;
;
;
;
class EscalatedCapability extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {API.ParsedCapability} claimed
   * @param {object} delegated
   * @param {API.Failure} cause
   */ constructor(claimed, delegated, cause){
        super();
        this.claimed = claimed;
        this.delegated = delegated;
        this.cause = cause;
        this.name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["the"])('EscalatedCapability');
    }
    describe() {
        return `Constraint violation: ${this.cause.message}`;
    }
}
class DelegationError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {(API.InvalidCapability | API.EscalatedDelegation | API.DelegationError)[]} causes
   * @param {object} context
   */ constructor(causes, context){
        super();
        this.name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["the"])('InvalidClaim');
        this.causes = causes;
        this.context = context;
    }
    describe() {
        return [
            `Can not derive ${this.context} from delegated capabilities:`,
            ...this.causes.map((cause)=>li(cause.message))
        ].join('\n');
    }
    /**
   * @type {API.InvalidCapability | API.EscalatedDelegation | API.DelegationError}
   */ get cause() {
        /* c8 ignore next 9 */ if (this.causes.length !== 1) {
            return this;
        } else {
            const [cause] = this.causes;
            const value = cause.name === 'InvalidClaim' ? cause.cause : cause;
            Object.defineProperties(this, {
                cause: {
                    value
                }
            });
            return value;
        }
    }
}
class SessionEscalation extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {object} source
   * @param {API.Delegation} source.delegation
   * @param {API.Failure} source.cause
   */ constructor({ delegation, cause }){
        super();
        this.name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["the"])('SessionEscalation');
        this.delegation = delegation;
        this.cause = cause;
    }
    describe() {
        const issuer = this.delegation.issuer.did();
        return [
            `Delegation ${this.delegation.cid} issued by ${issuer} has an invalid session`,
            li(this.cause.message)
        ].join('\n');
    }
}
class InvalidSignature extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {API.Delegation} delegation
   * @param {API.Verifier} verifier
   */ constructor(delegation, verifier){
        super();
        this.name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["the"])('InvalidSignature');
        this.delegation = delegation;
        this.verifier = verifier;
    }
    get issuer() {
        return this.delegation.issuer;
    }
    get audience() {
        return this.delegation.audience;
    }
    get key() {
        return this.verifier.toDIDKey();
    }
    describe() {
        const issuer = this.issuer.did();
        const key = this.key;
        return (issuer.startsWith('did:key') ? [
            `Proof ${this.delegation.cid} does not has a valid signature from ${key}`
        ] : [
            `Proof ${this.delegation.cid} issued by ${issuer} does not has a valid signature from ${key}`,
            `   Probably issuer signed with a different key, which got rotated, invalidating delegations that were issued with prior keys`
        ]).join('\n');
    }
}
class UnavailableProof extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {API.UCAN.Link} link
   * @param {Error} [cause]
   */ constructor(link, cause){
        super();
        this.name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["the"])('UnavailableProof');
        this.link = link;
        this.cause = cause;
    }
    describe() {
        return [
            `Linked proof '${this.link}' is not included and could not be resolved`,
            ...this.cause ? [
                li(`Proof resolution failed with: ${this.cause.message}`)
            ] : []
        ].join('\n');
    }
}
class DIDKeyResolutionError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {API.UCAN.DID} did
   * @param {API.Failure} [cause]
   */ constructor(did, cause){
        super();
        this.name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["the"])('DIDKeyResolutionError');
        this.did = did;
        this.cause = cause;
    }
    describe() {
        return `Unable to resolve '${this.did}' key`;
    }
}
class PrincipalAlignmentError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {API.UCAN.Principal} audience
   * @param {API.Delegation} delegation
   */ constructor(audience, delegation){
        super();
        this.name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["the"])('InvalidAudience');
        this.audience = audience;
        this.delegation = delegation;
    }
    describe() {
        return `Delegation audience is '${this.delegation.audience.did()}' instead of '${this.audience.did()}'`;
    }
    toJSON() {
        const { name, audience, message, stack } = this;
        return {
            name,
            audience: audience.did(),
            delegation: {
                audience: this.delegation.audience.did()
            },
            message,
            stack
        };
    }
}
class MalformedCapability extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {API.Capability} capability
   * @param {API.Failure} cause
   */ constructor(capability, cause){
        super();
        this.name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["the"])('MalformedCapability');
        this.capability = capability;
        this.cause = cause;
    }
    describe() {
        return [
            `Encountered malformed '${this.capability.can}' capability: ${format(this.capability)}`,
            li(this.cause.message)
        ].join('\n');
    }
}
class UnknownCapability extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {API.Capability} capability
   */ constructor(capability){
        super();
        this.name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["the"])('UnknownCapability');
        this.capability = capability;
    }
    /* c8 ignore next 3 */ describe() {
        return `Encountered unknown capability: ${format(this.capability)}`;
    }
}
class Expired extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {API.Delegation & { expiration: number }} delegation
   */ constructor(delegation){
        super();
        this.name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["the"])('Expired');
        this.delegation = delegation;
    }
    describe() {
        return `Proof ${this.delegation.cid} has expired on ${new Date(this.delegation.expiration * 1000)}`;
    }
    get expiredAt() {
        return this.delegation.expiration;
    }
    toJSON() {
        const { name, expiredAt, message, stack } = this;
        return {
            name,
            message,
            expiredAt,
            stack
        };
    }
}
class Revoked extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {API.Delegation} delegation
   */ constructor(delegation){
        super();
        this.name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["the"])('Revoked');
        this.delegation = delegation;
    }
    describe() {
        return `Proof ${this.delegation.cid} has been revoked`;
    }
    toJSON() {
        const { name, message, stack } = this;
        return {
            name,
            message,
            stack
        };
    }
}
class NotValidBefore extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {API.Delegation & { notBefore: number }} delegation
   */ constructor(delegation){
        super();
        this.name = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["the"])('NotValidBefore');
        this.delegation = delegation;
    }
    describe() {
        return `Proof ${this.delegation.cid} is not valid before ${new Date(this.delegation.notBefore * 1000)}`;
    }
    get validAt() {
        return this.delegation.notBefore;
    }
    toJSON() {
        const { name, validAt, message, stack } = this;
        return {
            name,
            message,
            validAt,
            stack
        };
    }
}
class Unauthorized extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {{
   * capability: API.CapabilityParser
   * delegationErrors: API.DelegationError[]
   * unknownCapabilities: API.Capability[]
   * invalidProofs: API.InvalidProof[]
   * failedProofs: API.InvalidClaim[]
   * }} cause
   */ constructor({ capability, delegationErrors, unknownCapabilities, invalidProofs, failedProofs }){
        super();
        this.name = 'Unauthorized';
        this.capability = capability;
        this.delegationErrors = delegationErrors;
        this.unknownCapabilities = unknownCapabilities;
        this.invalidProofs = invalidProofs;
        this.failedProofs = failedProofs;
    }
    describe() {
        const errors = [
            ...this.failedProofs.map((error)=>li(error.message)),
            ...this.delegationErrors.map((error)=>li(error.message)),
            ...this.invalidProofs.map((error)=>li(error.message))
        ];
        const unknown = this.unknownCapabilities.map((c)=>li(JSON.stringify(c)));
        return [
            `Claim ${this.capability} is not authorized`,
            ...errors.length > 0 ? errors : [
                li(`No matching delegated capability found`)
            ],
            ...unknown.length > 0 ? [
                li(`Encountered unknown capabilities\n${unknown.join('\n')}`)
            ] : []
        ].join('\n');
    }
}
/**
 * @param {unknown} capability
 * @param {string|number} [space]
 */ const format = (capability, space)=>JSON.stringify(capability, (_key, value)=>{
        /* c8 ignore next 2 */ if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isLink"])(value)) {
            return value.toString();
        } else {
            return value;
        }
    }, space);
const indent = (message, indent = '  ')=>`${indent}${message.split('\n').join(`\n${indent}`)}`;
const li = (message)=>indent(`- ${message}`);
}),
"[project]/node_modules/@ucanto/validator/src/capability.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "and",
    ()=>and,
    "capability",
    ()=>capability,
    "derive",
    ()=>derive,
    "or",
    ()=>or
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$interface$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/interface/src/lib.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/validator/src/util.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/validator/src/error.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/lib.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$invocation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/invocation.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$delegation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/delegation.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/schema.js [app-client] (ecmascript) <export * as Schema>");
;
;
;
;
const capability = ({ derives = defaultDerives, nb = defaultNBSchema, ...etc })=>new Capability({
        derives,
        nb,
        ...etc
    });
const defaultNBSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__["Schema"].struct({});
const or = (left, right)=>new Or(left, right);
const and = (...selectors)=>new And(selectors);
const derive = ({ from, to, derives })=>new Derive(from, to, derives);
/**
 * @template {API.Match} M
 * @implements {API.View<M>}
 */ class View {
    /**
   * @param {API.Source} source
   * @returns {API.MatchResult<M>}
   */ /* c8 ignore next 3 */ match(source) {
        return {
            error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["UnknownCapability"](source.capability)
        };
    }
    /**
   * @param {API.Source[]} capabilities
   * @returns {API.Select<M>}
   */ select(capabilities) {
        return select(this, capabilities);
    }
    /**
   * @template {API.ParsedCapability} U
   * @param {object} source
   * @param {API.TheCapabilityParser<API.DirectMatch<U>>} source.to
   * @param {API.Derives<U, API.InferDeriveProof<M['value']>>} source.derives
   * @returns {API.TheCapabilityParser<API.DerivedMatch<U, M>>}
   */ derive({ derives, to }) {
        return derive({
            derives,
            to,
            from: this
        });
    }
}
/**
 * @template {API.Match} M
 * @implements {API.CapabilityParser<M>}
 * @extends {View<M>}
 */ class Unit extends View {
    /**
   * @template {API.Match} W
   * @param {API.MatchSelector<W>} other
   * @returns {API.CapabilityParser<M | W>}
   */ or(other) {
        return or(this, other);
    }
    /**
   * @template {API.Match} W
   * @param {API.CapabilityParser<W>} other
   * @returns {API.CapabilitiesParser<[M, W]>}
   */ and(other) {
        return and(this, other);
    }
}
/**
 * @template {API.Ability} A
 * @template {API.URI} R
 * @template {API.Caveats} C
 * @implements {API.TheCapabilityParser<API.DirectMatch<API.ParsedCapability<A, R, C>>>}
 * @extends {Unit<API.DirectMatch<API.ParsedCapability<A, R, C>>>}
 */ class Capability extends Unit {
    /**
   * @param {Required<Descriptor<A, R, C>>} descriptor
   */ constructor(descriptor){
        super();
        this.descriptor = descriptor;
        this.schema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__["Schema"].struct({
            can: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__["Schema"].literal(descriptor.can),
            with: descriptor.with,
            nb: descriptor.nb
        });
    }
    /**
   * @param {API.InferCreateOptions<R, C>} options
   */ create(options) {
        const { descriptor, can } = this;
        const decoders = descriptor.nb;
        const data = options.nb || {};
        const resource = descriptor.with.read(options.with);
        if (resource.error) {
            throw Object.assign(new Error(`Invalid 'with' - ${resource.error.message}`), {
                cause: resource
            });
        }
        const nb = descriptor.nb.read(data);
        if (nb.error) {
            throw Object.assign(new Error(`Invalid 'nb' - ${nb.error.message}`), {
                cause: nb
            });
        }
        return createCapability({
            can,
            with: resource.ok,
            nb: nb.ok
        });
    }
    /**
   * @param {API.InferInvokeOptions<R, C>} options
   */ invoke({ with: with_, nb, ...options }) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$invocation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["invoke"])({
            ...options,
            capability: this.create({
                with: with_,
                nb
            })
        });
    }
    /**
   * @param {API.InferDelegationOptions<R, C>} options
   * @returns {Promise<API.Delegation<[API.InferDelegatedCapability<API.ParsedCapability<A, R, C>>]>>}
   */ async delegate({ nb: input = {}, with: with_, ...options }) {
        const { descriptor, can } = this;
        const readers = descriptor.nb;
        const resource = descriptor.with.read(with_);
        if (resource.error) {
            throw Object.assign(new Error(`Invalid 'with' - ${resource.error.message}`), {
                cause: resource
            });
        }
        const nb = descriptor.nb.partial().read(input);
        if (nb.error) {
            throw Object.assign(new Error(`Invalid 'nb' - ${nb.error.message}`), {
                cause: nb
            });
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$delegation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["delegate"])({
            capabilities: [
                createCapability({
                    can,
                    with: resource.ok,
                    nb: nb.ok
                })
            ],
            ...options
        });
    }
    get can() {
        return this.descriptor.can;
    }
    /**
   * @param {API.Source} source
   * @returns {API.MatchResult<API.DirectMatch<API.ParsedCapability<A, R, C>>>}
   */ match(source) {
        const result = parseCapability(this.descriptor, source);
        return result.error ? result : {
            ok: new Match(source, result.ok, this.descriptor)
        };
    }
    toString() {
        return JSON.stringify({
            can: this.descriptor.can
        });
    }
}
/**
 * Normalizes capability by removing empty nb field.
 *
 * @template {API.ParsedCapability} T
 * @param {T} source
 */ const createCapability = ({ can, with: with_, nb })=>/** @type {API.InferCapability<T>} */ ({
        can,
        with: with_,
        ...isEmpty(nb) ? {} : {
            nb
        }
    });
/**
 * @param {object} object
 * @returns {object is {}}
 */ const isEmpty = (object)=>{
    for(const _ in object){
        return false;
    }
    return true;
};
/**
 * @template {API.Match} M
 * @template {API.Match} W
 * @implements {API.CapabilityParser<M|W>}
 * @extends {Unit<M|W>}
 */ class Or extends Unit {
    /**
   * @param {API.Matcher<M>} left
   * @param {API.Matcher<W>} right
   */ constructor(left, right){
        super();
        this.left = left;
        this.right = right;
    }
    /**
   * @param {API.Source} capability
   * @return {API.MatchResult<M|W>}
   */ match(capability) {
        const left = this.left.match(capability);
        if (left.error) {
            const right = this.right.match(capability);
            if (right.error) {
                return right.error.name === 'MalformedCapability' ? right : left;
            } else {
                return right;
            }
        } else {
            return left;
        }
    }
    toString() {
        return `${this.left.toString()}|${this.right.toString()}`;
    }
}
/**
 * @template {API.MatchSelector<API.Match>[]} Selectors
 * @implements {API.CapabilitiesParser<API.InferMembers<Selectors>>}
 * @extends {View<API.Amplify<API.InferMembers<Selectors>>>}
 */ class And extends View {
    /**
   * @param {Selectors} selectors
   */ constructor(selectors){
        super();
        this.selectors = selectors;
    }
    /**
   * @param {API.Source} capability
   * @returns {API.MatchResult<API.Amplify<API.InferMembers<Selectors>>>}
   */ match(capability) {
        const group = [];
        for (const selector of this.selectors){
            const result = selector.match(capability);
            if (result.error) {
                return result;
            } else {
                group.push(result.ok);
            }
        }
        return {
            ok: new AndMatch(group)
        };
    }
    /**
   * @param {API.Source[]} capabilities
   */ select(capabilities) {
        return selectGroup(this, capabilities);
    }
    /**
   * @template E
   * @template {API.Match} X
   * @param {API.MatchSelector<API.Match<E, X>>} other
   * @returns {API.CapabilitiesParser<[...API.InferMembers<Selectors>, API.Match<E, X>]>}
   */ and(other) {
        return new And([
            ...this.selectors,
            other
        ]);
    }
    toString() {
        return `[${this.selectors.map(String).join(', ')}]`;
    }
}
/**
 * @template {API.ParsedCapability} T
 * @template {API.Match} M
 * @implements {API.TheCapabilityParser<API.DerivedMatch<T, M>>}
 * @extends {Unit<API.DerivedMatch<T, M>>}
 */ class Derive extends Unit {
    /**
   * @param {API.MatchSelector<M>} from
   * @param {API.TheCapabilityParser<API.DirectMatch<T>>} to
   * @param {API.Derives<T, API.InferDeriveProof<M['value']>>} derives
   */ constructor(from, to, derives){
        super();
        this.from = from;
        this.to = to;
        this.derives = derives;
    }
    /**
   * @type {typeof this.to['create']}
   */ create(options) {
        return this.to.create(options);
    }
    /**
   * @type {typeof this.to['invoke']}
   */ invoke(options) {
        return this.to.invoke(options);
    }
    /**
   * @type {typeof this.to['delegate']}
   */ delegate(options) {
        return this.to.delegate(options);
    }
    get can() {
        return this.to.can;
    }
    /**
   * @param {API.Source} capability
   * @returns {API.MatchResult<API.DerivedMatch<T, M>>}
   */ match(capability) {
        const match = this.to.match(capability);
        if (match.error) {
            return match;
        } else {
            return {
                ok: new DerivedMatch(match.ok, this.from, this.derives)
            };
        }
    }
    toString() {
        return this.to.toString();
    }
}
/**
 * @template {API.Ability} A
 * @template {API.URI} R
 * @template {API.Caveats} C
 * @implements {API.DirectMatch<API.ParsedCapability<A, R, C>>}
 */ class Match {
    /**
   * @param {API.Source} source
   * @param {API.ParsedCapability<A, R, C>} value
   * @param {Required<Descriptor<A, R, C>>} descriptor
   */ constructor(source, value, descriptor){
        this.source = [
            source
        ];
        this.value = value;
        this.descriptor = descriptor;
    }
    get can() {
        return this.value.can;
    }
    get proofs() {
        const proofs = [
            this.source[0].delegation
        ];
        Object.defineProperties(this, {
            proofs: {
                value: proofs
            }
        });
        return proofs;
    }
    /**
   * @param {API.CanIssue} context
   * @returns {API.DirectMatch<API.ParsedCapability<A, R, C>>|null}
   */ prune(context) {
        if (context.canIssue(this.value, this.source[0].delegation.issuer.did())) {
            return null;
        } else {
            return this;
        }
    }
    /**
   * @param {API.Source[]} capabilities
   * @returns {API.Select<API.DirectMatch<API.ParsedCapability<A, R, C>>>}
   */ select(capabilities) {
        const unknown = [];
        const errors = [];
        const matches = [];
        for (const capability of capabilities){
            const result = resolveCapability(this.descriptor, this.value, capability);
            if (result.ok) {
                const claim = this.descriptor.derives(this.value, result.ok);
                if (claim.error) {
                    errors.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["DelegationError"]([
                        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["EscalatedCapability"](this.value, result.ok, claim.error)
                    ], this));
                } else {
                    matches.push(new Match(capability, result.ok, this.descriptor));
                }
            } else {
                switch(result.error.name){
                    case 'UnknownCapability':
                        unknown.push(result.error.capability);
                        break;
                    case 'MalformedCapability':
                    default:
                        errors.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["DelegationError"]([
                            result.error
                        ], this));
                }
            }
        }
        return {
            matches,
            unknown,
            errors
        };
    }
    toString() {
        const { nb } = this.value;
        return JSON.stringify({
            can: this.descriptor.can,
            with: this.value.with,
            nb: nb && Object.keys(nb).length > 0 ? nb : undefined
        });
    }
}
/**
 * @template {API.ParsedCapability} T
 * @template {API.Match} M
 * @implements {API.DerivedMatch<T, M>}
 */ class DerivedMatch {
    /**
   * @param {API.DirectMatch<T>} selected
   * @param {API.MatchSelector<M>} from
   * @param {API.Derives<T, API.InferDeriveProof<M['value']>>} derives
   */ constructor(selected, from, derives){
        this.selected = selected;
        this.from = from;
        this.derives = derives;
    }
    get can() {
        return this.value.can;
    }
    get source() {
        return this.selected.source;
    }
    get proofs() {
        const proofs = [];
        for (const { delegation } of this.selected.source){
            proofs.push(delegation);
        }
        Object.defineProperties(this, {
            proofs: {
                value: proofs
            }
        });
        return proofs;
    }
    get value() {
        return this.selected.value;
    }
    /**
   * @param {API.CanIssue} context
   */ prune(context) {
        const selected = this.selected.prune(context);
        return selected ? new DerivedMatch(selected, this.from, this.derives) : null;
    }
    /**
   * @param {API.Source[]} capabilities
   */ select(capabilities) {
        const { derives, selected, from } = this;
        const { value } = selected;
        const direct = selected.select(capabilities);
        const derived = from.select(capabilities);
        const matches = [];
        const errors = [];
        for (const match of derived.matches){
            // If capability can not be derived it escalates
            const result = derives(value, match.value);
            if (result.error) {
                errors.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["DelegationError"]([
                    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["EscalatedCapability"](value, match.value, result.error)
                ], this));
            } else {
                matches.push(match);
            }
        }
        return {
            unknown: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["intersection"])(direct.unknown, derived.unknown),
            errors: [
                ...errors,
                ...direct.errors,
                ...derived.errors.map((error)=>new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["DelegationError"]([
                        error
                    ], this))
            ],
            matches: [
                ...direct.matches.map((match)=>new DerivedMatch(match, from, derives)),
                ...matches
            ]
        };
    }
    toString() {
        return this.selected.toString();
    }
}
/**
 * @template {API.MatchSelector<API.Match>[]} Selectors
 * @implements {API.Amplify<API.InferMembers<Selectors>>}
 */ class AndMatch {
    /**
   * @param {API.Match[]} matches
   */ constructor(matches){
        this.matches = matches;
    }
    get selectors() {
        return this.matches;
    }
    /**
   * @returns {API.Source[]}
   */ get source() {
        const source = [];
        for (const match of this.matches){
            source.push(...match.source);
        }
        Object.defineProperties(this, {
            source: {
                value: source
            }
        });
        return source;
    }
    /**
   * @param {API.CanIssue} context
   */ prune(context) {
        const matches = [];
        for (const match of this.matches){
            const pruned = match.prune(context);
            if (pruned) {
                matches.push(pruned);
            }
        }
        return matches.length === 0 ? null : new AndMatch(matches);
    }
    get proofs() {
        const proofs = [];
        for (const { delegation } of this.source){
            proofs.push(delegation);
        }
        Object.defineProperties(this, {
            proofs: {
                value: proofs
            }
        });
        return proofs;
    }
    /**
   * @type {API.InferValue<API.InferMembers<Selectors>>}
   */ get value() {
        const value = [];
        for (const match of this.matches){
            value.push(match.value);
        }
        Object.defineProperties(this, {
            value: {
                value
            }
        });
        return value;
    }
    /**
   * @param {API.Source[]} capabilities
   */ select(capabilities) {
        return selectGroup(this, capabilities);
    }
    toString() {
        return `[${this.matches.map((match)=>match.toString()).join(', ')}]`;
    }
}
/**
 * Resolves ability `pattern` of the delegated capability from the ability
 * of the claimed capability. If pattern matches returns claimed ability
 * otherwise returns given `fallback`.
 *
 * @example
 * ```js
 * resolveAbility('*', 'store/add', null) // => 'store/add'
 * resolveAbility('store/*', 'store/add', null) // => 'store/add'
 * resolveAbility('store/add', 'store/add', null) // => 'store/add'
 * resolveAbility('store/', 'store/add', null) // => null
 * resolveAbility('store/a*', 'store/add', null) // => null
 * resolveAbility('store/list', 'store/add', null) // => null
 * ```
 *
 * @template {API.Ability} T
 * @template U
 * @param {string} pattern
 * @param {T} can
 * @param {U} fallback
 * @returns {T|U}
 */ const resolveAbility = (pattern, can, fallback)=>{
    switch(pattern){
        case can:
        case '*':
            return can;
        default:
            return pattern.endsWith('/*') && can.startsWith(pattern.slice(0, -1)) ? can : fallback;
    }
};
/**
 * Resolves `source` resource of the delegated capability from the resource
 * `uri` of the claimed capability. If `source` is `"ucan:*""` or matches `uri`
 * then it returns `uri` back otherwise it returns `fallback`.
 *
 * @example
 * ```js
 * resolveResource('ucan:*', 'did:key:zAlice', null) // => 'did:key:zAlice'
 * resolveAbility('ucan:*', 'https://example.com', null) // => 'https://example.com'
 * resolveAbility('did:*', 'did:key:zAlice', null) // => null
 * resolveAbility('did:key:zAlice', 'did:key:zAlice', null) // => did:key:zAlice
 * ```
 * @template {string} T
 * @template U
 * @param {T} uri
 * @param {string} source
 * @param {U} fallback
 * @returns {T|U}
 */ const resolveResource = (source, uri, fallback)=>{
    switch(source){
        case uri:
        case 'ucan:*':
            return uri;
        default:
            return fallback;
    }
};
/**
 * Parses capability from the `source` using a provided `parser`.
 *
 * @template {API.Ability} A
 * @template {API.URI} R
 * @template {API.Caveats} C
 * @param {Required<Descriptor<A, R, C>>} descriptor
 * @param {API.Source} source
 * @returns {API.Result<API.ParsedCapability<A, R, C>, API.InvalidCapability>}
 */ const parseCapability = (descriptor, source)=>{
    const { delegation } = source;
    const capability = source.capability;
    if (descriptor.can !== capability.can) {
        return {
            error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["UnknownCapability"](capability)
        };
    }
    const uri = descriptor.with.read(capability.with);
    if (uri.error) {
        return {
            error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["MalformedCapability"](capability, uri.error)
        };
    }
    const nb = descriptor.nb.read(capability.nb || {});
    if (nb.error) {
        return {
            error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["MalformedCapability"](capability, nb.error)
        };
    }
    return {
        ok: new CapabilityView(descriptor.can, uri.ok, nb.ok, delegation)
    };
};
/**
 * Resolves delegated capability `source` from the `claimed` capability using
 * provided capability `parser`. It is similar to `parseCapability` except
 * `source` here is treated as capability pattern which is matched against the
 * `claimed` capability. This means we resolve `can` and `with` fields from the
 * `claimed` capability and inherit all missing `nb` fields from the claimed
 * capability.
 *
 * @template {API.Ability} A
 * @template {API.URI} R
 * @template {API.Caveats} C
 * @param {Required<Descriptor<A, R, C>>} descriptor
 * @param {API.ParsedCapability<A, R, C>} claimed
 * @param {API.Source} source
 * @returns {API.Result<API.ParsedCapability<A, R, C>, API.InvalidCapability>}
 */ const resolveCapability = (descriptor, claimed, { capability, delegation })=>{
    const can = resolveAbility(capability.can, claimed.can, null);
    if (can == null) {
        return {
            error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["UnknownCapability"](capability)
        };
    }
    const resource = resolveResource(capability.with, claimed.with, capability.with);
    const uri = descriptor.with.read(resource);
    if (uri.error) {
        return {
            error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["MalformedCapability"](capability, uri.error)
        };
    }
    const nb = descriptor.nb.read({
        ...claimed.nb,
        ...capability.nb
    });
    if (nb.error) {
        return {
            error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["MalformedCapability"](capability, nb.error)
        };
    }
    return {
        ok: new CapabilityView(can, uri.ok, nb.ok, delegation)
    };
};
/**
 * @template {API.Ability} A
 * @template {API.URI} R
 * @template C
 */ class CapabilityView {
    /**
   * @param {A} can
   * @param {R} with_
   * @param {C} nb
   * @param {API.Delegation} delegation
   */ constructor(can, with_, nb, delegation){
        this.can = can;
        this.with = with_;
        this.delegation = delegation;
        this.nb = nb;
    }
}
/**
 * @template {API.Match} M
 * @param {API.Matcher<M>} matcher
 * @param {API.Source[]} capabilities
 * @returns {API.Select<M>}
 */ const select = (matcher, capabilities)=>{
    const unknown = [];
    const matches = [];
    const errors = [];
    for (const capability of capabilities){
        const result = matcher.match(capability);
        if (result.error) {
            switch(result.error.name){
                case 'UnknownCapability':
                    unknown.push(result.error.capability);
                    break;
                case 'MalformedCapability':
                default:
                    errors.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["DelegationError"]([
                        result.error
                    ], result.error.capability));
            }
        } else {
            matches.push(result.ok);
        }
    }
    return {
        matches,
        errors,
        unknown
    };
};
/**
 * @template {API.Selector<API.Match>[]} S
 * @param {{selectors:S}} self
 * @param {API.Source[]} capabilities
 */ const selectGroup = (self, capabilities)=>{
    let unknown;
    const data = [];
    const errors = [];
    for (const selector of self.selectors){
        const selected = selector.select(capabilities);
        unknown = unknown ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["intersection"])(unknown, selected.unknown) : selected.unknown;
        for (const error of selected.errors){
            errors.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["DelegationError"]([
                error
            ], self));
        }
        data.push(selected.matches);
    }
    const matches = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["combine"])(data).map((group)=>new AndMatch(group));
    return {
        unknown: /* c8 ignore next */ unknown || [],
        errors,
        matches
    };
};
/**
 * @template {API.ParsedCapability} T
 * @template {API.ParsedCapability} U
 * @param {T} claimed
 * @param {U} delegated
 * @return {API.Result<true, API.Failure>}
 */ const defaultDerives = (claimed, delegated)=>{
    if (delegated.with.endsWith('*')) {
        if (!claimed.with.startsWith(delegated.with.slice(0, -1))) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__["Schema"].error(`Resource ${claimed.with} does not match delegated ${delegated.with} `);
        }
    } else if (delegated.with !== claimed.with) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__["Schema"].error(`Resource ${claimed.with} is not contained by ${delegated.with}`);
    }
    /* c8 ignore next 2 */ const caveats = delegated.nb || {};
    const nb = claimed.nb || {};
    const kv = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["entries"])(caveats);
    for (const [name, value] of kv){
        if (nb[name] != value) {
            return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__["Schema"].error(`${String(name)}: ${nb[name]} violates ${value}`);
        }
    }
    return {
        ok: true
    };
};
}),
"[project]/node_modules/@ucanto/validator/src/authorization.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "create",
    ()=>create,
    "iterate",
    ()=>iterate
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$interface$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/interface/src/lib.js [app-client] (ecmascript)");
;
/**
 * @template {API.ParsedCapability} C
 * @implements {API.Authorization<C>}
 */ class Authorization {
    /**
   * @param {API.Match<C>} match
   * @param {API.Authorization<API.ParsedCapability>[]} proofs
   */ constructor(match, proofs){
        this.match = match;
        this.proofs = proofs;
    }
    get capability() {
        return this.match.value;
    }
    get delegation() {
        return this.match.source[0].delegation;
    }
    get issuer() {
        return this.delegation.issuer;
    }
    get audience() {
        return this.delegation.audience;
    }
}
const create = (match, proofs = [])=>new Authorization(match, proofs);
const iterate = function*({ delegation, proofs }) {
    yield delegation.cid;
    for (const proof of proofs){
        yield* iterate(proof);
    }
};
}),
"[project]/node_modules/@ucanto/validator/src/lib.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "access",
    ()=>access,
    "authorize",
    ()=>authorize,
    "claim",
    ()=>claim
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$interface$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/interface/src/lib.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/lib.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$delegation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/delegation.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__UCAN$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/lib.js [app-client] (ecmascript) <export * as UCAN>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/result.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$capability$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/validator/src/capability.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/schema.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/schema.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/schema/schema.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2f$link$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__$3c$export__match__as__link$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/schema/link.js [app-client] (ecmascript) <locals> <export match as link>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$authorization$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/validator/src/authorization.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/validator/src/error.js [app-client] (ecmascript) <locals>");
;
;
;
;
;
;
;
;
;
/**
 * @param {UCAN.Link} proof
 * @returns {{error:API.UnavailableProof}}
 */ const unavailable = (proof)=>({
        error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["UnavailableProof"](proof)
    });
/**
 *
 * @param {UCAN.DID} did
 * @returns {{error:API.DIDKeyResolutionError}}
 */ const failDIDKeyResolution = (did)=>({
        error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["DIDKeyResolutionError"](did)
    });
/**
 * @param {Required<API.ClaimOptions>} config
 * @param {API.Match<unknown, API.Match>} match
 */ const resolveMatch = async (match, config)=>{
    const promises = [];
    const includes = new Set();
    for (const source of match.source){
        const id = source.delegation.cid.toString();
        if (!includes.has(id)) {
            promises.push(await resolveSources(source, config));
        }
    }
    const groups = await Promise.all(promises);
    const sources = [];
    const errors = [];
    for (const group of groups){
        sources.push(...group.sources);
        errors.push(...group.errors);
    }
    return {
        sources,
        errors
    };
};
/**
 * Takes `proofs` from the delegation which may contain `Delegation` or a link
 * to one and attempts to resolve links by side loading them. Returns set of
 * resolved `Delegation`s and errors for the proofs that could not be resolved.
 *
 * @param {API.Proof[]} proofs
 * @param {Required<API.ProofResolver>} config
 */ const resolveProofs = async (proofs, config)=>{
    /** @type {API.Delegation[]} */ const delegations = [];
    /** @type {API.UnavailableProof[]} */ const errors = [];
    const promises = [];
    for (const proof of proofs){
        // If it is a delegation we can just add it to the resolved set.
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$delegation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDelegation"])(proof)) {
            delegations.push(proof);
        } else {
            promises.push(new Promise(async (resolve)=>{
                // config.resolve is not supposed to throw, but we catch it just in
                // case it does and consider proof resolution failed.
                try {
                    const result = await config.resolve(proof);
                    if (result.error) {
                        errors.push(result.error);
                    } else {
                        delegations.push(result.ok);
                    }
                } catch (error) {
                    errors.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["UnavailableProof"](proof, error));
                }
                // we don't care about the result, we just need to signal that we are
                // done with this promise.
                resolve(null);
            }));
        }
    }
    // Wait for all the promises to resolve. At this point we have collected all
    // the resolved delegations and errors.
    await Promise.all(promises);
    return {
        delegations,
        errors
    };
};
/**
 * Takes a delegation source and attempts to resolve all the linked proofs.
 *
 * @param {API.Source} from
 * @param {Required<API.ClaimOptions>} config
 * @return {Promise<{sources:API.Source[], errors:ProofError[]}>}
 */ const resolveSources = async ({ delegation }, config)=>{
    const errors = [];
    const sources = [];
    const proofs = [];
    // First we attempt to resolve all the linked proofs.
    const { delegations, errors: failedProofs } = await resolveProofs(delegation.proofs, config);
    // All the proofs that failed to resolve are saved as proof errors.
    for (const error of failedProofs){
        errors.push(new ProofError(error.link, error));
    }
    // All the proofs that resolved are checked for principal alignment. Ones that
    // do not align are saved as proof errors.
    for (const proof of delegations){
        // If proof does not delegate to a matching audience save an proof error.
        if (delegation.issuer.did() !== proof.audience.did()) {
            errors.push(new ProofError(proof.cid, new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["PrincipalAlignmentError"](delegation.issuer, proof)));
        } else {
            proofs.push(proof);
        }
    }
    // In the second pass we attempt to proofs that were resolved and are aligned.
    for (const proof of proofs){
        // If proof is not valid (expired, not active yet or has incorrect
        // signature) save a corresponding proof error.
        const validation = await validate(proof, proofs, config);
        if (validation.error) {
            errors.push(new ProofError(proof.cid, validation.error));
        } else {
            // otherwise create source objects for it's capabilities, so we could
            // track which proof in which capability the are from.
            for (const capability of proof.capabilities){
                sources.push({
                    capability,
                    delegation: proof
                });
            }
        }
    }
    return {
        sources,
        errors
    };
};
/**
 * @param {API.ParsedCapability} capability
 * @param {API.DID} issuer
 */ const isSelfIssued = (capability, issuer)=>capability.with === issuer;
const access = async (invocation, { capability, ...config })=>claim(capability, [
        invocation
    ], config);
const claim = async (capability, proofs, { authority, principal, validateAuthorization, resolveDIDKey = failDIDKeyResolution, canIssue = isSelfIssued, resolve = unavailable, proofs: localProofs = [] })=>{
    const config = {
        canIssue,
        resolve,
        principal,
        capability,
        authority,
        validateAuthorization,
        resolveDIDKey,
        proofs: localProofs
    };
    const invalidProofs = [];
    /** @type {API.Source[]} */ const sources = [];
    const { delegations, errors } = await resolveProofs(proofs, config);
    invalidProofs.push(...errors);
    for (const proof of delegations){
        // Validate each proof if valid add ech capability to the list of sources.
        // otherwise collect the error.
        const validation = await validate(proof, delegations, config);
        if (validation.ok) {
            for (const capability of validation.ok.capabilities.values()){
                sources.push({
                    capability,
                    delegation: validation.ok
                });
            }
        } else {
            invalidProofs.push(validation.error);
        }
    }
    // look for the matching capability
    const selection = capability.select(sources);
    const { errors: delegationErrors, unknown: unknownCapabilities } = selection;
    const failedProofs = [];
    for (const matched of selection.matches){
        const selector = matched.prune(config);
        if (selector == null) {
            const authorization = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$authorization$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"](matched, []);
            const result = await validateAuthorization(authorization);
            if (result.error) {
                invalidProofs.push(result.error);
            } else {
                return {
                    ok: authorization
                };
            }
        } else {
            const result = await authorize(selector, config);
            if (result.error) {
                failedProofs.push(result.error);
            } else {
                const authorization = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$authorization$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"](matched, [
                    result.ok
                ]);
                const approval = await validateAuthorization(authorization);
                if (approval.error) {
                    invalidProofs.push(approval.error);
                } else {
                    return {
                        ok: authorization
                    };
                }
            }
        }
    }
    return {
        error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Unauthorized"]({
            capability,
            delegationErrors,
            unknownCapabilities,
            invalidProofs,
            failedProofs
        })
    };
};
const authorize = async (match, config)=>{
    // load proofs from all delegations
    const { sources, errors: invalidProofs } = await resolveMatch(match, config);
    const selection = match.select(sources);
    const { errors: delegationErrors, unknown: unknownCapabilities } = selection;
    const failedProofs = [];
    for (const matched of selection.matches){
        const selector = matched.prune(config);
        if (selector == null) {
            return {
                ok: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$authorization$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"](// @ts-expect-error - it may not be a parsed capability but rather a
                // group of capabilities but we can deal with that in the future.
                matched, [])
            };
        } else {
            const result = await authorize(selector, config);
            if (result.error) {
                failedProofs.push(result.error);
            } else {
                return {
                    ok: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$authorization$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"](// @ts-expect-error - it may not be a parsed capability but rather a
                    // group of capabilities but we can deal with that in the future.
                    matched, [
                        result.ok
                    ])
                };
            }
        }
    }
    return {
        error: new InvalidClaim({
            match,
            delegationErrors,
            unknownCapabilities,
            invalidProofs,
            failedProofs
        })
    };
};
class ProofError extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {API.UCANLink} proof
   * @param {API.Failure} cause
   */ constructor(proof, cause){
        super();
        this.name = 'ProofError';
        this.proof = proof;
        this.cause = cause;
    }
    describe() {
        return [
            `Capability can not be derived from prf:${this.proof} because:`,
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["li"])(this.cause.message)
        ].join(`\n`);
    }
}
/**
 * @implements {API.InvalidClaim}
 */ class InvalidClaim extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Failure"] {
    /**
   * @param {{
   * match: API.Match
   * delegationErrors: API.DelegationError[]
   * unknownCapabilities: API.Capability[]
   * invalidProofs: ProofError[]
   * failedProofs: API.InvalidClaim[]
   * }} info
   */ constructor(info){
        super();
        this.info = info;
        this.name = 'InvalidClaim';
    }
    get issuer() {
        return this.delegation.issuer;
    }
    get delegation() {
        return this.info.match.source[0].delegation;
    }
    describe() {
        const errors = [
            ...this.info.failedProofs.map((error)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["li"])(error.message)),
            ...this.info.delegationErrors.map((error)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["li"])(error.message)),
            ...this.info.invalidProofs.map((error)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["li"])(error.message))
        ];
        const unknown = this.info.unknownCapabilities.map((c)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["li"])(JSON.stringify(c)));
        return [
            `Capability ${this.info.match} is not authorized because:`,
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["li"])(`Capability can not be (self) issued by '${this.issuer.did()}'`),
            ...errors.length > 0 ? errors : [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["li"])(`Delegated capability not found`)
            ],
            ...unknown.length > 0 ? [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["li"])(`Encountered unknown capabilities\n${unknown.join('\n')}`)
            ] : []
        ].join('\n');
    }
}
/**
 * Validate a delegation to check it is within the time bound and that it is
 * authorized by the issuer.
 *
 * @template {API.Delegation} T
 * @param {T} delegation
 * @param {API.Delegation[]} proofs
 * @param {Required<API.ClaimOptions>} config
 * @returns {Promise<API.Result<T, API.InvalidProof|API.SessionEscalation|API.DIDKeyResolutionError>>}
 */ const validate = async (delegation, proofs, config)=>{
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__UCAN$3e$__["UCAN"].isExpired(delegation.data)) {
        return {
            error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Expired"](delegation)
        };
    }
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__UCAN$3e$__["UCAN"].isTooEarly(delegation.data)) {
        return {
            error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["NotValidBefore"](delegation)
        };
    }
    return await verifyAuthorization(delegation, proofs, config);
};
/**
 * Verifies that delegation has been authorized by the issuer. If issued by the
 * did:key principal checks that the signature is valid. If issued by the root
 * authority checks that the signature is valid. If issued by the principal
 * identified by other DID method attempts to resolve a valid `ucan/attest`
 * attestation from the authority, if attestation is not found falls back to
 * resolving did:key for the issuer and verifying its signature.
 *
 * @template {API.Delegation} T
 * @param {T} delegation
 * @param {API.Delegation[]} proofs
 * @param {Required<API.ClaimOptions>} config
 * @returns {Promise<API.Result<T, API.InvalidSignature|API.SessionEscalation|API.DIDKeyResolutionError>>}
 */ const verifyAuthorization = async (delegation, proofs, config)=>{
    const issuer = delegation.issuer.did();
    // If the issuer is a did:key we just verify a signature
    if (issuer.startsWith('did:key:')) {
        return verifySignature(delegation, config.principal.parse(issuer));
    } else if (issuer === config.authority.did()) {
        return verifySignature(delegation, config.authority);
    } else {
        // If issuer is not a did:key principal nor configured authority, we
        // attempt to resolve embedded authorization session from the authority.
        const session = await verifySession(delegation, proofs, config);
        // If we have valid session we consider authorization valid
        if (session.ok) {
            return {
                ok: delegation
            };
        } else if (session.error.failedProofs.length > 0) {
            return {
                error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["SessionEscalation"]({
                    delegation,
                    cause: session.error
                })
            };
        } else {
            const result = await config.resolveDIDKey(issuer);
            if (result.error) {
                return result;
            }
            const verifiers = result.ok;
            /** @type {(API.InvalidSignature | API.DIDKeyResolutionError)[]} */ const verificationErrResults = [];
            for (const verifier of verifiers){
                const verificationResult = await verifySignature(delegation, config.principal.parse(verifier).withDID(issuer));
                if (verificationResult.ok) {
                    return verificationResult;
                }
                if (verificationResult.error) {
                    verificationErrResults.push(verificationResult.error);
                }
            }
            // If no verifiers were found, there is no way to verify the signature
            if (verificationErrResults.length === 0) {
                return {
                    error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["DIDKeyResolutionError"](issuer)
                };
            }
            const combinedError = verificationErrResults[0];
            const combinedMessage = verificationErrResults.map((err)=>err.message).join('\n  ');
            // @ts-expect-error - both error types have describe method, override it to return the concatenated message
            combinedError.describe = ()=>combinedMessage;
            return {
                error: combinedError
            };
        }
    }
};
/**
 * @template {API.Delegation} T
 * @param {T} delegation
 * @param {API.Verifier} verifier
 * @returns {Promise<API.Result<T, API.InvalidSignature|API.DIDKeyResolutionError>>}
 */ const verifySignature = async (delegation, verifier)=>{
    const valid = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__UCAN$3e$__["UCAN"].verifySignature(delegation.data, verifier);
    return valid ? {
        ok: delegation
    } : {
        error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$error$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["InvalidSignature"](delegation, verifier)
    };
};
/**
 * Attempts to find an authorization session - an `ucan/attest` capability
 * delegation where `with` matches `config.authority` and `nb.proof`
 * matches given delegation.
 * @see https://github.com/storacha/specs/blob/feat/auth+account/w3-session.md#authorization-session
 *
 * @param {API.Delegation} delegation
 * @param {API.Delegation[]} proofs
 * @param {Required<API.ClaimOptions>} config
 */ const verifySession = async (delegation, proofs, config)=>{
    // Recognize attestations from all authorized principals, not just authority
    const withSchemas = config.proofs.filter((p)=>p.capabilities[0].can === 'ucan/attest' && p.capabilities[0].with === config.authority.did()).map((p)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["literal"](p.audience.did()));
    const withSchema = withSchemas.length ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["union"]([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["literal"](config.authority.did()),
        ...withSchemas
    ]) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["literal"](config.authority.did());
    // Create a schema that will match an authorization for this exact delegation
    const attestation = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$validator$2f$src$2f$capability$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["capability"])({
        with: withSchema,
        can: 'ucan/attest',
        nb: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["struct"]({
            proof: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2f$link$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__$3c$export__match__as__link$3e$__["link"](delegation.cid)
        })
    });
    return await claim(attestation, proofs// We only consider attestations otherwise we will end up doing an
    // exponential scan if there are other proofs that require attestations.
    .filter(isAttestation)// Also filter any proofs that _are_ the delegation we're verifying so
    // we don't recurse indefinitely.
    .filter((p)=>p.cid.toString() !== delegation.cid.toString()), config);
};
/**
 * Checks if the delegation is an attestation.
 *
 * @param {API.Delegation} proof
 */ const isAttestation = (proof)=>proof.capabilities[0]?.can === 'ucan/attest';
}),
"[project]/node_modules/@storacha/access/dist/errors.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
;
 //# sourceMappingURL=errors.js.map
}),
"[project]/node_modules/@storacha/access/dist/types.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

// export other types
__turbopack_context__.s([
    "AppName",
    ()=>AppName
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$interface$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/interface/src/lib.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/capabilities/dist/types.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$errors$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/dist/errors.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$did$2d$mailto$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@storacha/did-mailto/dist/index.js [app-client] (ecmascript) <locals>");
;
;
;
;
var AppName;
(function(AppName) {
    AppName["BskyBackups"] = "bsky-backups";
    AppName["TGMiniapp"] = "tg-miniapp";
    AppName["Console"] = "console";
})(AppName || (AppName = {})); //# sourceMappingURL=types.js.map
}),
"[project]/node_modules/@storacha/access/dist/encoding.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Encoding utilities
 *
 * It is recommended that you import directly with:
 * ```js
 * import * as Encoding from '@storacha/access/encoding'
 *
 * // or
 *
 * import { encodeDelegations } from '@storacha/access/encoding'
 * ```
 *
 * @module
 */ __turbopack_context__.s([
    "bytesToDelegations",
    ()=>bytesToDelegations,
    "delegationToString",
    ()=>delegationToString,
    "delegationsToBytes",
    ()=>delegationsToBytes,
    "delegationsToString",
    ()=>delegationsToString,
    "expirationToDate",
    ()=>expirationToDate,
    "stringToDelegation",
    ()=>stringToDelegation,
    "stringToDelegations",
    ()=>stringToDelegations
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$buffer$2d$reader$2d$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/buffer-reader-browser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$buffer$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/buffer-writer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$delegation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/delegation.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/node_modules/uint8arrays/dist/src/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/node_modules/uint8arrays/dist/src/to-string.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$from$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/node_modules/uint8arrays/dist/src/from-string.js [app-client] (ecmascript)");
// eslint-disable-next-line no-unused-vars
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$interface$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/interface/src/lib.js [app-client] (ecmascript)");
;
;
;
;
;
function delegationsToBytes(delegations) {
    if (!Array.isArray(delegations) || delegations.length === 0) {
        throw new Error('Delegations required to be an non empty array.');
    }
    const roots = delegations.map((d)=>d.root.cid);
    const cids = new Set();
    /** @type {CarBufferWriter.Block[]} */ const blocks = [];
    let byteLength = 0;
    for (const delegation of delegations){
        for (const block of delegation.export()){
            const cid = block.cid.toV1().toString();
            if (!cids.has(cid)) {
                byteLength += __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$buffer$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["blockLength"](block);
                blocks.push(block);
                cids.add(cid);
            }
        }
    }
    const headerLength = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$buffer$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["estimateHeaderLength"](roots.length);
    const writer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$buffer$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createWriter"](new ArrayBuffer(headerLength + byteLength), {
        roots
    });
    for (const block of blocks){
        writer.write(block);
    }
    return writer.close();
}
function bytesToDelegations(bytes) {
    if (!(bytes instanceof Uint8Array) || bytes.length === 0) {
        throw new TypeError('Input should be a non-empty Uint8Array.');
    }
    const reader = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$buffer$2d$reader$2d$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CarBufferReader"].fromBytes(bytes);
    const roots = reader.getRoots();
    /** @type {Types.Delegation<T>[]} */ const delegations = [];
    for (const root of roots){
        const rootBlock = reader.get(root);
        if (rootBlock) {
            const blocks = new Map();
            for (const block of reader.blocks()){
                if (block.cid.toString() !== root.toString()) blocks.set(block.cid.toString(), block);
            }
            // @ts-ignore
            delegations.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$delegation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Delegation"](rootBlock, blocks));
        } else {
            throw new Error('Failed to find root from raw delegation.');
        }
    }
    return delegations;
}
function delegationsToString(delegations, encoding = 'base64url') {
    const bytes = delegationsToBytes(delegations);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toString"](bytes, encoding);
}
function delegationToString(delegation, encoding) {
    return delegationsToString([
        delegation
    ], encoding);
}
function stringToDelegations(raw, encoding = 'base64url') {
    const bytes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$from$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromString"](raw, encoding);
    return bytesToDelegations(bytes);
}
function stringToDelegation(raw, encoding) {
    const delegations = stringToDelegations(raw, encoding);
    return delegations[0];
}
function expirationToDate(expiration) {
    const expires = expiration === Infinity || !expiration ? undefined : new Date(expiration * 1000);
    return expires;
} //# sourceMappingURL=encoding.js.map
}),
"[project]/node_modules/@storacha/access/dist/access.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "GrantedAccess",
    ()=>GrantedAccess,
    "accountAccess",
    ()=>accountAccess,
    "claim",
    ()=>claim,
    "createPendingAccessRequest",
    ()=>createPendingAccessRequest,
    "delegate",
    ()=>delegate,
    "request",
    ()=>request,
    "spaceAccess",
    ()=>spaceAccess,
    "toCapabilities",
    ()=>toCapabilities
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$access$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@storacha/capabilities/dist/access.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/dist/types.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/lib.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/result.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__DID$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/did.js [app-client] (ecmascript) <export * as DID>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$agent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/dist/agent.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/dist/encoding.js [app-client] (ecmascript)");
;
;
;
;
;
const delegate = async (agent, { delegations, proofs = [], space = agent.currentSpace() })=>{
    if (!space) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fail"])('Space must be specified');
    }
    const entries = Object.values(delegations).map((proof)=>[
            proof.cid.toString(),
            proof.cid
        ]);
    const { out } = await agent.invokeAndExecute(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$access$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["delegate"], {
        with: space,
        nb: {
            delegations: Object.fromEntries(entries)
        },
        // must be embedded here because it's referenced by cid in .nb.delegations
        proofs: [
            ...delegations,
            ...proofs
        ]
    });
    return out;
};
const request = async (agent, { account, provider = agent.connection.id.did(), audience: audience = agent.did(), access = spaceAccess, appName, sso })=>{
    // Build facts array with appName and SSO object
    const facts = [];
    if (appName) {
        facts.push({
            appName
        });
    }
    if (sso) {
        if (typeof sso !== 'object') {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fail"])('SSO parameter must be an object');
        }
        if (!sso.authProvider || typeof sso.authProvider !== 'string') {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fail"])('SSO authProvider must be a non-empty string');
        }
        if (!sso.externalUserId || typeof sso.externalUserId !== 'string') {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fail"])('SSO externalUserId must be a non-empty string');
        }
        if (!sso.externalSessionToken || typeof sso.externalSessionToken !== 'string') {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fail"])('SSO externalSessionToken must be a non-empty string');
        }
        facts.push({
            sso: {
                authProvider: sso.authProvider,
                externalUserId: sso.externalUserId,
                externalSessionToken: sso.externalSessionToken
            }
        });
    }
    // Request access from the account.
    const { out: result } = await agent.invokeAndExecute(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$access$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["authorize"], {
        audience: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__DID$3e$__["DID"].parse(provider),
        with: audience,
        nb: {
            iss: account,
            // New ucan spec moved to recap style layout for capabilities and new
            // `access/request` will use similar format as opposed to legacy one,
            // in the meantime we translate new format to legacy format here.
            att: [
                ...toCapabilities(access)
            ]
        },
        facts
    });
    return result.error ? result : {
        ok: new PendingAccessRequest({
            ...result.ok,
            agent,
            audience,
            provider
        })
    };
};
const claim = async (agent, { provider = agent.connection.id.did(), audience = agent.did() } = {})=>{
    const { out: result } = await agent.invokeAndExecute(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$access$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["claim"], {
        audience: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__DID$3e$__["DID"].parse(provider),
        with: audience
    });
    if (result.error) {
        return result;
    } else {
        const delegations = Object.values(result.ok.delegations);
        const proofs = delegations.flatMap((proof)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bytesToDelegations"])(proof));
        return {
            ok: new GrantedAccess({
                agent,
                proofs
            })
        };
    }
};
const createPendingAccessRequest = (agent, { request, expiration, provider = agent.connection.id.did(), audience: audience = agent.did() })=>new PendingAccessRequest({
        agent,
        request,
        expiration,
        provider,
        audience
    });
/**
 * Represents a pending access request. It can be used to poll for the requested
 * delegation.
 */ class PendingAccessRequest {
    /**
     * @typedef {object} PendingAccessRequestModel
     * @property {API.Agent} agent - Agent handling interaction.
     * @property {API.DID} audience - Principal requesting an access.
     * @property {API.ProviderDID} provider - Provider handling request.
     * @property {API.UTCUnixTimestamp} expiration - Seconds in UTC.
     * @property {API.Link} request - Link to the `access/authorize` invocation.
     *
     * @param {PendingAccessRequestModel} model
     */ constructor(model){
        this.model = model;
    }
    get agent() {
        return this.model.agent;
    }
    get audience() {
        return this.model.audience;
    }
    get expiration() {
        return new Date(this.model.expiration * 1000);
    }
    get request() {
        return this.model.request;
    }
    get provider() {
        return this.model.provider;
    }
    /**
     * Low level method and most likely you want to use `.claim` instead. This method will poll
     * fetch delegations **just once** and will return proofs matching to this request. Please note
     * that there may not be any matches in which case result will be `{ ok: [] }`.
     *
     * If you do want to continuously poll until request is approved or expired, you should use
     * `.claim` method instead.
     *
     * @returns {Promise<API.Result<API.Delegation[], API.InvocationError|API.AccessClaimFailure|RequestExpired>>}
     */ async poll() {
        const { agent, audience, provider, expiration } = this.model;
        const timeout = expiration * 1000 - Date.now();
        if (timeout <= 0) {
            return {
                error: new RequestExpired(this.model)
            };
        } else {
            const result = await claim(agent, {
                audience,
                provider
            });
            return result.error ? result : {
                ok: result.ok.proofs.filter((proof)=>isRequestedAccess(proof, this.model))
            };
        }
    }
    /**
     * Continuously polls delegations until this request is approved or expired. Returns
     * a `GrantedAccess` object (view over the delegations) that can be used in the
     * invocations or can be saved in the agent (store) using `.save()` method.
     *
     * @param {object} options
     * @param {number} [options.interval]
     * @param {AbortSignal} [options.signal]
     * @returns {Promise<API.Result<GrantedAccess, Error>>}
     */ async claim({ signal, interval = 250 } = {}) {
        while(signal?.aborted !== true){
            const result = await this.poll();
            // If polling failed, return the error.
            if (result.error) {
                return result;
            } else if (result.ok.length > 0) {
                return {
                    ok: new GrantedAccess({
                        agent: this.agent,
                        proofs: result.ok
                    })
                };
            }
            await new Promise((resolve)=>setTimeout(resolve, interval));
        }
        return {
            error: Object.assign(new Error('Aborted'), {
                reason: signal.reason
            })
        };
    }
}
/**
 * Error returned when pending access request expires.
 */ class RequestExpired extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Failure"] {
    /**
     * @param {PendingAccessRequestModel} model
     */ constructor(model){
        super();
        this.model = model;
    }
    get name() {
        return 'RequestExpired';
    }
    get request() {
        return this.model.request;
    }
    get expiredAt() {
        return new Date(this.model.expiration * 1000);
    }
    describe() {
        return `Access request expired at ${this.expiredAt} for ${this.request} request.`;
    }
}
class GrantedAccess {
    /**
     * @typedef {object} GrantedAccessModel
     * @property {API.Agent} agent - Agent that processed the request.
     * @property {API.Tuple<API.Delegation>} proofs - Delegations that grant access.
     *
     * @param {GrantedAccessModel} model
     */ constructor(model){
        this.model = model;
    }
    get proofs() {
        return this.model.proofs;
    }
    /**
     * Saves access into the agents proofs store so that it can be retained
     * between sessions.
     *
     * @param {object} input
     * @param {API.Agent} [input.agent]
     */ save({ agent = this.model.agent } = {}) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$agent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["importAuthorization"])(agent, this);
    }
}
/**
 * Checks if the given delegation is caused by the passed `request` for access.
 *
 * @param {API.Delegation} delegation
 * @param {object} selector
 * @param {API.Link} selector.request
 * @returns
 */ const isRequestedAccess = (delegation, { request })=>// `access/confirm` handler adds facts to the delegation issued by the account
    // so that principal requesting access can identify correct delegation when
    // access is granted.
    delegation.facts.some((fact)=>`${fact['access/request']}` === `${request}`);
const toCapabilities = (access)=>{
    const abilities = [];
    const entries = Object.entries(access);
    for (const [can, details] of entries){
        if (details) {
            abilities.push({
                can
            });
        }
    }
    return abilities;
};
const spaceAccess = {
    'assert/*': {},
    'space/*': {},
    'blob/*': {},
    'index/*': {},
    'store/*': {},
    'upload/*': {},
    'access/*': {},
    'filecoin/*': {},
    'usage/*': {}
};
const accountAccess = {
    '*': {}
}; //# sourceMappingURL=access.js.map
}),
"[project]/node_modules/@storacha/access/dist/provider.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AccountDID",
    ()=>AccountDID,
    "ProviderDID",
    ()=>ProviderDID,
    "add",
    ()=>add
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/dist/types.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$provider$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@storacha/capabilities/dist/provider.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$provider$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/capabilities/dist/provider.js [app-client] (ecmascript)");
;
;
const { Provider: ProviderDID, AccountDID } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$provider$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__;
const add = async (agent, { account, consumer, provider = agent.connection.id.did(), proofs })=>{
    if (!ProviderDID.is(provider)) {
        throw new Error(`Unable to determine provider from agent.connection.id did ${provider}. expected a did:web:`);
    }
    const { out } = await agent.invokeAndExecute(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$provider$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.add, {
        with: account,
        nb: {
            provider,
            consumer
        },
        proofs
    });
    return out;
}; //# sourceMappingURL=provider.js.map
}),
"[project]/node_modules/@storacha/access/dist/space-access.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "SpaceAccess",
    ()=>SpaceAccess
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/dist/types.js [app-client] (ecmascript) <locals>");
;
/**
 * Known valid provider/algorithm combinations
 *
 * @type {Record<string, string[]>}
 */ const VALID_COMBINATIONS = {
    'google-kms': [
        'RSA_DECRYPT_OAEP_3072_SHA256'
    ]
};
class SpaceAccess {
    /**
     * Creates and validates a space access configuration
     *
     * @template {API.SpaceAccessType} T
     * @param {T} [access] - The access configuration to validate
     * @returns {T}
     * @throws {Error} When access configuration is invalid
     */ static from(access) {
        if (!access || access.type === 'public') {
            return {
                type: 'public'
            };
        }
        if (access.type === 'private') {
            if (!access.encryption) {
                throw new Error('Private access type requires encryption configuration');
            }
            const { provider, algorithm } = access.encryption;
            if (!VALID_COMBINATIONS[provider]) {
                throw new Error(`unknown encryption provider: ${provider}`);
            }
            if (!VALID_COMBINATIONS[provider].includes(algorithm)) {
                throw new Error(`unknown encryption algorithm: ${algorithm} for provider: ${provider}`);
            }
            return access;
        }
        throw new Error(`unknown access type: ${/** @type {any} */ access.type}`);
    }
    /**
     * Creates a public space access configuration
     *
     * @returns {API.PublicAccess}
     */ static public() {
        return {
            type: 'public'
        };
    }
    /**
     * Creates a private space access configuration with encryption provider
     *
     * @param {string} [provider] - The encryption provider. Defaults to `google-kms`.
     * @param {string} [algorithm] - The encryption algorithm. Defaults to `RSA_DECRYPT_OAEP_3072_SHA256`.
     * @returns {API.PrivateAccess<API.EncryptionProvider>}
     * @throws {Error} When provider/algorithm combination is invalid
     */ static private(provider = 'google-kms', algorithm = 'RSA_DECRYPT_OAEP_3072_SHA256') {
        if (!VALID_COMBINATIONS[provider]) {
            throw new Error(`unknown encryption provider: ${provider}`);
        }
        if (!VALID_COMBINATIONS[provider].includes(algorithm)) {
            throw new Error(`unknown encryption algorithm: ${algorithm} for provider: ${provider}`);
        }
        return {
            type: 'private',
            encryption: {
                provider,
                algorithm
            }
        };
    }
} //# sourceMappingURL=space-access.js.map
}),
"[project]/node_modules/@storacha/access/dist/space.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "OwnedSpace",
    ()=>OwnedSpace,
    "SESSION_LIFETIME",
    ()=>SESSION_LIFETIME,
    "SharedSpace",
    ()=>SharedSpace,
    "createAuthorization",
    ()=>createAuthorization,
    "createRecovery",
    ()=>createRecovery,
    "fromDelegation",
    ()=>fromDelegation,
    "fromMnemonic",
    ()=>fromMnemonic,
    "generate",
    ()=>generate,
    "provision",
    ()=>provision,
    "toMnemonic",
    ()=>toMnemonic
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/ed25519.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/ed25519/signer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/lib.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$delegation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/delegation.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/schema.js [app-client] (ecmascript) <export * as Schema>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__UCAN$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/lib.js [app-client] (ecmascript) <export * as UCAN>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/result.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__DID$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/did.js [app-client] (ecmascript) <export * as DID>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@scure/bip39/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$esm$2f$wordlists$2f$english$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@scure/bip39/esm/wordlists/english.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/dist/types.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$access$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/dist/access.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$provider$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/dist/provider.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$space$2d$access$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/dist/space-access.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
const generate = async ({ name, access, agent })=>{
    const { signer } = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["generate"]();
    const normalizedAccess = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$space$2d$access$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SpaceAccess"].from(access);
    return new OwnedSpace({
        signer,
        name,
        access: normalizedAccess,
        agent
    });
};
const fromMnemonic = async (mnemonic, { name, access, agent })=>{
    // TODO: Improve recovery UX by auto-detecting access type from existing space metadata
    // or storing access type with space mnemonic. Should default to public if mnemonic
    // doesn't contain access type information.
    const secret = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["mnemonicToEntropy"](mnemonic, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$esm$2f$wordlists$2f$english$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["wordlist"]);
    const signer = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["derive"](secret);
    const normalizedAccess = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$space$2d$access$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SpaceAccess"].from(access);
    return new OwnedSpace({
        signer,
        name,
        access: normalizedAccess,
        agent
    });
};
const toMnemonic = ({ signer })=>{
    /** @type {Uint8Array} */ // @ts-expect-error - Field is defined but not in the interface
    const secret = signer.secret;
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["entropyToMnemonic"](secret, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$esm$2f$wordlists$2f$english$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["wordlist"]);
};
const createRecovery = (space, account)=>createAuthorization(space, {
        audience: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__DID$3e$__["DID"].parse(account),
        access: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$access$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["accountAccess"],
        expiration: Infinity
    });
const SESSION_LIFETIME = 60 * 60 * 24 * 365;
const createAuthorization = async ({ signer, name, access }, { audience, access: spaceAccess = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$access$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["spaceAccess"], expiration = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__UCAN$3e$__["UCAN"].now() + SESSION_LIFETIME })=>{
    const normalizedAccess = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$space$2d$access$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SpaceAccess"].from(access);
    const facts = [
        {
            space: {
                name,
                access: normalizedAccess
            }
        }
    ];
    return await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$delegation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["delegate"])({
        issuer: signer,
        audience: audience,
        capabilities: toCapabilities({
            [signer.did()]: spaceAccess
        }),
        ...expiration ? {
            expiration
        } : {},
        facts
    });
};
/**
 * @param {Record<API.Resource, API.Access>} allow
 * @returns {API.Capabilities}
 */ const toCapabilities = (allow)=>{
    const capabilities = [];
    for (const [subject, access] of Object.entries(allow)){
        const entries = Object.entries(access);
        for (const [can, details] of entries){
            if (details) {
                capabilities.push({
                    can,
                    with: subject
                });
            }
        }
    }
    return capabilities;
};
class OwnedSpace {
    /**
     * @param {Model<S>} model
     */ constructor(model){
        this.model = model;
    }
    get signer() {
        return this.model.signer;
    }
    get name() {
        return this.model.name;
    }
    get access() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$space$2d$access$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SpaceAccess"].from(this.model.access);
    }
    did() {
        return this.signer.did();
    }
    /**
     * Creates a renamed version of this space.
     *
     * @param {string} name
     */ withName(name) {
        return new OwnedSpace({
            signer: this.signer,
            name,
            access: this.access
        });
    }
    /**
     * Saves account in the agent store so it can be accessed across sessions.
     *
     * @param {object} input
     * @param {API.Agent<S>} [input.agent]
     * @returns {Promise<API.Result<API.Unit, Error>>}
     */ async save({ agent = this.model.agent } = {}) {
        if (!agent) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fail"])('Please provide an agent to save the space into');
        }
        const proof = await createAuthorization(this, {
            audience: agent
        });
        await agent.importSpaceFromDelegation(proof);
        await agent.setCurrentSpace(this.did());
        return {
            ok: {}
        };
    }
    /**
     * @param {Authorization} authorization
     * @param {object} options
     * @param {API.Agent<S>} [options.agent]
     */ provision({ proofs }, { agent = this.model.agent } = {}) {
        if (!agent) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fail"])('Please provide an agent to save the space into');
        }
        return provision(this, {
            proofs,
            agent
        });
    }
    /**
     * Creates a (UCAN) delegation that gives full access to the space to the
     * specified `account`. At the moment we only allow `did:mailto` principal
     * to be used as an `account`.
     *
     * @param {API.AccountDID} account
     */ async createRecovery(account) {
        return createRecovery(this, account);
    }
    /**
     * Creates (UCAN) delegation that gives specified `agent` an access to
     * specified ability (passed as `access.can` field) on the this space.
     * Optionally, you can specify `access.expiration` field to set the
     *
     * @param {API.Principal} principal
     * @param {object} [input]
     * @param {API.Access} [input.access]
     * @param {API.UCAN.UTCUnixTimestamp} [input.expiration]
     */ createAuthorization(principal, input) {
        return createAuthorization(this, {
            ...input,
            audience: principal
        });
    }
    /**
     * Derives BIP39 mnemonic that can be used to recover the space.
     *
     * @returns {string}
     */ toMnemonic() {
        return toMnemonic(this);
    }
}
const SpaceDID = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__["Schema"].did({
    method: 'key'
});
const fromDelegation = (delegation)=>{
    const result = SpaceDID.read(delegation.capabilities[0].with);
    if (result.error) {
        throw Object.assign(new Error(`Invalid delegation, expected capabilities[0].with to be DID, ${result.error}`), {
            cause: result.error
        });
    }
    /** @type {{name?:string, access?:API.SpaceAccessType}} */ const meta = delegation.facts[0]?.space ?? {};
    // Ensure access defaults to public for backwards compatibility
    meta.access = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$space$2d$access$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SpaceAccess"].from(meta.access);
    return new SharedSpace({
        id: result.ok,
        delegation,
        meta
    });
};
const provision = async (space, { proofs, agent })=>{
    const [capability] = proofs[0].capabilities;
    const { ok: account, error: reason } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$provider$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AccountDID"].read(capability.with);
    if (reason) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["error"])(reason);
    }
    return await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$provider$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["add"](agent, {
        consumer: space.did(),
        account,
        proofs
    });
};
class SharedSpace {
    /**
     * @typedef {object} SharedSpaceModel
     * @property {API.SpaceDID} id
     * @property {API.Delegation} delegation
     * @property {{name?:string, access?:API.SpaceAccessType}} meta
     * @property {API.Agent} [agent]
     *
     * @param {SharedSpaceModel} model
     */ constructor(model){
        this.model = model;
    }
    get delegation() {
        return this.model.delegation;
    }
    get meta() {
        return this.model.meta;
    }
    get name() {
        return this.meta.name ?? '';
    }
    get access() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$space$2d$access$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SpaceAccess"].from(this.meta.access);
    }
    did() {
        return this.model.id;
    }
    /**
     * @param {string} name
     */ withName(name) {
        return new SharedSpace({
            ...this.model,
            meta: {
                ...this.meta,
                name,
                access: this.access
            }
        });
    }
} //# sourceMappingURL=space.js.map
}),
"[project]/node_modules/@storacha/access/dist/delegations.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "canDelegateCapability",
    ()=>canDelegateCapability,
    "isExpired",
    ()=>isExpired,
    "isTooEarly",
    ()=>isTooEarly,
    "matchResource",
    ()=>matchResource,
    "validate",
    ()=>validate
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/lib.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$delegation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Delegation$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/delegation.js [app-client] (ecmascript) <export * as Delegation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/dist/types.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/capabilities/dist/utils.js [app-client] (ecmascript)");
;
;
;
function isExpired(delegation) {
    if (delegation.expiration === undefined || delegation.expiration <= Math.floor(Date.now() / 1000)) {
        return true;
    }
    return false;
}
function isTooEarly(delegation) {
    if (!delegation.notBefore) {
        return false;
    }
    return delegation.notBefore > Math.floor(Date.now() / 1000);
}
function validate(delegation, opts) {
    const { checkAudience, checkIsExpired = true, checkIsTooEarly = true } = opts ?? {};
    if (checkAudience && delegation.audience.did() !== checkAudience.did()) {
        throw new Error(`Delegation audience ${delegation.audience.did()} does not match required DID ${checkAudience.did()}`);
    }
    if (checkIsExpired && isExpired(delegation)) {
        throw new Error(`Delegation expired.`);
    }
    if (checkIsTooEarly && isTooEarly(delegation)) {
        throw new Error(`Delegation is not active yet (too early).`);
    }
}
function canDelegateCapability(delegation, capability) {
    const allowsCapabilities = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$delegation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Delegation$3e$__["Delegation"].allows(delegation);
    for (const [uri, abilities] of Object.entries(allowsCapabilities)){
        if (matchResource(uri, capability.with)) {
            const cans = Object.keys(abilities);
            for (const can of cans){
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["canDelegateAbility"])(can, capability.can)) {
                    return true;
                }
            }
        }
    }
    return false;
}
const matchResource = (resource, query)=>{
    if (query === 'ucan:*') {
        return true;
    } else if (typeof query === 'string') {
        return resource === query;
    } else {
        return query.test(resource);
    }
}; //# sourceMappingURL=delegations.js.map
}),
"[project]/node_modules/@storacha/access/dist/utils/buffers.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Convert a Uint8Array to an ArrayBuffer, taking into account
 * that we may be looking at a "data view".
 * thanks, https://stackoverflow.com/a/54646864
 *
 * If we aren't looking at a data view, simply returns the underlying ArrayBuffer
 * directly.
 *
 * @param {Uint8Array} array
 * @returns ArrayBuffer
 */ __turbopack_context__.s([
    "uint8ArrayToArrayBuffer",
    ()=>uint8ArrayToArrayBuffer
]);
function uint8ArrayToArrayBuffer(array) {
    if (array.byteOffset === 0 && array.byteLength === array.buffer.byteLength) {
        return array.buffer;
    } else {
        return array.buffer.slice(array.byteOffset, array.byteLength + array.byteOffset);
    }
} //# sourceMappingURL=buffers.js.map
}),
"[project]/node_modules/@storacha/access/dist/agent-data.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AgentData",
    ()=>AgentData,
    "getSessionProofs",
    ()=>getSessionProofs,
    "isSessionProof",
    ()=>isSessionProof
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/lib.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/ed25519.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Signer$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/ed25519/signer.js [app-client] (ecmascript) <export * as Signer>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$delegation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/delegation.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$interface$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/interface/src/lib.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/cid.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@storacha/capabilities/dist/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$ucan$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__UCAN$3e$__ = __turbopack_context__.i("[project]/node_modules/@storacha/capabilities/dist/ucan.js [app-client] (ecmascript) <export * as UCAN>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$delegations$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/dist/delegations.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$utils$2f$buffers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/dist/utils/buffers.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
class AgentData {
    /** @type {(data: import('./types.js').AgentDataExport) => Promise<void> | void} */ #save;
    /**
     * @param {import('./types.js').AgentDataModel} data
     * @param {import('./types.js').AgentDataOptions} [options]
     */ constructor(data, options = {}){
        this.meta = data.meta;
        this.principal = data.principal;
        this.spaces = data.spaces;
        this.delegations = data.delegations;
        this.currentSpace = data.currentSpace;
        this.#save = (data)=>options.store ? options.store.save(data) : undefined;
    }
    /**
     * Create a new AgentData instance from the passed initialization data.
     *
     * @param {Partial<import('./types.js').AgentDataModel>} [init]
     * @param {import('./types.js').AgentDataOptions} [options]
     */ static async create(init = {}, options = {}) {
        const agentData = new AgentData({
            meta: {
                name: 'agent',
                type: 'device',
                ...init.meta
            },
            principal: init.principal ?? await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Signer$3e$__["Signer"].generate(),
            spaces: init.spaces ?? new Map(),
            delegations: init.delegations ?? new Map(),
            currentSpace: init.currentSpace
        }, options);
        if (options.store) {
            await options.store.save(agentData.export());
        }
        return agentData;
    }
    /**
     * Instantiate AgentData from previously exported data.
     *
     * @param {import('./types.js').AgentDataExport} raw
     * @param {import('./types.js').AgentDataOptions} [options]
     */ static fromExport(raw, options) {
        /** @type {import('./types.js').AgentDataModel['delegations']} */ const dels = new Map();
        for (const [key, value] of raw.delegations){
            dels.set(key, {
                delegation: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$delegation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["importDAG"])(value.delegation.map((d)=>({
                        cid: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].parse(d.cid).toV1(),
                        bytes: d.bytes instanceof Uint8Array ? d.bytes : new Uint8Array(d.bytes)
                    }))),
                meta: value.meta
            });
        }
        return new AgentData({
            meta: raw.meta,
            // @ts-expect-error for some reason TS thinks this is a EdSigner
            principal: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Signer"].from(raw.principal),
            currentSpace: raw.currentSpace,
            spaces: raw.spaces,
            delegations: dels
        }, options);
    }
    /**
     * Export data in a format safe to pass to `structuredClone()`.
     */ export() {
        /** @type {import('./types.js').AgentDataExport} */ const raw = {
            meta: this.meta,
            principal: this.principal.toArchive(),
            currentSpace: this.currentSpace,
            spaces: this.spaces,
            delegations: new Map()
        };
        for (const [key, value] of this.delegations){
            raw.delegations.set(key, {
                meta: value.meta,
                delegation: [
                    ...value.delegation.export()
                ].map((b)=>({
                        cid: b.cid.toString(),
                        bytes: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$utils$2f$buffers$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["uint8ArrayToArrayBuffer"])(b.bytes)
                    }))
            });
        }
        return raw;
    }
    /**
     * @param {import('@ucanto/interface').DID} did
     * @param {import('./types.js').SpaceMeta} meta
     * @param {import('@ucanto/interface').Delegation} [proof]
     */ async addSpace(did, meta, proof) {
        this.spaces.set(did, meta);
        await (proof ? this.addDelegation(proof) : this.#save(this.export()));
    }
    /**
     * @deprecated
     * @param {import('@ucanto/interface').DID<'key'>} did
     */ async setCurrentSpace(did) {
        this.currentSpace = did;
        await this.#save(this.export());
    }
    /**
     * @param {import('@ucanto/interface').Delegation} delegation
     * @param {import('./types.js').DelegationMeta} [meta]
     */ async addDelegation(delegation, meta) {
        this.delegations.set(delegation.cid.toString(), {
            delegation,
            meta: meta ?? {}
        });
        await this.#save(this.export());
    }
    /**
     * @param {import('@ucanto/interface').UCANLink} cid
     */ async removeDelegation(cid) {
        this.delegations.delete(cid.toString());
        await this.#save(this.export());
    }
}
/**
 * Is the given capability a session attestation?
 *
 * @param {Ucanto.Capability} cap
 * @returns {boolean}
 */ const isSessionCapability = (cap)=>cap.can === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$ucan$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__UCAN$3e$__["UCAN"].attest.can;
const isSessionProof = (delegation)=>delegation.capabilities.some((cap)=>isSessionCapability(cap));
function getSessionProofs(data) {
    /** @type {SessionProofIndexedByAuthorizationAndIssuer} */ const proofs = {};
    for (const { delegation } of data.delegations.values()){
        if (isSessionProof(delegation)) {
            const cap = delegation.capabilities[0];
            if (cap && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$delegations$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isExpired"])(delegation)) {
                const proof = cap.nb.proof;
                if (proof) {
                    const proofCid = proof.toString();
                    const issuerDid = delegation.issuer.did();
                    proofs[proofCid] = proofs[proofCid] ?? {};
                    proofs[proofCid][issuerDid] = proofs[proofCid][issuerDid] ?? [];
                    proofs[proofCid][issuerDid].push(delegation);
                }
            }
        }
    }
    return proofs;
} //# sourceMappingURL=agent-data.js.map
}),
"[project]/node_modules/@storacha/access/dist/agent-use-cases.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "addProvider",
    ()=>addProvider,
    "addProviderAndDelegateToAccount",
    ()=>addProviderAndDelegateToAccount,
    "authorizeAndWait",
    ()=>authorizeAndWait,
    "authorizeWaitAndClaim",
    ()=>authorizeWaitAndClaim,
    "claimAccess",
    ()=>claimAccess,
    "delegationsIncludeSessionProof",
    ()=>delegationsIncludeSessionProof,
    "getAccountPlan",
    ()=>getAccountPlan,
    "pollAccessClaimUntil",
    ()=>pollAccessClaimUntil,
    "requestAccess",
    ()=>requestAccess,
    "waitForAuthorizationByPolling",
    ()=>waitForAuthorizationByPolling
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$agent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/dist/agent.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$access$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@storacha/capabilities/dist/access.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/dist/encoding.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@storacha/capabilities/dist/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$provider$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Provider$3e$__ = __turbopack_context__.i("[project]/node_modules/@storacha/capabilities/dist/provider.js [app-client] (ecmascript) <export * as Provider>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$plan$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Plan$3e$__ = __turbopack_context__.i("[project]/node_modules/@storacha/capabilities/dist/plan.js [app-client] (ecmascript) <export * as Plan>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$access$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Access$3e$__ = __turbopack_context__.i("[project]/node_modules/@storacha/capabilities/dist/access.js [app-client] (ecmascript) <export * as Access>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/lib.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/schema.js [app-client] (ecmascript) <export * as Schema>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$delegation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/delegation.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$agent$2d$data$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/dist/agent-data.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$did$2d$mailto$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@storacha/did-mailto/dist/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/dist/types.js [app-client] (ecmascript) <locals>");
;
;
;
;
;
;
;
;
;
const DIDWeb = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__["Schema"].DID.match({
    method: 'web'
});
async function requestAccess(access, account, capabilities) {
    const res = await access.invokeAndExecute(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$access$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["authorize"], {
        audience: access.connection.id,
        with: access.issuer.did(),
        nb: {
            iss: account.did(),
            att: [
                ...capabilities
            ]
        }
    });
    if (res?.out.error) {
        throw res.out.error;
    }
}
async function claimAccess(access, audienceOfClaimedDelegations = access.connection.id.did(), { addProofs = false, nonce } = {}) {
    const res = await access.invokeAndExecute(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$access$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["claim"], {
        audience: access.connection.id,
        with: audienceOfClaimedDelegations,
        nonce
    });
    if (res.out.error) {
        throw res.out.error;
    }
    const delegations = Object.values(res.out.ok.delegations).flatMap((bytes)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bytesToDelegations"])(bytes));
    if (addProofs) {
        for (const d of delegations){
            await access.addProof(d);
        }
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$agent$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["addSpacesFromDelegations"])(access, delegations);
    }
    return delegations;
}
async function addProvider({ access, space, account, provider }) {
    const result = await access.invokeAndExecute(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$provider$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Provider$3e$__["Provider"].add, {
        audience: access.connection.id,
        with: account.did(),
        nb: {
            provider,
            consumer: space
        }
    });
    if (result.out.error) {
        throw result.out.error;
    }
}
function delegationsIncludeSessionProof(delegations) {
    return delegations.some((d)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$agent$2d$data$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isSessionProof"])(d));
}
async function pollAccessClaimUntil(delegationsMatch, access, delegee, opts) {
    const interval = opts?.interval || 250;
    // eslint-disable-next-line no-constant-condition
    while(true){
        if (opts?.signal?.aborted) throw opts.signal.reason ?? new Error('operation aborted');
        const res = await access.invokeAndExecute(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$access$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Access$3e$__["Access"].claim, {
            with: delegee
        });
        if (res.out.error) throw res.out.error;
        const claims = Object.values(res.out.ok.delegations).flatMap((d)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$encoding$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bytesToDelegations"])(d));
        if (delegationsMatch(claims)) return claims;
        await new Promise((resolve)=>setTimeout(resolve, interval));
    }
}
async function waitForAuthorizationByPolling(access, opts = {}) {
    const claimed = await pollAccessClaimUntil(delegationsIncludeSessionProof, access, access.issuer.did(), {
        signal: opts?.signal,
        interval: opts?.interval
    });
    return [
        ...claimed
    ];
}
async function authorizeAndWait(access, email, opts = {}) {
    const expectAuthorization = opts.expectAuthorization || waitForAuthorizationByPolling;
    const account = {
        did: ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$did$2d$mailto$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromEmail"](email)
    };
    await requestAccess(access, account, opts?.capabilities || [
        {
            can: 'assert/*'
        },
        {
            can: 'space/*'
        },
        {
            can: 'store/*'
        },
        {
            can: 'provider/add'
        },
        {
            can: 'subscription/list'
        },
        {
            can: 'upload/*'
        },
        {
            can: 'ucan/*'
        },
        {
            can: 'plan/*'
        },
        {
            can: 'usage/*'
        },
        {
            can: 'w3up/*'
        }
    ]);
    const sessionDelegations = [
        ...await expectAuthorization(access, opts)
    ];
    if (!opts?.dontAddProofs) {
        await Promise.all(sessionDelegations.map(async (d)=>access.addProof(d)));
    }
}
async function authorizeWaitAndClaim(accessAgent, email, opts) {
    await authorizeAndWait(accessAgent, email, opts);
    await claimAccess(accessAgent, accessAgent.issuer.did(), {
        addProofs: opts?.addProofs ?? true
    });
}
async function addProviderAndDelegateToAccount(access, agentData, email, opts) {
    const space = opts?.space || access.currentSpace();
    const spaceMeta = space ? agentData.spaces.get(space) : undefined;
    const provider = opts?.provider || (()=>{
        const service = access.connection.id.did();
        if (DIDWeb.is(service)) {
            // connection.id did is a valid provider value. Try using that.
            return service;
        }
        throw new Error(`unable to determine provider to use to addProviderAndDelegateToAccount using access.connection.id did ${service}. expected a did:web:`);
    })();
    if (!space || !spaceMeta) {
        throw new Error('No space selected');
    }
    if (spaceMeta) {
        throw new Error('Space already registered with storacha.network.');
    }
    const account = {
        did: ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$did$2d$mailto$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromEmail"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$did$2d$mailto$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["email"](email))
    };
    await addProvider({
        access,
        space,
        account,
        provider
    });
    const delegateSpaceAccessResult = await delegateSpaceAccessToAccount(access, space, account);
    if (delegateSpaceAccessResult.out.error) {
        throw delegateSpaceAccessResult.out.error;
    }
    await agentData.addSpace(space, spaceMeta);
}
/**
 * @param {AccessAgent} access
 * @param {API.SpaceDID} space
 * @param {API.Principal<API.AccountDID>} account
 */ async function delegateSpaceAccessToAccount(access, space, account) {
    const issuerSaysAccountCanAdminSpace = await createIssuerSaysAccountCanAdminSpace(access.issuer, space, account, undefined, access.proofs([
        {
            with: space,
            can: '*'
        }
    ]), // we want to sign over control of this space forever
    Infinity);
    return access.invokeAndExecute(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$access$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["delegate"], {
        audience: access.connection.id,
        with: space,
        expiration: Infinity,
        nb: {
            delegations: {
                [issuerSaysAccountCanAdminSpace.cid.toString()]: issuerSaysAccountCanAdminSpace.cid
            }
        },
        proofs: [
            // must be embedded here because it's referenced by cid in .nb.delegations
            issuerSaysAccountCanAdminSpace
        ]
    });
}
/**
 * @param {API.Signer<API.DIDKey>} issuer
 * @param {API.SpaceDID} space
 * @param {API.Principal<API.AccountDID>} account
 * @param {API.Capabilities} capabilities
 * @param {API.Delegation[]} proofs
 * @param {number} expiration
 * @returns
 */ async function createIssuerSaysAccountCanAdminSpace(issuer, space, account, capabilities = [
    {
        can: '*',
        with: space
    }
], proofs = [], expiration) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$delegation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["delegate"])({
        issuer,
        audience: account,
        capabilities,
        proofs,
        expiration
    });
}
async function getAccountPlan(agent, account) {
    const receipt = await agent.invokeAndExecute(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$plan$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Plan$3e$__["Plan"].get, {
        with: account
    });
    return receipt.out;
} //# sourceMappingURL=agent-use-cases.js.map
}),
"[project]/node_modules/@storacha/access/dist/agent.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Agent",
    ()=>Agent,
    "addSpacesFromDelegations",
    ()=>addSpacesFromDelegations,
    "connection",
    ()=>connection,
    "importAuthorization",
    ()=>importAuthorization
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$client$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/client/src/lib.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$client$2f$src$2f$connection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/client/src/connection.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/car.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$http$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/http.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/lib.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$delegation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Delegation$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/delegation.js [app-client] (ecmascript) <export * as Delegation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$space$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@storacha/capabilities/dist/space.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$ucan$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/capabilities/dist/ucan.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$access$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/dist/access.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$space$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/dist/space.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$invocation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/invocation.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$delegation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/delegation.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__DID$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/did.js [app-client] (ecmascript) <export * as DID>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/schema.js [app-client] (ecmascript) <export * as Schema>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$delegations$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/dist/delegations.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$agent$2d$data$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/dist/agent-data.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@storacha/capabilities/dist/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$ucan$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__UCAN$3e$__ = __turbopack_context__.i("[project]/node_modules/@storacha/capabilities/dist/ucan.js [app-client] (ecmascript) <export * as UCAN>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/dist/types.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$agent$2d$use$2d$cases$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/dist/agent-use-cases.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
;
const HOST = 'https://up.storacha.network';
const PRINCIPAL = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__DID$3e$__["DID"].parse('did:web:up.storacha.network');
/**
 * Default identities for the service, including the primary identity.
 *
 * @type {API.DID[]}
 */ const IDENTITIES = [
    PRINCIPAL.did(),
    'did:web:web3.storage'
];
/**
 * Keeps track of AgentData for all Agents constructed.
 * Used by addSpacesFromDelegations - so it can only accept Agent as param, but
 * still mutate corresponding AgentData
 *
 * @deprecated - remove this when deprecated addSpacesFromDelegations is removed
 */ /** @type {WeakMap<Agent<Record<string, any>>, AgentData>} */ const agentToData = new WeakMap();
function connection(options = {}) {
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$client$2f$src$2f$connection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["connect"]({
        id: options.principal ?? PRINCIPAL,
        codec: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["outbound"],
        channel: options.channel ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$http$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["open"]({
            url: options.url ?? new URL(HOST),
            method: 'POST',
            fetch: options.fetch ?? globalThis.fetch.bind(globalThis)
        })
    });
}
class Agent {
    /** @type {import('./agent-data.js').AgentData} */ #data;
    /**
     * DIDs the service is known by, including the primary. They are used by
     * `invoke` and `invokeAndExecute` to scope session proofs to just the service
     * DID or it's aliases.
     *
     * @type {Set<API.DID>}
     */ #serviceIdentities;
    /**
     * @param {import('./agent-data.js').AgentData} data - Agent data
     * @param {import('./types.js').AgentOptions<S>} [options]
     */ constructor(data, options = {}){
        /** @type { Client.Channel<S> & { url?: URL } | undefined } */ const channel = options.connection?.channel;
        this.url = options.url ?? channel?.url ?? new URL(HOST);
        this.connection = options.connection ?? connection({
            principal: options.servicePrincipal,
            url: this.url
        });
        this.#data = data;
        agentToData.set(this, this.#data);
        const primary = this.connection.id;
        const serviceIdentities = new Set(options.serviceIdentities);
        // If the default identities includes the configured primary identity then
        // add them to the service identities list.
        if (IDENTITIES.includes(primary.did())) {
            for (const id of IDENTITIES){
                serviceIdentities.add(id);
            }
        }
        // Add the primary identity if not already in service identities.
        if (!serviceIdentities.has(primary.did())) {
            serviceIdentities.add(primary.did());
        }
        this.#serviceIdentities = serviceIdentities;
    }
    /**
     * Create a new Agent instance, optionally with the passed initialization data.
     *
     * @template {Record<string, any>} [R=Service]
     * @param {Partial<import('./types.js').AgentDataModel>} [init]
     * @param {import('./types.js').AgentOptions<R> & import('./types.js').AgentDataOptions} [options]
     */ static async create(init, options = {}) {
        const data = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$agent$2d$data$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AgentData"].create(init, options);
        return new Agent(data, options);
    }
    /**
     * Instantiate an Agent from pre-exported agent data.
     *
     * @template {Record<string, any>} [R=Service]
     * @param {import('./types.js').AgentDataExport} raw
     * @param {import('./types.js').AgentOptions<R> & import('./types.js').AgentDataOptions} [options]
     */ static from(raw, options = {}) {
        const data = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$agent$2d$data$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["AgentData"].fromExport(raw, options);
        return new Agent(data, options);
    }
    get issuer() {
        return this.#data.principal;
    }
    get meta() {
        return this.#data.meta;
    }
    get spaces() {
        return this.#data.spaces;
    }
    did() {
        return this.#data.principal.did();
    }
    /**
     * Add a proof to the agent store.
     *
     * @param {API.Delegation} delegation
     */ async addProof(delegation) {
        return await this.addProofs([
            delegation
        ]);
    }
    /**
     * Adds set of proofs to the agent store.
     *
     * @param {Iterable<API.Delegation>} delegations
     */ async addProofs(delegations) {
        for (const proof of delegations){
            await this.#data.addDelegation(proof, {
                audience: this.meta
            });
        }
        await this.removeExpiredDelegations();
        return {};
    }
    /**
     * Query the delegations store for all the delegations matching the capabilities provided.
     *
     * @param {API.CapabilityQuery[]} [caps]
     */ #delegations(caps) {
        const _caps = new Set(caps);
        /** @type {Array<{ delegation: API.Delegation, meta: API.DelegationMeta }>} */ const values = [];
        for (const [, value] of this.#data.delegations){
            // check expiration
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$delegations$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isExpired"])(value.delegation) && // check if delegation can be used
            !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$delegations$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isTooEarly"])(value.delegation)) {
                // check if we need to filter for caps
                if (Array.isArray(caps) && caps.length > 0) {
                    for (const cap of _caps){
                        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$delegations$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["canDelegateCapability"])(value.delegation, cap)) {
                            values.push(value);
                        }
                    }
                } else {
                    values.push(value);
                }
            }
        }
        return values;
    }
    /**
     * Clean up any expired delegations.
     */ async removeExpiredDelegations() {
        for (const [, value] of this.#data.delegations){
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$delegations$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isExpired"])(value.delegation)) {
                await this.#data.removeDelegation(value.delegation.cid);
            }
        }
    }
    /**
     * Revoke a delegation by CID.
     *
     * If the delegation was issued by this agent (and therefore is stored in the
     * delegation store) you can just pass the CID. If not, or if the current agent's
     * delegation store no longer contains the delegation, you MUST pass a chain of
     * proofs that proves your authority to revoke this delegation as `options.proofs`.
     *
     * @param {API.UCANLink} delegationCID
     * @param {object} [options]
     * @param {API.Delegation[]} [options.proofs]
     */ async revoke(delegationCID, options = {}) {
        const additionalProofs = options.proofs ?? [];
        // look for the identified delegation in the delegation store and the passed proofs
        const delegation = [
            ...this.delegations(),
            ...additionalProofs
        ].find((delegation)=>delegation.cid.equals(delegationCID));
        if (!delegation) {
            return {
                error: new Error(`could not find delegation ${delegationCID.toString()} - please include the delegation in options.proofs`)
            };
        }
        const receipt = await this.invokeAndExecute(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$ucan$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__UCAN$3e$__["UCAN"].revoke, {
            // per https://github.com/storacha/upload-service/blob/main/packages/capabilities/src/ucan.js#L38C6-L38C6 the resource here should be
            // the current issuer - using the space DID here works for simple cases but falls apart when a delegee tries to revoke a delegation
            // they have re-delegated, since they don't have "ucan/revoke" capabilities on the space
            with: this.issuer.did(),
            nb: {
                ucan: delegation.cid
            },
            proofs: [
                delegation,
                ...additionalProofs
            ]
        });
        return receipt.out;
    }
    /**
     * Get all the proofs matching the capabilities.
     *
     * Proofs are delegations with an audience matching agent DID, or with an
     * audience matching the session DID.
     *
     * Proof of session will also be included in the returned proofs if any
     * proofs matching the passed capabilities require it.
     *
     * @param {API.CapabilityQuery[]} [caps] - Capabilities to filter by. Empty or undefined caps with return all the proofs.
     * @param {object} [options]
     * @param {API.DID|API.DID[]} [options.sessionProofIssuer] - only include session proofs for these issuer(s)
     */ proofs(caps, options) {
        /** @type {Map<string, API.Delegation<API.Capabilities>>} */ const authorizations = new Map();
        for (const { delegation } of this.#delegations(caps)){
            if (delegation.audience.did() === this.issuer.did()) {
                authorizations.set(delegation.cid.toString(), delegation);
            }
        }
        /** @type {Set<API.DID>} */ const sessionProofIssuers = new Set();
        if (options?.sessionProofIssuer) {
            const ids = Array.isArray(options.sessionProofIssuer) ? options.sessionProofIssuer : [
                options.sessionProofIssuer
            ];
            for (const id of ids){
                sessionProofIssuers.add(id);
            }
        }
        // now let's add any session proofs that refer to those authorizations
        const sessions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$agent$2d$data$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getSessionProofs"])(this.#data);
        for (const proof of [
            ...authorizations.values()
        ]){
            const proofsByIssuer = sessions[proof.asCID.toString()] ?? {};
            const sessionProofs = [];
            if (sessionProofIssuers.size > 0) {
                for (const id of sessionProofIssuers){
                    const proofs = proofsByIssuer[id];
                    if (proofs) sessionProofs.push(...proofs);
                }
            } else {
                sessionProofs.push(...Object.values(proofsByIssuer).flat());
            }
            for (const sessionProof of sessionProofs){
                authorizations.set(sessionProof.cid.toString(), sessionProof);
            }
        }
        return [
            ...authorizations.values()
        ];
    }
    /**
     * Get delegations created by the agent for others.
     *
     * @param {API.CapabilityQuery[]} [caps] - Capabilities to filter by. Empty or undefined caps with return all the delegations.
     */ delegations(caps) {
        const arr = [];
        for (const { delegation } of this.delegationsWithMeta(caps)){
            arr.push(delegation);
        }
        return arr;
    }
    /**
     * Get delegations created by the agent for others and their metadata.
     *
     * @param {API.CapabilityQuery[]} [caps] - Capabilities to filter by. Empty or undefined caps with return all the delegations.
     */ delegationsWithMeta(caps) {
        const arr = [];
        for (const value of this.#delegations(caps)){
            const { delegation } = value;
            const isSession = delegation.capabilities.some((c)=>c.can === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$ucan$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["attest"].can);
            if (!isSession && delegation.audience.did() !== this.issuer.did()) {
                arr.push(value);
            }
        }
        return arr;
    }
    /**
     * Creates a space signer and a delegation to the agent
     *
     * @param {string} name
     * @param {object} [options]
     * @param {API.SpaceAccessType} [options.access] - The access type for the space. Defaults to { type: 'public' }.
     */ async createSpace(name, { access } = {}) {
        return await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$space$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["generate"]({
            name,
            access,
            agent: this
        });
    }
    /**
     * @param {string} secret
     * @param {object} options
     * @param {string} options.name - The name of the space.
     * @param {API.SpaceAccessType} [options.access] - The access type for the space. Defaults to { type: 'public' }.
     */ async recoverSpace(secret, { name, access }) {
        return await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$space$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromMnemonic"](secret, {
            name,
            access,
            agent: this
        });
    }
    /**
     * Import a space from a delegation.
     *
     * @param {API.Delegation} delegation
     * @param {object} options
     * @param {string} [options.name]
     */ async importSpaceFromDelegation(delegation, { name = '' } = {}) {
        const space = name === '' ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$space$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromDelegation"](delegation) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$space$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromDelegation"](delegation).withName(name);
        // Store space metadata preserving all properties
        this.#data.spaces.set(space.did(), {
            ...space.meta,
            name: space.name,
            access: space.access
        });
        await this.addProof(space.delegation);
        // if we do not have a current space, make this one current
        if (!this.currentSpace()) {
            await this.setCurrentSpace(space.did());
        }
        return space;
    }
    /**
     * Sets the current selected space
     *
     * Other methods will default to use the current space if no resource is defined
     *
     * @param {API.SpaceDID} space
     */ async setCurrentSpace(space) {
        if (!this.#data.spaces.has(space)) {
            throw new Error(`Agent has no proofs for ${space}.`);
        }
        await this.#data.setCurrentSpace(space);
        return space;
    }
    /**
     * Get current space DID
     */ currentSpace() {
        return this.#data.currentSpace;
    }
    /**
     * Get current space DID, proofs and abilities
     */ currentSpaceWithMeta() {
        if (!this.#data.currentSpace) {
            return;
        }
        const proofs = this.proofs([
            {
                can: 'space/info',
                with: this.#data.currentSpace
            }
        ]);
        const caps = new Set();
        for (const p of proofs){
            for (const cap of p.capabilities){
                caps.add(cap.can);
            }
        }
        return {
            did: this.#data.currentSpace,
            proofs,
            capabilities: [
                ...caps
            ],
            meta: this.#data.spaces.get(this.#data.currentSpace)
        };
    }
    /**
     *
     * @param {import('./types.js').DelegationOptions} options
     */ async delegate(options) {
        const space = this.currentSpaceWithMeta();
        if (!space) {
            throw new Error('no space selected.');
        }
        const caps = options.abilities.map((a)=>{
            return {
                with: space.did,
                can: a
            };
        });
        // Verify agent can provide proofs for each requested capability
        for (const cap of caps){
            if (!this.proofs([
                cap
            ]).length) {
                throw new Error(`cannot delegate capability ${cap.can} with ${cap.with}`);
            }
        }
        const delegation = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$delegation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["delegate"])({
            issuer: this.issuer,
            capabilities: caps,
            proofs: this.proofs(caps),
            facts: [
                {
                    space: space.meta ?? {}
                }
            ],
            ...options
        });
        await this.#data.addDelegation(delegation, {
            audience: options.audienceMeta
        });
        await this.removeExpiredDelegations();
        return delegation;
    }
    /**
     * Invoke and execute the given capability on the Access service connection
     *
     * ```js
     *
     * await agent.invokeAndExecute(Space.recover, {
     *   nb: {
     *     identity: 'mailto: email@gmail.com',
     *   },
     * })
     *
     * // sugar for
     * const recoverInvocation = await agent.invoke(Space.recover, {
     *   nb: {
     *     identity: 'mailto: email@gmail.com',
     *   },
     * })
     *
     * await recoverInvocation.execute(agent.connection)
     * ```
     *
     * @template {API.Ability} A
     * @template {API.URI} R
     * @template {API.Caveats} C
     * @param {API.TheCapabilityParser<API.CapabilityMatch<A, R, C>>} cap
     * @param {API.InvokeOptions<A, R, API.TheCapabilityParser<API.CapabilityMatch<A, R, C>>>} options
     * @returns {Promise<API.InferReceipt<API.Capability<A, R, C>, S>>}
     */ async invokeAndExecute(cap, options) {
        const inv = await this.invoke(cap, options);
        const out = inv.execute(this.connection);
        return out;
    }
    /**
     * Execute invocations on the agent's connection
     *
     * @example
     * ```js
     * const i1 = await agent.invoke(Space.info, {})
     * const i2 = await agent.invoke(Space.recover, {
     *   nb: {
     *     identity: 'mailto:hello@storacha.network',
     *   },
     * })
     *
     * const results = await agent.execute2(i1, i2)
     *
     * ```
     * @template {API.Capability} C
     * @template {API.Tuple<API.ServiceInvocation<C, S>>} I
     * @param {I} invocations
     */ execute(...invocations) {
        return this.connection.execute(...invocations);
    }
    /**
     * Creates an invocation for the given capability with Agent's proofs, service, issuer and space.
     *
     * @example
     * ```js
     * const recoverInvocation = await agent.invoke(Space.recover, {
     *   nb: {
     *     identity: 'mailto: email@gmail.com',
     *   },
     * })
     *
     * await recoverInvocation.execute(agent.connection)
     * // or
     * await agent.execute(recoverInvocation)
     * ```
     *
     * @template {API.Ability} A
     * @template {API.URI} R
     * @template {API.TheCapabilityParser<API.CapabilityMatch<A, R, C>>} CAP
     * @template {API.Caveats} [C={}]
     * @param {CAP} cap
     * @param {import('./types.js').InvokeOptions<A, R, CAP>} options
     */ async invoke(cap, options) {
        const audience = options.audience || this.connection.id;
        const space = options.with || this.currentSpace();
        if (!space) {
            throw new Error('No space or resource selected, you need pass a resource.');
        }
        const proofs = [
            ...options.proofs || [],
            ...this.proofs([
                {
                    with: space,
                    can: cap.can
                }
            ], {
                sessionProofIssuer: this.#serviceIdentities.has(audience.did()) ? [
                    ...this.#serviceIdentities
                ] : audience.did()
            })
        ];
        if (proofs.length === 0 && options.with !== this.did()) {
            throw new Error(`no proofs available for resource ${space} and ability ${cap.can}`);
        }
        const inv = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$invocation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["invoke"])({
            ...options,
            audience,
            // @ts-ignore
            capability: cap.create({
                with: space,
                nb: 'nb' in options ? options.nb : undefined
            }),
            issuer: this.issuer,
            proofs: [
                ...proofs
            ],
            nonce: options.nonce
        });
        return inv;
    }
    /**
     * Get Space information from Access service
     *
     * @param {API.URI<"did:">} [space]
     * @param {object} [options]
     * @param {string} [options.nonce]
     */ async getSpaceInfo(space, options) {
        const _space = space || this.currentSpace();
        if (!_space) {
            throw new Error('No space selected, you need pass a resource.');
        }
        const inv = await this.invokeAndExecute(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$space$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["info"], {
            ...options,
            with: _space
        });
        if (inv.out.error) {
            throw inv.out.error;
        }
        return inv.out.ok;
    }
}
async function addSpacesFromDelegations(agent, delegations) {
    const data = agentToData.get(agent);
    if (!data) {
        throw Object.assign(new Error(`cannot determine AgentData for Agent`), {
            agent: agent
        });
    }
    // spaces we find along the way.
    const spaces = new Map();
    // only consider ucans with this agent as the audience
    const ours = delegations.filter((x)=>x.audience.did() === agent.did());
    // space names are stored as facts in proofs in the special `ucan:*` delegation from email to agent.
    const ucanStars = ours.filter((x)=>x.capabilities[0].can === '*' && x.capabilities[0].with === 'ucan:*');
    for (const delegation of ucanStars){
        for (const proof of delegation.proofs){
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$delegation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["isDelegation"])(proof) || !proof.capabilities[0].with.startsWith('did:key')) {
                continue;
            }
            const space = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$space$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromDelegation"](proof);
            spaces.set(space.did(), space.meta);
        }
    }
    // Find any other spaces the user may have access to
    for (const delegation of ours){
        // TODO: we need a more robust way to determine which spaces a user has access to
        // it may or may not involve look at delegations
        const allows = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$delegation$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Delegation$3e$__["Delegation"].allows(delegation);
        for (const [resource, value] of Object.entries(allows)){
            // If we discovered a delegation to any DID, we add it to the spaces list.
            if (resource.startsWith('did:key') && Object.keys(value).length > 0) {
                if (!spaces.has(resource)) {
                    spaces.set(resource, {});
                }
            }
        }
    }
    for (const [did, meta] of spaces){
        await data.addSpace(did, meta);
    }
}
const importAuthorization = async (agent, { proofs })=>{
    try {
        await agent.addProofs(proofs);
        await addSpacesFromDelegations(agent, proofs);
        return {
            ok: {}
        };
    } catch (error) {
        return {
            error
        };
    }
}; //# sourceMappingURL=agent.js.map
}),
"[project]/node_modules/@storacha/access/dist/drivers/indexeddb.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "IndexedDBDriver",
    ()=>IndexedDBDriver
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p$2d$defer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/p-defer/index.js [app-client] (ecmascript)");
;
/**
 * @template T
 * @typedef {import('./types.js').Driver<T>} Driver
 */ const STORE_NAME = 'AccessStore';
const DATA_ID = 1;
class IndexedDBDriver {
    /** @type {string} */ #dbName;
    /** @type {number|undefined} */ #dbVersion;
    /** @type {string} */ #dbStoreName;
    /** @type {IDBDatabase|undefined} */ #db;
    /** @type {boolean} */ #autoOpen;
    /**
     * @param {string} dbName
     * @param {object} [options]
     * @param {number} [options.dbVersion]
     * @param {string} [options.dbStoreName]
     * @param {boolean} [options.autoOpen]
     */ constructor(dbName, options = {}){
        this.#dbName = dbName;
        this.#dbVersion = options.dbVersion;
        this.#dbStoreName = options.dbStoreName ?? STORE_NAME;
        this.#autoOpen = options.autoOpen ?? true;
    }
    /** @returns {Promise<IDBDatabase>} */ async #getOpenDB() {
        if (!this.#db) {
            if (!this.#autoOpen) throw new Error('Store is not open');
            await this.open();
        }
        // @ts-expect-error open sets this.#db
        return this.#db;
    }
    async open() {
        const db = this.#db;
        if (db) return;
        /** @type {import('p-defer').DeferredPromise<void>} */ const { resolve, reject, promise } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p$2d$defer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])();
        const openReq = indexedDB.open(this.#dbName, this.#dbVersion);
        openReq.addEventListener('upgradeneeded', ()=>{
            const db = openReq.result;
            db.createObjectStore(this.#dbStoreName, {
                keyPath: 'id'
            });
        });
        openReq.addEventListener('success', ()=>{
            this.#db = openReq.result;
            resolve();
        });
        openReq.addEventListener('error', ()=>reject(openReq.error));
        return promise;
    }
    async close() {
        const db = this.#db;
        if (!db) throw new Error('Store is not open');
        db.close();
        this.#db = undefined;
    }
    /** @param {T} data */ async save(data) {
        const db = await this.#getOpenDB();
        const putData = withObjectStore(db, 'readwrite', this.#dbStoreName, async (store)=>{
            /** @type {import('p-defer').DeferredPromise<void>} */ const { resolve, reject, promise } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p$2d$defer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])();
            const putReq = store.put({
                id: DATA_ID,
                ...data
            });
            putReq.addEventListener('success', ()=>resolve());
            putReq.addEventListener('error', ()=>reject(new Error('failed to query DB', {
                    cause: putReq.error
                })));
            return promise;
        });
        return await putData();
    }
    async load() {
        const db = await this.#getOpenDB();
        const getData = withObjectStore(db, 'readonly', this.#dbStoreName, async (store)=>{
            /** @type {import('p-defer').DeferredPromise<T|undefined>} */ const { resolve, reject, promise } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p$2d$defer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])();
            const getReq = store.get(DATA_ID);
            getReq.addEventListener('success', ()=>resolve(getReq.result));
            getReq.addEventListener('error', ()=>reject(new Error('failed to query DB', {
                    cause: getReq.error
                })));
            return promise;
        });
        return await getData();
    }
    async reset() {
        const db = await this.#getOpenDB();
        const clear = withObjectStore(db, 'readwrite', this.#dbStoreName, (s)=>{
            /** @type {import('p-defer').DeferredPromise<void>} */ const { resolve, reject, promise } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p$2d$defer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])();
            const req = s.clear();
            req.addEventListener('success', ()=>{
                resolve();
            });
            req.addEventListener('error', ()=>reject(new Error('failed to query DB', {
                    cause: req.error
                })));
            return promise;
        });
        await clear();
    }
}
/**
 * @template T
 * @param {IDBDatabase} db
 * @param {IDBTransactionMode} txnMode
 * @param {string} storeName
 * @param {(s: IDBObjectStore) => Promise<T>} fn
 * @returns
 */ function withObjectStore(db, txnMode, storeName, fn) {
    return async ()=>{
        const tx = db.transaction(storeName, txnMode);
        /** @type {import('p-defer').DeferredPromise<T>} */ const { resolve, reject, promise } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$p$2d$defer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"])();
        /** @type {T} */ let result;
        tx.addEventListener('complete', ()=>resolve(result));
        tx.addEventListener('abort', ()=>reject(tx.error || new Error('transaction aborted')));
        tx.addEventListener('error', ()=>reject(new Error('transaction error', {
                cause: tx.error
            })));
        try {
            result = await fn(tx.objectStore(storeName));
            tx.commit();
        } catch (error) {
            reject(error);
            tx.abort();
        }
        return promise;
    };
} //# sourceMappingURL=indexeddb.js.map
}),
"[project]/node_modules/@storacha/access/dist/stores/store-indexeddb.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "StoreIndexedDB",
    ()=>StoreIndexedDB
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$drivers$2f$indexeddb$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/dist/drivers/indexeddb.js [app-client] (ecmascript)");
;
class StoreIndexedDB extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$drivers$2f$indexeddb$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IndexedDBDriver"] {
} //# sourceMappingURL=store-indexeddb.js.map
}),
"[project]/node_modules/@storacha/access/dist/access.js [app-client] (ecmascript) <export * as Access>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Access",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$access$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$dist$2f$access$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/dist/access.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@storacha/did-mailto/dist/types.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
;
 //# sourceMappingURL=types.js.map
}),
"[project]/node_modules/@storacha/did-mailto/dist/index.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "email",
    ()=>email,
    "fromEmail",
    ()=>fromEmail,
    "fromString",
    ()=>fromString,
    "toEmail",
    ()=>toEmail
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$did$2d$mailto$2f$dist$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/did-mailto/dist/types.js [app-client] (ecmascript)");
;
function fromEmail(email) {
    const { domain, local } = parseEmail(email);
    const did = `did:mailto:${encodeURIComponent(domain)}:${encodeURIComponent(local)}`;
    return did;
}
function toEmail(did) {
    const parts = did.split(':');
    if (parts[1] !== 'mailto') {
        throw new Error(`DID ${did} is not a mailto did.`);
    }
    return `${decodeURIComponent(parts[3])}@${decodeURIComponent(parts[2])}`;
}
function email(input) {
    const { domain, local } = parseEmail(input);
    /** @type {import("./types.js").EmailAddress} */ const emailAddress = `${local}@${domain}`;
    return emailAddress;
}
function fromString(input) {
    const colonParts = input.split(':');
    if (colonParts.length !== 4) {
        throw new TypeError(`expected did:mailto to have 4 colon-delimited segments, but got ${colonParts.length}`);
    }
    const [domain, local] = [
        colonParts[2],
        colonParts[3]
    ];
    return `did:mailto:${domain}:${local}`;
}
/**
 * @param {string} email
 */ function parseEmail(email) {
    const atParts = email.split('@');
    if (atParts.length < 2) {
        throw new TypeError(`expected at least 2 @-delimited segments, but got ${atParts.length}`);
    }
    const domain = atParts.at(-1) ?? '';
    const local = atParts.slice(0, -1).join('@');
    return {
        domain,
        local
    };
} //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@storacha/did-mailto/dist/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "email",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$did$2d$mailto$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["email"],
    "fromEmail",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$did$2d$mailto$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromEmail"],
    "fromString",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$did$2d$mailto$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromString"],
    "toEmail",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$did$2d$mailto$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["toEmail"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$did$2d$mailto$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@storacha/did-mailto/dist/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$did$2d$mailto$2f$dist$2f$types$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/did-mailto/dist/types.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@storacha/did-mailto/dist/index.js [app-client] (ecmascript) <export * as DIDMailto>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DIDMailto",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$did$2d$mailto$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$did$2d$mailto$2f$dist$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/did-mailto/dist/index.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@storacha/access/node_modules/uint8arrays/dist/src/equals.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Returns true if the two passed Uint8Arrays have the same content
 */ __turbopack_context__.s([
    "equals",
    ()=>equals
]);
function equals(a, b) {
    if (a === b) {
        return true;
    }
    if (a.byteLength !== b.byteLength) {
        return false;
    }
    for(let i = 0; i < a.byteLength; i++){
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
} //# sourceMappingURL=equals.js.map
}),
"[project]/node_modules/@storacha/access/node_modules/uint8arrays/dist/src/alloc.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Returns a `Uint8Array` of the requested size. Referenced memory will
 * be initialized to 0.
 */ __turbopack_context__.s([
    "alloc",
    ()=>alloc,
    "allocUnsafe",
    ()=>allocUnsafe
]);
function alloc(size = 0) {
    return new Uint8Array(size);
}
function allocUnsafe(size = 0) {
    return new Uint8Array(size);
} //# sourceMappingURL=alloc.js.map
}),
"[project]/node_modules/@storacha/access/node_modules/uint8arrays/dist/src/util/as-uint8array.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * To guarantee Uint8Array semantics, convert nodejs Buffers
 * into vanilla Uint8Arrays
 */ __turbopack_context__.s([
    "asUint8Array",
    ()=>asUint8Array
]);
function asUint8Array(buf) {
    return buf;
} //# sourceMappingURL=as-uint8array.js.map
}),
"[project]/node_modules/@storacha/access/node_modules/uint8arrays/dist/src/xor.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "xor",
    ()=>xor
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/node_modules/uint8arrays/dist/src/alloc.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/node_modules/uint8arrays/dist/src/util/as-uint8array.js [app-client] (ecmascript)");
;
;
function xor(a, b) {
    if (a.length !== b.length) {
        throw new Error('Inputs should have the same length');
    }
    const result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["allocUnsafe"])(a.length);
    for(let i = 0; i < a.length; i++){
        result[i] = a[i] ^ b[i];
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asUint8Array"])(result);
} //# sourceMappingURL=xor.js.map
}),
"[project]/node_modules/@storacha/access/node_modules/uint8arrays/dist/src/compare.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Can be used with Array.sort to sort and array with Uint8Array entries
 */ __turbopack_context__.s([
    "compare",
    ()=>compare
]);
function compare(a, b) {
    for(let i = 0; i < a.byteLength; i++){
        if (a[i] < b[i]) {
            return -1;
        }
        if (a[i] > b[i]) {
            return 1;
        }
    }
    if (a.byteLength > b.byteLength) {
        return 1;
    }
    if (a.byteLength < b.byteLength) {
        return -1;
    }
    return 0;
} //# sourceMappingURL=compare.js.map
}),
"[project]/node_modules/@storacha/access/node_modules/uint8arrays/dist/src/concat.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "concat",
    ()=>concat
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/node_modules/uint8arrays/dist/src/alloc.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/node_modules/uint8arrays/dist/src/util/as-uint8array.js [app-client] (ecmascript)");
;
;
function concat(arrays, length) {
    if (length == null) {
        length = arrays.reduce((acc, curr)=>acc + curr.length, 0);
    }
    const output = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["allocUnsafe"])(length);
    let offset = 0;
    for (const arr of arrays){
        output.set(arr, offset);
        offset += arr.length;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asUint8Array"])(output);
} //# sourceMappingURL=concat.js.map
}),
"[project]/node_modules/@storacha/access/node_modules/uint8arrays/dist/src/util/bases.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$basics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/basics.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/node_modules/uint8arrays/dist/src/alloc.js [app-client] (ecmascript)");
;
;
function createCodec(name, prefix, encode, decode) {
    return {
        name,
        prefix,
        encoder: {
            name,
            prefix,
            encode
        },
        decoder: {
            decode
        }
    };
}
const string = createCodec('utf8', 'u', (buf)=>{
    const decoder = new TextDecoder('utf8');
    return 'u' + decoder.decode(buf);
}, (str)=>{
    const encoder = new TextEncoder();
    return encoder.encode(str.substring(1));
});
const ascii = createCodec('ascii', 'a', (buf)=>{
    let string = 'a';
    for(let i = 0; i < buf.length; i++){
        string += String.fromCharCode(buf[i]);
    }
    return string;
}, (str)=>{
    str = str.substring(1);
    const buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["allocUnsafe"])(str.length);
    for(let i = 0; i < str.length; i++){
        buf[i] = str.charCodeAt(i);
    }
    return buf;
});
const BASES = {
    utf8: string,
    'utf-8': string,
    hex: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$basics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bases"].base16,
    latin1: ascii,
    ascii,
    binary: ascii,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$basics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bases"]
};
const __TURBOPACK__default__export__ = BASES;
 //# sourceMappingURL=bases.js.map
}),
"[project]/node_modules/@storacha/access/node_modules/uint8arrays/dist/src/from-string.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "fromString",
    ()=>fromString
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$bases$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/node_modules/uint8arrays/dist/src/util/bases.js [app-client] (ecmascript)");
;
function fromString(string, encoding = 'utf8') {
    const base = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$bases$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"][encoding];
    if (base == null) {
        throw new Error(`Unsupported encoding "${encoding}"`);
    }
    // add multibase prefix
    return base.decoder.decode(`${base.prefix}${string}`); // eslint-disable-line @typescript-eslint/restrict-template-expressions
} //# sourceMappingURL=from-string.js.map
}),
"[project]/node_modules/@storacha/access/node_modules/uint8arrays/dist/src/to-string.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "toString",
    ()=>toString
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$bases$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/node_modules/uint8arrays/dist/src/util/bases.js [app-client] (ecmascript)");
;
function toString(array, encoding = 'utf8') {
    const base = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$bases$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"][encoding];
    if (base == null) {
        throw new Error(`Unsupported encoding "${encoding}"`);
    }
    // strip multibase prefix
    return base.encoder.encode(array).substring(1);
} //# sourceMappingURL=to-string.js.map
}),
"[project]/node_modules/@storacha/access/node_modules/uint8arrays/dist/src/index.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

/**
 * @packageDocumentation
 *
 * `Uint8Array`s bring memory-efficient(ish) byte handling to browsers - they are similar to Node.js `Buffer`s but lack a lot of the utility methods present on that class.
 *
 * This module exports a number of function that let you do common operations - joining Uint8Arrays together, seeing if they have the same contents etc.
 *
 * Since Node.js `Buffer`s are also `Uint8Array`s, it falls back to `Buffer` internally where it makes sense for performance reasons.
 *
 * ## alloc(size)
 *
 * Create a new `Uint8Array`. When running under Node.js, `Buffer` will be used in preference to `Uint8Array`.
 *
 * ### Example
 *
 * ```js
 * import { alloc } from 'uint8arrays/alloc'
 *
 * const buf = alloc(100)
 * ```
 *
 * ## allocUnsafe(size)
 *
 * Create a new `Uint8Array`. When running under Node.js, `Buffer` will be used in preference to `Uint8Array`.
 *
 * On platforms that support it, memory referenced by the returned `Uint8Array` will not be initialized.
 *
 * ### Example
 *
 * ```js
 * import { allocUnsafe } from 'uint8arrays/alloc'
 *
 * const buf = allocUnsafe(100)
 * ```
 *
 * ## compare(a, b)
 *
 * Compare two `Uint8Arrays`
 *
 * ### Example
 *
 * ```js
 * import { compare } from 'uint8arrays/compare'
 *
 * const arrays = [
 *   Uint8Array.from([3, 4, 5]),
 *   Uint8Array.from([0, 1, 2])
 * ]
 *
 * const sorted = arrays.sort(compare)
 *
 * console.info(sorted)
 * // [
 * //    Uint8Array[0, 1, 2]
 * //    Uint8Array[3, 4, 5]
 * // ]
 * ```
 *
 * ## concat(arrays, \[length])
 *
 * Concatenate one or more `Uint8Array`s and return a `Uint8Array` with their contents.
 *
 * If you know the length of the arrays, pass it as a second parameter, otherwise it will be calculated by traversing the list of arrays.
 *
 * ### Example
 *
 * ```js
 * import { concat } from 'uint8arrays/concat'
 *
 * const arrays = [
 *   Uint8Array.from([0, 1, 2]),
 *   Uint8Array.from([3, 4, 5])
 * ]
 *
 * const all = concat(arrays, 6)
 *
 * console.info(all)
 * // Uint8Array[0, 1, 2, 3, 4, 5]
 * ```
 *
 * ## equals(a, b)
 *
 * Returns true if the two arrays are the same array or if they have the same length and contents.
 *
 * ### Example
 *
 * ```js
 * import { equals } from 'uint8arrays/equals'
 *
 * const a = Uint8Array.from([0, 1, 2])
 * const b = Uint8Array.from([3, 4, 5])
 * const c = Uint8Array.from([0, 1, 2])
 *
 * console.info(equals(a, b)) // false
 * console.info(equals(a, c)) // true
 * console.info(equals(a, a)) // true
 * ```
 *
 * ## fromString(string, encoding = 'utf8')
 *
 * Returns a new `Uint8Array` created from the passed string and interpreted as the passed encoding.
 *
 * Supports `utf8` and any of the [multibase encodings](https://github.com/multiformats/multibase/blob/master/multibase.csv) as implemented by the [multiformats module](https://www.npmjs.com/package/multiformats).
 *
 * ### Example
 *
 * ```js
 * import { fromString } from 'uint8arrays/from-string'
 *
 * console.info(fromString('hello world')) // Uint8Array[104, 101 ...
 * console.info(fromString('00010203aabbcc', 'base16')) // Uint8Array[0, 1 ...
 * console.info(fromString('AAECA6q7zA', 'base64')) // Uint8Array[0, 1 ...
 * console.info(fromString('01234', 'ascii')) // Uint8Array[48, 49 ...
 * ```
 *
 * ## toString(array, encoding = 'utf8')
 *
 * Returns a string created from the passed `Uint8Array` in the passed encoding.
 *
 * Supports `utf8` and any of the [multibase encodings](https://github.com/multiformats/multibase/blob/master/multibase.csv) as implemented by the [multiformats module](https://www.npmjs.com/package/multiformats).
 *
 * ### Example
 *
 * ```js
 * import { toString } from 'uint8arrays/to-string'
 *
 * console.info(toString(Uint8Array.from([104, 101...]))) // 'hello world'
 * console.info(toString(Uint8Array.from([0, 1, 2...]), 'base16')) // '00010203aabbcc'
 * console.info(toString(Uint8Array.from([0, 1, 2...]), 'base64')) // 'AAECA6q7zA'
 * console.info(toString(Uint8Array.from([48, 49, 50...]), 'ascii')) // '01234'
 * ```
 *
 * ## xor(a, b)
 *
 * Returns a `Uint8Array` containing `a` and `b` xored together.
 *
 * ### Example
 *
 * ```js
 * import { xor } from 'uint8arrays/xor'
 *
 * console.info(xor(Uint8Array.from([1, 0]), Uint8Array.from([0, 1]))) // Uint8Array[1, 1]
 * ```
 *
 * ## xorCompare(a, b)
 *
 * Compares the distances between two xor `Uint8Array`s.
 *
 * ### Example
 *
 * ```ts
 * import { xor } from 'uint8arrays/xor'
 * import { xorCompare } from 'uint8arrays/xor-compare'
 *
 * const target = Uint8Array.from([1, 1])
 * const val1 = Uint8Array.from([1, 0])
 * const xor1 = xor(target, val1)
 *
 * const val2 = Uint8Array.from([0, 1])
 * const xor2 = xor(target, val2)
 *
 * console.info(xorCompare(xor1, xor2)) // -1 or 0 or 1
 * ```
 */ __turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$equals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/node_modules/uint8arrays/dist/src/equals.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$xor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/node_modules/uint8arrays/dist/src/xor.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$compare$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/node_modules/uint8arrays/dist/src/compare.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$concat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/node_modules/uint8arrays/dist/src/concat.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$from$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/node_modules/uint8arrays/dist/src/from-string.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$access$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/access/node_modules/uint8arrays/dist/src/to-string.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@storacha/blob-index/node_modules/uint8arrays/dist/src/equals.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Returns true if the two passed Uint8Arrays have the same content
 */ __turbopack_context__.s([
    "equals",
    ()=>equals
]);
function equals(a, b) {
    if (a === b) {
        return true;
    }
    if (a.byteLength !== b.byteLength) {
        return false;
    }
    for(let i = 0; i < a.byteLength; i++){
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
} //# sourceMappingURL=equals.js.map
}),
"[project]/node_modules/@storacha/blob-index/node_modules/uint8arrays/dist/src/alloc.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Returns a `Uint8Array` of the requested size. Referenced memory will
 * be initialized to 0.
 */ __turbopack_context__.s([
    "alloc",
    ()=>alloc,
    "allocUnsafe",
    ()=>allocUnsafe
]);
function alloc(size = 0) {
    return new Uint8Array(size);
}
function allocUnsafe(size = 0) {
    return new Uint8Array(size);
} //# sourceMappingURL=alloc.js.map
}),
"[project]/node_modules/@storacha/blob-index/node_modules/uint8arrays/dist/src/util/as-uint8array.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * To guarantee Uint8Array semantics, convert nodejs Buffers
 * into vanilla Uint8Arrays
 */ __turbopack_context__.s([
    "asUint8Array",
    ()=>asUint8Array
]);
function asUint8Array(buf) {
    return buf;
} //# sourceMappingURL=as-uint8array.js.map
}),
"[project]/node_modules/@storacha/blob-index/node_modules/uint8arrays/dist/src/xor.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "xor",
    ()=>xor
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/blob-index/node_modules/uint8arrays/dist/src/alloc.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/blob-index/node_modules/uint8arrays/dist/src/util/as-uint8array.js [app-client] (ecmascript)");
;
;
function xor(a, b) {
    if (a.length !== b.length) {
        throw new Error('Inputs should have the same length');
    }
    const result = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["allocUnsafe"])(a.length);
    for(let i = 0; i < a.length; i++){
        result[i] = a[i] ^ b[i];
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asUint8Array"])(result);
} //# sourceMappingURL=xor.js.map
}),
"[project]/node_modules/@storacha/blob-index/node_modules/uint8arrays/dist/src/compare.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Can be used with Array.sort to sort and array with Uint8Array entries
 */ __turbopack_context__.s([
    "compare",
    ()=>compare
]);
function compare(a, b) {
    for(let i = 0; i < a.byteLength; i++){
        if (a[i] < b[i]) {
            return -1;
        }
        if (a[i] > b[i]) {
            return 1;
        }
    }
    if (a.byteLength > b.byteLength) {
        return 1;
    }
    if (a.byteLength < b.byteLength) {
        return -1;
    }
    return 0;
} //# sourceMappingURL=compare.js.map
}),
"[project]/node_modules/@storacha/blob-index/node_modules/uint8arrays/dist/src/concat.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "concat",
    ()=>concat
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/blob-index/node_modules/uint8arrays/dist/src/alloc.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/blob-index/node_modules/uint8arrays/dist/src/util/as-uint8array.js [app-client] (ecmascript)");
;
;
function concat(arrays, length) {
    if (length == null) {
        length = arrays.reduce((acc, curr)=>acc + curr.length, 0);
    }
    const output = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["allocUnsafe"])(length);
    let offset = 0;
    for (const arr of arrays){
        output.set(arr, offset);
        offset += arr.length;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asUint8Array"])(output);
} //# sourceMappingURL=concat.js.map
}),
"[project]/node_modules/@storacha/blob-index/node_modules/uint8arrays/dist/src/util/bases.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>__TURBOPACK__default__export__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$basics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/basics.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/blob-index/node_modules/uint8arrays/dist/src/alloc.js [app-client] (ecmascript)");
;
;
function createCodec(name, prefix, encode, decode) {
    return {
        name,
        prefix,
        encoder: {
            name,
            prefix,
            encode
        },
        decoder: {
            decode
        }
    };
}
const string = createCodec('utf8', 'u', (buf)=>{
    const decoder = new TextDecoder('utf8');
    return 'u' + decoder.decode(buf);
}, (str)=>{
    const encoder = new TextEncoder();
    return encoder.encode(str.substring(1));
});
const ascii = createCodec('ascii', 'a', (buf)=>{
    let string = 'a';
    for(let i = 0; i < buf.length; i++){
        string += String.fromCharCode(buf[i]);
    }
    return string;
}, (str)=>{
    str = str.substring(1);
    const buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["allocUnsafe"])(str.length);
    for(let i = 0; i < str.length; i++){
        buf[i] = str.charCodeAt(i);
    }
    return buf;
});
const BASES = {
    utf8: string,
    'utf-8': string,
    hex: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$basics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bases"].base16,
    latin1: ascii,
    ascii,
    binary: ascii,
    ...__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$basics$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bases"]
};
const __TURBOPACK__default__export__ = BASES;
 //# sourceMappingURL=bases.js.map
}),
"[project]/node_modules/@storacha/blob-index/node_modules/uint8arrays/dist/src/from-string.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "fromString",
    ()=>fromString
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$bases$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/blob-index/node_modules/uint8arrays/dist/src/util/bases.js [app-client] (ecmascript)");
;
function fromString(string, encoding = 'utf8') {
    const base = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$bases$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"][encoding];
    if (base == null) {
        throw new Error(`Unsupported encoding "${encoding}"`);
    }
    // add multibase prefix
    return base.decoder.decode(`${base.prefix}${string}`); // eslint-disable-line @typescript-eslint/restrict-template-expressions
} //# sourceMappingURL=from-string.js.map
}),
"[project]/node_modules/@storacha/blob-index/node_modules/uint8arrays/dist/src/to-string.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "toString",
    ()=>toString
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$bases$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/blob-index/node_modules/uint8arrays/dist/src/util/bases.js [app-client] (ecmascript)");
;
function toString(array, encoding = 'utf8') {
    const base = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$bases$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"][encoding];
    if (base == null) {
        throw new Error(`Unsupported encoding "${encoding}"`);
    }
    // strip multibase prefix
    return base.encoder.encode(array).substring(1);
} //# sourceMappingURL=to-string.js.map
}),
"[project]/node_modules/@storacha/blob-index/node_modules/uint8arrays/dist/src/index.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

/**
 * @packageDocumentation
 *
 * `Uint8Array`s bring memory-efficient(ish) byte handling to browsers - they are similar to Node.js `Buffer`s but lack a lot of the utility methods present on that class.
 *
 * This module exports a number of function that let you do common operations - joining Uint8Arrays together, seeing if they have the same contents etc.
 *
 * Since Node.js `Buffer`s are also `Uint8Array`s, it falls back to `Buffer` internally where it makes sense for performance reasons.
 *
 * ## alloc(size)
 *
 * Create a new `Uint8Array`. When running under Node.js, `Buffer` will be used in preference to `Uint8Array`.
 *
 * ### Example
 *
 * ```js
 * import { alloc } from 'uint8arrays/alloc'
 *
 * const buf = alloc(100)
 * ```
 *
 * ## allocUnsafe(size)
 *
 * Create a new `Uint8Array`. When running under Node.js, `Buffer` will be used in preference to `Uint8Array`.
 *
 * On platforms that support it, memory referenced by the returned `Uint8Array` will not be initialized.
 *
 * ### Example
 *
 * ```js
 * import { allocUnsafe } from 'uint8arrays/alloc'
 *
 * const buf = allocUnsafe(100)
 * ```
 *
 * ## compare(a, b)
 *
 * Compare two `Uint8Arrays`
 *
 * ### Example
 *
 * ```js
 * import { compare } from 'uint8arrays/compare'
 *
 * const arrays = [
 *   Uint8Array.from([3, 4, 5]),
 *   Uint8Array.from([0, 1, 2])
 * ]
 *
 * const sorted = arrays.sort(compare)
 *
 * console.info(sorted)
 * // [
 * //    Uint8Array[0, 1, 2]
 * //    Uint8Array[3, 4, 5]
 * // ]
 * ```
 *
 * ## concat(arrays, \[length])
 *
 * Concatenate one or more `Uint8Array`s and return a `Uint8Array` with their contents.
 *
 * If you know the length of the arrays, pass it as a second parameter, otherwise it will be calculated by traversing the list of arrays.
 *
 * ### Example
 *
 * ```js
 * import { concat } from 'uint8arrays/concat'
 *
 * const arrays = [
 *   Uint8Array.from([0, 1, 2]),
 *   Uint8Array.from([3, 4, 5])
 * ]
 *
 * const all = concat(arrays, 6)
 *
 * console.info(all)
 * // Uint8Array[0, 1, 2, 3, 4, 5]
 * ```
 *
 * ## equals(a, b)
 *
 * Returns true if the two arrays are the same array or if they have the same length and contents.
 *
 * ### Example
 *
 * ```js
 * import { equals } from 'uint8arrays/equals'
 *
 * const a = Uint8Array.from([0, 1, 2])
 * const b = Uint8Array.from([3, 4, 5])
 * const c = Uint8Array.from([0, 1, 2])
 *
 * console.info(equals(a, b)) // false
 * console.info(equals(a, c)) // true
 * console.info(equals(a, a)) // true
 * ```
 *
 * ## fromString(string, encoding = 'utf8')
 *
 * Returns a new `Uint8Array` created from the passed string and interpreted as the passed encoding.
 *
 * Supports `utf8` and any of the [multibase encodings](https://github.com/multiformats/multibase/blob/master/multibase.csv) as implemented by the [multiformats module](https://www.npmjs.com/package/multiformats).
 *
 * ### Example
 *
 * ```js
 * import { fromString } from 'uint8arrays/from-string'
 *
 * console.info(fromString('hello world')) // Uint8Array[104, 101 ...
 * console.info(fromString('00010203aabbcc', 'base16')) // Uint8Array[0, 1 ...
 * console.info(fromString('AAECA6q7zA', 'base64')) // Uint8Array[0, 1 ...
 * console.info(fromString('01234', 'ascii')) // Uint8Array[48, 49 ...
 * ```
 *
 * ## toString(array, encoding = 'utf8')
 *
 * Returns a string created from the passed `Uint8Array` in the passed encoding.
 *
 * Supports `utf8` and any of the [multibase encodings](https://github.com/multiformats/multibase/blob/master/multibase.csv) as implemented by the [multiformats module](https://www.npmjs.com/package/multiformats).
 *
 * ### Example
 *
 * ```js
 * import { toString } from 'uint8arrays/to-string'
 *
 * console.info(toString(Uint8Array.from([104, 101...]))) // 'hello world'
 * console.info(toString(Uint8Array.from([0, 1, 2...]), 'base16')) // '00010203aabbcc'
 * console.info(toString(Uint8Array.from([0, 1, 2...]), 'base64')) // 'AAECA6q7zA'
 * console.info(toString(Uint8Array.from([48, 49, 50...]), 'ascii')) // '01234'
 * ```
 *
 * ## xor(a, b)
 *
 * Returns a `Uint8Array` containing `a` and `b` xored together.
 *
 * ### Example
 *
 * ```js
 * import { xor } from 'uint8arrays/xor'
 *
 * console.info(xor(Uint8Array.from([1, 0]), Uint8Array.from([0, 1]))) // Uint8Array[1, 1]
 * ```
 *
 * ## xorCompare(a, b)
 *
 * Compares the distances between two xor `Uint8Array`s.
 *
 * ### Example
 *
 * ```ts
 * import { xor } from 'uint8arrays/xor'
 * import { xorCompare } from 'uint8arrays/xor-compare'
 *
 * const target = Uint8Array.from([1, 1])
 * const val1 = Uint8Array.from([1, 0])
 * const xor1 = xor(target, val1)
 *
 * const val2 = Uint8Array.from([0, 1])
 * const xor2 = xor(target, val2)
 *
 * console.info(xorCompare(xor1, xor2)) // -1 or 0 or 1
 * ```
 */ __turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$equals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/blob-index/node_modules/uint8arrays/dist/src/equals.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$xor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/blob-index/node_modules/uint8arrays/dist/src/xor.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$compare$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/blob-index/node_modules/uint8arrays/dist/src/compare.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$concat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/blob-index/node_modules/uint8arrays/dist/src/concat.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$from$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/blob-index/node_modules/uint8arrays/dist/src/from-string.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$to$2d$string$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/blob-index/node_modules/uint8arrays/dist/src/to-string.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
 //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/alloc.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Returns a `Uint8Array` of the requested size. Referenced memory will
 * be initialized to 0.
 */ __turbopack_context__.s([
    "alloc",
    ()=>alloc,
    "allocUnsafe",
    ()=>allocUnsafe
]);
function alloc(size = 0) {
    return new Uint8Array(size);
}
function allocUnsafe(size = 0) {
    return new Uint8Array(size);
} //# sourceMappingURL=alloc.js.map
}),
"[project]/node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/util/as-uint8array.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * To guarantee Uint8Array semantics, convert nodejs Buffers
 * into vanilla Uint8Arrays
 */ __turbopack_context__.s([
    "asUint8Array",
    ()=>asUint8Array
]);
function asUint8Array(buf) {
    return buf;
} //# sourceMappingURL=as-uint8array.js.map
}),
"[project]/node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/concat.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "concat",
    ()=>concat
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/alloc.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/util/as-uint8array.js [app-client] (ecmascript)");
;
;
function concat(arrays, length) {
    if (length == null) {
        length = arrays.reduce((acc, curr)=>acc + curr.length, 0);
    }
    const output = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["allocUnsafe"])(length);
    let offset = 0;
    for (const arr of arrays){
        output.set(arr, offset);
        offset += arr.length;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$util$2f$as$2d$uint8array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asUint8Array"])(output);
} //# sourceMappingURL=concat.js.map
}),
"[project]/node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/equals.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Returns true if the two passed Uint8Arrays have the same content
 */ __turbopack_context__.s([
    "equals",
    ()=>equals
]);
function equals(a, b) {
    if (a === b) {
        return true;
    }
    if (a.byteLength !== b.byteLength) {
        return false;
    }
    for(let i = 0; i < a.byteLength; i++){
        if (a[i] !== b[i]) {
            return false;
        }
    }
    return true;
} //# sourceMappingURL=equals.js.map
}),
"[project]/node_modules/@noble/ed25519/lib/esm/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*! noble-ed25519 - MIT License (c) 2019 Paul Miller (paulmillr.com) */ __turbopack_context__.s([
    "CURVE",
    ()=>CURVE,
    "ExtendedPoint",
    ()=>ExtendedPoint,
    "Point",
    ()=>Point,
    "RistrettoPoint",
    ()=>RistrettoPoint,
    "Signature",
    ()=>Signature,
    "bytesToHex",
    ()=>bytesToHex,
    "curve25519",
    ()=>curve25519,
    "getPublicKey",
    ()=>getPublicKey,
    "getSharedSecret",
    ()=>getSharedSecret,
    "hexToBytes",
    ()=>hexToBytes,
    "sign",
    ()=>sign,
    "sync",
    ()=>sync,
    "utils",
    ()=>utils,
    "verify",
    ()=>verify
]);
;
const _0n = BigInt(0);
const _1n = BigInt(1);
const _2n = BigInt(2);
const _8n = BigInt(8);
const CU_O = BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989');
const CURVE = Object.freeze({
    a: BigInt(-1),
    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),
    P: BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819949'),
    l: CU_O,
    n: CU_O,
    h: BigInt(8),
    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),
    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960')
});
;
const POW_2_256 = BigInt('0x10000000000000000000000000000000000000000000000000000000000000000');
const SQRT_M1 = BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');
const SQRT_D = BigInt('6853475219497561581579357271197624642482790079785650197046958215289687604742');
const SQRT_AD_MINUS_ONE = BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');
const INVSQRT_A_MINUS_D = BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');
const ONE_MINUS_D_SQ = BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');
const D_MINUS_ONE_SQ = BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');
class ExtendedPoint {
    constructor(x, y, z, t){
        this.x = x;
        this.y = y;
        this.z = z;
        this.t = t;
    }
    static fromAffine(p) {
        if (!(p instanceof Point)) {
            throw new TypeError('ExtendedPoint#fromAffine: expected Point');
        }
        if (p.equals(Point.ZERO)) return ExtendedPoint.ZERO;
        return new ExtendedPoint(p.x, p.y, _1n, mod(p.x * p.y));
    }
    static toAffineBatch(points) {
        const toInv = invertBatch(points.map((p)=>p.z));
        return points.map((p, i)=>p.toAffine(toInv[i]));
    }
    static normalizeZ(points) {
        return this.toAffineBatch(points).map(this.fromAffine);
    }
    equals(other) {
        assertExtPoint(other);
        const { x: X1, y: Y1, z: Z1 } = this;
        const { x: X2, y: Y2, z: Z2 } = other;
        const X1Z2 = mod(X1 * Z2);
        const X2Z1 = mod(X2 * Z1);
        const Y1Z2 = mod(Y1 * Z2);
        const Y2Z1 = mod(Y2 * Z1);
        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
    }
    negate() {
        return new ExtendedPoint(mod(-this.x), this.y, this.z, mod(-this.t));
    }
    double() {
        const { x: X1, y: Y1, z: Z1 } = this;
        const { a } = CURVE;
        const M = mod;
        const A = M(X1 * X1);
        const B = M(Y1 * Y1);
        const C = M(_2n * M(Z1 * Z1));
        const D = M(a * A);
        const x1y1 = X1 + Y1;
        const E = M(M(x1y1 * x1y1) - A - B);
        const G = D + B;
        const F = G - C;
        const H = D - B;
        const X3 = M(E * F);
        const Y3 = M(G * H);
        const T3 = M(E * H);
        const Z3 = M(F * G);
        return new ExtendedPoint(X3, Y3, Z3, T3);
    }
    add(other) {
        const { x: X1, y: Y1, z: Z1, t: T1 } = this;
        assertExtPoint(other);
        const { x: X2, y: Y2, z: Z2, t: T2 } = other;
        const { a, d } = CURVE;
        const M = mod;
        const A = M(X1 * X2);
        const B = M(Y1 * Y2);
        const C = M(T1 * d * T2);
        const D = M(Z1 * Z2);
        const E = M((X1 + Y1) * (X2 + Y2) - A - B);
        const F = M(D - C);
        const G = M(D + C);
        const H = M(B - a * A);
        const X3 = M(E * F);
        const Y3 = M(G * H);
        const T3 = M(E * H);
        const Z3 = M(F * G);
        return new ExtendedPoint(X3, Y3, Z3, T3);
    }
    subtract(other) {
        return this.add(other.negate());
    }
    precomputeWindow(W) {
        const windows = 1 + 256 / W;
        const points = [];
        let p = this;
        let base = p;
        for(let window = 0; window < windows; window++){
            base = p;
            points.push(base);
            for(let i = 1; i < 2 ** (W - 1); i++){
                base = base.add(p);
                points.push(base);
            }
            p = base.double();
        }
        return points;
    }
    wNAF(n, affinePoint) {
        if (!affinePoint && this.equals(ExtendedPoint.BASE)) affinePoint = Point.BASE;
        const W = affinePoint && affinePoint._WINDOW_SIZE || 1;
        if (256 % W) {
            throw new Error('Point#wNAF: Invalid precomputation window, must be power of 2');
        }
        let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
        if (!precomputes) {
            precomputes = this.precomputeWindow(W);
            if (affinePoint && W !== 1) {
                precomputes = ExtendedPoint.normalizeZ(precomputes);
                pointPrecomputes.set(affinePoint, precomputes);
            }
        }
        let p = ExtendedPoint.ZERO;
        let f = ExtendedPoint.BASE;
        const windows = 1 + 256 / W;
        const windowSize = 2 ** (W - 1);
        const mask = BigInt(2 ** W - 1);
        const maxNumber = 2 ** W;
        const shiftBy = BigInt(W);
        for(let window = 0; window < windows; window++){
            const offset = window * windowSize;
            let wbits = Number(n & mask);
            n >>= shiftBy;
            if (wbits > windowSize) {
                wbits -= maxNumber;
                n += _1n;
            }
            const offset1 = offset;
            const offset2 = offset + Math.abs(wbits) - 1;
            const cond1 = window % 2 !== 0;
            const cond2 = wbits < 0;
            if (wbits === 0) {
                f = f.add(constTimeNegate(cond1, precomputes[offset1]));
            } else {
                p = p.add(constTimeNegate(cond2, precomputes[offset2]));
            }
        }
        return ExtendedPoint.normalizeZ([
            p,
            f
        ])[0];
    }
    multiply(scalar, affinePoint) {
        return this.wNAF(normalizeScalar(scalar, CURVE.l), affinePoint);
    }
    multiplyUnsafe(scalar) {
        let n = normalizeScalar(scalar, CURVE.l, false);
        const G = ExtendedPoint.BASE;
        const P0 = ExtendedPoint.ZERO;
        if (n === _0n) return P0;
        if (this.equals(P0) || n === _1n) return this;
        if (this.equals(G)) return this.wNAF(n);
        let p = P0;
        let d = this;
        while(n > _0n){
            if (n & _1n) p = p.add(d);
            d = d.double();
            n >>= _1n;
        }
        return p;
    }
    isSmallOrder() {
        return this.multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);
    }
    isTorsionFree() {
        let p = this.multiplyUnsafe(CURVE.l / _2n).double();
        if (CURVE.l % _2n) p = p.add(this);
        return p.equals(ExtendedPoint.ZERO);
    }
    toAffine(invZ) {
        const { x, y, z } = this;
        const is0 = this.equals(ExtendedPoint.ZERO);
        if (invZ == null) invZ = is0 ? _8n : invert(z);
        const ax = mod(x * invZ);
        const ay = mod(y * invZ);
        const zz = mod(z * invZ);
        if (is0) return Point.ZERO;
        if (zz !== _1n) throw new Error('invZ was invalid');
        return new Point(ax, ay);
    }
    fromRistrettoBytes() {
        legacyRist();
    }
    toRistrettoBytes() {
        legacyRist();
    }
    fromRistrettoHash() {
        legacyRist();
    }
}
ExtendedPoint.BASE = new ExtendedPoint(CURVE.Gx, CURVE.Gy, _1n, mod(CURVE.Gx * CURVE.Gy));
ExtendedPoint.ZERO = new ExtendedPoint(_0n, _1n, _1n, _0n);
function constTimeNegate(condition, item) {
    const neg = item.negate();
    return condition ? neg : item;
}
function assertExtPoint(other) {
    if (!(other instanceof ExtendedPoint)) throw new TypeError('ExtendedPoint expected');
}
function assertRstPoint(other) {
    if (!(other instanceof RistrettoPoint)) throw new TypeError('RistrettoPoint expected');
}
function legacyRist() {
    throw new Error('Legacy method: switch to RistrettoPoint');
}
class RistrettoPoint {
    constructor(ep){
        this.ep = ep;
    }
    static calcElligatorRistrettoMap(r0) {
        const { d } = CURVE;
        const r = mod(SQRT_M1 * r0 * r0);
        const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);
        let c = BigInt(-1);
        const D = mod((c - d * r) * mod(r + d));
        let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
        let s_ = mod(s * r0);
        if (!edIsNegative(s_)) s_ = mod(-s_);
        if (!Ns_D_is_sq) s = s_;
        if (!Ns_D_is_sq) c = r;
        const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);
        const s2 = s * s;
        const W0 = mod((s + s) * D);
        const W1 = mod(Nt * SQRT_AD_MINUS_ONE);
        const W2 = mod(_1n - s2);
        const W3 = mod(_1n + s2);
        return new ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));
    }
    static hashToCurve(hex) {
        hex = ensureBytes(hex, 64);
        const r1 = bytes255ToNumberLE(hex.slice(0, 32));
        const R1 = this.calcElligatorRistrettoMap(r1);
        const r2 = bytes255ToNumberLE(hex.slice(32, 64));
        const R2 = this.calcElligatorRistrettoMap(r2);
        return new RistrettoPoint(R1.add(R2));
    }
    static fromHex(hex) {
        hex = ensureBytes(hex, 32);
        const { a, d } = CURVE;
        const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';
        const s = bytes255ToNumberLE(hex);
        if (!equalBytes(numberTo32BytesLE(s), hex) || edIsNegative(s)) throw new Error(emsg);
        const s2 = mod(s * s);
        const u1 = mod(_1n + a * s2);
        const u2 = mod(_1n - a * s2);
        const u1_2 = mod(u1 * u1);
        const u2_2 = mod(u2 * u2);
        const v = mod(a * d * u1_2 - u2_2);
        const { isValid, value: I } = invertSqrt(mod(v * u2_2));
        const Dx = mod(I * u2);
        const Dy = mod(I * Dx * v);
        let x = mod((s + s) * Dx);
        if (edIsNegative(x)) x = mod(-x);
        const y = mod(u1 * Dy);
        const t = mod(x * y);
        if (!isValid || edIsNegative(t) || y === _0n) throw new Error(emsg);
        return new RistrettoPoint(new ExtendedPoint(x, y, _1n, t));
    }
    toRawBytes() {
        let { x, y, z, t } = this.ep;
        const u1 = mod(mod(z + y) * mod(z - y));
        const u2 = mod(x * y);
        const u2sq = mod(u2 * u2);
        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq));
        const D1 = mod(invsqrt * u1);
        const D2 = mod(invsqrt * u2);
        const zInv = mod(D1 * D2 * t);
        let D;
        if (edIsNegative(t * zInv)) {
            let _x = mod(y * SQRT_M1);
            let _y = mod(x * SQRT_M1);
            x = _x;
            y = _y;
            D = mod(D1 * INVSQRT_A_MINUS_D);
        } else {
            D = D2;
        }
        if (edIsNegative(x * zInv)) y = mod(-y);
        let s = mod((z - y) * D);
        if (edIsNegative(s)) s = mod(-s);
        return numberTo32BytesLE(s);
    }
    toHex() {
        return bytesToHex(this.toRawBytes());
    }
    toString() {
        return this.toHex();
    }
    equals(other) {
        assertRstPoint(other);
        const a = this.ep;
        const b = other.ep;
        const one = mod(a.x * b.y) === mod(a.y * b.x);
        const two = mod(a.y * b.y) === mod(a.x * b.x);
        return one || two;
    }
    add(other) {
        assertRstPoint(other);
        return new RistrettoPoint(this.ep.add(other.ep));
    }
    subtract(other) {
        assertRstPoint(other);
        return new RistrettoPoint(this.ep.subtract(other.ep));
    }
    multiply(scalar) {
        return new RistrettoPoint(this.ep.multiply(scalar));
    }
    multiplyUnsafe(scalar) {
        return new RistrettoPoint(this.ep.multiplyUnsafe(scalar));
    }
}
RistrettoPoint.BASE = new RistrettoPoint(ExtendedPoint.BASE);
RistrettoPoint.ZERO = new RistrettoPoint(ExtendedPoint.ZERO);
const pointPrecomputes = new WeakMap();
class Point {
    constructor(x, y){
        this.x = x;
        this.y = y;
    }
    _setWindowSize(windowSize) {
        this._WINDOW_SIZE = windowSize;
        pointPrecomputes.delete(this);
    }
    static fromHex(hex, strict = true) {
        const { d, P } = CURVE;
        hex = ensureBytes(hex, 32);
        const normed = hex.slice();
        normed[31] = hex[31] & ~0x80;
        const y = bytesToNumberLE(normed);
        if (strict && y >= P) throw new Error('Expected 0 < hex < P');
        if (!strict && y >= POW_2_256) throw new Error('Expected 0 < hex < 2**256');
        const y2 = mod(y * y);
        const u = mod(y2 - _1n);
        const v = mod(d * y2 + _1n);
        let { isValid, value: x } = uvRatio(u, v);
        if (!isValid) throw new Error('Point.fromHex: invalid y coordinate');
        const isXOdd = (x & _1n) === _1n;
        const isLastByteOdd = (hex[31] & 0x80) !== 0;
        if (isLastByteOdd !== isXOdd) {
            x = mod(-x);
        }
        return new Point(x, y);
    }
    static async fromPrivateKey(privateKey) {
        return (await getExtendedPublicKey(privateKey)).point;
    }
    toRawBytes() {
        const bytes = numberTo32BytesLE(this.y);
        bytes[31] |= this.x & _1n ? 0x80 : 0;
        return bytes;
    }
    toHex() {
        return bytesToHex(this.toRawBytes());
    }
    toX25519() {
        const { y } = this;
        const u = mod((_1n + y) * invert(_1n - y));
        return numberTo32BytesLE(u);
    }
    isTorsionFree() {
        return ExtendedPoint.fromAffine(this).isTorsionFree();
    }
    equals(other) {
        return this.x === other.x && this.y === other.y;
    }
    negate() {
        return new Point(mod(-this.x), this.y);
    }
    add(other) {
        return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();
    }
    subtract(other) {
        return this.add(other.negate());
    }
    multiply(scalar) {
        return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();
    }
}
Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
Point.ZERO = new Point(_0n, _1n);
class Signature {
    constructor(r, s){
        this.r = r;
        this.s = s;
        this.assertValidity();
    }
    static fromHex(hex) {
        const bytes = ensureBytes(hex, 64);
        const r = Point.fromHex(bytes.slice(0, 32), false);
        const s = bytesToNumberLE(bytes.slice(32, 64));
        return new Signature(r, s);
    }
    assertValidity() {
        const { r, s } = this;
        if (!(r instanceof Point)) throw new Error('Expected Point instance');
        normalizeScalar(s, CURVE.l, false);
        return this;
    }
    toRawBytes() {
        const u8 = new Uint8Array(64);
        u8.set(this.r.toRawBytes());
        u8.set(numberTo32BytesLE(this.s), 32);
        return u8;
    }
    toHex() {
        return bytesToHex(this.toRawBytes());
    }
}
;
function isBytes(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array';
}
function abytes(item) {
    if (!isBytes(item)) throw new Error('Uint8Array expected');
}
function concatBytes(...arrays) {
    arrays.every(abytes);
    if (arrays.length === 1) return arrays[0];
    const length = arrays.reduce((a, arr)=>a + arr.length, 0);
    const result = new Uint8Array(length);
    for(let i = 0, pad = 0; i < arrays.length; i++){
        const arr = arrays[i];
        result.set(arr, pad);
        pad += arr.length;
    }
    return result;
}
const hexes = Array.from({
    length: 256
}, (_, i)=>i.toString(16).padStart(2, '0'));
function bytesToHex(bytes) {
    abytes(bytes);
    let hex = '';
    for(let i = 0; i < bytes.length; i++){
        hex += hexes[bytes[i]];
    }
    return hex;
}
const asciis = {
    _0: 48,
    _9: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};
function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0;
    if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10);
    if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10);
    return;
}
function hexToBytes(hex) {
    if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);
    const array = new Uint8Array(al);
    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
    }
    return array;
}
function numberTo32BytesBE(num) {
    const length = 32;
    const hex = num.toString(16).padStart(length * 2, '0');
    return hexToBytes(hex);
}
function numberTo32BytesLE(num) {
    return numberTo32BytesBE(num).reverse();
}
function edIsNegative(num) {
    return (mod(num) & _1n) === _1n;
}
function bytesToNumberLE(uint8a) {
    abytes(uint8a);
    return BigInt('0x' + bytesToHex(Uint8Array.from(uint8a).reverse()));
}
const MAX_255B = BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');
function bytes255ToNumberLE(bytes) {
    return mod(bytesToNumberLE(bytes) & MAX_255B);
}
function mod(a, b = CURVE.P) {
    const res = a % b;
    return res >= _0n ? res : b + res;
}
function invert(number, modulo = CURVE.P) {
    if (number === _0n || modulo <= _0n) {
        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
    }
    let a = mod(number, modulo);
    let b = modulo;
    let x = _0n, y = _1n, u = _1n, v = _0n;
    while(a !== _0n){
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        b = a, a = r, x = u, y = v, u = m, v = n;
    }
    const gcd = b;
    if (gcd !== _1n) throw new Error('invert: does not exist');
    return mod(x, modulo);
}
function invertBatch(nums, p = CURVE.P) {
    const tmp = new Array(nums.length);
    const lastMultiplied = nums.reduce((acc, num, i)=>{
        if (num === _0n) return acc;
        tmp[i] = acc;
        return mod(acc * num, p);
    }, _1n);
    const inverted = invert(lastMultiplied, p);
    nums.reduceRight((acc, num, i)=>{
        if (num === _0n) return acc;
        tmp[i] = mod(acc * tmp[i], p);
        return mod(acc * num, p);
    }, inverted);
    return tmp;
}
function pow2(x, power) {
    const { P } = CURVE;
    let res = x;
    while(power-- > _0n){
        res *= res;
        res %= P;
    }
    return res;
}
function pow_2_252_3(x) {
    const { P } = CURVE;
    const _5n = BigInt(5);
    const _10n = BigInt(10);
    const _20n = BigInt(20);
    const _40n = BigInt(40);
    const _80n = BigInt(80);
    const x2 = x * x % P;
    const b2 = x2 * x % P;
    const b4 = pow2(b2, _2n) * b2 % P;
    const b5 = pow2(b4, _1n) * x % P;
    const b10 = pow2(b5, _5n) * b5 % P;
    const b20 = pow2(b10, _10n) * b10 % P;
    const b40 = pow2(b20, _20n) * b20 % P;
    const b80 = pow2(b40, _40n) * b40 % P;
    const b160 = pow2(b80, _80n) * b80 % P;
    const b240 = pow2(b160, _80n) * b80 % P;
    const b250 = pow2(b240, _10n) * b10 % P;
    const pow_p_5_8 = pow2(b250, _2n) * x % P;
    return {
        pow_p_5_8,
        b2
    };
}
function uvRatio(u, v) {
    const v3 = mod(v * v * v);
    const v7 = mod(v3 * v3 * v);
    const pow = pow_2_252_3(u * v7).pow_p_5_8;
    let x = mod(u * v3 * pow);
    const vx2 = mod(v * x * x);
    const root1 = x;
    const root2 = mod(x * SQRT_M1);
    const useRoot1 = vx2 === u;
    const useRoot2 = vx2 === mod(-u);
    const noRoot = vx2 === mod(-u * SQRT_M1);
    if (useRoot1) x = root1;
    if (useRoot2 || noRoot) x = root2;
    if (edIsNegative(x)) x = mod(-x);
    return {
        isValid: useRoot1 || useRoot2,
        value: x
    };
}
function invertSqrt(number) {
    return uvRatio(_1n, number);
}
function modlLE(hash) {
    return mod(bytesToNumberLE(hash), CURVE.l);
}
function equalBytes(b1, b2) {
    if (b1.length !== b2.length) {
        return false;
    }
    for(let i = 0; i < b1.length; i++){
        if (b1[i] !== b2[i]) {
            return false;
        }
    }
    return true;
}
function ensureBytes(hex, expectedLength) {
    const bytes = isBytes(hex) ? Uint8Array.from(hex) : hexToBytes(hex);
    if (typeof expectedLength === 'number' && bytes.length !== expectedLength) throw new Error(`Expected ${expectedLength} bytes`);
    return bytes;
}
function normalizeScalar(num, max, strict = true) {
    if (!max) throw new TypeError('Specify max value');
    if (typeof num === 'number' && Number.isSafeInteger(num)) num = BigInt(num);
    if (typeof num === 'bigint' && num < max) {
        if (strict) {
            if (_0n < num) return num;
        } else {
            if (_0n <= num) return num;
        }
    }
    throw new TypeError('Expected valid scalar: 0 < scalar < max');
}
function adjustBytes25519(bytes) {
    bytes[0] &= 248;
    bytes[31] &= 127;
    bytes[31] |= 64;
    return bytes;
}
function decodeScalar25519(n) {
    return bytesToNumberLE(adjustBytes25519(ensureBytes(n, 32)));
}
function checkPrivateKey(key) {
    key = typeof key === 'bigint' || typeof key === 'number' ? numberTo32BytesBE(normalizeScalar(key, POW_2_256)) : ensureBytes(key);
    if (key.length !== 32) throw new Error(`Expected 32 bytes`);
    return key;
}
function getKeyFromHash(hashed) {
    const head = adjustBytes25519(hashed.slice(0, 32));
    const prefix = hashed.slice(32, 64);
    const scalar = modlLE(head);
    const point = Point.BASE.multiply(scalar);
    const pointBytes = point.toRawBytes();
    return {
        head,
        prefix,
        scalar,
        point,
        pointBytes
    };
}
let _sha512Sync;
function sha512s(...m) {
    if (typeof _sha512Sync !== 'function') throw new Error('utils.sha512Sync must be set to use sync methods');
    return _sha512Sync(...m);
}
async function getExtendedPublicKey(key) {
    return getKeyFromHash(await utils.sha512(checkPrivateKey(key)));
}
function getExtendedPublicKeySync(key) {
    return getKeyFromHash(sha512s(checkPrivateKey(key)));
}
async function getPublicKey(privateKey) {
    return (await getExtendedPublicKey(privateKey)).pointBytes;
}
function getPublicKeySync(privateKey) {
    return getExtendedPublicKeySync(privateKey).pointBytes;
}
async function sign(message, privateKey) {
    message = ensureBytes(message);
    const { prefix, scalar, pointBytes } = await getExtendedPublicKey(privateKey);
    const r = modlLE(await utils.sha512(prefix, message));
    const R = Point.BASE.multiply(r);
    const k = modlLE(await utils.sha512(R.toRawBytes(), pointBytes, message));
    const s = mod(r + k * scalar, CURVE.l);
    return new Signature(R, s).toRawBytes();
}
function signSync(message, privateKey) {
    message = ensureBytes(message);
    const { prefix, scalar, pointBytes } = getExtendedPublicKeySync(privateKey);
    const r = modlLE(sha512s(prefix, message));
    const R = Point.BASE.multiply(r);
    const k = modlLE(sha512s(R.toRawBytes(), pointBytes, message));
    const s = mod(r + k * scalar, CURVE.l);
    return new Signature(R, s).toRawBytes();
}
function prepareVerification(sig, message, publicKey) {
    message = ensureBytes(message);
    if (!(publicKey instanceof Point)) publicKey = Point.fromHex(publicKey, false);
    const { r, s } = sig instanceof Signature ? sig.assertValidity() : Signature.fromHex(sig);
    const SB = ExtendedPoint.BASE.multiplyUnsafe(s);
    return {
        r,
        s,
        SB,
        pub: publicKey,
        msg: message
    };
}
function finishVerification(publicKey, r, SB, hashed) {
    const k = modlLE(hashed);
    const kA = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(k);
    const RkA = ExtendedPoint.fromAffine(r).add(kA);
    return RkA.subtract(SB).multiplyUnsafe(CURVE.h).equals(ExtendedPoint.ZERO);
}
async function verify(sig, message, publicKey) {
    const { r, SB, msg, pub } = prepareVerification(sig, message, publicKey);
    const hashed = await utils.sha512(r.toRawBytes(), pub.toRawBytes(), msg);
    return finishVerification(pub, r, SB, hashed);
}
function verifySync(sig, message, publicKey) {
    const { r, SB, msg, pub } = prepareVerification(sig, message, publicKey);
    const hashed = sha512s(r.toRawBytes(), pub.toRawBytes(), msg);
    return finishVerification(pub, r, SB, hashed);
}
const sync = {
    getExtendedPublicKey: getExtendedPublicKeySync,
    getPublicKey: getPublicKeySync,
    sign: signSync,
    verify: verifySync
};
async function getSharedSecret(privateKey, publicKey) {
    const { head } = await getExtendedPublicKey(privateKey);
    const u = Point.fromHex(publicKey).toX25519();
    return curve25519.scalarMult(head, u);
}
Point.BASE._setWindowSize(8);
function cswap(swap, x_2, x_3) {
    const dummy = mod(swap * (x_2 - x_3));
    x_2 = mod(x_2 - dummy);
    x_3 = mod(x_3 + dummy);
    return [
        x_2,
        x_3
    ];
}
function montgomeryLadder(pointU, scalar) {
    const { P } = CURVE;
    const u = normalizeScalar(pointU, P);
    const k = normalizeScalar(scalar, P);
    const a24 = BigInt(121665);
    const x_1 = u;
    let x_2 = _1n;
    let z_2 = _0n;
    let x_3 = u;
    let z_3 = _1n;
    let swap = _0n;
    let sw;
    for(let t = BigInt(255 - 1); t >= _0n; t--){
        const k_t = k >> t & _1n;
        swap ^= k_t;
        sw = cswap(swap, x_2, x_3);
        x_2 = sw[0];
        x_3 = sw[1];
        sw = cswap(swap, z_2, z_3);
        z_2 = sw[0];
        z_3 = sw[1];
        swap = k_t;
        const A = x_2 + z_2;
        const AA = mod(A * A);
        const B = x_2 - z_2;
        const BB = mod(B * B);
        const E = AA - BB;
        const C = x_3 + z_3;
        const D = x_3 - z_3;
        const DA = mod(D * A);
        const CB = mod(C * B);
        const dacb = DA + CB;
        const da_cb = DA - CB;
        x_3 = mod(dacb * dacb);
        z_3 = mod(x_1 * mod(da_cb * da_cb));
        x_2 = mod(AA * BB);
        z_2 = mod(E * (AA + mod(a24 * E)));
    }
    sw = cswap(swap, x_2, x_3);
    x_2 = sw[0];
    x_3 = sw[1];
    sw = cswap(swap, z_2, z_3);
    z_2 = sw[0];
    z_3 = sw[1];
    const { pow_p_5_8, b2 } = pow_2_252_3(z_2);
    const xp2 = mod(pow2(pow_p_5_8, BigInt(3)) * b2);
    return mod(x_2 * xp2);
}
function encodeUCoordinate(u) {
    return numberTo32BytesLE(mod(u, CURVE.P));
}
function decodeUCoordinate(uEnc) {
    const u = ensureBytes(uEnc, 32);
    u[31] &= 127;
    return bytesToNumberLE(u);
}
const curve25519 = {
    BASE_POINT_U: '0900000000000000000000000000000000000000000000000000000000000000',
    scalarMult (privateKey, publicKey) {
        const u = decodeUCoordinate(publicKey);
        const p = decodeScalar25519(privateKey);
        const pu = montgomeryLadder(u, p);
        if (pu === _0n) throw new Error('Invalid private or public key received');
        return encodeUCoordinate(pu);
    },
    scalarMultBase (privateKey) {
        return curve25519.scalarMult(privateKey, curve25519.BASE_POINT_U);
    }
};
const crypto = {
    node: void 0,
    web: typeof self === 'object' && 'crypto' in self ? self.crypto : undefined
};
const utils = {
    bytesToHex,
    hexToBytes,
    concatBytes,
    getExtendedPublicKey,
    mod,
    invert,
    TORSION_SUBGROUP: [
        '0100000000000000000000000000000000000000000000000000000000000000',
        'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',
        '0000000000000000000000000000000000000000000000000000000000000080',
        '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',
        'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',
        '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',
        '0000000000000000000000000000000000000000000000000000000000000000',
        'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa'
    ],
    hashToPrivateScalar: (hash)=>{
        hash = ensureBytes(hash);
        if (hash.length < 40 || hash.length > 1024) throw new Error('Expected 40-1024 bytes of private key as per FIPS 186');
        return mod(bytesToNumberLE(hash), CURVE.l - _1n) + _1n;
    },
    randomBytes: (bytesLength = 32)=>{
        if (crypto.web) {
            return crypto.web.getRandomValues(new Uint8Array(bytesLength));
        } else if (crypto.node) {
            const { randomBytes } = crypto.node;
            return new Uint8Array(randomBytes(bytesLength).buffer);
        } else {
            throw new Error("The environment doesn't have randomBytes function");
        }
    },
    randomPrivateKey: ()=>{
        return utils.randomBytes(32);
    },
    sha512: async (...messages)=>{
        const message = concatBytes(...messages);
        if (crypto.web) {
            const buffer = await crypto.web.subtle.digest('SHA-512', message.buffer);
            return new Uint8Array(buffer);
        } else if (crypto.node) {
            return Uint8Array.from(crypto.node.createHash('sha512').update(message).digest());
        } else {
            throw new Error("The environment doesn't have sha512 function");
        }
    },
    precompute (windowSize = 8, point = Point.BASE) {
        const cached = point.equals(Point.BASE) ? point : new Point(point.x, point.y);
        cached._setWindowSize(windowSize);
        cached.multiply(_2n);
        return cached;
    },
    sha512Sync: undefined
};
Object.defineProperties(utils, {
    sha512Sync: {
        configurable: false,
        get () {
            return _sha512Sync;
        },
        set (val) {
            if (!_sha512Sync) _sha512Sync = val;
        }
    }
});
}),
"[project]/node_modules/@ucanto/principal/src/ed25519/type.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
}),
"[project]/node_modules/@ucanto/principal/src/verifier.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "or",
    ()=>or,
    "withDID",
    ()=>withDID
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$interface$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/interface/src/lib.js [app-client] (ecmascript)");
;
/**
 * @param {API.DID} did
 * @param {API.PrincipalParser[]} parsers
 * @return {API.Verifier}
 */ const parseWith = (did, parsers)=>{
    if (did.startsWith('did:')) {
        for (const parser of parsers){
            try {
                return parser.parse(did);
            } catch (_) {}
        }
        throw new Error(`Unsupported did ${did}`);
    } else {
        throw new Error(`Expected did instead got ${did}`);
    }
};
const or = (left, right)=>new Parser([
        left,
        right
    ]);
/**
 * @implements {API.ComposedDIDParser}
 */ class Parser {
    /**
   * @param {API.PrincipalParser[]} variants
   */ constructor(variants){
        this.variants = variants;
    }
    /**
   * @param {API.DID} did
   */ parse(did) {
        return parseWith(did, this.variants);
    }
    /**
   * @param {API.PrincipalParser} parser
   */ or(parser) {
        return new Parser([
            ...this.variants,
            parser
        ]);
    }
}
const withDID = (key, id)=>new VerifierWithDID(id, key);
/**
 * @template {API.DID} ID
 * @template {API.MulticodecCode} SigAlg
 * @implements {API.Verifier<ID, SigAlg>}
 */ class VerifierWithDID {
    /**
   * @param {ID} id
   * @param {API.VerifierKey<SigAlg>} key
   */ constructor(id, key){
        this.id = id;
        this.key = key;
    }
    did() {
        return this.id;
    }
    toDIDKey() {
        return this.key.toDIDKey();
    }
    /**
   * @template T
   * @param {API.ByteView<T>} payload
   * @param {API.Signature<T, SigAlg>} signature
   * @returns {API.Await<boolean>}
   */ verify(payload, signature) {
        return this.key.verify(payload, signature);
    }
    /**
   * @template {API.DID} ID
   * @param {ID} id
   */ withDID(id) {
        return withDID(this.key, id);
    }
}
}),
"[project]/node_modules/@ucanto/principal/src/ed25519/verifier.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "code",
    ()=>code,
    "decode",
    ()=>decode,
    "encode",
    ()=>encode,
    "format",
    ()=>format,
    "name",
    ()=>name,
    "or",
    ()=>or,
    "parse",
    ()=>parse,
    "signatureAlgorithm",
    ()=>signatureAlgorithm,
    "signatureCode",
    ()=>signatureCode
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/did.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ed25519$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/ed25519/lib/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/varint.js [app-client] (ecmascript) <export * as varint>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/ed25519/type.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$signature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/signature.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base58.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$verifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/verifier.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
const code = 0xed;
const name = 'Ed25519';
const signatureCode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$signature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EdDSA"];
const signatureAlgorithm = 'EdDSA';
const PUBLIC_TAG_SIZE = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(code);
const SIZE = 32 + PUBLIC_TAG_SIZE;
const parse = (did)=>decode(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parse"](did));
const decode = (bytes)=>{
    const [algorithm] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].decode(bytes);
    if (algorithm !== code) {
        throw new RangeError(`Unsupported key algorithm with multicode 0x${code.toString(16)}`);
    } else if (bytes.byteLength !== SIZE) {
        throw new RangeError(`Expected Uint8Array with byteLength ${SIZE}, instead got Uint8Array with byteLength ${bytes.byteLength}`);
    } else {
        return new Ed25519Verifier(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    }
};
const format = (principal)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["format"](principal);
const encode = (principal)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"](principal);
/**
 * @implements {API.EdVerifier}
 */ class Ed25519Verifier extends Uint8Array {
    /** @type {typeof code} */ get code() {
        return code;
    }
    /** @type {typeof signatureCode} */ get signatureCode() {
        return signatureCode;
    }
    /** @type {typeof signatureAlgorithm} */ get signatureAlgorithm() {
        return signatureAlgorithm;
    }
    /**
   * Raw public key without a multiformat code.
   *
   * @readonly
   */ get publicKey() {
        const key = new Uint8Array(this.buffer, this.byteOffset + PUBLIC_TAG_SIZE);
        Object.defineProperties(this, {
            publicKey: {
                value: key
            }
        });
        return key;
    }
    /**
   * DID of the Principal in `did:key` format.
   * @returns {API.DID<"key">}
   */ did() {
        return `did:key:${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base58btc"].encode(this)}`;
    }
    /**
   * @template T
   * @param {API.ByteView<T>} payload
   * @param {API.Signature<T, Signature.EdDSA>} signature
   * @returns {API.Await<boolean>}
   */ verify(payload, signature) {
        return signature.code === signatureCode && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ed25519$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["verify"](signature.raw, payload, this.publicKey);
    }
    /**
   * @template {API.DID} ID
   * @param {ID} id
   * @returns {API.Verifier<ID, typeof signatureCode>}
   */ withDID(id) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$verifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withDID"](this, id);
    }
    toDIDKey() {
        return this.did();
    }
}
const or = (other)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$verifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"]({
        parse
    }, other);
}),
"[project]/node_modules/@ucanto/principal/src/signer.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "or",
    ()=>or,
    "withDID",
    ()=>withDID
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$interface$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/interface/src/lib.js [app-client] (ecmascript)");
;
const or = (left, right)=>new Importer([
        left,
        right
    ]);
/**
 * @template {[API.SignerImporter, ...API.SignerImporter[]]} Importers
 * @implements {API.CompositeImporter<Importers>}
 */ class Importer {
    /**
   * @param {Importers} variants
   */ constructor(variants){
        this.variants = variants;
        this.from = create(variants);
    }
    /**
   * @template {API.SignerImporter} Other
   * @param {Other} other
   * @returns {API.CompositeImporter<[Other, ...Importers]>}
   */ or(other) {
        return new Importer([
            other,
            ...this.variants
        ]);
    }
}
/**
 * @template {[API.SignerImporter, ...API.SignerImporter[]]} Importers
 * @param {Importers} importers
 */ const create = (importers)=>{
    /**
   * @template {API.DID} ID - DID that can be imported, which may be a type union.
   * @template {API.SigAlg} Alg - Multicodec code corresponding to signature algorithm.
   * @param {API.SignerArchive<ID, Alg>} archive
   * @returns {API.Signer<ID, Alg>}
   */ const from = (archive)=>{
        if (archive.id.startsWith('did:key:')) {
            return importWith(archive, importers);
        } else {
            for (const [name, key] of Object.entries(archive.keys)){
                const id = name;
                const signer = importWith({
                    id,
                    keys: {
                        [id]: key
                    }
                }, importers);
                return signer.withDID(archive.id);
            }
            throw new Error(`Archive ${archive.id} contains no keys`);
        }
    };
    return from;
};
/**
 * @param {API.SignerArchive} archive
 * @param {API.SignerImporter[]} importers
 * @returns {API.Signer}
 */ const importWith = (archive, importers)=>{
    for (const importer of importers){
        try {
            return importer.from(archive);
        } catch (_) {}
    }
    throw new Error(`Unsupported signer`);
};
const withDID = ({ signer, verifier }, id)=>new SignerWithDID(signer, verifier.withDID(id));
/**
 * @template {API.DID} ID
 * @template {number} Code
 * @implements {API.Signer<ID, Code>}
 */ class SignerWithDID {
    /**
   * @param {API.Signer<API.DID<'key'>, Code>} key
   * @param {API.Verifier<ID, Code>} verifier
   */ constructor(key, verifier){
        this.key = key;
        this.verifier = verifier;
    }
    /** @type {API.Signer<ID, Code>} */ get signer() {
        return this;
    }
    get signatureAlgorithm() {
        return this.key.signatureAlgorithm;
    }
    get signatureCode() {
        return this.key.signatureCode;
    }
    /**
   * @returns {ID}
   */ did() {
        return this.verifier.did();
    }
    toDIDKey() {
        return this.verifier.toDIDKey();
    }
    /**
   * @template {API.DID} ID
   * @param {ID} id
   */ withDID(id) {
        return withDID(this.key, id);
    }
    /**
   * @template T
   * @param {API.ByteView<T>} payload
   */ sign(payload) {
        return this.key.sign(payload);
    }
    /**
   * @template T
   * @param {API.ByteView<T>} payload
   * @param {API.Signature<T, Code>} signature
   */ verify(payload, signature) {
        return this.verifier.verify(payload, signature);
    }
    toArchive() {
        const { keys } = this.key.toArchive();
        return {
            id: this.did(),
            keys
        };
    }
}
}),
"[project]/node_modules/@ucanto/principal/src/ed25519/signer.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PUB_KEY_OFFSET",
    ()=>PUB_KEY_OFFSET,
    "code",
    ()=>code,
    "decode",
    ()=>decode,
    "derive",
    ()=>derive,
    "encode",
    ()=>encode,
    "format",
    ()=>format,
    "from",
    ()=>from,
    "generate",
    ()=>generate,
    "name",
    ()=>name,
    "or",
    ()=>or,
    "parse",
    ()=>parse,
    "signatureAlgorithm",
    ()=>signatureAlgorithm,
    "signatureCode",
    ()=>signatureCode
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ed25519$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/ed25519/lib/esm/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/varint.js [app-client] (ecmascript) <export * as varint>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/ed25519/type.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$verifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/ed25519/verifier.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base64.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$signature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/signature.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/signer.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
const code = 0x1300;
const name = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$verifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["name"];
const signatureAlgorithm = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$verifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["signatureAlgorithm"];
const signatureCode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$verifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["signatureCode"];
const PRIVATE_TAG_SIZE = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(code);
const PUBLIC_TAG_SIZE = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$verifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["code"]);
const KEY_SIZE = 32;
const SIZE = PRIVATE_TAG_SIZE + KEY_SIZE + PUBLIC_TAG_SIZE + KEY_SIZE;
const PUB_KEY_OFFSET = PRIVATE_TAG_SIZE + KEY_SIZE;
const generate = ()=>derive(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ed25519$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["utils"].randomPrivateKey());
const derive = async (secret)=>{
    if (secret.byteLength !== KEY_SIZE) {
        throw new Error(`Expected Uint8Array with byteLength of ${KEY_SIZE} instead not ${secret.byteLength}`);
    }
    const publicKey = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ed25519$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getPublicKey"](secret);
    const signer = new Ed25519Signer(SIZE);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodeTo(code, signer, 0);
    signer.set(secret, PRIVATE_TAG_SIZE);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodeTo(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$verifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["code"], signer, PRIVATE_TAG_SIZE + KEY_SIZE);
    signer.set(publicKey, PRIVATE_TAG_SIZE + KEY_SIZE + PUBLIC_TAG_SIZE);
    return signer;
};
const from = ({ id, keys })=>{
    if (id.startsWith('did:key:')) {
        const key = keys[id];
        if (key instanceof Uint8Array) {
            return decode(key);
        }
    }
    throw new TypeError(`Unsupported archive format`);
};
const or = (other)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"]({
        from
    }, other);
const decode = (bytes)=>{
    if (bytes.byteLength !== SIZE) {
        throw new Error(`Expected Uint8Array with byteLength of ${SIZE} instead not ${bytes.byteLength}`);
    }
    {
        const [keyCode] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].decode(bytes);
        if (keyCode !== code) {
            throw new Error(`Given bytes must be a multiformat with ${code} tag`);
        }
    }
    {
        const [code] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].decode(bytes.subarray(PUB_KEY_OFFSET));
        if (code !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$verifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["code"]) {
            throw new Error(`Given bytes must contain public key in multiformats with ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$verifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["code"]} tag`);
        }
    }
    return new Ed25519Signer(bytes);
};
const encode = (signer)=>signer.encode();
const format = (signer, encoder)=>(encoder || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64pad"]).encode(encode(signer));
const parse = (principal, decoder)=>decode((decoder || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64pad"]).decode(principal));
/**
 * @implements {API.EdSigner}
 */ class Ed25519Signer extends Uint8Array {
    /** @type {typeof code} */ get code() {
        return code;
    }
    get signer() {
        return this;
    }
    /** @type {API.EdVerifier} */ get verifier() {
        const bytes = new Uint8Array(this.buffer, PRIVATE_TAG_SIZE + KEY_SIZE);
        const verifier = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$verifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](bytes);
        Object.defineProperties(this, {
            verifier: {
                value: verifier
            }
        });
        return verifier;
    }
    /**
   * Raw public key without multiformat code.
   */ get secret() {
        const secret = new Uint8Array(this.buffer, PRIVATE_TAG_SIZE, KEY_SIZE);
        Object.defineProperties(this, {
            secret: {
                value: secret
            }
        });
        return secret;
    }
    /**
   * DID of this principal in `did:key` format.
   */ did() {
        return this.verifier.did();
    }
    toDIDKey() {
        return this.verifier.toDIDKey();
    }
    /**
   * @template {API.DID} ID
   * @param {ID} id
   * @returns {API.Signer<ID, typeof Signature.EdDSA>}
   */ withDID(id) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withDID"](this, id);
    }
    /**
   * @template T
   * @param {API.ByteView<T>} payload
   * @returns {Promise<API.SignatureView<T, typeof Signature.EdDSA>>}
   */ async sign(payload) {
        const raw = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$ed25519$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sign"](payload, this.secret);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$signature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"](this.signatureCode, raw);
    }
    /**
   * @template T
   * @param {API.ByteView<T>} payload
   * @param {API.Signature<T, typeof this.signatureCode>} signature
   */ verify(payload, signature) {
        return this.verifier.verify(payload, signature);
    }
    get signatureAlgorithm() {
        return signatureAlgorithm;
    }
    get signatureCode() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$signature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EdDSA"];
    }
    encode() {
        return this;
    }
    toArchive() {
        const id = this.did();
        return {
            id,
            keys: {
                [id]: this.encode()
            }
        };
    }
}
}),
"[project]/node_modules/@ucanto/principal/src/ed25519.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/ed25519/signer.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$verifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/ed25519/verifier.js [app-client] (ecmascript)");
;
;
;
}),
"[project]/node_modules/@ucanto/principal/src/ed25519/signer.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PUB_KEY_OFFSET",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["PUB_KEY_OFFSET"],
    "code",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["code"],
    "decode",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["decode"],
    "derive",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["derive"],
    "encode",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encode"],
    "format",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["format"],
    "from",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["from"],
    "generate",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["generate"],
    "name",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["name"],
    "or",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["or"],
    "parse",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["parse"],
    "signatureAlgorithm",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["signatureAlgorithm"],
    "signatureCode",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["signatureCode"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/ed25519/signer.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/ed25519/type.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@ucanto/principal/src/ed25519.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "PUB_KEY_OFFSET",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PUB_KEY_OFFSET"],
    "Signer",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    "Verifier",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$verifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    "code",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["code"],
    "decode",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"],
    "derive",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["derive"],
    "encode",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"],
    "format",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["format"],
    "from",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"],
    "generate",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["generate"],
    "name",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["name"],
    "or",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"],
    "parse",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parse"],
    "signatureAlgorithm",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["signatureAlgorithm"],
    "signatureCode",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["signatureCode"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/ed25519.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/ed25519/signer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$verifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/ed25519/verifier.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@ucanto/principal/src/ed25519/verifier.js [app-client] (ecmascript) <export * as Verifier>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Verifier",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$verifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$verifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/ed25519/verifier.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@ucanto/principal/src/rsa/type.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
}),
"[project]/node_modules/@ucanto/principal/src/multiformat.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "decode",
    ()=>decode,
    "encodeTo",
    ()=>encodeTo,
    "encodingLength",
    ()=>encodingLength,
    "tagWith",
    ()=>tagWith,
    "untagWith",
    ()=>untagWith
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/varint.js [app-client] (ecmascript) <export * as varint>");
;
const tagWith = (code, bytes)=>{
    const offset = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(code);
    const multiformat = new Uint8Array(bytes.byteLength + offset);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodeTo(code, multiformat, 0);
    multiformat.set(bytes, offset);
    return multiformat;
};
const untagWith = (code, source, byteOffset = 0)=>{
    const bytes = byteOffset !== 0 ? source.subarray(byteOffset) : source;
    const [tag, size] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].decode(bytes);
    if (tag !== code) {
        throw new Error(`Expected multiformat with 0x${code.toString(16)} tag instead got 0x${tag.toString(16)}`);
    } else {
        return new Uint8Array(bytes.buffer, bytes.byteOffset + size);
    }
};
const encodingLength = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength;
const encodeTo = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodeTo;
const decode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].decode;
}),
"[project]/node_modules/@ucanto/principal/src/rsa/asn1.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * ASN1 Tags as per https://luca.ntop.org/Teaching/Appunti/asn1.html
 */ __turbopack_context__.s([
    "BITSTRING_TAG",
    ()=>BITSTRING_TAG,
    "INT_TAG",
    ()=>INT_TAG,
    "NULL_TAG",
    ()=>NULL_TAG,
    "OBJECT_TAG",
    ()=>OBJECT_TAG,
    "OCTET_STRING_TAG",
    ()=>OCTET_STRING_TAG,
    "SEQUENCE_TAG",
    ()=>SEQUENCE_TAG,
    "UNUSED_BIT_PAD",
    ()=>UNUSED_BIT_PAD,
    "encodeBitString",
    ()=>encodeBitString,
    "encodeDERLength",
    ()=>encodeDERLength,
    "encodeInt",
    ()=>encodeInt,
    "encodeOctetString",
    ()=>encodeOctetString,
    "encodeSequence",
    ()=>encodeSequence,
    "enterSequence",
    ()=>enterSequence,
    "into",
    ()=>into,
    "readBitString",
    ()=>readBitString,
    "readDERLength",
    ()=>readDERLength,
    "readInt",
    ()=>readInt,
    "readOctetString",
    ()=>readOctetString,
    "readSequence",
    ()=>readSequence,
    "readSequenceWith",
    ()=>readSequenceWith,
    "skip",
    ()=>skip,
    "skipInt",
    ()=>skipInt,
    "skipSequence",
    ()=>skipSequence
]);
const TAG_SIZE = 1;
const INT_TAG = 0x02;
const BITSTRING_TAG = 0x03;
const OCTET_STRING_TAG = 0x04;
const NULL_TAG = 0x05;
const OBJECT_TAG = 0x06;
const SEQUENCE_TAG = 0x30;
const UNUSED_BIT_PAD = 0x00;
const encodeDERLength = (length)=>{
    if (length <= 127) {
        return new Uint8Array([
            length
        ]);
    }
    /** @type {number[]} */ const octets = [];
    while(length !== 0){
        octets.push(length & 0xff);
        length = length >>> 8;
    }
    octets.reverse();
    return new Uint8Array([
        0x80 | octets.length & 0xff,
        ...octets
    ]);
};
const readDERLength = (bytes, offset = 0)=>{
    if ((bytes[offset] & 0x80) === 0) {
        return {
            number: bytes[offset],
            consumed: 1
        };
    }
    const numberBytes = bytes[offset] & 0x7f;
    /* c8 ignore next 5 */ if (bytes.length < numberBytes + 1) {
        throw new Error(`ASN parsing error: Too few bytes. Expected encoded length's length to be at least ${numberBytes}`);
    }
    let length = 0;
    for(let i = 0; i < numberBytes; i++){
        length = length << 8;
        length = length | bytes[offset + i + 1];
    }
    return {
        number: length,
        consumed: numberBytes + 1
    };
};
const skip = (input, expectedTag, position)=>{
    const parsed = into(input, expectedTag, position);
    return parsed.position + parsed.length;
};
const into = (input, expectedTag, offset)=>{
    const actualTag = input[offset];
    /* c8 ignore next 7 */ if (actualTag !== expectedTag) {
        throw new Error(`ASN parsing error: Expected tag 0x${expectedTag.toString(16)} at position ${offset}, but got 0x${actualTag.toString(16)}.`);
    }
    // length
    const length = readDERLength(input, offset + TAG_SIZE);
    const position = offset + TAG_SIZE + length.consumed;
    // content
    return {
        position,
        length: length.number
    };
};
const encodeBitString = (input)=>{
    // encode input length + 1 for unused bit pad
    const length = encodeDERLength(input.byteLength + 1);
    // allocate a buffer of desired size
    const bytes = new Uint8Array(TAG_SIZE + // ASN_BITSTRING_TAG
    length.byteLength + 1 + // amount of unused bits at the end of our bitstring
    input.byteLength);
    let byteOffset = 0;
    // write bytestring tag
    bytes[byteOffset] = BITSTRING_TAG;
    byteOffset += TAG_SIZE;
    // write length of the bytestring
    bytes.set(length, byteOffset);
    byteOffset += length.byteLength;
    // write unused bits at the end of our bitstring
    bytes[byteOffset] = UNUSED_BIT_PAD;
    byteOffset += 1;
    // write actual data into bitstring
    bytes.set(input, byteOffset);
    return bytes;
};
const encodeOctetString = (input)=>{
    // encode input length
    const length = encodeDERLength(input.byteLength);
    // allocate a buffer of desired size
    const bytes = new Uint8Array(TAG_SIZE + length.byteLength + input.byteLength);
    let byteOffset = 0;
    // write octet string tag
    bytes[byteOffset] = OCTET_STRING_TAG;
    byteOffset += TAG_SIZE;
    // write octet string length
    bytes.set(length, byteOffset);
    byteOffset += length.byteLength;
    // write actual data into bitstring
    bytes.set(input, byteOffset);
    return bytes;
};
const encodeSequence = (sequence)=>{
    // calculate bytelength for all the parts
    let byteLength = 0;
    for (const item of sequence){
        byteLength += item.byteLength;
    }
    // encode sequence byte length
    const length = encodeDERLength(byteLength);
    // allocate the buffer to write sequence into
    const bytes = new Uint8Array(TAG_SIZE + length.byteLength + byteLength);
    let byteOffset = 0;
    // write the sequence tag
    bytes[byteOffset] = SEQUENCE_TAG;
    byteOffset += TAG_SIZE;
    // write sequence length
    bytes.set(length, byteOffset);
    byteOffset += length.byteLength;
    // write each item in the sequence
    for (const item of sequence){
        bytes.set(item, byteOffset);
        byteOffset += item.byteLength;
    }
    return bytes;
};
const readSequence = (bytes, offset = 0)=>{
    const { position, length } = into(bytes, SEQUENCE_TAG, offset);
    return new Uint8Array(bytes.buffer, bytes.byteOffset + position, length);
};
const encodeInt = (input)=>{
    const extra = input.byteLength === 0 || input[0] & 0x80 ? 1 : 0;
    // encode input length
    const length = encodeDERLength(input.byteLength + extra);
    // allocate a buffer of desired size
    const bytes = new Uint8Array(TAG_SIZE + // INT_TAG
    length.byteLength + input.byteLength + extra);
    let byteOffset = 0;
    // write octet string tag
    bytes[byteOffset] = INT_TAG;
    byteOffset += TAG_SIZE;
    // write int length
    bytes.set(length, byteOffset);
    byteOffset += length.byteLength;
    // add 0 if the most-significant bit is set
    if (extra > 0) {
        bytes[byteOffset] = UNUSED_BIT_PAD;
        byteOffset += extra;
    }
    // write actual data into bitstring
    bytes.set(input, byteOffset);
    return bytes;
};
const enterSequence = (bytes, offset = 0)=>into(bytes, SEQUENCE_TAG, offset).position;
const skipSequence = (bytes, offset = 0)=>skip(bytes, SEQUENCE_TAG, offset);
const skipInt = (bytes, offset = 0)=>skip(bytes, INT_TAG, offset);
const readBitString = (bytes, offset = 0)=>{
    const { position, length } = into(bytes, BITSTRING_TAG, offset);
    const tag = bytes[position];
    /* c8 ignore next 5 */ if (tag !== UNUSED_BIT_PAD) {
        throw new Error(`Can not read bitstring, expected length to be multiple of 8, but got ${tag} unused bits in last byte.`);
    }
    return new Uint8Array(bytes.buffer, bytes.byteOffset + position + 1, length - 1);
};
const readInt = (bytes, byteOffset = 0)=>{
    const { position, length } = into(bytes, INT_TAG, byteOffset);
    let delta = 0;
    // drop leading 0s
    while(bytes[position + delta] === 0){
        delta++;
    }
    return new Uint8Array(bytes.buffer, bytes.byteOffset + position + delta, length - delta);
};
const readOctetString = (bytes, offset = 0)=>{
    const { position, length } = into(bytes, OCTET_STRING_TAG, offset);
    return new Uint8Array(bytes.buffer, bytes.byteOffset + position, length);
};
const readSequenceWith = (readers, source, byteOffset = 0)=>{
    const results = [];
    const sequence = readSequence(source, byteOffset);
    let offset = 0;
    for (const read of readers){
        const chunk = read(sequence, offset);
        results.push(chunk);
        offset = chunk.byteOffset + chunk.byteLength - sequence.byteOffset;
    }
    return results;
};
}),
"[project]/node_modules/@ucanto/principal/src/rsa/spki.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "SPKI_PARAMS_ENCODED",
    ()=>SPKI_PARAMS_ENCODED,
    "decode",
    ()=>decode,
    "encode",
    ()=>encode
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$interface$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/interface/src/lib.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/rsa/asn1.js [app-client] (ecmascript)");
;
;
const SPKI_PARAMS_ENCODED = new Uint8Array([
    48,
    13,
    6,
    9,
    42,
    134,
    72,
    134,
    247,
    13,
    1,
    1,
    1,
    5,
    0
]);
const encode = (key)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeSequence"])([
        SPKI_PARAMS_ENCODED,
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeBitString"])(key)
    ]);
const decode = (info)=>{
    // go into the top-level SEQUENCE
    const offset = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["enterSequence"])(info, 0);
    // skip the header we expect (SKPI_PARAMS_ENCODED)
    const keyOffset = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["skipSequence"])(info, offset);
    // we expect the bitstring next
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readBitString"])(info, keyOffset);
};
}),
"[project]/node_modules/@ucanto/principal/src/rsa/pkcs8.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "decode",
    ()=>decode,
    "encode",
    ()=>encode
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$interface$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/interface/src/lib.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base64.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/rsa/asn1.js [app-client] (ecmascript)");
;
;
;
const PKSC8_HEADER = new Uint8Array([
    // version
    2,
    1,
    0,
    // privateKeyAlgorithm
    48,
    13,
    6,
    9,
    42,
    134,
    72,
    134,
    247,
    13,
    1,
    1,
    1,
    5,
    0
]);
const decode = (info)=>{
    let offset = 0;
    // go into the top-level SEQUENCE
    offset = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["enterSequence"])(info, offset);
    offset = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["skipInt"])(info, offset);
    offset = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["skipSequence"])(info, offset);
    // we expect the bitstring next
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readOctetString"])(info, offset);
};
const encode = (key)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeSequence"])([
        PKSC8_HEADER,
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeOctetString"])(key)
    ]);
}),
"[project]/node_modules/@ucanto/principal/src/rsa/public-key.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "decode",
    ()=>decode,
    "encode",
    ()=>encode,
    "fromJWK",
    ()=>fromJWK,
    "fromSPKI",
    ()=>fromSPKI,
    "toJWK",
    ()=>toJWK,
    "toSPKI",
    ()=>toSPKI
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$interface$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/interface/src/lib.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/rsa/asn1.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$spki$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/rsa/spki.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base64.js [app-client] (ecmascript)");
;
;
;
;
const decode = (key, byteOffset = 0)=>{
    const [n, e] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readSequenceWith"])([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readInt"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readInt"]
    ], key, byteOffset);
    return {
        n,
        e
    };
};
const encode = ({ n, e })=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeSequence"])([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeInt"])(n),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeInt"])(e)
    ]);
const toSPKI = (key)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$spki$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"](encode(key));
const fromSPKI = (info)=>decode(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$spki$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](info));
const toJWK = ({ n, e })=>({
        kty: 'RSA',
        alg: 'RS256',
        key_ops: [
            'verify'
        ],
        ext: true,
        n: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64url"].baseEncode(n),
        e: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64url"].baseEncode(e)
    });
const fromJWK = ({ n, e })=>({
        n: base64urlDecode(n),
        e: base64urlDecode(e)
    });
/**
 * @param {string|undefined} input
 */ const base64urlDecode = (input = '')=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64url"].baseDecode(input);
}),
"[project]/node_modules/@ucanto/principal/src/rsa/private-key.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "code",
    ()=>code,
    "decode",
    ()=>decode,
    "encode",
    ()=>encode,
    "fromJWK",
    ()=>fromJWK,
    "fromPKCS8",
    ()=>fromPKCS8,
    "toJWK",
    ()=>toJWK,
    "toPKCS8",
    ()=>toPKCS8,
    "toSPKI",
    ()=>toSPKI
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$interface$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/interface/src/lib.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/rsa/asn1.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base64.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$pkcs8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/rsa/pkcs8.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$spki$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/rsa/spki.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$public$2d$key$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/rsa/public-key.js [app-client] (ecmascript)");
;
;
;
;
;
;
const code = 0x1305;
const VERSION = new Uint8Array();
const decode = (source, byteOffset = 0)=>{
    const [v, n, e, d, p, q, dp, dq, qi] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readSequenceWith"])([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readInt"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readInt"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readInt"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readInt"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readInt"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readInt"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readInt"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readInt"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readInt"]
    ], source, byteOffset);
    return {
        v,
        n,
        e,
        d,
        p,
        q,
        dp,
        dq,
        qi
    };
};
const encode = ({ v, n, e, d, p, q, dp, dq, qi })=>{
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeSequence"])([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeInt"])(v),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeInt"])(n),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeInt"])(e),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeInt"])(d),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeInt"])(p),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeInt"])(q),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeInt"])(dp),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeInt"])(dq),
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$asn1$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeInt"])(qi)
    ]);
};
const toJWK = ({ n, e, d, p, q, dp, dq, qi })=>({
        kty: 'RSA',
        alg: 'RS256',
        key_ops: [
            'sign'
        ],
        ext: true,
        n: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64url"].baseEncode(n),
        e: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64url"].baseEncode(e),
        d: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64url"].baseEncode(d),
        p: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64url"].baseEncode(p),
        q: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64url"].baseEncode(q),
        dp: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64url"].baseEncode(dp),
        dq: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64url"].baseEncode(dq),
        qi: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64url"].baseEncode(qi)
    });
const fromJWK = ({ n, e, d, p, q, dp, dq, qi })=>({
        v: VERSION,
        n: base64urlDecode(n),
        e: base64urlDecode(e),
        d: base64urlDecode(d),
        p: base64urlDecode(p),
        q: base64urlDecode(q),
        dp: base64urlDecode(dp),
        dq: base64urlDecode(dq),
        qi: base64urlDecode(qi)
    });
const toPKCS8 = (key)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$pkcs8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"](encode(key));
const fromPKCS8 = (info)=>decode(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$pkcs8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](info));
const toSPKI = (key)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$spki$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$public$2d$key$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"](key));
/**
 *
 * @param {string|undefined} input
 * @returns
 */ const base64urlDecode = (input = '')=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64url"].baseDecode(input);
}),
"[project]/node_modules/@ucanto/principal/src/rsa.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Verifier",
    ()=>RSAVerifier,
    "code",
    ()=>code,
    "decode",
    ()=>decode,
    "from",
    ()=>from,
    "generate",
    ()=>generate,
    "name",
    ()=>name,
    "or",
    ()=>or,
    "signatureAlgorithm",
    ()=>signatureAlgorithm,
    "signatureCode",
    ()=>signatureCode
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$one$2d$webcrypto$2f$browser$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/one-webcrypto/browser.mjs [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base58.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/rsa/type.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/did.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$multiformat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/multiformat.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$signature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/signature.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$spki$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/rsa/spki.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$pkcs8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/rsa/pkcs8.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$private$2d$key$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/rsa/private-key.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$public$2d$key$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/rsa/public-key.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$verifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/verifier.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/signer.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
;
;
const name = 'RSA';
const code = 0x1305;
/** @type {API.RSAVerifier['code']} */ const verifierCode = 0x1205;
const signatureCode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$signature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["RS256"];
const signatureAlgorithm = 'RS256';
const ALG = 'RSASSA-PKCS1-v1_5';
const HASH_ALG = 'SHA-256';
const KEY_SIZE = 2048;
const SALT_LENGTH = 128;
const IMPORT_PARAMS = {
    name: ALG,
    hash: {
        name: HASH_ALG
    }
};
const generate = async ({ size = KEY_SIZE, extractable = false } = {})=>{
    // We start by generate an RSA keypair using web crypto API.
    const { publicKey, privateKey } = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$one$2d$webcrypto$2f$browser$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["webcrypto"].subtle.generateKey({
        name: ALG,
        modulusLength: size,
        publicExponent: new Uint8Array([
            0x01,
            0x00,
            0x01
        ]),
        hash: {
            name: HASH_ALG
        }
    }, extractable, [
        'sign',
        'verify'
    ]);
    // Next we need to encode public key, because `RSAVerifier` uses it to
    // for implementing a `did()` method. To do this we first export
    // Subject Public Key Info (SPKI) using web crypto API.
    const spki = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$one$2d$webcrypto$2f$browser$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["webcrypto"].subtle.exportKey('spki', publicKey);
    // Then we extract public key from the SPKI and tag it with RSA public key
    // multicode
    const publicBytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$multiformat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["tagWith"])(verifierCode, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$spki$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](new Uint8Array(spki)));
    // Now that we have publicKey and it's multiformat representation we can
    // create a verifier.
    const verifier = new RSAVerifier({
        bytes: publicBytes,
        publicKey
    });
    // If we generated non extractable key we just wrap actual keys and verifier
    // in the RSASigner view.
    if (!extractable) {
        return new UnextractableRSASigner({
            privateKey,
            verifier
        });
    } else {
        const pkcs8 = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$one$2d$webcrypto$2f$browser$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["webcrypto"].subtle.exportKey('pkcs8', privateKey);
        const bytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$multiformat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["tagWith"])(code, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$pkcs8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](new Uint8Array(pkcs8)));
        return new ExtractableRSASigner({
            privateKey,
            bytes,
            verifier
        });
    }
};
const from = ({ id, keys })=>{
    if (id.startsWith('did:key:')) {
        const did = id;
        const key = keys[did];
        if (key instanceof Uint8Array) {
            return decode(key);
        } else {
            return new UnextractableRSASigner({
                privateKey: key,
                verifier: RSAVerifier.parse(did)
            });
        }
    } else {
        throw new TypeError(`RSA can not import from ${id} archive, try generic Signer instead`);
    }
};
const or = (other)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"]({
        from
    }, other);
const decode = (bytes)=>{
    // First we decode RSA key data from the private key with multicode tag.
    const rsa = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$private$2d$key$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$multiformat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["untagWith"])(code, bytes));
    // Then we encode RSA key data as public key with multicode tag.
    const publicBytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$multiformat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["tagWith"])(verifierCode, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$public$2d$key$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"](rsa));
    return new ExtractableRSASigner({
        bytes,
        privateKey: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$one$2d$webcrypto$2f$browser$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["webcrypto"].subtle.importKey('pkcs8', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$pkcs8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$multiformat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["untagWith"])(code, bytes)), IMPORT_PARAMS, true, [
            'sign'
        ]),
        verifier: RSAVerifier.decode(publicBytes)
    });
};
/**
 * @implements {API.RSAVerifier}
 */ class RSAVerifier {
    /**
   * @param {object} options
   * @param {API.Await<CryptoKey>} options.publicKey
   * @param {API.ByteView<API.RSAVerifier>} options.bytes
   */ constructor({ publicKey, bytes }){
        /** @private */ this.publicKey = publicKey;
        /** @private */ this.bytes = bytes;
    }
    /**
   * @template {API.DID} ID
   * @param {ID} id
   * @returns {API.Verifier<ID, typeof signatureCode>}
   */ withDID(id) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$verifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withDID"](this, id);
    }
    toDIDKey() {
        return this.did();
    }
    /**
   * @param {API.ByteView<API.RSAVerifier>} bytes
   * @returns {API.RSAVerifier}
   */ static decode(bytes) {
        return new this({
            bytes,
            publicKey: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$one$2d$webcrypto$2f$browser$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["webcrypto"].subtle.importKey('spki', __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$spki$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$multiformat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["untagWith"])(verifierCode, bytes)), IMPORT_PARAMS, true, [
                'verify'
            ])
        });
    }
    /**
   * @param {API.DIDKey} did
   * @returns {API.RSAVerifier}
   */ static parse(did) {
        return RSAVerifier.decode(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parse"](did));
    }
    /**
   * @param {API.PrincipalParser} other
   */ static or(other) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$verifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"](this, other);
    }
    /** @type {typeof verifierCode} */ get code() {
        return verifierCode;
    }
    /**
   * @type {typeof signatureCode}
   */ get signatureCode() {
        return signatureCode;
    }
    /**
   * @type {typeof signatureAlgorithm}
   */ get signatureAlgorithm() {
        return signatureAlgorithm;
    }
    /**
   * DID of the Principal in `did:key` format.
   * @returns {API.DID<"key">}
   */ did() {
        return `did:key:${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base58btc"].encode(this.bytes)}`;
    }
    /**
   * @template T
   * @param {API.ByteView<T>} payload
   * @param {API.Signature<T, typeof this.signatureCode>} signature
   * @returns {Promise<boolean>}
   */ async verify(payload, signature) {
        // if signature code does not match RS256 it's not signed by corresponding
        // signer.
        if (signature.code !== signatureCode) {
            return false;
        }
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$one$2d$webcrypto$2f$browser$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["webcrypto"].subtle.verify({
            name: ALG,
            hash: {
                name: HASH_ALG
            }
        }, await this.publicKey, signature.raw, payload);
    }
}
const RSAVerifier$ = RSAVerifier;
;
/**
 * @typedef {API.ByteView<API.Signer<API.DID<'key'>, typeof signatureCode> & CryptoKey>} EncodedSigner
 */ class RSASigner {
    /**
   * @param {object} options
   * @param {API.Await<CryptoKey>} options.privateKey
   * @param {API.RSAVerifier} options.verifier
   */ constructor({ privateKey, verifier }){
        /** @readonly */ this.verifier = verifier;
        /** @protected */ this.privateKey = privateKey;
    }
    get signer() {
        return this;
    }
    /**
   * @type {typeof code}
   */ get code() {
        return code;
    }
    /**
   * @type {typeof signatureCode}
   */ get signatureCode() {
        return signatureCode;
    }
    /**
   * @type {typeof signatureAlgorithm}
   */ get signatureAlgorithm() {
        return signatureAlgorithm;
    }
    did() {
        return this.verifier.did();
    }
    toDIDKey() {
        return this.verifier.toDIDKey();
    }
    /**
   * @template T
   * @param {API.ByteView<T>} payload
   * @param {API.Signature<T, typeof this.signatureCode>} signature
   */ verify(payload, signature) {
        return this.verifier.verify(payload, signature);
    }
    /**
   * @template T
   * @param {API.ByteView<T>} payload
   * @returns {Promise<API.SignatureView<T, typeof signatureCode>>}
   */ async sign(payload) {
        const buffer = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$one$2d$webcrypto$2f$browser$2e$mjs__$5b$app$2d$client$5d$__$28$ecmascript$29$__["webcrypto"].subtle.sign({
            name: ALG,
            saltLength: SALT_LENGTH
        }, await this.privateKey, payload);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$signature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"](signatureCode, new Uint8Array(buffer));
    }
}
/**
 * @implements {API.RSASigner}
 */ class ExtractableRSASigner extends RSASigner {
    /**
   * @param {object} options
   * @param {API.Await<CryptoKey>} options.privateKey
   * @param {EncodedSigner} options.bytes
   * @param {API.RSAVerifier} options.verifier
   */ constructor(options){
        super(options);
        this.bytes = options.bytes;
    }
    /**
   * @template {API.DID} ID
   * @param {ID} id
   * @returns {API.Signer<ID, typeof signatureCode>}
   */ withDID(id) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withDID"](this, id);
    }
    toArchive() {
        const id = this.did();
        return {
            id,
            keys: {
                [id]: this.bytes
            }
        };
    }
}
/**
 * @implements {API.RSASigner}
 */ class UnextractableRSASigner extends RSASigner {
    /**
   * @param {object} options
   * @param {CryptoKey} options.privateKey
   * @param {API.RSAVerifier} options.verifier
   */ constructor(options){
        super(options);
        this.privateKey = options.privateKey;
    }
    /**
   * @template {API.DID} ID
   * @param {ID} id
   * @returns {API.Signer<ID, typeof signatureCode>}
   */ withDID(id) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["withDID"](this, id);
    }
    toArchive() {
        const id = this.did();
        return {
            id,
            keys: {
                [id]: this.privateKey
            }
        };
    }
}
}),
"[project]/node_modules/@ucanto/principal/src/rsa.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Verifier",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["Verifier"],
    "code",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["code"],
    "decode",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["decode"],
    "from",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["from"],
    "generate",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["generate"],
    "name",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["name"],
    "or",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["or"],
    "signatureAlgorithm",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["signatureAlgorithm"],
    "signatureCode",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["signatureCode"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/rsa.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2f$type$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/rsa/type.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@ucanto/principal/src/absentee.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "from",
    ()=>from
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$signature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/signature.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/lib.js [app-client] (ecmascript) <locals>");
;
;
const from = ({ id })=>new Absentee(id);
/**
 * An absentee is a special type of signer that produces an absent signature,
 * which signals that verifier needs to verify authorization interactively.
 *
 * @template {UCAN.DID} ID
 * @implements {UCAN.Signer<ID, Signature.NON_STANDARD>}
 */ class Absentee {
    /**
   * @param {ID} id
   */ constructor(id){
        this.id = id;
    }
    did() {
        return this.id;
    }
    /* c8 ignore next 3 */ get signatureCode() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$signature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NON_STANDARD"];
    }
    get signatureAlgorithm() {
        return '';
    }
    sign() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$signature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createNonStandard"](this.signatureAlgorithm, new Uint8Array(0));
    }
}
}),
"[project]/node_modules/@ucanto/principal/src/lib.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Signer",
    ()=>Signer,
    "Verifier",
    ()=>Verifier
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/ed25519.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/ed25519.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$verifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Verifier$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/ed25519/verifier.js [app-client] (ecmascript) <export * as Verifier>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/ed25519/signer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/rsa.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/rsa.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$absentee$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/absentee.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$multiformat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/multiformat.js [app-client] (ecmascript)");
;
;
;
;
const Verifier = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$verifier$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Verifier$3e$__["Verifier"].or(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__.Verifier);
const Signer = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["or"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$rsa$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__);
;
}),
"[project]/node_modules/@ucanto/principal/src/ed25519/signer.js [app-client] (ecmascript) <export * as Signer>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Signer",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2f$signer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/ed25519/signer.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@ucanto/principal/src/ed25519.js [app-client] (ecmascript) <export * as ed25519>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ed25519",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$principal$2f$src$2f$ed25519$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/principal/src/ed25519.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@scure/bip39/node_modules/@noble/hashes/esm/crypto.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "crypto",
    ()=>crypto
]);
const crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined; //# sourceMappingURL=crypto.js.map
}),
"[project]/node_modules/@scure/bip39/node_modules/@noble/hashes/esm/utils.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Utilities for hex, bytes, CSPRNG.
 * @module
 */ /*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ // We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
__turbopack_context__.s([
    "Hash",
    ()=>Hash,
    "abytes",
    ()=>abytes,
    "aexists",
    ()=>aexists,
    "ahash",
    ()=>ahash,
    "anumber",
    ()=>anumber,
    "aoutput",
    ()=>aoutput,
    "asyncLoop",
    ()=>asyncLoop,
    "byteSwap",
    ()=>byteSwap,
    "byteSwap32",
    ()=>byteSwap32,
    "byteSwapIfBE",
    ()=>byteSwapIfBE,
    "bytesToHex",
    ()=>bytesToHex,
    "bytesToUtf8",
    ()=>bytesToUtf8,
    "checkOpts",
    ()=>checkOpts,
    "clean",
    ()=>clean,
    "concatBytes",
    ()=>concatBytes,
    "createHasher",
    ()=>createHasher,
    "createOptHasher",
    ()=>createOptHasher,
    "createView",
    ()=>createView,
    "createXOFer",
    ()=>createXOFer,
    "hexToBytes",
    ()=>hexToBytes,
    "isBytes",
    ()=>isBytes,
    "isLE",
    ()=>isLE,
    "kdfInputToBytes",
    ()=>kdfInputToBytes,
    "nextTick",
    ()=>nextTick,
    "randomBytes",
    ()=>randomBytes,
    "rotl",
    ()=>rotl,
    "rotr",
    ()=>rotr,
    "swap32IfBE",
    ()=>swap32IfBE,
    "swap8IfBE",
    ()=>swap8IfBE,
    "toBytes",
    ()=>toBytes,
    "u32",
    ()=>u32,
    "u8",
    ()=>u8,
    "utf8ToBytes",
    ()=>utf8ToBytes,
    "wrapConstructor",
    ()=>wrapConstructor,
    "wrapConstructorWithOpts",
    ()=>wrapConstructorWithOpts,
    "wrapXOFConstructorWithOpts",
    ()=>wrapXOFConstructorWithOpts
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@scure/bip39/node_modules/@noble/hashes/esm/crypto.js [app-client] (ecmascript)");
;
function isBytes(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array';
}
function anumber(n) {
    if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);
}
function abytes(b, ...lengths) {
    if (!isBytes(b)) throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);
}
function ahash(h) {
    if (typeof h !== 'function' || typeof h.create !== 'function') throw new Error('Hash should be wrapped by utils.createHasher');
    anumber(h.outputLen);
    anumber(h.blockLen);
}
function aexists(instance, checkFinished = true) {
    if (instance.destroyed) throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');
}
function aoutput(out, instance) {
    abytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error('digestInto() expects output buffer of length at least ' + min);
    }
}
function u8(arr) {
    return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
}
function u32(arr) {
    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
function clean(...arrays) {
    for(let i = 0; i < arrays.length; i++){
        arrays[i].fill(0);
    }
}
function createView(arr) {
    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr(word, shift) {
    return word << 32 - shift | word >>> shift;
}
function rotl(word, shift) {
    return word << shift | word >>> 32 - shift >>> 0;
}
const isLE = /* @__PURE__ */ (()=>new Uint8Array(new Uint32Array([
        0x11223344
    ]).buffer)[0] === 0x44)();
function byteSwap(word) {
    return word << 24 & 0xff000000 | word << 8 & 0xff0000 | word >>> 8 & 0xff00 | word >>> 24 & 0xff;
}
const swap8IfBE = isLE ? (n)=>n : (n)=>byteSwap(n);
const byteSwapIfBE = swap8IfBE;
function byteSwap32(arr) {
    for(let i = 0; i < arr.length; i++){
        arr[i] = byteSwap(arr[i]);
    }
    return arr;
}
const swap32IfBE = isLE ? (u)=>u : byteSwap32;
// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex
const hasHexBuiltin = /* @__PURE__ */ (()=>// @ts-ignore
    typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */ Array.from({
    length: 256
}, (_, i)=>i.toString(16).padStart(2, '0'));
function bytesToHex(bytes) {
    abytes(bytes);
    // @ts-ignore
    if (hasHexBuiltin) return bytes.toHex();
    // pre-caching improves the speed 6x
    let hex = '';
    for(let i = 0; i < bytes.length; i++){
        hex += hexes[bytes[i]];
    }
    return hex;
}
// We use optimized technique to convert hex string to byte array
const asciis = {
    _0: 48,
    _9: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};
function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48
    if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)
    if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)
    return;
}
function hexToBytes(hex) {
    if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);
    // @ts-ignore
    if (hasHexBuiltin) return Uint8Array.fromHex(hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);
    const array = new Uint8Array(al);
    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163
    }
    return array;
}
const nextTick = async ()=>{};
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for(let i = 0; i < iters; i++){
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick) continue;
        await nextTick();
        ts += diff;
    }
}
function utf8ToBytes(str) {
    if (typeof str !== 'string') throw new Error('string expected');
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
function bytesToUtf8(bytes) {
    return new TextDecoder().decode(bytes);
}
function toBytes(data) {
    if (typeof data === 'string') data = utf8ToBytes(data);
    abytes(data);
    return data;
}
function kdfInputToBytes(data) {
    if (typeof data === 'string') data = utf8ToBytes(data);
    abytes(data);
    return data;
}
function concatBytes(...arrays) {
    let sum = 0;
    for(let i = 0; i < arrays.length; i++){
        const a = arrays[i];
        abytes(a);
        sum += a.length;
    }
    const res = new Uint8Array(sum);
    for(let i = 0, pad = 0; i < arrays.length; i++){
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
function checkOpts(defaults, opts) {
    if (opts !== undefined && ({}).toString.call(opts) !== '[object Object]') throw new Error('options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
class Hash {
}
function createHasher(hashCons) {
    const hashC = (msg)=>hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = ()=>hashCons();
    return hashC;
}
function createOptHasher(hashCons) {
    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts)=>hashCons(opts);
    return hashC;
}
function createXOFer(hashCons) {
    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts)=>hashCons(opts);
    return hashC;
}
const wrapConstructor = createHasher;
const wrapConstructorWithOpts = createOptHasher;
const wrapXOFConstructorWithOpts = createXOFer;
function randomBytes(bytesLength = 32) {
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["crypto"] && typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["crypto"].getRandomValues === 'function') {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["crypto"].getRandomValues(new Uint8Array(bytesLength));
    }
    // Legacy Node.js compatibility
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["crypto"] && typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["crypto"].randomBytes === 'function') {
        return Uint8Array.from(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["crypto"].randomBytes(bytesLength));
    }
    throw new Error('crypto.getRandomValues must be defined');
} //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/@scure/bip39/node_modules/@noble/hashes/esm/hmac.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * HMAC: RFC2104 message authentication code.
 * @module
 */ __turbopack_context__.s([
    "HMAC",
    ()=>HMAC,
    "hmac",
    ()=>hmac
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@scure/bip39/node_modules/@noble/hashes/esm/utils.js [app-client] (ecmascript)");
;
class HMAC extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Hash"] {
    constructor(hash, _key){
        super();
        this.finished = false;
        this.destroyed = false;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ahash"])(hash);
        const key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toBytes"])(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== 'function') throw new Error('Expected instance of class which extends utils.Hash');
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        // blockLen can be bigger than outputLen
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36;
        this.iHash.update(pad);
        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone
        this.oHash = hash.create();
        // Undo internal XOR && apply outer XOR
        for(let i = 0; i < pad.length; i++)pad[i] ^= 0x36 ^ 0x5c;
        this.oHash.update(pad);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clean"])(pad);
    }
    update(buf) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aexists"])(this);
        this.iHash.update(buf);
        return this;
    }
    digestInto(out) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aexists"])(this);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["abytes"])(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
    }
    digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
    }
    _cloneInto(to) {
        // Create new instance without calling constructor since key already in state and we don't know it.
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
    }
    clone() {
        return this._cloneInto();
    }
    destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
    }
}
const hmac = (hash, key, message)=>new HMAC(hash, key).update(message).digest();
hmac.create = (hash, key)=>new HMAC(hash, key); //# sourceMappingURL=hmac.js.map
}),
"[project]/node_modules/@scure/bip39/node_modules/@noble/hashes/esm/pbkdf2.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * PBKDF (RFC 2898). Can be used to create a key from password and salt.
 * @module
 */ __turbopack_context__.s([
    "pbkdf2",
    ()=>pbkdf2,
    "pbkdf2Async",
    ()=>pbkdf2Async
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$hmac$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@scure/bip39/node_modules/@noble/hashes/esm/hmac.js [app-client] (ecmascript)");
// prettier-ignore
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@scure/bip39/node_modules/@noble/hashes/esm/utils.js [app-client] (ecmascript)");
;
;
// Common prologue and epilogue for sync/async functions
function pbkdf2Init(hash, _password, _salt, _opts) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ahash"])(hash);
    const opts = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["checkOpts"])({
        dkLen: 32,
        asyncTick: 10
    }, _opts);
    const { c, dkLen, asyncTick } = opts;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["anumber"])(c);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["anumber"])(dkLen);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["anumber"])(asyncTick);
    if (c < 1) throw new Error('iterations (c) should be >= 1');
    const password = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kdfInputToBytes"])(_password);
    const salt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["kdfInputToBytes"])(_salt);
    // DK = PBKDF2(PRF, Password, Salt, c, dkLen);
    const DK = new Uint8Array(dkLen);
    // U1 = PRF(Password, Salt + INT_32_BE(i))
    const PRF = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$hmac$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["hmac"].create(hash, password);
    const PRFSalt = PRF._cloneInto().update(salt);
    return {
        c,
        dkLen,
        asyncTick,
        DK,
        PRF,
        PRFSalt
    };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
    PRF.destroy();
    PRFSalt.destroy();
    if (prfW) prfW.destroy();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clean"])(u);
    return DK;
}
function pbkdf2(hash, password, salt, opts) {
    const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
    let prfW; // Working copy
    const arr = new Uint8Array(4);
    const view = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createView"])(arr);
    const u = new Uint8Array(PRF.outputLen);
    // DK = T1 + T2 +  + Tdklen/hlen
    for(let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen){
        // Ti = F(Password, Salt, c, i)
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc
        // U1 = PRF(Password, Salt + INT_32_BE(i))
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        for(let ui = 1; ui < c; ui++){
            // Uc = PRF(Password, Uc1)
            PRF._cloneInto(prfW).update(u).digestInto(u);
            for(let i = 0; i < Ti.length; i++)Ti[i] ^= u[i];
        }
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}
async function pbkdf2Async(hash, password, salt, opts) {
    const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
    let prfW; // Working copy
    const arr = new Uint8Array(4);
    const view = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createView"])(arr);
    const u = new Uint8Array(PRF.outputLen);
    // DK = T1 + T2 +  + Tdklen/hlen
    for(let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen){
        // Ti = F(Password, Salt, c, i)
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        // F(Password, Salt, c, i) = U1 ^ U2 ^  ^ Uc
        // U1 = PRF(Password, Salt + INT_32_BE(i))
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asyncLoop"])(c - 1, asyncTick, ()=>{
            // Uc = PRF(Password, Uc1)
            PRF._cloneInto(prfW).update(u).digestInto(u);
            for(let i = 0; i < Ti.length; i++)Ti[i] ^= u[i];
        });
    }
    return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
} //# sourceMappingURL=pbkdf2.js.map
}),
"[project]/node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_md.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Internal Merkle-Damgard hash utils.
 * @module
 */ __turbopack_context__.s([
    "Chi",
    ()=>Chi,
    "HashMD",
    ()=>HashMD,
    "Maj",
    ()=>Maj,
    "SHA224_IV",
    ()=>SHA224_IV,
    "SHA256_IV",
    ()=>SHA256_IV,
    "SHA384_IV",
    ()=>SHA384_IV,
    "SHA512_IV",
    ()=>SHA512_IV,
    "setBigUint64",
    ()=>setBigUint64
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@scure/bip39/node_modules/@noble/hashes/esm/utils.js [app-client] (ecmascript)");
;
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number(value >> _32n & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
function Chi(a, b, c) {
    return a & b ^ ~a & c;
}
function Maj(a, b, c) {
    return a & b ^ a & c ^ b & c;
}
class HashMD extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Hash"] {
    constructor(blockLen, outputLen, padOffset, isLE){
        super();
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createView"])(this.buffer);
    }
    update(data) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aexists"])(this);
        data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toBytes"])(data);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["abytes"])(data);
        const { view, buffer, blockLen } = this;
        const len = data.length;
        for(let pos = 0; pos < len;){
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createView"])(data);
                for(; blockLen <= len - pos; pos += blockLen)this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aexists"])(this);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aoutput"])(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 0b10000000;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clean"])(this.buffer.subarray(pos));
        // we have less than padOffset left in buffer, so we cannot put length in
        // current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for(let i = pos; i < blockLen; i++)buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createView"])(out);
        const len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');
        for(let i = 0; i < outLen; i++)oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.destroyed = destroyed;
        to.finished = finished;
        to.length = length;
        to.pos = pos;
        if (length % blockLen) to.buffer.set(buffer);
        return to;
    }
    clone() {
        return this._cloneInto();
    }
}
const SHA256_IV = /* @__PURE__ */ Uint32Array.from([
    0x6a09e667,
    0xbb67ae85,
    0x3c6ef372,
    0xa54ff53a,
    0x510e527f,
    0x9b05688c,
    0x1f83d9ab,
    0x5be0cd19
]);
const SHA224_IV = /* @__PURE__ */ Uint32Array.from([
    0xc1059ed8,
    0x367cd507,
    0x3070dd17,
    0xf70e5939,
    0xffc00b31,
    0x68581511,
    0x64f98fa7,
    0xbefa4fa4
]);
const SHA384_IV = /* @__PURE__ */ Uint32Array.from([
    0xcbbb9d5d,
    0xc1059ed8,
    0x629a292a,
    0x367cd507,
    0x9159015a,
    0x3070dd17,
    0x152fecd8,
    0xf70e5939,
    0x67332667,
    0xffc00b31,
    0x8eb44a87,
    0x68581511,
    0xdb0c2e0d,
    0x64f98fa7,
    0x47b5481d,
    0xbefa4fa4
]);
const SHA512_IV = /* @__PURE__ */ Uint32Array.from([
    0x6a09e667,
    0xf3bcc908,
    0xbb67ae85,
    0x84caa73b,
    0x3c6ef372,
    0xfe94f82b,
    0xa54ff53a,
    0x5f1d36f1,
    0x510e527f,
    0xade682d1,
    0x9b05688c,
    0x2b3e6c1f,
    0x1f83d9ab,
    0xfb41bd6b,
    0x5be0cd19,
    0x137e2179
]); //# sourceMappingURL=_md.js.map
}),
"[project]/node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_u64.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.
 * @todo re-check https://issues.chromium.org/issues/42212588
 * @module
 */ __turbopack_context__.s([
    "add",
    ()=>add,
    "add3H",
    ()=>add3H,
    "add3L",
    ()=>add3L,
    "add4H",
    ()=>add4H,
    "add4L",
    ()=>add4L,
    "add5H",
    ()=>add5H,
    "add5L",
    ()=>add5L,
    "default",
    ()=>__TURBOPACK__default__export__,
    "fromBig",
    ()=>fromBig,
    "rotlBH",
    ()=>rotlBH,
    "rotlBL",
    ()=>rotlBL,
    "rotlSH",
    ()=>rotlSH,
    "rotlSL",
    ()=>rotlSL,
    "rotr32H",
    ()=>rotr32H,
    "rotr32L",
    ()=>rotr32L,
    "rotrBH",
    ()=>rotrBH,
    "rotrBL",
    ()=>rotrBL,
    "rotrSH",
    ()=>rotrSH,
    "rotrSL",
    ()=>rotrSL,
    "shrSH",
    ()=>shrSH,
    "shrSL",
    ()=>shrSL,
    "split",
    ()=>split,
    "toBig",
    ()=>toBig
]);
const U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
const _32n = /* @__PURE__ */ BigInt(32);
function fromBig(n, le = false) {
    if (le) return {
        h: Number(n & U32_MASK64),
        l: Number(n >> _32n & U32_MASK64)
    };
    return {
        h: Number(n >> _32n & U32_MASK64) | 0,
        l: Number(n & U32_MASK64) | 0
    };
}
function split(lst, le = false) {
    const len = lst.length;
    let Ah = new Uint32Array(len);
    let Al = new Uint32Array(len);
    for(let i = 0; i < len; i++){
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [
            h,
            l
        ];
    }
    return [
        Ah,
        Al
    ];
}
const toBig = (h, l)=>BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
// for Shift in [0, 32)
const shrSH = (h, _l, s)=>h >>> s;
const shrSL = (h, l, s)=>h << 32 - s | l >>> s;
// Right rotate for Shift in [1, 32)
const rotrSH = (h, l, s)=>h >>> s | l << 32 - s;
const rotrSL = (h, l, s)=>h << 32 - s | l >>> s;
// Right rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotrBH = (h, l, s)=>h << 64 - s | l >>> s - 32;
const rotrBL = (h, l, s)=>h >>> s - 32 | l << 64 - s;
// Right rotate for shift===32 (just swaps l&h)
const rotr32H = (_h, l)=>l;
const rotr32L = (h, _l)=>h;
// Left rotate for Shift in [1, 32)
const rotlSH = (h, l, s)=>h << s | l >>> 32 - s;
const rotlSL = (h, l, s)=>l << s | h >>> 32 - s;
// Left rotate for Shift in (32, 64), NOTE: 32 is special case.
const rotlBH = (h, l, s)=>l << s - 32 | h >>> 64 - s;
const rotlBL = (h, l, s)=>h << s - 32 | l >>> 64 - s;
// JS uses 32-bit signed integers for bitwise operations which means we cannot
// simple take carry out of low bit sum by shift, we need to use division.
function add(Ah, Al, Bh, Bl) {
    const l = (Al >>> 0) + (Bl >>> 0);
    return {
        h: Ah + Bh + (l / 2 ** 32 | 0) | 0,
        l: l | 0
    };
}
// Addition with more than 2 elements
const add3L = (Al, Bl, Cl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
const add3H = (low, Ah, Bh, Ch)=>Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
const add4L = (Al, Bl, Cl, Dl)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
const add4H = (low, Ah, Bh, Ch, Dh)=>Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
const add5L = (Al, Bl, Cl, Dl, El)=>(Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
const add5H = (low, Ah, Bh, Ch, Dh, Eh)=>Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
;
// prettier-ignore
const u64 = {
    fromBig,
    split,
    toBig,
    shrSH,
    shrSL,
    rotrSH,
    rotrSL,
    rotrBH,
    rotrBL,
    rotr32H,
    rotr32L,
    rotlSH,
    rotlSL,
    rotlBH,
    rotlBL,
    add,
    add3L,
    add3H,
    add4L,
    add4H,
    add5H,
    add5L
};
const __TURBOPACK__default__export__ = u64;
 //# sourceMappingURL=_u64.js.map
}),
"[project]/node_modules/@scure/bip39/node_modules/@noble/hashes/esm/sha2.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.
 * SHA256 is the fastest hash implementable in JS, even faster than Blake3.
 * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and
 * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).
 * @module
 */ __turbopack_context__.s([
    "SHA224",
    ()=>SHA224,
    "SHA256",
    ()=>SHA256,
    "SHA384",
    ()=>SHA384,
    "SHA512",
    ()=>SHA512,
    "SHA512_224",
    ()=>SHA512_224,
    "SHA512_256",
    ()=>SHA512_256,
    "sha224",
    ()=>sha224,
    "sha256",
    ()=>sha256,
    "sha384",
    ()=>sha384,
    "sha512",
    ()=>sha512,
    "sha512_224",
    ()=>sha512_224,
    "sha512_256",
    ()=>sha512_256
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_md.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_u64.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@scure/bip39/node_modules/@noble/hashes/esm/utils.js [app-client] (ecmascript)");
;
;
;
/**
 * Round constants:
 * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)
 */ // prettier-ignore
const SHA256_K = /* @__PURE__ */ Uint32Array.from([
    0x428a2f98,
    0x71374491,
    0xb5c0fbcf,
    0xe9b5dba5,
    0x3956c25b,
    0x59f111f1,
    0x923f82a4,
    0xab1c5ed5,
    0xd807aa98,
    0x12835b01,
    0x243185be,
    0x550c7dc3,
    0x72be5d74,
    0x80deb1fe,
    0x9bdc06a7,
    0xc19bf174,
    0xe49b69c1,
    0xefbe4786,
    0x0fc19dc6,
    0x240ca1cc,
    0x2de92c6f,
    0x4a7484aa,
    0x5cb0a9dc,
    0x76f988da,
    0x983e5152,
    0xa831c66d,
    0xb00327c8,
    0xbf597fc7,
    0xc6e00bf3,
    0xd5a79147,
    0x06ca6351,
    0x14292967,
    0x27b70a85,
    0x2e1b2138,
    0x4d2c6dfc,
    0x53380d13,
    0x650a7354,
    0x766a0abb,
    0x81c2c92e,
    0x92722c85,
    0xa2bfe8a1,
    0xa81a664b,
    0xc24b8b70,
    0xc76c51a3,
    0xd192e819,
    0xd6990624,
    0xf40e3585,
    0x106aa070,
    0x19a4c116,
    0x1e376c08,
    0x2748774c,
    0x34b0bcb5,
    0x391c0cb3,
    0x4ed8aa4a,
    0x5b9cca4f,
    0x682e6ff3,
    0x748f82ee,
    0x78a5636f,
    0x84c87814,
    0x8cc70208,
    0x90befffa,
    0xa4506ceb,
    0xbef9a3f7,
    0xc67178f2
]);
/** Reusable temporary buffer. "W" comes straight from spec. */ const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HashMD"] {
    constructor(outputLen = 32){
        super(64, outputLen, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA256_IV"][0] | 0;
        this.B = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA256_IV"][1] | 0;
        this.C = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA256_IV"][2] | 0;
        this.D = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA256_IV"][3] | 0;
        this.E = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA256_IV"][4] | 0;
        this.F = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA256_IV"][5] | 0;
        this.G = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA256_IV"][6] | 0;
        this.H = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA256_IV"][7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [
            A,
            B,
            C,
            D,
            E,
            F,
            G,
            H
        ];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for(let i = 0; i < 16; i++, offset += 4)SHA256_W[i] = view.getUint32(offset, false);
        for(let i = 16; i < 64; i++){
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotr"])(W15, 7) ^ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotr"])(W15, 18) ^ W15 >>> 3;
            const s1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotr"])(W2, 17) ^ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotr"])(W2, 19) ^ W2 >>> 10;
            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for(let i = 0; i < 64; i++){
            const sigma1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotr"])(E, 6) ^ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotr"])(E, 11) ^ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotr"])(E, 25);
            const T1 = H + sigma1 + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Chi"])(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
            const sigma0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotr"])(A, 2) ^ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotr"])(A, 13) ^ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotr"])(A, 22);
            const T2 = sigma0 + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Maj"])(A, B, C) | 0;
            H = G;
            G = F;
            F = E;
            E = D + T1 | 0;
            D = C;
            C = B;
            B = A;
            A = T1 + T2 | 0;
        }
        // Add the compressed chunk to the current hash value
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clean"])(SHA256_W);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clean"])(this.buffer);
    }
}
class SHA224 extends SHA256 {
    constructor(){
        super(28);
        this.A = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA224_IV"][0] | 0;
        this.B = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA224_IV"][1] | 0;
        this.C = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA224_IV"][2] | 0;
        this.D = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA224_IV"][3] | 0;
        this.E = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA224_IV"][4] | 0;
        this.F = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA224_IV"][5] | 0;
        this.G = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA224_IV"][6] | 0;
        this.H = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA224_IV"][7] | 0;
    }
}
// SHA2-512 is slower than sha256 in js because u64 operations are slow.
// Round contants
// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409
// prettier-ignore
const K512 = /* @__PURE__ */ (()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["split"]([
        '0x428a2f98d728ae22',
        '0x7137449123ef65cd',
        '0xb5c0fbcfec4d3b2f',
        '0xe9b5dba58189dbbc',
        '0x3956c25bf348b538',
        '0x59f111f1b605d019',
        '0x923f82a4af194f9b',
        '0xab1c5ed5da6d8118',
        '0xd807aa98a3030242',
        '0x12835b0145706fbe',
        '0x243185be4ee4b28c',
        '0x550c7dc3d5ffb4e2',
        '0x72be5d74f27b896f',
        '0x80deb1fe3b1696b1',
        '0x9bdc06a725c71235',
        '0xc19bf174cf692694',
        '0xe49b69c19ef14ad2',
        '0xefbe4786384f25e3',
        '0x0fc19dc68b8cd5b5',
        '0x240ca1cc77ac9c65',
        '0x2de92c6f592b0275',
        '0x4a7484aa6ea6e483',
        '0x5cb0a9dcbd41fbd4',
        '0x76f988da831153b5',
        '0x983e5152ee66dfab',
        '0xa831c66d2db43210',
        '0xb00327c898fb213f',
        '0xbf597fc7beef0ee4',
        '0xc6e00bf33da88fc2',
        '0xd5a79147930aa725',
        '0x06ca6351e003826f',
        '0x142929670a0e6e70',
        '0x27b70a8546d22ffc',
        '0x2e1b21385c26c926',
        '0x4d2c6dfc5ac42aed',
        '0x53380d139d95b3df',
        '0x650a73548baf63de',
        '0x766a0abb3c77b2a8',
        '0x81c2c92e47edaee6',
        '0x92722c851482353b',
        '0xa2bfe8a14cf10364',
        '0xa81a664bbc423001',
        '0xc24b8b70d0f89791',
        '0xc76c51a30654be30',
        '0xd192e819d6ef5218',
        '0xd69906245565a910',
        '0xf40e35855771202a',
        '0x106aa07032bbd1b8',
        '0x19a4c116b8d2d0c8',
        '0x1e376c085141ab53',
        '0x2748774cdf8eeb99',
        '0x34b0bcb5e19b48a8',
        '0x391c0cb3c5c95a63',
        '0x4ed8aa4ae3418acb',
        '0x5b9cca4f7763e373',
        '0x682e6ff3d6b2b8a3',
        '0x748f82ee5defb2fc',
        '0x78a5636f43172f60',
        '0x84c87814a1f0ab72',
        '0x8cc702081a6439ec',
        '0x90befffa23631e28',
        '0xa4506cebde82bde9',
        '0xbef9a3f7b2c67915',
        '0xc67178f2e372532b',
        '0xca273eceea26619c',
        '0xd186b8c721c0c207',
        '0xeada7dd6cde0eb1e',
        '0xf57d4f7fee6ed178',
        '0x06f067aa72176fba',
        '0x0a637dc5a2c898a6',
        '0x113f9804bef90dae',
        '0x1b710b35131c471b',
        '0x28db77f523047d84',
        '0x32caab7b40c72493',
        '0x3c9ebe0a15c9bebc',
        '0x431d67c49c100d4c',
        '0x4cc5d4becb3e42b6',
        '0x597f299cfc657e2a',
        '0x5fcb6fab3ad6faec',
        '0x6c44198c4a475817'
    ].map((n)=>BigInt(n))))();
const SHA512_Kh = /* @__PURE__ */ (()=>K512[0])();
const SHA512_Kl = /* @__PURE__ */ (()=>K512[1])();
// Reusable temporary buffers
const SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);
const SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);
class SHA512 extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HashMD"] {
    constructor(outputLen = 64){
        super(128, outputLen, 16, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        // h -- high 32 bits, l -- low 32 bits
        this.Ah = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA512_IV"][0] | 0;
        this.Al = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA512_IV"][1] | 0;
        this.Bh = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA512_IV"][2] | 0;
        this.Bl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA512_IV"][3] | 0;
        this.Ch = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA512_IV"][4] | 0;
        this.Cl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA512_IV"][5] | 0;
        this.Dh = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA512_IV"][6] | 0;
        this.Dl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA512_IV"][7] | 0;
        this.Eh = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA512_IV"][8] | 0;
        this.El = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA512_IV"][9] | 0;
        this.Fh = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA512_IV"][10] | 0;
        this.Fl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA512_IV"][11] | 0;
        this.Gh = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA512_IV"][12] | 0;
        this.Gl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA512_IV"][13] | 0;
        this.Hh = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA512_IV"][14] | 0;
        this.Hl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA512_IV"][15] | 0;
    }
    // prettier-ignore
    get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [
            Ah,
            Al,
            Bh,
            Bl,
            Ch,
            Cl,
            Dh,
            Dl,
            Eh,
            El,
            Fh,
            Fl,
            Gh,
            Gl,
            Hh,
            Hl
        ];
    }
    // prettier-ignore
    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array
        for(let i = 0; i < 16; i++, offset += 4){
            SHA512_W_H[i] = view.getUint32(offset);
            SHA512_W_L[i] = view.getUint32(offset += 4);
        }
        for(let i = 16; i < 80; i++){
            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)
            const W15h = SHA512_W_H[i - 15] | 0;
            const W15l = SHA512_W_L[i - 15] | 0;
            const s0h = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotrSH"](W15h, W15l, 1) ^ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotrSH"](W15h, W15l, 8) ^ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shrSH"](W15h, W15l, 7);
            const s0l = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotrSL"](W15h, W15l, 1) ^ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotrSL"](W15h, W15l, 8) ^ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shrSL"](W15h, W15l, 7);
            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)
            const W2h = SHA512_W_H[i - 2] | 0;
            const W2l = SHA512_W_L[i - 2] | 0;
            const s1h = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotrSH"](W2h, W2l, 19) ^ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotrBH"](W2h, W2l, 61) ^ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shrSH"](W2h, W2l, 6);
            const s1l = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotrSL"](W2h, W2l, 19) ^ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotrBL"](W2h, W2l, 61) ^ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["shrSL"](W2h, W2l, 6);
            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];
            const SUMl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["add4L"](s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
            const SUMh = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["add4H"](SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
            SHA512_W_H[i] = SUMh | 0;
            SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        // Compression function main loop, 80 rounds
        for(let i = 0; i < 80; i++){
            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)
            const sigma1h = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotrSH"](Eh, El, 14) ^ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotrSH"](Eh, El, 18) ^ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotrBH"](Eh, El, 41);
            const sigma1l = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotrSL"](Eh, El, 14) ^ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotrSL"](Eh, El, 18) ^ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotrBL"](Eh, El, 41);
            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;
            const CHIh = Eh & Fh ^ ~Eh & Gh;
            const CHIl = El & Fl ^ ~El & Gl;
            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]
            // prettier-ignore
            const T1ll = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["add5L"](Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
            const T1h = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["add5H"](T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
            const T1l = T1ll | 0;
            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)
            const sigma0h = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotrSH"](Ah, Al, 28) ^ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotrBH"](Ah, Al, 34) ^ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotrBH"](Ah, Al, 39);
            const sigma0l = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotrSL"](Ah, Al, 28) ^ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotrBL"](Ah, Al, 34) ^ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotrBL"](Ah, Al, 39);
            const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
            const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
            Hh = Gh | 0;
            Hl = Gl | 0;
            Gh = Fh | 0;
            Gl = Fl | 0;
            Fh = Eh | 0;
            Fl = El | 0;
            ({ h: Eh, l: El } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["add"](Dh | 0, Dl | 0, T1h | 0, T1l | 0));
            Dh = Ch | 0;
            Dl = Cl | 0;
            Ch = Bh | 0;
            Cl = Bl | 0;
            Bh = Ah | 0;
            Bl = Al | 0;
            const All = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["add3L"](T1l, sigma0l, MAJl);
            Ah = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["add3H"](All, T1h, sigma0h, MAJh);
            Al = All | 0;
        }
        // Add the compressed chunk to the current hash value
        ({ h: Ah, l: Al } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["add"](this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["add"](this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["add"](this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["add"](this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["add"](this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["add"](this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["add"](this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_u64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["add"](this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
    }
    roundClean() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clean"])(SHA512_W_H, SHA512_W_L);
    }
    destroy() {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["clean"])(this.buffer);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    }
}
class SHA384 extends SHA512 {
    constructor(){
        super(48);
        this.Ah = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA384_IV"][0] | 0;
        this.Al = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA384_IV"][1] | 0;
        this.Bh = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA384_IV"][2] | 0;
        this.Bl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA384_IV"][3] | 0;
        this.Ch = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA384_IV"][4] | 0;
        this.Cl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA384_IV"][5] | 0;
        this.Dh = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA384_IV"][6] | 0;
        this.Dl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA384_IV"][7] | 0;
        this.Eh = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA384_IV"][8] | 0;
        this.El = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA384_IV"][9] | 0;
        this.Fh = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA384_IV"][10] | 0;
        this.Fl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA384_IV"][11] | 0;
        this.Gh = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA384_IV"][12] | 0;
        this.Gl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA384_IV"][13] | 0;
        this.Hh = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA384_IV"][14] | 0;
        this.Hl = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["SHA384_IV"][15] | 0;
    }
}
/**
 * Truncated SHA512/256 and SHA512/224.
 * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as "intermediary" IV of SHA512/t.
 * Then t hashes string to produce result IV.
 * See `test/misc/sha2-gen-iv.js`.
 */ /** SHA512/224 IV */ const T224_IV = /* @__PURE__ */ Uint32Array.from([
    0x8c3d37c8,
    0x19544da2,
    0x73e19966,
    0x89dcd4d6,
    0x1dfab7ae,
    0x32ff9c82,
    0x679dd514,
    0x582f9fcf,
    0x0f6d2b69,
    0x7bd44da8,
    0x77e36f73,
    0x04c48942,
    0x3f9d85a8,
    0x6a1d36c8,
    0x1112e6ad,
    0x91d692a1
]);
/** SHA512/256 IV */ const T256_IV = /* @__PURE__ */ Uint32Array.from([
    0x22312194,
    0xfc2bf72c,
    0x9f555fa3,
    0xc84c64c2,
    0x2393b86b,
    0x6f53b151,
    0x96387719,
    0x5940eabd,
    0x96283ee2,
    0xa88effe3,
    0xbe5e1e25,
    0x53863992,
    0x2b0199fc,
    0x2c85b8aa,
    0x0eb72ddc,
    0x81c52ca2
]);
class SHA512_224 extends SHA512 {
    constructor(){
        super(28);
        this.Ah = T224_IV[0] | 0;
        this.Al = T224_IV[1] | 0;
        this.Bh = T224_IV[2] | 0;
        this.Bl = T224_IV[3] | 0;
        this.Ch = T224_IV[4] | 0;
        this.Cl = T224_IV[5] | 0;
        this.Dh = T224_IV[6] | 0;
        this.Dl = T224_IV[7] | 0;
        this.Eh = T224_IV[8] | 0;
        this.El = T224_IV[9] | 0;
        this.Fh = T224_IV[10] | 0;
        this.Fl = T224_IV[11] | 0;
        this.Gh = T224_IV[12] | 0;
        this.Gl = T224_IV[13] | 0;
        this.Hh = T224_IV[14] | 0;
        this.Hl = T224_IV[15] | 0;
    }
}
class SHA512_256 extends SHA512 {
    constructor(){
        super(32);
        this.Ah = T256_IV[0] | 0;
        this.Al = T256_IV[1] | 0;
        this.Bh = T256_IV[2] | 0;
        this.Bl = T256_IV[3] | 0;
        this.Ch = T256_IV[4] | 0;
        this.Cl = T256_IV[5] | 0;
        this.Dh = T256_IV[6] | 0;
        this.Dl = T256_IV[7] | 0;
        this.Eh = T256_IV[8] | 0;
        this.El = T256_IV[9] | 0;
        this.Fh = T256_IV[10] | 0;
        this.Fl = T256_IV[11] | 0;
        this.Gh = T256_IV[12] | 0;
        this.Gl = T256_IV[13] | 0;
        this.Hh = T256_IV[14] | 0;
        this.Hl = T256_IV[15] | 0;
    }
}
const sha256 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createHasher"])(()=>new SHA256());
const sha224 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createHasher"])(()=>new SHA224());
const sha512 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createHasher"])(()=>new SHA512());
const sha384 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createHasher"])(()=>new SHA384());
const sha512_256 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createHasher"])(()=>new SHA512_256());
const sha512_224 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createHasher"])(()=>new SHA512_224()); //# sourceMappingURL=sha2.js.map
}),
"[project]/node_modules/@noble/hashes/esm/_assert.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Assertion helpers
 * @module
 */ __turbopack_context__.s([
    "abytes",
    ()=>abytes,
    "aexists",
    ()=>aexists,
    "ahash",
    ()=>ahash,
    "anumber",
    ()=>anumber,
    "aoutput",
    ()=>aoutput
]);
function anumber(n) {
    if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);
}
// copied from utils
function isBytes(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array';
}
function abytes(b, ...lengths) {
    if (!isBytes(b)) throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);
}
function ahash(h) {
    if (typeof h !== 'function' || typeof h.create !== 'function') throw new Error('Hash should be wrapped by utils.wrapConstructor');
    anumber(h.outputLen);
    anumber(h.blockLen);
}
function aexists(instance, checkFinished = true) {
    if (instance.destroyed) throw new Error('Hash instance has been destroyed');
    if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');
}
function aoutput(out, instance) {
    abytes(out);
    const min = instance.outputLen;
    if (out.length < min) {
        throw new Error('digestInto() expects output buffer of length at least ' + min);
    }
}
;
 //# sourceMappingURL=_assert.js.map
}),
"[project]/node_modules/@noble/hashes/esm/crypto.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "crypto",
    ()=>crypto
]);
const crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined; //# sourceMappingURL=crypto.js.map
}),
"[project]/node_modules/@noble/hashes/esm/utils.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */ /**
 * Utilities for hex, bytes, CSPRNG.
 * @module
 */ // We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.
// node.js versions earlier than v19 don't declare it in global scope.
// For node.js, package.json#exports field mapping rewrites import
// from `crypto` to `cryptoNode`, which imports native module.
// Makes the utils un-importable in browsers without a bundler.
// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.
__turbopack_context__.s([
    "Hash",
    ()=>Hash,
    "asyncLoop",
    ()=>asyncLoop,
    "byteSwap",
    ()=>byteSwap,
    "byteSwap32",
    ()=>byteSwap32,
    "byteSwapIfBE",
    ()=>byteSwapIfBE,
    "bytesToHex",
    ()=>bytesToHex,
    "checkOpts",
    ()=>checkOpts,
    "concatBytes",
    ()=>concatBytes,
    "createView",
    ()=>createView,
    "hexToBytes",
    ()=>hexToBytes,
    "isBytes",
    ()=>isBytes,
    "isLE",
    ()=>isLE,
    "nextTick",
    ()=>nextTick,
    "randomBytes",
    ()=>randomBytes,
    "rotl",
    ()=>rotl,
    "rotr",
    ()=>rotr,
    "toBytes",
    ()=>toBytes,
    "u32",
    ()=>u32,
    "u8",
    ()=>u8,
    "utf8ToBytes",
    ()=>utf8ToBytes,
    "wrapConstructor",
    ()=>wrapConstructor,
    "wrapConstructorWithOpts",
    ()=>wrapConstructorWithOpts,
    "wrapXOFConstructorWithOpts",
    ()=>wrapXOFConstructorWithOpts
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/crypto.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/_assert.js [app-client] (ecmascript)");
;
;
function isBytes(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array';
}
const u8 = (arr)=>new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
const u32 = (arr)=>new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
const createView = (arr)=>new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
const rotr = (word, shift)=>word << 32 - shift | word >>> shift;
const rotl = (word, shift)=>word << shift | word >>> 32 - shift >>> 0;
const isLE = /* @__PURE__ */ (()=>new Uint8Array(new Uint32Array([
        0x11223344
    ]).buffer)[0] === 0x44)();
const byteSwap = (word)=>word << 24 & 0xff000000 | word << 8 & 0xff0000 | word >>> 8 & 0xff00 | word >>> 24 & 0xff;
const byteSwapIfBE = isLE ? (n)=>n : (n)=>byteSwap(n);
function byteSwap32(arr) {
    for(let i = 0; i < arr.length; i++){
        arr[i] = byteSwap(arr[i]);
    }
}
// Array where index 0xf0 (240) is mapped to string 'f0'
const hexes = /* @__PURE__ */ Array.from({
    length: 256
}, (_, i)=>i.toString(16).padStart(2, '0'));
function bytesToHex(bytes) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["abytes"])(bytes);
    // pre-caching improves the speed 6x
    let hex = '';
    for(let i = 0; i < bytes.length; i++){
        hex += hexes[bytes[i]];
    }
    return hex;
}
// We use optimized technique to convert hex string to byte array
const asciis = {
    _0: 48,
    _9: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};
function asciiToBase16(ch) {
    if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48
    if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)
    if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)
    return;
}
function hexToBytes(hex) {
    if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);
    const hl = hex.length;
    const al = hl / 2;
    if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);
    const array = new Uint8Array(al);
    for(let ai = 0, hi = 0; ai < al; ai++, hi += 2){
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === undefined || n2 === undefined) {
            const char = hex[hi] + hex[hi + 1];
            throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163
    }
    return array;
}
const nextTick = async ()=>{};
async function asyncLoop(iters, tick, cb) {
    let ts = Date.now();
    for(let i = 0; i < iters; i++){
        cb(i);
        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick) continue;
        await nextTick();
        ts += diff;
    }
}
function utf8ToBytes(str) {
    if (typeof str !== 'string') throw new Error('utf8ToBytes expected string, got ' + typeof str);
    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809
}
function toBytes(data) {
    if (typeof data === 'string') data = utf8ToBytes(data);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["abytes"])(data);
    return data;
}
function concatBytes(...arrays) {
    let sum = 0;
    for(let i = 0; i < arrays.length; i++){
        const a = arrays[i];
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["abytes"])(a);
        sum += a.length;
    }
    const res = new Uint8Array(sum);
    for(let i = 0, pad = 0; i < arrays.length; i++){
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
    }
    return res;
}
class Hash {
    // Safe version that clones internal state
    clone() {
        return this._cloneInto();
    }
}
function checkOpts(defaults, opts) {
    if (opts !== undefined && ({}).toString.call(opts) !== '[object Object]') throw new Error('Options should be object or undefined');
    const merged = Object.assign(defaults, opts);
    return merged;
}
function wrapConstructor(hashCons) {
    const hashC = (msg)=>hashCons().update(toBytes(msg)).digest();
    const tmp = hashCons();
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = ()=>hashCons();
    return hashC;
}
function wrapConstructorWithOpts(hashCons) {
    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts)=>hashCons(opts);
    return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
    const hashC = (msg, opts)=>hashCons(opts).update(toBytes(msg)).digest();
    const tmp = hashCons({});
    hashC.outputLen = tmp.outputLen;
    hashC.blockLen = tmp.blockLen;
    hashC.create = (opts)=>hashCons(opts);
    return hashC;
}
function randomBytes(bytesLength = 32) {
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["crypto"] && typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["crypto"].getRandomValues === 'function') {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["crypto"].getRandomValues(new Uint8Array(bytesLength));
    }
    // Legacy Node.js compatibility
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["crypto"] && typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["crypto"].randomBytes === 'function') {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$crypto$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["crypto"].randomBytes(bytesLength);
    }
    throw new Error('crypto.getRandomValues must be defined');
} //# sourceMappingURL=utils.js.map
}),
"[project]/node_modules/@noble/hashes/esm/_md.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Chi",
    ()=>Chi,
    "HashMD",
    ()=>HashMD,
    "Maj",
    ()=>Maj,
    "setBigUint64",
    ()=>setBigUint64
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/_assert.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/utils.js [app-client] (ecmascript)");
;
;
function setBigUint64(view, byteOffset, value, isLE) {
    if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);
    const _32n = BigInt(32);
    const _u32_max = BigInt(0xffffffff);
    const wh = Number(value >> _32n & _u32_max);
    const wl = Number(value & _u32_max);
    const h = isLE ? 4 : 0;
    const l = isLE ? 0 : 4;
    view.setUint32(byteOffset + h, wh, isLE);
    view.setUint32(byteOffset + l, wl, isLE);
}
const Chi = (a, b, c)=>a & b ^ ~a & c;
const Maj = (a, b, c)=>a & b ^ a & c ^ b & c;
class HashMD extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Hash"] {
    constructor(blockLen, outputLen, padOffset, isLE){
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createView"])(this.buffer);
    }
    update(data) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aexists"])(this);
        const { view, buffer, blockLen } = this;
        data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toBytes"])(data);
        const len = data.length;
        for(let pos = 0; pos < len;){
            const take = Math.min(blockLen - this.pos, len - pos);
            // Fast path: we have at least one block in input, cast it to view and process
            if (take === blockLen) {
                const dataView = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createView"])(data);
                for(; blockLen <= len - pos; pos += blockLen)this.process(dataView, pos);
                continue;
            }
            buffer.set(data.subarray(pos, pos + take), this.pos);
            this.pos += take;
            pos += take;
            if (this.pos === blockLen) {
                this.process(view, 0);
                this.pos = 0;
            }
        }
        this.length += data.length;
        this.roundClean();
        return this;
    }
    digestInto(out) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aexists"])(this);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_assert$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aoutput"])(out, this);
        this.finished = true;
        // Padding
        // We can avoid allocation of buffer for padding completely if it
        // was previously not allocated here. But it won't change performance.
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        // append the bit '1' to the message
        buffer[pos++] = 0b10000000;
        this.buffer.subarray(pos).fill(0);
        // we have less than padOffset left in buffer, so we cannot put length in
        // current block, need process it and pad again
        if (this.padOffset > blockLen - pos) {
            this.process(view, 0);
            pos = 0;
        }
        // Pad until full block byte with zeros
        for(let i = pos; i < blockLen; i++)buffer[i] = 0;
        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that
        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.
        // So we just write lowest 64 bits of that value.
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createView"])(out);
        const len = this.outputLen;
        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT
        if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');
        for(let i = 0; i < outLen; i++)oview.setUint32(4 * i, state[i], isLE);
    }
    digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
    }
    _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen) to.buffer.set(buffer);
        return to;
    }
} //# sourceMappingURL=_md.js.map
}),
"[project]/node_modules/@noble/hashes/esm/sha256.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "SHA256",
    ()=>SHA256,
    "sha224",
    ()=>sha224,
    "sha256",
    ()=>sha256
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/_md.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/utils.js [app-client] (ecmascript)");
;
;
/**
 * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.
 *
 * To break sha256 using birthday attack, attackers need to try 2^128 hashes.
 * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.
 *
 * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).
 * @module
 */ /** Round constants: first 32 bits of fractional parts of the cube roots of the first 64 primes 2..311). */ // prettier-ignore
const SHA256_K = /* @__PURE__ */ new Uint32Array([
    0x428a2f98,
    0x71374491,
    0xb5c0fbcf,
    0xe9b5dba5,
    0x3956c25b,
    0x59f111f1,
    0x923f82a4,
    0xab1c5ed5,
    0xd807aa98,
    0x12835b01,
    0x243185be,
    0x550c7dc3,
    0x72be5d74,
    0x80deb1fe,
    0x9bdc06a7,
    0xc19bf174,
    0xe49b69c1,
    0xefbe4786,
    0x0fc19dc6,
    0x240ca1cc,
    0x2de92c6f,
    0x4a7484aa,
    0x5cb0a9dc,
    0x76f988da,
    0x983e5152,
    0xa831c66d,
    0xb00327c8,
    0xbf597fc7,
    0xc6e00bf3,
    0xd5a79147,
    0x06ca6351,
    0x14292967,
    0x27b70a85,
    0x2e1b2138,
    0x4d2c6dfc,
    0x53380d13,
    0x650a7354,
    0x766a0abb,
    0x81c2c92e,
    0x92722c85,
    0xa2bfe8a1,
    0xa81a664b,
    0xc24b8b70,
    0xc76c51a3,
    0xd192e819,
    0xd6990624,
    0xf40e3585,
    0x106aa070,
    0x19a4c116,
    0x1e376c08,
    0x2748774c,
    0x34b0bcb5,
    0x391c0cb3,
    0x4ed8aa4a,
    0x5b9cca4f,
    0x682e6ff3,
    0x748f82ee,
    0x78a5636f,
    0x84c87814,
    0x8cc70208,
    0x90befffa,
    0xa4506ceb,
    0xbef9a3f7,
    0xc67178f2
]);
/** Initial state: first 32 bits of fractional parts of the square roots of the first 8 primes 2..19. */ // prettier-ignore
const SHA256_IV = /* @__PURE__ */ new Uint32Array([
    0x6a09e667,
    0xbb67ae85,
    0x3c6ef372,
    0xa54ff53a,
    0x510e527f,
    0x9b05688c,
    0x1f83d9ab,
    0x5be0cd19
]);
/**
 * Temporary buffer, not used to store anything between runs.
 * Named this way because it matches specification.
 */ const SHA256_W = /* @__PURE__ */ new Uint32Array(64);
class SHA256 extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HashMD"] {
    constructor(){
        super(64, 32, 8, false);
        // We cannot use array here since array allows indexing by variable
        // which means optimizer/compiler cannot use registers.
        this.A = SHA256_IV[0] | 0;
        this.B = SHA256_IV[1] | 0;
        this.C = SHA256_IV[2] | 0;
        this.D = SHA256_IV[3] | 0;
        this.E = SHA256_IV[4] | 0;
        this.F = SHA256_IV[5] | 0;
        this.G = SHA256_IV[6] | 0;
        this.H = SHA256_IV[7] | 0;
    }
    get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [
            A,
            B,
            C,
            D,
            E,
            F,
            G,
            H
        ];
    }
    // prettier-ignore
    set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
    }
    process(view, offset) {
        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array
        for(let i = 0; i < 16; i++, offset += 4)SHA256_W[i] = view.getUint32(offset, false);
        for(let i = 16; i < 64; i++){
            const W15 = SHA256_W[i - 15];
            const W2 = SHA256_W[i - 2];
            const s0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotr"])(W15, 7) ^ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotr"])(W15, 18) ^ W15 >>> 3;
            const s1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotr"])(W2, 17) ^ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotr"])(W2, 19) ^ W2 >>> 10;
            SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        // Compression function main loop, 64 rounds
        let { A, B, C, D, E, F, G, H } = this;
        for(let i = 0; i < 64; i++){
            const sigma1 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotr"])(E, 6) ^ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotr"])(E, 11) ^ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotr"])(E, 25);
            const T1 = H + sigma1 + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Chi"])(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
            const sigma0 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotr"])(A, 2) ^ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotr"])(A, 13) ^ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["rotr"])(A, 22);
            const T2 = sigma0 + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$_md$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Maj"])(A, B, C) | 0;
            H = G;
            G = F;
            F = E;
            E = D + T1 | 0;
            D = C;
            C = B;
            B = A;
            A = T1 + T2 | 0;
        }
        // Add the compressed chunk to the current hash value
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
    }
    roundClean() {
        SHA256_W.fill(0);
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
    }
}
/**
 * Constants taken from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf.
 */ class SHA224 extends SHA256 {
    constructor(){
        super();
        this.A = 0xc1059ed8 | 0;
        this.B = 0x367cd507 | 0;
        this.C = 0x3070dd17 | 0;
        this.D = 0xf70e5939 | 0;
        this.E = 0xffc00b31 | 0;
        this.F = 0x68581511 | 0;
        this.G = 0x64f98fa7 | 0;
        this.H = 0xbefa4fa4 | 0;
        this.outputLen = 28;
    }
}
const sha256 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["wrapConstructor"])(()=>new SHA256());
const sha224 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["wrapConstructor"])(()=>new SHA224()); //# sourceMappingURL=sha256.js.map
}),
"[project]/node_modules/@scure/base/lib/esm/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */ __turbopack_context__.s([
    "base16",
    ()=>base16,
    "base32",
    ()=>base32,
    "base32crockford",
    ()=>base32crockford,
    "base32hex",
    ()=>base32hex,
    "base32hexnopad",
    ()=>base32hexnopad,
    "base32nopad",
    ()=>base32nopad,
    "base58",
    ()=>base58,
    "base58check",
    ()=>base58check,
    "base58flickr",
    ()=>base58flickr,
    "base58xmr",
    ()=>base58xmr,
    "base58xrp",
    ()=>base58xrp,
    "base64",
    ()=>base64,
    "base64nopad",
    ()=>base64nopad,
    "base64url",
    ()=>base64url,
    "base64urlnopad",
    ()=>base64urlnopad,
    "bech32",
    ()=>bech32,
    "bech32m",
    ()=>bech32m,
    "bytes",
    ()=>bytes,
    "bytesToString",
    ()=>bytesToString,
    "createBase58check",
    ()=>createBase58check,
    "hex",
    ()=>hex,
    "str",
    ()=>str,
    "stringToBytes",
    ()=>stringToBytes,
    "utf8",
    ()=>utf8,
    "utils",
    ()=>utils
]);
function isBytes(a) {
    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array';
}
/** Asserts something is Uint8Array. */ function abytes(b, ...lengths) {
    if (!isBytes(b)) throw new Error('Uint8Array expected');
    if (lengths.length > 0 && !lengths.includes(b.length)) throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);
}
function isArrayOf(isString, arr) {
    if (!Array.isArray(arr)) return false;
    if (arr.length === 0) return true;
    if (isString) {
        return arr.every((item)=>typeof item === 'string');
    } else {
        return arr.every((item)=>Number.isSafeInteger(item));
    }
}
// no abytes: seems to have 10% slowdown. Why?!
function afn(input) {
    if (typeof input !== 'function') throw new Error('function expected');
    return true;
}
function astr(label, input) {
    if (typeof input !== 'string') throw new Error(`${label}: string expected`);
    return true;
}
function anumber(n) {
    if (!Number.isSafeInteger(n)) throw new Error(`invalid integer: ${n}`);
}
function aArr(input) {
    if (!Array.isArray(input)) throw new Error('array expected');
}
function astrArr(label, input) {
    if (!isArrayOf(true, input)) throw new Error(`${label}: array of strings expected`);
}
function anumArr(label, input) {
    if (!isArrayOf(false, input)) throw new Error(`${label}: array of numbers expected`);
}
/**
 * @__NO_SIDE_EFFECTS__
 */ function chain(...args) {
    const id = (a)=>a;
    // Wrap call in closure so JIT can inline calls
    const wrap = (a, b)=>(c)=>a(b(c));
    // Construct chain of args[-1].encode(args[-2].encode([...]))
    const encode = args.map((x)=>x.encode).reduceRight(wrap, id);
    // Construct chain of args[0].decode(args[1].decode(...))
    const decode = args.map((x)=>x.decode).reduce(wrap, id);
    return {
        encode,
        decode
    };
}
/**
 * Encodes integer radix representation to array of strings using alphabet and back.
 * Could also be array of strings.
 * @__NO_SIDE_EFFECTS__
 */ function alphabet(letters) {
    // mapping 1 to "b"
    const lettersA = typeof letters === 'string' ? letters.split('') : letters;
    const len = lettersA.length;
    astrArr('alphabet', lettersA);
    // mapping "b" to 1
    const indexes = new Map(lettersA.map((l, i)=>[
            l,
            i
        ]));
    return {
        encode: (digits)=>{
            aArr(digits);
            return digits.map((i)=>{
                if (!Number.isSafeInteger(i) || i < 0 || i >= len) throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${letters}`);
                return lettersA[i];
            });
        },
        decode: (input)=>{
            aArr(input);
            return input.map((letter)=>{
                astr('alphabet.decode', letter);
                const i = indexes.get(letter);
                if (i === undefined) throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
                return i;
            });
        }
    };
}
/**
 * @__NO_SIDE_EFFECTS__
 */ function join(separator = '') {
    astr('join', separator);
    return {
        encode: (from)=>{
            astrArr('join.decode', from);
            return from.join(separator);
        },
        decode: (to)=>{
            astr('join.decode', to);
            return to.split(separator);
        }
    };
}
/**
 * Pad strings array so it has integer number of bits
 * @__NO_SIDE_EFFECTS__
 */ function padding(bits, chr = '=') {
    anumber(bits);
    astr('padding', chr);
    return {
        encode (data) {
            astrArr('padding.encode', data);
            while(data.length * bits % 8)data.push(chr);
            return data;
        },
        decode (input) {
            astrArr('padding.decode', input);
            let end = input.length;
            if (end * bits % 8) throw new Error('padding: invalid, string should have whole number of bytes');
            for(; end > 0 && input[end - 1] === chr; end--){
                const last = end - 1;
                const byte = last * bits;
                if (byte % 8 === 0) throw new Error('padding: invalid, string has too much padding');
            }
            return input.slice(0, end);
        }
    };
}
/**
 * @__NO_SIDE_EFFECTS__
 */ function normalize(fn) {
    afn(fn);
    return {
        encode: (from)=>from,
        decode: (to)=>fn(to)
    };
}
/**
 * Slow: O(n^2) time complexity
 */ function convertRadix(data, from, to) {
    // base 1 is impossible
    if (from < 2) throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);
    if (to < 2) throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);
    aArr(data);
    if (!data.length) return [];
    let pos = 0;
    const res = [];
    const digits = Array.from(data, (d)=>{
        anumber(d);
        if (d < 0 || d >= from) throw new Error(`invalid integer: ${d}`);
        return d;
    });
    const dlen = digits.length;
    while(true){
        let carry = 0;
        let done = true;
        for(let i = pos; i < dlen; i++){
            const digit = digits[i];
            const fromCarry = from * carry;
            const digitBase = fromCarry + digit;
            if (!Number.isSafeInteger(digitBase) || fromCarry / from !== carry || digitBase - digit !== fromCarry) {
                throw new Error('convertRadix: carry overflow');
            }
            const div = digitBase / to;
            carry = digitBase % to;
            const rounded = Math.floor(div);
            digits[i] = rounded;
            if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase) throw new Error('convertRadix: carry overflow');
            if (!done) continue;
            else if (!rounded) pos = i;
            else done = false;
        }
        res.push(carry);
        if (done) break;
    }
    for(let i = 0; i < data.length - 1 && data[i] === 0; i++)res.push(0);
    return res.reverse();
}
const gcd = (a, b)=>b === 0 ? a : gcd(b, a % b);
const radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from, to)=>from + (to - gcd(from, to));
const powers = /* @__PURE__ */ (()=>{
    let res = [];
    for(let i = 0; i < 40; i++)res.push(2 ** i);
    return res;
})();
/**
 * Implemented with numbers, because BigInt is 5x slower
 */ function convertRadix2(data, from, to, padding) {
    aArr(data);
    if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);
    if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);
    if (radix2carry(from, to) > 32) {
        throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
    }
    let carry = 0;
    let pos = 0; // bitwise position in current element
    const max = powers[from];
    const mask = powers[to] - 1;
    const res = [];
    for (const n of data){
        anumber(n);
        if (n >= max) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);
        carry = carry << from | n;
        if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
        pos += from;
        for(; pos >= to; pos -= to)res.push((carry >> pos - to & mask) >>> 0);
        const pow = powers[pos];
        if (pow === undefined) throw new Error('invalid carry');
        carry &= pow - 1; // clean carry, otherwise it will cause overflow
    }
    carry = carry << to - pos & mask;
    if (!padding && pos >= from) throw new Error('Excess padding');
    if (!padding && carry > 0) throw new Error(`Non-zero padding: ${carry}`);
    if (padding && pos > 0) res.push(carry >>> 0);
    return res;
}
/**
 * @__NO_SIDE_EFFECTS__
 */ function radix(num) {
    anumber(num);
    const _256 = 2 ** 8;
    return {
        encode: (bytes)=>{
            if (!isBytes(bytes)) throw new Error('radix.encode input should be Uint8Array');
            return convertRadix(Array.from(bytes), _256, num);
        },
        decode: (digits)=>{
            anumArr('radix.decode', digits);
            return Uint8Array.from(convertRadix(digits, num, _256));
        }
    };
}
/**
 * If both bases are power of same number (like `2**8 <-> 2**64`),
 * there is a linear algorithm. For now we have implementation for power-of-two bases only.
 * @__NO_SIDE_EFFECTS__
 */ function radix2(bits, revPadding = false) {
    anumber(bits);
    if (bits <= 0 || bits > 32) throw new Error('radix2: bits should be in (0..32]');
    if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32) throw new Error('radix2: carry overflow');
    return {
        encode: (bytes)=>{
            if (!isBytes(bytes)) throw new Error('radix2.encode input should be Uint8Array');
            return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
        },
        decode: (digits)=>{
            anumArr('radix2.decode', digits);
            return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
        }
    };
}
function unsafeWrapper(fn) {
    afn(fn);
    return function(...args) {
        try {
            return fn.apply(null, args);
        } catch (e) {}
    };
}
function checksum(len, fn) {
    anumber(len);
    afn(fn);
    return {
        encode (data) {
            if (!isBytes(data)) throw new Error('checksum.encode: input should be Uint8Array');
            const sum = fn(data).slice(0, len);
            const res = new Uint8Array(data.length + len);
            res.set(data);
            res.set(sum, data.length);
            return res;
        },
        decode (data) {
            if (!isBytes(data)) throw new Error('checksum.decode: input should be Uint8Array');
            const payload = data.slice(0, -len);
            const oldChecksum = data.slice(-len);
            const newChecksum = fn(payload).slice(0, len);
            for(let i = 0; i < len; i++)if (newChecksum[i] !== oldChecksum[i]) throw new Error('Invalid checksum');
            return payload;
        }
    };
}
const utils = {
    alphabet,
    chain,
    checksum,
    convertRadix,
    convertRadix2,
    radix,
    radix2,
    join,
    padding
};
const base16 = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));
const base32 = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), padding(5), join(''));
const base32nopad = chain(radix2(5), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'), join(''));
const base32hex = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), padding(5), join(''));
const base32hexnopad = chain(radix2(5), alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'), join(''));
const base32crockford = chain(radix2(5), alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'), join(''), normalize((s)=>s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1')));
// Built-in base64 conversion https://caniuse.com/mdn-javascript_builtins_uint8array_frombase64
// prettier-ignore
const hasBase64Builtin = /* @__PURE__ */ (()=>typeof Uint8Array.from([]).toBase64 === 'function' && typeof Uint8Array.fromBase64 === 'function')();
const decodeBase64Builtin = (s, isUrl)=>{
    astr('base64', s);
    const re = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;
    const alphabet = isUrl ? 'base64url' : 'base64';
    if (s.length > 0 && !re.test(s)) throw new Error('invalid base64');
    return Uint8Array.fromBase64(s, {
        alphabet,
        lastChunkHandling: 'strict'
    });
};
const base64 = hasBase64Builtin ? {
    encode (b) {
        abytes(b);
        return b.toBase64();
    },
    decode (s) {
        return decodeBase64Builtin(s, false);
    }
} : chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), padding(6), join(''));
const base64nopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'), join(''));
const base64url = hasBase64Builtin ? {
    encode (b) {
        abytes(b);
        return b.toBase64({
            alphabet: 'base64url'
        });
    },
    decode (s) {
        return decodeBase64Builtin(s, true);
    }
} : chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), padding(6), join(''));
const base64urlnopad = chain(radix2(6), alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'), join(''));
// base58 code
// -----------
const genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc)=>chain(radix(58), alphabet(abc), join(''));
const base58 = genBase58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz');
const base58flickr = genBase58('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ');
const base58xrp = genBase58('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz');
// Data len (index) -> encoded block len
const XMR_BLOCK_LEN = [
    0,
    2,
    3,
    5,
    6,
    7,
    9,
    10,
    11
];
const base58xmr = {
    encode (data) {
        let res = '';
        for(let i = 0; i < data.length; i += 8){
            const block = data.subarray(i, i + 8);
            res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length], '1');
        }
        return res;
    },
    decode (str) {
        let res = [];
        for(let i = 0; i < str.length; i += 11){
            const slice = str.slice(i, i + 11);
            const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);
            const block = base58.decode(slice);
            for(let j = 0; j < block.length - blockLen; j++){
                if (block[j] !== 0) throw new Error('base58xmr: wrong padding');
            }
            res = res.concat(Array.from(block.slice(block.length - blockLen)));
        }
        return Uint8Array.from(res);
    }
};
const createBase58check = (sha256)=>chain(checksum(4, (data)=>sha256(sha256(data))), base58);
const base58check = createBase58check;
const BECH_ALPHABET = chain(alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'), join(''));
const POLYMOD_GENERATORS = [
    0x3b6a57b2,
    0x26508e6d,
    0x1ea119fa,
    0x3d4233dd,
    0x2a1462b3
];
function bech32Polymod(pre) {
    const b = pre >> 25;
    let chk = (pre & 0x1ffffff) << 5;
    for(let i = 0; i < POLYMOD_GENERATORS.length; i++){
        if ((b >> i & 1) === 1) chk ^= POLYMOD_GENERATORS[i];
    }
    return chk;
}
function bechChecksum(prefix, words, encodingConst = 1) {
    const len = prefix.length;
    let chk = 1;
    for(let i = 0; i < len; i++){
        const c = prefix.charCodeAt(i);
        if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);
        chk = bech32Polymod(chk) ^ c >> 5;
    }
    chk = bech32Polymod(chk);
    for(let i = 0; i < len; i++)chk = bech32Polymod(chk) ^ prefix.charCodeAt(i) & 0x1f;
    for (let v of words)chk = bech32Polymod(chk) ^ v;
    for(let i = 0; i < 6; i++)chk = bech32Polymod(chk);
    chk ^= encodingConst;
    return BECH_ALPHABET.encode(convertRadix2([
        chk % powers[30]
    ], 30, 5, false));
}
/**
 * @__NO_SIDE_EFFECTS__
 */ function genBech32(encoding) {
    const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;
    const _words = radix2(5);
    const fromWords = _words.decode;
    const toWords = _words.encode;
    const fromWordsUnsafe = unsafeWrapper(fromWords);
    function encode(prefix, words, limit = 90) {
        astr('bech32.encode prefix', prefix);
        if (isBytes(words)) words = Array.from(words);
        anumArr('bech32.encode', words);
        const plen = prefix.length;
        if (plen === 0) throw new TypeError(`Invalid prefix length ${plen}`);
        const actualLength = plen + 7 + words.length;
        if (limit !== false && actualLength > limit) throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
        const lowered = prefix.toLowerCase();
        const sum = bechChecksum(lowered, words, ENCODING_CONST);
        return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
    }
    function decode(str, limit = 90) {
        astr('bech32.decode input', str);
        const slen = str.length;
        if (slen < 8 || limit !== false && slen > limit) throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);
        // don't allow mixed case
        const lowered = str.toLowerCase();
        if (str !== lowered && str !== str.toUpperCase()) throw new Error(`String must be lowercase or uppercase`);
        const sepIndex = lowered.lastIndexOf('1');
        if (sepIndex === 0 || sepIndex === -1) throw new Error(`Letter "1" must be present between prefix and data only`);
        const prefix = lowered.slice(0, sepIndex);
        const data = lowered.slice(sepIndex + 1);
        if (data.length < 6) throw new Error('Data must be at least 6 characters long');
        const words = BECH_ALPHABET.decode(data).slice(0, -6);
        const sum = bechChecksum(prefix, words, ENCODING_CONST);
        if (!data.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
        return {
            prefix,
            words
        };
    }
    const decodeUnsafe = unsafeWrapper(decode);
    function decodeToBytes(str) {
        const { prefix, words } = decode(str, false);
        return {
            prefix,
            words,
            bytes: fromWords(words)
        };
    }
    function encodeFromBytes(prefix, bytes) {
        return encode(prefix, toWords(bytes));
    }
    return {
        encode,
        decode,
        encodeFromBytes,
        decodeToBytes,
        decodeUnsafe,
        fromWords,
        fromWordsUnsafe,
        toWords
    };
}
const bech32 = genBech32('bech32');
const bech32m = genBech32('bech32m');
const utf8 = {
    encode: (data)=>new TextDecoder().decode(data),
    decode: (str)=>new TextEncoder().encode(str)
};
// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex
// prettier-ignore
const hasHexBuiltin = /* @__PURE__ */ (()=>typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();
// prettier-ignore
const hexBuiltin = {
    encode (data) {
        abytes(data);
        return data.toHex();
    },
    decode (s) {
        astr('hex', s);
        return Uint8Array.fromHex(s);
    }
};
const hex = hasHexBuiltin ? hexBuiltin : chain(radix2(4), alphabet('0123456789abcdef'), join(''), normalize((s)=>{
    if (typeof s !== 'string' || s.length % 2 !== 0) throw new TypeError(`hex.decode: expected string, got ${typeof s} with length ${s.length}`);
    return s.toLowerCase();
}));
// prettier-ignore
const CODERS = {
    utf8,
    hex,
    base16,
    base32,
    base64,
    base64url,
    base58,
    base58xmr
};
const coderTypeError = 'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';
const bytesToString = (type, bytes)=>{
    if (typeof type !== 'string' || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);
    if (!isBytes(bytes)) throw new TypeError('bytesToString() expects Uint8Array');
    return CODERS[type].encode(bytes);
};
const str = bytesToString; // as in python, but for bytes only
const stringToBytes = (type, str)=>{
    if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);
    if (typeof str !== 'string') throw new TypeError('stringToBytes() expects string');
    return CODERS[type].decode(str);
};
const bytes = stringToBytes; //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/@scure/bip39/esm/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Audited & minimal JS implementation of
 * [BIP39 mnemonic phrases](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki).
 * @module
 * @example
```js
import * as bip39 from '@scure/bip39';
import { wordlist } from '@scure/bip39/wordlists/english';
const mn = bip39.generateMnemonic(wordlist);
console.log(mn);
const ent = bip39.mnemonicToEntropy(mn, wordlist)
bip39.entropyToMnemonic(ent, wordlist);
bip39.validateMnemonic(mn, wordlist);
await bip39.mnemonicToSeed(mn, 'password');
bip39.mnemonicToSeedSync(mn, 'password');

// Wordlists
import { wordlist as czech } from '@scure/bip39/wordlists/czech';
import { wordlist as english } from '@scure/bip39/wordlists/english';
import { wordlist as french } from '@scure/bip39/wordlists/french';
import { wordlist as italian } from '@scure/bip39/wordlists/italian';
import { wordlist as japanese } from '@scure/bip39/wordlists/japanese';
import { wordlist as korean } from '@scure/bip39/wordlists/korean';
import { wordlist as portuguese } from '@scure/bip39/wordlists/portuguese';
import { wordlist as simplifiedChinese } from '@scure/bip39/wordlists/simplified-chinese';
import { wordlist as spanish } from '@scure/bip39/wordlists/spanish';
import { wordlist as traditionalChinese } from '@scure/bip39/wordlists/traditional-chinese';
```
 */ /*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) */ __turbopack_context__.s([
    "entropyToMnemonic",
    ()=>entropyToMnemonic,
    "generateMnemonic",
    ()=>generateMnemonic,
    "mnemonicToEntropy",
    ()=>mnemonicToEntropy,
    "mnemonicToSeed",
    ()=>mnemonicToSeed,
    "mnemonicToSeedSync",
    ()=>mnemonicToSeedSync,
    "validateMnemonic",
    ()=>validateMnemonic
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$pbkdf2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@scure/bip39/node_modules/@noble/hashes/esm/pbkdf2.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@scure/bip39/node_modules/@noble/hashes/esm/sha2.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@scure/bip39/node_modules/@noble/hashes/esm/utils.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$base$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@scure/base/lib/esm/index.js [app-client] (ecmascript)");
;
;
;
;
// Japanese wordlist
const isJapanese = (wordlist)=>wordlist[0] === '\u3042\u3044\u3053\u304f\u3057\u3093';
// Normalization replaces equivalent sequences of characters
// so that any two texts that are equivalent will be reduced
// to the same sequence of code points, called the normal form of the original text.
// https://tonsky.me/blog/unicode/#why-is-a----
function nfkd(str) {
    if (typeof str !== 'string') throw new TypeError('invalid mnemonic type: ' + typeof str);
    return str.normalize('NFKD');
}
function normalize(str) {
    const norm = nfkd(str);
    const words = norm.split(' ');
    if (![
        12,
        15,
        18,
        21,
        24
    ].includes(words.length)) throw new Error('Invalid mnemonic');
    return {
        nfkd: norm,
        words
    };
}
function aentropy(ent) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["abytes"])(ent, 16, 20, 24, 28, 32);
}
function generateMnemonic(wordlist, strength = 128) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["anumber"])(strength);
    if (strength % 32 !== 0 || strength > 256) throw new TypeError('Invalid entropy');
    return entropyToMnemonic((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$utils$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["randomBytes"])(strength / 8), wordlist);
}
const calcChecksum = (entropy)=>{
    // Checksum is ent.length/4 bits long
    const bitsLeft = 8 - entropy.length / 4;
    // Zero rightmost "bitsLeft" bits in byte
    // For example: bitsLeft=4 val=10111101 -> 10110000
    return new Uint8Array([
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sha256"])(entropy)[0] >> bitsLeft << bitsLeft
    ]);
};
function getCoder(wordlist) {
    if (!Array.isArray(wordlist) || wordlist.length !== 2048 || typeof wordlist[0] !== 'string') throw new Error('Wordlist: expected array of 2048 strings');
    wordlist.forEach((i)=>{
        if (typeof i !== 'string') throw new Error('wordlist: non-string element: ' + i);
    });
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$base$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["utils"].chain(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$base$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["utils"].checksum(1, calcChecksum), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$base$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["utils"].radix2(11, true), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$base$2f$lib$2f$esm$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["utils"].alphabet(wordlist));
}
function mnemonicToEntropy(mnemonic, wordlist) {
    const { words } = normalize(mnemonic);
    const entropy = getCoder(wordlist).decode(words);
    aentropy(entropy);
    return entropy;
}
function entropyToMnemonic(entropy, wordlist) {
    aentropy(entropy);
    const words = getCoder(wordlist).encode(entropy);
    return words.join(isJapanese(wordlist) ? '\u3000' : ' ');
}
function validateMnemonic(mnemonic, wordlist) {
    try {
        mnemonicToEntropy(mnemonic, wordlist);
    } catch (e) {
        return false;
    }
    return true;
}
const psalt = (passphrase)=>nfkd('mnemonic' + passphrase);
function mnemonicToSeed(mnemonic, passphrase = '') {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$pbkdf2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pbkdf2Async"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sha512"], normalize(mnemonic).nfkd, psalt(passphrase), {
        c: 2048,
        dkLen: 64
    });
}
function mnemonicToSeedSync(mnemonic, passphrase = '') {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$pbkdf2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pbkdf2"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$scure$2f$bip39$2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha2$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sha512"], normalize(mnemonic).nfkd, psalt(passphrase), {
        c: 2048,
        dkLen: 64
    });
}
}),
"[project]/node_modules/@scure/bip39/esm/wordlists/english.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "wordlist",
    ()=>wordlist
]);
const wordlist = `abandon
ability
able
about
above
absent
absorb
abstract
absurd
abuse
access
accident
account
accuse
achieve
acid
acoustic
acquire
across
act
action
actor
actress
actual
adapt
add
addict
address
adjust
admit
adult
advance
advice
aerobic
affair
afford
afraid
again
age
agent
agree
ahead
aim
air
airport
aisle
alarm
album
alcohol
alert
alien
all
alley
allow
almost
alone
alpha
already
also
alter
always
amateur
amazing
among
amount
amused
analyst
anchor
ancient
anger
angle
angry
animal
ankle
announce
annual
another
answer
antenna
antique
anxiety
any
apart
apology
appear
apple
approve
april
arch
arctic
area
arena
argue
arm
armed
armor
army
around
arrange
arrest
arrive
arrow
art
artefact
artist
artwork
ask
aspect
assault
asset
assist
assume
asthma
athlete
atom
attack
attend
attitude
attract
auction
audit
august
aunt
author
auto
autumn
average
avocado
avoid
awake
aware
away
awesome
awful
awkward
axis
baby
bachelor
bacon
badge
bag
balance
balcony
ball
bamboo
banana
banner
bar
barely
bargain
barrel
base
basic
basket
battle
beach
bean
beauty
because
become
beef
before
begin
behave
behind
believe
below
belt
bench
benefit
best
betray
better
between
beyond
bicycle
bid
bike
bind
biology
bird
birth
bitter
black
blade
blame
blanket
blast
bleak
bless
blind
blood
blossom
blouse
blue
blur
blush
board
boat
body
boil
bomb
bone
bonus
book
boost
border
boring
borrow
boss
bottom
bounce
box
boy
bracket
brain
brand
brass
brave
bread
breeze
brick
bridge
brief
bright
bring
brisk
broccoli
broken
bronze
broom
brother
brown
brush
bubble
buddy
budget
buffalo
build
bulb
bulk
bullet
bundle
bunker
burden
burger
burst
bus
business
busy
butter
buyer
buzz
cabbage
cabin
cable
cactus
cage
cake
call
calm
camera
camp
can
canal
cancel
candy
cannon
canoe
canvas
canyon
capable
capital
captain
car
carbon
card
cargo
carpet
carry
cart
case
cash
casino
castle
casual
cat
catalog
catch
category
cattle
caught
cause
caution
cave
ceiling
celery
cement
census
century
cereal
certain
chair
chalk
champion
change
chaos
chapter
charge
chase
chat
cheap
check
cheese
chef
cherry
chest
chicken
chief
child
chimney
choice
choose
chronic
chuckle
chunk
churn
cigar
cinnamon
circle
citizen
city
civil
claim
clap
clarify
claw
clay
clean
clerk
clever
click
client
cliff
climb
clinic
clip
clock
clog
close
cloth
cloud
clown
club
clump
cluster
clutch
coach
coast
coconut
code
coffee
coil
coin
collect
color
column
combine
come
comfort
comic
common
company
concert
conduct
confirm
congress
connect
consider
control
convince
cook
cool
copper
copy
coral
core
corn
correct
cost
cotton
couch
country
couple
course
cousin
cover
coyote
crack
cradle
craft
cram
crane
crash
crater
crawl
crazy
cream
credit
creek
crew
cricket
crime
crisp
critic
crop
cross
crouch
crowd
crucial
cruel
cruise
crumble
crunch
crush
cry
crystal
cube
culture
cup
cupboard
curious
current
curtain
curve
cushion
custom
cute
cycle
dad
damage
damp
dance
danger
daring
dash
daughter
dawn
day
deal
debate
debris
decade
december
decide
decline
decorate
decrease
deer
defense
define
defy
degree
delay
deliver
demand
demise
denial
dentist
deny
depart
depend
deposit
depth
deputy
derive
describe
desert
design
desk
despair
destroy
detail
detect
develop
device
devote
diagram
dial
diamond
diary
dice
diesel
diet
differ
digital
dignity
dilemma
dinner
dinosaur
direct
dirt
disagree
discover
disease
dish
dismiss
disorder
display
distance
divert
divide
divorce
dizzy
doctor
document
dog
doll
dolphin
domain
donate
donkey
donor
door
dose
double
dove
draft
dragon
drama
drastic
draw
dream
dress
drift
drill
drink
drip
drive
drop
drum
dry
duck
dumb
dune
during
dust
dutch
duty
dwarf
dynamic
eager
eagle
early
earn
earth
easily
east
easy
echo
ecology
economy
edge
edit
educate
effort
egg
eight
either
elbow
elder
electric
elegant
element
elephant
elevator
elite
else
embark
embody
embrace
emerge
emotion
employ
empower
empty
enable
enact
end
endless
endorse
enemy
energy
enforce
engage
engine
enhance
enjoy
enlist
enough
enrich
enroll
ensure
enter
entire
entry
envelope
episode
equal
equip
era
erase
erode
erosion
error
erupt
escape
essay
essence
estate
eternal
ethics
evidence
evil
evoke
evolve
exact
example
excess
exchange
excite
exclude
excuse
execute
exercise
exhaust
exhibit
exile
exist
exit
exotic
expand
expect
expire
explain
expose
express
extend
extra
eye
eyebrow
fabric
face
faculty
fade
faint
faith
fall
false
fame
family
famous
fan
fancy
fantasy
farm
fashion
fat
fatal
father
fatigue
fault
favorite
feature
february
federal
fee
feed
feel
female
fence
festival
fetch
fever
few
fiber
fiction
field
figure
file
film
filter
final
find
fine
finger
finish
fire
firm
first
fiscal
fish
fit
fitness
fix
flag
flame
flash
flat
flavor
flee
flight
flip
float
flock
floor
flower
fluid
flush
fly
foam
focus
fog
foil
fold
follow
food
foot
force
forest
forget
fork
fortune
forum
forward
fossil
foster
found
fox
fragile
frame
frequent
fresh
friend
fringe
frog
front
frost
frown
frozen
fruit
fuel
fun
funny
furnace
fury
future
gadget
gain
galaxy
gallery
game
gap
garage
garbage
garden
garlic
garment
gas
gasp
gate
gather
gauge
gaze
general
genius
genre
gentle
genuine
gesture
ghost
giant
gift
giggle
ginger
giraffe
girl
give
glad
glance
glare
glass
glide
glimpse
globe
gloom
glory
glove
glow
glue
goat
goddess
gold
good
goose
gorilla
gospel
gossip
govern
gown
grab
grace
grain
grant
grape
grass
gravity
great
green
grid
grief
grit
grocery
group
grow
grunt
guard
guess
guide
guilt
guitar
gun
gym
habit
hair
half
hammer
hamster
hand
happy
harbor
hard
harsh
harvest
hat
have
hawk
hazard
head
health
heart
heavy
hedgehog
height
hello
helmet
help
hen
hero
hidden
high
hill
hint
hip
hire
history
hobby
hockey
hold
hole
holiday
hollow
home
honey
hood
hope
horn
horror
horse
hospital
host
hotel
hour
hover
hub
huge
human
humble
humor
hundred
hungry
hunt
hurdle
hurry
hurt
husband
hybrid
ice
icon
idea
identify
idle
ignore
ill
illegal
illness
image
imitate
immense
immune
impact
impose
improve
impulse
inch
include
income
increase
index
indicate
indoor
industry
infant
inflict
inform
inhale
inherit
initial
inject
injury
inmate
inner
innocent
input
inquiry
insane
insect
inside
inspire
install
intact
interest
into
invest
invite
involve
iron
island
isolate
issue
item
ivory
jacket
jaguar
jar
jazz
jealous
jeans
jelly
jewel
job
join
joke
journey
joy
judge
juice
jump
jungle
junior
junk
just
kangaroo
keen
keep
ketchup
key
kick
kid
kidney
kind
kingdom
kiss
kit
kitchen
kite
kitten
kiwi
knee
knife
knock
know
lab
label
labor
ladder
lady
lake
lamp
language
laptop
large
later
latin
laugh
laundry
lava
law
lawn
lawsuit
layer
lazy
leader
leaf
learn
leave
lecture
left
leg
legal
legend
leisure
lemon
lend
length
lens
leopard
lesson
letter
level
liar
liberty
library
license
life
lift
light
like
limb
limit
link
lion
liquid
list
little
live
lizard
load
loan
lobster
local
lock
logic
lonely
long
loop
lottery
loud
lounge
love
loyal
lucky
luggage
lumber
lunar
lunch
luxury
lyrics
machine
mad
magic
magnet
maid
mail
main
major
make
mammal
man
manage
mandate
mango
mansion
manual
maple
marble
march
margin
marine
market
marriage
mask
mass
master
match
material
math
matrix
matter
maximum
maze
meadow
mean
measure
meat
mechanic
medal
media
melody
melt
member
memory
mention
menu
mercy
merge
merit
merry
mesh
message
metal
method
middle
midnight
milk
million
mimic
mind
minimum
minor
minute
miracle
mirror
misery
miss
mistake
mix
mixed
mixture
mobile
model
modify
mom
moment
monitor
monkey
monster
month
moon
moral
more
morning
mosquito
mother
motion
motor
mountain
mouse
move
movie
much
muffin
mule
multiply
muscle
museum
mushroom
music
must
mutual
myself
mystery
myth
naive
name
napkin
narrow
nasty
nation
nature
near
neck
need
negative
neglect
neither
nephew
nerve
nest
net
network
neutral
never
news
next
nice
night
noble
noise
nominee
noodle
normal
north
nose
notable
note
nothing
notice
novel
now
nuclear
number
nurse
nut
oak
obey
object
oblige
obscure
observe
obtain
obvious
occur
ocean
october
odor
off
offer
office
often
oil
okay
old
olive
olympic
omit
once
one
onion
online
only
open
opera
opinion
oppose
option
orange
orbit
orchard
order
ordinary
organ
orient
original
orphan
ostrich
other
outdoor
outer
output
outside
oval
oven
over
own
owner
oxygen
oyster
ozone
pact
paddle
page
pair
palace
palm
panda
panel
panic
panther
paper
parade
parent
park
parrot
party
pass
patch
path
patient
patrol
pattern
pause
pave
payment
peace
peanut
pear
peasant
pelican
pen
penalty
pencil
people
pepper
perfect
permit
person
pet
phone
photo
phrase
physical
piano
picnic
picture
piece
pig
pigeon
pill
pilot
pink
pioneer
pipe
pistol
pitch
pizza
place
planet
plastic
plate
play
please
pledge
pluck
plug
plunge
poem
poet
point
polar
pole
police
pond
pony
pool
popular
portion
position
possible
post
potato
pottery
poverty
powder
power
practice
praise
predict
prefer
prepare
present
pretty
prevent
price
pride
primary
print
priority
prison
private
prize
problem
process
produce
profit
program
project
promote
proof
property
prosper
protect
proud
provide
public
pudding
pull
pulp
pulse
pumpkin
punch
pupil
puppy
purchase
purity
purpose
purse
push
put
puzzle
pyramid
quality
quantum
quarter
question
quick
quit
quiz
quote
rabbit
raccoon
race
rack
radar
radio
rail
rain
raise
rally
ramp
ranch
random
range
rapid
rare
rate
rather
raven
raw
razor
ready
real
reason
rebel
rebuild
recall
receive
recipe
record
recycle
reduce
reflect
reform
refuse
region
regret
regular
reject
relax
release
relief
rely
remain
remember
remind
remove
render
renew
rent
reopen
repair
repeat
replace
report
require
rescue
resemble
resist
resource
response
result
retire
retreat
return
reunion
reveal
review
reward
rhythm
rib
ribbon
rice
rich
ride
ridge
rifle
right
rigid
ring
riot
ripple
risk
ritual
rival
river
road
roast
robot
robust
rocket
romance
roof
rookie
room
rose
rotate
rough
round
route
royal
rubber
rude
rug
rule
run
runway
rural
sad
saddle
sadness
safe
sail
salad
salmon
salon
salt
salute
same
sample
sand
satisfy
satoshi
sauce
sausage
save
say
scale
scan
scare
scatter
scene
scheme
school
science
scissors
scorpion
scout
scrap
screen
script
scrub
sea
search
season
seat
second
secret
section
security
seed
seek
segment
select
sell
seminar
senior
sense
sentence
series
service
session
settle
setup
seven
shadow
shaft
shallow
share
shed
shell
sheriff
shield
shift
shine
ship
shiver
shock
shoe
shoot
shop
short
shoulder
shove
shrimp
shrug
shuffle
shy
sibling
sick
side
siege
sight
sign
silent
silk
silly
silver
similar
simple
since
sing
siren
sister
situate
six
size
skate
sketch
ski
skill
skin
skirt
skull
slab
slam
sleep
slender
slice
slide
slight
slim
slogan
slot
slow
slush
small
smart
smile
smoke
smooth
snack
snake
snap
sniff
snow
soap
soccer
social
sock
soda
soft
solar
soldier
solid
solution
solve
someone
song
soon
sorry
sort
soul
sound
soup
source
south
space
spare
spatial
spawn
speak
special
speed
spell
spend
sphere
spice
spider
spike
spin
spirit
split
spoil
sponsor
spoon
sport
spot
spray
spread
spring
spy
square
squeeze
squirrel
stable
stadium
staff
stage
stairs
stamp
stand
start
state
stay
steak
steel
stem
step
stereo
stick
still
sting
stock
stomach
stone
stool
story
stove
strategy
street
strike
strong
struggle
student
stuff
stumble
style
subject
submit
subway
success
such
sudden
suffer
sugar
suggest
suit
summer
sun
sunny
sunset
super
supply
supreme
sure
surface
surge
surprise
surround
survey
suspect
sustain
swallow
swamp
swap
swarm
swear
sweet
swift
swim
swing
switch
sword
symbol
symptom
syrup
system
table
tackle
tag
tail
talent
talk
tank
tape
target
task
taste
tattoo
taxi
teach
team
tell
ten
tenant
tennis
tent
term
test
text
thank
that
theme
then
theory
there
they
thing
this
thought
three
thrive
throw
thumb
thunder
ticket
tide
tiger
tilt
timber
time
tiny
tip
tired
tissue
title
toast
tobacco
today
toddler
toe
together
toilet
token
tomato
tomorrow
tone
tongue
tonight
tool
tooth
top
topic
topple
torch
tornado
tortoise
toss
total
tourist
toward
tower
town
toy
track
trade
traffic
tragic
train
transfer
trap
trash
travel
tray
treat
tree
trend
trial
tribe
trick
trigger
trim
trip
trophy
trouble
truck
true
truly
trumpet
trust
truth
try
tube
tuition
tumble
tuna
tunnel
turkey
turn
turtle
twelve
twenty
twice
twin
twist
two
type
typical
ugly
umbrella
unable
unaware
uncle
uncover
under
undo
unfair
unfold
unhappy
uniform
unique
unit
universe
unknown
unlock
until
unusual
unveil
update
upgrade
uphold
upon
upper
upset
urban
urge
usage
use
used
useful
useless
usual
utility
vacant
vacuum
vague
valid
valley
valve
van
vanish
vapor
various
vast
vault
vehicle
velvet
vendor
venture
venue
verb
verify
version
very
vessel
veteran
viable
vibrant
vicious
victory
video
view
village
vintage
violin
virtual
virus
visa
visit
visual
vital
vivid
vocal
voice
void
volcano
volume
vote
voyage
wage
wagon
wait
walk
wall
walnut
want
warfare
warm
warrior
wash
wasp
waste
water
wave
way
wealth
weapon
wear
weasel
weather
web
wedding
weekend
weird
welcome
west
wet
whale
what
wheat
wheel
when
where
whip
whisper
wide
width
wife
wild
will
win
window
wine
wing
wink
winner
winter
wire
wisdom
wise
wish
witness
wolf
woman
wonder
wood
wool
word
work
world
worry
worth
wrap
wreck
wrestle
wrist
write
wrong
yard
year
yellow
you
young
youth
zebra
zero
zone
zoo`.split('\n');
}),
"[project]/node_modules/one-webcrypto/browser.mjs [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "webcrypto",
    ()=>webcrypto
]);
const _globalReference = globalThis || window || self;
const webcrypto = _globalReference.crypto;
}),
"[project]/node_modules/p-defer/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "default",
    ()=>pDefer
]);
function pDefer() {
    const deferred = {};
    deferred.promise = new Promise((resolve, reject)=>{
        deferred.resolve = resolve;
        deferred.reject = reject;
    });
    return deferred;
}
}),
"[project]/node_modules/@web3-storage/data-segment/src/api.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// @see https://github.com/microsoft/TypeScript/issues/41825
__turbopack_context__.s([]);
;
}),
"[project]/node_modules/@web3-storage/data-segment/src/constant.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * Number of bits per byte
 */ __turbopack_context__.s([
    "BYTES_PER_FR",
    ()=>BYTES_PER_FR,
    "EXPANDED_BYTES_PER_NODE",
    ()=>EXPANDED_BYTES_PER_NODE,
    "EXPANDED_BYTES_PER_QUAD",
    ()=>EXPANDED_BYTES_PER_QUAD,
    "FRS_PER_QUAD",
    ()=>FRS_PER_QUAD,
    "FR_RATIO",
    ()=>FR_RATIO,
    "IN_BITS_FR",
    ()=>IN_BITS_FR,
    "IN_BYTES_PER_QUAD",
    ()=>IN_BYTES_PER_QUAD,
    "LEAFS_PER_QUAD",
    ()=>LEAFS_PER_QUAD,
    "MIN_PAYLOAD_SIZE",
    ()=>MIN_PAYLOAD_SIZE,
    "NODE_SIZE",
    ()=>NODE_SIZE,
    "OUT_BITS_FR",
    ()=>OUT_BITS_FR,
    "OUT_BYTES_PER_QUAD",
    ()=>OUT_BYTES_PER_QUAD,
    "PADDED_BYTES_PER_QUAD",
    ()=>PADDED_BYTES_PER_QUAD
]);
const BITS_PER_BYTE = 8;
const FRS_PER_QUAD = 4;
const LEAFS_PER_QUAD = BigInt(FRS_PER_QUAD);
const IN_BITS_FR = 254;
const OUT_BITS_FR = 256;
const IN_BYTES_PER_QUAD = FRS_PER_QUAD * IN_BITS_FR / BITS_PER_BYTE;
const OUT_BYTES_PER_QUAD = FRS_PER_QUAD * OUT_BITS_FR / BITS_PER_BYTE;
const PADDED_BYTES_PER_QUAD = BigInt(IN_BYTES_PER_QUAD);
const EXPANDED_BYTES_PER_QUAD = BigInt(OUT_BYTES_PER_QUAD);
const BYTES_PER_FR = /** @type {32} */ OUT_BYTES_PER_QUAD / FRS_PER_QUAD;
const FR_RATIO = IN_BITS_FR / OUT_BITS_FR;
const NODE_SIZE = OUT_BYTES_PER_QUAD / FRS_PER_QUAD;
const EXPANDED_BYTES_PER_NODE = BigInt(NODE_SIZE);
const MIN_PAYLOAD_SIZE = 2 * NODE_SIZE + 1;
}),
"[project]/node_modules/@web3-storage/data-segment/src/node.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "empty",
    ()=>empty,
    "from",
    ()=>from,
    "of",
    ()=>of
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/api.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/constant.js [app-client] (ecmascript)");
;
;
;
const of = (...bytes)=>from(bytes);
const from = (bytes)=>{
    /* c8 ignore next 7 */ if (bytes instanceof Uint8Array) {
        if (bytes.length > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NODE_SIZE"]) {
            return bytes.subarray(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NODE_SIZE"]);
        } else if (bytes.length == __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NODE_SIZE"]) {
            return bytes;
        }
    }
    const node = new Uint8Array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NODE_SIZE"]);
    node.set([
        ...bytes
    ]);
    return node;
};
const empty = ()=>EMPTY;
const EMPTY = from(new Uint8Array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NODE_SIZE"]).fill(0));
Object.freeze(EMPTY.buffer);
}),
"[project]/node_modules/@web3-storage/data-segment/src/constant.js [app-client] (ecmascript) <export NODE_SIZE as Size>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Size",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["NODE_SIZE"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/constant.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@web3-storage/data-segment/src/ipld/sha256.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "code",
    ()=>code
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/api.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sync$2d$multihash$2d$sha2$2f$src$2f$sha256$2f$web$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/sync-multihash-sha2/src/sha256/web.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sync$2d$multihash$2d$sha2$2f$src$2f$sha256$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/sync-multihash-sha2/src/sha256/digest.js [app-client] (ecmascript)");
;
;
;
const code = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sync$2d$multihash$2d$sha2$2f$src$2f$sha256$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["code"];
}),
"[project]/node_modules/@web3-storage/data-segment/src/ipld/cbor.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "code",
    ()=>code,
    "decode",
    ()=>decode,
    "encode",
    ()=>encode,
    "name",
    ()=>name
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/api.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-cbor/src/index.js [app-client] (ecmascript)");
;
;
const code = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["code"];
const name = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["name"];
const encode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"];
const decode = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"];
}),
"[project]/node_modules/@web3-storage/data-segment/src/ipld.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createLink",
    ()=>createLink
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/api.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$ipld$2f$sha256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/ipld/sha256.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$ipld$2f$cbor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/ipld/cbor.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/link.js [app-client] (ecmascript) <locals>");
;
;
;
;
const createLink = (bytes, { hasher, codec })=>{
    const digest = hasher.digest(bytes);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["create"](codec.code, digest);
};
}),
"[project]/node_modules/@web3-storage/data-segment/src/ipld/sha256.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "code",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$ipld$2f$sha256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["code"],
    "digest",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sync$2d$multihash$2d$sha2$2f$src$2f$sha256$2f$web$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["digest"],
    "name",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sync$2d$multihash$2d$sha2$2f$src$2f$sha256$2f$web$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["name"],
    "size",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sync$2d$multihash$2d$sha2$2f$src$2f$sha256$2f$web$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["size"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$ipld$2f$sha256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/ipld/sha256.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sync$2d$multihash$2d$sha2$2f$src$2f$sha256$2f$web$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/sync-multihash-sha2/src/sha256/web.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@web3-storage/data-segment/src/ipld/sha256.js [app-client] (ecmascript) <export * as SHA256>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "SHA256",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$ipld$2f$sha256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$ipld$2f$sha256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/ipld/sha256.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@web3-storage/data-segment/src/proof.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "computeNode",
    ()=>computeNode,
    "create",
    ()=>create,
    "depth",
    ()=>depth,
    "from",
    ()=>from,
    "offset",
    ()=>offset,
    "path",
    ()=>path,
    "resolveRoot",
    ()=>resolveRoot,
    "truncate",
    ()=>truncate,
    "truncatedHash",
    ()=>truncatedHash,
    "validateLevelIndex",
    ()=>validateLevelIndex,
    "verify",
    ()=>verify
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/api.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bytes.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/node.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__NODE_SIZE__as__Size$3e$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/constant.js [app-client] (ecmascript) <export NODE_SIZE as Size>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$ipld$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/ipld.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$ipld$2f$sha256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__SHA256$3e$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/ipld/sha256.js [app-client] (ecmascript) <export * as SHA256>");
;
;
;
;
const path = ([, path])=>path;
const offset = ([offset])=>offset;
const depth = (proof)=>path(proof).length;
const verify = (proof, { tree, node })=>{
    const computedRoot = resolveRoot(proof, node);
    if (computedRoot.error) {
        return {
            error: new Error(`computing root: ${computedRoot.error.message}`)
        };
    }
    if (!__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["equals"](computedRoot.ok, tree)) {
        return {
            error: new Error('inclusion proof does not lead to the same root')
        };
    }
    return {
        ok: {}
    };
};
const MAX_DEPTH = 63;
function resolveRoot(proof, node) {
    if (depth(proof) > MAX_DEPTH) {
        return {
            error: new RangeError('merkle proofs with depths greater than 63 are not supported')
        };
    }
    let position = offset(proof);
    if (position >> BigInt(depth(proof)) !== 0n) {
        return {
            error: new RangeError('offset greater than width of the tree')
        };
    }
    let top = node;
    let right = 0n;
    for (const node of path(proof)){
        right = position & 1n;
        position = position >> 1n;
        top = right === 1n ? computeNode(node, top) : computeNode(top, node);
    }
    return {
        ok: top
    };
}
function truncatedHash(payload, options = {}) {
    const hasher = options.hasher || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$ipld$2f$sha256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__SHA256$3e$__["SHA256"];
    const { digest } = hasher.digest(payload);
    return truncate(digest);
}
const computeNode = (left, right, options)=>{
    const payload = new Uint8Array(left.length + right.length);
    payload.set(left, 0);
    payload.set(right, left.length);
    return truncatedHash(payload, options);
};
function truncate(node) {
    node[__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__NODE_SIZE__as__Size$3e$__["Size"] - 1] &= 0b00111111;
    return node;
}
const create = ({ offset, path })=>[
        offset,
        path
    ];
const from = (source)=>{
    const [offset, path] = Array.isArray(source) ? source : [
        source.offset,
        source.path
    ];
    return create({
        offset: BigInt(offset),
        path
    });
};
const validateLevelIndex = (height, level, index)=>{
    if (level < 0) {
        throw new RangeError('level can not be negative');
    }
    if (level > height) {
        throw new RangeError(`level too high: ${level} >= ${height}`);
    }
    if (index > (1 << height - level) - 1) {
        throw new RangeError(`index too large for level: idx ${index}, level ${level} : ${(1 << height - level) - 1}`);
    }
};
}),
"[project]/node_modules/@web3-storage/data-segment/src/zero-comm.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "fromLevel",
    ()=>fromLevel
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/api.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/node.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__NODE_SIZE__as__Size$3e$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/constant.js [app-client] (ecmascript) <export NODE_SIZE as Size>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$proof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/proof.js [app-client] (ecmascript)");
;
;
;
const MAX_LEVEL = 64;
/**
 * This is a lazy zero-comm buffer which we fill up on demand.
 */ class ZeroComm {
    constructor(){
        this.bytes = new Uint8Array(MAX_LEVEL * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__NODE_SIZE__as__Size$3e$__["Size"]);
        this.bytes.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["empty"](), 0);
        /** @private */ this.node = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["empty"]();
        /** @private */ this.length = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__NODE_SIZE__as__Size$3e$__["Size"];
    }
    /**
   * @param {number} start
   * @param {number} end
   */ slice(start, end) {
        while(this.length < end){
            this.node = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$proof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["computeNode"](this.node, this.node);
            this.bytes.set(this.node, this.length);
            this.length += __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__NODE_SIZE__as__Size$3e$__["Size"];
        }
        return this.bytes.subarray(start, end);
    }
}
const ZERO_COMM = new ZeroComm();
const fromLevel = (level)=>{
    if (level < 0 || level >= MAX_LEVEL) {
        throw new Error(`Only levels between 0 and ${MAX_LEVEL - 1} inclusive are available`);
    }
    return ZERO_COMM.slice(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__NODE_SIZE__as__Size$3e$__["Size"] * level, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__NODE_SIZE__as__Size$3e$__["Size"] * (level + 1));
};
}),
"[project]/node_modules/@web3-storage/data-segment/src/piece/tree.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "MAX_LEAF_COUNT",
    ()=>MAX_LEAF_COUNT,
    "allocate",
    ()=>allocate,
    "build",
    ()=>build,
    "fromChunks",
    ()=>fromChunks,
    "fromLeafs",
    ()=>fromLeafs,
    "padLeafs",
    ()=>padLeafs,
    "root",
    ()=>root,
    "split",
    ()=>split
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/api.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/node.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__NODE_SIZE__as__Size$3e$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/constant.js [app-client] (ecmascript) <export NODE_SIZE as Size>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$proof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/proof.js [app-client] (ecmascript)");
;
;
;
;
const MAX_LEAF_COUNT = 2 ** 32 - 1;
function allocate(leafs) {
    const adjustedLeafs = 2 ** Math.ceil(Math.log2(leafs));
    if (adjustedLeafs > MAX_LEAF_COUNT) {
        throw new RangeError(`too many leafs ${adjustedLeafs} exceeds ${MAX_LEAF_COUNT} limit`);
    }
    const height = Math.ceil(Math.log2(adjustedLeafs));
    const nodes = new Array(height + 1);
    for (const level of nodes.keys()){
        nodes[level] = new Array(1 << level);
    }
    return new PieceTree({
        nodes,
        height
    });
}
/**
 * @param {API.TreeData} tree
 */ const depth = (tree)=>{
    return tree.nodes.length;
};
const root = (tree)=>{
    return tree.nodes[0][0];
};
const split = (source)=>{
    const count = source.length / __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__NODE_SIZE__as__Size$3e$__["Size"];
    const chunks = new Array(count);
    for(let n = 0; n < count; n++){
        const offset = n * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__NODE_SIZE__as__Size$3e$__["Size"];
        const chunk = source.subarray(offset, offset + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__NODE_SIZE__as__Size$3e$__["Size"]);
        chunks[n] = chunk;
    }
    return chunks;
};
const build = (source)=>fromChunks(split(source));
const fromChunks = (chunks)=>{
    if (chunks.length === 0) {
        throw new RangeError('Empty source');
    }
    const leafs = chunks //await Promise.all(chunks.map(truncatedHash))
    ;
    return fromLeafs(leafs);
};
const fromLeafs = (leafs)=>{
    const tree = allocate(leafs.length);
    // Set the padded leaf nodes
    tree.nodes[depth(tree) - 1] = padLeafs(leafs);
    let parentNodes = tree.nodes[depth(tree) - 1];
    // Construct the Merkle tree bottom-up, starting from the leafs
    // Note the -1 due to 0-indexing the root level
    for(let level = depth(tree) - 2; level >= 0; level--){
        /** @type {API.MerkleTreeNode[]} */ const currentLevel = new Array(Math.ceil(parentNodes.length / 2));
        // Traverse the level left to right
        for(let i = 0; i + 1 < parentNodes.length; i = i + 2){
            currentLevel[Math.floor(i / 2)] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$proof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["computeNode"](parentNodes[i], parentNodes[i + 1]);
        }
        tree.nodes[level] = currentLevel;
        parentNodes = currentLevel;
    }
    return new PieceTree(tree);
};
const padLeafs = (leafs)=>{
    const paddingAmount = (1 << Math.ceil(Math.log2(leafs.length))) - leafs.length;
    // arrays are zeroed by default in JS
    const paddingLeafs = new Array(paddingAmount);
    return [
        ...leafs,
        ...paddingLeafs
    ];
};
/**
 * @implements {API.PieceTree}
 */ class PieceTree {
    /**
   * @param {object} data
   * @param {API.MerkleTreeNode[][]} data.nodes
   * @param {number} data.height
   */ constructor({ nodes, height }){
        this.nodes = nodes;
        this.height = height;
    }
    get root() {
        return root(this);
    }
    get leafs() {
        const { nodes } = this;
        return nodes[nodes.length - 1];
    }
    get leafCount() {
        return 2 ** this.height;
    }
    /**
   *
   * @param {number} level
   * @param {number} index
   */ node(level, index) {
        const { nodes } = this;
        return nodes[level][index];
    }
}
}),
"[project]/node_modules/@web3-storage/data-segment/src/fr32.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "fromPieceSize",
    ()=>fromPieceSize,
    "pad",
    ()=>pad,
    "toPieceSize",
    ()=>toPieceSize,
    "toZeroPaddedSize",
    ()=>toZeroPaddedSize,
    "unpad",
    ()=>unpad
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/api.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/constant.js [app-client] (ecmascript)");
;
;
function toZeroPaddedSize(payloadSize) {
    const size = Math.max(payloadSize, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MIN_PAYLOAD_SIZE"]);
    const highestBit = Math.floor(Math.log2(size));
    const bound = Math.ceil(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FR_RATIO"] * 2 ** (highestBit + 1));
    // the size is either the closest pow2 number, or the next pow2 number if we
    // don't have space for padding
    return size <= bound ? bound : Math.ceil(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FR_RATIO"] * 2 ** (highestBit + 2));
}
const toPieceSize = (size)=>toZeroPaddedSize(size) / __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FR_RATIO"];
const fromPieceSize = (size)=>size * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["FR_RATIO"];
const pad = (source, output = new Uint8Array(toPieceSize(source.length)))=>{
    const size = toZeroPaddedSize(source.byteLength);
    // Calculate number of quads in the given source
    const quadCount = size / __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IN_BYTES_PER_QUAD"];
    // Cycle over four(4) 31-byte groups, leaving 1 byte in between:
    // 31 + 1 + 31 + 1 + 31 + 1 + 31 = 127
    for(let n = 0; n < quadCount; n++){
        const readOffset = n * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IN_BYTES_PER_QUAD"];
        const writeOffset = n * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OUT_BYTES_PER_QUAD"];
        // First 31 bytes + 6 bits are taken as-is (trimmed later)
        output.set(source.subarray(readOffset, readOffset + 32), writeOffset);
        // first 2-bit "shim" forced into the otherwise identical output
        output[writeOffset + 31] &= 0b00111111;
        // copy next Fr32 preceded with the last two bits of the previous Fr32
        for(let i = 32; i < 64; i++){
            output[writeOffset + i] = source[readOffset + i] << 2 | source[readOffset + i - 1] >> 6;
        }
        // next 2-bit shim
        output[writeOffset + 63] &= 0b00111111;
        for(let i = 64; i < 96; i++){
            output[writeOffset + i] = source[readOffset + i] << 4 | source[readOffset + i - 1] >> 4;
        }
        // next 2-bit shim
        output[writeOffset + 95] &= 0b00111111;
        for(let i = 96; i < 127; i++){
            output[writeOffset + i] = source[readOffset + i] << 6 | source[readOffset + i - 1] >> 2;
        }
        // we shim last 2-bits by shifting the last byte by two bits
        output[writeOffset + 127] = source[readOffset + 126] >> 2;
    }
    return output;
};
const unpad = (source, out = new Uint8Array(fromPieceSize(source.length)))=>{
    const chunks = source.length / 128;
    for(let chunk = 0; chunk < chunks; chunk++){
        const inOffNext = chunk * 128 + 1;
        const outOff = chunk * 127;
        let at = source[chunk * 128];
        for(let i = 0; i < 32; i++){
            const next = source[i + inOffNext];
            out[outOff + i] = at;
            at = next;
        }
        out[outOff + 31] |= at << 6;
        for(let i = 32; i < 64; i++){
            const next = source[i + inOffNext];
            out[outOff + i] = at >> 2;
            out[outOff + i] |= next << 6;
            at = next;
        }
        out[outOff + 63] ^= at << 6 ^ at << 4;
        for(let i = 64; i < 96; i++){
            const next = source[i + inOffNext];
            out[outOff + i] = at >> 4;
            out[outOff + i] |= next << 4;
            at = next;
        }
        out[outOff + 95] ^= at << 4 ^ at << 2;
        for(let i = 96; i < 127; i++){
            const next = source[i + inOffNext];
            out[outOff + i];
            out[outOff + i] = at >> 6;
            out[outOff + i] |= next << 2;
            at = next;
        }
    }
    return out;
};
}),
"[project]/node_modules/@web3-storage/data-segment/src/uint64.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "log2Ceil",
    ()=>log2Ceil,
    "log2Floor",
    ()=>log2Floor,
    "onesCount64",
    ()=>onesCount64,
    "pow2",
    ()=>pow2,
    "trailingZeros64",
    ()=>trailingZeros64
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/api.js [app-client] (ecmascript)");
;
const log2Floor = (n)=>{
    let result = 0n;
    while(n >>= 1n)result++;
    return Number(result);
};
const log2Ceil = (n)=>n <= 1n ? 0 : log2Floor(BigInt(n) - 1n) + 1;
const trailingZeros64 = (n)=>{
    if (n === 0n) {
        return 64;
    }
    let count = 0;
    while((n & 1n) === 0n){
        n >>= 1n;
        count++;
    }
    return count;
};
const onesCount64 = (value)=>{
    let count = 0;
    const mask = 1n;
    for(let i = 0n; i < 64n; i++){
        if ((value & mask << i) !== 0n) {
            count++;
        }
    }
    return count;
};
const pow2 = (n)=>1n << n;
}),
"[project]/node_modules/@web3-storage/data-segment/src/piece/size/padded.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "from",
    ()=>from,
    "fromExpanded",
    ()=>fromExpanded,
    "fromHeight",
    ()=>fromHeight,
    "fromWidth",
    ()=>fromWidth,
    "toExpanded",
    ()=>toExpanded,
    "toHeight",
    ()=>toHeight,
    "toWidth",
    ()=>toWidth,
    "tryFrom",
    ()=>tryFrom
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/api.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$uint64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/uint64.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/constant.js [app-client] (ecmascript)");
;
;
;
const from = (size)=>{
    const result = tryFrom(size);
    if (result.error) {
        throw result.error;
    } else {
        return result.ok;
    }
};
const tryFrom = (input)=>{
    const size = BigInt(input);
    if (size < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PADDED_BYTES_PER_QUAD"]) {
        return {
            error: new RangeError(`Padded payload must contain at least ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PADDED_BYTES_PER_QUAD"]} bytes`)
        };
    }
    if (size >> BigInt((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$uint64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["trailingZeros64"])(size)) !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PADDED_BYTES_PER_QUAD"]) {
        return {
            error: new RangeError(`Padded payload size must be (2 * ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PADDED_BYTES_PER_QUAD"]})`)
        };
    }
    return {
        ok: size
    };
};
const fromExpanded = (size)=>fromQuads(size / __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EXPANDED_BYTES_PER_QUAD"]);
const toExpanded = (size)=>toQauds(size) * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EXPANDED_BYTES_PER_QUAD"];
const fromHeight = (height)=>{
    // We calculate number of quads tree by calculating number of nodes tree
    // at second layer. This works because we deal with a binary tree so first
    // layer nodes will contain 2 leaves and second layer nodes will contain 4
    // leaves hence number of quads.
    const quads = 2n ** BigInt(height - 2);
    return quads * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PADDED_BYTES_PER_QUAD"];
};
const toHeight = (size)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$uint64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log2Ceil"])(toWidth(size));
const toWidth = (size)=>toQauds(size) * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LEAFS_PER_QUAD"];
const fromWidth = (width)=>fromQuads(width / __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LEAFS_PER_QUAD"]);
/**
 * @param {API.PaddedSize} size
 */ const toQauds = (size)=>size / __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PADDED_BYTES_PER_QUAD"];
/**
 *
 * @param {API.uint64} count
 * @returns {API.PaddedSize}
 */ const fromQuads = (count)=>count * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PADDED_BYTES_PER_QUAD"];
}),
"[project]/node_modules/@web3-storage/data-segment/src/piece/size/unpadded.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "fromPiece",
    ()=>fromPiece,
    "toExpanded",
    ()=>toExpanded,
    "toHeight",
    ()=>toHeight,
    "toPadded",
    ()=>toPadded,
    "toPadding",
    ()=>toPadding,
    "toWidth",
    ()=>toWidth
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/api.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/constant.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$uint64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/uint64.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$piece$2f$size$2f$padded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/piece/size/padded.js [app-client] (ecmascript)");
;
;
;
;
const fromPiece = ({ height, padding })=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$piece$2f$size$2f$padded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromHeight"](height) - padding;
const toPadding = (size)=>toPadded(size) - size;
const toPadded = (size)=>toQauds(size) * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PADDED_BYTES_PER_QUAD"];
const toExpanded = (size)=>toQauds(size) * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EXPANDED_BYTES_PER_QUAD"];
const toWidth = (size)=>toQauds(size) * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["LEAFS_PER_QUAD"];
const toHeight = (size)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$uint64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log2Ceil"])(toWidth(size));
/**
 * Takes arbitrary payload size and calculates number of quads that will be
 * required to represent it.
 *
 * @param {API.uint64} size
 */ const toQauds = (size)=>{
    // Number of quads required to fit given payload size.
    // Since bigint division truncates we add another quads shy of 1 number of
    // bytes to round up.
    const quadCount = (size + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PADDED_BYTES_PER_QUAD"] - 1n) / __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["PADDED_BYTES_PER_QUAD"];
    // Next we we log2 then pow2 with some rounding to ensure that result
    // is 2 ^ n.
    return 2n ** BigInt((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$uint64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log2Ceil"])(quadCount));
};
}),
"[project]/node_modules/@web3-storage/data-segment/src/piece/size/expanded.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "from",
    ()=>from,
    "fromHeight",
    ()=>fromHeight,
    "fromWidth",
    ()=>fromWidth,
    "toHeight",
    ()=>toHeight,
    "toWidth",
    ()=>toWidth,
    "tryFrom",
    ()=>tryFrom
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/api.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/constant.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$uint64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/uint64.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$piece$2f$size$2f$padded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/piece/size/padded.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$piece$2f$size$2f$unpadded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/piece/size/unpadded.js [app-client] (ecmascript)");
;
;
;
;
;
const tryFrom = (input)=>{
    const size = BigInt(input);
    if (size < __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EXPANDED_BYTES_PER_QUAD"]) {
        return {
            error: RangeError(`Minimum piece size is ${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EXPANDED_BYTES_PER_QUAD"]} bytes`)
        };
    }
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$uint64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["onesCount64"])(size) !== 1) {
        return {
            error: RangeError('Piece size must be a power of 2')
        };
    }
    return {
        ok: size
    };
};
const from = (size)=>{
    const result = tryFrom(size);
    if (result.error) {
        throw result.error;
    } else {
        return result.ok;
    }
};
const fromHeight = (height)=>fromWidth(2n ** BigInt(height));
const toHeight = (size)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$uint64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["log2Ceil"])(toWidth(size));
const fromWidth = (width)=>width * __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EXPANDED_BYTES_PER_NODE"];
const toWidth = (size)=>size / __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["EXPANDED_BYTES_PER_NODE"];
}),
"[project]/node_modules/@web3-storage/data-segment/src/piece/size.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$piece$2f$size$2f$unpadded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/piece/size/unpadded.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$piece$2f$size$2f$padded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/piece/size/padded.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$piece$2f$size$2f$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/piece/size/expanded.js [app-client] (ecmascript) <locals>");
;
;
;
;
}),
"[project]/node_modules/@web3-storage/data-segment/src/piece/size/unpadded.js [app-client] (ecmascript) <export * as Unpadded>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Unpadded",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$piece$2f$size$2f$unpadded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$piece$2f$size$2f$unpadded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/piece/size/unpadded.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@web3-storage/data-segment/src/digest.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "HEIGHT_SIZE",
    ()=>HEIGHT_SIZE,
    "MAX_DIGEST_SIZE",
    ()=>MAX_DIGEST_SIZE,
    "MAX_HEIGHT",
    ()=>MAX_HEIGHT,
    "MAX_PAYLOAD_SIZE",
    ()=>MAX_PAYLOAD_SIZE,
    "MAX_SIZE",
    ()=>MAX_SIZE,
    "ROOT_SIZE",
    ()=>ROOT_SIZE,
    "TAG_SIZE",
    ()=>TAG_SIZE,
    "code",
    ()=>code,
    "fromBytes",
    ()=>fromBytes,
    "fromPiece",
    ()=>fromPiece,
    "height",
    ()=>height,
    "name",
    ()=>name,
    "padding",
    ()=>padding,
    "root",
    ()=>root,
    "toBytes",
    ()=>toBytes
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/varint.js [app-client] (ecmascript) <export * as varint>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/api.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/constant.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$ipld$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/ipld.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$ipld$2f$sha256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__SHA256$3e$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/ipld/sha256.js [app-client] (ecmascript) <export * as SHA256>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$piece$2f$size$2f$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/piece/size/expanded.js [app-client] (ecmascript) <locals>");
;
;
;
;
;
const name = 'fr32-sha2-256-trunc254-padded-binary-tree';
const code = 0x1011;
/**
 * Varint is used to encode the tree height which is limited to 9 bytes.
 *
 * @see https://github.com/multiformats/unsigned-varint#practical-maximum-of-9-bytes-for-security
 */ const MAX_PADDING_SIZE = 9;
const HEIGHT_SIZE = 1;
const ROOT_SIZE = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$ipld$2f$sha256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__SHA256$3e$__["SHA256"].size;
const MAX_DIGEST_SIZE = MAX_PADDING_SIZE + HEIGHT_SIZE + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$ipld$2f$sha256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__SHA256$3e$__["SHA256"].size;
const TAG_SIZE = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(code);
const MAX_SIZE = TAG_SIZE + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(MAX_DIGEST_SIZE) + MAX_DIGEST_SIZE;
const MAX_HEIGHT = 255;
const MAX_PAYLOAD_SIZE = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$piece$2f$size$2f$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromHeight"])(MAX_HEIGHT) * BigInt(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IN_BITS_FR"]) / BigInt(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OUT_BITS_FR"]);
const fromPiece = ({ padding, height, root })=>{
    const paddingLength = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(Number(padding));
    const size = paddingLength + HEIGHT_SIZE + ROOT_SIZE;
    const sizeLength = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(size);
    const multihashLength = TAG_SIZE + sizeLength + size;
    let offset = 0;
    const bytes = new Uint8Array(multihashLength);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodeTo(code, bytes, offset);
    offset += TAG_SIZE;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodeTo(size, bytes, offset);
    offset += sizeLength;
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodeTo(Number(padding), bytes, offset);
    offset += paddingLength;
    bytes[offset] = height;
    offset += HEIGHT_SIZE;
    bytes.set(root, offset);
    return new Digest(bytes);
};
const fromBytes = (bytes)=>new Digest(bytes);
const toBytes = ({ digest })=>{
    const SIZE_BYTE_LENGTH = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(digest.length);
    // number of bytes prefix will take up
    const prefixByteLength = SIZE_BYTE_LENGTH + TAG_SIZE;
    // if digest is view within a buffer that has enough bytes in front to
    // fit the prefix it may be already include a prefix in which case we
    // will simply use a larger slice.
    if (digest.byteOffset >= prefixByteLength) {
        const bytes = new Uint8Array(digest.buffer, digest.byteOffset - prefixByteLength, digest.byteOffset + digest.length);
        // if the prefix matches our bytes represent a multihash
        const [tag, offset] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].decode(bytes);
        if (tag === code && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].decode(bytes, offset)[0] === digest.length) {
            return bytes;
        }
    }
    const bytes = new Uint8Array(digest.length + prefixByteLength);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodeTo(code, bytes);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodeTo(digest.length, bytes, TAG_SIZE);
    bytes.set(digest, prefixByteLength);
    return bytes;
};
const height = ({ digest })=>{
    const [, offset] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].decode(digest);
    return digest[offset];
};
const padding = ({ digest })=>{
    const [padding] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].decode(digest);
    return BigInt(padding);
};
const root = ({ digest })=>{
    const [, offset] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].decode(digest);
    return digest.subarray(offset + HEIGHT_SIZE, offset + HEIGHT_SIZE + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$ipld$2f$sha256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__SHA256$3e$__["SHA256"].size);
};
/**
 * @implements {API.PieceDigest}
 */ class Digest {
    /**
   * @param {Uint8Array} bytes
   */ constructor(bytes){
        this.bytes = bytes;
        const [tag] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].decode(bytes);
        if (tag !== code) {
            throw new RangeError(`Expected multihash with code ${code}`);
        }
        let offset = TAG_SIZE;
        const [size, length] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].decode(bytes, offset);
        offset += length;
        const digest = bytes.subarray(offset);
        if (digest.length !== size) {
            throw new RangeError(`Invalid multihash size expected ${offset + size} bytes, got ${bytes.length} bytes`);
        }
        this.digest = digest;
    }
    get name() {
        return name;
    }
    get code() {
        return code;
    }
    get size() {
        return this.digest.length;
    }
    get padding() {
        return padding(this);
    }
    get height() {
        return height(this);
    }
    get root() {
        return root(this);
    }
}
}),
"[project]/node_modules/@web3-storage/data-segment/src/multihash.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "MAX_HEIGHT",
    ()=>MAX_HEIGHT,
    "MAX_PAYLOAD_SIZE",
    ()=>MAX_PAYLOAD_SIZE,
    "code",
    ()=>code,
    "create",
    ()=>create,
    "digest",
    ()=>digest,
    "name",
    ()=>name
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/api.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/constant.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$zero$2d$comm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/zero-comm.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$proof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/proof.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$piece$2f$tree$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/piece/tree.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$fr32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/fr32.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$piece$2f$size$2f$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/piece/size/expanded.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$piece$2f$size$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/piece/size.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$piece$2f$size$2f$unpadded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Unpadded$3e$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/piece/size/unpadded.js [app-client] (ecmascript) <export * as Unpadded>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/digest.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/varint.js [app-client] (ecmascript) <export * as varint>");
;
;
;
;
;
;
;
;
;
;
;
const name = 'fr32-sha2-256-trunc254-padded-binary-tree';
const code = 0x1011;
const MAX_HEIGHT = 255;
const MAX_PAYLOAD_SIZE = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$piece$2f$size$2f$expanded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromHeight"])(MAX_HEIGHT) * BigInt(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IN_BITS_FR"]) / BigInt(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["OUT_BITS_FR"]);
const digest = (payload)=>{
    const hasher = new Hasher();
    hasher.write(payload);
    return hasher.digest();
};
const create = ()=>new Hasher();
/**
 * @typedef {[API.MerkleTreeNode[], ...API.MerkleTreeNode[][]]} Layers
 *
 * @implements {API.StreamingHasher<typeof code, number, API.PieceDigest>}
 */ class Hasher {
    constructor(){
        /**
     * The number of bytes consumed by the hasher.
     *
     * @private
     */ this.bytesWritten = 0n;
        /**
     * This buffer is used to accumulate bytes until we have enough to fill a
     * quad.
     *
     *  Note that you should never read bytes past {@link offset} as those
     * are considered dirty and may contain garbage.
     *
     * @protected
     */ this.buffer = new Uint8Array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IN_BYTES_PER_QUAD"]);
        /**
     * Offset is the number of bytes in we have written into the buffer. If
     * offset is 0 it means that the buffer is effectively empty. When `offset`
     * is equal to `this.buffer.length` we have a quad that can be processed.
     *
     * @protected
     */ this.offset = 0;
        /**
     * The layers of the tree. Each layer will contain either 0 or 1 nodes
     * between writes. When we write into a hasher, if we have enough nodes
     * leaves will be created and pushed into the `layers[0]` array, after
     * which we flush and combine every two leafs into a node which is moved
     * to the next layer. This process is repeated until we reach the top
     * layer, leaving each layer either empty or with a single node.
     *
     * @type {Layers}
     */ this.layers = [
            []
        ];
    }
    /**
   * Return the total number of bytes written into the hasher. Calling
   * {@link reset} will reset the hasher and the count will be reset to 0.
   *
   * @returns {bigint}
   */ count() {
        return this.bytesWritten;
    }
    /**
   * Computes the digest of all the data that has been written into this hasher.
   * This method does not have side-effects, meaning that you can continue
   * writing and call this method again to compute digest of all the data
   * written from the very beginning.
   */ digest() {
        const bytes = new Uint8Array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["MAX_SIZE"]);
        const count = this.digestInto(bytes, 0, true);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromBytes"](bytes.subarray(0, count));
    }
    /**
   * Computes the digest and writes into the given buffer. You can provide
   * optional `byteOffset` to write digest at that offset in the buffer. By
   * default the multihash prefix will be written into the buffer, but you can
   * opt-out by passing `false` as the `asMultihash` argument.
   *
   * @param {Uint8Array} output
   * @param {number} [byteOffset]
   * @param {boolean} asMultihash
   */ digestInto(output, byteOffset = 0, asMultihash = true) {
        const { buffer, layers, offset, bytesWritten } = this;
        // We do not want to mutate the layers, so we create a shallow copy of it
        // which we will use to compute the root.
        let [leaves, ...nodes] = layers;
        // If we have some bytes in the buffer we fill rest with zeros and compute
        // leaves from it. Note that it is safe to mutate the buffer here as bytes
        // past `offset` are considered dirty and should not be read.
        if (offset > 0 || bytesWritten === 0n) {
            leaves = [
                ...leaves,
                ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$piece$2f$tree$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["split"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$fr32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pad"])(buffer.fill(0, offset)))
            ];
        }
        const tree = build([
            leaves,
            ...nodes
        ]);
        const height = tree.length - 1;
        const [root] = tree[height];
        const padding = Number(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$piece$2f$size$2f$unpadded$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Unpadded$3e$__["Unpadded"].toPadding(this.bytesWritten));
        const paddingLength = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(padding);
        let endOffset = byteOffset;
        // Write the multihash prefix if requested
        if (asMultihash) {
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodeTo(code, output, endOffset);
            endOffset += __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["TAG_SIZE"];
            const size = paddingLength + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["HEIGHT_SIZE"] + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ROOT_SIZE"];
            const sizeLength = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(size);
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodeTo(size, output, endOffset);
            endOffset += sizeLength;
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodeTo(padding, output, endOffset);
        endOffset += paddingLength;
        // Write the tree height as the first byte of the digest
        output[endOffset] = height;
        endOffset += 1;
        // Write the root as the remaining 32 bytes of the digest
        output.set(root, endOffset);
        endOffset += root.length;
        // Return number of bytes written
        return endOffset - byteOffset;
    }
    /**
   * @param {Uint8Array} bytes
   */ write(bytes) {
        const { buffer, offset, layers } = this;
        const leaves = layers[0];
        const { length } = bytes;
        // If we got no bytes there is nothing to do here
        if (length === 0) {
            return this;
        /* c8 ignore next 5 */ } else if (this.bytesWritten + BigInt(length) > MAX_PAYLOAD_SIZE) {
            throw new RangeError(`Writing ${length} bytes exceeds max payload size of ${MAX_PAYLOAD_SIZE}`);
        } else if (offset + length < buffer.length) {
            buffer.set(bytes, offset);
            this.offset += length;
            this.bytesWritten += BigInt(length);
            return this;
        } else {
            // Number of bytes required to fill the quad buffer
            const bytesRequired = buffer.length - offset;
            // copy required bytes into the buffer and turn them into leaves
            // which we push into the leaf layer.
            buffer.set(bytes.subarray(0, bytesRequired), offset);
            leaves.push(...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$piece$2f$tree$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["split"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$fr32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pad"])(buffer)));
            // Now we slice remaining bytes into quads, create leaves from them
            // and push them into the leaf layer.
            let readOffset = bytesRequired;
            while(readOffset + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IN_BYTES_PER_QUAD"] < length){
                const quad = bytes.subarray(readOffset, readOffset + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IN_BYTES_PER_QUAD"]);
                leaves.push(...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$piece$2f$tree$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["split"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$fr32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pad"])(quad)));
                readOffset += __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$constant$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["IN_BYTES_PER_QUAD"];
            }
            // Whatever byte were left are copied into the buffer and we update
            // the offset to reflect that.
            this.buffer.set(bytes.subarray(readOffset), 0);
            this.offset = length - readOffset;
            // We also update the total number of bytes written.
            this.bytesWritten += BigInt(length);
            // Now prune the layers to propagate all the new leaves up the tree.
            prune(this.layers);
            return this;
        }
    }
    /**
   * Resets this hasher to its initial state so it could be recycled as new
   * instance.
   */ reset() {
        this.offset = 0;
        this.bytesWritten = 0n;
        this.layers.length = 1;
        this.layers[0].length = 0;
        return this;
    }
    /* c8 ignore next 3 */ dispose() {
        this.reset();
    }
    get code() {
        return code;
    }
    get name() {
        return name;
    }
}
/**
 * Prunes layers by combining node pairs into nodes in the next layer and
 * removing them from the layer that they were in. After pruning each layer
 * will end up with at most one node. New layers may be created in the process
 * when nodes from the top layer are combined.
 *
 * @param {Layers} layers
 */ const prune = (layers)=>flush(layers, false);
/**
 * Flushes all the nodes in layers by combining node pairs into nodes in the
 * next layer. Layers with only one node are combined with zero padded nodes
 * (corresponding to the level of the layer). Unlike {@link prune} combined
 * nodes are not removed and layers are copied instead of been mutated.
 *
 * @param {Layers} layers
 */ const build = (layers)=>flush([
        ...layers
    ], true);
/**
 * @param {Layers} layers
 * @param {boolean} build
 * @returns {Layers}
 */ const flush = (layers, build)=>{
    // Note it is important that we do not mutate any of the layers otherwise
    // writing more data into the hasher and computing the digest will produce
    // wrong results.
    let level = 0;
    // We will walk up the tree until we reach the top layer. However, we may end
    // up with creating new layers in the process, so we will keep track of the
    while(level < layers.length){
        let next = layers[level + 1];
        const layer = layers[level];
        // If we have the odd number of nodes and we have not reached the top
        // layer, we push a zero padding node corresponding to the current level.
        if (build && layer.length % 2 > 0 && next) {
            layer.push(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$zero$2d$comm$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromLevel"](level));
        }
        level += 1;
        // If we have 0 nodes in the current layer we just move to the next one.
        // If we have a next layer and we are building  will combine nodes from the current layer
        next = next ? build ? [
            ...next
        ] : next : [];
        let index = 0;
        // Note that we have checked that we have an even number of nodes so
        // we will never end up with an extra node when consuming two at a time.
        while(index + 1 < layer.length){
            const node = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$proof$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["computeNode"])(layer[index], layer[index + 1]);
            // we proactively delete nodes in order to free up a memory used.
            delete layer[index];
            delete layer[index + 1];
            next.push(node);
            index += 2;
        }
        if (next.length) {
            layers[level] = next;
        }
        // we remove nodes that we have combined from the current layer to reduce
        // memory overhead and move to the next layer.
        layer.splice(0, index);
    }
    return layers;
};
}),
"[project]/node_modules/@web3-storage/data-segment/src/multihash.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Digest",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    "MAX_HEIGHT",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$multihash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["MAX_HEIGHT"],
    "MAX_PAYLOAD_SIZE",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$multihash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["MAX_PAYLOAD_SIZE"],
    "code",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$multihash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["code"],
    "create",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$multihash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["create"],
    "digest",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$multihash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["digest"],
    "name",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$multihash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["name"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$multihash$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/multihash.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$web3$2d$storage$2f$data$2d$segment$2f$src$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@web3-storage/data-segment/src/digest.js [app-client] (ecmascript)");
}),
"[project]/node_modules/sync-multihash-sha2/src/sha256/digest.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Digest",
    ()=>Digest,
    "code",
    ()=>code,
    "name",
    ()=>name,
    "prefix",
    ()=>prefix,
    "size",
    ()=>size
]);
const name = 'sha2-256';
const code = 0x12;
const size = 32;
const prefix = new Uint8Array([
    18,
    32
]);
class Digest {
    /**
   * @param {Uint8Array} bytes
   */ constructor(bytes){
        /** @type {typeof code} */ this.code = code;
        /** @type {typeof name} */ this.name = name;
        this.bytes = bytes;
        /** @type {typeof size} */ this.size = size;
        this.digest = bytes.subarray(2);
    }
}
}),
"[project]/node_modules/sync-multihash-sha2/src/sha256/web.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

/* c8 ignore next */ __turbopack_context__.s([
    "digest",
    ()=>digest
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@noble/hashes/esm/sha256.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sync$2d$multihash$2d$sha2$2f$src$2f$sha256$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/sync-multihash-sha2/src/sha256/digest.js [app-client] (ecmascript)");
;
;
;
const digest = (payload)=>{
    const digest = new Uint8Array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sync$2d$multihash$2d$sha2$2f$src$2f$sha256$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["prefix"].length + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sync$2d$multihash$2d$sha2$2f$src$2f$sha256$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["size"]);
    digest.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sync$2d$multihash$2d$sha2$2f$src$2f$sha256$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["prefix"], 0);
    digest.set((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$noble$2f$hashes$2f$esm$2f$sha256$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sha256"])(payload), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sync$2d$multihash$2d$sha2$2f$src$2f$sha256$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["prefix"].length);
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sync$2d$multihash$2d$sha2$2f$src$2f$sha256$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Digest"](digest);
};
}),
"[project]/node_modules/sync-multihash-sha2/src/sha256/web.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "code",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sync$2d$multihash$2d$sha2$2f$src$2f$sha256$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["code"],
    "digest",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sync$2d$multihash$2d$sha2$2f$src$2f$sha256$2f$web$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["digest"],
    "name",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sync$2d$multihash$2d$sha2$2f$src$2f$sha256$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["name"],
    "size",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sync$2d$multihash$2d$sha2$2f$src$2f$sha256$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["size"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sync$2d$multihash$2d$sha2$2f$src$2f$sha256$2f$web$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/sync-multihash-sha2/src/sha256/web.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$sync$2d$multihash$2d$sha2$2f$src$2f$sha256$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/sync-multihash-sha2/src/sha256/digest.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@storacha/filecoin-client/dist/service.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "services",
    ()=>services
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/did.js [app-client] (ecmascript)");
;
const services = {
    STOREFRONT: {
        url: new URL('https://up.storacha.network'),
        principal: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parse"]('did:web:up.storacha.network')
    },
    AGGREGATOR: {
        url: new URL('https://aggregator.web3.storage'),
        principal: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parse"]('did:web:web3.storage')
    },
    DEALER: {
        url: new URL('https://dealer.web3.storage'),
        principal: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parse"]('did:web:web3.storage')
    },
    DEAL_TRACKER: {
        url: new URL('https://tracker.web3.storage'),
        principal: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parse"]('did:web:web3.storage')
    }
}; //# sourceMappingURL=service.js.map
}),
"[project]/node_modules/@storacha/filecoin-client/dist/storefront.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "connection",
    ()=>connection,
    "filecoinAccept",
    ()=>filecoinAccept,
    "filecoinInfo",
    ()=>filecoinInfo,
    "filecoinOffer",
    ()=>filecoinOffer,
    "filecoinSubmit",
    ()=>filecoinSubmit
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$client$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/client/src/lib.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$client$2f$src$2f$connection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/client/src/connection.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/lib.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__CAR$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/car.js [app-client] (ecmascript) <export * as CAR>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$http$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__HTTP$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/http.js [app-client] (ecmascript) <export * as HTTP>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$filecoin$2f$storefront$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/capabilities/dist/filecoin/storefront.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$filecoin$2d$client$2f$dist$2f$service$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/filecoin-client/dist/service.js [app-client] (ecmascript)");
;
;
;
;
const connection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$client$2f$src$2f$connection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["connect"])({
    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$filecoin$2d$client$2f$dist$2f$service$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["services"].STOREFRONT.principal,
    codec: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__CAR$3e$__["CAR"].outbound,
    channel: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$http$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__HTTP$3e$__["HTTP"].open({
        url: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$filecoin$2d$client$2f$dist$2f$service$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["services"].STOREFRONT.url,
        method: 'POST'
    })
});
async function filecoinOffer({ issuer, with: resource, proofs, audience }, content, piece, options = {}) {
    /* c8 ignore next */ const conn = options.connection ?? connection;
    const invocation = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$filecoin$2f$storefront$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["filecoinOffer"].invoke({
        issuer,
        /* c8 ignore next */ audience: audience ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$filecoin$2d$client$2f$dist$2f$service$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["services"].STOREFRONT.principal,
        with: resource,
        nb: {
            content,
            piece
        },
        proofs,
        expiration: Infinity
    });
    return await invocation.execute(conn);
}
async function filecoinSubmit({ issuer, with: resource, proofs, audience }, content, piece, options = {}) {
    /* c8 ignore next */ const conn = options.connection ?? connection;
    const invocation = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$filecoin$2f$storefront$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["filecoinSubmit"].invoke({
        issuer,
        /* c8 ignore next */ audience: audience ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$filecoin$2d$client$2f$dist$2f$service$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["services"].STOREFRONT.principal,
        with: resource,
        nb: {
            content,
            piece
        },
        proofs,
        expiration: Infinity
    });
    return await invocation.execute(conn);
}
async function filecoinAccept({ issuer, with: resource, proofs, audience }, content, piece, options = {}) {
    /* c8 ignore next */ const conn = options.connection ?? connection;
    const invocation = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$filecoin$2f$storefront$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["filecoinAccept"].invoke({
        issuer,
        /* c8 ignore next */ audience: audience ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$filecoin$2d$client$2f$dist$2f$service$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["services"].STOREFRONT.principal,
        with: resource,
        nb: {
            content,
            piece
        },
        proofs,
        expiration: Infinity
    });
    return await invocation.execute(conn);
}
async function filecoinInfo({ issuer, with: resource, proofs, audience }, piece, options = {}) {
    /* c8 ignore next */ const conn = options.connection ?? connection;
    const invocation = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$filecoin$2f$storefront$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["filecoinInfo"].invoke({
        issuer,
        /* c8 ignore next */ audience: audience ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$filecoin$2d$client$2f$dist$2f$service$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["services"].STOREFRONT.principal,
        with: resource,
        nb: {
            piece
        },
        proofs
    });
    return await invocation.execute(conn);
} //# sourceMappingURL=storefront.js.map
}),
"[project]/node_modules/@storacha/filecoin-client/dist/aggregator.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "connection",
    ()=>connection,
    "pieceAccept",
    ()=>pieceAccept,
    "pieceOffer",
    ()=>pieceOffer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$client$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/client/src/lib.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$client$2f$src$2f$connection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/client/src/connection.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/lib.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__CAR$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/car.js [app-client] (ecmascript) <export * as CAR>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$http$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__HTTP$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/http.js [app-client] (ecmascript) <export * as HTTP>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$filecoin$2f$aggregator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/capabilities/dist/filecoin/aggregator.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$filecoin$2d$client$2f$dist$2f$service$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/filecoin-client/dist/service.js [app-client] (ecmascript)");
;
;
;
;
const connection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$client$2f$src$2f$connection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["connect"])({
    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$filecoin$2d$client$2f$dist$2f$service$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["services"].AGGREGATOR.principal,
    codec: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__CAR$3e$__["CAR"].outbound,
    channel: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$http$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__HTTP$3e$__["HTTP"].open({
        url: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$filecoin$2d$client$2f$dist$2f$service$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["services"].AGGREGATOR.url,
        method: 'POST'
    })
});
async function pieceOffer({ issuer, with: resource, proofs, audience }, piece, group, options = {}) {
    /* c8 ignore next */ const conn = options.connection ?? connection;
    const invocation = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$filecoin$2f$aggregator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pieceOffer"].invoke({
        issuer,
        /* c8 ignore next */ audience: audience ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$filecoin$2d$client$2f$dist$2f$service$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["services"].AGGREGATOR.principal,
        with: resource,
        nb: {
            piece,
            group
        },
        proofs,
        expiration: Infinity
    });
    return await invocation.execute(conn);
}
async function pieceAccept({ issuer, with: resource, proofs, audience }, piece, group, options = {}) {
    /* c8 ignore next */ const conn = options.connection ?? connection;
    const invocation = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$filecoin$2f$aggregator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["pieceAccept"].invoke({
        issuer,
        /* c8 ignore next */ audience: audience ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$filecoin$2d$client$2f$dist$2f$service$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["services"].AGGREGATOR.principal,
        with: resource,
        nb: {
            piece,
            group
        },
        proofs,
        expiration: Infinity
    });
    return await invocation.execute(conn);
} //# sourceMappingURL=aggregator.js.map
}),
"[project]/node_modules/@storacha/filecoin-client/dist/dealer.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "aggregateAccept",
    ()=>aggregateAccept,
    "aggregateOffer",
    ()=>aggregateOffer,
    "connection",
    ()=>connection
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$client$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/client/src/lib.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$client$2f$src$2f$connection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/client/src/connection.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/lib.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__CAR$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/car.js [app-client] (ecmascript) <export * as CAR>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$http$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__HTTP$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/http.js [app-client] (ecmascript) <export * as HTTP>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/lib.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$cbor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__CBOR$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/cbor.js [app-client] (ecmascript) <export * as CBOR>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$filecoin$2f$dealer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/capabilities/dist/filecoin/dealer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$filecoin$2d$client$2f$dist$2f$service$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/filecoin-client/dist/service.js [app-client] (ecmascript)");
;
;
;
;
;
const connection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$client$2f$src$2f$connection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["connect"])({
    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$filecoin$2d$client$2f$dist$2f$service$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["services"].DEALER.principal,
    codec: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__CAR$3e$__["CAR"].outbound,
    channel: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$http$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__HTTP$3e$__["HTTP"].open({
        url: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$filecoin$2d$client$2f$dist$2f$service$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["services"].DEALER.url,
        method: 'POST'
    })
});
async function aggregateOffer({ issuer, with: resource, proofs, audience }, aggregate, pieces, options = {}) {
    /* c8 ignore next */ const conn = options.connection ?? connection;
    const block = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$cbor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__CBOR$3e$__["CBOR"].write(pieces);
    const invocation = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$filecoin$2f$dealer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aggregateOffer"].invoke({
        issuer,
        /* c8 ignore next */ audience: audience ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$filecoin$2d$client$2f$dist$2f$service$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["services"].AGGREGATOR.principal,
        with: resource,
        nb: {
            aggregate,
            pieces: block.cid
        },
        proofs,
        expiration: Infinity
    });
    invocation.attach(block);
    return await invocation.execute(conn);
}
async function aggregateAccept({ issuer, with: resource, proofs, audience }, aggregate, pieces, options = {}) {
    /* c8 ignore next */ const conn = options.connection ?? connection;
    const invocation = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$filecoin$2f$dealer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["aggregateAccept"].invoke({
        issuer,
        /* c8 ignore next */ audience: audience ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$filecoin$2d$client$2f$dist$2f$service$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["services"].AGGREGATOR.principal,
        with: resource,
        nb: {
            aggregate,
            pieces
        },
        proofs,
        expiration: Infinity
    });
    return await invocation.execute(conn);
} //# sourceMappingURL=dealer.js.map
}),
"[project]/node_modules/@storacha/filecoin-client/dist/deal-tracker.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "connection",
    ()=>connection,
    "dealInfo",
    ()=>dealInfo
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$client$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/client/src/lib.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$client$2f$src$2f$connection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/client/src/connection.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/lib.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__CAR$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/car.js [app-client] (ecmascript) <export * as CAR>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$http$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__HTTP$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/transport/src/http.js [app-client] (ecmascript) <export * as HTTP>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$filecoin$2f$deal$2d$tracker$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/capabilities/dist/filecoin/deal-tracker.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$filecoin$2d$client$2f$dist$2f$service$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/filecoin-client/dist/service.js [app-client] (ecmascript)");
;
;
;
;
const connection = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$client$2f$src$2f$connection$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["connect"])({
    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$filecoin$2d$client$2f$dist$2f$service$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["services"].DEAL_TRACKER.principal,
    codec: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__CAR$3e$__["CAR"].outbound,
    channel: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$transport$2f$src$2f$http$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__HTTP$3e$__["HTTP"].open({
        url: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$filecoin$2d$client$2f$dist$2f$service$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["services"].DEAL_TRACKER.url,
        method: 'POST'
    })
});
async function dealInfo({ issuer, with: resource, proofs, audience }, piece, options = {}) {
    /* c8 ignore next */ const conn = options.connection ?? connection;
    const invocation = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$capabilities$2f$dist$2f$filecoin$2f$deal$2d$tracker$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["dealInfo"].invoke({
        issuer,
        /* c8 ignore next */ audience: audience ?? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$filecoin$2d$client$2f$dist$2f$service$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["services"].DEAL_TRACKER.principal,
        with: resource,
        nb: {
            piece
        },
        proofs
    });
    return await invocation.execute(conn);
} //# sourceMappingURL=deal-tracker.js.map
}),
"[project]/node_modules/@storacha/filecoin-client/dist/index.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$filecoin$2d$client$2f$dist$2f$storefront$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/filecoin-client/dist/storefront.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$filecoin$2d$client$2f$dist$2f$aggregator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/filecoin-client/dist/aggregator.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$filecoin$2d$client$2f$dist$2f$dealer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/filecoin-client/dist/dealer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$filecoin$2d$client$2f$dist$2f$deal$2d$tracker$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/filecoin-client/dist/deal-tracker.js [app-client] (ecmascript)"); //# sourceMappingURL=index.js.map
;
;
;
;
}),
"[project]/node_modules/@storacha/filecoin-client/dist/storefront.js [app-client] (ecmascript) <export * as Storefront>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "Storefront",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$filecoin$2d$client$2f$dist$2f$storefront$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$filecoin$2d$client$2f$dist$2f$storefront$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/filecoin-client/dist/storefront.js [app-client] (ecmascript)");
}),
"[project]/node_modules/retry/lib/retry_operation.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

function RetryOperation(timeouts, options) {
    // Compatibility for the old (timeouts, retryForever) signature
    if (typeof options === 'boolean') {
        options = {
            forever: options
        };
    }
    this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
    this._timeouts = timeouts;
    this._options = options || {};
    this._maxRetryTime = options && options.maxRetryTime || Infinity;
    this._fn = null;
    this._errors = [];
    this._attempts = 1;
    this._operationTimeout = null;
    this._operationTimeoutCb = null;
    this._timeout = null;
    this._operationStart = null;
    this._timer = null;
    if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
    }
}
module.exports = RetryOperation;
RetryOperation.prototype.reset = function() {
    this._attempts = 1;
    this._timeouts = this._originalTimeouts.slice(0);
};
RetryOperation.prototype.stop = function() {
    if (this._timeout) {
        clearTimeout(this._timeout);
    }
    if (this._timer) {
        clearTimeout(this._timer);
    }
    this._timeouts = [];
    this._cachedTimeouts = null;
};
RetryOperation.prototype.retry = function(err) {
    if (this._timeout) {
        clearTimeout(this._timeout);
    }
    if (!err) {
        return false;
    }
    var currentTime = new Date().getTime();
    if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.push(err);
        this._errors.unshift(new Error('RetryOperation timeout occurred'));
        return false;
    }
    this._errors.push(err);
    var timeout = this._timeouts.shift();
    if (timeout === undefined) {
        if (this._cachedTimeouts) {
            // retry forever, only keep last error
            this._errors.splice(0, this._errors.length - 1);
            timeout = this._cachedTimeouts.slice(-1);
        } else {
            return false;
        }
    }
    var self = this;
    this._timer = setTimeout(function() {
        self._attempts++;
        if (self._operationTimeoutCb) {
            self._timeout = setTimeout(function() {
                self._operationTimeoutCb(self._attempts);
            }, self._operationTimeout);
            if (self._options.unref) {
                self._timeout.unref();
            }
        }
        self._fn(self._attempts);
    }, timeout);
    if (this._options.unref) {
        this._timer.unref();
    }
    return true;
};
RetryOperation.prototype.attempt = function(fn, timeoutOps) {
    this._fn = fn;
    if (timeoutOps) {
        if (timeoutOps.timeout) {
            this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
            this._operationTimeoutCb = timeoutOps.cb;
        }
    }
    var self = this;
    if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
            self._operationTimeoutCb();
        }, self._operationTimeout);
    }
    this._operationStart = new Date().getTime();
    this._fn(this._attempts);
};
RetryOperation.prototype.try = function(fn) {
    console.log('Using RetryOperation.try() is deprecated');
    this.attempt(fn);
};
RetryOperation.prototype.start = function(fn) {
    console.log('Using RetryOperation.start() is deprecated');
    this.attempt(fn);
};
RetryOperation.prototype.start = RetryOperation.prototype.try;
RetryOperation.prototype.errors = function() {
    return this._errors;
};
RetryOperation.prototype.attempts = function() {
    return this._attempts;
};
RetryOperation.prototype.mainError = function() {
    if (this._errors.length === 0) {
        return null;
    }
    var counts = {};
    var mainError = null;
    var mainErrorCount = 0;
    for(var i = 0; i < this._errors.length; i++){
        var error = this._errors[i];
        var message = error.message;
        var count = (counts[message] || 0) + 1;
        counts[message] = count;
        if (count >= mainErrorCount) {
            mainError = error;
            mainErrorCount = count;
        }
    }
    return mainError;
};
}),
"[project]/node_modules/retry/lib/retry.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

var RetryOperation = __turbopack_context__.r("[project]/node_modules/retry/lib/retry_operation.js [app-client] (ecmascript)");
exports.operation = function(options) {
    var timeouts = exports.timeouts(options);
    return new RetryOperation(timeouts, {
        forever: options && (options.forever || options.retries === Infinity),
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
    });
};
exports.timeouts = function(options) {
    if (options instanceof Array) {
        return [].concat(options);
    }
    var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1000,
        maxTimeout: Infinity,
        randomize: false
    };
    for(var key in options){
        opts[key] = options[key];
    }
    if (opts.minTimeout > opts.maxTimeout) {
        throw new Error('minTimeout is greater than maxTimeout');
    }
    var timeouts = [];
    for(var i = 0; i < opts.retries; i++){
        timeouts.push(this.createTimeout(i, opts));
    }
    if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts));
    }
    // sort the array numerically ascending
    timeouts.sort(function(a, b) {
        return a - b;
    });
    return timeouts;
};
exports.createTimeout = function(attempt, opts) {
    var random = opts.randomize ? Math.random() + 1 : 1;
    var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
    timeout = Math.min(timeout, opts.maxTimeout);
    return timeout;
};
exports.wrap = function(obj, options, methods) {
    if (options instanceof Array) {
        methods = options;
        options = null;
    }
    if (!methods) {
        methods = [];
        for(var key in obj){
            if (typeof obj[key] === 'function') {
                methods.push(key);
            }
        }
    }
    for(var i = 0; i < methods.length; i++){
        var method = methods[i];
        var original = obj[method];
        obj[method] = (function retryWrapper(original) {
            var op = exports.operation(options);
            var args = Array.prototype.slice.call(arguments, 1);
            var callback = args.pop();
            args.push(function(err) {
                if (op.retry(err)) {
                    return;
                }
                if (err) {
                    arguments[0] = op.mainError();
                }
                callback.apply(this, arguments);
            });
            op.attempt(function() {
                original.apply(obj, args);
            });
        }).bind(obj, original);
        obj[method].options = options;
    }
};
}),
"[project]/node_modules/retry/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = __turbopack_context__.r("[project]/node_modules/retry/lib/retry.js [app-client] (ecmascript)");
}),
"[project]/node_modules/p-retry/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "AbortError",
    ()=>AbortError,
    "default",
    ()=>pRetry
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$retry$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/retry/index.js [app-client] (ecmascript)");
;
const networkErrorMsgs = new Set([
    'Failed to fetch',
    'NetworkError when attempting to fetch resource.',
    'The Internet connection appears to be offline.',
    'Network request failed',
    'fetch failed'
]);
class AbortError extends Error {
    constructor(message){
        super();
        if (message instanceof Error) {
            this.originalError = message;
            ({ message } = message);
        } else {
            this.originalError = new Error(message);
            this.originalError.stack = this.stack;
        }
        this.name = 'AbortError';
        this.message = message;
    }
}
const decorateErrorWithCounts = (error, attemptNumber, options)=>{
    // Minus 1 from attemptNumber because the first attempt does not count as a retry
    const retriesLeft = options.retries - (attemptNumber - 1);
    error.attemptNumber = attemptNumber;
    error.retriesLeft = retriesLeft;
    return error;
};
const isNetworkError = (errorMessage)=>networkErrorMsgs.has(errorMessage);
const getDOMException = (errorMessage)=>globalThis.DOMException === undefined ? new Error(errorMessage) : new DOMException(errorMessage);
async function pRetry(input, options) {
    return new Promise((resolve, reject)=>{
        options = {
            onFailedAttempt () {},
            retries: 10,
            ...options
        };
        const operation = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$retry$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].operation(options);
        operation.attempt(async (attemptNumber)=>{
            try {
                resolve(await input(attemptNumber));
            } catch (error) {
                if (!(error instanceof Error)) {
                    reject(new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`));
                    return;
                }
                if (error instanceof AbortError) {
                    operation.stop();
                    reject(error.originalError);
                } else if (error instanceof TypeError && !isNetworkError(error.message)) {
                    operation.stop();
                    reject(error);
                } else {
                    decorateErrorWithCounts(error, attemptNumber, options);
                    try {
                        await options.onFailedAttempt(error);
                    } catch (error) {
                        reject(error);
                        return;
                    }
                    if (!operation.retry(error)) {
                        reject(operation.mainError());
                    }
                }
            }
        });
        if (options.signal && !options.signal.aborted) {
            options.signal.addEventListener('abort', ()=>{
                operation.stop();
                const reason = options.signal.reason === undefined ? getDOMException('The operation was aborted.') : options.signal.reason;
                reject(reason instanceof Error ? reason : getDOMException(reason));
            }, {
                once: true
            });
        }
    });
}
}),
"[project]/node_modules/@ipld/dag-pb/src/pb-decode.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "decodeNode",
    ()=>decodeNode
]);
const textDecoder = new TextDecoder();
/**
 * @typedef {import('./interface.js').RawPBLink} RawPBLink
 */ /**
 * @typedef {import('./interface.js').RawPBNode} RawPBNode
 */ /**
 * @param {Uint8Array} bytes
 * @param {number} offset
 * @returns {[number, number]}
 */ function decodeVarint(bytes, offset) {
    let v = 0;
    for(let shift = 0;; shift += 7){
        /* c8 ignore next 3 */ if (shift >= 64) {
            throw new Error('protobuf: varint overflow');
        }
        /* c8 ignore next 3 */ if (offset >= bytes.length) {
            throw new Error('protobuf: unexpected end of data');
        }
        const b = bytes[offset++];
        v += shift < 28 ? (b & 0x7f) << shift : (b & 0x7f) * 2 ** shift;
        if (b < 0x80) {
            break;
        }
    }
    return [
        v,
        offset
    ];
}
/**
 * @param {Uint8Array} bytes
 * @param {number} offset
 * @returns {[Uint8Array, number]}
 */ function decodeBytes(bytes, offset) {
    let byteLen;
    [byteLen, offset] = decodeVarint(bytes, offset);
    const postOffset = offset + byteLen;
    /* c8 ignore next 3 */ if (byteLen < 0 || postOffset < 0) {
        throw new Error('protobuf: invalid length');
    }
    /* c8 ignore next 3 */ if (postOffset > bytes.length) {
        throw new Error('protobuf: unexpected end of data');
    }
    return [
        bytes.subarray(offset, postOffset),
        postOffset
    ];
}
/**
 * @param {Uint8Array} bytes
 * @param {number} index
 * @returns {[number, number, number]}
 */ function decodeKey(bytes, index) {
    let wire;
    [wire, index] = decodeVarint(bytes, index);
    // [wireType, fieldNum, newIndex]
    return [
        wire & 0x7,
        wire >> 3,
        index
    ];
}
/**
 * @param {Uint8Array} bytes
 * @returns {RawPBLink}
 */ function decodeLink(bytes) {
    /** @type {RawPBLink} */ const link = {};
    const l = bytes.length;
    let index = 0;
    while(index < l){
        let wireType, fieldNum;
        [wireType, fieldNum, index] = decodeKey(bytes, index);
        if (fieldNum === 1) {
            if (link.Hash) {
                throw new Error('protobuf: (PBLink) duplicate Hash section');
            }
            if (wireType !== 2) {
                throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`);
            }
            if (link.Name !== undefined) {
                throw new Error('protobuf: (PBLink) invalid order, found Name before Hash');
            }
            if (link.Tsize !== undefined) {
                throw new Error('protobuf: (PBLink) invalid order, found Tsize before Hash');
            }
            [link.Hash, index] = decodeBytes(bytes, index);
        } else if (fieldNum === 2) {
            if (link.Name !== undefined) {
                throw new Error('protobuf: (PBLink) duplicate Name section');
            }
            if (wireType !== 2) {
                throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`);
            }
            if (link.Tsize !== undefined) {
                throw new Error('protobuf: (PBLink) invalid order, found Tsize before Name');
            }
            let byts;
            [byts, index] = decodeBytes(bytes, index);
            link.Name = textDecoder.decode(byts);
        } else if (fieldNum === 3) {
            if (link.Tsize !== undefined) {
                throw new Error('protobuf: (PBLink) duplicate Tsize section');
            }
            if (wireType !== 0) {
                throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`);
            }
            [link.Tsize, index] = decodeVarint(bytes, index);
        } else {
            throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`);
        }
    }
    /* c8 ignore next 3 */ if (index > l) {
        throw new Error('protobuf: (PBLink) unexpected end of data');
    }
    return link;
}
function decodeNode(bytes) {
    const l = bytes.length;
    let index = 0;
    /** @type {RawPBLink[]|void} */ let links = undefined // eslint-disable-line no-undef-init
    ;
    let linksBeforeData = false;
    /** @type {Uint8Array|void} */ let data = undefined // eslint-disable-line no-undef-init
    ;
    while(index < l){
        let wireType, fieldNum;
        [wireType, fieldNum, index] = decodeKey(bytes, index);
        if (wireType !== 2) {
            throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`);
        }
        if (fieldNum === 1) {
            if (data) {
                throw new Error('protobuf: (PBNode) duplicate Data section');
            }
            [data, index] = decodeBytes(bytes, index);
            if (links) {
                linksBeforeData = true;
            }
        } else if (fieldNum === 2) {
            if (linksBeforeData) {
                throw new Error('protobuf: (PBNode) duplicate Links section');
            } else if (!links) {
                links = [];
            }
            let byts;
            [byts, index] = decodeBytes(bytes, index);
            links.push(decodeLink(byts));
        } else {
            throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`);
        }
    }
    /* c8 ignore next 3 */ if (index > l) {
        throw new Error('protobuf: (PBNode) unexpected end of data');
    }
    /** @type {RawPBNode} */ const node = {};
    if (data) {
        node.Data = data;
    }
    node.Links = links || [];
    return node;
}
}),
"[project]/node_modules/@ipld/dag-pb/src/pb-encode.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "encodeNode",
    ()=>encodeNode
]);
const textEncoder = new TextEncoder();
const maxInt32 = 2 ** 32;
const maxUInt32 = 2 ** 31;
/**
 * @typedef {import('./interface.js').RawPBLink} RawPBLink
 */ /**
 * @typedef {import('./interface.js').RawPBNode} RawPBNode
 */ // the encoders work backward from the end of the bytes array
/**
 * encodeLink() is passed a slice of the parent byte array that ends where this
 * link needs to end, so it packs to the right-most part of the passed `bytes`
 *
 * @param {RawPBLink} link
 * @param {Uint8Array} bytes
 * @returns {number}
 */ function encodeLink(link, bytes) {
    let i = bytes.length;
    if (typeof link.Tsize === 'number') {
        if (link.Tsize < 0) {
            throw new Error('Tsize cannot be negative');
        }
        if (!Number.isSafeInteger(link.Tsize)) {
            throw new Error('Tsize too large for encoding');
        }
        i = encodeVarint(bytes, i, link.Tsize) - 1;
        bytes[i] = 0x18;
    }
    if (typeof link.Name === 'string') {
        const nameBytes = textEncoder.encode(link.Name);
        i -= nameBytes.length;
        bytes.set(nameBytes, i);
        i = encodeVarint(bytes, i, nameBytes.length) - 1;
        bytes[i] = 0x12;
    }
    if (link.Hash) {
        i -= link.Hash.length;
        bytes.set(link.Hash, i);
        i = encodeVarint(bytes, i, link.Hash.length) - 1;
        bytes[i] = 0xa;
    }
    return bytes.length - i;
}
function encodeNode(node) {
    const size = sizeNode(node);
    const bytes = new Uint8Array(size);
    let i = size;
    if (node.Data) {
        i -= node.Data.length;
        bytes.set(node.Data, i);
        i = encodeVarint(bytes, i, node.Data.length) - 1;
        bytes[i] = 0xa;
    }
    if (node.Links) {
        for(let index = node.Links.length - 1; index >= 0; index--){
            const size = encodeLink(node.Links[index], bytes.subarray(0, i));
            i -= size;
            i = encodeVarint(bytes, i, size) - 1;
            bytes[i] = 0x12;
        }
    }
    return bytes;
}
/**
 * work out exactly how many bytes this link takes up
 *
 * @param {RawPBLink} link
 * @returns
 */ function sizeLink(link) {
    let n = 0;
    if (link.Hash) {
        const l = link.Hash.length;
        n += 1 + l + sov(l);
    }
    if (typeof link.Name === 'string') {
        const l = textEncoder.encode(link.Name).length;
        n += 1 + l + sov(l);
    }
    if (typeof link.Tsize === 'number') {
        n += 1 + sov(link.Tsize);
    }
    return n;
}
/**
 * Work out exactly how many bytes this node takes up
 *
 * @param {RawPBNode} node
 * @returns {number}
 */ function sizeNode(node) {
    let n = 0;
    if (node.Data) {
        const l = node.Data.length;
        n += 1 + l + sov(l);
    }
    if (node.Links) {
        for (const link of node.Links){
            const l = sizeLink(link);
            n += 1 + l + sov(l);
        }
    }
    return n;
}
/**
 * @param {Uint8Array} bytes
 * @param {number} offset
 * @param {number} v
 * @returns {number}
 */ function encodeVarint(bytes, offset, v) {
    offset -= sov(v);
    const base = offset;
    while(v >= maxUInt32){
        bytes[offset++] = v & 0x7f | 0x80;
        v /= 128;
    }
    while(v >= 128){
        bytes[offset++] = v & 0x7f | 0x80;
        v >>>= 7;
    }
    bytes[offset] = v;
    return base;
}
/**
 * size of varint
 *
 * @param {number} x
 * @returns {number}
 */ function sov(x) {
    if (x % 2 === 0) {
        x++;
    }
    return Math.floor((len64(x) + 6) / 7);
}
/**
 * golang math/bits, how many bits does it take to represent this integer?
 *
 * @param {number} x
 * @returns {number}
 */ function len64(x) {
    let n = 0;
    if (x >= maxInt32) {
        x = Math.floor(x / maxInt32);
        n = 32;
    }
    if (x >= 1 << 16) {
        x >>>= 16;
        n += 16;
    }
    if (x >= 1 << 8) {
        x >>>= 8;
        n += 8;
    }
    return n + len8tab[x];
}
// golang math/bits
const len8tab = [
    0,
    1,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    7,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8,
    8
];
}),
"[project]/node_modules/@ipld/dag-pb/src/util.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createLink",
    ()=>createLink,
    "createNode",
    ()=>createNode,
    "prepare",
    ()=>prepare,
    "toByteView",
    ()=>toByteView,
    "validate",
    ()=>validate
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/cid.js [app-client] (ecmascript) <locals>");
;
/* eslint-disable complexity, no-nested-ternary */ /**
 * @typedef {import('./interface.js').PBLink} PBLink
 * @typedef {import('./interface.js').PBNode} PBNode
 */ /**
 * @template T
 * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView
 */ /**
 * @template T
 * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView
 */ const pbNodeProperties = [
    'Data',
    'Links'
];
const pbLinkProperties = [
    'Hash',
    'Name',
    'Tsize'
];
const textEncoder = new TextEncoder();
/**
 * @param {PBLink} a
 * @param {PBLink} b
 * @returns {number}
 */ function linkComparator(a, b) {
    if (a === b) {
        return 0;
    }
    const abuf = a.Name ? textEncoder.encode(a.Name) : [];
    const bbuf = b.Name ? textEncoder.encode(b.Name) : [];
    let x = abuf.length;
    let y = bbuf.length;
    for(let i = 0, len = Math.min(x, y); i < len; ++i){
        if (abuf[i] !== bbuf[i]) {
            x = abuf[i];
            y = bbuf[i];
            break;
        }
    }
    return x < y ? -1 : y < x ? 1 : 0;
}
/**
 * @param {any} node
 * @param {string[]} properties
 * @returns {boolean}
 */ function hasOnlyProperties(node, properties) {
    return !Object.keys(node).some((p)=>!properties.includes(p));
}
/**
 * Converts a CID, or a PBLink-like object to a PBLink
 *
 * @param {any} link
 * @returns {PBLink}
 */ function asLink(link) {
    if (typeof link.asCID === 'object') {
        const Hash = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].asCID(link);
        if (!Hash) {
            throw new TypeError('Invalid DAG-PB form');
        }
        return {
            Hash
        };
    }
    if (typeof link !== 'object' || Array.isArray(link)) {
        throw new TypeError('Invalid DAG-PB form');
    }
    const pbl = {};
    if (link.Hash) {
        let cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].asCID(link.Hash);
        try {
            if (!cid) {
                if (typeof link.Hash === 'string') {
                    cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].parse(link.Hash);
                } else if (link.Hash instanceof Uint8Array) {
                    cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].decode(link.Hash);
                }
            }
        } catch (/** @type {any} */ e) {
            throw new TypeError(`Invalid DAG-PB form: ${e.message}`);
        }
        if (cid) {
            pbl.Hash = cid;
        }
    }
    if (!pbl.Hash) {
        throw new TypeError('Invalid DAG-PB form');
    }
    if (typeof link.Name === 'string') {
        pbl.Name = link.Name;
    }
    if (typeof link.Tsize === 'number') {
        pbl.Tsize = link.Tsize;
    }
    return pbl;
}
function prepare(node) {
    if (node instanceof Uint8Array || typeof node === 'string') {
        node = {
            Data: node
        };
    }
    if (typeof node !== 'object' || Array.isArray(node)) {
        throw new TypeError('Invalid DAG-PB form');
    }
    /** @type {PBNode} */ const pbn = {};
    if (node.Data !== undefined) {
        if (typeof node.Data === 'string') {
            pbn.Data = textEncoder.encode(node.Data);
        } else if (node.Data instanceof Uint8Array) {
            pbn.Data = node.Data;
        } else {
            throw new TypeError('Invalid DAG-PB form');
        }
    }
    if (node.Links !== undefined) {
        if (Array.isArray(node.Links)) {
            pbn.Links = node.Links.map(asLink);
            pbn.Links.sort(linkComparator);
        } else {
            throw new TypeError('Invalid DAG-PB form');
        }
    } else {
        pbn.Links = [];
    }
    return pbn;
}
function validate(node) {
    /*
  type PBLink struct {
    Hash optional Link
    Name optional String
    Tsize optional Int
  }

  type PBNode struct {
    Links [PBLink]
    Data optional Bytes
  }
  */ // @ts-ignore private property for TS
    if (!node || typeof node !== 'object' || Array.isArray(node) || node instanceof Uint8Array || node['/'] && node['/'] === node.bytes) {
        throw new TypeError('Invalid DAG-PB form');
    }
    if (!hasOnlyProperties(node, pbNodeProperties)) {
        throw new TypeError('Invalid DAG-PB form (extraneous properties)');
    }
    if (node.Data !== undefined && !(node.Data instanceof Uint8Array)) {
        throw new TypeError('Invalid DAG-PB form (Data must be bytes)');
    }
    if (!Array.isArray(node.Links)) {
        throw new TypeError('Invalid DAG-PB form (Links must be a list)');
    }
    for(let i = 0; i < node.Links.length; i++){
        const link = node.Links[i];
        // @ts-ignore private property for TS
        if (!link || typeof link !== 'object' || Array.isArray(link) || link instanceof Uint8Array || link['/'] && link['/'] === link.bytes) {
            throw new TypeError('Invalid DAG-PB form (bad link)');
        }
        if (!hasOnlyProperties(link, pbLinkProperties)) {
            throw new TypeError('Invalid DAG-PB form (extraneous properties on link)');
        }
        if (link.Hash === undefined) {
            throw new TypeError('Invalid DAG-PB form (link must have a Hash)');
        }
        // @ts-ignore private property for TS
        if (link.Hash == null || !link.Hash['/'] || link.Hash['/'] !== link.Hash.bytes) {
            throw new TypeError('Invalid DAG-PB form (link Hash must be a CID)');
        }
        if (link.Name !== undefined && typeof link.Name !== 'string') {
            throw new TypeError('Invalid DAG-PB form (link Name must be a string)');
        }
        if (link.Tsize !== undefined) {
            if (typeof link.Tsize !== 'number' || link.Tsize % 1 !== 0) {
                throw new TypeError('Invalid DAG-PB form (link Tsize must be an integer)');
            }
            if (link.Tsize < 0) {
                throw new TypeError('Invalid DAG-PB form (link Tsize cannot be negative)');
            }
        }
        if (i > 0 && linkComparator(link, node.Links[i - 1]) === -1) {
            throw new TypeError('Invalid DAG-PB form (links must be sorted by Name bytes)');
        }
    }
}
function createNode(data, links = []) {
    return prepare({
        Data: data,
        Links: links
    });
}
function createLink(name, size, cid) {
    return asLink({
        Hash: cid,
        Name: name,
        Tsize: size
    });
}
function toByteView(buf) {
    if (buf instanceof ArrayBuffer) {
        return new Uint8Array(buf, 0, buf.byteLength);
    }
    return buf;
}
}),
"[project]/node_modules/@ipld/dag-pb/src/index.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "code",
    ()=>code,
    "decode",
    ()=>decode,
    "encode",
    ()=>encode,
    "name",
    ()=>name
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/cid.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$pb$2d$decode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-pb/src/pb-decode.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$pb$2d$encode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-pb/src/pb-encode.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-pb/src/util.js [app-client] (ecmascript)");
;
;
;
;
const name = 'dag-pb';
const code = 0x70;
function encode(node) {
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["validate"])(node);
    const pbn = {};
    if (node.Links) {
        pbn.Links = node.Links.map((l)=>{
            const link = {};
            if (l.Hash) {
                link.Hash = l.Hash.bytes; // cid -> bytes
            }
            if (l.Name !== undefined) {
                link.Name = l.Name;
            }
            if (l.Tsize !== undefined) {
                link.Tsize = l.Tsize;
            }
            return link;
        });
    }
    if (node.Data) {
        pbn.Data = node.Data;
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$pb$2d$encode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encodeNode"])(pbn);
}
function decode(bytes) {
    const buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toByteView"])(bytes);
    const pbn = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$pb$2f$src$2f$pb$2d$decode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeNode"])(buf);
    const node = {};
    if (pbn.Data) {
        node.Data = pbn.Data;
    }
    if (pbn.Links) {
        node.Links = pbn.Links.map((l)=>{
            const link = {};
            try {
                link.Hash = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].decode(l.Hash);
            } catch  {
            // ignore parse fail
            }
            if (!link.Hash) {
                throw new Error('Invalid Hash field found in link, expected CID');
            }
            if (l.Name !== undefined) {
                link.Name = l.Name;
            }
            if (l.Tsize !== undefined) {
                link.Tsize = l.Tsize;
            }
            return link;
        });
    }
    return node;
}
;
}),
"[project]/node_modules/@protobufjs/aspromise/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = asPromise;
/**
 * Callback as used by {@link util.asPromise}.
 * @typedef asPromiseCallback
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {...*} params Additional arguments
 * @returns {undefined}
 */ /**
 * Returns a promise from a node-style callback function.
 * @memberof util
 * @param {asPromiseCallback} fn Function to call
 * @param {*} ctx Function context
 * @param {...*} params Function arguments
 * @returns {Promise<*>} Promisified function
 */ function asPromise(fn, ctx /*, varargs */ ) {
    var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
    while(index < arguments.length)params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err /*, varargs */ ) {
            if (pending) {
                pending = false;
                if (err) reject(err);
                else {
                    var params = new Array(arguments.length - 1), offset = 0;
                    while(offset < params.length)params[offset++] = arguments[offset];
                    resolve.apply(null, params);
                }
            }
        };
        try {
            fn.apply(ctx || null, params);
        } catch (err) {
            if (pending) {
                pending = false;
                reject(err);
            }
        }
    });
}
}),
"[project]/node_modules/@protobufjs/base64/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * A minimal base64 implementation for number arrays.
 * @memberof util
 * @namespace
 */ var base64 = exports;
/**
 * Calculates the byte length of a base64 encoded string.
 * @param {string} string Base64 encoded string
 * @returns {number} Byte length
 */ base64.length = function length(string) {
    var p = string.length;
    if (!p) return 0;
    var n = 0;
    while(--p % 4 > 1 && string.charAt(p) === "=")++n;
    return Math.ceil(string.length * 3) / 4 - n;
};
// Base64 encoding table
var b64 = new Array(64);
// Base64 decoding table
var s64 = new Array(123);
// 65..90, 97..122, 48..57, 43, 47
for(var i = 0; i < 64;)s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
/**
 * Encodes a buffer to a base64 encoded string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} Base64 encoded string
 */ base64.encode = function encode(buffer, start, end) {
    var parts = null, chunk = [];
    var i = 0, j = 0, t; // temporary
    while(start < end){
        var b = buffer[start++];
        switch(j){
            case 0:
                chunk[i++] = b64[b >> 2];
                t = (b & 3) << 4;
                j = 1;
                break;
            case 1:
                chunk[i++] = b64[t | b >> 4];
                t = (b & 15) << 2;
                j = 2;
                break;
            case 2:
                chunk[i++] = b64[t | b >> 6];
                chunk[i++] = b64[b & 63];
                j = 0;
                break;
        }
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (j) {
        chunk[i++] = b64[t];
        chunk[i++] = 61;
        if (j === 1) chunk[i++] = 61;
    }
    if (parts) {
        if (i) parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};
var invalidEncoding = "invalid encoding";
/**
 * Decodes a base64 encoded string to a buffer.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Number of bytes written
 * @throws {Error} If encoding is invalid
 */ base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, t; // temporary
    for(var i = 0; i < string.length;){
        var c = string.charCodeAt(i++);
        if (c === 61 && j > 1) break;
        if ((c = s64[c]) === undefined) throw Error(invalidEncoding);
        switch(j){
            case 0:
                t = c;
                j = 1;
                break;
            case 1:
                buffer[offset++] = t << 2 | (c & 48) >> 4;
                t = c;
                j = 2;
                break;
            case 2:
                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
                t = c;
                j = 3;
                break;
            case 3:
                buffer[offset++] = (t & 3) << 6 | c;
                j = 0;
                break;
        }
    }
    if (j === 1) throw Error(invalidEncoding);
    return offset - start;
};
/**
 * Tests if the specified string appears to be base64 encoded.
 * @param {string} string String to test
 * @returns {boolean} `true` if probably base64 encoded, otherwise false
 */ base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
};
}),
"[project]/node_modules/@protobufjs/eventemitter/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = EventEmitter;
/**
 * Constructs a new event emitter instance.
 * @classdesc A minimal event emitter.
 * @memberof util
 * @constructor
 */ function EventEmitter() {
    /**
     * Registered listeners.
     * @type {Object.<string,*>}
     * @private
     */ this._listeners = {};
}
/**
 * Registers an event listener.
 * @param {string} evt Event name
 * @param {function} fn Listener
 * @param {*} [ctx] Listener context
 * @returns {util.EventEmitter} `this`
 */ EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn: fn,
        ctx: ctx || this
    });
    return this;
};
/**
 * Removes an event listener or any matching listeners if arguments are omitted.
 * @param {string} [evt] Event name. Removes all listeners if omitted.
 * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.
 * @returns {util.EventEmitter} `this`
 */ EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === undefined) this._listeners = {};
    else {
        if (fn === undefined) this._listeners[evt] = [];
        else {
            var listeners = this._listeners[evt];
            for(var i = 0; i < listeners.length;)if (listeners[i].fn === fn) listeners.splice(i, 1);
            else ++i;
        }
    }
    return this;
};
/**
 * Emits an event by calling its listeners with the specified arguments.
 * @param {string} evt Event name
 * @param {...*} args Arguments
 * @returns {util.EventEmitter} `this`
 */ EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
        var args = [], i = 1;
        for(; i < arguments.length;)args.push(arguments[i++]);
        for(i = 0; i < listeners.length;)listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
};
}),
"[project]/node_modules/@protobufjs/float/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = factory(factory);
/**
 * Reads / writes floats / doubles from / to buffers.
 * @name util.float
 * @namespace
 */ /**
 * Writes a 32 bit float to a buffer using little endian byte order.
 * @name util.float.writeFloatLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */ /**
 * Writes a 32 bit float to a buffer using big endian byte order.
 * @name util.float.writeFloatBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */ /**
 * Reads a 32 bit float from a buffer using little endian byte order.
 * @name util.float.readFloatLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */ /**
 * Reads a 32 bit float from a buffer using big endian byte order.
 * @name util.float.readFloatBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */ /**
 * Writes a 64 bit double to a buffer using little endian byte order.
 * @name util.float.writeDoubleLE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */ /**
 * Writes a 64 bit double to a buffer using big endian byte order.
 * @name util.float.writeDoubleBE
 * @function
 * @param {number} val Value to write
 * @param {Uint8Array} buf Target buffer
 * @param {number} pos Target buffer offset
 * @returns {undefined}
 */ /**
 * Reads a 64 bit double from a buffer using little endian byte order.
 * @name util.float.readDoubleLE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */ /**
 * Reads a 64 bit double from a buffer using big endian byte order.
 * @name util.float.readDoubleBE
 * @function
 * @param {Uint8Array} buf Source buffer
 * @param {number} pos Source buffer offset
 * @returns {number} Value read
 */ // Factory function for the purpose of node-based testing in modified global environments
function factory(exports) {
    // float: typed array
    if (typeof Float32Array !== "undefined") (function() {
        var f32 = new Float32Array([
            -0
        ]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
        function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
        }
        function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
        }
        /* istanbul ignore next */ exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        /* istanbul ignore next */ exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
        function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
        }
        function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
        }
        /* istanbul ignore next */ exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        /* istanbul ignore next */ exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
    // float: ieee754
    })();
    else (function() {
        function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign) val = -val;
            if (val === 0) writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);
            else if (isNaN(val)) writeUint(2143289344, buf, pos);
            else if (val > 3.4028234663852886e+38) writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 1.1754943508222875e-38) writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);
            else {
                var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
        }
        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
        function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 // denormal
             ? sign * 1.401298464324817e-45 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }
        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
    })();
    // double: typed array
    if (typeof Float64Array !== "undefined") (function() {
        var f64 = new Float64Array([
            -0
        ]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
        function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
        }
        function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
        }
        /* istanbul ignore next */ exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        /* istanbul ignore next */ exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
        function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
        }
        function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
        }
        /* istanbul ignore next */ exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        /* istanbul ignore next */ exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
    // double: ieee754
    })();
    else (function() {
        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign) val = -val;
            if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);
            } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
            } else if (val > 1.7976931348623157e+308) {
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
                var mantissa;
                if (val < 2.2250738585072014e-308) {
                    mantissa = val / 5e-324;
                    writeUint(mantissa >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                    var exponent = Math.floor(Math.log(val) / Math.LN2);
                    if (exponent === 1024) exponent = 1023;
                    mantissa = val * Math.pow(2, -exponent);
                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
            }
        }
        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 // denormal
             ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }
        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
    })();
    return exports;
}
// uint helpers
function writeUintLE(val, buf, pos) {
    buf[pos] = val & 255;
    buf[pos + 1] = val >>> 8 & 255;
    buf[pos + 2] = val >>> 16 & 255;
    buf[pos + 3] = val >>> 24;
}
function writeUintBE(val, buf, pos) {
    buf[pos] = val >>> 24;
    buf[pos + 1] = val >>> 16 & 255;
    buf[pos + 2] = val >>> 8 & 255;
    buf[pos + 3] = val & 255;
}
function readUintLE(buf, pos) {
    return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
}
function readUintBE(buf, pos) {
    return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
}
}),
"[project]/node_modules/@protobufjs/inquire/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = inquire;
/**
 * Requires a module only if available.
 * @memberof util
 * @param {string} moduleName Module to require
 * @returns {?Object} Required module if available and not empty, otherwise `null`
 */ function inquire(moduleName) {
    try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName); // eslint-disable-line no-eval
        if (mod && (mod.length || Object.keys(mod).length)) return mod;
    } catch (e) {} // eslint-disable-line no-empty
    return null;
}
}),
"[project]/node_modules/@protobufjs/utf8/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * A minimal UTF8 implementation for number arrays.
 * @memberof util
 * @namespace
 */ var utf8 = exports;
/**
 * Calculates the UTF8 byte length of a string.
 * @param {string} string String
 * @returns {number} Byte length
 */ utf8.length = function utf8_length(string) {
    var len = 0, c = 0;
    for(var i = 0; i < string.length; ++i){
        c = string.charCodeAt(i);
        if (c < 128) len += 1;
        else if (c < 2048) len += 2;
        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {
            ++i;
            len += 4;
        } else len += 3;
    }
    return len;
};
/**
 * Reads UTF8 bytes as a string.
 * @param {Uint8Array} buffer Source buffer
 * @param {number} start Source start
 * @param {number} end Source end
 * @returns {string} String read
 */ utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1) return "";
    var parts = null, chunk = [], i = 0, t; // temporary
    while(start < end){
        t = buffer[start++];
        if (t < 128) chunk[i++] = t;
        else if (t > 191 && t < 224) chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;
            chunk[i++] = 0xD800 + (t >> 10);
            chunk[i++] = 0xDC00 + (t & 1023);
        } else chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
        }
    }
    if (parts) {
        if (i) parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
};
/**
 * Writes a string as UTF8 bytes.
 * @param {string} string Source string
 * @param {Uint8Array} buffer Destination buffer
 * @param {number} offset Destination offset
 * @returns {number} Bytes written
 */ utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset, c1, c2; // character 2
    for(var i = 0; i < string.length; ++i){
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
            buffer[offset++] = c1;
        } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6 | 192;
            buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {
            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);
            ++i;
            buffer[offset++] = c1 >> 18 | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6 & 63 | 128;
            buffer[offset++] = c1 & 63 | 128;
        } else {
            buffer[offset++] = c1 >> 12 | 224;
            buffer[offset++] = c1 >> 6 & 63 | 128;
            buffer[offset++] = c1 & 63 | 128;
        }
    }
    return offset - start;
};
}),
"[project]/node_modules/@protobufjs/pool/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = pool;
/**
 * An allocator as used by {@link util.pool}.
 * @typedef PoolAllocator
 * @type {function}
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */ /**
 * A slicer as used by {@link util.pool}.
 * @typedef PoolSlicer
 * @type {function}
 * @param {number} start Start offset
 * @param {number} end End offset
 * @returns {Uint8Array} Buffer slice
 * @this {Uint8Array}
 */ /**
 * A general purpose buffer pool.
 * @memberof util
 * @function
 * @param {PoolAllocator} alloc Allocator
 * @param {PoolSlicer} slice Slicer
 * @param {number} [size=8192] Slab size
 * @returns {PoolAllocator} Pooled allocator
 */ function pool(alloc, slice, size) {
    var SIZE = size || 8192;
    var MAX = SIZE >>> 1;
    var slab = null;
    var offset = SIZE;
    return function pool_alloc(size) {
        if (size < 1 || size > MAX) return alloc(size);
        if (offset + size > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size);
        if (offset & 7) offset = (offset | 7) + 1;
        return buf;
    };
}
}),
"[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/util/longbits.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = LongBits;
var util = __turbopack_context__.r("[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/util/minimal.js [app-client] (ecmascript)");
/**
 * Constructs new long bits.
 * @classdesc Helper class for working with the low and high bits of a 64 bit value.
 * @memberof util
 * @constructor
 * @param {number} lo Low 32 bits, unsigned
 * @param {number} hi High 32 bits, unsigned
 */ function LongBits(lo, hi) {
    // note that the casts below are theoretically unnecessary as of today, but older statically
    // generated converter code might still call the ctor with signed 32bits. kept for compat.
    /**
     * Low bits.
     * @type {number}
     */ this.lo = lo >>> 0;
    /**
     * High bits.
     * @type {number}
     */ this.hi = hi >>> 0;
}
/**
 * Zero bits.
 * @memberof util.LongBits
 * @type {util.LongBits}
 */ var zero = LongBits.zero = new LongBits(0, 0);
zero.toNumber = function() {
    return 0;
};
zero.zzEncode = zero.zzDecode = function() {
    return this;
};
zero.length = function() {
    return 1;
};
/**
 * Zero hash.
 * @memberof util.LongBits
 * @type {string}
 */ var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
/**
 * Constructs new long bits from the specified number.
 * @param {number} value Value
 * @returns {util.LongBits} Instance
 */ LongBits.fromNumber = function fromNumber(value) {
    if (value === 0) return zero;
    var sign = value < 0;
    if (sign) value = -value;
    var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295) hi = 0;
        }
    }
    return new LongBits(lo, hi);
};
/**
 * Constructs new long bits from a number, long or string.
 * @param {Long|number|string} value Value
 * @returns {util.LongBits} Instance
 */ LongBits.from = function from(value) {
    if (typeof value === "number") return LongBits.fromNumber(value);
    if (util.isString(value)) {
        /* istanbul ignore else */ if (util.Long) value = util.Long.fromString(value);
        else return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
};
/**
 * Converts this long bits to a possibly unsafe JavaScript number.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {number} Possibly unsafe number
 */ LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo) hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
};
/**
 * Converts this long bits to a long.
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long} Long
 */ LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : {
        low: this.lo | 0,
        high: this.hi | 0,
        unsigned: Boolean(unsigned)
    };
};
var charCodeAt = String.prototype.charCodeAt;
/**
 * Constructs new long bits from the specified 8 characters long hash.
 * @param {string} hash Hash
 * @returns {util.LongBits} Bits
 */ LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash) return zero;
    return new LongBits((charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0, (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0);
};
/**
 * Converts this long bits to a 8 characters long hash.
 * @returns {string} Hash
 */ LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
};
/**
 * Zig-zag encodes this long bits.
 * @returns {util.LongBits} `this`
 */ LongBits.prototype.zzEncode = function zzEncode() {
    var mask = this.hi >> 31;
    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo = (this.lo << 1 ^ mask) >>> 0;
    return this;
};
/**
 * Zig-zag decodes this long bits.
 * @returns {util.LongBits} `this`
 */ LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi = (this.hi >>> 1 ^ mask) >>> 0;
    return this;
};
/**
 * Calculates the length of this longbits when encoded as a varint.
 * @returns {number} Length
 */ LongBits.prototype.length = function length() {
    var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
    return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
};
}),
"[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/util/minimal.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var util = exports;
// used to return a Promise where callback is omitted
util.asPromise = __turbopack_context__.r("[project]/node_modules/@protobufjs/aspromise/index.js [app-client] (ecmascript)");
// converts to / from base64 encoded strings
util.base64 = __turbopack_context__.r("[project]/node_modules/@protobufjs/base64/index.js [app-client] (ecmascript)");
// base class of rpc.Service
util.EventEmitter = __turbopack_context__.r("[project]/node_modules/@protobufjs/eventemitter/index.js [app-client] (ecmascript)");
// float handling accross browsers
util.float = __turbopack_context__.r("[project]/node_modules/@protobufjs/float/index.js [app-client] (ecmascript)");
// requires modules optionally and hides the call from bundlers
util.inquire = __turbopack_context__.r("[project]/node_modules/@protobufjs/inquire/index.js [app-client] (ecmascript)");
// converts to / from utf8 encoded strings
util.utf8 = __turbopack_context__.r("[project]/node_modules/@protobufjs/utf8/index.js [app-client] (ecmascript)");
// provides a node-like buffer pool in the browser
util.pool = __turbopack_context__.r("[project]/node_modules/@protobufjs/pool/index.js [app-client] (ecmascript)");
// utility to work with the low and high bits of a 64 bit value
util.LongBits = __turbopack_context__.r("[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/util/longbits.js [app-client] (ecmascript)");
/**
 * Whether running within node or not.
 * @memberof util
 * @type {boolean}
 */ util.isNode = Boolean(("TURBOPACK compile-time value", "object") !== "undefined" && /*TURBOPACK member replacement*/ __turbopack_context__.g && /*TURBOPACK member replacement*/ __turbopack_context__.g.process && /*TURBOPACK member replacement*/ __turbopack_context__.g.process.versions && /*TURBOPACK member replacement*/ __turbopack_context__.g.process.versions.node);
/**
 * Global object reference.
 * @memberof util
 * @type {Object}
 */ util.global = util.isNode && /*TURBOPACK member replacement*/ __turbopack_context__.g || typeof window !== "undefined" && window || typeof self !== "undefined" && self || /*TURBOPACK member replacement*/ __turbopack_context__.e; // eslint-disable-line no-invalid-this
/**
 * An immuable empty array.
 * @memberof util
 * @type {Array.<*>}
 * @const
 */ util.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes
/**
 * An immutable empty object.
 * @type {Object}
 * @const
 */ util.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes
/**
 * Tests if the specified value is an integer.
 * @function
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is an integer
 */ util.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
};
/**
 * Tests if the specified value is a string.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a string
 */ util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
};
/**
 * Tests if the specified value is a non-null object.
 * @param {*} value Value to test
 * @returns {boolean} `true` if the value is a non-null object
 */ util.isObject = function isObject(value) {
    return value && typeof value === "object";
};
/**
 * Checks if a property on a message is considered to be present.
 * This is an alias of {@link util.isSet}.
 * @function
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */ util.isset = /**
 * Checks if a property on a message is considered to be present.
 * @param {Object} obj Plain object or message instance
 * @param {string} prop Property name
 * @returns {boolean} `true` if considered to be present, otherwise `false`
 */ util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop)) return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
};
/**
 * Any compatible Buffer instance.
 * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.
 * @interface Buffer
 * @extends Uint8Array
 */ /**
 * Node's Buffer class if available.
 * @type {Constructor<Buffer>}
 */ util.Buffer = function() {
    try {
        var Buffer = util.inquire("buffer").Buffer;
        // refuse to use non-node buffers if not explicitly assigned (perf reasons):
        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;
    } catch (e) {
        /* istanbul ignore next */ return null;
    }
}();
// Internal alias of or polyfull for Buffer.from.
util._Buffer_from = null;
// Internal alias of or polyfill for Buffer.allocUnsafe.
util._Buffer_allocUnsafe = null;
/**
 * Creates a new buffer of whatever type supported by the environment.
 * @param {number|number[]} [sizeOrArray=0] Buffer size or number array
 * @returns {Uint8Array|Buffer} Buffer
 */ util.newBuffer = function newBuffer(sizeOrArray) {
    /* istanbul ignore next */ return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
};
/**
 * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.
 * @type {Constructor<Uint8Array>}
 */ util.Array = typeof Uint8Array !== "undefined" ? Uint8Array /* istanbul ignore next */  : Array;
/**
 * Any compatible Long instance.
 * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.
 * @interface Long
 * @property {number} low Low bits
 * @property {number} high High bits
 * @property {boolean} unsigned Whether unsigned or not
 */ /**
 * Long.js's Long class if available.
 * @type {Constructor<Long>}
 */ util.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long || /* istanbul ignore next */ util.global.Long || util.inquire("long");
/**
 * Regular expression used to verify 2 bit (`bool`) map keys.
 * @type {RegExp}
 * @const
 */ util.key2Re = /^true|false|0|1$/;
/**
 * Regular expression used to verify 32 bit (`int32` etc.) map keys.
 * @type {RegExp}
 * @const
 */ util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
/**
 * Regular expression used to verify 64 bit (`int64` etc.) map keys.
 * @type {RegExp}
 * @const
 */ util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
/**
 * Converts a number or long to an 8 characters long hash string.
 * @param {Long|number} value Value to convert
 * @returns {string} Hash
 */ util.longToHash = function longToHash(value) {
    return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
};
/**
 * Converts an 8 characters long hash string to a long or number.
 * @param {string} hash Hash
 * @param {boolean} [unsigned=false] Whether unsigned or not
 * @returns {Long|number} Original value
 */ util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long) return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
};
/**
 * Merges the properties of the source object into the destination object.
 * @memberof util
 * @param {Object.<string,*>} dst Destination object
 * @param {Object.<string,*>} src Source object
 * @param {boolean} [ifNotSet=false] Merges only if the key is not already set
 * @returns {Object.<string,*>} Destination object
 */ function merge(dst, src, ifNotSet) {
    for(var keys = Object.keys(src), i = 0; i < keys.length; ++i)if (dst[keys[i]] === undefined || !ifNotSet) dst[keys[i]] = src[keys[i]];
    return dst;
}
util.merge = merge;
/**
 * Converts the first character of a string to lower case.
 * @param {string} str String to convert
 * @returns {string} Converted string
 */ util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
};
/**
 * Creates a custom error constructor.
 * @memberof util
 * @param {string} name Error name
 * @returns {Constructor<Error>} Custom error constructor
 */ function newError(name) {
    function CustomError(message, properties) {
        if (!(this instanceof CustomError)) return new CustomError(message, properties);
        // Error.call(this, message);
        // ^ just returns a new error instance because the ctor can be called as a function
        Object.defineProperty(this, "message", {
            get: function() {
                return message;
            }
        });
        /* istanbul ignore next */ if (Error.captureStackTrace) Error.captureStackTrace(this, CustomError);
        else Object.defineProperty(this, "stack", {
            value: new Error().stack || ""
        });
        if (properties) merge(this, properties);
    }
    CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
            value: CustomError,
            writable: true,
            enumerable: false,
            configurable: true
        },
        name: {
            get: function get() {
                return name;
            },
            set: undefined,
            enumerable: false,
            // configurable: false would accurately preserve the behavior of
            // the original, but I'm guessing that was not intentional.
            // For an actual error subclass, this property would
            // be configurable.
            configurable: true
        },
        toString: {
            value: function value() {
                return this.name + ": " + this.message;
            },
            writable: true,
            enumerable: false,
            configurable: true
        }
    });
    return CustomError;
}
util.newError = newError;
/**
 * Constructs a new protocol error.
 * @classdesc Error subclass indicating a protocol specifc error.
 * @memberof util
 * @extends Error
 * @template T extends Message<T>
 * @constructor
 * @param {string} message Error message
 * @param {Object.<string,*>} [properties] Additional properties
 * @example
 * try {
 *     MyMessage.decode(someBuffer); // throws if required fields are missing
 * } catch (e) {
 *     if (e instanceof ProtocolError && e.instance)
 *         console.log("decoded so far: " + JSON.stringify(e.instance));
 * }
 */ util.ProtocolError = newError("ProtocolError");
/**
 * So far decoded message instance.
 * @name util.ProtocolError#instance
 * @type {Message<T>}
 */ /**
 * A OneOf getter as returned by {@link util.oneOfGetter}.
 * @typedef OneOfGetter
 * @type {function}
 * @returns {string|undefined} Set field name, if any
 */ /**
 * Builds a getter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfGetter} Unbound getter
 */ util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for(var i = 0; i < fieldNames.length; ++i)fieldMap[fieldNames[i]] = 1;
    /**
     * @returns {string|undefined} Set field name, if any
     * @this Object
     * @ignore
     */ return function() {
        for(var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null) return keys[i];
    };
};
/**
 * A OneOf setter as returned by {@link util.oneOfSetter}.
 * @typedef OneOfSetter
 * @type {function}
 * @param {string|undefined} value Field name
 * @returns {undefined}
 */ /**
 * Builds a setter for a oneof's present field name.
 * @param {string[]} fieldNames Field names
 * @returns {OneOfSetter} Unbound setter
 */ util.oneOfSetter = function setOneOf(fieldNames) {
    /**
     * @param {string} name Field name
     * @returns {undefined}
     * @this Object
     * @ignore
     */ return function(name) {
        for(var i = 0; i < fieldNames.length; ++i)if (fieldNames[i] !== name) delete this[fieldNames[i]];
    };
};
/**
 * Default conversion options used for {@link Message#toJSON} implementations.
 *
 * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:
 *
 * - Longs become strings
 * - Enums become string keys
 * - Bytes become base64 encoded strings
 * - (Sub-)Messages become plain objects
 * - Maps become plain objects with all string keys
 * - Repeated fields become arrays
 * - NaN and Infinity for float and double fields become strings
 *
 * @type {IConversionOptions}
 * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json
 */ util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
};
// Sets up buffer utility according to the environment (called in index-minimal)
util._configure = function() {
    var Buffer = util.Buffer;
    /* istanbul ignore if */ if (!Buffer) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
    }
    // because node 4.x buffers are incompatible & immutable
    // see: https://github.com/dcodeIO/protobuf.js/pull/665
    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from || /* istanbul ignore next */ function Buffer_from(value, encoding) {
        return new Buffer(value, encoding);
    };
    util._Buffer_allocUnsafe = Buffer.allocUnsafe || /* istanbul ignore next */ function Buffer_allocUnsafe(size) {
        return new Buffer(size);
    };
};
}),
"[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/writer.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = Writer;
var util = __turbopack_context__.r("[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/util/minimal.js [app-client] (ecmascript)");
var BufferWriter; // cyclic
var LongBits = util.LongBits, base64 = util.base64, utf8 = util.utf8;
/**
 * Constructs a new writer operation instance.
 * @classdesc Scheduled writer operation.
 * @constructor
 * @param {function(*, Uint8Array, number)} fn Function to call
 * @param {number} len Value byte length
 * @param {*} val Value to write
 * @ignore
 */ function Op(fn, len, val) {
    /**
     * Function to call.
     * @type {function(Uint8Array, number, *)}
     */ this.fn = fn;
    /**
     * Value byte length.
     * @type {number}
     */ this.len = len;
    /**
     * Next operation.
     * @type {Writer.Op|undefined}
     */ this.next = undefined;
    /**
     * Value to write.
     * @type {*}
     */ this.val = val; // type varies
}
/* istanbul ignore next */ function noop() {} // eslint-disable-line no-empty-function
/**
 * Constructs a new writer state instance.
 * @classdesc Copied writer state.
 * @memberof Writer
 * @constructor
 * @param {Writer} writer Writer to copy state from
 * @ignore
 */ function State(writer) {
    /**
     * Current head.
     * @type {Writer.Op}
     */ this.head = writer.head;
    /**
     * Current tail.
     * @type {Writer.Op}
     */ this.tail = writer.tail;
    /**
     * Current buffer length.
     * @type {number}
     */ this.len = writer.len;
    /**
     * Next state.
     * @type {State|null}
     */ this.next = writer.states;
}
/**
 * Constructs a new writer instance.
 * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 */ function Writer() {
    /**
     * Current length.
     * @type {number}
     */ this.len = 0;
    /**
     * Operations head.
     * @type {Object}
     */ this.head = new Op(noop, 0, 0);
    /**
     * Operations tail
     * @type {Object}
     */ this.tail = this.head;
    /**
     * Linked forked states.
     * @type {Object|null}
     */ this.states = null;
// When a value is written, the writer calculates its byte length and puts it into a linked
// list of operations to perform when finish() is called. This both allows us to allocate
// buffers of the exact required size and reduces the amount of work we have to do compared
// to first calculating over objects and then encoding over objects. In our case, the encoding
// part is just a linked list walk calling operations with already prepared values.
}
var create = function create() {
    return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
            return new BufferWriter();
        })();
    } : function create_array() {
        return new Writer();
    };
};
/**
 * Creates a new writer.
 * @function
 * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}
 */ Writer.create = create();
/**
 * Allocates a buffer of the specified size.
 * @param {number} size Buffer size
 * @returns {Uint8Array} Buffer
 */ Writer.alloc = function alloc(size) {
    return new util.Array(size);
};
// Use Uint8Array buffer pool in the browser, just like node does with buffers
/* istanbul ignore else */ if (util.Array !== Array) Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
/**
 * Pushes a new operation to the queue.
 * @param {function(Uint8Array, number, *)} fn Function to call
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @returns {Writer} `this`
 * @private
 */ Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
};
function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
}
function writeVarint32(val, buf, pos) {
    while(val > 127){
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
    }
    buf[pos] = val;
}
/**
 * Constructs a new varint writer operation instance.
 * @classdesc Scheduled varint writer operation.
 * @extends Op
 * @constructor
 * @param {number} len Value byte length
 * @param {number} val Value to write
 * @ignore
 */ function VarintOp(len, val) {
    this.len = len;
    this.next = undefined;
    this.val = val;
}
VarintOp.prototype = Object.create(Op.prototype);
VarintOp.prototype.fn = writeVarint32;
/**
 * Writes an unsigned 32 bit value as a varint.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.uint32 = function write_uint32(value) {
    // here, the call to this.push has been inlined and a varint specific Op subclass is used.
    // uint32 is by far the most frequently used operation and benefits significantly from this.
    this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
    return this;
};
/**
 * Writes a signed 32 bit value as a varint.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.int32 = function write_int32(value) {
    return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec
     : this.uint32(value);
};
/**
 * Writes a 32 bit value as a varint, zig-zag encoded.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
};
function writeVarint64(val, buf, pos) {
    while(val.hi){
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
    }
    while(val.lo > 127){
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
}
/**
 * Writes an unsigned 64 bit value as a varint.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */ Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
};
/**
 * Writes a signed 64 bit value as a varint.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */ Writer.prototype.int64 = Writer.prototype.uint64;
/**
 * Writes a signed 64 bit value as a varint, zig-zag encoded.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */ Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
};
/**
 * Writes a boolish value as a varint.
 * @param {boolean} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
};
function writeFixed32(val, buf, pos) {
    buf[pos] = val & 255;
    buf[pos + 1] = val >>> 8 & 255;
    buf[pos + 2] = val >>> 16 & 255;
    buf[pos + 3] = val >>> 24;
}
/**
 * Writes an unsigned 32 bit value as fixed 32 bits.
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
};
/**
 * Writes a signed 32 bit value as fixed 32 bits.
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.sfixed32 = Writer.prototype.fixed32;
/**
 * Writes an unsigned 64 bit value as fixed 64 bits.
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */ Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
};
/**
 * Writes a signed 64 bit value as fixed 64 bits.
 * @function
 * @param {Long|number|string} value Value to write
 * @returns {Writer} `this`
 * @throws {TypeError} If `value` is a string and no long library is present.
 */ Writer.prototype.sfixed64 = Writer.prototype.fixed64;
/**
 * Writes a float (32 bit).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
};
/**
 * Writes a double (64 bit float).
 * @function
 * @param {number} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
};
var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
    buf.set(val, pos); // also works for plain array values
} : function writeBytes_for(val, buf, pos) {
    for(var i = 0; i < val.length; ++i)buf[pos + i] = val[i];
};
/**
 * Writes a sequence of bytes.
 * @param {Uint8Array|string} value Buffer or base64 encoded string to write
 * @returns {Writer} `this`
 */ Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len) return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
};
/**
 * Writes a string.
 * @param {string} value Value to write
 * @returns {Writer} `this`
 */ Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
};
/**
 * Forks this writer's state by pushing it to a stack.
 * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.
 * @returns {Writer} `this`
 */ Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
};
/**
 * Resets this instance to the last state.
 * @returns {Writer} `this`
 */ Writer.prototype.reset = function reset() {
    if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
    } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
    }
    return this;
};
/**
 * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.
 * @returns {Writer} `this`
 */ Writer.prototype.ldelim = function ldelim() {
    var head = this.head, tail = this.tail, len = this.len;
    this.reset().uint32(len);
    if (len) {
        this.tail.next = head.next; // skip noop
        this.tail = tail;
        this.len += len;
    }
    return this;
};
/**
 * Finishes the write operation.
 * @returns {Uint8Array} Finished buffer
 */ Writer.prototype.finish = function finish() {
    var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
    while(head){
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
    }
    // this.head = this.tail = null;
    return buf;
};
Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
};
}),
"[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/writer_buffer.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = BufferWriter;
// extends Writer
var Writer = __turbopack_context__.r("[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/writer.js [app-client] (ecmascript)");
(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
var util = __turbopack_context__.r("[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/util/minimal.js [app-client] (ecmascript)");
/**
 * Constructs a new buffer writer instance.
 * @classdesc Wire format writer using node buffers.
 * @extends Writer
 * @constructor
 */ function BufferWriter() {
    Writer.call(this);
}
BufferWriter._configure = function() {
    /**
     * Allocates a buffer of the specified size.
     * @function
     * @param {number} size Buffer size
     * @returns {Buffer} Buffer
     */ BufferWriter.alloc = util._Buffer_allocUnsafe;
    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)
    // also works for plain array values
    } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy) val.copy(buf, pos, 0, val.length);
        else for(var i = 0; i < val.length;)buf[pos++] = val[i++];
    };
};
/**
 * @override
 */ BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value)) value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len) this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
};
function writeStringBuffer(val, buf, pos) {
    if (val.length < 40) util.utf8.write(val, buf, pos);
    else if (buf.utf8Write) buf.utf8Write(val, pos);
    else buf.write(val, pos);
}
/**
 * @override
 */ BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util.Buffer.byteLength(value);
    this.uint32(len);
    if (len) this._push(writeStringBuffer, len, value);
    return this;
};
/**
 * Finishes the write operation.
 * @name BufferWriter#finish
 * @function
 * @returns {Buffer} Finished buffer
 */ BufferWriter._configure();
}),
"[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/reader.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = Reader;
var util = __turbopack_context__.r("[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/util/minimal.js [app-client] (ecmascript)");
var BufferReader; // cyclic
var LongBits = util.LongBits, utf8 = util.utf8;
/* istanbul ignore next */ function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
}
/**
 * Constructs a new reader instance using the specified buffer.
 * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.
 * @constructor
 * @param {Uint8Array} buffer Buffer to read from
 */ function Reader(buffer) {
    /**
     * Read buffer.
     * @type {Uint8Array}
     */ this.buf = buffer;
    /**
     * Read buffer position.
     * @type {number}
     */ this.pos = 0;
    /**
     * Read buffer length.
     * @type {number}
     */ this.len = buffer.length;
}
var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
    if (buffer instanceof Uint8Array || Array.isArray(buffer)) return new Reader(buffer);
    throw Error("illegal buffer");
} : function create_array(buffer) {
    if (Array.isArray(buffer)) return new Reader(buffer);
    throw Error("illegal buffer");
};
var create = function create() {
    return util.Buffer ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer) {
            return util.Buffer.isBuffer(buffer) ? new BufferReader(buffer) : create_array(buffer);
        })(buffer);
    } : create_array;
};
/**
 * Creates a new reader using the specified buffer.
 * @function
 * @param {Uint8Array|Buffer} buffer Buffer to read from
 * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}
 * @throws {Error} If `buffer` is not a valid buffer
 */ Reader.create = create();
Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;
/**
 * Reads a varint as an unsigned 32 bit value.
 * @function
 * @returns {number} Value read
 */ Reader.prototype.uint32 = function read_uint32_setup() {
    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)
    return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        /* istanbul ignore if */ if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
        }
        return value;
    };
}();
/**
 * Reads a varint as a signed 32 bit value.
 * @returns {number} Value read
 */ Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
};
/**
 * Reads a zig-zag encoded varint as a signed 32 bit value.
 * @returns {number} Value read
 */ Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
};
/* eslint-disable no-invalid-this */ function readLongVarint() {
    // tends to deopt with local vars for octet etc.
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) {
        for(; i < 4; ++i){
            // 1st..4th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128) return bits;
        }
        // 5th
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128) return bits;
        i = 0;
    } else {
        for(; i < 3; ++i){
            /* istanbul ignore if */ if (this.pos >= this.len) throw indexOutOfRange(this);
            // 1st..3th
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128) return bits;
        }
        // 4th
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
    }
    if (this.len - this.pos > 4) {
        for(; i < 5; ++i){
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128) return bits;
        }
    } else {
        for(; i < 5; ++i){
            /* istanbul ignore if */ if (this.pos >= this.len) throw indexOutOfRange(this);
            // 6th..10th
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128) return bits;
        }
    }
    /* istanbul ignore next */ throw Error("invalid varint encoding");
}
/* eslint-enable no-invalid-this */ /**
 * Reads a varint as a signed 64 bit value.
 * @name Reader#int64
 * @function
 * @returns {Long} Value read
 */ /**
 * Reads a varint as an unsigned 64 bit value.
 * @name Reader#uint64
 * @function
 * @returns {Long} Value read
 */ /**
 * Reads a zig-zag encoded varint as a signed 64 bit value.
 * @name Reader#sint64
 * @function
 * @returns {Long} Value read
 */ /**
 * Reads a varint as a boolean.
 * @returns {boolean} Value read
 */ Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
};
function readFixed32_end(buf, end) {
    return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
}
/**
 * Reads fixed 32 bits as an unsigned 32 bit integer.
 * @returns {number} Value read
 */ Reader.prototype.fixed32 = function read_fixed32() {
    /* istanbul ignore if */ if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
    return readFixed32_end(this.buf, this.pos += 4);
};
/**
 * Reads fixed 32 bits as a signed 32 bit integer.
 * @returns {number} Value read
 */ Reader.prototype.sfixed32 = function read_sfixed32() {
    /* istanbul ignore if */ if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
    return readFixed32_end(this.buf, this.pos += 4) | 0;
};
/* eslint-disable no-invalid-this */ function readFixed64() {
    /* istanbul ignore if */ if (this.pos + 8 > this.len) throw indexOutOfRange(this, 8);
    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
}
/* eslint-enable no-invalid-this */ /**
 * Reads fixed 64 bits.
 * @name Reader#fixed64
 * @function
 * @returns {Long} Value read
 */ /**
 * Reads zig-zag encoded fixed 64 bits.
 * @name Reader#sfixed64
 * @function
 * @returns {Long} Value read
 */ /**
 * Reads a float (32 bit) as a number.
 * @function
 * @returns {number} Value read
 */ Reader.prototype.float = function read_float() {
    /* istanbul ignore if */ if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
};
/**
 * Reads a double (64 bit float) as a number.
 * @function
 * @returns {number} Value read
 */ Reader.prototype.double = function read_double() {
    /* istanbul ignore if */ if (this.pos + 8 > this.len) throw indexOutOfRange(this, 4);
    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
};
/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @returns {Uint8Array} Value read
 */ Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(), start = this.pos, end = this.pos + length;
    /* istanbul ignore if */ if (end > this.len) throw indexOutOfRange(this, length);
    this.pos += length;
    if (Array.isArray(this.buf)) return this.buf.slice(start, end);
    if (start === end) {
        var nativeBuffer = util.Buffer;
        return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);
    }
    return this._slice.call(this.buf, start, end);
};
/**
 * Reads a string preceeded by its byte length as a varint.
 * @returns {string} Value read
 */ Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
};
/**
 * Skips the specified number of bytes if specified, otherwise skips a varint.
 * @param {number} [length] Length if known, otherwise a varint is assumed
 * @returns {Reader} `this`
 */ Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
        /* istanbul ignore if */ if (this.pos + length > this.len) throw indexOutOfRange(this, length);
        this.pos += length;
    } else {
        do {
            /* istanbul ignore if */ if (this.pos >= this.len) throw indexOutOfRange(this);
        }while (this.buf[this.pos++] & 128)
    }
    return this;
};
/**
 * Skips the next element of the specified wire type.
 * @param {number} wireType Wire type received
 * @returns {Reader} `this`
 */ Reader.prototype.skipType = function(wireType) {
    switch(wireType){
        case 0:
            this.skip();
            break;
        case 1:
            this.skip(8);
            break;
        case 2:
            this.skip(this.uint32());
            break;
        case 3:
            while((wireType = this.uint32() & 7) !== 4){
                this.skipType(wireType);
            }
            break;
        case 5:
            this.skip(4);
            break;
        /* istanbul ignore next */ default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
};
Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();
    var fn = util.Long ? "toLong" : /* istanbul ignore next */ "toNumber";
    util.merge(Reader.prototype, {
        int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
        }
    });
};
}),
"[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/reader_buffer.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = BufferReader;
// extends Reader
var Reader = __turbopack_context__.r("[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/reader.js [app-client] (ecmascript)");
(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
var util = __turbopack_context__.r("[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/util/minimal.js [app-client] (ecmascript)");
/**
 * Constructs a new buffer reader instance.
 * @classdesc Wire format reader using node buffers.
 * @extends Reader
 * @constructor
 * @param {Buffer} buffer Buffer to read from
 */ function BufferReader(buffer) {
    Reader.call(this, buffer);
/**
     * Read buffer.
     * @name BufferReader#buf
     * @type {Buffer}
     */ }
BufferReader._configure = function() {
    /* istanbul ignore else */ if (util.Buffer) BufferReader.prototype._slice = util.Buffer.prototype.slice;
};
/**
 * @override
 */ BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32(); // modifies pos
    return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
};
/**
 * Reads a sequence of bytes preceeded by its length as a varint.
 * @name BufferReader#bytes
 * @function
 * @returns {Buffer} Value read
 */ BufferReader._configure();
}),
"[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/rpc/service.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = Service;
var util = __turbopack_context__.r("[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/util/minimal.js [app-client] (ecmascript)");
// Extends EventEmitter
(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
/**
 * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.
 *
 * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.
 * @typedef rpc.ServiceMethodCallback
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {Error|null} error Error, if any
 * @param {TRes} [response] Response message
 * @returns {undefined}
 */ /**
 * A service method part of a {@link rpc.Service} as created by {@link Service.create}.
 * @typedef rpc.ServiceMethod
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 * @type {function}
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message
 * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`
 */ /**
 * Constructs a new RPC service instance.
 * @classdesc An RPC service as returned by {@link Service#create}.
 * @exports rpc.Service
 * @extends util.EventEmitter
 * @constructor
 * @param {RPCImpl} rpcImpl RPC implementation
 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
 */ function Service(rpcImpl, requestDelimited, responseDelimited) {
    if (typeof rpcImpl !== "function") throw TypeError("rpcImpl must be a function");
    util.EventEmitter.call(this);
    /**
     * RPC implementation. Becomes `null` once the service is ended.
     * @type {RPCImpl|null}
     */ this.rpcImpl = rpcImpl;
    /**
     * Whether requests are length-delimited.
     * @type {boolean}
     */ this.requestDelimited = Boolean(requestDelimited);
    /**
     * Whether responses are length-delimited.
     * @type {boolean}
     */ this.responseDelimited = Boolean(responseDelimited);
}
/**
 * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.
 * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method
 * @param {Constructor<TReq>} requestCtor Request constructor
 * @param {Constructor<TRes>} responseCtor Response constructor
 * @param {TReq|Properties<TReq>} request Request message or plain object
 * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback
 * @returns {undefined}
 * @template TReq extends Message<TReq>
 * @template TRes extends Message<TRes>
 */ Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
    if (!request) throw TypeError("request must be specified");
    var self = this;
    if (!callback) return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);
    if (!self.rpcImpl) {
        setTimeout(function() {
            callback(Error("already ended"));
        }, 0);
        return undefined;
    }
    try {
        return self.rpcImpl(method, requestCtor[self.requestDelimited ? "encodeDelimited" : "encode"](request).finish(), function rpcCallback(err, response) {
            if (err) {
                self.emit("error", err, method);
                return callback(err);
            }
            if (response === null) {
                self.end(/* endedByRPC */ true);
                return undefined;
            }
            if (!(response instanceof responseCtor)) {
                try {
                    response = responseCtor[self.responseDelimited ? "decodeDelimited" : "decode"](response);
                } catch (err) {
                    self.emit("error", err, method);
                    return callback(err);
                }
            }
            self.emit("data", response, method);
            return callback(null, response);
        });
    } catch (err) {
        self.emit("error", err, method);
        setTimeout(function() {
            callback(err);
        }, 0);
        return undefined;
    }
};
/**
 * Ends this service and emits the `end` event.
 * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.
 * @returns {rpc.Service} `this`
 */ Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
        if (!endedByRPC) this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
    }
    return this;
};
}),
"[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/rpc.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

/**
 * Streaming RPC helpers.
 * @namespace
 */ var rpc = exports;
/**
 * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.
 * @typedef RPCImpl
 * @type {function}
 * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called
 * @param {Uint8Array} requestData Request data
 * @param {RPCImplCallback} callback Callback function
 * @returns {undefined}
 * @example
 * function rpcImpl(method, requestData, callback) {
 *     if (protobuf.util.lcFirst(method.name) !== "myMethod") // compatible with static code
 *         throw Error("no such method");
 *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {
 *         callback(err, responseData);
 *     });
 * }
 */ /**
 * Node-style callback as used by {@link RPCImpl}.
 * @typedef RPCImplCallback
 * @type {function}
 * @param {Error|null} error Error, if any, otherwise `null`
 * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error
 * @returns {undefined}
 */ rpc.Service = __turbopack_context__.r("[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/rpc/service.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/roots.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

module.exports = {}; /**
 * Named roots.
 * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).
 * Can also be used manually to make roots available across modules.
 * @name roots
 * @type {Object.<string,Root>}
 * @example
 * // pbjs -r myroot -o compiled.js ...
 *
 * // in another module:
 * require("./compiled.js");
 *
 * // in any subsequent module:
 * var root = protobuf.roots["myroot"];
 */ 
}),
"[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/index-minimal.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

var protobuf = exports;
/**
 * Build type, one of `"full"`, `"light"` or `"minimal"`.
 * @name build
 * @type {string}
 * @const
 */ protobuf.build = "minimal";
// Serialization
protobuf.Writer = __turbopack_context__.r("[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/writer.js [app-client] (ecmascript)");
protobuf.BufferWriter = __turbopack_context__.r("[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/writer_buffer.js [app-client] (ecmascript)");
protobuf.Reader = __turbopack_context__.r("[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/reader.js [app-client] (ecmascript)");
protobuf.BufferReader = __turbopack_context__.r("[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/reader_buffer.js [app-client] (ecmascript)");
// Utility
protobuf.util = __turbopack_context__.r("[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/util/minimal.js [app-client] (ecmascript)");
protobuf.rpc = __turbopack_context__.r("[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/rpc.js [app-client] (ecmascript)");
protobuf.roots = __turbopack_context__.r("[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/roots.js [app-client] (ecmascript)");
protobuf.configure = configure;
/* istanbul ignore next */ /**
 * Reconfigures the library according to the environment.
 * @returns {undefined}
 */ function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
}
// Set up buffer utility according to the environment
configure();
}),
"[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/minimal.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {
"use strict";

// minimal library entry point.
module.exports = __turbopack_context__.r("[project]/node_modules/@ipld/unixfs/node_modules/protobufjs/src/index-minimal.js [app-client] (ecmascript)");
}),
"[project]/node_modules/actor/src/task.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

// This is file is only here to allow importing type namespace
// from JS.
__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$actor$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/actor/src/lib.js [app-client] (ecmascript) <locals>");
;
}),
"[project]/node_modules/actor/src/lib.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "abort",
    ()=>abort,
    "all",
    ()=>all,
    "batch",
    ()=>batch,
    "current",
    ()=>current,
    "effect",
    ()=>effect,
    "effects",
    ()=>effects,
    "exit",
    ()=>exit,
    "fork",
    ()=>fork,
    "group",
    ()=>group,
    "isInstruction",
    ()=>isInstruction,
    "isMessage",
    ()=>isMessage,
    "join",
    ()=>join,
    "listen",
    ()=>listen,
    "loop",
    ()=>loop,
    "main",
    ()=>main,
    "none",
    ()=>none,
    "resume",
    ()=>resume,
    "send",
    ()=>send,
    "sleep",
    ()=>sleep,
    "spawn",
    ()=>spawn,
    "suspend",
    ()=>suspend,
    "tag",
    ()=>tag,
    "terminate",
    ()=>terminate,
    "then",
    ()=>then,
    "wait",
    ()=>wait
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$actor$2f$src$2f$task$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/actor/src/task.js [app-client] (ecmascript) <locals>");
;
;
const effect = function*(task) {
    const message = yield* task;
    yield* send(message);
};
function* current() {
    return yield CURRENT;
}
const suspend = function*() {
    yield SUSPEND;
};
function* sleep(duration = 0) {
    const task = yield* current();
    const id = setTimeout(enqueue, duration, task);
    try {
        yield* suspend();
    } finally{
        clearTimeout(id);
    }
}
const wait = function*(input) {
    const task = yield* current();
    if (isAsync(input)) {
        let failed = false;
        /** @type {unknown} */ let output = undefined;
        input.then((value)=>{
            failed = false;
            output = value;
            enqueue(task);
        }, (error)=>{
            failed = true;
            output = error;
            enqueue(task);
        });
        yield* suspend();
        if (failed) {
            throw output;
        } else {
            return output;
        }
    } else {
        // This may seem redundunt but it is not, by enqueuing this task we allow
        // scheduler to perform other queued tasks first. This way many race
        // conditions can be avoided when values are sometimes promises and other
        // times aren't.
        // Unlike `await` however this will resume in the same tick.
        main(wake(task));
        yield* suspend();
        return input;
    }
};
/**
 * @template T, X, M
 * @param {Task.Controller<T, X, M>} task
 * @returns {Task.Task<void, never, never>}
 */ function* wake(task) {
    enqueue(task);
}
/**
 * Checks if value value is a promise (or it's lookalike).
 *
 * @template T
 * @param {any} node
 * @returns {node is PromiseLike<T>}
 */ const isAsync = (node)=>node != null && typeof /** @type {{then?:unknown}} */ node.then === "function";
const send = function*(message) {
    yield message;
};
const listen = function*(source) {
    /** @type {Task.Fork<void, never, Tagged<Tag, T>>[]} */ const forks = [];
    for (const entry of Object.entries(source)){
        const [name, effect] = entry;
        if (effect !== NONE) {
            forks.push((yield* fork(tag(effect, name))));
        }
    }
    yield* group(forks);
};
const effects = (tasks)=>tasks.length > 0 ? batch(tasks.map(effect)) : NONE;
function* batch(effects) {
    const forks = [];
    for (const effect of effects){
        forks.push((yield* fork(effect)));
    }
    yield* group(forks);
}
const tag = (effect, tag)=>// @ts-ignore
    effect === NONE ? NONE : effect instanceof Tagger ? new Tagger([
        ...effect.tags,
        tag
    ], effect.source) : new Tagger([
        tag
    ], effect);
/**
 * @template {string} Tag
 * @template Success, Failure, Message
 *
 * @implements {Task.Task<Success, Failure, Tagged<Tag, Message>>}
 * @implements {Task.Controller<Success, Failure, Tagged<Tag, Message>>}
 */ class Tagger {
    /**
   * @param {Task.Task<Success, Failure, Message>} source
   * @param {string[]} tags
   */ constructor(tags, source){
        this.tags = tags;
        this.source = source;
        /** @type {Task.Controller<Success, Failure, Message>} */ this.controller;
    }
    /* c8 ignore next 3 */ [Symbol.iterator]() {
        if (!this.controller) {
            this.controller = this.source[Symbol.iterator]();
        }
        return this;
    }
    /**
   * @param {Task.TaskState<Success, Message>} state
   * @returns {Task.TaskState<Success, Tagged<Tag, Message>>}
   */ box(state) {
        if (state.done) {
            return state;
        } else {
            switch(state.value){
                case SUSPEND:
                case CURRENT:
                    return state;
                default:
                    {
                        // Instead of boxing result at each transform step we perform in-place
                        // mutation as we know nothing else is accessing this value.
                        const tagged = state;
                        let { value } = tagged;
                        for (const tag of this.tags){
                            value = withTag(tag, value);
                        }
                        tagged.value = value;
                        return tagged;
                    }
            }
        }
    }
    /**
   *
   * @param {Task.Instruction<Message>} instruction
   */ next(instruction) {
        return this.box(this.controller.next(instruction));
    }
    /**
   *
   * @param {Failure} error
   */ throw(error) {
        return this.box(this.controller.throw(error));
    }
    /**
   * @param {Success} value
   */ return(value) {
        return this.box(this.controller.return(value));
    }
    get [Symbol.toStringTag]() {
        return "TaggedEffect";
    }
}
const none = ()=>NONE;
const all = function*(tasks) {
    const self = yield* current();
    /** @type {(id:number) => (value:T) => void} */ const succeed = (id)=>(value)=>{
            delete forks[id];
            results[id] = value;
            count -= 1;
            if (count === 0) {
                enqueue(self);
            }
        };
    /** @type {(error:X) => void} */ const fail = (error)=>{
        for (const handle of forks){
            if (handle) {
                enqueue(abort(handle, error));
            }
        }
        enqueue(abort(self, error));
    };
    /** @type {Task.Fork<void, never>[]} */ let forks = [];
    let count = 0;
    for (const task of tasks){
        forks.push((yield* fork(then(task, succeed(count++), fail))));
    }
    const results = new Array(count);
    if (count > 0) {
        yield* suspend();
    }
    return results;
};
/**
 * @template {string} Tag
 * @template T
 * @param {Tag} tag
 * @param {Task.Message<T>} value
 */ const withTag = (tag, value)=>/** @type {Tagged<Tag, T>} */ ({
        type: tag,
        [tag]: value
    });
function* then(task, resolve, reject) {
    try {
        return resolve((yield* task));
    } catch (error) {
        return reject(error);
    }
}
// Special control instructions recognized by a scheduler.
const CURRENT = Symbol("current");
const SUSPEND = Symbol("suspend");
const isMessage = (value)=>{
    switch(value){
        case SUSPEND:
        case CURRENT:
            return false;
        default:
            return true;
    }
};
const isInstruction = (value)=>!isMessage(value);
/**
 * @template T, X, M
 * @implements {Task.TaskGroup<T, X, M>}
 */ class Group {
    /**
   * @template T, X, M
   * @param {Task.Controller<T, X, M>|Task.Fork<T, X, M>} member
   * @returns {Task.Group<T, X, M>}
   */ static of(member) {
        return /** @type {{group?:Task.TaskGroup<T, X, M>}} */ member.group || MAIN;
    }
    /**
   * @template T, X, M
   * @param {(Task.Controller<T, X, M>|Task.Fork<T, X, M>) & {group?:Task.TaskGroup<T, X, M>}} member
   * @param {Task.TaskGroup<T, X, M>} group
   */ static enqueue(member, group) {
        member.group = group;
        group.stack.active.push(member);
    }
    /**
   * @param {Task.Controller<T, X, M>} driver
   * @param {Task.Controller<T, X, M>[]} [active]
   * @param {Set<Task.Controller<T, X, M>>} [idle]
   * @param {Task.Stack<T, X, M>} [stack]
   */ constructor(driver, active = [], idle = new Set(), stack = new Stack(active, idle)){
        this.driver = driver;
        this.parent = Group.of(driver);
        this.stack = stack;
        this.id = ++ID;
    }
}
/**
 * @template T, X, M
 * @implements {Task.Main<T, X, M>}
 */ class Main {
    constructor(){
        this.status = IDLE;
        this.stack = new Stack();
        this.id = 0;
    }
}
/**
 * @template T, X, M
 */ class Stack {
    /**
   * @param {Task.Controller<T, X, M>[]} [active]
   * @param {Set<Task.Controller<T, X, M>>} [idle]
   */ constructor(active = [], idle = new Set()){
        this.active = active;
        this.idle = idle;
    }
    /**
   *
   * @param {Task.Stack<unknown, unknown, unknown>} stack
   * @returns
   */ static size({ active, idle }) {
        return active.length + idle.size;
    }
}
const main = (task)=>enqueue(task[Symbol.iterator]());
/**
 * @template T, X, M
 * @param {Task.Controller<T, X, M>} task
 */ const enqueue = (task)=>{
    let group = Group.of(task);
    group.stack.active.push(task);
    group.stack.idle.delete(task);
    // then walk up the group chain and unblock their driver tasks.
    while(group.parent){
        const { idle, active } = group.parent.stack;
        if (idle.has(group.driver)) {
            idle.delete(group.driver);
            active.push(group.driver);
        } else {
            break;
        }
        group = group.parent;
    }
    if (MAIN.status === IDLE) {
        MAIN.status = ACTIVE;
        while(true){
            try {
                for (const _message of step(MAIN)){}
                MAIN.status = IDLE;
                break;
            } catch (_error) {
                // Top level task may crash and throw an error, but given this is a main
                // group we do not want to interupt other unrelated tasks, which is why
                // we discard the error and the task that caused it.
                MAIN.stack.active.shift();
            }
        }
    }
};
const resume = (task)=>enqueue(task);
/**
 * @template T, X, M
 * @param {Task.Group<T, X, M>} group
 */ const step = function*(group) {
    const { active } = group.stack;
    let task = active[0];
    group.stack.idle.delete(task);
    while(task){
        /** @type {Task.TaskState<T, M>} */ let state = INIT;
        // Keep processing insturctions until task is done, it send suspend request
        // or it's has been removed from the active queue.
        //  Group changes require extra care so please make sure to understand
        // the detail here. It occurs when spawned task(s) are joined into a group
        // which will change the task driver, that is when `task === active[0]` will
        // became false and need to to drop the task immediately otherwise race
        // condition will occur due to task been  driven by multiple concurrent
        // schedulers.
        loop: while(!state.done && task === active[0]){
            const instruction = state.value;
            switch(instruction){
                // if task is suspended we add it to the idle list and break the loop
                // to move to a next task.
                case SUSPEND:
                    group.stack.idle.add(task);
                    break loop;
                // if task requested a context (which is usually to suspend itself)
                // pass back a task reference and continue.
                case CURRENT:
                    state = task.next(task);
                    break;
                default:
                    // otherwise task sent a message which we yield to the driver and
                    // continue
                    state = task.next((yield instruction));
                    break;
            }
        }
        // If task is complete, or got suspended we move to a next task
        active.shift();
        task = active[0];
        group.stack.idle.delete(task);
    }
};
function* spawn(task) {
    main(task);
}
const fork = (task, options)=>new Fork(task, options);
const exit = (handle, value)=>conclude(handle, {
        ok: true,
        value
    });
const terminate = (handle)=>conclude(handle, {
        ok: true,
        value: undefined
    });
const abort = (handle, error)=>conclude(handle, {
        ok: false,
        error
    });
/**
 * Aborts given task with an given error.
 *
 * @template T, M, X
 * @param {Task.Controller<T, X, M>} handle
 * @param {Task.Result<T, X>} result
 * @returns {Task.Task<void, never> & Task.Controller<void, never>}
 */ function* conclude(handle, result) {
    try {
        const task = handle;
        const state = result.ok ? task.return(result.value) : task.throw(result.error);
        if (!state.done) {
            if (state.value === SUSPEND) {
                const { idle } = Group.of(task).stack;
                idle.add(task);
            } else {
                enqueue(task);
            }
        }
    } catch (error) {}
}
function* group(forks) {
    // Abort eraly if there'se no work todo.
    if (forks.length === 0) return;
    const self = yield* current();
    /** @type {Task.TaskGroup<T, X, M>} */ const group = new Group(self);
    /** @type {Task.Failure<X>|null} */ let failure = null;
    for (const fork of forks){
        const { result } = fork;
        if (result) {
            if (!result.ok && !failure) {
                failure = result;
            }
            continue;
        }
        move(fork, group);
    }
    // Keep work looping until there is nom more work to be done
    try {
        if (failure) {
            throw failure.error;
        }
        while(true){
            yield* step(group);
            if (Stack.size(group.stack) > 0) {
                yield* suspend();
            } else {
                break;
            }
        }
    } catch (error) {
        for (const task of group.stack.active){
            yield* abort(task, error);
        }
        for (const task of group.stack.idle){
            yield* abort(task, error);
            enqueue(task);
        }
        throw error;
    }
}
/**
 * @template T, X, M
 * @param {Task.Fork<T, X, M>} fork
 * @param {Task.TaskGroup<T, X, M>} group
 */ const move = (fork, group)=>{
    const from = Group.of(fork);
    if (from !== group) {
        const { active, idle } = from.stack;
        const target = group.stack;
        fork.group = group;
        // If it is idle just move from one group to the other
        // and update the group task thinks it belongs to.
        if (idle.has(fork)) {
            idle.delete(fork);
            target.idle.add(fork);
        } else {
            const index = active.indexOf(fork);
            // If task is in the job queue, we move it to a target job queue. Moving
            // top task in the queue requires extra care so it does not end up
            // processed by two groups which would lead to race. For that reason
            // `step` loop checks for group changes on each turn.
            if (index >= 0) {
                active.splice(index, 1);
                target.active.push(fork);
            }
        // otherwise task is complete
        }
    }
};
function* join(fork) {
    // If fork is still idle activate it.
    if (fork.status === IDLE) {
        yield* fork;
    }
    if (!fork.result) {
        yield* group([
            fork
        ]);
    }
    const result = fork.result;
    if (result.ok) {
        return result.value;
    } else {
        throw result.error;
    }
}
/**
 * @template T, X
 * @implements {Task.Future<T, X>}
 */ class Future {
    /**
   * @param {Task.StateHandler<T, X>} handler
   */ constructor(handler){
        this.handler = handler;
        /**
     * @abstract
     * @type {Task.Result<T, X>|void}
     */ this.result;
    }
    /**
   * @type {Promise<T>}
   */ get promise() {
        const { result } = this;
        const promise = result == null ? new Promise((succeed, fail)=>{
            this.handler.onsuccess = succeed;
            this.handler.onfailure = fail;
        }) : result.ok ? Promise.resolve(result.value) : Promise.reject(result.error);
        Object.defineProperty(this, "promise", {
            value: promise
        });
        return promise;
    }
    /**
   * @template U, [E=never]
   * @param {((value:T) => U | PromiseLike<U>)|undefined|null} [onresolve]
   * @param {((error:X) => E|PromiseLike<E>)|undefined|null} [onreject]
   * @returns {Promise<U|E>}
   */ then(onresolve, onreject) {
        return this.activate().promise.then(onresolve, onreject);
    }
    /**
   * @template [U=never]
   * @param {(error:X) => U} onreject
   */ catch(onreject) {
        return this.activate().promise.catch(onreject);
    }
    /**
   * @param {() => void} onfinally
   * @returns {Task.Future<T, X>}
   */ finally(onfinally) {
        return this.activate().promise.finally(onfinally);
    }
    /**
   * @abstract
   */ /* c8 ignore next 3 */ activate() {
        return this;
    }
}
/**
 * @template T, X, M
 * @implements {Task.Fork<T, X, M>}
 * @implements {Task.Controller<T, X, M>}
 * @implements {Task.Task<Task.Fork<T, X, M>, never>}
 * @implements {Task.Future<T, X>}
 * @extends {Future<T, X>}
 */ class Fork extends Future {
    /**
   * @param {Task.Task<T, X, M>} task
   * @param {Task.ForkOptions} [options]
   * @param {Task.StateHandler<T, X>} [handler]
   * @param {Task.TaskState<T, M>} [state]
   */ constructor(task, options = BLANK, handler = {}, state = INIT){
        super(handler);
        this.id = ++ID;
        this.name = options.name || "";
        /** @type {Task.Task<T, X, M>} */ this.task = task;
        this.state = state;
        this.status = IDLE;
        /** @type {Task.Result<T, X>} */ this.result;
        this.handler = handler;
        /** @type {Task.Controller<T, X, M>} */ this.controller;
    }
    *resume() {
        resume(this);
    }
    /**
   * @returns {Task.Task<T, X, M>}
   */ join() {
        return join(this);
    }
    /**
   * @param {X} error
   */ abort(error) {
        return abort(this, error);
    }
    /**
   * @param {T} value
   */ exit(value) {
        return exit(this, value);
    }
    get [Symbol.toStringTag]() {
        return "Fork";
    }
    /**
   * @returns {Task.Controller<Task.Fork<T, X, M>, never, never>}
   */ *[Symbol.iterator]() {
        return this.activate();
    }
    activate() {
        this.controller = this.task[Symbol.iterator]();
        this.status = ACTIVE;
        enqueue(this);
        return this;
    }
    /**
   * @private
   * @param {any} error
   * @returns {never}
   */ panic(error) {
        this.result = {
            ok: false,
            error
        };
        this.status = FINISHED;
        const { handler } = this;
        if (handler.onfailure) {
            handler.onfailure(error);
        }
        throw error;
    }
    /**
   * @private
   * @param {Task.TaskState<T, M>} state
   */ step(state) {
        this.state = state;
        if (state.done) {
            this.result = {
                ok: true,
                value: state.value
            };
            this.status = FINISHED;
            const { handler } = this;
            if (handler.onsuccess) {
                handler.onsuccess(state.value);
            }
        }
        return state;
    }
    /**
   * @param {unknown} value
   */ next(value) {
        try {
            return this.step(this.controller.next(value));
        } catch (error) {
            return this.panic(error);
        }
    }
    /**
   * @param {T} value
   */ return(value) {
        try {
            return this.step(this.controller.return(value));
        } catch (error) {
            return this.panic(error);
        }
    }
    /**
   * @param {X} error
   */ throw(error) {
        try {
            return this.step(this.controller.throw(error));
        } catch (error) {
            return this.panic(error);
        }
    }
}
const loop = function*(init, next) {
    /** @type {Task.Controller<void, never, M>} */ const controller = yield* current();
    const group = new Group(controller);
    Group.enqueue(init[Symbol.iterator](), group);
    while(true){
        for (const message of step(group)){
            Group.enqueue(next(message)[Symbol.iterator](), group);
        }
        if (Stack.size(group.stack) > 0) {
            yield* suspend();
        } else {
            break;
        }
    }
};
let ID = 0;
/** @type {Task.Status} */ const IDLE = "idle";
const ACTIVE = "active";
const FINISHED = "finished";
/** @type {Task.TaskState<any, any>} */ const INIT = {
    done: false,
    value: CURRENT
};
const BLANK = {};
/** @type {Task.Effect<never>} */ const NONE = function* none() {}();
/** @type {Task.Main<any, any, any>} */ const MAIN = new Main();
}),
"[project]/node_modules/@perma/map/src/api.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
;
}),
"[project]/node_modules/@perma/map/src/bitfield/api.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
;
}),
"[project]/node_modules/@perma/map/src/bitfield/Uint32.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "and",
    ()=>and,
    "bitCount",
    ()=>bitCount,
    "empty",
    ()=>empty,
    "from",
    ()=>from,
    "fromBytes",
    ()=>fromBytes,
    "get",
    ()=>get,
    "or",
    ()=>or,
    "popcount",
    ()=>popcount,
    "set",
    ()=>set,
    "size",
    ()=>size,
    "toBytes",
    ()=>toBytes,
    "unset",
    ()=>unset
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/bitfield/api.js [app-client] (ecmascript)");
;
;
const empty = (size = 32)=>{
    // We could support < 32, but it seems impractical and would negatively affect
    // performance as we would have to do extra bound checks.
    if (size !== 32) {
        throw new Error(`Uint32 BitField does not support size: ${size}`);
    }
    return 0;
};
const from = (bits, size)=>{
    let bitfield = empty(size);
    for (const bit of bits){
        bitfield = set(bitfield, bit);
    }
    return bitfield;
};
const size = (_bitField)=>32;
/**
 * Reads out 5 bits at the given bit offset.
 *
 * @param {API.Uint32} bitField - Bitfield in Uint32 representation.
 * @param {API.Uint32} index - Index with-in `bitField` to read bits from.
 * @returns {API.Uint32}
 */ const mask = (bitField, index)=>bitField >>> index & 0b11111;
/**
 * Creates mask that can be used to check a bit in nodes bitmap for the give
 * key (hash) at given depth.
 *
 * @param {API.Uint32} bitField - Key hash as 32 bit integer.
 * @param {API.Uint32} index - Index with-in the 32bit bitfield
 */ const offset = (bitField, index)=>1 << mask(bitField, index);
const popcount = (bitField, index = 31)=>bitCount(bitField & offset(index, 0) - 1);
const set = (bitField, index)=>bitField | 1 << index;
const unset = (bitField, index)=>bitField & (0xff ^ 1 << index);
const get = (bitField, index)=>(bitField >> index & 0x1) !== 0;
const bitCount = (bitField)=>{
    const n1 = bitField - (bitField >> 1 & 0x55555555);
    const n2 = (n1 & 0x33333333) + (n1 >> 2 & 0x33333333);
    const n3 = (n2 + (n2 >> 4) & 0xf0f0f0f) * 0x1010101;
    return n3 >> 24;
};
const and = (left, right)=>left & right;
const or = (left, right)=>left | right;
const toBytes = (bitField)=>Uint8Array.of(bitField >> 24 & 0b1111_1111, bitField >> 16 & 0b1111_1111, bitField >> 8 & 0b1111_1111, bitField & 0b1111_1111);
const fromBytes = (bytes)=>{
    if (bytes.length !== 4) {
        throw new Error(`Expected 4 bytes instead got ${bytes.length}`);
    }
    return (bytes[0] << 24) + (bytes[1] << 16) + (bytes[2] << 8) + bytes[3];
};
}),
"[project]/node_modules/@perma/map/src/bitfield/Uint32.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "API",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    "and",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["and"],
    "bitCount",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bitCount"],
    "empty",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["empty"],
    "from",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["from"],
    "fromBytes",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromBytes"],
    "get",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["get"],
    "or",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["or"],
    "popcount",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["popcount"],
    "set",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["set"],
    "size",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["size"],
    "toBytes",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["toBytes"],
    "unset",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["unset"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/bitfield/Uint32.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/bitfield/api.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@perma/map/src/path/api.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
;
}),
"[project]/node_modules/@perma/map/src/path/Uint32.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "configure",
    ()=>configure,
    "hash32",
    ()=>hash32
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$path$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/path/api.js [app-client] (ecmascript)");
// @ts-expect-error - has no types
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$murmurhash3js$2d$revisited$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/murmurhash3js-revisited/index.js [app-client] (ecmascript)");
;
;
const utf8 = new TextEncoder();
const hash32 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$murmurhash3js$2d$revisited$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].x64.hash126;
const configure = ({ bitWidth = 5, hash = hash32 })=>{
    const hashSize = 4;
    if (bitWidth > hashSize * 8) {
        throw new RangeError(`Can not use bitWidth ${bitWidth} which exceeds the hashSize ${hashSize}`);
    }
    if (hashSize * 8 > 32) {
        throw new RangeError(`Can not use hashSize ${hashSize} as it can not be encoded in Uint32`);
    }
    // Mask for reading `bitWidth` number of bits from the end.
    const mask = 0xffffffff >>> 32 - bitWidth;
    /**
   * Determines bit position for the path entry at the given `depth`.
   * ```js
   * const key = hash("result") // 0b00011010010110010101111100110010
   * // Which is following path (in reverse as we read from the right)
   * // 10010/11001/10111/10010/00101/01101/00000 -> [ 18, 25, 23, 18, 5, 13, 0 ]
   * at(key, 0) // 0b10010 -> 18
   * at(key, 1) // 0b11001 -> 25
   * at(key, 2) // 0b10111 -> 23
   * at(key, 3) // 0b10010 -> 18
   * at(key, 4) // 0b00101 -> 5
   * at(key, 5) // 0b01101 -> 13
   * at(key, 6) // 0b00000 -> 0
   * ```
   *
   * @param {API.Uint32} path
   * @param {number} depth
   */ const at = (path, depth)=>path >>> depth * bitWidth & mask;
    /**
   * @param {string} key
   * @returns {API.Uint32}
   */ const from = (key)=>hash(utf8.encode(key));
    return {
        at,
        from,
        size: Math.ceil(hashSize * 8 / bitWidth)
    };
};
}),
"[project]/node_modules/@perma/map/src/node.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "associate",
    ()=>associate,
    "associateCollision",
    ()=>associateCollision,
    "copyAndSetChild",
    ()=>copyAndSetChild,
    "create",
    ()=>create,
    "delete",
    ()=>remove,
    "dissociate",
    ()=>dissociate,
    "dissociateCollision",
    ()=>dissociateCollision,
    "entries",
    ()=>entries,
    "fork",
    ()=>fork,
    "forkAndSet",
    ()=>forkAndSet,
    "forkCollision",
    ()=>forkCollision,
    "get",
    ()=>get,
    "inlineChild",
    ()=>inlineChild,
    "keyAt",
    ()=>keyAt,
    "keyPosition",
    ()=>keyPosition,
    "keys",
    ()=>keys,
    "lookup",
    ()=>lookup,
    "lookupCollision",
    ()=>lookupCollision,
    "mergeTwoLeaves",
    ()=>mergeTwoLeaves,
    "migrateLeafToBranch",
    ()=>migrateLeafToBranch,
    "resolveNode",
    ()=>resolveNode,
    "set",
    ()=>set,
    "valueAt",
    ()=>valueAt,
    "valuePosition",
    ()=>valuePosition,
    "values",
    ()=>values
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/api.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/bitfield/Uint32.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/bitfield/Uint32.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$path$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/path/Uint32.js [app-client] (ecmascript)");
;
;
;
;
;
/**
 * @template T
 * @template {string} K
 * @template {API.Config} C
 * @implements {API.BitmapIndexedNode<T, K, C>}
 */ class BitmapIndexedNode {
    /**
   * @param {API.Edit|null} edit
   * @param {ReturnType<C['BitField']['empty']>} datamap
   * @param {ReturnType<C['BitField']['empty']>} nodemap
   * @param {API.Children<T, K, C>} children
   * @param {C} config
   */ constructor(edit, datamap, nodemap, children, config){
        this.edit = edit;
        this.config = config;
        this.datamap = datamap;
        this.nodemap = nodemap;
        this.children = children;
    }
    get nodeArity() {
        return this.config.BitField.popcount(this.nodemap);
    }
    get dataArity() {
        return this.config.BitField.popcount(this.datamap);
    }
    /**
   * @returns {API.BitmapIndexedNode<T, K, C>}
   */ /* c8 ignore next 3 */ empty() {
        return create(this.config);
    }
    /**
   * @template X
   * @param {API.Uint32} depth
   * @param {ReturnType<C['Path']['from']>} path
   * @param {K} key
   * @param {X} notFound
   * @returns {T|X}
   */ lookup(depth, path, key, notFound) {
        return lookup(this, depth, path, key, notFound);
    }
    /**
   * @template {string} R
   * @param {API.Edit|null} edit
   * @param {API.Uint32} depth
   * @param {ReturnType<C['Path']['from']>} path
   * @param {K|R} key
   * @param {T} value
   * @param {{value:boolean}} addedLeaf
   * @returns {API.BitmapIndexedNode<T, K | R, C>}
   */ associate(edit, depth, path, key, value, addedLeaf) {
        return associate(this, edit, depth, path, key, value, addedLeaf);
    }
    /**
   * @param {API.Edit|null} edit
   * @param {API.Uint32} depth
   * @param {ReturnType<C['Path']['from']>} path
   * @param {K} key
   * @param {{value:boolean}} removedLeaf
   * @returns {API.BitmapIndexedNode<T, K, C>}
   */ dissociate(edit, depth, path, key, removedLeaf) {
        return dissociate(this, edit, depth, path, key, removedLeaf);
    }
    /**
   * @param {API.Edit|null} edit
   * @returns {API.BitmapIndexedNode<T, K, C>}
   */ fork(edit = null) {
        return fork(this, edit);
    }
    /**
   * @returns {IterableIterator<[K, T]>}
   */ entries() {
        return entries(this);
    }
    /**
   * @returns {IterableIterator<K>}
   */ keys() {
        return keys(this);
    }
    /**
   * @returns {IterableIterator<T>}
   */ values() {
        return values(this);
    }
}
/**
 * @template T
 * @template {string} K
 * @template {API.Config} C
 * @implements {API.HashCollisionNode<T, K, C>}
 */ class HashCollisionNode {
    /**
   * @param {API.Edit|null} edit
   * @param {number} count
   * @param {API.CollisionEntries<T, K>} children
   * @param {C} config
   */ /* c8 ignore next 12 */ constructor(edit, count, children, config){
        this.edit = edit;
        this.count = count;
        this.children = children;
        this.config = config;
    }
    get nodeArity() {
        return 0;
    }
    get dataArity() {
        return this.count;
    }
    /**
   * @template X
   * @param {API.Uint32} _shift
   * @param {unknown} _path
   * @param {K} key
   * @param {X} notFound
   * @returns {T|X}
   */ /* c8 ignore next 3 */ lookup(_shift, _path, key, notFound) {
        return lookupCollision(this, key, notFound);
    }
    /**
   * @template {string} R
   * @param {API.Edit|null} edit
   * @param {API.Uint32} _shift
   * @param {ReturnType<C['Path']['from']>} path
   * @param {K|R} key
   * @param {T} value
   * @param {{value:boolean}} addedLeaf
   * @returns {API.HashCollisionNode<T, K | R, C>}
   */ /* c8 ignore next 3 */ associate(edit, _shift, path, key, value, addedLeaf) {
        return associateCollision(this, edit, path, key, value, addedLeaf);
    }
    /**
   * @param {API.Edit|null} edit
   * @param {API.Uint32} _shift
   * @param {ReturnType<C['Path']['from']>} path
   * @param {K} key
   * @param {{value:boolean}} removedLeaf
   * @returns {API.Node<T, K, C>}
   */ /* c8 ignore next 3 */ dissociate(edit, _shift, path, key, removedLeaf) {
        return dissociateCollision(this, edit, path, key, removedLeaf);
    }
    /**
   * @param {API.Edit|null} edit
   * @returns {this}
   */ /* c8 ignore next 3 */ fork(edit = null) {
        return forkCollision(this, edit);
    }
    /**
   * @returns {IterableIterator<[K, T]>}
   */ /* c8 ignore next 3 */ entries() {
        return entries(this);
    }
    /**
   * @returns {IterableIterator<K>}
   */ /* c8 ignore next 3 */ keys() {
        return keys(this);
    }
    /**
   * @returns {IterableIterator<T>}
   */ /* c8 ignore next 3 */ values() {
        return values(this);
    }
}
const lookupCollision = (node, name, notFound)=>{
    const { children: entries, count } = node;
    // find where entry with this name belongs
    const n = findHashCollisionNodeIndex(entries, count, name);
    // if entry name at this index matches given name return the value otherwise
    // return `notFound` as we have no such entry.
    return entries[n] === name ? entries[n + 1] : notFound;
};
const associateCollision = (node, edit, key, name, value, addedLeaf)=>{
    const { children, count } = node;
    const index = findHashCollisionNodeIndex(children, count, name);
    // If entry at this index has a different name we fork the node and
    // add a new entry.
    if (children[index] !== name) {
        const newNode = node.fork(edit);
        addedLeaf.value = true;
        newNode.count += 1;
        newNode.children.splice(index, key, value);
        return newNode;
    } else if (children[index + 1] !== value) {
        const newNode = node.fork(edit);
        newNode.children[index + 1] = value;
        return newNode;
    } else {
        return node;
    }
};
const dissociateCollision = (node, edit, hash, name, removedLeaf)=>{
    const { children: entries, count, config } = node;
    const index = findHashCollisionNodeIndex(entries, count, name);
    // If there is no entry with a the given name this is noop so we just
    // return back this node.
    if (entries[index] !== name) {
        return node;
    } else {
        removedLeaf.value = true;
        // If conflict contained only two entries removing one of them would
        // leave us with no conflict which is why we create a new node with a
        // an entry other than one that would correspond provided name
        if (count === 2) {
            const offset = index === 0 ? 2 : 0;
            return associate(create(config), edit, 0, hash, entries[offset], entries[offset + 1], removedLeaf);
        } else {
            const newNode = node.fork(edit);
            newNode.children.splice(index, 2);
            newNode.count -= 1;
            return newNode;
        }
    }
};
const forkCollision = (node, edit = null)=>{
    if (canEdit(node.edit, edit)) {
        return node;
    } else {
        return new HashCollisionNode(edit, node.count, node.children.slice(), node.config);
    }
};
/**
 * Finds the index inside collision entries where given `key` belongs, which is
 * index where `key <= entries[index]` is `true`. If no index satisfies this
 * constraint index will be `entries.length` indicating that key belongs in the
 * last position.
 *
 * @template T
 * @template {string} K
 * @param {API.CollisionEntries<T, K>} entries
 * @param {number} count
 * @param {K} key
 */ /* c8 ignore next 8 */ const findHashCollisionNodeIndex = (entries, count, key)=>{
    let index = 0;
    // increase index until we find a index where key <= entries[index]
    while(index < count && entries[index] > key){
        index += 2;
    }
    return index;
};
const defaultConfig = {
    bitWidth: 32,
    BitField: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    Path: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$path$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__
};
const create = (config, edit = null)=>new BitmapIndexedNode(edit, config.BitField.empty(Math.pow(2, config.bitWidth)), config.BitField.empty(Math.pow(2, config.bitWidth)), [], config);
const get = (node, key, notFound)=>lookup(node, 0, node.config.Path.from(key), key, notFound);
const lookup = (node, depth, path, key, notFound)=>{
    const { datamap, nodemap, config } = node;
    const { Path, BitField } = config;
    const offset = Path.at(path, depth);
    // If bit is set in the data bitmap we have some key, value under the
    // matching hash segment.
    if (BitField.get(datamap, offset)) {
        const index = BitField.popcount(datamap, offset);
        // If key matches actual key in the map we found the the value
        // otherwise we did not.
        if (keyAt(node, index) === key) {
            return valueAt(node, index);
        } else {
            return notFound;
        }
    } else if (BitField.get(nodemap, offset)) {
        // Resolve node and continue lookup within it.
        const child = resolveNode(node, offset);
        return child.lookup(depth + 1, path, key, notFound);
    } else {
        return notFound;
    }
};
const set = (node, edit, key, value, addedLeaf)=>associate(node, edit, 0, node.config.Path.from(key), key, value, addedLeaf);
const associate = (node, edit, depth, path, key, value, addedLeaf)=>{
    const { datamap, nodemap, config } = node;
    const { Path, BitField } = config;
    const offset = Path.at(path, depth);
    // If bit is set in the data bitmap we have some key, value under the
    // matching hash segment.
    if (BitField.get(datamap, offset)) {
        const index = BitField.popcount(datamap, offset);
        const found = keyAt(node, index);
        // If we have entry with given name and value is the same return node
        // as is, otherwise fork node and set the value.
        if (key === found) {
            return valueAt(node, index) === value ? node : forkAndSet(node, edit, index, value);
        } else {
            const branch = mergeTwoLeaves(config, edit, depth + 1, Path.from(found), found, valueAt(node, index), path, key, value);
            addedLeaf.value = true;
            return migrateLeafToBranch(node, edit, offset, branch);
        }
    } else if (BitField.get(nodemap, offset)) {
        const child = resolveNode(node, offset);
        const newChild = child.associate(edit, depth + 1, path, key, value, addedLeaf);
        if (child === newChild) {
            return node;
        } else {
            return copyAndSetChild(node, edit, offset, newChild);
        }
    } else {
        const index = BitField.popcount(datamap, offset);
        addedLeaf.value = true;
        /** @type {API.BitmapIndexedNode<T, K|R, C>} */ const newNode = node.fork(edit);
        // Capture new entry in the data bitmap
        newNode.datamap = BitField.set(datamap, offset);
        newNode.children.splice(keyPosition(index), 0, key, value);
        return newNode;
    }
};
/**
 * @template T
 * @template {string} K
 * @template {API.Config} C
 * @param {API.BitmapIndexedNode<T, K, C>} node
 * @param {API.Edit|null} edit
 * @param {K} key
 * @param {{ value: boolean }} removedLeaf
 * @returns {API.BitmapIndexedNode<T, K, C>}
 */ const remove = (node, edit, key, removedLeaf)=>dissociate(node, edit, 0, node.config.Path.from(key), key, removedLeaf);
;
const dissociate = (source, edit, depth, path, key, removedLeaf)=>{
    const { datamap, nodemap, config } = source;
    const { BitField, Path } = config;
    const offset = Path.at(path, depth);
    // If bit is set in the data bitmap we have an entry under the
    // matching hash segment.
    if (BitField.get(datamap, offset)) {
        const index = BitField.popcount(datamap, offset);
        // If key at a given index matches given `name` we fork a node and remove
        // the entry
        if (key === keyAt(source, index)) {
            removedLeaf.value = true;
            const node = fork(source, edit);
            // Update the bitmap
            node.datamap = BitField.unset(source.datamap, offset);
            // remove the child
            node.children.splice(keyPosition(index), 2);
            return node;
        } else {
            return source;
        }
    } else if (BitField.get(nodemap, offset)) {
        const node = resolveNode(source, offset);
        const child = node.dissociate(edit, depth + 1, path, key, removedLeaf);
        // if child has a single element we need to canonicalize
        if (hasSingleLeaf(child)) {
            // if source has a single child, we collapse and return the child
            // otherwise we inline the child.
            return hasSingleNode(source) ? child : inlineChild(source, edit, offset, child);
        } else if (node === child) {
            return source;
        } else {
            return copyAndSetChild(source, edit, offset, child);
        }
    } else {
        return source;
    }
};
const entries = function*({ children }) {
    let offset = 0;
    const count = children.length;
    while(offset < count){
        const key = children[offset];
        if (typeof key === "string") {
            offset += 1;
            const value = children[offset];
            yield [
                key,
                value
            ];
            offset += 1;
        } else {
            break;
        }
    }
    while(offset < count){
        const node = children[offset];
        yield* node.entries();
        offset += 1;
    }
};
const fork = (node, edit)=>{
    if (canEdit(node.edit, edit)) {
        return node;
    } else {
        const newNode = new BitmapIndexedNode(edit, node.datamap, node.nodemap, node.children.slice(), node.config);
        return newNode;
    }
};
const keys = function*({ children }) {
    let offset = 0;
    const count = children.length;
    while(offset < count){
        const key = children[offset];
        if (typeof key === "string") {
            yield key;
            offset += 2;
        } else {
            break;
        }
    }
    while(offset < count){
        const node = children[offset];
        yield* node.keys();
        offset += 1;
    }
};
const values = function*({ children }) {
    let offset = 0;
    const count = children.length;
    while(offset < count){
        const key = children[offset];
        if (typeof key === "string") {
            offset += 1;
            yield children[offset];
            offset += 1;
        } else {
            break;
        }
    }
    while(offset < count){
        const node = children[offset];
        yield* node.values();
        offset += 1;
    }
};
const forkAndSet = (node, edit, offset, value)=>{
    const newNode = node.fork(edit);
    newNode.children[valuePosition(offset)] = value;
    return newNode;
};
const inlineChild = (source, edit, offset, child)=>{
    const { datamap, nodemap, config } = source;
    const { BitField } = config;
    const node = fork(source, edit);
    // remove the node that we are inlining
    node.children.splice(nodePosition(source, offset), 1);
    // add key-value pair where it wolud fall
    node.children.splice(keyPosition(BitField.popcount(datamap, offset)), 0, child.children[0], child.children[1]);
    node.datamap = BitField.set(datamap, offset);
    node.nodemap = BitField.unset(nodemap, offset);
    return node;
};
const copyAndSetChild = (node, edit, offset, child)=>{
    const newNode = fork(node, edit);
    newNode.children[nodePosition(node, offset)] = child;
    return newNode;
};
const migrateLeafToBranch = (source, edit, offset, branch)=>{
    const { nodemap, datamap, config } = source;
    const { BitField } = config;
    const index = BitField.popcount(datamap, offset);
    // Previous id corresponds to the key position
    const oldId = keyPosition(index);
    const newId = nodePosition(source, offset);
    const node = fork(source, edit);
    // remove an old leaf
    node.datamap = BitField.unset(datamap, offset);
    node.children.splice(oldId, 2);
    // add a new branch
    node.nodemap = BitField.set(nodemap, offset);
    node.children.splice(newId - 1, 0, branch);
    return node;
};
const mergeTwoLeaves = (config, edit, depth, oldPath, oldKey, oldValue, newPath, newKey, newValue)=>{
    const { BitField, Path } = config;
    // If we have reached end of the path we can no longer create another
    // `BitmapIndexedNode`, instead we create a node containing (hash) colliding
    // entries
    /* c8 ignore next 7 */ if (Path.size < depth) {
        return new HashCollisionNode(edit, 2, [
            oldKey,
            oldValue,
            newKey,
            newValue
        ], config);
    } else {
        const oldOffset = Path.at(oldPath, depth);
        const newOffset = Path.at(newPath, depth);
        // If offsets still match create another intermediery node and merge these
        // two nodes at next depth level.
        if (oldOffset === newOffset) {
            return new BitmapIndexedNode(edit, BitField.empty(Math.pow(2, config.bitWidth)), BitField.from([
                oldOffset
            ], Math.pow(2, config.bitWidth)), [
                mergeTwoLeaves(config, edit, depth + 1, oldPath, oldKey, oldValue, newPath, newKey, newValue)
            ], config);
        } else {
            return new BitmapIndexedNode(edit, BitField.from([
                oldOffset,
                newOffset
            ], Math.pow(2, config.bitWidth)), BitField.empty(Math.pow(2, config.bitWidth)), // We insert child with a lower index first so that we can derive it's
            // index on access via popcount
            oldOffset < newOffset ? [
                oldKey,
                oldValue,
                newKey,
                newValue
            ] : [
                newKey,
                newValue,
                oldKey,
                oldValue
            ], config);
        }
    }
};
const keyAt = ({ children }, index)=>children[keyPosition(index)];
const keyPosition = (index)=>index * 2;
const valueAt = ({ children }, index)=>children[valuePosition(index)];
const valuePosition = (index)=>index * 2 + 1;
const resolveNode = (node, offset)=>node.children[nodePosition(node, offset)];
/**
 * @template T
 * @template {string} K
 * @template {API.Config} C
 * @param {API.BitmapIndexedNode<T, K, C>} node
 * @param {number} offset
 */ const nodePosition = ({ children, nodemap, config }, offset)=>children.length - 1 - config.BitField.popcount(nodemap, offset);
/**
 * @param {API.Edit|null} owner
 * @param {API.Edit|null} editor
 */ const canEdit = (owner, editor)=>owner != null && owner === editor;
/**
 * Returns `true` if node has a single entry. It also refines type to
 * `BitmapIndexedNode` because `HashCollisionNode` is normalized to
 * `BitmapIndexedNode` when it contains only a single entry.
 *
 * @template T
 * @template {string} K
 * @template {API.Config} C
 * @param {API.Node<T, K, C>} node
 * @returns {node is API.BitmapIndexedNode<T, K, C>}
 */ const hasSingleLeaf = (node)=>node.nodeArity === 0 && node.dataArity === 1;
/**
 * Returns `true` if node has a single childe node and 0 child leaves.
 *
 * @template T
 * @template {string} K
 * @template {API.Config} C
 * @param {API.BitmapIndexedNode<T, K, C>} node
 * @returns {node is API.BitmapIndexedNode<T, K, C>}
 */ const hasSingleNode = ({ config: { BitField }, datamap, nodemap })=>BitField.popcount(datamap) === 0 && BitField.popcount(nodemap) === 1;
}),
"[project]/node_modules/@perma/map/src/path/Uint8Array.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "configure",
    ()=>configure,
    "hash64",
    ()=>hash64,
    "toInt",
    ()=>toInt
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$path$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/path/api.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$murmur3$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/murmur3/src/index.js [app-client] (ecmascript)");
;
const utf8 = new TextEncoder();
;
const hash64 = (bytes)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$murmur3$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["murmur364"].encode(bytes);
const configure = ({ bitWidth = 8, hash = hash64 } = {})=>{
    const hashSize = hash(new Uint8Array()).byteLength;
    /**
   * @param {Uint8Array} path
   * @param {number} depth
   * @returns {API.Uint32}
   */ const at = (path, depth)=>{
        const offset = depth * bitWidth;
        if (offset > hashSize) {
            throw new RangeError(`Out of bounds`);
        }
        return toInt(path, offset, bitWidth);
    };
    /**
   * @param {string} key
   * @returns {Uint8Array}
   */ const from = (key)=>hash(utf8.encode(key));
    return {
        from,
        at,
        size: Math.ceil(hashSize * 8 / bitWidth)
    };
};
const toInt = (bytes, offset, count)=>{
    let byteOffset = offset / 8 | 0;
    let bitOffset = offset % 8;
    let desired = count;
    let bits = 0;
    while(desired > 0 && byteOffset < bytes.byteLength){
        const byte = bytes[byteOffset];
        const available = 8 - bitOffset;
        const taking = available < desired ? available : desired;
        const bitsLeft = 8 - bitOffset - taking;
        // mask to turn of bits before bitOffset
        const mask = 0xff >> bitOffset;
        // turn off offset bits and shift to drop remaining bit on the right
        const value = (mask & byte) >> bitsLeft;
        bits = (bits << taking) + value;
        desired -= taking;
        byteOffset++;
        bitOffset = 0;
    }
    return bits;
};
}),
"[project]/node_modules/@perma/map/src/bitfield/Uint8Array.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "and",
    ()=>and,
    "empty",
    ()=>empty,
    "from",
    ()=>from,
    "fromBytes",
    ()=>fromBytes,
    "get",
    ()=>get,
    "or",
    ()=>or,
    "popcount",
    ()=>popcount,
    "set",
    ()=>set,
    "size",
    ()=>size,
    "toBytes",
    ()=>toBytes,
    "unset",
    ()=>unset
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/bitfield/Uint32.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/bitfield/api.js [app-client] (ecmascript)");
;
;
const empty = (size = 256)=>{
    if (size % 8 !== 0) {
        throw new Error(`Must be multiple of 8`);
    }
    return new Uint8Array(size / 8);
};
const from = (bits, size)=>{
    let bitfield = empty(size);
    for (const index of bits){
        const { byte, byteOffset, bitOffset } = at(bitfield, index);
        bitfield[byteOffset] = byte | 1 << bitOffset;
    }
    return bitfield;
};
const size = (bitfield)=>bitfield.byteLength * 8;
/**
 * Compute offset for the given index
 *
 * @param {Uint8Array} bitfield
 * @param {number} index
 */ const at = (bitfield, index)=>{
    const byteOffset = bitfield.byteLength - 1 - (index / 8 | 0);
    const bitOffset = index % 8;
    const byte = bitfield[byteOffset];
    return {
        byte,
        byteOffset,
        bitOffset
    };
};
/**
 * Set a particular bit.
 *
 * @param {Uint8Array} bytes
 * @param {number} index
 * @param {number} byte
 * @returns {Uint8Array}
 */ const setByte = (bytes, index, byte)=>{
    if (bytes[index] !== byte) {
        const result = bytes.slice(0);
        result[index] = byte;
        return result;
    }
    return bytes;
};
const set = (bitfield, index)=>{
    const { byte, byteOffset, bitOffset } = at(bitfield, index);
    return setByte(bitfield, byteOffset, byte | 1 << bitOffset);
};
const unset = (bitfield, index)=>{
    const { byte, byteOffset, bitOffset } = at(bitfield, index);
    return setByte(bitfield, byteOffset, byte & (0xff ^ 1 << bitOffset));
};
const get = (bitfield, index)=>{
    var { byte, bitOffset } = at(bitfield, index);
    return (byte >> bitOffset & 0x1) !== 0;
};
const toBytes = (bitfield)=>bitfield;
const fromBytes = (bytes)=>bytes;
const popcount = (bitfield, index = bitfield.byteLength * 8)=>{
    const { byteOffset, bitOffset, byte } = at(bitfield, index);
    let count = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["popcount"])(byte, bitOffset);
    let offset = bitfield.byteLength - 1;
    while(offset > byteOffset){
        const byte = bitfield[offset];
        count += (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["bitCount"])(byte);
        offset--;
    }
    return count;
};
const or = (left, right)=>{
    const result = left.slice();
    let offset = 0;
    while(offset < left.length){
        result[offset] |= right[offset];
        offset++;
    }
    return result;
};
const and = (left, right)=>{
    const result = left.slice();
    let offset = 0;
    while(offset < left.length){
        result[offset] &= right[offset];
        offset++;
    }
    return result;
};
;
}),
"[project]/node_modules/@perma/map/src/bitfield/Uint8Array.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "API",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__,
    "and",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["and"],
    "empty",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["empty"],
    "from",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["from"],
    "fromBytes",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["fromBytes"],
    "get",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["get"],
    "or",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["or"],
    "popcount",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["popcount"],
    "set",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["set"],
    "size",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["size"],
    "toBytes",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["toBytes"],
    "unset",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["unset"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/bitfield/Uint8Array.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/bitfield/api.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@perma/map/src/lib.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "builder",
    ()=>builder,
    "empty",
    ()=>empty,
    "from",
    ()=>from,
    "get",
    ()=>get,
    "has",
    ()=>has
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/api.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/node.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$path$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/path/Uint32.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$path$2f$Uint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/path/Uint8Array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/bitfield/Uint32.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/bitfield/Uint32.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/bitfield/Uint8Array.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/bitfield/Uint8Array.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
const NOT_FOUND = new RangeError("Not Found");
const empty = (options)=>{
    const config = configure(options);
    return new PersistentHashMap(0, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["create"])(config, null), config);
};
/**
 * @template {API.Config} [C=API.Config<API.Uint32>]
 * @param {Partial<C>} config
 * @returns {C}
 */ const configure = ({ bitWidth = 5, /* c8 ignore next 4 */ BitField = bitWidth === 5 ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$bitfield$2f$Uint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__, Path = bitWidth === 5 ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$path$2f$Uint32$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["configure"]({
    bitWidth
}) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$path$2f$Uint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["configure"]({
    bitWidth
}) } = {})=>/** @type {C} */ ({
        bitWidth,
        BitField,
        Path
    });
const from = (entries, options)=>{
    const node = builder(options);
    for (const [key, value] of entries){
        node.set(key, value);
    }
    return node.build();
};
const has = (hamt, key)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["get"](hamt.root, key, NOT_FOUND) !== NOT_FOUND;
const get = (hamt, key, notFound = undefined)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["get"](hamt.root, key, notFound);
const builder = (options)=>{
    const edit = {};
    const config = configure(options);
    return new HashMapBuilder(edit, 0, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["create"])(config, edit), config);
};
/**
 * @template T
 * @template {string} K
 * @template {API.Config} C
 * @implements {API.PersistentHashMap<T, K, C>}
 */ class PersistentHashMap {
    /**
   *
   * @param {number} count
   * @param {API.BitmapIndexedNode<T, K, C>} root
   * @param {C} config
   */ constructor(count = 0, root, config){
        this.count = count;
        this.root = root;
        this.config = config;
    }
    get size() {
        return this.count;
    }
    clone() {
        return new PersistentHashMap(this.count, this.root, this.config);
    }
    /**
   * @returns {API.PersistentHashMap<T, K, C>}
   */ empty() {
        return new PersistentHashMap(0, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["create"])(this.config, null), this.config);
    }
    /**
   * @param {K} key
   * @returns {boolean}
   */ has(key) {
        return has(this, key);
    }
    /**
   * @param {K} key
   * @returns {T|undefined}
   */ get(key) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["get"](this.root, key, undefined);
    }
    /**
   * @template {string} R
   * @param {R} key
   * @param {T} value
   * @returns {PersistentHashMap<T, K|R, C>}
   */ set(key, value) {
        const addedLeaf = {
            value: false
        };
        const root = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["set"](this.root, null, key, value, addedLeaf);
        if (root === this.root) {
            return this;
        } else {
            return new PersistentHashMap(addedLeaf.value ? this.count + 1 : this.count, root, this.config);
        }
    }
    /**
   * @param {K} key
   */ delete(key) {
        const root = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["delete"](this.root, null, key, {
            value: false
        });
        if (root === this.root) {
            return this;
        } else {
            return new PersistentHashMap(this.count - 1, root, this.config);
        }
    }
    /* c8 ignore next 3 */ get bitField() {
        return this.config.BitField.or(this.root.datamap, this.root.nodemap);
    }
    [Symbol.iterator]() {
        return this.entries();
    }
    entries() {
        return this.root.entries();
    }
    keys() {
        return this.root.keys();
    }
    values() {
        return this.root.values();
    }
    /**
   * @returns {API.HashMapBuilder<T, K, C>}
   */ createBuilder() {
        return new HashMapBuilder({}, this.count, this.root, this.config);
    }
}
/**
 * @template T
 * @template {string} K
 * @template {API.Config} C
 */ class HashMapBuilder {
    /**
   * @param {API.Edit} edit
   * @param {number} count
   * @param {API.BitmapIndexedNode<T, K, C>} root
   * @param {C} config
   */ constructor(edit, count, root, config){
        /**
     * @type {API.Edit|null}
     * @private
     */ this.edit = edit;
        /**
     * @private
     */ this.count = count;
        this.root = root;
        this.config = config;
    }
    get size() {
        if (this.edit) {
            return this.count;
        } else {
            throw new Error(`.size was accessed on the finalized builder`);
        }
    }
    /**
   * @template {string} R
   * @param {R} key
   * @param {T} value
   * @returns {HashMapBuilder<T, K|R, C>}
   */ set(key, value) {
        if (this.edit) {
            const addedLeaf = {
                value: false
            };
            const root = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["set"](this.root, this.edit, key, value, addedLeaf);
            if (this.root !== root) {
                this.root = root;
            }
            if (addedLeaf.value) {
                this.count += 1;
            }
            return this;
        } else {
            throw new Error(`.set was called on the finalized builder`);
        }
    }
    /**
   * @param {K} key
   */ delete(key) {
        if (this.edit) {
            if (this.count === 0) {
                return this;
            }
            const removedLeaf = {
                value: false
            };
            const root = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["delete"](this.root, this.edit, key, removedLeaf);
            if (root !== this.root) {
                this.root = root;
            }
            if (removedLeaf.value) {
                this.count -= 1;
            }
            return this;
        } else {
            throw new Error(`.delete was called on the finalized builder`);
        }
    }
    build() {
        if (this.edit) {
            this.edit = null;
            return new PersistentHashMap(this.count, this.root, this.config);
        } else {
            throw new Error(`.build was called on the finalized builder`);
        }
    }
}
}),
"[project]/node_modules/@perma/map/src/path/InfiniteUint8Array.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "configure",
    ()=>configure,
    "hash64",
    ()=>hash64,
    "read",
    ()=>read
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$path$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/path/api.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$path$2f$Uint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/path/Uint8Array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$murmur3$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@multiformats/murmur3/src/index.js [app-client] (ecmascript)");
;
;
;
const utf8 = new TextEncoder();
const hash64 = (bytes)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$multiformats$2f$murmur3$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["murmur364"].encode(bytes);
const configure = ({ bitWidth = 8, hash = hash64 })=>{
    const hashSize = hash(new Uint8Array()).byteLength;
    const options = {
        bitWidth,
        hash,
        hashSize
    };
    /**
   * @param {Uint8Array} path
   * @param {number} depth
   * @returns {API.Uint32}
   */ const at = (path, depth)=>read(path, depth, options);
    /**
   * @param {string} key
   */ const from = (key)=>utf8.encode(key);
    return {
        at,
        from,
        size: Infinity
    };
};
const read = (key, depth = 0, { bitWidth = 8, hash, hashSize })=>{
    // key digest consists of infinite number of hash frames that are computed
    // from key + frame n which looks like
    // [hash(key), hash([key, 1]), hash([key, n])]
    // You can think of the hash as concatination of all frames. Here we calculate
    // frame bit size from hash size as we going to use that several times.
    const frameBitSize = hashSize * 8;
    // We start with 0 digest and required `bitCount` corresponding to `bitWith`.
    // In the loop we'll going to consume `bitCount` hash bits.
    let digest = 0;
    let bitCount = bitWidth;
    // Calculate absolute bit offset within the key digest.
    let bitOffset = bitWidth * depth;
    while(bitCount > 0){
        // We derive frame number based on current bit offset.
        const frameOffset = bitOffset / frameBitSize >> 0;
        // Then we compute that hash frame
        const frame = frameOffset === 0 ? hash(key) : hash(appendByte(key, frameOffset));
        // compute bit offset within the current frame
        const offset = frameBitSize <= bitOffset ? bitOffset % frameBitSize : bitOffset;
        // calculate number of bits remaining in this frame
        const maxBits = frameBitSize - offset;
        // we will consume all required bits from frame if enough are available
        // otherwise we consume whatever's available and continue rest in the next
        // cycle(s).
        const count = maxBits < bitCount ? maxBits : bitCount;
        digest = (digest << count) + (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$path$2f$Uint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["toInt"])(frame, offset, count);
        bitCount -= count;
        bitOffset += count;
    }
    return digest;
};
/**
 * @param {Uint8Array} source
 * @param {number} byte
 */ const appendByte = (source, byte)=>{
    const bytes = new Uint8Array(source.byteLength + 1).fill(byte, source.byteLength);
    bytes.set(source);
    return bytes;
};
}),
"[project]/node_modules/@perma/map/src/unixfs.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "bitField",
    ()=>bitField,
    "bitWidth",
    ()=>bitWidth,
    "builder",
    ()=>builder,
    "config",
    ()=>config,
    "empty",
    ()=>empty,
    "from",
    ()=>from,
    "iterate",
    ()=>iterate,
    "tableSize",
    ()=>tableSize
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/lib.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/node.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$path$2f$InfiniteUint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/path/InfiniteUint8Array.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@perma/map/src/api.js [app-client] (ecmascript)");
;
;
;
;
;
const bitWidth = 8;
const config = {
    bitWidth,
    Path: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$path$2f$InfiniteUint8Array$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["configure"]({
        bitWidth
    })
};
const tableSize = (hamt)=>Math.pow(2, hamt.config.bitWidth);
const empty = (options = config)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["empty"](options);
const builder = (options = config)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["builder"](options);
const from = (entries, options = config)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["from"](entries, options);
const bitField = ({ datamap, nodemap, config: { BitField } })=>withoutLeadingZeros(BitField.toBytes(BitField.or(datamap, nodemap)));
/**
 * @param {Uint8Array} bytes
 */ const withoutLeadingZeros = (bytes)=>{
    let offset = 0;
    while(offset < bytes.byteLength){
        if (bytes[offset] !== 0) {
            return bytes.subarray(offset);
        }
        offset += 1;
    }
    return bytes.subarray(offset);
};
const iterate = function*(root) {
    const { config, datamap, nodemap } = root;
    const { BitField: bitfield } = config;
    const size = bitfield.size(datamap);
    let bitOffset = 0;
    let dataCount = 0;
    while(bitOffset < size){
        const prefix = bitOffset.toString(16).toUpperCase().padStart(2, "0");
        if (bitfield.get(datamap, bitOffset)) {
            const key = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["keyAt"](root, dataCount);
            yield {
                prefix,
                key,
                value: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["valueAt"](root, dataCount)
            };
            dataCount++;
        } else if (bitfield.get(nodemap, bitOffset)) {
            yield {
                prefix,
                // UnixFS never contains hash collision nodes because it uses
                // inifinite hashes
                node: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$perma$2f$map$2f$src$2f$node$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["resolveNode"](root, bitOffset)
            };
        }
        bitOffset++;
    }
};
}),
"[project]/node_modules/murmurhash3js-revisited/lib/murmurHash3js.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

/* jshint -W086: true */ // +----------------------------------------------------------------------+
// | murmurHash3js.js v3.0.1 // https://github.com/pid/murmurHash3js
// | A javascript implementation of MurmurHash3's x86 hashing algorithms. |
// |----------------------------------------------------------------------|
// | Copyright (c) 2012-2015 Karan Lyons                                       |
// | https://github.com/karanlyons/murmurHash3.js/blob/c1778f75792abef7bdd74bc85d2d4e1a3d25cfe9/murmurHash3.js |
// | Freely distributable under the MIT license.                          |
// +----------------------------------------------------------------------+
;
(function(root, undefined) {
    'use strict';
    // Create a local object that'll be exported or referenced globally.
    var library = {
        'version': '3.0.0',
        'x86': {},
        'x64': {},
        'inputValidation': true
    };
    // PRIVATE FUNCTIONS
    // -----------------
    function _validBytes(bytes) {
        // check the input is an array or a typed array
        if (!Array.isArray(bytes) && !ArrayBuffer.isView(bytes)) {
            return false;
        }
        // check all bytes are actually bytes
        for(var i = 0; i < bytes.length; i++){
            if (!Number.isInteger(bytes[i]) || bytes[i] < 0 || bytes[i] > 255) {
                return false;
            }
        }
        return true;
    }
    function _x86Multiply(m, n) {
        //
        // Given two 32bit ints, returns the two multiplied together as a
        // 32bit int.
        //
        return (m & 0xffff) * n + (((m >>> 16) * n & 0xffff) << 16);
    }
    function _x86Rotl(m, n) {
        //
        // Given a 32bit int and an int representing a number of bit positions,
        // returns the 32bit int rotated left by that number of positions.
        //
        return m << n | m >>> 32 - n;
    }
    function _x86Fmix(h) {
        //
        // Given a block, returns murmurHash3's final x86 mix of that block.
        //
        h ^= h >>> 16;
        h = _x86Multiply(h, 0x85ebca6b);
        h ^= h >>> 13;
        h = _x86Multiply(h, 0xc2b2ae35);
        h ^= h >>> 16;
        return h;
    }
    function _x64Add(m, n) {
        //
        // Given two 64bit ints (as an array of two 32bit ints) returns the two
        // added together as a 64bit int (as an array of two 32bit ints).
        //
        m = [
            m[0] >>> 16,
            m[0] & 0xffff,
            m[1] >>> 16,
            m[1] & 0xffff
        ];
        n = [
            n[0] >>> 16,
            n[0] & 0xffff,
            n[1] >>> 16,
            n[1] & 0xffff
        ];
        var o = [
            0,
            0,
            0,
            0
        ];
        o[3] += m[3] + n[3];
        o[2] += o[3] >>> 16;
        o[3] &= 0xffff;
        o[2] += m[2] + n[2];
        o[1] += o[2] >>> 16;
        o[2] &= 0xffff;
        o[1] += m[1] + n[1];
        o[0] += o[1] >>> 16;
        o[1] &= 0xffff;
        o[0] += m[0] + n[0];
        o[0] &= 0xffff;
        return [
            o[0] << 16 | o[1],
            o[2] << 16 | o[3]
        ];
    }
    function _x64Multiply(m, n) {
        //
        // Given two 64bit ints (as an array of two 32bit ints) returns the two
        // multiplied together as a 64bit int (as an array of two 32bit ints).
        //
        m = [
            m[0] >>> 16,
            m[0] & 0xffff,
            m[1] >>> 16,
            m[1] & 0xffff
        ];
        n = [
            n[0] >>> 16,
            n[0] & 0xffff,
            n[1] >>> 16,
            n[1] & 0xffff
        ];
        var o = [
            0,
            0,
            0,
            0
        ];
        o[3] += m[3] * n[3];
        o[2] += o[3] >>> 16;
        o[3] &= 0xffff;
        o[2] += m[2] * n[3];
        o[1] += o[2] >>> 16;
        o[2] &= 0xffff;
        o[2] += m[3] * n[2];
        o[1] += o[2] >>> 16;
        o[2] &= 0xffff;
        o[1] += m[1] * n[3];
        o[0] += o[1] >>> 16;
        o[1] &= 0xffff;
        o[1] += m[2] * n[2];
        o[0] += o[1] >>> 16;
        o[1] &= 0xffff;
        o[1] += m[3] * n[1];
        o[0] += o[1] >>> 16;
        o[1] &= 0xffff;
        o[0] += m[0] * n[3] + m[1] * n[2] + m[2] * n[1] + m[3] * n[0];
        o[0] &= 0xffff;
        return [
            o[0] << 16 | o[1],
            o[2] << 16 | o[3]
        ];
    }
    function _x64Rotl(m, n) {
        //
        // Given a 64bit int (as an array of two 32bit ints) and an int
        // representing a number of bit positions, returns the 64bit int (as an
        // array of two 32bit ints) rotated left by that number of positions.
        //
        n %= 64;
        if (n === 32) {
            return [
                m[1],
                m[0]
            ];
        } else if (n < 32) {
            return [
                m[0] << n | m[1] >>> 32 - n,
                m[1] << n | m[0] >>> 32 - n
            ];
        } else {
            n -= 32;
            return [
                m[1] << n | m[0] >>> 32 - n,
                m[0] << n | m[1] >>> 32 - n
            ];
        }
    }
    function _x64LeftShift(m, n) {
        //
        // Given a 64bit int (as an array of two 32bit ints) and an int
        // representing a number of bit positions, returns the 64bit int (as an
        // array of two 32bit ints) shifted left by that number of positions.
        //
        n %= 64;
        if (n === 0) {
            return m;
        } else if (n < 32) {
            return [
                m[0] << n | m[1] >>> 32 - n,
                m[1] << n
            ];
        } else {
            return [
                m[1] << n - 32,
                0
            ];
        }
    }
    function _x64Xor(m, n) {
        //
        // Given two 64bit ints (as an array of two 32bit ints) returns the two
        // xored together as a 64bit int (as an array of two 32bit ints).
        //
        return [
            m[0] ^ n[0],
            m[1] ^ n[1]
        ];
    }
    function _x64Fmix(h) {
        //
        // Given a block, returns murmurHash3's final x64 mix of that block.
        // (`[0, h[0] >>> 1]` is a 33 bit unsigned right shift. This is the
        // only place where we need to right shift 64bit ints.)
        //
        h = _x64Xor(h, [
            0,
            h[0] >>> 1
        ]);
        h = _x64Multiply(h, [
            0xff51afd7,
            0xed558ccd
        ]);
        h = _x64Xor(h, [
            0,
            h[0] >>> 1
        ]);
        h = _x64Multiply(h, [
            0xc4ceb9fe,
            0x1a85ec53
        ]);
        h = _x64Xor(h, [
            0,
            h[0] >>> 1
        ]);
        return h;
    }
    // PUBLIC FUNCTIONS
    // ----------------
    library.x86.hash32 = function(bytes, seed) {
        //
        // Given a string and an optional seed as an int, returns a 32 bit hash
        // using the x86 flavor of MurmurHash3, as an unsigned int.
        //
        if (library.inputValidation && !_validBytes(bytes)) {
            return undefined;
        }
        seed = seed || 0;
        var remainder = bytes.length % 4;
        var blocks = bytes.length - remainder;
        var h1 = seed;
        var k1 = 0;
        var c1 = 0xcc9e2d51;
        var c2 = 0x1b873593;
        for(var i = 0; i < blocks; i = i + 4){
            k1 = bytes[i] | bytes[i + 1] << 8 | bytes[i + 2] << 16 | bytes[i + 3] << 24;
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c2);
            h1 ^= k1;
            h1 = _x86Rotl(h1, 13);
            h1 = _x86Multiply(h1, 5) + 0xe6546b64;
        }
        k1 = 0;
        switch(remainder){
            case 3:
                k1 ^= bytes[i + 2] << 16;
            case 2:
                k1 ^= bytes[i + 1] << 8;
            case 1:
                k1 ^= bytes[i];
                k1 = _x86Multiply(k1, c1);
                k1 = _x86Rotl(k1, 15);
                k1 = _x86Multiply(k1, c2);
                h1 ^= k1;
        }
        h1 ^= bytes.length;
        h1 = _x86Fmix(h1);
        return h1 >>> 0;
    };
    library.x86.hash128 = function(bytes, seed) {
        //
        // Given a string and an optional seed as an int, returns a 128 bit
        // hash using the x86 flavor of MurmurHash3, as an unsigned hex.
        //
        if (library.inputValidation && !_validBytes(bytes)) {
            return undefined;
        }
        seed = seed || 0;
        var remainder = bytes.length % 16;
        var blocks = bytes.length - remainder;
        var h1 = seed;
        var h2 = seed;
        var h3 = seed;
        var h4 = seed;
        var k1 = 0;
        var k2 = 0;
        var k3 = 0;
        var k4 = 0;
        var c1 = 0x239b961b;
        var c2 = 0xab0e9789;
        var c3 = 0x38b34ae5;
        var c4 = 0xa1e38b93;
        for(var i = 0; i < blocks; i = i + 16){
            k1 = bytes[i] | bytes[i + 1] << 8 | bytes[i + 2] << 16 | bytes[i + 3] << 24;
            k2 = bytes[i + 4] | bytes[i + 5] << 8 | bytes[i + 6] << 16 | bytes[i + 7] << 24;
            k3 = bytes[i + 8] | bytes[i + 9] << 8 | bytes[i + 10] << 16 | bytes[i + 11] << 24;
            k4 = bytes[i + 12] | bytes[i + 13] << 8 | bytes[i + 14] << 16 | bytes[i + 15] << 24;
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c2);
            h1 ^= k1;
            h1 = _x86Rotl(h1, 19);
            h1 += h2;
            h1 = _x86Multiply(h1, 5) + 0x561ccd1b;
            k2 = _x86Multiply(k2, c2);
            k2 = _x86Rotl(k2, 16);
            k2 = _x86Multiply(k2, c3);
            h2 ^= k2;
            h2 = _x86Rotl(h2, 17);
            h2 += h3;
            h2 = _x86Multiply(h2, 5) + 0x0bcaa747;
            k3 = _x86Multiply(k3, c3);
            k3 = _x86Rotl(k3, 17);
            k3 = _x86Multiply(k3, c4);
            h3 ^= k3;
            h3 = _x86Rotl(h3, 15);
            h3 += h4;
            h3 = _x86Multiply(h3, 5) + 0x96cd1c35;
            k4 = _x86Multiply(k4, c4);
            k4 = _x86Rotl(k4, 18);
            k4 = _x86Multiply(k4, c1);
            h4 ^= k4;
            h4 = _x86Rotl(h4, 13);
            h4 += h1;
            h4 = _x86Multiply(h4, 5) + 0x32ac3b17;
        }
        k1 = 0;
        k2 = 0;
        k3 = 0;
        k4 = 0;
        switch(remainder){
            case 15:
                k4 ^= bytes[i + 14] << 16;
            case 14:
                k4 ^= bytes[i + 13] << 8;
            case 13:
                k4 ^= bytes[i + 12];
                k4 = _x86Multiply(k4, c4);
                k4 = _x86Rotl(k4, 18);
                k4 = _x86Multiply(k4, c1);
                h4 ^= k4;
            case 12:
                k3 ^= bytes[i + 11] << 24;
            case 11:
                k3 ^= bytes[i + 10] << 16;
            case 10:
                k3 ^= bytes[i + 9] << 8;
            case 9:
                k3 ^= bytes[i + 8];
                k3 = _x86Multiply(k3, c3);
                k3 = _x86Rotl(k3, 17);
                k3 = _x86Multiply(k3, c4);
                h3 ^= k3;
            case 8:
                k2 ^= bytes[i + 7] << 24;
            case 7:
                k2 ^= bytes[i + 6] << 16;
            case 6:
                k2 ^= bytes[i + 5] << 8;
            case 5:
                k2 ^= bytes[i + 4];
                k2 = _x86Multiply(k2, c2);
                k2 = _x86Rotl(k2, 16);
                k2 = _x86Multiply(k2, c3);
                h2 ^= k2;
            case 4:
                k1 ^= bytes[i + 3] << 24;
            case 3:
                k1 ^= bytes[i + 2] << 16;
            case 2:
                k1 ^= bytes[i + 1] << 8;
            case 1:
                k1 ^= bytes[i];
                k1 = _x86Multiply(k1, c1);
                k1 = _x86Rotl(k1, 15);
                k1 = _x86Multiply(k1, c2);
                h1 ^= k1;
        }
        h1 ^= bytes.length;
        h2 ^= bytes.length;
        h3 ^= bytes.length;
        h4 ^= bytes.length;
        h1 += h2;
        h1 += h3;
        h1 += h4;
        h2 += h1;
        h3 += h1;
        h4 += h1;
        h1 = _x86Fmix(h1);
        h2 = _x86Fmix(h2);
        h3 = _x86Fmix(h3);
        h4 = _x86Fmix(h4);
        h1 += h2;
        h1 += h3;
        h1 += h4;
        h2 += h1;
        h3 += h1;
        h4 += h1;
        return ("00000000" + (h1 >>> 0).toString(16)).slice(-8) + ("00000000" + (h2 >>> 0).toString(16)).slice(-8) + ("00000000" + (h3 >>> 0).toString(16)).slice(-8) + ("00000000" + (h4 >>> 0).toString(16)).slice(-8);
    };
    library.x64.hash128 = function(bytes, seed) {
        //
        // Given a string and an optional seed as an int, returns a 128 bit
        // hash using the x64 flavor of MurmurHash3, as an unsigned hex.
        //
        if (library.inputValidation && !_validBytes(bytes)) {
            return undefined;
        }
        seed = seed || 0;
        var remainder = bytes.length % 16;
        var blocks = bytes.length - remainder;
        var h1 = [
            0,
            seed
        ];
        var h2 = [
            0,
            seed
        ];
        var k1 = [
            0,
            0
        ];
        var k2 = [
            0,
            0
        ];
        var c1 = [
            0x87c37b91,
            0x114253d5
        ];
        var c2 = [
            0x4cf5ad43,
            0x2745937f
        ];
        for(var i = 0; i < blocks; i = i + 16){
            k1 = [
                bytes[i + 4] | bytes[i + 5] << 8 | bytes[i + 6] << 16 | bytes[i + 7] << 24,
                bytes[i] | bytes[i + 1] << 8 | bytes[i + 2] << 16 | bytes[i + 3] << 24
            ];
            k2 = [
                bytes[i + 12] | bytes[i + 13] << 8 | bytes[i + 14] << 16 | bytes[i + 15] << 24,
                bytes[i + 8] | bytes[i + 9] << 8 | bytes[i + 10] << 16 | bytes[i + 11] << 24
            ];
            k1 = _x64Multiply(k1, c1);
            k1 = _x64Rotl(k1, 31);
            k1 = _x64Multiply(k1, c2);
            h1 = _x64Xor(h1, k1);
            h1 = _x64Rotl(h1, 27);
            h1 = _x64Add(h1, h2);
            h1 = _x64Add(_x64Multiply(h1, [
                0,
                5
            ]), [
                0,
                0x52dce729
            ]);
            k2 = _x64Multiply(k2, c2);
            k2 = _x64Rotl(k2, 33);
            k2 = _x64Multiply(k2, c1);
            h2 = _x64Xor(h2, k2);
            h2 = _x64Rotl(h2, 31);
            h2 = _x64Add(h2, h1);
            h2 = _x64Add(_x64Multiply(h2, [
                0,
                5
            ]), [
                0,
                0x38495ab5
            ]);
        }
        k1 = [
            0,
            0
        ];
        k2 = [
            0,
            0
        ];
        switch(remainder){
            case 15:
                k2 = _x64Xor(k2, _x64LeftShift([
                    0,
                    bytes[i + 14]
                ], 48));
            case 14:
                k2 = _x64Xor(k2, _x64LeftShift([
                    0,
                    bytes[i + 13]
                ], 40));
            case 13:
                k2 = _x64Xor(k2, _x64LeftShift([
                    0,
                    bytes[i + 12]
                ], 32));
            case 12:
                k2 = _x64Xor(k2, _x64LeftShift([
                    0,
                    bytes[i + 11]
                ], 24));
            case 11:
                k2 = _x64Xor(k2, _x64LeftShift([
                    0,
                    bytes[i + 10]
                ], 16));
            case 10:
                k2 = _x64Xor(k2, _x64LeftShift([
                    0,
                    bytes[i + 9]
                ], 8));
            case 9:
                k2 = _x64Xor(k2, [
                    0,
                    bytes[i + 8]
                ]);
                k2 = _x64Multiply(k2, c2);
                k2 = _x64Rotl(k2, 33);
                k2 = _x64Multiply(k2, c1);
                h2 = _x64Xor(h2, k2);
            case 8:
                k1 = _x64Xor(k1, _x64LeftShift([
                    0,
                    bytes[i + 7]
                ], 56));
            case 7:
                k1 = _x64Xor(k1, _x64LeftShift([
                    0,
                    bytes[i + 6]
                ], 48));
            case 6:
                k1 = _x64Xor(k1, _x64LeftShift([
                    0,
                    bytes[i + 5]
                ], 40));
            case 5:
                k1 = _x64Xor(k1, _x64LeftShift([
                    0,
                    bytes[i + 4]
                ], 32));
            case 4:
                k1 = _x64Xor(k1, _x64LeftShift([
                    0,
                    bytes[i + 3]
                ], 24));
            case 3:
                k1 = _x64Xor(k1, _x64LeftShift([
                    0,
                    bytes[i + 2]
                ], 16));
            case 2:
                k1 = _x64Xor(k1, _x64LeftShift([
                    0,
                    bytes[i + 1]
                ], 8));
            case 1:
                k1 = _x64Xor(k1, [
                    0,
                    bytes[i]
                ]);
                k1 = _x64Multiply(k1, c1);
                k1 = _x64Rotl(k1, 31);
                k1 = _x64Multiply(k1, c2);
                h1 = _x64Xor(h1, k1);
        }
        h1 = _x64Xor(h1, [
            0,
            bytes.length
        ]);
        h2 = _x64Xor(h2, [
            0,
            bytes.length
        ]);
        h1 = _x64Add(h1, h2);
        h2 = _x64Add(h2, h1);
        h1 = _x64Fmix(h1);
        h2 = _x64Fmix(h2);
        h1 = _x64Add(h1, h2);
        h2 = _x64Add(h2, h1);
        return ("00000000" + (h1[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h1[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[1] >>> 0).toString(16)).slice(-8);
    };
    // INITIALIZATION
    // --------------
    // Export murmurHash3 for CommonJS, either as an AMD module or just as part
    // of the global object.
    if (typeof exports !== 'undefined') {
        if (("TURBOPACK compile-time value", "object") !== 'undefined' && module.exports) {
            exports = module.exports = library;
        }
        exports.murmurHash3 = library;
    } else if (typeof define === 'function' && define.amd) {
        ((r)=>r !== undefined && __turbopack_context__.v(r))(function() {
            return library;
        }());
    } else {
        // Use murmurHash3.noConflict to restore `murmurHash3` back to its
        // original value. Returns a reference to the library object, to allow
        // it to be used under a different name.
        library._murmurHash3 = root.murmurHash3;
        library.noConflict = function() {
            root.murmurHash3 = library._murmurHash3;
            library._murmurHash3 = undefined;
            library.noConflict = undefined;
            return library;
        };
        root.murmurHash3 = library;
    }
})(/*TURBOPACK member replacement*/ __turbopack_context__.e);
}),
"[project]/node_modules/murmurhash3js-revisited/index.js [app-client] (ecmascript)", ((__turbopack_context__, module, exports) => {

module.exports = __turbopack_context__.r("[project]/node_modules/murmurhash3js-revisited/lib/murmurHash3js.js [app-client] (ecmascript)");
}),
"[project]/node_modules/@multiformats/murmur3/src/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "murmur3128",
    ()=>murmur3128,
    "murmur332",
    ()=>murmur332,
    "murmur364",
    ()=>murmur364
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__bytes$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bytes.js [app-client] (ecmascript) <export * as bytes>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$hasher$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/hashes/hasher.js [app-client] (ecmascript)");
// @ts-expect-error no types
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$murmurhash3js$2d$revisited$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/murmurhash3js-revisited/index.js [app-client] (ecmascript)");
;
;
;
/**
 * @param {number} number
 * @returns {Uint8Array}
 */ function fromNumberTo32BitBuf(number) {
    const bytes = new Array(4);
    for(let i = 0; i < 4; i++){
        bytes[i] = number & 0xff;
        number = number >> 8;
    }
    return new Uint8Array(bytes);
}
const murmur332 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$hasher$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"])({
    name: 'murmur3-32',
    code: 0x23,
    encode: (input)=>fromNumberTo32BitBuf(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$murmurhash3js$2d$revisited$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].x86.hash32(input))
});
const murmur3128 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$hasher$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"])({
    name: 'murmur3-128',
    code: 0x22,
    encode: (input)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__bytes$3e$__["bytes"].fromHex(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$murmurhash3js$2d$revisited$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].x64.hash128(input))
});
const murmur364 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$hasher$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"])({
    name: 'murmur3-x64-64',
    code: 0x22,
    encode: (input)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bytes$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__bytes$3e$__["bytes"].fromHex(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$murmurhash3js$2d$revisited$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].x64.hash128(input)).subarray(0, 8)
});
}),
"[project]/node_modules/@storacha/blob-index/dist/api.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
;
 //# sourceMappingURL=api.js.map
}),
"[project]/node_modules/@storacha/blob-index/dist/digest-map.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "DigestMap",
    ()=>DigestMap
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$dist$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/blob-index/dist/api.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/bases/base58.js [app-client] (ecmascript)");
;
;
/** @type {WeakMap<Uint8Array, string>} */ const cache = new WeakMap();
/** @param {API.MultihashDigest} digest */ const toBase58String = (digest)=>{
    let str = cache.get(digest.bytes);
    if (!str) {
        str = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base58btc"].encode(digest.bytes);
        cache.set(digest.bytes, str);
    }
    return str;
};
class DigestMap {
    /** @type {Map<string, [Key, Value]>} */ #data;
    /**
     * @param {Array<[Key, Value]>} [entries]
     */ constructor(entries){
        this.#data = new Map();
        for (const [k, v] of entries ?? []){
            this.set(k, v);
        }
    }
    get [Symbol.toStringTag]() {
        return 'DigestMap';
    }
    clear() {
        this.#data.clear();
    }
    /**
     * @param {Key} key
     * @returns {boolean}
     */ delete(key) {
        const mhstr = toBase58String(key);
        return this.#data.delete(mhstr);
    }
    /**
     * @param {(value: Value, key: Key, map: Map<Key, Value>) => void} callbackfn
     * @param {any} [thisArg]
     */ forEach(callbackfn, thisArg) {
        for (const [k, v] of this.#data.values()){
            callbackfn.call(thisArg, v, k, this);
        }
    }
    /**
     * @param {Key} key
     * @returns {Value|undefined}
     */ get(key) {
        const data = this.#data.get(toBase58String(key));
        if (data) return data[1];
    }
    /**
     * @param {Key} key
     * @returns {boolean}
     */ has(key) {
        return this.#data.has(toBase58String(key));
    }
    /**
     * @param {Key} key
     * @param {Value} value
     */ set(key, value) {
        this.#data.set(toBase58String(key), [
            key,
            value
        ]);
        return this;
    }
    /** @returns {number} */ get size() {
        return this.#data.size;
    }
    /** @returns */ [Symbol.iterator]() {
        return this.entries();
    }
    /** @returns {IterableIterator<[Key, Value]>} */ *entries() {
        yield* this.#data.values();
    }
    /** @returns {IterableIterator<Key>} */ *keys() {
        for (const [k] of this.#data.values()){
            yield k;
        }
    }
    /** @returns {IterableIterator<Value>} */ *values() {
        for (const [, v] of this.#data.values()){
            yield v;
        }
    }
} //# sourceMappingURL=digest-map.js.map
}),
"[project]/node_modules/@storacha/blob-index/dist/sharded-dag-index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BlobIndexSchema",
    ()=>BlobIndexSchema,
    "DecodeFailure",
    ()=>DecodeFailure,
    "MultihashSchema",
    ()=>MultihashSchema,
    "ShardedDAGIndexSchema",
    ()=>ShardedDAGIndexSchema,
    "UnknownFormat",
    ()=>UnknownFormat,
    "archive",
    ()=>archive,
    "create",
    ()=>create,
    "extract",
    ()=>extract,
    "version",
    ()=>version,
    "view",
    ()=>view
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$dist$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/blob-index/dist/api.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$lib$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/lib.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__CAR$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/car.js [app-client] (ecmascript) <export * as CAR>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/result.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__ = __turbopack_context__.i("[project]/node_modules/@ucanto/core/src/schema.js [app-client] (ecmascript) <export * as Schema>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@storacha/blob-index/node_modules/uint8arrays/dist/src/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$compare$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/blob-index/node_modules/uint8arrays/dist/src/compare.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-cbor/src/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/hashes/digest.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/link.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$sha2$2d$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/hashes/sha2-browser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$dist$2f$digest$2d$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/blob-index/dist/digest-map.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
const version = 'index/sharded/dag@0.1';
const ShardedDAGIndexSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__["Schema"].variant({
    [version]: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__["Schema"].struct({
        /** DAG root. */ content: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__["Schema"].link(),
        /** Shards the DAG can be found in. */ shards: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__["Schema"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__["Schema"].link())
    })
});
const MultihashSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__["Schema"].bytes();
const BlobIndexSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__["Schema"].tuple([
    MultihashSchema,
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__["Schema"].array(/** multihash bytes, offset, length. */ __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__["Schema"].tuple([
        MultihashSchema,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__["Schema"].tuple([
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__["Schema"].number(),
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__Schema$3e$__["Schema"].number()
        ])
    ]))
]);
const extract = (archive)=>{
    const { roots, blocks } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__CAR$3e$__["CAR"].decode(archive);
    if (!roots.length) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["error"])(new UnknownFormat('missing root block'));
    }
    const { code } = roots[0].cid;
    if (code !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["code"]) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["error"])(new UnknownFormat(`unexpected root CID codec: 0x${code.toString(16)}`));
    }
    return view({
        root: roots[0],
        blocks
    });
};
const view = ({ root, blocks })=>{
    const [version, dagIndexData] = ShardedDAGIndexSchema.match(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](root.bytes));
    switch(version){
        case version:
            {
                const dagIndex = create(dagIndexData.content);
                for (const shardLink of dagIndexData.shards){
                    const shard = blocks.get(shardLink.toString());
                    if (!shard) {
                        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["error"])(new DecodeFailure(`missing shard block: ${shardLink}`));
                    }
                    const blobIndexData = BlobIndexSchema.from(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](shard.bytes));
                    const blobIndex = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$dist$2f$digest$2d$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DigestMap"]();
                    for (const [digest, [offset, length]] of blobIndexData[1]){
                        blobIndex.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](digest), [
                            offset,
                            length
                        ]);
                    }
                    dagIndex.shards.set(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](blobIndexData[0]), blobIndex);
                }
                return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ok"])(dagIndex);
            }
        default:
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["error"])(new UnknownFormat(`unknown index version: ${version}`));
    }
};
/** @implements {API.ShardedDAGIndexView} */ class ShardedDAGIndex {
    #content;
    #shards;
    /** @param {API.UnknownLink} content */ constructor(content){
        this.#content = content;
        /** @type {DigestMap<API.ShardDigest, API.Position>} */ this.#shards = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$dist$2f$digest$2d$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DigestMap"]();
    }
    get content() {
        return this.#content;
    }
    get shards() {
        return this.#shards;
    }
    /**
     * @param {API.ShardDigest} shard
     * @param {API.SliceDigest} slice
     * @param {API.Position} pos
     */ setSlice(shard, slice, pos) {
        let index = this.#shards.get(shard);
        if (!index) {
            index = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$dist$2f$digest$2d$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["DigestMap"]();
            this.#shards.set(shard, index);
        }
        index.set(slice, pos);
    }
    archive() {
        return archive(this);
    }
}
class UnknownFormat extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Failure"] {
    #reason;
    /** @param {string} [reason] */ constructor(reason){
        super();
        this.name = 'UnknownFormat';
        this.#reason = reason;
    }
    describe() {
        return this.#reason ?? 'unknown format';
    }
}
class DecodeFailure extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Failure"] {
    #reason;
    /** @param {string} [reason] */ constructor(reason){
        super();
        this.name = 'DecodeFailure';
        this.#reason = reason;
    }
    describe() {
        return this.#reason ?? 'failed to decode';
    }
}
const create = (content)=>new ShardedDAGIndex(content);
const archive = async (model)=>{
    const roots = [];
    const blocks = new Map();
    try {
        const shards = [
            ...model.shards.entries()
        ].sort((a, b)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$compare$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["compare"])(a[0].digest, b[0].digest));
        const index = {
            content: model.content,
            shards: []
        };
        for (const s of shards){
            const slices = [
                ...s[1].entries()
            ].sort((a, b)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$compare$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["compare"])(a[0].digest, b[0].digest)).map((e)=>[
                    e[0].bytes,
                    e[1]
                ]);
            const bytes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"]([
                s[0].bytes,
                slices
            ]);
            const digest = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$sha2$2d$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sha256"].digest(bytes);
            const cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["create"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["code"], digest);
            blocks.set(cid.toString(), {
                cid,
                bytes
            });
            index.shards.push(cid);
        }
        const bytes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"]({
            [version]: index
        });
        const digest = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$sha2$2d$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sha256"].digest(bytes);
        const cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["create"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["code"], digest);
        roots.push({
            cid,
            bytes
        });
    } catch (/** @type {any} */ err) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["error"])({
            name: 'EncodeFailure',
            message: `encoding DAG: ${err.message}`,
            stack: err.stack
        });
    }
    try {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["ok"])(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$car$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__CAR$3e$__["CAR"].encode({
            roots,
            blocks
        }));
    } catch (/** @type {any} */ err) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ucanto$2f$core$2f$src$2f$result$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["error"])({
            name: 'EncodeFailure',
            message: `encoding CAR: ${err.message}`,
            stack: err.stack
        });
    }
}; //# sourceMappingURL=sharded-dag-index.js.map
}),
"[project]/node_modules/@storacha/blob-index/dist/util.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "fromShardArchives",
    ()=>fromShardArchives,
    "indexShardedDAG",
    ()=>indexShardedDAG
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$carstream$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/carstream/src/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$carstream$2f$src$2f$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/carstream/src/reader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$sha2$2d$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/hashes/sha2-browser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$dist$2f$api$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/blob-index/dist/api.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$dist$2f$sharded$2d$dag$2d$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/blob-index/dist/sharded-dag-index.js [app-client] (ecmascript)");
;
;
;
;
const fromShardArchives = async (content, shards)=>{
    const index = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$dist$2f$sharded$2d$dag$2d$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])(content);
    for (const s of shards){
        const digest = await __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$sha2$2d$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sha256"].digest(s);
        await new ReadableStream({
            pull: (c)=>{
                c.enqueue(s);
                c.close();
            }
        }).pipeThrough(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$carstream$2f$src$2f$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CARReaderStream"]()).pipeTo(new WritableStream({
            write ({ cid, blockOffset, blockLength }) {
                index.setSlice(digest, cid.multihash, [
                    blockOffset,
                    blockLength
                ]);
            }
        }));
    }
    return index;
};
async function indexShardedDAG(root, shards, shardIndexes) {
    const index = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$dist$2f$sharded$2d$dag$2d$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])(root);
    for (const [i, shard] of shards.entries()){
        const slices = shardIndexes[i];
        index.shards.set(shard.multihash, slices);
    }
    return await index.archive();
} //# sourceMappingURL=util.js.map
}),
"[project]/node_modules/@storacha/blob-index/dist/index.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$dist$2f$sharded$2d$dag$2d$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/blob-index/dist/sharded-dag-index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$dist$2f$digest$2d$map$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/blob-index/dist/digest-map.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$dist$2f$util$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/blob-index/dist/util.js [app-client] (ecmascript)"); //# sourceMappingURL=index.js.map
;
;
;
}),
"[project]/node_modules/@storacha/blob-index/dist/sharded-dag-index.js [app-client] (ecmascript) <export * as ShardedDAGIndex>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ShardedDAGIndex",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$dist$2f$sharded$2d$dag$2d$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$storacha$2f$blob$2d$index$2f$dist$2f$sharded$2d$dag$2d$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@storacha/blob-index/dist/sharded-dag-index.js [app-client] (ecmascript)");
}),
"[project]/node_modules/uint8arraylist/dist/src/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @packageDocumentation
 *
 * A class that lets you do operations over a list of Uint8Arrays without
 * copying them.
 *
 * ```js
 * import { Uint8ArrayList } from 'uint8arraylist'
 *
 * const list = new Uint8ArrayList()
 * list.append(Uint8Array.from([0, 1, 2]))
 * list.append(Uint8Array.from([3, 4, 5]))
 *
 * list.subarray()
 * // -> Uint8Array([0, 1, 2, 3, 4, 5])
 *
 * list.consume(3)
 * list.subarray()
 * // -> Uint8Array([3, 4, 5])
 *
 * // you can also iterate over the list
 * for (const buf of list) {
 *   // ..do something with `buf`
 * }
 *
 * list.subarray(0, 1)
 * // -> Uint8Array([0])
 * ```
 *
 * ## Converting Uint8ArrayLists to Uint8Arrays
 *
 * There are two ways to turn a `Uint8ArrayList` into a `Uint8Array` - `.slice` and `.subarray` and one way to turn a `Uint8ArrayList` into a `Uint8ArrayList` with different contents - `.sublist`.
 *
 * ### slice
 *
 * Slice follows the same semantics as [Uint8Array.slice](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice) in that it creates a new `Uint8Array` and copies bytes into it using an optional offset & length.
 *
 * ```js
 * const list = new Uint8ArrayList()
 * list.append(Uint8Array.from([0, 1, 2]))
 * list.append(Uint8Array.from([3, 4, 5]))
 *
 * list.slice(0, 1)
 * // -> Uint8Array([0])
 * ```
 *
 * ### subarray
 *
 * Subarray attempts to follow the same semantics as [Uint8Array.subarray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray) with one important different - this is a no-copy operation, unless the requested bytes span two internal buffers in which case it is a copy operation.
 *
 * ```js
 * const list = new Uint8ArrayList()
 * list.append(Uint8Array.from([0, 1, 2]))
 * list.append(Uint8Array.from([3, 4, 5]))
 *
 * list.subarray(0, 1)
 * // -> Uint8Array([0]) - no-copy
 *
 * list.subarray(2, 5)
 * // -> Uint8Array([2, 3, 4]) - copy
 * ```
 *
 * ### sublist
 *
 * Sublist creates and returns a new `Uint8ArrayList` that shares the underlying buffers with the original so is always a no-copy operation.
 *
 * ```js
 * const list = new Uint8ArrayList()
 * list.append(Uint8Array.from([0, 1, 2]))
 * list.append(Uint8Array.from([3, 4, 5]))
 *
 * list.sublist(0, 1)
 * // -> Uint8ArrayList([0]) - no-copy
 *
 * list.sublist(2, 5)
 * // -> Uint8ArrayList([2], [3, 4]) - no-copy
 * ```
 *
 * ## Inspiration
 *
 * Borrows liberally from [bl](https://www.npmjs.com/package/bl) but only uses native JS types.
 */ __turbopack_context__.s([
    "Uint8ArrayList",
    ()=>Uint8ArrayList,
    "isUint8ArrayList",
    ()=>isUint8ArrayList
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/alloc.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$concat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/concat.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$equals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arraylist/node_modules/uint8arrays/dist/src/equals.js [app-client] (ecmascript)");
;
;
;
const symbol = Symbol.for('@achingbrain/uint8arraylist');
function findBufAndOffset(bufs, index) {
    if (index == null || index < 0) {
        throw new RangeError('index is out of bounds');
    }
    let offset = 0;
    for (const buf of bufs){
        const bufEnd = offset + buf.byteLength;
        if (index < bufEnd) {
            return {
                buf,
                index: index - offset
            };
        }
        offset = bufEnd;
    }
    throw new RangeError('index is out of bounds');
}
function isUint8ArrayList(value) {
    return Boolean(value?.[symbol]);
}
class Uint8ArrayList {
    bufs;
    length;
    [symbol] = true;
    constructor(...data){
        this.bufs = [];
        this.length = 0;
        if (data.length > 0) {
            this.appendAll(data);
        }
    }
    *[Symbol.iterator]() {
        yield* this.bufs;
    }
    get byteLength() {
        return this.length;
    }
    /**
     * Add one or more `bufs` to the end of this Uint8ArrayList
     */ append(...bufs) {
        this.appendAll(bufs);
    }
    /**
     * Add all `bufs` to the end of this Uint8ArrayList
     */ appendAll(bufs) {
        let length = 0;
        for (const buf of bufs){
            if (buf instanceof Uint8Array) {
                length += buf.byteLength;
                this.bufs.push(buf);
            } else if (isUint8ArrayList(buf)) {
                length += buf.byteLength;
                this.bufs.push(...buf.bufs);
            } else {
                throw new Error('Could not append value, must be an Uint8Array or a Uint8ArrayList');
            }
        }
        this.length += length;
    }
    /**
     * Add one or more `bufs` to the start of this Uint8ArrayList
     */ prepend(...bufs) {
        this.prependAll(bufs);
    }
    /**
     * Add all `bufs` to the start of this Uint8ArrayList
     */ prependAll(bufs) {
        let length = 0;
        for (const buf of bufs.reverse()){
            if (buf instanceof Uint8Array) {
                length += buf.byteLength;
                this.bufs.unshift(buf);
            } else if (isUint8ArrayList(buf)) {
                length += buf.byteLength;
                this.bufs.unshift(...buf.bufs);
            } else {
                throw new Error('Could not prepend value, must be an Uint8Array or a Uint8ArrayList');
            }
        }
        this.length += length;
    }
    /**
     * Read the value at `index`
     */ get(index) {
        const res = findBufAndOffset(this.bufs, index);
        return res.buf[res.index];
    }
    /**
     * Set the value at `index` to `value`
     */ set(index, value) {
        const res = findBufAndOffset(this.bufs, index);
        res.buf[res.index] = value;
    }
    /**
     * Copy bytes from `buf` to the index specified by `offset`
     */ write(buf, offset = 0) {
        if (buf instanceof Uint8Array) {
            for(let i = 0; i < buf.length; i++){
                this.set(offset + i, buf[i]);
            }
        } else if (isUint8ArrayList(buf)) {
            for(let i = 0; i < buf.length; i++){
                this.set(offset + i, buf.get(i));
            }
        } else {
            throw new Error('Could not write value, must be an Uint8Array or a Uint8ArrayList');
        }
    }
    /**
     * Remove bytes from the front of the pool
     */ consume(bytes) {
        // first, normalize the argument, in accordance with how Buffer does it
        bytes = Math.trunc(bytes);
        // do nothing if not a positive number
        if (Number.isNaN(bytes) || bytes <= 0) {
            return;
        }
        // if consuming all bytes, skip iterating
        if (bytes === this.byteLength) {
            this.bufs = [];
            this.length = 0;
            return;
        }
        while(this.bufs.length > 0){
            if (bytes >= this.bufs[0].byteLength) {
                bytes -= this.bufs[0].byteLength;
                this.length -= this.bufs[0].byteLength;
                this.bufs.shift();
            } else {
                this.bufs[0] = this.bufs[0].subarray(bytes);
                this.length -= bytes;
                break;
            }
        }
    }
    /**
     * Extracts a section of an array and returns a new array.
     *
     * This is a copy operation as it is with Uint8Arrays and Arrays
     * - note this is different to the behaviour of Node Buffers.
     */ slice(beginInclusive, endExclusive) {
        const { bufs, length } = this._subList(beginInclusive, endExclusive);
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$concat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["concat"])(bufs, length);
    }
    /**
     * Returns a alloc from the given start and end element index.
     *
     * In the best case where the data extracted comes from a single Uint8Array
     * internally this is a no-copy operation otherwise it is a copy operation.
     */ subarray(beginInclusive, endExclusive) {
        const { bufs, length } = this._subList(beginInclusive, endExclusive);
        if (bufs.length === 1) {
            return bufs[0];
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$concat$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["concat"])(bufs, length);
    }
    /**
     * Returns a allocList from the given start and end element index.
     *
     * This is a no-copy operation.
     */ sublist(beginInclusive, endExclusive) {
        const { bufs, length } = this._subList(beginInclusive, endExclusive);
        const list = new Uint8ArrayList();
        list.length = length;
        // don't loop, just set the bufs
        list.bufs = [
            ...bufs
        ];
        return list;
    }
    _subList(beginInclusive, endExclusive) {
        beginInclusive = beginInclusive ?? 0;
        endExclusive = endExclusive ?? this.length;
        if (beginInclusive < 0) {
            beginInclusive = this.length + beginInclusive;
        }
        if (endExclusive < 0) {
            endExclusive = this.length + endExclusive;
        }
        if (beginInclusive < 0 || endExclusive > this.length) {
            throw new RangeError('index is out of bounds');
        }
        if (beginInclusive === endExclusive) {
            return {
                bufs: [],
                length: 0
            };
        }
        if (beginInclusive === 0 && endExclusive === this.length) {
            return {
                bufs: this.bufs,
                length: this.length
            };
        }
        const bufs = [];
        let offset = 0;
        for(let i = 0; i < this.bufs.length; i++){
            const buf = this.bufs[i];
            const bufStart = offset;
            const bufEnd = bufStart + buf.byteLength;
            // for next loop
            offset = bufEnd;
            if (beginInclusive >= bufEnd) {
                continue;
            }
            const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd;
            const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd;
            if (sliceStartInBuf && sliceEndsInBuf) {
                // slice is wholly contained within this buffer
                if (beginInclusive === bufStart && endExclusive === bufEnd) {
                    // requested whole buffer
                    bufs.push(buf);
                    break;
                }
                // requested part of buffer
                const start = beginInclusive - bufStart;
                bufs.push(buf.subarray(start, start + (endExclusive - beginInclusive)));
                break;
            }
            if (sliceStartInBuf) {
                // slice starts in this buffer
                if (beginInclusive === 0) {
                    // requested whole buffer
                    bufs.push(buf);
                    continue;
                }
                // requested part of buffer
                bufs.push(buf.subarray(beginInclusive - bufStart));
                continue;
            }
            if (sliceEndsInBuf) {
                if (endExclusive === bufEnd) {
                    // requested whole buffer
                    bufs.push(buf);
                    break;
                }
                // requested part of buffer
                bufs.push(buf.subarray(0, endExclusive - bufStart));
                break;
            }
            // slice started before this buffer and ends after it
            bufs.push(buf);
        }
        return {
            bufs,
            length: endExclusive - beginInclusive
        };
    }
    indexOf(search, offset = 0) {
        if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {
            throw new TypeError('The "value" argument must be a Uint8ArrayList or Uint8Array');
        }
        const needle = search instanceof Uint8Array ? search : search.subarray();
        offset = Number(offset ?? 0);
        if (isNaN(offset)) {
            offset = 0;
        }
        if (offset < 0) {
            offset = this.length + offset;
        }
        if (offset < 0) {
            offset = 0;
        }
        if (search.length === 0) {
            return offset > this.length ? this.length : offset;
        }
        // https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm
        const M = needle.byteLength;
        if (M === 0) {
            throw new TypeError('search must be at least 1 byte long');
        }
        // radix
        const radix = 256;
        const rightmostPositions = new Int32Array(radix);
        // position of the rightmost occurrence of the byte c in the pattern
        for(let c = 0; c < radix; c++){
            // -1 for bytes not in pattern
            rightmostPositions[c] = -1;
        }
        for(let j = 0; j < M; j++){
            // rightmost position for bytes in pattern
            rightmostPositions[needle[j]] = j;
        }
        // Return offset of first match, -1 if no match
        const right = rightmostPositions;
        const lastIndex = this.byteLength - needle.byteLength;
        const lastPatIndex = needle.byteLength - 1;
        let skip;
        for(let i = offset; i <= lastIndex; i += skip){
            skip = 0;
            for(let j = lastPatIndex; j >= 0; j--){
                const char = this.get(i + j);
                if (needle[j] !== char) {
                    skip = Math.max(1, j - right[char]);
                    break;
                }
            }
            if (skip === 0) {
                return i;
            }
        }
        return -1;
    }
    getInt8(byteOffset) {
        const buf = this.subarray(byteOffset, byteOffset + 1);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getInt8(0);
    }
    setInt8(byteOffset, value) {
        const buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["allocUnsafe"])(1);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setInt8(0, value);
        this.write(buf, byteOffset);
    }
    getInt16(byteOffset, littleEndian) {
        const buf = this.subarray(byteOffset, byteOffset + 2);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getInt16(0, littleEndian);
    }
    setInt16(byteOffset, value, littleEndian) {
        const buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["alloc"])(2);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setInt16(0, value, littleEndian);
        this.write(buf, byteOffset);
    }
    getInt32(byteOffset, littleEndian) {
        const buf = this.subarray(byteOffset, byteOffset + 4);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getInt32(0, littleEndian);
    }
    setInt32(byteOffset, value, littleEndian) {
        const buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["alloc"])(4);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setInt32(0, value, littleEndian);
        this.write(buf, byteOffset);
    }
    getBigInt64(byteOffset, littleEndian) {
        const buf = this.subarray(byteOffset, byteOffset + 8);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getBigInt64(0, littleEndian);
    }
    setBigInt64(byteOffset, value, littleEndian) {
        const buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["alloc"])(8);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setBigInt64(0, value, littleEndian);
        this.write(buf, byteOffset);
    }
    getUint8(byteOffset) {
        const buf = this.subarray(byteOffset, byteOffset + 1);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getUint8(0);
    }
    setUint8(byteOffset, value) {
        const buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["allocUnsafe"])(1);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setUint8(0, value);
        this.write(buf, byteOffset);
    }
    getUint16(byteOffset, littleEndian) {
        const buf = this.subarray(byteOffset, byteOffset + 2);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getUint16(0, littleEndian);
    }
    setUint16(byteOffset, value, littleEndian) {
        const buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["alloc"])(2);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setUint16(0, value, littleEndian);
        this.write(buf, byteOffset);
    }
    getUint32(byteOffset, littleEndian) {
        const buf = this.subarray(byteOffset, byteOffset + 4);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getUint32(0, littleEndian);
    }
    setUint32(byteOffset, value, littleEndian) {
        const buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["alloc"])(4);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setUint32(0, value, littleEndian);
        this.write(buf, byteOffset);
    }
    getBigUint64(byteOffset, littleEndian) {
        const buf = this.subarray(byteOffset, byteOffset + 8);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getBigUint64(0, littleEndian);
    }
    setBigUint64(byteOffset, value, littleEndian) {
        const buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["alloc"])(8);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setBigUint64(0, value, littleEndian);
        this.write(buf, byteOffset);
    }
    getFloat32(byteOffset, littleEndian) {
        const buf = this.subarray(byteOffset, byteOffset + 4);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getFloat32(0, littleEndian);
    }
    setFloat32(byteOffset, value, littleEndian) {
        const buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["alloc"])(4);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setFloat32(0, value, littleEndian);
        this.write(buf, byteOffset);
    }
    getFloat64(byteOffset, littleEndian) {
        const buf = this.subarray(byteOffset, byteOffset + 8);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        return view.getFloat64(0, littleEndian);
    }
    setFloat64(byteOffset, value, littleEndian) {
        const buf = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$alloc$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["alloc"])(8);
        const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
        view.setFloat64(0, value, littleEndian);
        this.write(buf, byteOffset);
    }
    equals(other) {
        if (other == null) {
            return false;
        }
        if (!(other instanceof Uint8ArrayList)) {
            return false;
        }
        if (other.bufs.length !== this.bufs.length) {
            return false;
        }
        for(let i = 0; i < this.bufs.length; i++){
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$node_modules$2f$uint8arrays$2f$dist$2f$src$2f$equals$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["equals"])(this.bufs[i], other.bufs[i])) {
                return false;
            }
        }
        return true;
    }
    /**
     * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this
     * method if you know the total size of all the Uint8Arrays ahead of time.
     */ static fromUint8Arrays(bufs, length) {
        const list = new Uint8ArrayList();
        list.bufs = bufs;
        if (length == null) {
            length = bufs.reduce((acc, curr)=>acc + curr.byteLength, 0);
        }
        list.length = length;
        return list;
    }
} /*
function indexOf (needle: Uint8Array, haystack: Uint8Array, offset = 0) {
  for (let i = offset; i < haystack.byteLength; i++) {
    for (let j = 0; j < needle.length; j++) {
      if (haystack[i + j] !== needle[j]) {
        break
      }

      if (j === needle.byteLength -1) {
        return i
      }
    }

    if (haystack.byteLength - i < needle.byteLength) {
      break
    }
  }

  return -1
}
*/  //# sourceMappingURL=index.js.map
}),
"[project]/node_modules/carstream/src/varint.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "decode",
    ()=>decode,
    "encode",
    ()=>encode
]);
const MSB = 0x80;
const REST = 0x7F;
const MSBALL = ~REST;
const INT = Math.pow(2, 31);
const encode = (num)=>{
    /** @type {number[]} */ const out = [];
    let offset = 0;
    while(num >= INT){
        out[offset++] = num & 0xFF | MSB;
        num /= 128;
    }
    while(num & MSBALL){
        out[offset++] = num & 0xFF | MSB;
        num >>>= 7;
    }
    out[offset] = num | 0;
    return out;
};
const decode = (buf, offset)=>{
    let res = 0;
    offset = offset || 0;
    let shift = 0;
    let counter = offset;
    let b;
    const l = buf.length;
    do {
        if (counter >= l || shift > 49) throw new RangeError('Could not decode varint');
        b = buf.get(counter++);
        res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
        shift += 7;
    }while (b >= MSB)
    return [
        res,
        counter - offset
    ];
};
}),
"[project]/node_modules/carstream/src/reader.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* eslint-env browser */ __turbopack_context__.s([
    "CARReaderStream",
    ()=>CARReaderStream
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/uint8arraylist/dist/src/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-cbor/src/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/hashes/digest.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/multiformats/dist/src/link.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$carstream$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/carstream/src/varint.js [app-client] (ecmascript)");
;
;
;
;
;
const State = {
    ReadHeaderLength: 0,
    ReadHeader: 1,
    ReadBlockLength: 2,
    ReadBlock: 3
};
const CIDV0_BYTES = {
    SHA2_256: 0x12,
    LENGTH: 0x20,
    DAG_PB: 0x70
};
class CARReaderStream extends TransformStream {
    /** @type {Promise<import('./api.js').CARHeader>} */ #headerPromise;
    /**
   * @param {QueuingStrategy<Uint8Array>} [writableStrategy]
   * An object that optionally defines a queuing strategy for the stream.
   * @param {QueuingStrategy<import('./api.js').Block & import('./api.js').Position>} [readableStrategy]
   * An object that optionally defines a queuing strategy for the stream.
   * Defaults to a CountQueuingStrategy with highWaterMark of `1` to allow
   * `getHeader` to be called before the stream is consumed.
   */ constructor(writableStrategy, readableStrategy){
        const buffer = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$uint8arraylist$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Uint8ArrayList"]();
        let offset = 0;
        let prevOffset = offset;
        let wanted = 8;
        let state = State.ReadHeaderLength;
        /** @type {(value: import('./api.js').CARHeader) => void} */ let resolveHeader;
        const headerPromise = new Promise((resolve)=>{
            resolveHeader = resolve;
        });
        super({
            transform (chunk, controller) {
                buffer.append(chunk);
                while(true){
                    if (buffer.length < wanted) break;
                    if (state === State.ReadHeaderLength) {
                        const [length, bytes] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$carstream$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])(buffer);
                        buffer.consume(bytes);
                        prevOffset = offset;
                        offset += bytes;
                        state = State.ReadHeader;
                        wanted = length;
                    } else if (state === State.ReadHeader) {
                        const header = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])(buffer.slice(0, wanted));
                        resolveHeader && resolveHeader(header);
                        buffer.consume(wanted);
                        prevOffset = offset;
                        offset += wanted;
                        state = State.ReadBlockLength;
                        wanted = 8;
                    } else if (state === State.ReadBlockLength) {
                        const [length, bytes] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$carstream$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])(buffer);
                        buffer.consume(bytes);
                        prevOffset = offset;
                        offset += bytes;
                        state = State.ReadBlock;
                        wanted = length;
                    } else if (state === State.ReadBlock) {
                        const _offset = prevOffset;
                        const length = offset - prevOffset + wanted;
                        prevOffset = offset;
                        /** @type {import('multiformats').UnknownLink} */ let cid;
                        if (buffer.get(0) === CIDV0_BYTES.SHA2_256 && buffer.get(1) === CIDV0_BYTES.LENGTH) {
                            const bytes = buffer.subarray(0, 34);
                            const multihash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])(bytes);
                            // @ts-expect-error
                            cid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createLegacy"])(multihash);
                            buffer.consume(34);
                            offset += 34;
                        } else {
                            const [version, versionBytes] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$carstream$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])(buffer);
                            if (version !== 1) throw new Error(`unexpected CID version (${version})`);
                            buffer.consume(versionBytes);
                            offset += versionBytes;
                            const [codec, codecBytes] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$carstream$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])(buffer);
                            buffer.consume(codecBytes);
                            offset += codecBytes;
                            const multihashBytes = getMultihashLength(buffer);
                            const multihash = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])(buffer.subarray(0, multihashBytes));
                            cid = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["create"])(codec, multihash);
                            buffer.consume(multihashBytes);
                            offset += multihashBytes;
                        }
                        const blockBytes = wanted - (offset - prevOffset);
                        const bytes = buffer.subarray(0, blockBytes);
                        controller.enqueue({
                            cid,
                            bytes,
                            offset: _offset,
                            length,
                            blockOffset: offset,
                            blockLength: blockBytes
                        });
                        buffer.consume(blockBytes);
                        prevOffset = offset;
                        offset += blockBytes;
                        state = State.ReadBlockLength;
                        wanted = 8;
                    }
                }
            },
            flush (controller) {
                if (state !== State.ReadBlockLength) {
                    controller.error(new Error('unexpected end of data'));
                }
            }
        }, writableStrategy, readableStrategy ?? new CountQueuingStrategy({
            highWaterMark: 1
        }));
        this.#headerPromise = headerPromise;
    }
    /**
   * Get the decoded CAR header.
   */ getHeader() {
        return this.#headerPromise;
    }
}
/** @param {Uint8ArrayList} bytes */ const getMultihashLength = (bytes)=>{
    const [, codeBytes] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$carstream$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])(bytes);
    const [length, lengthBytes] = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$carstream$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])(bytes, codeBytes);
    return codeBytes + lengthBytes + length;
};
}),
"[project]/node_modules/carstream/src/writer.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* eslint-env browser */ __turbopack_context__.s([
    "CARWriterStream",
    ()=>CARWriterStream,
    "encodeBlock",
    ()=>encodeBlock,
    "encodeHeader",
    ()=>encodeHeader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-cbor/src/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$carstream$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/carstream/src/varint.js [app-client] (ecmascript)");
;
;
const encodeHeader = (roots)=>{
    const headerBytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"])({
        version: 1,
        roots
    });
    const varintBytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$carstream$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"])(headerBytes.length);
    const header = new Uint8Array(varintBytes.length + headerBytes.length);
    header.set(varintBytes, 0);
    header.set(headerBytes, varintBytes.length);
    return header;
};
const encodeBlock = (block)=>{
    const varintBytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$carstream$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"])(block.cid.bytes.length + block.bytes.length);
    const bytes = new Uint8Array(varintBytes.length + block.cid.bytes.length + block.bytes.length);
    bytes.set(varintBytes);
    bytes.set(block.cid.bytes, varintBytes.length);
    bytes.set(block.bytes, varintBytes.length + block.cid.bytes.length);
    return bytes;
};
class CARWriterStream extends TransformStream {
    /**
   * @param {import('multiformats').UnknownLink[]} [roots]
   * @param {QueuingStrategy<import('./api.js').Block>} [writableStrategy]
   * @param {QueuingStrategy<Uint8Array>} [readableStrategy]
   */ constructor(roots = [], writableStrategy, readableStrategy){
        super({
            start: (controller)=>controller.enqueue(encodeHeader(roots)),
            transform: (block, controller)=>controller.enqueue(encodeBlock(block))
        }, writableStrategy, readableStrategy);
    }
}
}),
"[project]/node_modules/carstream/src/index.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "code",
    ()=>code
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$carstream$2f$src$2f$reader$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/carstream/src/reader.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$carstream$2f$src$2f$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/carstream/src/writer.js [app-client] (ecmascript)");
;
;
const code = 0x0202;
}),
"[project]/node_modules/environment/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* globals WorkerGlobalScope, DedicatedWorkerGlobalScope, SharedWorkerGlobalScope, ServiceWorkerGlobalScope */ __turbopack_context__.s([
    "isAndroid",
    ()=>isAndroid,
    "isBrowser",
    ()=>isBrowser,
    "isBun",
    ()=>isBun,
    "isDedicatedWorker",
    ()=>isDedicatedWorker,
    "isDeno",
    ()=>isDeno,
    "isElectron",
    ()=>isElectron,
    "isIos",
    ()=>isIos,
    "isJsDom",
    ()=>isJsDom,
    "isLinux",
    ()=>isLinux,
    "isMacOs",
    ()=>isMacOs,
    "isNode",
    ()=>isNode,
    "isServiceWorker",
    ()=>isServiceWorker,
    "isSharedWorker",
    ()=>isSharedWorker,
    "isWebWorker",
    ()=>isWebWorker,
    "isWindows",
    ()=>isWindows
]);
const isBrowser = globalThis.window?.document !== undefined;
const isNode = globalThis.process?.versions?.node !== undefined;
const isBun = globalThis.process?.versions?.bun !== undefined;
const isDeno = globalThis.Deno?.version?.deno !== undefined;
const isElectron = globalThis.process?.versions?.electron !== undefined;
const isJsDom = globalThis.navigator?.userAgent?.includes('jsdom') === true;
const isWebWorker = typeof WorkerGlobalScope !== 'undefined' && globalThis instanceof WorkerGlobalScope;
const isDedicatedWorker = typeof DedicatedWorkerGlobalScope !== 'undefined' && globalThis instanceof DedicatedWorkerGlobalScope;
const isSharedWorker = typeof SharedWorkerGlobalScope !== 'undefined' && globalThis instanceof SharedWorkerGlobalScope;
const isServiceWorker = typeof ServiceWorkerGlobalScope !== 'undefined' && globalThis instanceof ServiceWorkerGlobalScope;
// Note: I'm intentionally not DRYing up the other variables to keep them "lazy".
const platform = globalThis.navigator?.userAgentData?.platform;
const isMacOs = platform === 'macOS' || globalThis.navigator?.platform === 'MacIntel' // Even on Apple silicon Macs.
 || globalThis.navigator?.userAgent?.includes(' Mac ') === true || globalThis.process?.platform === 'darwin';
const isWindows = platform === 'Windows' || globalThis.navigator?.platform === 'Win32' || globalThis.process?.platform === 'win32';
const isLinux = platform === 'Linux' || globalThis.navigator?.platform?.startsWith('Linux') === true || globalThis.navigator?.userAgent?.includes(' Linux ') === true || globalThis.process?.platform === 'linux';
const isIos = platform === 'iOS' || globalThis.navigator?.platform === 'MacIntel' && globalThis.navigator?.maxTouchPoints > 1 || /iPad|iPhone|iPod/.test(globalThis.navigator?.platform);
const isAndroid = platform === 'Android' || globalThis.navigator?.platform === 'Android' || globalThis.navigator?.userAgent?.includes(' Android ') === true || globalThis.process?.platform === 'android';
}),
]);

//# sourceMappingURL=node_modules_fec8e499._.js.map