(globalThis.TURBOPACK || (globalThis.TURBOPACK = [])).push([typeof document === "object" ? document.currentScript : undefined,
"[project]/node_modules/@ipld/dag-ucan/src/ucan.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
}),
"[project]/node_modules/@ipld/dag-ucan/src/utf8.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "decode",
    ()=>decode,
    "decoder",
    ()=>decoder,
    "encode",
    ()=>encode,
    "encoder",
    ()=>encoder
]);
const encoder = new TextEncoder();
const decoder = new TextDecoder();
const encode = (text)=>encoder.encode(text);
const decode = (bytes)=>decoder.decode(bytes);
}),
"[project]/node_modules/@ipld/dag-ucan/src/did.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BLS12381G1",
    ()=>BLS12381G1,
    "BLS12381G2",
    ()=>BLS12381G2,
    "DID_CORE",
    ()=>DID_CORE,
    "ED25519",
    ()=>ED25519,
    "P256",
    ()=>P256,
    "P384",
    ()=>P384,
    "P521",
    ()=>P521,
    "RSA",
    ()=>RSA,
    "SECP256K1",
    ()=>SECP256K1,
    "decode",
    ()=>decode,
    "encode",
    ()=>encode,
    "format",
    ()=>format,
    "from",
    ()=>from,
    "parse",
    ()=>parse
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$ucan$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/ucan.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/node_modules/multiformats/dist/src/bases/base58.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/node_modules/multiformats/dist/src/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/node_modules/multiformats/dist/src/varint.js [app-client] (ecmascript) <export * as varint>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/utf8.js [app-client] (ecmascript)");
;
;
;
;
const DID_PREFIX = "did:";
const DID_PREFIX_SIZE = DID_PREFIX.length;
const DID_KEY_PREFIX = `did:key:`;
const DID_KEY_PREFIX_SIZE = DID_KEY_PREFIX.length;
const ED25519 = 0xed;
const RSA = 0x1205;
const P256 = 0x1200;
const P384 = 0x1201;
const P521 = 0x1202;
const SECP256K1 = 0xe7;
const BLS12381G1 = 0xea;
const BLS12381G2 = 0xeb;
const DID_CORE = 0x0d1d;
const METHOD_OFFSET = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(DID_CORE);
const parse = (did)=>{
    if (!did.startsWith(DID_PREFIX)) {
        throw new RangeError(`Invalid DID "${did}", must start with 'did:'`);
    } else if (did.startsWith(DID_KEY_PREFIX)) {
        const key = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base58btc"].decode(did.slice(DID_KEY_PREFIX_SIZE));
        return decode(key);
    } else {
        const suffix = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"](did.slice(DID_PREFIX_SIZE));
        const bytes = new Uint8Array(suffix.byteLength + METHOD_OFFSET);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodeTo(DID_CORE, bytes);
        bytes.set(suffix, METHOD_OFFSET);
        return new DID(bytes);
    }
};
const format = (id)=>id.did();
const from = (principal)=>{
    if (principal instanceof DID) {
        return principal;
    } else if (principal instanceof Uint8Array) {
        return decode(principal);
    } else if (typeof principal === "string") {
        return parse(principal);
    } else {
        return parse(principal.did());
    }
};
const decode = (bytes)=>{
    const [code] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].decode(bytes);
    const { buffer, byteOffset, byteLength } = bytes;
    switch(code){
        case P256:
            if (bytes.length > 35) {
                throw new RangeError(`Only p256-pub compressed is supported.`);
            }
        case ED25519:
        case RSA:
        case P384:
        case P521:
        case BLS12381G1:
        case BLS12381G2:
        case SECP256K1:
            return new DIDKey(buffer, byteOffset, byteLength);
        case DID_CORE:
            return new DID(buffer, byteOffset, byteLength);
        default:
            throw new RangeError(`Unsupported DID encoding, unknown multicode 0x${code.toString(16)}.`);
    }
};
const encode = (principal)=>parse(principal.did());
/**
 * @template {UCAN.DID} ID
 * @implements {UCAN.PrincipalView<ID>}
 * @extends {Uint8Array}
 */ class DID extends Uint8Array {
    /**
   * @returns {ID}
   */ did() {
        const bytes = new Uint8Array(this.buffer, this.byteOffset + METHOD_OFFSET);
        return `did:${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](bytes)}`;
    }
    toJSON() {
        return this.did();
    }
}
/**
 * @implements {UCAN.PrincipalView<UCAN.DID<"key">>}
 * @extends {DID<UCAN.DID<"key">>}
 */ class DIDKey extends DID {
    /**
   * @return {`did:key:${string}`}
   */ did() {
        return `did:key:${__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base58$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base58btc"].encode(this)}`;
    }
}
}),
"[project]/node_modules/@ipld/dag-ucan/src/signature.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "BLS12381G1",
    ()=>BLS12381G1,
    "BLS12381G2",
    ()=>BLS12381G2,
    "EIP191",
    ()=>EIP191,
    "ES256",
    ()=>ES256,
    "ES256K",
    ()=>ES256K,
    "ES384",
    ()=>ES384,
    "ES512",
    ()=>ES512,
    "EdDSA",
    ()=>EdDSA,
    "NON_STANDARD",
    ()=>NON_STANDARD,
    "RS256",
    ()=>RS256,
    "Signature",
    ()=>Signature,
    "create",
    ()=>create,
    "createNamed",
    ()=>createNamed,
    "createNonStandard",
    ()=>createNonStandard,
    "decode",
    ()=>decode,
    "encode",
    ()=>encode,
    "format",
    ()=>format,
    "fromJSON",
    ()=>fromJSON,
    "nameCode",
    ()=>nameCode,
    "parse",
    ()=>parse,
    "toJSON",
    ()=>toJSON,
    "view",
    ()=>view
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$ucan$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/ucan.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/node_modules/multiformats/dist/src/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/node_modules/multiformats/dist/src/varint.js [app-client] (ecmascript) <export * as varint>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/node_modules/multiformats/dist/src/bases/base64.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/utf8.js [app-client] (ecmascript)");
;
;
;
;
const NON_STANDARD = 0xd000;
const ES256K = 0xd0e7;
const BLS12381G1 = 0xd0ea;
const BLS12381G2 = 0xd0eb;
const EdDSA = 0xd0ed;
const ES256 = 0xd01200;
const ES384 = 0xd01201;
const ES512 = 0xd01202;
const RS256 = 0xd01205;
const EIP191 = 0xd191;
/**
 * @param {number} code
 * @returns {string}
 */ const codeName = (code)=>{
    switch(code){
        case ES256K:
            return "ES256K";
        case BLS12381G1:
            return "BLS12381G1";
        case BLS12381G2:
            return "BLS12381G2";
        case EdDSA:
            return "EdDSA";
        case ES256:
            return "ES256";
        case ES384:
            return "ES384";
        case ES512:
            return "ES512";
        case RS256:
            return "RS256";
        case EIP191:
            return "EIP191";
        default:
            throw new RangeError(`Unknown signature algorithm code 0x${code.toString(16)}`);
    }
};
const nameCode = (name)=>{
    switch(name){
        case "ES256K":
            return ES256K;
        case "BLS12381G1":
            return BLS12381G1;
        case "BLS12381G2":
            return BLS12381G2;
        case "EdDSA":
            return EdDSA;
        case "ES256":
            return ES256;
        case "ES384":
            return ES384;
        case "ES512":
            return ES512;
        case "RS256":
            return RS256;
        case "EIP191":
            return EIP191;
        default:
            return NON_STANDARD;
    }
};
class Signature extends Uint8Array {
    get code() {
        const [code] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].decode(this);
        Object.defineProperties(this, {
            code: {
                value: code
            }
        });
        return code;
    }
    get size() {
        const value = size(this);
        Object.defineProperties(this, {
            size: {
                value
            }
        });
        return value;
    }
    get algorithm() {
        const value = algorithm(this);
        Object.defineProperties(this, {
            algorithm: {
                value
            }
        });
        return value;
    }
    get raw() {
        const { buffer, byteOffset, size, code } = this;
        const codeSize = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(code);
        const rawSize = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(size);
        const value = new Uint8Array(buffer, byteOffset + codeSize + rawSize, size);
        Object.defineProperties(this, {
            raw: {
                value
            }
        });
        return value;
    }
    /**
   * Verify that this signature was created by the given key.
   *
   * @param {UCAN.Crypto.Verifier<A>} signer
   * @param {UCAN.ByteView<T>} payload
   */ async verify(signer, payload) {
        try {
            if (await signer.verify(payload, this) === true) {
                return {
                    ok: {}
                };
            } else {
                throw new Error("Invalid signature");
            }
        } catch (cause) {
            return {
                error: cause
            };
        }
    }
    toJSON() {
        return toJSON(this);
    }
}
/**
 * @param {UCAN.Signature} signature
 */ const algorithm = (signature)=>{
    const { code, raw, buffer, byteOffset } = signature;
    if (code === NON_STANDARD) {
        const offset = raw.byteLength + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(code) + __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(raw.byteLength);
        const bytes = new Uint8Array(buffer, byteOffset + offset);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](bytes);
    } else {
        return codeName(code);
    }
};
/**
 * @param {UCAN.Signature} signature
 */ const size = (signature)=>{
    const offset = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(signature.code);
    const [size] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].decode(new Uint8Array(signature.buffer, signature.byteOffset + offset));
    return size;
};
const create = (code, raw)=>{
    const _ = codeName(code);
    const codeSize = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(code);
    const rawSize = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(raw.byteLength);
    /** @type {Signature<T, A>} */ const signature = new Signature(codeSize + rawSize + raw.byteLength);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodeTo(code, signature);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodeTo(raw.byteLength, signature, codeSize);
    signature.set(raw, codeSize + rawSize);
    Object.defineProperties(signature, {
        code: {
            value: code
        },
        size: {
            value: raw.byteLength
        }
    });
    return signature;
};
const createNamed = (name, raw)=>{
    const code = nameCode(name);
    return code === NON_STANDARD ? createNonStandard(name, raw) : create(code, raw);
};
const createNonStandard = (name, raw)=>{
    const code = NON_STANDARD;
    const codeSize = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(code);
    const rawSize = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodingLength(raw.byteLength);
    const nameBytes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"](name);
    /** @type {Signature<T, typeof NON_STANDARD>} */ const signature = new Signature(codeSize + rawSize + raw.byteLength + nameBytes.byteLength);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodeTo(code, signature);
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$varint$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__varint$3e$__["varint"].encodeTo(raw.byteLength, signature, codeSize);
    signature.set(raw, codeSize + rawSize);
    signature.set(nameBytes, codeSize + rawSize + raw.byteLength);
    return signature;
};
const view = (bytes)=>new Signature(bytes.buffer, bytes.byteOffset, bytes.byteLength);
const decode = (bytes)=>{
    if (!(bytes instanceof Uint8Array)) {
        throw new TypeError(`Can only decode Uint8Array into a Signature, instead got ${JSON.stringify(bytes)}`);
    }
    /** @type {UCAN.SignatureView<T, A>} */ const signature = view(bytes);
    const { code, algorithm, raw } = signature;
    return signature;
};
const encode = (signature)=>decode(signature);
const format = (signature, base)=>(base || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64url"]).encode(signature);
const parse = (signature, base)=>decode((base || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64url"]).decode(signature));
const toJSON = (signature)=>({
        "/": {
            bytes: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64"].baseEncode(signature)
        }
    });
const fromJSON = (json)=>decode(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64"].baseDecode(json["/"].bytes));
}),
"[project]/node_modules/@ipld/dag-ucan/src/schema.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "ParseError",
    ()=>ParseError,
    "asCapability",
    ()=>asCapability,
    "fail",
    ()=>fail,
    "readArray",
    ()=>readArray,
    "readBytes",
    ()=>readBytes,
    "readCapabilities",
    ()=>readCapabilities,
    "readCapability",
    ()=>readCapability,
    "readFact",
    ()=>readFact,
    "readInt",
    ()=>readInt,
    "readJWTPayload",
    ()=>readJWTPayload,
    "readLiteral",
    ()=>readLiteral,
    "readNullable",
    ()=>readNullable,
    "readOptional",
    ()=>readOptional,
    "readOptionalArray",
    ()=>readOptionalArray,
    "readPayload",
    ()=>readPayload,
    "readPrincipal",
    ()=>readPrincipal,
    "readProof",
    ()=>readProof,
    "readSignature",
    ()=>readSignature,
    "readString",
    ()=>readString,
    "readStringPrincipal",
    ()=>readStringPrincipal,
    "readStringProof",
    ()=>readStringProof,
    "readStruct",
    ()=>readStruct,
    "readVersion",
    ()=>readVersion,
    "throw",
    ()=>fail
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$ucan$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/ucan.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/utf8.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/node_modules/multiformats/dist/src/link.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$identity$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/node_modules/multiformats/dist/src/hashes/identity.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/did.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$codecs$2f$raw$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/node_modules/multiformats/dist/src/codecs/raw.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$signature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/signature.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
const readPayload = (data)=>readPayloadWith(data, {
        readPrincipal,
        readProof
    });
const readJWTPayload = (data)=>readPayloadWith(data, {
        readPrincipal: readStringPrincipal,
        readProof: readStringProof
    });
/**
 *
 * @template {UCAN.Capabilities} C
 * @param {Record<string, unknown>|UCAN.Payload<C>} data
 * @param {object} readers
 * @param {(source:unknown, context:string) => UCAN.Principal} readers.readPrincipal
 * @param {(source:unknown, context:string) => UCAN.Link} readers.readProof
 * @returns {UCAN.Payload<C>}
 */ const readPayloadWith = (data, { readPrincipal, readProof })=>({
        iss: readPrincipal(data.iss, "iss"),
        aud: readPrincipal(data.aud, "aud"),
        att: readCapabilities(data.att, "att"),
        prf: readOptionalArray(data.prf, readProof, "prf") || [],
        exp: readNullable(data.exp === Infinity ? null : data.exp, readInt, "exp"),
        nbf: readOptional(data.nbf, readInt, "nbf"),
        fct: readOptionalArray(data.fct, readFact, "fct") || [],
        nnc: readOptional(data.nnc, readString, "nnc")
    });
const readSignature = (source)=>{
    if (source instanceof Uint8Array) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$signature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](source);
    } else {
        throw new TypeError(`Can only decode Uint8Array into a Signature, instead got ${JSON.stringify(source)}`);
    }
};
const readInt = (input, name)=>Number.isInteger(input) ? input : ParseError.throw(`Expected ${name} to be integer, instead got ${JSON.stringify(input)}`);
const readCapability = (input, context)=>readStruct(input, asCapability, context);
const readCapabilities = (input, context)=>readArray(input, readCapability, context);
const asCapability = (input)=>/** @type {C} */ ({
        ...input,
        can: readAbility(input.can),
        with: readResource(input.with)
    });
/**
 * @param {unknown} input
 */ const readAbility = (input)=>typeof input !== "string" ? ParseError.throw(`Capability has invalid 'can: ${JSON.stringify(input)}', value must be a string`) : input.slice(1, -1).includes("/") ? input.toLocaleLowerCase() : input === "*" ? input : ParseError.throw(`Capability has invalid 'can: "${input}"', value must have at least one path segment`);
/**
 * @param {unknown} input
 */ const readResource = (input)=>typeof input !== "string" ? ParseError.throw(`Capability has invalid 'with: ${JSON.stringify(input)}', value must be a string`) : parseURL(input) || ParseError.throw(`Capability has invalid 'with: "${input}"', value must be a valid URI string`);
/**
 * @param {string} input
 */ const parseURL = (input)=>{
    try {
        new URL(input);
        return input;
    } catch (_) {
        return null;
    }
};
const readArray = (input, read, context)=>Array.isArray(input) ? input.map((element, n)=>read(element, `${context}[${n}]`)) : ParseError.throw(`${context} must be an array`);
const readOptionalArray = (input, reader, context)=>input === undefined ? input : readArray(input, reader, context);
const readStruct = (input, reader, context)=>input != null && typeof input === "object" ? reader(input) : ParseError.throw(`${context} must be of type object, instead got ${input}`);
const readFact = (input, context)=>readStruct(input, Object, context);
const readProof = (source, context)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isLink"](source) ? source : fail(`Expected ${context} to be IPLD link, instead got ${JSON.stringify(source)}`);
const readStringProof = (source, context)=>parseProof(readString(source, context));
/**
 * @param {string} source
 * @returns {UCAN.Link}
 */ const parseProof = (source)=>{
    // First we attempt to read proof as CID, if we fail fallback to reading it as
    // an inline proof.
    try {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["parse"](source);
    } catch (error) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["create"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$codecs$2f$raw$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["code"], __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$identity$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["identity"].digest(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"](source)));
    }
};
const readPrincipal = (input, context)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](readBytes(input, context));
const readStringPrincipal = (source, context)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parse"](readString(source, context));
const readOptional = (source, read, context = "Field")=>source !== undefined ? read(source, context) : undefined;
const readNullable = (source, read, context)=>source === null ? null : read(source, context);
const readString = (source, context = "Field")=>typeof source === "string" ? source : fail(`${context} has invalid value ${source}`);
const readBytes = (source, context)=>source instanceof Uint8Array ? source : fail(`Expected ${context} to be Uint8Array, instead got ${JSON.stringify(source)}`);
const readVersion = (input, context)=>/\d+\.\d+\.\d+/.test(input) ? input : ParseError.throw(`Invalid version '${context}: ${JSON.stringify(input)}'`);
const readLiteral = (input, literal, context)=>input === literal ? literal : ParseError.throw(`Expected ${context} to be a ${JSON.stringify(literal)} instead got ${JSON.stringify(input)}`);
class ParseError extends TypeError {
    get name() {
        return "ParseError";
    }
    /**
   * @param {string} message
   * @returns {never}
   */ static throw(message) {
        throw new this(message);
    }
}
const fail = (reason)=>ParseError.throw(reason);
;
}),
"[project]/node_modules/@ipld/dag-ucan/src/formatter.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "format",
    ()=>format,
    "formatHeader",
    ()=>formatHeader,
    "formatPayload",
    ()=>formatPayload,
    "formatSignPayload",
    ()=>formatSignPayload,
    "formatSignature",
    ()=>formatSignature
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$ucan$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/ucan.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/did.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$json$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-json/src/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/node_modules/multiformats/dist/src/bases/base64.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$signature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/signature.js [app-client] (ecmascript)");
;
;
;
;
;
const format = (model)=>{
    const header = formatHeader(model.v, model.s.algorithm);
    const payload = formatPayload(model);
    const signature = formatSignature(model.s);
    return `${header}.${payload}.${signature}`;
};
const formatSignPayload = (payload, version, alg)=>`${formatHeader(version, alg)}.${formatPayload(payload)}`;
const formatHeader = (version, alg)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64url"].baseEncode(encodeHeader(version, alg));
const formatPayload = (data)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64url"].baseEncode(encodePayload(data));
const formatSignature = (signature)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64url"].baseEncode(signature.raw);
/**
 * @param {UCAN.Version} v
 * @param {string} alg
 * @returns {UCAN.ByteView<UCAN.JWTHeader>}
 */ const encodeHeader = (v, alg)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$json$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"]({
        alg,
        ucv: v,
        typ: "JWT"
    });
/**
 * @template {UCAN.Capabilities} C
 * @param {UCAN.Payload<C>} data
 * @returns {UCAN.ByteView<UCAN.JWTPayload<C>>}
 */ const encodePayload = (data)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$json$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"]({
        iss: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["format"](data.iss),
        aud: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["format"](data.aud),
        att: data.att,
        exp: data.exp,
        prf: data.prf.map(encodeProof),
        // leave out optionals and empty fields
        ...data.fct.length > 0 && {
            fct: data.fct
        },
        ...data.nnc && {
            nnc: data.nnc
        },
        ...data.nbf && {
            nbf: data.nbf
        }
    });
/**
 * @param {UCAN.Link} proof
 * @returns {UCAN.ToString<UCAN.Link>}
 */ const encodeProof = (proof)=>proof.toString();
}),
"[project]/node_modules/@ipld/dag-ucan/src/view.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "View",
    ()=>View
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$ucan$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/ucan.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/did.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$json$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-json/src/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/utf8.js [app-client] (ecmascript)");
;
;
;
;
/**
 * @param {unknown} data
 */ const toJSON = (data)=>JSON.parse((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$json$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"])(data)));
class View {
    /**
   * @param {UCAN.UCAN<C>} model
   */ constructor(model){
        /** @readonly */ this.model = model;
    }
    get version() {
        return this.model.v;
    }
    get issuer() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"](this.model.iss);
    }
    get audience() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["from"](this.model.aud);
    }
    /**
   * @returns {C}
   */ get capabilities() {
        return this.model.att;
    }
    /**
   * @returns {number}
   */ get expiration() {
        const { exp } = this.model;
        return exp === null ? Infinity : exp;
    }
    /**
   * @returns {undefined|number}
   */ get notBefore() {
        return this.model.nbf;
    }
    /**
   * @returns {undefined|string}
   */ get nonce() {
        return this.model.nnc;
    }
    /**
   * @returns {UCAN.Fact[]}
   */ get facts() {
        return this.model.fct;
    }
    /**
   * @returns {UCAN.Link[]}
   */ get proofs() {
        return this.model.prf;
    }
    get signature() {
        return this.model.s;
    }
    // compatibility with UCAN.UCAN
    get jwt() {
        return this.model.jwt;
    }
    get s() {
        return this.model.s;
    }
    get v() {
        return this.model.v;
    }
    get iss() {
        return this.model.iss;
    }
    get aud() {
        return this.model.aud;
    }
    get att() {
        return this.model.att;
    }
    get exp() {
        return this.model.exp;
    }
    get nbf() {
        return this.model.nbf;
    }
    get nnc() {
        return this.model.nnc;
    }
    get fct() {
        return this.model.fct;
    }
    get prf() {
        return this.model.prf;
    }
    /**
   * @returns {UCAN.ToJSON<UCAN.UCAN<C>, UCAN.UCANJSON<this>>}
   */ toJSON() {
        const { v, iss, aud, s, att, prf, exp, fct, nnc, nbf } = this.model;
        return {
            iss,
            aud,
            v,
            s,
            exp,
            ...toJSON({
                att,
                prf,
                ...fct.length > 0 && {
                    fct
                }
            }),
            ...nnc != null && {
                nnc
            },
            ...nbf && {
                nbf
            }
        };
    }
}
}),
"[project]/node_modules/@ipld/dag-ucan/src/codec/cbor.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "code",
    ()=>code,
    "decode",
    ()=>decode,
    "encode",
    ()=>encode,
    "from",
    ()=>from,
    "name",
    ()=>name
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$ucan$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/ucan.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-cbor/src/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/schema.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$formatter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/formatter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$signature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/signature.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$view$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/view.js [app-client] (ecmascript)");
;
;
;
;
;
;
const name = "dag-ucan";
const code = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["code"];
const from = (model)=>new CBORView(model);
const encode = (model)=>{
    const { fct, nnc, nbf, ...payload } = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readPayload"])(model);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"]({
        // leave out optionals unless they are set
        ...fct.length > 0 && {
            fct
        },
        ...nnc != null && {
            nnc
        },
        ...nbf && {
            nbf
        },
        ...payload,
        // add version and signature
        v: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVersion"])(model.v, "v"),
        s: encodeSignature(model.s, "s")
    });
};
/**
 * @param {UCAN.Signature} signature
 * @param {string} context
 */ const encodeSignature = (signature, context)=>{
    try {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$signature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"](signature);
    } catch (cause) {
        throw new Error(`Expected signature ${context}, instead got ${JSON.stringify(signature)}`, // @ts-expect-error - types don't know about second arg
        {
            cause
        });
    }
};
const decode = (bytes)=>{
    const model = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](bytes);
    return new CBORView({
        ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readPayload"])(model),
        v: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVersion"])(model.v, "v"),
        s: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readSignature"])(model.s)
    });
};
;
/**
 * @template {UCAN.Capabilities} C
 * @extends {View<C>}
 */ class CBORView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$view$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["View"] {
    /** @type {UCAN.MulticodecCode<typeof code, "CBOR">} */ get code() {
        return code;
    }
    format() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$formatter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["format"])(this.model);
    }
    encode() {
        return encode(this.model);
    }
}
}),
"[project]/node_modules/@ipld/dag-ucan/src/parser.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "parse",
    ()=>parse,
    "parseHeader",
    ()=>parseHeader,
    "parsePayload",
    ()=>parsePayload
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$ucan$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/ucan.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$json$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-json/src/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/schema.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/node_modules/multiformats/dist/src/bases/base64.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$signature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/signature.js [app-client] (ecmascript)");
;
;
;
;
;
const parse = (jwt)=>{
    const segments = jwt.split(".");
    const [header, payload, signature] = segments.length === 3 ? segments : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["throw"](`Can't parse UCAN: ${jwt}: Expected JWT format: 3 dot-separated base64url-encoded values.`);
    const { ucv, alg } = parseHeader(header);
    return {
        ...parsePayload(payload),
        v: ucv,
        s: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$signature$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createNamed"])(alg, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64url"].baseDecode(signature))
    };
};
const parseHeader = (header)=>{
    const { ucv, alg, typ } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$json$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64url"].baseDecode(header));
    return {
        typ: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readLiteral"](typ, "JWT", "typ"),
        ucv: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readVersion"](ucv, "ucv"),
        alg: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readString"](alg, "alg")
    };
};
const parsePayload = (source)=>{
    /** @type {Record<string, unknown>} */ const payload = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$json$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64url"].baseDecode(source));
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readJWTPayload"](payload);
};
}),
"[project]/node_modules/@ipld/dag-ucan/src/codec/jwt.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "decode",
    ()=>decode,
    "encode",
    ()=>encode,
    "format",
    ()=>format,
    "from",
    ()=>from,
    "name",
    ()=>name
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$ucan$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/ucan.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/utf8.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/parser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$codecs$2f$raw$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/node_modules/multiformats/dist/src/codecs/raw.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$view$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/view.js [app-client] (ecmascript)");
;
;
;
;
;
;
const name = "dag-ucan";
const from = (model)=>new JWTView(model);
const decode = (bytes)=>{
    const jwt = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](bytes);
    return new JWTView({
        ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parse"])(jwt),
        jwt
    });
};
const encode = ({ jwt })=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"](jwt);
const format = ({ jwt })=>jwt;
/**
 * @template {UCAN.Capabilities} C
 * @extends {View<C>}
 */ class JWTView extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$view$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["View"] {
    /**
   * @param {UCAN.FromJWT<C>} model
   */ constructor(model){
        super(model);
        this.model = model;
    }
    /** @type {UCAN.MulticodecCode<typeof code, "Raw">} */ get code() {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$codecs$2f$raw$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["code"];
    }
    format() {
        return format(this.model);
    }
    encode() {
        return encode(this.model);
    }
}
}),
"[project]/node_modules/@ipld/dag-ucan/src/lib.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "VERSION",
    ()=>VERSION,
    "code",
    ()=>code,
    "decode",
    ()=>decode,
    "encode",
    ()=>encode,
    "format",
    ()=>format,
    "isExpired",
    ()=>isExpired,
    "isTooEarly",
    ()=>isTooEarly,
    "issue",
    ()=>issue,
    "link",
    ()=>link,
    "name",
    ()=>name,
    "now",
    ()=>now,
    "parse",
    ()=>parse,
    "verifySignature",
    ()=>verifySignature,
    "write",
    ()=>write
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$ucan$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/ucan.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$cbor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/codec/cbor.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$formatter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/formatter.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$jwt$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/codec/jwt.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$codecs$2f$raw$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/node_modules/multiformats/dist/src/codecs/raw.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/utf8.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/schema.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/did.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/src/parser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$sha2$2d$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/node_modules/multiformats/dist/src/hashes/sha2-browser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-ucan/node_modules/multiformats/dist/src/link.js [app-client] (ecmascript) <locals>");
;
;
;
;
;
;
;
;
;
;
;
;
const VERSION = "0.9.1";
const name = "dag-ucan";
const code = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$cbor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["code"];
/**
 * We cast sha256 to workaround typescripts limited inference problem when using
 * sha256 as default. If hasher is omitted type `A` should match sha256.code
 * but TS fails to deduce that.
 * @type {UCAN.MultihashHasher<any>}
 */ const defaultHasher = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$sha2$2d$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["sha256"];
const encode = (ucan)=>ucan.jwt ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$jwt$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encode"](ucan) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$cbor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encode"](ucan);
const decode = (bytes)=>{
    try {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$cbor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["decode"](bytes);
    } catch (_) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$jwt$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["decode"](bytes);
    }
};
const link = async (ucan, options)=>{
    const { cid } = await write(ucan, options);
    return cid;
};
const write = async (ucan, { hasher = defaultHasher } = {})=>{
    const [code, bytes] = ucan.jwt ? [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$codecs$2f$raw$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["code"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$jwt$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encode"](ucan)
    ] : [
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$cbor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["code"],
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$cbor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["encode"](ucan)
    ];
    const digest = await hasher.digest(bytes);
    return {
        bytes,
        cid: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$link$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["create"])(code, digest),
        data: ucan
    };
};
const parse = (jwt)=>{
    const model = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$parser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parse"])(jwt);
    // If formatting UCAN produces same jwt string we can use IPLD representation
    // otherwise we need to fallback to raw representation. This decision will
    // affect how we `encode` the UCAN.
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$formatter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["format"](model) === jwt ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$cbor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["from"](model) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$jwt$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["from"]({
        ...model,
        jwt: jwt
    });
};
const format = (ucan)=>ucan.jwt ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$jwt$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["format"](ucan) : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$formatter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["format"](ucan);
const issue = async ({ issuer, audience, capabilities, lifetimeInSeconds = 30, expiration = now() + lifetimeInSeconds, notBefore, facts = [], proofs = [], nonce })=>{
    const v = VERSION;
    const data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$schema$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readPayload"])({
        iss: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parse"])(issuer.did()),
        aud: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["parse"])(audience.did()),
        att: capabilities,
        fct: facts,
        exp: expiration,
        nbf: notBefore,
        prf: proofs,
        nnc: nonce
    });
    const payload = encodeSignaturePayload(data, v, issuer.signatureAlgorithm);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$codec$2f$cbor$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["from"]({
        ...data,
        v,
        s: await issuer.sign(payload)
    });
};
/**
 *
 * @param {UCAN.Payload} payload
 * @param {UCAN.Version} version
 * @param {string} algorithm
 * @returns
 */ const encodeSignaturePayload = (payload, version, algorithm)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$utf8$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"]((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$formatter$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["formatSignPayload"])(payload, version, algorithm));
const verifySignature = (ucan, verifier)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$ucan$2f$src$2f$did$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["format"])(ucan.issuer) === verifier.did() && verifier.verify(encodeSignaturePayload(ucan.model, ucan.model.v, ucan.signature.algorithm), ucan.signature);
const isExpired = (ucan)=>ucan.expiration <= now();
const isTooEarly = (ucan)=>ucan.notBefore != null && now() <= ucan.notBefore;
const now = ()=>Math.floor(Date.now() / 1000);
}),
"[project]/node_modules/@ipld/dag-cbor/src/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "code",
    ()=>code,
    "decode",
    ()=>decode,
    "decodeOptions",
    ()=>decodeOptions,
    "encode",
    ()=>encode,
    "encodeOptions",
    ()=>encodeOptions,
    "name",
    ()=>name,
    "toByteView",
    ()=>toByteView
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$cborg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/cborg/cborg.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$encode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cborg/lib/encode.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$decode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cborg/lib/decode.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cborg/lib/token.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-cbor/node_modules/multiformats/dist/src/cid.js [app-client] (ecmascript) <locals>");
;
;
// https://github.com/ipfs/go-ipfs/issues/3570#issuecomment-273931692
const CID_CBOR_TAG = 42;
function toByteView(buf) {
    if (buf instanceof ArrayBuffer) {
        return new Uint8Array(buf, 0, buf.byteLength);
    }
    return buf;
}
/**
 * cidEncoder will receive all Objects during encode, it needs to filter out
 * anything that's not a CID and return `null` for that so it's encoded as
 * normal.
 *
 * @param {any} obj
 * @returns {cborg.Token[]|null}
 */ function cidEncoder(obj) {
    if (obj.asCID !== obj && obj['/'] !== obj.bytes) {
        return null // any other kind of object
        ;
    }
    const cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].asCID(obj);
    /* c8 ignore next 4 */ // very unlikely case, and it'll probably throw a recursion error in cborg
    if (!cid) {
        return null;
    }
    const bytes = new Uint8Array(cid.bytes.byteLength + 1);
    bytes.set(cid.bytes, 1); // prefix is 0x00, for historical reasons
    return [
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].tag, CID_CBOR_TAG),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].bytes, bytes)
    ];
}
// eslint-disable-next-line jsdoc/require-returns-check
/**
 * Intercept all `undefined` values from an object walk and reject the entire
 * object if we find one.
 *
 * @returns {null}
 */ function undefinedEncoder() {
    throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded');
}
/**
 * Intercept all `number` values from an object walk and reject the entire
 * object if we find something that doesn't fit the IPLD data model (NaN &
 * Infinity).
 *
 * @param {number} num
 * @returns {null}
 */ function numberEncoder(num) {
    if (Number.isNaN(num)) {
        throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded');
    }
    if (num === Infinity || num === -Infinity) {
        throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded');
    }
    return null;
}
/**
 * @param {Map<any, any>} map
 * @returns {null}
 */ function mapEncoder(map) {
    for (const key of map.keys()){
        if (typeof key !== 'string' || key.length === 0) {
            throw new Error('Non-string Map keys are not supported by the IPLD Data Model and cannot be encoded');
        }
    }
    return null;
}
const _encodeOptions = {
    float64: true,
    typeEncoders: {
        Map: mapEncoder,
        Object: cidEncoder,
        undefined: undefinedEncoder,
        number: numberEncoder
    }
};
const encodeOptions = {
    ..._encodeOptions,
    typeEncoders: {
        ..._encodeOptions.typeEncoders
    }
};
/**
 * @param {Uint8Array} bytes
 * @returns {CID}
 */ function cidDecoder(bytes) {
    if (bytes[0] !== 0) {
        throw new Error('Invalid CID for CBOR tag 42; expected leading 0x00');
    }
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].decode(bytes.subarray(1)) // ignore leading 0x00
    ;
}
const _decodeOptions = {
    allowIndefinite: false,
    coerceUndefinedToNull: true,
    allowNaN: false,
    allowInfinity: false,
    allowBigInt: true,
    // safe-integer range, which may surprise users
    strict: true,
    useMaps: false,
    rejectDuplicateMapKeys: true,
    /** @type {import('cborg').TagDecoder[]} */ tags: []
};
_decodeOptions.tags[CID_CBOR_TAG] = cidDecoder;
const decodeOptions = {
    ..._decodeOptions,
    tags: _decodeOptions.tags.slice()
};
const name = 'dag-cbor';
const code = 0x71;
const encode = (node)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$encode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"](node, _encodeOptions);
const decode = (data)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$decode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](toByteView(data), _decodeOptions);
}),
"[project]/node_modules/@ipld/dag-json/src/index.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* eslint max-depth: ["error", 7] */ __turbopack_context__.s([
    "code",
    ()=>code,
    "decode",
    ()=>decode,
    "encode",
    ()=>encode,
    "format",
    ()=>format,
    "name",
    ()=>name,
    "parse",
    ()=>parse,
    "stringify",
    ()=>format
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$cborg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/cborg/cborg.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cborg/lib/token.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$json$2f$json$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/cborg/lib/json/json.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$json$2f$decode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cborg/lib/json/decode.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$json$2f$encode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cborg/lib/json/encode.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$json$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-json/node_modules/multiformats/dist/src/index.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$json$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-json/node_modules/multiformats/dist/src/cid.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$json$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-json/node_modules/multiformats/dist/src/bases/base64.js [app-client] (ecmascript)");
;
;
;
;
/**
 * @template T
 * @typedef {import('multiformats/codecs/interface').ByteView<T>} ByteView
 */ /**
 * @template T
 * @typedef {import('multiformats/codecs/interface').ArrayBufferView<T>} ArrayBufferView
 */ /**
 * @template T
 * @typedef {import('multiformats').ToString<T>} ToString
 */ /**
 * @typedef {import('cborg/interface').DecodeTokenizer} DecodeTokenizer
 */ /**
 * @template T
 * @param {ByteView<T> | ArrayBufferView<T>} buf
 * @returns {ByteView<T>}
 */ function toByteView(buf) {
    if (buf instanceof ArrayBuffer) {
        return new Uint8Array(buf, 0, buf.byteLength);
    }
    return buf;
}
/**
 * cidEncoder will receive all Objects during encode, it needs to filter out
 * anything that's not a CID and return `null` for that so it's encoded as
 * normal. Encoding a CID means replacing it with a `{"/":"<CidString>}`
 * object as per the DAG-JSON spec.
 *
 * @param {any} obj
 * @returns {Token[]|null}
 */ function cidEncoder(obj) {
    if (obj.asCID !== obj && obj['/'] !== obj.bytes) {
        return null // any other kind of object
        ;
    }
    const cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$json$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].asCID(obj);
    /* c8 ignore next 4 */ // very unlikely case, and it'll probably throw a recursion error in cborg
    if (!cid) {
        return null;
    }
    const cidString = cid.toString();
    return [
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].map, Infinity, 1),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].string, '/', 1),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].string, cidString, cidString.length),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].break, undefined, 1)
    ];
}
/**
 * bytesEncoder will receive all Uint8Arrays (and friends) during encode, it
 * needs to replace it with a `{"/":{"bytes":"Base64ByteString"}}` object as
 * per the DAG-JSON spec.
 *
 * @param {Uint8Array} bytes
 * @returns {Token[]|null}
 */ function bytesEncoder(bytes) {
    const bytesString = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$json$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64"].encode(bytes).slice(1) // no mbase prefix
    ;
    return [
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].map, Infinity, 1),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].string, '/', 1),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].map, Infinity, 1),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].string, 'bytes', 5),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].string, bytesString, bytesString.length),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].break, undefined, 1),
        new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].break, undefined, 1)
    ];
}
/**
 * taBytesEncoder wraps bytesEncoder() but for the more exotic typed arrays so
 * that we access the underlying ArrayBuffer data
 *
 * @param {Int8Array|Uint16Array|Int16Array|Uint32Array|Int32Array|Float32Array|Float64Array|Uint8ClampedArray|BigInt64Array|BigUint64Array} obj
 * @returns {Token[]|null}
 */ function taBytesEncoder(obj) {
    return bytesEncoder(new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
}
/**
 * abBytesEncoder wraps bytesEncoder() but for plain ArrayBuffers
 *
 * @param {ArrayBuffer} ab
 * @returns {Token[]|null}
 */ function abBytesEncoder(ab) {
    return bytesEncoder(new Uint8Array(ab));
}
// eslint-disable-next-line jsdoc/require-returns-check
/**
 * Intercept all `undefined` values from an object walk and reject the entire
 * object if we find one.
 *
 * @returns {null}
 */ function undefinedEncoder() {
    throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded');
}
/**
 * Intercept all `number` values from an object walk and reject the entire
 * object if we find something that doesn't fit the IPLD data model (NaN &
 * Infinity).
 *
 * @param {number} num
 * @returns {null}
 */ function numberEncoder(num) {
    if (Number.isNaN(num)) {
        throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded');
    }
    if (num === Infinity || num === -Infinity) {
        throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded');
    }
    return null // process with standard number encoder
    ;
}
const encodeOptions = {
    typeEncoders: {
        Object: cidEncoder,
        Buffer: bytesEncoder,
        Uint8Array: bytesEncoder,
        Int8Array: taBytesEncoder,
        Uint16Array: taBytesEncoder,
        Int16Array: taBytesEncoder,
        Uint32Array: taBytesEncoder,
        Int32Array: taBytesEncoder,
        Float32Array: taBytesEncoder,
        Float64Array: taBytesEncoder,
        Uint8ClampedArray: taBytesEncoder,
        BigInt64Array: taBytesEncoder,
        BigUint64Array: taBytesEncoder,
        DataView: taBytesEncoder,
        ArrayBuffer: abBytesEncoder,
        undefined: undefinedEncoder,
        number: numberEncoder
    }
};
/**
 * @implements {DecodeTokenizer}
 */ class DagJsonTokenizer extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$json$2f$decode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Tokenizer"] {
    /**
   * @param {Uint8Array} data
   * @param {object} [options]
   */ constructor(data, options){
        super(data, options);
        /** @type {Token[]} */ this.tokenBuffer = [];
    }
    /**
   * @returns {boolean}
   */ done() {
        return this.tokenBuffer.length === 0 && super.done();
    }
    /**
   * @returns {Token}
   */ _next() {
        if (this.tokenBuffer.length > 0) {
            // @ts-ignore https://github.com/Microsoft/TypeScript/issues/30406
            return this.tokenBuffer.pop();
        }
        return super.next();
    }
    /**
   * Implements rules outlined in https://github.com/ipld/specs/pull/356
   *
   * @returns {Token}
   */ next() {
        const token = this._next();
        if (token.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].map) {
            const keyToken = this._next();
            if (keyToken.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].string && keyToken.value === '/') {
                const valueToken = this._next();
                if (valueToken.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].string) {
                    const breakToken = this._next() // swallow the end-of-map token
                    ;
                    if (breakToken.type !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].break) {
                        throw new Error('Invalid encoded CID form');
                    }
                    this.tokenBuffer.push(valueToken); // CID.parse will pick this up after our tag token
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].tag, 42, 0);
                }
                if (valueToken.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].map) {
                    const innerKeyToken = this._next();
                    if (innerKeyToken.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].string && innerKeyToken.value === 'bytes') {
                        const innerValueToken = this._next();
                        if (innerValueToken.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].string) {
                            for(let i = 0; i < 2; i++){
                                const breakToken = this._next() // swallow two end-of-map tokens
                                ;
                                if (breakToken.type !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].break) {
                                    throw new Error('Invalid encoded Bytes form');
                                }
                            }
                            const bytes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$json$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$bases$2f$base64$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["base64"].decode(`m${innerValueToken.value}`);
                            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].bytes, bytes, innerValueToken.value.length);
                        }
                        this.tokenBuffer.push(innerValueToken); // bail
                    }
                    this.tokenBuffer.push(innerKeyToken); // bail
                }
                this.tokenBuffer.push(valueToken); // bail
            }
            this.tokenBuffer.push(keyToken); // bail
        }
        return token;
    }
}
const decodeOptions = {
    allowIndefinite: false,
    allowUndefined: false,
    allowNaN: false,
    allowInfinity: false,
    allowBigInt: true,
    // safe-integer range, which may surprise users
    strict: true,
    useMaps: false,
    rejectDuplicateMapKeys: true,
    /** @type {import('cborg').TagDecoder[]} */ tags: []
};
// we're going to get TAG(42)STRING("bafy...") from the tokenizer so we only need
// to deal with the STRING("bafy...") at this point
decodeOptions.tags[42] = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$json$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].parse;
const name = 'dag-json';
const code = 0x0129;
const encode = (node)=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$json$2f$encode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"](node, encodeOptions);
const decode = (data)=>{
    const buf = toByteView(data);
    // the tokenizer is stateful so we need a single instance of it
    const options = Object.assign(decodeOptions, {
        tokenizer: new DagJsonTokenizer(buf, decodeOptions)
    });
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$json$2f$decode$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](buf, options);
};
const format = (node)=>utf8Decoder.decode(encode(node));
;
const utf8Decoder = new TextDecoder();
const parse = (data)=>decode(utf8Encoder.encode(data));
const utf8Encoder = new TextEncoder();
}),
"[project]/node_modules/@ipld/car/src/decoder-common.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CIDV0_BYTES",
    ()=>CIDV0_BYTES,
    "V2_HEADER_LENGTH",
    ()=>V2_HEADER_LENGTH,
    "decodeV2Header",
    ()=>decodeV2Header,
    "decodeVarint",
    ()=>decodeVarint,
    "getMultihashLength",
    ()=>getMultihashLength
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/varint/index.js [app-client] (ecmascript)");
;
const CIDV0_BYTES = {
    SHA2_256: 0x12,
    LENGTH: 0x20,
    DAG_PB: 0x70
};
const V2_HEADER_LENGTH = /* characteristics */ 16 /* v1 offset */  + 8 /* v1 size */  + 8 /* index offset */  + 8;
function decodeVarint(bytes, seeker) {
    if (!bytes.length) {
        throw new Error('Unexpected end of data');
    }
    const i = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].decode(bytes);
    seeker.seek(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].decode.bytes);
    return i;
}
function decodeV2Header(bytes) {
    const dv = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
    let offset = 0;
    const header = {
        version: 2,
        /** @type {[bigint, bigint]} */ characteristics: [
            dv.getBigUint64(offset, true),
            dv.getBigUint64(offset += 8, true)
        ],
        dataOffset: Number(dv.getBigUint64(offset += 8, true)),
        dataSize: Number(dv.getBigUint64(offset += 8, true)),
        indexOffset: Number(dv.getBigUint64(offset += 8, true))
    };
    return header;
}
function getMultihashLength(bytes) {
    // | code | length | .... |
    // where both code and length are varints, so we have to decode
    // them first before we can know total length
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].decode(bytes); // code
    const codeLength = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].decode.bytes;
    const length = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].decode(bytes.subarray(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].decode.bytes));
    const lengthLength = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].decode.bytes;
    const mhLength = codeLength + lengthLength + length;
    return mhLength;
}
}),
"[project]/node_modules/@ipld/car/src/header-validator.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/* eslint-disable jsdoc/check-indentation, max-depth */ /**
 * Auto-generated with @ipld/schema@v4.2.0 at Thu Sep 14 2023 from IPLD Schema:
 *
 * # CarV1HeaderOrV2Pragma is a more relaxed form, and can parse {version:x} where
 * # roots are optional. This is typically useful for the {verison:2} CARv2
 * # pragma.
 *
 * type CarV1HeaderOrV2Pragma struct {
 *   roots optional [&Any]
 *   # roots is _not_ optional for CarV1 but we defer that check within code to
 *   # gracefully handle the V2 case where it's just {version:X}
 *   version Int
 * }
 *
 * # CarV1Header is the strict form of the header, and requires roots to be
 * # present. This is compatible with the CARv1 specification.
 *
 * # type CarV1Header struct {
 * #   roots [&Any]
 * #   version Int
 * # }
 *
 */ __turbopack_context__.s([
    "CarV1HeaderOrV2Pragma",
    ()=>CarV1HeaderOrV2Pragma
]);
const Kinds = {
    Null: /**
         * @param obj
         * @returns {undefined|null}
         */ (/** @type {any} */ obj)=>obj === null ? obj : undefined,
    Int: /**
        * @param obj
        * @returns {undefined|number}
        */ (/** @type {any} */ obj)=>Number.isInteger(obj) ? obj : undefined,
    Float: /**
          * @param obj
          * @returns {undefined|number}
          */ (/** @type {any} */ obj)=>typeof obj === 'number' && Number.isFinite(obj) ? obj : undefined,
    String: /**
           * @param obj
           * @returns {undefined|string}
           */ (/** @type {any} */ obj)=>typeof obj === 'string' ? obj : undefined,
    Bool: /**
         * @param obj
         * @returns {undefined|boolean}
         */ (/** @type {any} */ obj)=>typeof obj === 'boolean' ? obj : undefined,
    Bytes: /**
          * @param obj
          * @returns {undefined|Uint8Array}
          */ (/** @type {any} */ obj)=>obj instanceof Uint8Array ? obj : undefined,
    Link: /**
         * @param obj
         * @returns {undefined|object}
         */ (/** @type {any} */ obj)=>obj !== null && typeof obj === 'object' && obj.asCID === obj ? obj : undefined,
    List: /**
         * @param obj
         * @returns {undefined|Array<any>}
         */ (/** @type {any} */ obj)=>Array.isArray(obj) ? obj : undefined,
    Map: /**
        * @param obj
        * @returns {undefined|object}
        */ (/** @type {any} */ obj)=>obj !== null && typeof obj === 'object' && obj.asCID !== obj && !Array.isArray(obj) && !(obj instanceof Uint8Array) ? obj : undefined
};
/** @type {{ [k in string]: (obj:any)=>undefined|any}} */ const Types = {
    'CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)': Kinds.Link,
    'CarV1HeaderOrV2Pragma > roots (anon)': /**
                                           * @param obj
                                           * @returns {undefined|any}
                                           */ (/** @type {any} */ obj)=>{
        if (Kinds.List(obj) === undefined) {
            return undefined;
        }
        for(let i = 0; i < obj.length; i++){
            let v = obj[i];
            v = Types['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v);
            if (v === undefined) {
                return undefined;
            }
            if (v !== obj[i]) {
                const ret = obj.slice(0, i);
                for(let j = i; j < obj.length; j++){
                    let v = obj[j];
                    v = Types['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v);
                    if (v === undefined) {
                        return undefined;
                    }
                    ret.push(v);
                }
                return ret;
            }
        }
        return obj;
    },
    Int: Kinds.Int,
    CarV1HeaderOrV2Pragma: /**
                          * @param obj
                          * @returns {undefined|any}
                          */ (/** @type {any} */ obj)=>{
        if (Kinds.Map(obj) === undefined) {
            return undefined;
        }
        const entries = Object.entries(obj);
        /** @type {{[k in string]: any}} */ let ret = obj;
        let requiredCount = 1;
        for(let i = 0; i < entries.length; i++){
            const [key, value] = entries[i];
            switch(key){
                case 'roots':
                    {
                        const v = Types['CarV1HeaderOrV2Pragma > roots (anon)'](obj[key]);
                        if (v === undefined) {
                            return undefined;
                        }
                        if (v !== value || ret !== obj) {
                            if (ret === obj) {
                                /** @type {{[k in string]: any}} */ ret = {};
                                for(let j = 0; j < i; j++){
                                    ret[entries[j][0]] = entries[j][1];
                                }
                            }
                            ret.roots = v;
                        }
                    }
                    break;
                case 'version':
                    {
                        requiredCount--;
                        const v = Types.Int(obj[key]);
                        if (v === undefined) {
                            return undefined;
                        }
                        if (v !== value || ret !== obj) {
                            if (ret === obj) {
                                /** @type {{[k in string]: any}} */ ret = {};
                                for(let j = 0; j < i; j++){
                                    ret[entries[j][0]] = entries[j][1];
                                }
                            }
                            ret.version = v;
                        }
                    }
                    break;
                default:
                    return undefined;
            }
        }
        if (requiredCount > 0) {
            return undefined;
        }
        return ret;
    }
};
/** @type {{ [k in string]: (obj:any)=>undefined|any}} */ const Reprs = {
    'CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)': Kinds.Link,
    'CarV1HeaderOrV2Pragma > roots (anon)': /**
                                           * @param obj
                                           * @returns {undefined|any}
                                           */ (/** @type {any} */ obj)=>{
        if (Kinds.List(obj) === undefined) {
            return undefined;
        }
        for(let i = 0; i < obj.length; i++){
            let v = obj[i];
            v = Reprs['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v);
            if (v === undefined) {
                return undefined;
            }
            if (v !== obj[i]) {
                const ret = obj.slice(0, i);
                for(let j = i; j < obj.length; j++){
                    let v = obj[j];
                    v = Reprs['CarV1HeaderOrV2Pragma > roots (anon) > valueType (anon)'](v);
                    if (v === undefined) {
                        return undefined;
                    }
                    ret.push(v);
                }
                return ret;
            }
        }
        return obj;
    },
    Int: Kinds.Int,
    CarV1HeaderOrV2Pragma: /**
                          * @param obj
                          * @returns {undefined|any}
                          */ (/** @type {any} */ obj)=>{
        if (Kinds.Map(obj) === undefined) {
            return undefined;
        }
        const entries = Object.entries(obj);
        /** @type {{[k in string]: any}} */ let ret = obj;
        let requiredCount = 1;
        for(let i = 0; i < entries.length; i++){
            const [key, value] = entries[i];
            switch(key){
                case 'roots':
                    {
                        const v = Reprs['CarV1HeaderOrV2Pragma > roots (anon)'](value);
                        if (v === undefined) {
                            return undefined;
                        }
                        if (v !== value || ret !== obj) {
                            if (ret === obj) {
                                /** @type {{[k in string]: any}} */ ret = {};
                                for(let j = 0; j < i; j++){
                                    ret[entries[j][0]] = entries[j][1];
                                }
                            }
                            ret.roots = v;
                        }
                    }
                    break;
                case 'version':
                    {
                        requiredCount--;
                        const v = Reprs.Int(value);
                        if (v === undefined) {
                            return undefined;
                        }
                        if (v !== value || ret !== obj) {
                            if (ret === obj) {
                                /** @type {{[k in string]: any}} */ ret = {};
                                for(let j = 0; j < i; j++){
                                    ret[entries[j][0]] = entries[j][1];
                                }
                            }
                            ret.version = v;
                        }
                    }
                    break;
                default:
                    return undefined;
            }
        }
        if (requiredCount > 0) {
            return undefined;
        }
        return ret;
    }
};
const CarV1HeaderOrV2Pragma = {
    toTyped: Types.CarV1HeaderOrV2Pragma,
    toRepresentation: Reprs.CarV1HeaderOrV2Pragma
};
}),
"[project]/node_modules/@ipld/car/src/buffer-decoder.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "bytesReader",
    ()=>bytesReader,
    "fromBytes",
    ()=>fromBytes,
    "limitReader",
    ()=>limitReader,
    "readBlockHead",
    ()=>readBlockHead,
    "readHeader",
    ()=>readHeader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-cbor/src/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/node_modules/multiformats/dist/src/cid.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/node_modules/multiformats/dist/src/hashes/digest.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/decoder-common.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$header$2d$validator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/header-validator.js [app-client] (ecmascript)");
;
;
;
;
;
function readHeader(reader, strictVersion) {
    const length = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeVarint"])(reader.upTo(8), reader);
    if (length === 0) {
        throw new Error('Invalid CAR header (zero length)');
    }
    const header = reader.exactly(length, true);
    const block = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])(header);
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$header$2d$validator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CarV1HeaderOrV2Pragma"].toTyped(block) === undefined) {
        throw new Error('Invalid CAR header format');
    }
    if (block.version !== 1 && block.version !== 2 || strictVersion !== undefined && block.version !== strictVersion) {
        throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== undefined ? ` (expected ${strictVersion})` : ''}`);
    }
    if (block.version === 1) {
        // CarV1HeaderOrV2Pragma makes roots optional, let's make it mandatory
        if (!Array.isArray(block.roots)) {
            throw new Error('Invalid CAR header format');
        }
        return block;
    }
    // version 2
    if (block.roots !== undefined) {
        throw new Error('Invalid CAR header format');
    }
    const v2Header = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeV2Header"])(reader.exactly(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["V2_HEADER_LENGTH"], true));
    reader.seek(v2Header.dataOffset - reader.pos);
    const v1Header = readHeader(reader, 1);
    return Object.assign(v1Header, v2Header);
}
/**
 * Reads CID sync
 *
 * @param {BytesBufferReader} reader
 * @returns {CID}
 */ function readCid(reader) {
    const first = reader.exactly(2, false);
    if (first[0] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CIDV0_BYTES"].SHA2_256 && first[1] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CIDV0_BYTES"].LENGTH) {
        // cidv0 32-byte sha2-256
        const bytes = reader.exactly(34, true);
        const multihash = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](bytes);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].create(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CIDV0_BYTES"].DAG_PB, multihash);
    }
    const version = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeVarint"])(reader.upTo(8), reader);
    if (version !== 1) {
        throw new Error(`Unexpected CID version (${version})`);
    }
    const codec = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeVarint"])(reader.upTo(8), reader);
    const bytes = reader.exactly((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getMultihashLength"])(reader.upTo(8)), true);
    const multihash = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](bytes);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].create(version, codec, multihash);
}
function readBlockHead(reader) {
    // length includes a CID + Binary, where CID has a variable length
    // we have to deal with
    const start = reader.pos;
    let length = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeVarint"])(reader.upTo(8), reader);
    if (length === 0) {
        throw new Error('Invalid CAR section (zero length)');
    }
    length += reader.pos - start;
    const cid = readCid(reader);
    const blockLength = length - Number(reader.pos - start) // subtract CID length
    ;
    return {
        cid,
        length,
        blockLength
    };
}
function fromBytes(bytes) {
    let reader = bytesReader(bytes);
    const header = readHeader(reader);
    if (header.version === 2) {
        const v1length = reader.pos - header.dataOffset;
        reader = limitReader(reader, header.dataSize - v1length);
    }
    const blocks = [];
    while(reader.upTo(8).length > 0){
        const { cid, blockLength } = readBlockHead(reader);
        blocks.push({
            cid,
            bytes: reader.exactly(blockLength, true)
        });
    }
    return {
        header,
        blocks
    };
}
function bytesReader(bytes) {
    let pos = 0;
    /** @type {BytesBufferReader} */ return {
        upTo (length) {
            return bytes.subarray(pos, pos + Math.min(length, bytes.length - pos));
        },
        exactly (length, seek = false) {
            if (length > bytes.length - pos) {
                throw new Error('Unexpected end of data');
            }
            const out = bytes.subarray(pos, pos + length);
            if (seek) {
                pos += length;
            }
            return out;
        },
        seek (length) {
            pos += length;
        },
        get pos () {
            return pos;
        }
    };
}
function limitReader(reader, byteLimit) {
    let bytesRead = 0;
    /** @type {BytesBufferReader} */ return {
        upTo (length) {
            let bytes = reader.upTo(length);
            if (bytes.length + bytesRead > byteLimit) {
                bytes = bytes.subarray(0, byteLimit - bytesRead);
            }
            return bytes;
        },
        exactly (length, seek = false) {
            const bytes = reader.exactly(length, seek);
            if (bytes.length + bytesRead > byteLimit) {
                throw new Error('Unexpected end of data');
            }
            if (seek) {
                bytesRead += length;
            }
            return bytes;
        },
        seek (length) {
            bytesRead += length;
            reader.seek(length);
        },
        get pos () {
            return reader.pos;
        }
    };
}
}),
"[project]/node_modules/@ipld/car/src/buffer-reader-browser.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CarBufferReader",
    ()=>CarBufferReader,
    "__browser",
    ()=>__browser
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$buffer$2d$decoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/buffer-decoder.js [app-client] (ecmascript)");
;
class CarBufferReader {
    /**
   * @constructs CarBufferReader
   * @param {CarHeader|CarV2Header} header
   * @param {Block[]} blocks
   */ constructor(header, blocks){
        this._header = header;
        this._blocks = blocks;
        this._cids = undefined;
    }
    /**
   * @property {number} version of the CAR
   * @memberof CarBufferReader
   * @instance
   */ get version() {
        return this._header.version;
    }
    /**
   * Get the list of roots defined by the CAR referenced by this reader. May be
   * zero or more `CID`s.
   *
   * @function
   * @memberof CarBufferReader
   * @instance
   * @returns {CID[]}
   */ getRoots() {
        return this._header.roots;
    }
    /**
   * Check whether a given `CID` exists within the CAR referenced by this
   * reader.
   *
   * @function
   * @memberof CarBufferReader
   * @instance
   * @param {CID} key
   * @returns {boolean}
   */ has(key) {
        return this._blocks.some((b)=>b.cid.equals(key));
    }
    /**
   * Fetch a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) from the CAR
   * referenced by this reader matching the provided `CID`. In the case where
   * the provided `CID` doesn't exist within the CAR, `undefined` will be
   * returned.
   *
   * @function
   * @memberof CarBufferReader
   * @instance
   * @param {CID} key
   * @returns {Block | undefined}
   */ get(key) {
        return this._blocks.find((b)=>b.cid.equals(key));
    }
    /**
   * Returns a `Block[]` of the `Block`s (`{ cid:CID, bytes:Uint8Array }` pairs) contained within
   * the CAR referenced by this reader.
   *
   * @function
   * @memberof CarBufferReader
   * @instance
   * @returns {Block[]}
   */ blocks() {
        return this._blocks;
    }
    /**
   * Returns a `CID[]` of the `CID`s contained within the CAR referenced by this reader.
   *
   * @function
   * @memberof CarBufferReader
   * @instance
   * @returns {CID[]}
   */ cids() {
        if (!this._cids) {
            this._cids = this._blocks.map((b)=>b.cid);
        }
        return this._cids;
    }
    /**
   * Instantiate a {@link CarBufferReader} from a `Uint8Array` blob. This performs a
   * decode fully in memory and maintains the decoded state in memory for full
   * access to the data via the `CarReader` API.
   *
   * @static
   * @memberof CarBufferReader
   * @param {Uint8Array} bytes
   * @returns {CarBufferReader}
   */ static fromBytes(bytes) {
        if (!(bytes instanceof Uint8Array)) {
            throw new TypeError('fromBytes() requires a Uint8Array');
        }
        const { header, blocks } = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$buffer$2d$decoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["fromBytes"](bytes);
        return new CarBufferReader(header, blocks);
    }
}
const __browser = true;
}),
"[project]/node_modules/@ipld/car/src/buffer-writer.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "addBlock",
    ()=>addBlock,
    "addRoot",
    ()=>addRoot,
    "blockLength",
    ()=>blockLength,
    "calculateHeaderLength",
    ()=>calculateHeaderLength,
    "close",
    ()=>close,
    "createWriter",
    ()=>createWriter,
    "estimateHeaderLength",
    ()=>estimateHeaderLength,
    "headerLength",
    ()=>headerLength,
    "resizeHeader",
    ()=>resizeHeader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-cbor/src/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$cborg$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/cborg/cborg.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cborg/lib/token.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$length$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cborg/lib/length.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/varint/index.js [app-client] (ecmascript)");
;
;
;
;
/**
 * @typedef {import('./api.js').CID} CID
 * @typedef {import('./api.js').Block} Block
 * @typedef {import('./api.js').CarBufferWriter} Writer
 * @typedef {import('./api.js').CarBufferWriterOptions} Options
 * @typedef {import('./coding.js').CarEncoder} CarEncoder
 */ /**
 * A simple CAR writer that writes to a pre-allocated buffer.
 *
 * @class
 * @name CarBufferWriter
 * @implements {Writer}
 */ class CarBufferWriter {
    /**
   * @param {Uint8Array} bytes
   * @param {number} headerSize
   */ constructor(bytes, headerSize){
        /** @readonly */ this.bytes = bytes;
        this.byteOffset = headerSize;
        /**
     * @readonly
     * @type {CID[]}
     */ this.roots = [];
        this.headerSize = headerSize;
    }
    /**
   * Add a root to this writer, to be used to create a header when the CAR is
   * finalized with {@link CarBufferWriter.close `close()`}
   *
   * @param {CID} root
   * @param {{resize?:boolean}} [options]
   * @returns {CarBufferWriter}
   */ addRoot(root, options) {
        addRoot(this, root, options);
        return this;
    }
    /**
   * Write a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) to the archive.
   * Throws if there is not enough capacity.
   *
   * @param {Block} block - A `{ cid:CID, bytes:Uint8Array }` pair.
   * @returns {CarBufferWriter}
   */ write(block) {
        addBlock(this, block);
        return this;
    }
    /**
   * Finalize the CAR and return it as a `Uint8Array`.
   *
   * @param {object} [options]
   * @param {boolean} [options.resize]
   * @returns {Uint8Array}
   */ close(options) {
        return close(this, options);
    }
}
const addRoot = (writer, root, options = {})=>{
    const { resize = false } = options;
    const { bytes, headerSize, byteOffset, roots } = writer;
    writer.roots.push(root);
    const size = headerLength(writer);
    // If there is not enough space for the new root
    if (size > headerSize) {
        // Check if we root would fit if we were to resize the head.
        if (size - headerSize + byteOffset < bytes.byteLength) {
            // If resize is enabled resize head
            if (resize) {
                resizeHeader(writer, size);
            // otherwise remove head and throw an error suggesting to resize
            } else {
                roots.pop();
                throw new RangeError(`Header of size ${headerSize} has no capacity for new root ${root}.
  However there is a space in the buffer and you could call addRoot(root, { resize: root }) to resize header to make a space for this root.`);
            }
        // If head would not fit even with resize pop new root and throw error
        } else {
            roots.pop();
            throw new RangeError(`Buffer has no capacity for a new root ${root}`);
        }
    }
};
const blockLength = ({ cid, bytes })=>{
    const size = cid.bytes.byteLength + bytes.byteLength;
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].encodingLength(size) + size;
};
const addBlock = (writer, { cid, bytes })=>{
    const byteLength = cid.bytes.byteLength + bytes.byteLength;
    const size = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].encode(byteLength);
    if (writer.byteOffset + size.length + byteLength > writer.bytes.byteLength) {
        throw new RangeError('Buffer has no capacity for this block');
    } else {
        writeBytes(writer, size);
        writeBytes(writer, cid.bytes);
        writeBytes(writer, bytes);
    }
};
const close = (writer, options = {})=>{
    const { resize = false } = options;
    const { roots, bytes, byteOffset, headerSize } = writer;
    const headerBytes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"]({
        version: 1,
        roots
    });
    const varintBytes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].encode(headerBytes.length);
    const size = varintBytes.length + headerBytes.byteLength;
    const offset = headerSize - size;
    // If header size estimate was accurate we just write header and return
    // view into buffer.
    if (offset === 0) {
        writeHeader(writer, varintBytes, headerBytes);
        return bytes.subarray(0, byteOffset);
    // If header was overestimated and `{resize: true}` is passed resize header
    } else if (resize) {
        resizeHeader(writer, size);
        writeHeader(writer, varintBytes, headerBytes);
        return bytes.subarray(0, writer.byteOffset);
    } else {
        throw new RangeError(`Header size was overestimated.
You can use close({ resize: true }) to resize header`);
    }
};
const resizeHeader = (writer, byteLength)=>{
    const { bytes, headerSize } = writer;
    // Move data section to a new offset
    bytes.set(bytes.subarray(headerSize, writer.byteOffset), byteLength);
    // Update header size & byteOffset
    writer.byteOffset += byteLength - headerSize;
    writer.headerSize = byteLength;
};
/**
 * @param {CarBufferWriter} writer
 * @param {number[]|Uint8Array} bytes
 */ const writeBytes = (writer, bytes)=>{
    writer.bytes.set(bytes, writer.byteOffset);
    writer.byteOffset += bytes.length;
};
/**
 * @param {{bytes:Uint8Array}} writer
 * @param {number[]} varint
 * @param {Uint8Array} header
 */ const writeHeader = ({ bytes }, varint, header)=>{
    bytes.set(varint);
    bytes.set(header, varint.length);
};
const headerPreludeTokens = [
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].map, 2),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].string, 'version'),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].uint, 1),
    new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].string, 'roots')
];
const CID_TAG = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].tag, 42);
const calculateHeaderLength = (rootLengths)=>{
    const tokens = [
        ...headerPreludeTokens
    ];
    tokens.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].array, rootLengths.length));
    for (const rootLength of rootLengths){
        tokens.push(CID_TAG);
        tokens.push(new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Token"](__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$token$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Type"].bytes, {
            length: rootLength + 1
        }));
    }
    const length = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cborg$2f$lib$2f$length$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["tokensToLength"])(tokens) // no options needed here because we have simple tokens
    ;
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].encodingLength(length) + length;
};
const headerLength = ({ roots })=>calculateHeaderLength(roots.map((cid)=>cid.bytes.byteLength));
const estimateHeaderLength = (rootCount, rootByteLength = 36)=>calculateHeaderLength(new Array(rootCount).fill(rootByteLength));
const createWriter = (buffer, options = {})=>{
    const { roots = [], byteOffset = 0, byteLength = buffer.byteLength, headerSize = headerLength({
        roots
    }) } = options;
    const bytes = new Uint8Array(buffer, byteOffset, byteLength);
    const writer = new CarBufferWriter(bytes, headerSize);
    for (const root of roots){
        writer.addRoot(root);
    }
    return writer;
};
}),
"[project]/node_modules/@ipld/car/src/indexed-reader-browser.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CarIndexedReader",
    ()=>CarIndexedReader,
    "__browser",
    ()=>__browser
]);
class CarIndexedReader {
    static async fromFile() {
        throw new Error('Unsupported in this environment');
    }
}
const __browser = true;
}),
"[project]/node_modules/@ipld/car/src/decoder.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "asyncIterableReader",
    ()=>asyncIterableReader,
    "bytesReader",
    ()=>bytesReader,
    "chunkReader",
    ()=>chunkReader,
    "createDecoder",
    ()=>createDecoder,
    "limitReader",
    ()=>limitReader,
    "readBlockHead",
    ()=>readBlockHead,
    "readHeader",
    ()=>readHeader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-cbor/src/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/node_modules/multiformats/dist/src/cid.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/node_modules/multiformats/dist/src/hashes/digest.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/decoder-common.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$header$2d$validator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/header-validator.js [app-client] (ecmascript)");
;
;
;
;
;
async function readHeader(reader, strictVersion) {
    const length = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeVarint"])(await reader.upTo(8), reader);
    if (length === 0) {
        throw new Error('Invalid CAR header (zero length)');
    }
    const header = await reader.exactly(length, true);
    const block = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"])(header);
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$header$2d$validator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CarV1HeaderOrV2Pragma"].toTyped(block) === undefined) {
        throw new Error('Invalid CAR header format');
    }
    if (block.version !== 1 && block.version !== 2 || strictVersion !== undefined && block.version !== strictVersion) {
        throw new Error(`Invalid CAR version: ${block.version}${strictVersion !== undefined ? ` (expected ${strictVersion})` : ''}`);
    }
    if (block.version === 1) {
        // CarV1HeaderOrV2Pragma makes roots optional, let's make it mandatory
        if (!Array.isArray(block.roots)) {
            throw new Error('Invalid CAR header format');
        }
        return block;
    }
    // version 2
    if (block.roots !== undefined) {
        throw new Error('Invalid CAR header format');
    }
    const v2Header = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeV2Header"])(await reader.exactly(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["V2_HEADER_LENGTH"], true));
    reader.seek(v2Header.dataOffset - reader.pos);
    const v1Header = await readHeader(reader, 1);
    return Object.assign(v1Header, v2Header);
}
/**
 * @param {BytesReader} reader
 * @returns {Promise<CID>}
 */ async function readCid(reader) {
    const first = await reader.exactly(2, false);
    if (first[0] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CIDV0_BYTES"].SHA2_256 && first[1] === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CIDV0_BYTES"].LENGTH) {
        // cidv0 32-byte sha2-256
        const bytes = await reader.exactly(34, true);
        const multihash = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](bytes);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].create(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["CIDV0_BYTES"].DAG_PB, multihash);
    }
    const version = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeVarint"])(await reader.upTo(8), reader);
    if (version !== 1) {
        throw new Error(`Unexpected CID version (${version})`);
    }
    const codec = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeVarint"])(await reader.upTo(8), reader);
    const bytes = await reader.exactly((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["getMultihashLength"])(await reader.upTo(8)), true);
    const multihash = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$hashes$2f$digest$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decode"](bytes);
    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].create(version, codec, multihash);
}
async function readBlockHead(reader) {
    // length includes a CID + Binary, where CID has a variable length
    // we have to deal with
    const start = reader.pos;
    let length = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2d$common$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["decodeVarint"])(await reader.upTo(8), reader);
    if (length === 0) {
        throw new Error('Invalid CAR section (zero length)');
    }
    length += reader.pos - start;
    const cid = await readCid(reader);
    const blockLength = length - Number(reader.pos - start) // subtract CID length
    ;
    return {
        cid,
        length,
        blockLength
    };
}
/**
 * @param {BytesReader} reader
 * @returns {Promise<Block>}
 */ async function readBlock(reader) {
    const { cid, blockLength } = await readBlockHead(reader);
    const bytes = await reader.exactly(blockLength, true);
    return {
        bytes,
        cid
    };
}
/**
 * @param {BytesReader} reader
 * @returns {Promise<BlockIndex>}
 */ async function readBlockIndex(reader) {
    const offset = reader.pos;
    const { cid, length, blockLength } = await readBlockHead(reader);
    const index = {
        cid,
        length,
        blockLength,
        offset,
        blockOffset: reader.pos
    };
    reader.seek(index.blockLength);
    return index;
}
function createDecoder(reader) {
    const headerPromise = (async ()=>{
        const header = await readHeader(reader);
        if (header.version === 2) {
            const v1length = reader.pos - header.dataOffset;
            reader = limitReader(reader, header.dataSize - v1length);
        }
        return header;
    })();
    return {
        header: ()=>headerPromise,
        async *blocks () {
            await headerPromise;
            while((await reader.upTo(8)).length > 0){
                yield await readBlock(reader);
            }
        },
        async *blocksIndex () {
            await headerPromise;
            while((await reader.upTo(8)).length > 0){
                yield await readBlockIndex(reader);
            }
        }
    };
}
function bytesReader(bytes) {
    let pos = 0;
    /** @type {BytesReader} */ return {
        async upTo (length) {
            const out = bytes.subarray(pos, pos + Math.min(length, bytes.length - pos));
            return out;
        },
        async exactly (length, seek = false) {
            if (length > bytes.length - pos) {
                throw new Error('Unexpected end of data');
            }
            const out = bytes.subarray(pos, pos + length);
            if (seek) {
                pos += length;
            }
            return out;
        },
        seek (length) {
            pos += length;
        },
        get pos () {
            return pos;
        }
    };
}
function chunkReader(readChunk /*, closer */ ) {
    let pos = 0;
    let have = 0;
    let offset = 0;
    let currentChunk = new Uint8Array(0);
    const read = async (/** @type {number} */ length)=>{
        have = currentChunk.length - offset;
        const bufa = [
            currentChunk.subarray(offset)
        ];
        while(have < length){
            const chunk = await readChunk();
            if (chunk == null) {
                break;
            }
            /* c8 ignore next 8 */ // undo this ignore ^ when we have a fd implementation that can seek()
            if (have < 0) {
                /* c8 ignore next 4 */ // toohard to test the else
                if (chunk.length > have) {
                    bufa.push(chunk.subarray(-have));
                } // else discard
            } else {
                bufa.push(chunk);
            }
            have += chunk.length;
        }
        currentChunk = new Uint8Array(bufa.reduce((p, c)=>p + c.length, 0));
        let off = 0;
        for (const b of bufa){
            currentChunk.set(b, off);
            off += b.length;
        }
        offset = 0;
    };
    /** @type {BytesReader} */ return {
        async upTo (length) {
            if (currentChunk.length - offset < length) {
                await read(length);
            }
            return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length));
        },
        async exactly (length, seek = false) {
            if (currentChunk.length - offset < length) {
                await read(length);
            }
            if (currentChunk.length - offset < length) {
                throw new Error('Unexpected end of data');
            }
            const out = currentChunk.subarray(offset, offset + length);
            if (seek) {
                pos += length;
                offset += length;
            }
            return out;
        },
        seek (length) {
            pos += length;
            offset += length;
        },
        get pos () {
            return pos;
        }
    };
}
function asyncIterableReader(asyncIterable) {
    const iterator = asyncIterable[Symbol.asyncIterator]();
    async function readChunk() {
        const next = await iterator.next();
        if (next.done) {
            return null;
        }
        return next.value;
    }
    return chunkReader(readChunk);
}
function limitReader(reader, byteLimit) {
    let bytesRead = 0;
    /** @type {BytesReader} */ return {
        async upTo (length) {
            let bytes = await reader.upTo(length);
            if (bytes.length + bytesRead > byteLimit) {
                bytes = bytes.subarray(0, byteLimit - bytesRead);
            }
            return bytes;
        },
        async exactly (length, seek = false) {
            const bytes = await reader.exactly(length, seek);
            if (bytes.length + bytesRead > byteLimit) {
                throw new Error('Unexpected end of data');
            }
            if (seek) {
                bytesRead += length;
            }
            return bytes;
        },
        seek (length) {
            bytesRead += length;
            reader.seek(length);
        },
        get pos () {
            return reader.pos;
        }
    };
}
}),
"[project]/node_modules/@ipld/car/src/indexer.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CarIndexer",
    ()=>CarIndexer
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/decoder.js [app-client] (ecmascript)");
;
class CarIndexer {
    /**
   * @param {number} version
   * @param {CID[]} roots
   * @param {AsyncGenerator<BlockIndex>} iterator
   */ constructor(version, roots, iterator){
        this._version = version;
        this._roots = roots;
        this._iterator = iterator;
    }
    get version() {
        return this._version;
    }
    /**
   * Get the list of roots defined by the CAR referenced by this indexer. May be
   * zero or more `CID`s.
   *
   * @function
   * @memberof CarIndexer
   * @instance
   * @async
   * @returns {Promise<CID[]>}
   */ async getRoots() {
        return this._roots;
    }
    /**
   * @returns {AsyncIterator<BlockIndex>}
   */ [Symbol.asyncIterator]() {
        return this._iterator;
    }
    /**
   * Instantiate a {@link CarIndexer} from a `Uint8Array` blob. Only the header
   * is decoded initially, the remainder is processed and emitted via the
   * iterator as it is consumed.
   *
   * @async
   * @static
   * @memberof CarIndexer
   * @param {Uint8Array} bytes
   * @returns {Promise<CarIndexer>}
   */ static async fromBytes(bytes) {
        if (!(bytes instanceof Uint8Array)) {
            throw new TypeError('fromBytes() requires a Uint8Array');
        }
        return decodeIndexerComplete((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bytesReader"])(bytes));
    }
    /**
   * Instantiate a {@link CarIndexer} from a `AsyncIterable<Uint8Array>`,
   * such as a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).
   * is decoded initially, the remainder is processed and emitted via the
   * iterator as it is consumed.
   *
   * @async
   * @static
   * @memberof CarIndexer
   * @param {AsyncIterable<Uint8Array>} asyncIterable
   * @returns {Promise<CarIndexer>}
   */ static async fromIterable(asyncIterable) {
        if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === 'function')) {
            throw new TypeError('fromIterable() requires an async iterable');
        }
        return decodeIndexerComplete((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asyncIterableReader"])(asyncIterable));
    }
}
/**
 * @private
 * @param {BytesReader} reader
 * @returns {Promise<CarIndexer>}
 */ async function decodeIndexerComplete(reader) {
    const decoder = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDecoder"])(reader);
    const { version, roots } = await decoder.header();
    return new CarIndexer(version, roots, decoder.blocksIndex());
}
}),
"[project]/node_modules/@ipld/car/src/iterator.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CarBlockIterator",
    ()=>CarBlockIterator,
    "CarCIDIterator",
    ()=>CarCIDIterator,
    "CarIteratorBase",
    ()=>CarIteratorBase
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/decoder.js [app-client] (ecmascript)");
;
class CarIteratorBase {
    /**
   * @param {number} version
   * @param {CID[]} roots
   * @param {AsyncIterable<Block>|void} iterable
   */ constructor(version, roots, iterable){
        this._version = version;
        this._roots = roots;
        this._iterable = iterable;
        this._decoded = false;
    }
    get version() {
        return this._version;
    }
    /**
   * @returns {Promise<CID[]>}
   */ async getRoots() {
        return this._roots;
    }
}
class CarBlockIterator extends CarIteratorBase {
    // inherited method
    /**
   * Get the list of roots defined by the CAR referenced by this iterator. May be
   * zero or more `CID`s.
   *
   * @function getRoots
   * @memberof CarBlockIterator
   * @instance
   * @async
   * @returns {Promise<CID[]>}
   */ /**
   * @returns {AsyncIterator<Block>}
   */ [Symbol.asyncIterator]() {
        if (this._decoded) {
            throw new Error('Cannot decode more than once');
        }
        /* c8 ignore next 3 */ if (!this._iterable) {
            throw new Error('Block iterable not found');
        }
        this._decoded = true;
        return this._iterable[Symbol.asyncIterator]();
    }
    /**
   * Instantiate a {@link CarBlockIterator} from a `Uint8Array` blob. Rather
   * than decoding the entire byte array prior to returning the iterator, as in
   * {@link CarReader.fromBytes}, only the header is decoded and the remainder
   * of the CAR is parsed as the `Block`s as yielded.
   *
   * @async
   * @static
   * @memberof CarBlockIterator
   * @param {Uint8Array} bytes
   * @returns {Promise<CarBlockIterator>}
   */ static async fromBytes(bytes) {
        const { version, roots, iterator } = await fromBytes(bytes);
        return new CarBlockIterator(version, roots, iterator);
    }
    /**
   * Instantiate a {@link CarBlockIterator} from a `AsyncIterable<Uint8Array>`,
   * such as a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).
   * Rather than decoding the entire byte array prior to returning the iterator,
   * as in {@link CarReader.fromIterable}, only the header is decoded and the
   * remainder of the CAR is parsed as the `Block`s as yielded.
   *
   * @async
   * @static
   * @param {AsyncIterable<Uint8Array>} asyncIterable
   * @returns {Promise<CarBlockIterator>}
   */ static async fromIterable(asyncIterable) {
        const { version, roots, iterator } = await fromIterable(asyncIterable);
        return new CarBlockIterator(version, roots, iterator);
    }
}
class CarCIDIterator extends CarIteratorBase {
    // inherited method
    /**
   * Get the list of roots defined by the CAR referenced by this iterator. May be
   * zero or more `CID`s.
   *
   * @function getRoots
   * @memberof CarCIDIterator
   * @instance
   * @async
   * @returns {Promise<CID[]>}
   */ /**
   * @returns {AsyncIterator<CID>}
   */ [Symbol.asyncIterator]() {
        if (this._decoded) {
            throw new Error('Cannot decode more than once');
        }
        /* c8 ignore next 3 */ if (!this._iterable) {
            throw new Error('Block iterable not found');
        }
        this._decoded = true;
        const iterable = this._iterable[Symbol.asyncIterator]();
        return {
            async next () {
                const next = await iterable.next();
                if (next.done) {
                    return next;
                }
                return {
                    done: false,
                    value: next.value.cid
                };
            }
        };
    }
    /**
   * Instantiate a {@link CarCIDIterator} from a `Uint8Array` blob. Rather
   * than decoding the entire byte array prior to returning the iterator, as in
   * {@link CarReader.fromBytes}, only the header is decoded and the remainder
   * of the CAR is parsed as the `CID`s as yielded.
   *
   * @async
   * @static
   * @memberof CarCIDIterator
   * @param {Uint8Array} bytes
   * @returns {Promise<CarCIDIterator>}
   */ static async fromBytes(bytes) {
        const { version, roots, iterator } = await fromBytes(bytes);
        return new CarCIDIterator(version, roots, iterator);
    }
    /**
   * Instantiate a {@link CarCIDIterator} from a `AsyncIterable<Uint8Array>`,
   * such as a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).
   * Rather than decoding the entire byte array prior to returning the iterator,
   * as in {@link CarReader.fromIterable}, only the header is decoded and the
   * remainder of the CAR is parsed as the `CID`s as yielded.
   *
   * @async
   * @static
   * @memberof CarCIDIterator
   * @param {AsyncIterable<Uint8Array>} asyncIterable
   * @returns {Promise<CarCIDIterator>}
   */ static async fromIterable(asyncIterable) {
        const { version, roots, iterator } = await fromIterable(asyncIterable);
        return new CarCIDIterator(version, roots, iterator);
    }
}
/**
 * @param {Uint8Array} bytes
 * @returns {Promise<{ version:number, roots:CID[], iterator:AsyncIterable<Block>}>}
 */ async function fromBytes(bytes) {
    if (!(bytes instanceof Uint8Array)) {
        throw new TypeError('fromBytes() requires a Uint8Array');
    }
    return decodeIterator((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bytesReader"])(bytes));
}
/**
 * @param {AsyncIterable<Uint8Array>} asyncIterable
 * @returns {Promise<{ version:number, roots:CID[], iterator:AsyncIterable<Block>}>}
 */ async function fromIterable(asyncIterable) {
    if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === 'function')) {
        throw new TypeError('fromIterable() requires an async iterable');
    }
    return decodeIterator((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asyncIterableReader"])(asyncIterable));
}
/**
 * @private
 * @param {BytesReader} reader
 * @returns {Promise<{ version:number, roots:CID[], iterator:AsyncIterable<Block>}>}
 */ async function decodeIterator(reader) {
    const decoder = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDecoder"])(reader);
    const { version, roots } = await decoder.header();
    return {
        version,
        roots,
        iterator: decoder.blocks()
    };
}
}),
"[project]/node_modules/@ipld/car/src/reader-browser.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CarReader",
    ()=>CarReader,
    "__browser",
    ()=>__browser,
    "decodeReaderComplete",
    ()=>decodeReaderComplete
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/decoder.js [app-client] (ecmascript)");
;
class CarReader {
    /**
   * @constructs CarReader
   * @param {CarHeader|CarV2Header} header
   * @param {Block[]} blocks
   */ constructor(header, blocks){
        this._header = header;
        this._blocks = blocks;
        this._keys = blocks.map((b)=>b.cid.toString());
    }
    /**
   * @property
   * @memberof CarReader
   * @instance
   */ get version() {
        return this._header.version;
    }
    /**
   * Get the list of roots defined by the CAR referenced by this reader. May be
   * zero or more `CID`s.
   *
   * @function
   * @memberof CarReader
   * @instance
   * @async
   * @returns {Promise<CID[]>}
   */ async getRoots() {
        return this._header.roots;
    }
    /**
   * Check whether a given `CID` exists within the CAR referenced by this
   * reader.
   *
   * @function
   * @memberof CarReader
   * @instance
   * @async
   * @param {CID} key
   * @returns {Promise<boolean>}
   */ async has(key) {
        return this._keys.indexOf(key.toString()) > -1;
    }
    /**
   * Fetch a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) from the CAR
   * referenced by this reader matching the provided `CID`. In the case where
   * the provided `CID` doesn't exist within the CAR, `undefined` will be
   * returned.
   *
   * @function
   * @memberof CarReader
   * @instance
   * @async
   * @param {CID} key
   * @returns {Promise<Block | undefined>}
   */ async get(key) {
        const index = this._keys.indexOf(key.toString());
        return index > -1 ? this._blocks[index] : undefined;
    }
    /**
   * Returns a `BlockIterator` (`AsyncIterable<Block>`) that iterates over all
   * of the `Block`s (`{ cid:CID, bytes:Uint8Array }` pairs) contained within
   * the CAR referenced by this reader.
   *
   * @function
   * @memberof CarReader
   * @instance
   * @async
   * @generator
   * @returns {AsyncGenerator<Block>}
   */ async *blocks() {
        for (const block of this._blocks){
            yield block;
        }
    }
    /**
   * Returns a `CIDIterator` (`AsyncIterable<CID>`) that iterates over all of
   * the `CID`s contained within the CAR referenced by this reader.
   *
   * @function
   * @memberof CarReader
   * @instance
   * @async
   * @generator
   * @returns {AsyncGenerator<CID>}
   */ async *cids() {
        for (const block of this._blocks){
            yield block.cid;
        }
    }
    /**
   * Instantiate a {@link CarReader} from a `Uint8Array` blob. This performs a
   * decode fully in memory and maintains the decoded state in memory for full
   * access to the data via the `CarReader` API.
   *
   * @async
   * @static
   * @memberof CarReader
   * @param {Uint8Array} bytes
   * @returns {Promise<CarReader>}
   */ static async fromBytes(bytes) {
        if (!(bytes instanceof Uint8Array)) {
            throw new TypeError('fromBytes() requires a Uint8Array');
        }
        return decodeReaderComplete((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bytesReader"])(bytes));
    }
    /**
   * Instantiate a {@link CarReader} from a `AsyncIterable<Uint8Array>`, such as
   * a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).
   * This performs a decode fully in memory and maintains the decoded state in
   * memory for full access to the data via the `CarReader` API.
   *
   * Care should be taken for large archives; this API may not be appropriate
   * where memory is a concern or the archive is potentially larger than the
   * amount of memory that the runtime can handle.
   *
   * @async
   * @static
   * @memberof CarReader
   * @param {AsyncIterable<Uint8Array>} asyncIterable
   * @returns {Promise<CarReader>}
   */ static async fromIterable(asyncIterable) {
        if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === 'function')) {
            throw new TypeError('fromIterable() requires an async iterable');
        }
        return decodeReaderComplete((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["asyncIterableReader"])(asyncIterable));
    }
}
async function decodeReaderComplete(reader) {
    const decoder = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createDecoder"])(reader);
    const header = await decoder.header();
    const blocks = [];
    for await (const block of decoder.blocks()){
        blocks.push(block);
    }
    return new CarReader(header, blocks);
}
const __browser = true;
}),
"[project]/node_modules/@ipld/car/src/encoder.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "createEncoder",
    ()=>createEncoder,
    "createHeader",
    ()=>createHeader
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/dag-cbor/src/index.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/varint/index.js [app-client] (ecmascript)");
;
;
/**
 * @typedef {import('multiformats').CID} CID
 * @typedef {import('./api.js').Block} Block
 * @typedef {import('./coding.js').CarEncoder} CarEncoder
 * @typedef {import('./coding.js').IteratorChannel_Writer<Uint8Array>} IteratorChannel_Writer
 */ const CAR_V1_VERSION = 1;
function createHeader(roots) {
    const headerBytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$dag$2d$cbor$2f$src$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["encode"])({
        version: CAR_V1_VERSION,
        roots
    });
    const varintBytes = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].encode(headerBytes.length);
    const header = new Uint8Array(varintBytes.length + headerBytes.length);
    header.set(varintBytes, 0);
    header.set(headerBytes, varintBytes.length);
    return header;
}
/**
 * @param {IteratorChannel_Writer} writer
 * @returns {CarEncoder}
 */ function createEncoder(writer) {
    // none of this is wrapped in a mutex, that needs to happen above this to
    // avoid overwrites
    return {
        /**
     * @param {CID[]} roots
     * @returns {Promise<void>}
     */ async setRoots (roots) {
            const bytes = createHeader(roots);
            await writer.write(bytes);
        },
        /**
     * @param {Block} block
     * @returns {Promise<void>}
     */ async writeBlock (block) {
            const { cid, bytes } = block;
            await writer.write(new Uint8Array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$varint$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["default"].encode(cid.bytes.length + bytes.length)));
            await writer.write(cid.bytes);
            if (bytes.length) {
                // zero-length blocks are valid, but it'd be safer if we didn't write them
                await writer.write(bytes);
            }
        },
        /**
     * @returns {Promise<void>}
     */ async close () {
            await writer.end();
        },
        /**
     * @returns {number}
     */ version () {
            return CAR_V1_VERSION;
        }
    };
}
;
}),
"[project]/node_modules/@ipld/car/src/iterator-channel.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

/**
 * @template {any} T
 * @typedef {import('./coding.js').IteratorChannel<T>} IteratorChannel
 */ __turbopack_context__.s([
    "create",
    ()=>create
]);
function noop() {}
function create() {
    /** @type {T[]} */ const chunkQueue = [];
    /** @type {Promise<void> | null} */ let drainer = null;
    let drainerResolver = noop;
    let ended = false;
    /** @type {Promise<IteratorResult<T>> | null} */ let outWait = null;
    let outWaitResolver = noop;
    const makeDrainer = ()=>{
        if (!drainer) {
            drainer = new Promise((resolve)=>{
                drainerResolver = ()=>{
                    drainer = null;
                    drainerResolver = noop;
                    resolve();
                };
            });
        }
        return drainer;
    };
    /**
   * @returns {IteratorChannel<T>}
   */ const writer = {
        /**
     * @param {T} chunk
     * @returns {Promise<void>}
     */ write (chunk) {
            chunkQueue.push(chunk);
            const drainer = makeDrainer();
            outWaitResolver();
            return drainer;
        },
        async end () {
            ended = true;
            const drainer = makeDrainer();
            outWaitResolver();
            await drainer;
        }
    };
    /** @type {AsyncIterator<T>} */ const iterator = {
        /** @returns {Promise<IteratorResult<T>>} */ async next () {
            const chunk = chunkQueue.shift();
            if (chunk) {
                if (chunkQueue.length === 0) {
                    drainerResolver();
                }
                return {
                    done: false,
                    value: chunk
                };
            }
            if (ended) {
                drainerResolver();
                return {
                    done: true,
                    value: undefined
                };
            }
            if (!outWait) {
                outWait = new Promise((resolve)=>{
                    outWaitResolver = ()=>{
                        outWait = null;
                        outWaitResolver = noop;
                        return resolve(iterator.next());
                    };
                });
            }
            return outWait;
        }
    };
    return {
        writer,
        iterator
    };
}
}),
"[project]/node_modules/@ipld/car/src/writer-browser.js [app-client] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "CarWriter",
    ()=>CarWriter,
    "CarWriterOut",
    ()=>CarWriterOut,
    "__browser",
    ()=>__browser
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/node_modules/multiformats/dist/src/cid.js [app-client] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/decoder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$encoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/encoder.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$iterator$2d$channel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/iterator-channel.js [app-client] (ecmascript)");
;
;
;
;
class CarWriter {
    /**
   * @param {CID[]} roots
   * @param {CarEncoder} encoder
   */ constructor(roots, encoder){
        this._encoder = encoder;
        /** @type {Promise<void>} */ this._mutex = encoder.setRoots(roots);
        this._ended = false;
    }
    /**
   * Write a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) to the archive.
   *
   * @function
   * @memberof CarWriter
   * @instance
   * @async
   * @param {Block} block - A `{ cid:CID, bytes:Uint8Array }` pair.
   * @returns {Promise<void>} The returned promise will only resolve once the
   * bytes this block generates are written to the `out` iterable.
   */ async put(block) {
        if (!(block.bytes instanceof Uint8Array) || !block.cid) {
            throw new TypeError('Can only write {cid, bytes} objects');
        }
        if (this._ended) {
            throw new Error('Already closed');
        }
        const cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].asCID(block.cid);
        if (!cid) {
            throw new TypeError('Can only write {cid, bytes} objects');
        }
        this._mutex = this._mutex.then(()=>this._encoder.writeBlock({
                cid,
                bytes: block.bytes
            }));
        return this._mutex;
    }
    /**
   * Finalise the CAR archive and signal that the `out` iterable should end once
   * any remaining bytes are written.
   *
   * @function
   * @memberof CarWriter
   * @instance
   * @async
   * @returns {Promise<void>}
   */ async close() {
        if (this._ended) {
            throw new Error('Already closed');
        }
        await this._mutex;
        this._ended = true;
        return this._encoder.close();
    }
    /**
   * Returns the version number of the CAR file being written
   *
   * @returns {number}
   */ version() {
        return this._encoder.version();
    }
    /**
   * Create a new CAR writer "channel" which consists of a
   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair.
   *
   * @async
   * @static
   * @memberof CarWriter
   * @param {CID[] | CID | void} roots
   * @returns {WriterChannel} The channel takes the form of
   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }`.
   */ static create(roots) {
        roots = toRoots(roots);
        const { encoder, iterator } = encodeWriter();
        const writer = new CarWriter(roots, encoder);
        const out = new CarWriterOut(iterator);
        return {
            writer,
            out
        };
    }
    /**
   * Create a new CAR appender "channel" which consists of a
   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair.
   * This appender does not consider roots and does not produce a CAR header.
   * It is designed to append blocks to an _existing_ CAR archive. It is
   * expected that `out` will be concatenated onto the end of an existing
   * archive that already has a properly formatted header.
   *
   * @async
   * @static
   * @memberof CarWriter
   * @returns {WriterChannel} The channel takes the form of
   * `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }`.
   */ static createAppender() {
        const { encoder, iterator } = encodeWriter();
        encoder.setRoots = ()=>Promise.resolve();
        const writer = new CarWriter([], encoder);
        const out = new CarWriterOut(iterator);
        return {
            writer,
            out
        };
    }
    /**
   * Update the list of roots in the header of an existing CAR as represented
   * in a Uint8Array.
   *
   * This operation is an _overwrite_, the total length of the CAR will not be
   * modified. A rejection will occur if the new header will not be the same
   * length as the existing header, in which case the CAR will not be modified.
   * It is the responsibility of the user to ensure that the roots being
   * replaced encode as the same length as the new roots.
   *
   * The byte array passed in an argument will be modified and also returned
   * upon successful modification.
   *
   * @async
   * @static
   * @memberof CarWriter
   * @param {Uint8Array} bytes
   * @param {CID[]} roots - A new list of roots to replace the existing list in
   * the CAR header. The new header must take up the same number of bytes as the
   * existing header, so the roots should collectively be the same byte length
   * as the existing roots.
   * @returns {Promise<Uint8Array>}
   */ static async updateRootsInBytes(bytes, roots) {
        const reader = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["bytesReader"])(bytes);
        await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$decoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["readHeader"])(reader);
        const newHeader = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$encoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createHeader"])(roots);
        if (Number(reader.pos) !== newHeader.length) {
            throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${reader.pos} bytes, new header is ${newHeader.length} bytes)`);
        }
        bytes.set(newHeader, 0);
        return bytes;
    }
}
class CarWriterOut {
    /**
   * @param {AsyncIterator<Uint8Array>} iterator
   */ constructor(iterator){
        this._iterator = iterator;
    }
    [Symbol.asyncIterator]() {
        if (this._iterating) {
            throw new Error('Multiple iterator not supported');
        }
        this._iterating = true;
        return this._iterator;
    }
}
function encodeWriter() {
    /** @type {IteratorChannel} */ const iw = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$iterator$2d$channel$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["create"])();
    const { writer, iterator } = iw;
    const encoder = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$encoder$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["createEncoder"])(writer);
    return {
        encoder,
        iterator
    };
}
/**
 * @private
 * @param {CID[] | CID | void} roots
 * @returns {CID[]}
 */ function toRoots(roots) {
    if (roots === undefined) {
        return [];
    }
    if (!Array.isArray(roots)) {
        const cid = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].asCID(roots);
        if (!cid) {
            throw new TypeError('roots must be a single CID or an array of CIDs');
        }
        return [
            cid
        ];
    }
    const _roots = [];
    for (const root of roots){
        const _root = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$node_modules$2f$multiformats$2f$dist$2f$src$2f$cid$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__$3c$locals$3e$__["CID"].asCID(root);
        if (!_root) {
            throw new TypeError('roots must be a single CID or an array of CIDs');
        }
        _roots.push(_root);
    }
    return _roots;
}
const __browser = true;
}),
"[project]/node_modules/@ipld/car/src/index-browser.js [app-client] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$buffer$2d$reader$2d$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/buffer-reader-browser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$buffer$2d$writer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/buffer-writer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$indexed$2d$reader$2d$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/indexed-reader-browser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$indexer$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/indexer.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$iterator$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/iterator.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$reader$2d$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/reader-browser.js [app-client] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ipld$2f$car$2f$src$2f$writer$2d$browser$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ipld/car/src/writer-browser.js [app-client] (ecmascript)");
;
;
;
;
;
;
;
;
}),
]);

//# sourceMappingURL=node_modules_%40ipld_9a2611d7._.js.map