{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/core/src/link.js"],"sourcesContent":["export * from 'multiformats/link'\nexport { base32 } from 'multiformats/bases/base32'\nexport { base58btc } from 'multiformats/bases/base58'\n"],"names":[],"mappings":";AAAA;AACA;AACA","ignoreList":[0]}},
    {"offset": {"line": 15, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/core/src/cbor.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport * as CBOR from '@ipld/dag-cbor'\nexport { code, name, decode } from '@ipld/dag-cbor'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { create as createLink, isLink } from 'multiformats/link'\n\n// @see https://www.iana.org/assignments/media-types/application/vnd.ipld.dag-cbor\nexport const contentType = 'application/vnd.ipld.dag-cbor'\n\n/**\n * @param {unknown} data\n * @param {Set<unknown>} seen\n * @returns {unknown}\n */\nconst prepare = (data, seen) => {\n  if (seen.has(data)) {\n    throw new TypeError('Can not encode circular structure')\n  }\n  // top level undefined is ok\n  if (data === undefined && seen.size === 0) {\n    return null\n  }\n\n  if (data === null) {\n    return null\n  }\n\n  if (typeof data === 'symbol' && seen.size === 0) {\n    return null\n  }\n\n  if (isLink(data)) {\n    return data\n  }\n\n  if (ArrayBuffer.isView(data)) {\n    return data\n  }\n\n  if (Array.isArray(data)) {\n    seen.add(data)\n    const items = []\n    for (const item of data) {\n      items.push(\n        item === undefined || typeof item === 'symbol'\n          ? null\n          : prepare(item, seen)\n      )\n    }\n    return items\n  }\n\n  if (typeof (/** @type {{toJSON?:unknown}} */ (data).toJSON) === 'function') {\n    seen.add(data)\n    const json = /** @type {{toJSON():unknown}} */ (data).toJSON()\n    return prepare(json, seen)\n  }\n\n  if (typeof data === 'object') {\n    seen.add(data)\n    /** @type {Record<string, unknown>} */\n    const object = {}\n    for (const [key, value] of Object.entries(data)) {\n      if (value !== undefined && typeof value !== 'symbol') {\n        object[key] = prepare(value, new Set(seen))\n      }\n    }\n    return object\n  }\n\n  return data\n}\n\n/**\n * @template T\n * @param {T} data\n * @returns {CBOR.ByteView<T>}\n */\nexport const encode = data =>\n  /** @type {CBOR.ByteView<T>} */ (CBOR.encode(prepare(data, new Set())))\n\n/**\n * @template T\n * @param {API.ByteView<T>} bytes\n * @param {{hasher?: API.MultihashHasher }} options\n * @returns {Promise<API.Link<T, typeof CBOR.code>>}\n *\n */\nexport const link = async (bytes, { hasher = sha256 } = {}) => {\n  return /** @type {API.Link<T, typeof CBOR.code>} */ (\n    createLink(CBOR.code, await hasher.digest(bytes))\n  )\n}\n\n/**\n * @template T\n * @param {T} data\n * @param {{hasher?: API.MultihashHasher }} [options]\n * @returns {Promise<API.Block<T, typeof CBOR.code>>}\n */\nexport const write = async (data, options) => {\n  const bytes = encode(data)\n  const cid = await link(bytes, options)\n\n  return { cid, bytes }\n}\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AAEA;AACA;;;;;;AAGO,MAAM,cAAc;AAE3B;;;;CAIC,GACD,MAAM,UAAU,CAAC,MAAM;IACrB,IAAI,KAAK,GAAG,CAAC,OAAO;QAClB,MAAM,IAAI,UAAU;IACtB;IACA,4BAA4B;IAC5B,IAAI,SAAS,aAAa,KAAK,IAAI,KAAK,GAAG;QACzC,OAAO;IACT;IAEA,IAAI,SAAS,MAAM;QACjB,OAAO;IACT;IAEA,IAAI,OAAO,SAAS,YAAY,KAAK,IAAI,KAAK,GAAG;QAC/C,OAAO;IACT;IAEA,IAAI,IAAA,oNAAM,EAAC,OAAO;QAChB,OAAO;IACT;IAEA,IAAI,YAAY,MAAM,CAAC,OAAO;QAC5B,OAAO;IACT;IAEA,IAAI,MAAM,OAAO,CAAC,OAAO;QACvB,KAAK,GAAG,CAAC;QACT,MAAM,QAAQ,EAAE;QAChB,KAAK,MAAM,QAAQ,KAAM;YACvB,MAAM,IAAI,CACR,SAAS,aAAa,OAAO,SAAS,WAClC,OACA,QAAQ,MAAM;QAEtB;QACA,OAAO;IACT;IAEA,IAAI,OAAQ,8BAA8B,GAAG,AAAC,KAAM,MAAM,KAAM,YAAY;QAC1E,KAAK,GAAG,CAAC;QACT,MAAM,OAAO,+BAA+B,GAAG,AAAC,KAAM,MAAM;QAC5D,OAAO,QAAQ,MAAM;IACvB;IAEA,IAAI,OAAO,SAAS,UAAU;QAC5B,KAAK,GAAG,CAAC;QACT,oCAAoC,GACpC,MAAM,SAAS,CAAC;QAChB,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,OAAO,OAAO,CAAC,MAAO;YAC/C,IAAI,UAAU,aAAa,OAAO,UAAU,UAAU;gBACpD,MAAM,CAAC,IAAI,GAAG,QAAQ,OAAO,IAAI,IAAI;YACvC;QACF;QACA,OAAO;IACT;IAEA,OAAO;AACT;AAOO,MAAM,SAAS,CAAA,OACa,kKAAW,CAAC,QAAQ,MAAM,IAAI;AAS1D,MAAM,OAAO,OAAO,OAAO,EAAE,SAAS,yNAAM,EAAE,GAAG,CAAC,CAAC;IACxD,OACE,IAAA,oNAAU,EAAC,gKAAS,EAAE,MAAM,OAAO,MAAM,CAAC;AAE9C;AAQO,MAAM,QAAQ,OAAO,MAAM;IAChC,MAAM,QAAQ,OAAO;IACrB,MAAM,MAAM,MAAM,KAAK,OAAO;IAE9B,OAAO;QAAE;QAAK;IAAM;AACtB","ignoreList":[0]}},
    {"offset": {"line": 122, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/core/src/dag.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport { create as createLink } from './link.js'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport * as MF from 'multiformats/interface'\nimport * as CBOR from './cbor.js'\nimport { identity } from 'multiformats/hashes/identity'\n\nexport { CBOR, sha256, identity }\n\n/**\n * Function takes arbitrary value and if it happens to be an `IPLDView`\n * it will iterate over it's blocks. It is just a convenience for traversing\n * arbitrary structures that may contain `IPLDView`s in them.\n * Note if you pass anything other than `IPLDView` it will not attempt\n * to find views nested inside them, instead it will just emit no blocks.\n *\n * @param {unknown} value\n * @returns {IterableIterator<API.Block>}\n */\nexport const iterate = function* (value) {\n  if (\n    value &&\n    typeof value === 'object' &&\n    'iterateIPLDBlocks' in value &&\n    typeof value.iterateIPLDBlocks === 'function'\n  ) {\n    yield* value.iterateIPLDBlocks()\n  }\n}\n\n/**\n * @template [T=unknown]\n * @typedef {Map<API.ToString<API.Link>, API.Block<T, number, number, 0>|API.Block<T, number, number, 1>>} BlockStore\n */\n\n/**\n * @template [T=unknown]\n * @param {API.Block<T>[]} blocks\n * @returns {API.BlockStore<T>}\n */\nexport const createStore = (blocks = []) => {\n  const store = new Map()\n  addEveryInto(blocks, store)\n  return store\n}\n\n/** @type {API.MulticodecCode<typeof identity.code, typeof identity.name>} */\nconst EMBED_CODE = identity.code\n\n/**\n * Gets block corresponding to the given CID from the store. If store does not\n * contain the block, `fallback` is returned. If `fallback` is not provided, it\n * will throw an error.\n *\n * @template {0|1} V\n * @template {T} U\n * @template T\n * @template {API.MulticodecCode} Format\n * @template {API.MulticodecCode} Alg\n * @template [E=never]\n * @param {API.Link<U, Format, Alg, V>} cid\n * @param {BlockStore<T>} store\n * @param {E} [fallback]\n * @returns {API.Block<U, Format, Alg, V>|E}\n */\nexport const get = (cid, store, fallback) => {\n  // If CID uses identity hash, we can return the block data directly\n  if (cid.multihash.code === EMBED_CODE) {\n    return { cid, bytes: cid.multihash.digest }\n  }\n\n  const block = /** @type {API.Block<U, Format, Alg, V>|undefined} */ (\n    store.get(`${cid}`)\n  )\n  return block ? block : fallback === undefined ? notFound(cid) : fallback\n}\n\n/**\n * @template T\n * @template {T} U\n * @param {U} source\n * @template {API.MulticodecCode} [C=API.MulticodecCode<typeof CBOR.code, typeof CBOR.name>]\n * @param {object} options\n * @param {MF.BlockEncoder<C, U>} [options.codec]\n * @returns {API.Block<U, C, typeof EMBED_CODE> & { data: U }}\n */\nexport const embed = (source, { codec } = {}) => {\n  const encoder = /** @type {MF.BlockEncoder<C, U>}  */ (codec || CBOR)\n  const bytes = encoder.encode(source)\n  const digest = identity.digest(bytes)\n  return {\n    cid: createLink(encoder.code, digest),\n    bytes,\n    data: source,\n  }\n}\n\n/**\n * @param {API.Link<*, *, *, *>} link\n * @returns {never}\n */\nexport const notFound = link => {\n  throw new Error(`Block for the ${link} is not found`)\n}\n\n/**\n * @template T\n * @template {T} U\n * @template {API.MulticodecCode} C\n * @template {API.MulticodecCode} A\n * @param {U} source\n * @param {BlockStore<T>} store\n * @param {object} options\n * @param {MF.BlockEncoder<C, unknown>} [options.codec]\n * @param {MF.MultihashHasher<A>} [options.hasher]\n * @returns {Promise<API.Block<U, C, A> & { data: U }>}\n */\nexport const writeInto = async (source, store, options = {}) => {\n  const codec = /** @type {MF.BlockEncoder<C, U>} */ (options.codec || CBOR)\n  const hasher = /** @type {MF.MultihashHasher<A>} */ (options.hasher || sha256)\n\n  const bytes = codec.encode(source)\n  const digest = await hasher.digest(bytes)\n  /** @type {API.Link<U, typeof codec.code, typeof hasher.code>} */\n  const link = createLink(codec.code, digest)\n  store.set(/** @type {API.ToString<typeof link>} */ (link.toString()), {\n    bytes,\n    cid: link,\n  })\n\n  return { bytes, cid: link, data: source }\n}\n\n/**\n * @template T\n * @template {T} U\n * @param {API.Block<U>} block\n * @param {BlockStore<T>} store\n * @returns {API.Block<U>}\n */\nexport const addInto = ({ cid, bytes }, store) => {\n  store.set(/** @type {API.ToString<typeof cid>} */ (cid.toString()), {\n    bytes,\n    cid,\n  })\n\n  return { bytes, cid }\n}\n\n/**\n * @template T\n * @template {T} U\n * @param {Iterable<API.Block<U>>} source\n * @param {BlockStore<T>} store\n */\nexport const addEveryInto = (source, store) => {\n  for (const block of source) {\n    addInto(block, store)\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;;;;;;;;AAcO,MAAM,UAAU,UAAW,KAAK;IACrC,IACE,SACA,OAAO,UAAU,YACjB,uBAAuB,SACvB,OAAO,MAAM,iBAAiB,KAAK,YACnC;QACA,OAAO,MAAM,iBAAiB;IAChC;AACF;AAYO,MAAM,cAAc,CAAC,SAAS,EAAE;IACrC,MAAM,QAAQ,IAAI;IAClB,aAAa,QAAQ;IACrB,OAAO;AACT;AAEA,2EAA2E,GAC3E,MAAM,aAAa,oNAAQ,CAAC,IAAI;AAkBzB,MAAM,MAAM,CAAC,KAAK,OAAO;IAC9B,mEAAmE;IACnE,IAAI,IAAI,SAAS,CAAC,IAAI,KAAK,YAAY;QACrC,OAAO;YAAE;YAAK,OAAO,IAAI,SAAS,CAAC,MAAM;QAAC;IAC5C;IAEA,MAAM,QACJ,MAAM,GAAG,CAAC,GAAG,KAAK;IAEpB,OAAO,QAAQ,QAAQ,aAAa,YAAY,SAAS,OAAO;AAClE;AAWO,MAAM,QAAQ,CAAC,QAAQ,EAAE,KAAK,EAAE,GAAG,CAAC,CAAC;IAC1C,MAAM,UAAiD,SAAS;IAChE,MAAM,QAAQ,QAAQ,MAAM,CAAC;IAC7B,MAAM,SAAS,oNAAQ,CAAC,MAAM,CAAC;IAC/B,OAAO;QACL,KAAK,IAAA,oMAAU,EAAC,QAAQ,IAAI,EAAE;QAC9B;QACA,MAAM;IACR;AACF;AAMO,MAAM,WAAW,CAAA;IACtB,MAAM,IAAI,MAAM,CAAC,cAAc,EAAE,KAAK,aAAa,CAAC;AACtD;AAcO,MAAM,YAAY,OAAO,QAAQ,OAAO,UAAU,CAAC,CAAC;IACzD,MAAM,QAA8C,QAAQ,KAAK,IAAI;IACrE,MAAM,SAA+C,QAAQ,MAAM,IAAI,yNAAM;IAE7E,MAAM,QAAQ,MAAM,MAAM,CAAC;IAC3B,MAAM,SAAS,MAAM,OAAO,MAAM,CAAC;IACnC,+DAA+D,GAC/D,MAAM,OAAO,IAAA,oMAAU,EAAC,MAAM,IAAI,EAAE;IACpC,MAAM,GAAG,CAA2C,KAAK,QAAQ,IAAK;QACpE;QACA,KAAK;IACP;IAEA,OAAO;QAAE;QAAO,KAAK;QAAM,MAAM;IAAO;AAC1C;AASO,MAAM,UAAU,CAAC,EAAE,GAAG,EAAE,KAAK,EAAE,EAAE;IACtC,MAAM,GAAG,CAA0C,IAAI,QAAQ,IAAK;QAClE;QACA;IACF;IAEA,OAAO;QAAE;QAAO;IAAI;AACtB;AAQO,MAAM,eAAe,CAAC,QAAQ;IACnC,KAAK,MAAM,SAAS,OAAQ;QAC1B,QAAQ,OAAO;IACjB;AACF","ignoreList":[0]}},
    {"offset": {"line": 225, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/core/src/car.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport { CarBufferReader } from '@ipld/car/buffer-reader'\nimport * as CarBufferWriter from '@ipld/car/buffer-writer'\nimport { base32 } from 'multiformats/bases/base32'\nimport { create as createLink } from './link.js'\nimport { sha256 } from 'multiformats/hashes/sha2'\n\n// @see https://www.iana.org/assignments/media-types/application/vnd.ipld.car\nexport const contentType = 'application/vnd.ipld.car'\nexport const name = 'CAR'\n\n/** @type {API.MulticodecCode<0x0202, 'CAR'>} */\nexport const code = 0x0202\n\n/**\n * @typedef {{\n * roots: API.IPLDBlock[]\n * blocks: Map<string, API.IPLDBlock>\n * }} Model\n */\n\nclass Writer {\n  /**\n   * @param {API.IPLDBlock[]} blocks\n   * @param {number} byteLength\n   */\n  constructor(blocks = [], byteLength = 0) {\n    this.written = new Set()\n    this.blocks = blocks\n    this.byteLength = byteLength\n  }\n  /**\n   * @param {API.IPLDBlock[]} blocks\n   */\n  write(...blocks) {\n    for (const block of blocks) {\n      const id = block.cid.toString(base32)\n      if (!this.written.has(id)) {\n        this.blocks.push(block)\n        this.byteLength += CarBufferWriter.blockLength(\n          /** @type {any} */ (block)\n        )\n        this.written.add(id)\n      }\n    }\n    return this\n  }\n  /**\n   * @param {API.IPLDBlock[]} rootBlocks\n   */\n  flush(...rootBlocks) {\n    const roots = []\n    // We reverse the roots so that the first root is the last block in the CAR\n    for (const block of rootBlocks.reverse()) {\n      const id = block.cid.toString(base32)\n      if (!this.written.has(id)) {\n        this.blocks.unshift(block)\n        this.byteLength += CarBufferWriter.blockLength({\n          cid: /** @type {CarBufferWriter.CID} */ (block.cid),\n          bytes: block.bytes,\n        })\n        this.written.add(id)\n      }\n\n      // We unshift here because we want to preserve the order of the roots\n      roots.unshift(/** @type {CarBufferWriter.CID} */ (block.cid))\n    }\n\n    this.byteLength += CarBufferWriter.headerLength({ roots })\n\n    const buffer = new ArrayBuffer(this.byteLength)\n    const writer = CarBufferWriter.createWriter(buffer, { roots })\n\n    for (const block of /** @type {CarBufferWriter.Block[]} */ (this.blocks)) {\n      writer.write(block)\n    }\n\n    return writer.close()\n  }\n}\n\nexport const createWriter = () => new Writer()\n\n/**\n * @template {Partial<Model>} T\n * @param {T} input\n * @returns {API.ByteView<T>}\n */\nexport const encode = ({ roots = [], blocks }) => {\n  const writer = new Writer()\n  if (blocks) {\n    writer.write(...blocks.values())\n  }\n  return writer.flush(...roots)\n}\n\n/**\n * @param {API.ByteView<Partial<Model>>} bytes\n * @returns {Model}\n */\nexport const decode = bytes => {\n  const reader = CarBufferReader.fromBytes(bytes)\n  /** @type {API.IPLDBlock[]} */\n  const roots = []\n  const blocks = new Map()\n\n  for (const root of reader.getRoots()) {\n    const block = /** @type {API.IPLDBlock} */ (reader.get(root))\n    if (block) {\n      roots.push(block)\n    }\n  }\n\n  for (const block of reader.blocks()) {\n    blocks.set(block.cid.toString(), block)\n  }\n\n  return { roots, blocks }\n}\n\n/**\n * @template {Partial<Model>} T\n * @param {API.ByteView<T>} bytes\n * @param {{hasher?: API.MultihashHasher }} options\n */\nexport const link = async (bytes, { hasher = sha256 } = {}) => {\n  return /** @type {API.Link<T, typeof code, typeof hasher.code>} */ (\n    createLink(code, await hasher.digest(bytes))\n  )\n}\n\n/**\n * @template {Partial<Model>} T\n * @param {T} data\n * @param {{hasher?: API.MultihashHasher }} [options]\n * @returns {Promise<API.Block<T, typeof code>>}\n */\nexport const write = async (data, options) => {\n  const bytes = encode(data)\n  const cid = await link(bytes, options)\n\n  return { bytes, cid }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;;;;;;;AAGO,MAAM,cAAc;AACpB,MAAM,OAAO;AAGb,MAAM,OAAO;AAEpB;;;;;CAKC,GAED,MAAM;IACJ;;;GAGC,GACD,YAAY,SAAS,EAAE,EAAE,aAAa,CAAC,CAAE;QACvC,IAAI,CAAC,OAAO,GAAG,IAAI;QACnB,IAAI,CAAC,MAAM,GAAG;QACd,IAAI,CAAC,UAAU,GAAG;IACpB;IACA;;GAEC,GACD,MAAM,GAAG,MAAM,EAAE;QACf,KAAK,MAAM,SAAS,OAAQ;YAC1B,MAAM,KAAK,MAAM,GAAG,CAAC,QAAQ,CAAC,+MAAM;YACpC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK;gBACzB,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;gBACjB,IAAI,CAAC,UAAU,IAAI,0KAA2B,CACxB;gBAEtB,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC;YACnB;QACF;QACA,OAAO,IAAI;IACb;IACA;;GAEC,GACD,MAAM,GAAG,UAAU,EAAE;QACnB,MAAM,QAAQ,EAAE;QAChB,2EAA2E;QAC3E,KAAK,MAAM,SAAS,WAAW,OAAO,GAAI;YACxC,MAAM,KAAK,MAAM,GAAG,CAAC,QAAQ,CAAC,+MAAM;YACpC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,KAAK;gBACzB,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC;gBACpB,IAAI,CAAC,UAAU,IAAI,0KAA2B,CAAC;oBAC7C,KAAyC,MAAM,GAAG;oBAClD,OAAO,MAAM,KAAK;gBACpB;gBACA,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC;YACnB;YAEA,qEAAqE;YACrE,MAAM,OAAO,CAAqC,MAAM,GAAG;QAC7D;QAEA,IAAI,CAAC,UAAU,IAAI,2KAA4B,CAAC;YAAE;QAAM;QAExD,MAAM,SAAS,IAAI,YAAY,IAAI,CAAC,UAAU;QAC9C,MAAM,SAAS,2KAA4B,CAAC,QAAQ;YAAE;QAAM;QAE5D,KAAK,MAAM,SAAiD,IAAI,CAAC,MAAM,CAAG;YACxE,OAAO,KAAK,CAAC;QACf;QAEA,OAAO,OAAO,KAAK;IACrB;AACF;AAEO,MAAM,eAAe,IAAM,IAAI;AAO/B,MAAM,SAAS,CAAC,EAAE,QAAQ,EAAE,EAAE,MAAM,EAAE;IAC3C,MAAM,SAAS,IAAI;IACnB,IAAI,QAAQ;QACV,OAAO,KAAK,IAAI,OAAO,MAAM;IAC/B;IACA,OAAO,OAAO,KAAK,IAAI;AACzB;AAMO,MAAM,SAAS,CAAA;IACpB,MAAM,SAAS,yLAAe,CAAC,SAAS,CAAC;IACzC,4BAA4B,GAC5B,MAAM,QAAQ,EAAE;IAChB,MAAM,SAAS,IAAI;IAEnB,KAAK,MAAM,QAAQ,OAAO,QAAQ,GAAI;QACpC,MAAM,QAAsC,OAAO,GAAG,CAAC;QACvD,IAAI,OAAO;YACT,MAAM,IAAI,CAAC;QACb;IACF;IAEA,KAAK,MAAM,SAAS,OAAO,MAAM,GAAI;QACnC,OAAO,GAAG,CAAC,MAAM,GAAG,CAAC,QAAQ,IAAI;IACnC;IAEA,OAAO;QAAE;QAAO;IAAO;AACzB;AAOO,MAAM,OAAO,OAAO,OAAO,EAAE,SAAS,yNAAM,EAAE,GAAG,CAAC,CAAC;IACxD,OACE,IAAA,oMAAU,EAAC,MAAM,MAAM,OAAO,MAAM,CAAC;AAEzC;AAQO,MAAM,QAAQ,OAAO,MAAM;IAChC,MAAM,QAAQ,OAAO;IACrB,MAAM,MAAM,MAAM,KAAK,OAAO;IAE9B,OAAO;QAAE;QAAO;IAAI;AACtB","ignoreList":[0]}},
    {"offset": {"line": 358, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 363, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/core/src/result.js"],"sourcesContent":["import * as API from '@ucanto/interface'\n\n/**\n * Creates the success result containing given `value`. Throws if\n * `null` or `undefined` passed to encourage use of units instead.\n *\n * @template {{}|string|boolean|number} T\n * @param {T} value\n * @returns {{ok: T, error?:undefined}}\n */\nexport const ok = value => {\n  if (value == null) {\n    throw new TypeError(`ok(${value}) is not allowed, consider ok({}) instead`)\n  } else {\n    return { ok: value }\n  }\n}\n\n/**\n * Creates the failing result containing given `cause` of error.\n * Throws if `cause` is `null` or `undefined` to encourage\n * passing descriptive errors instead.\n *\n * @template {{}|string|boolean|number} X\n * @param {X} cause\n * @returns {{ok?:undefined, error:X}}\n */\nexport const error = cause => {\n  if (cause == null) {\n    throw new TypeError(\n      `error(${cause}) is not allowed, consider passing an error instead`\n    )\n  } else {\n    return { error: cause }\n  }\n}\n\n/**\n * Crash the program with a given `message`. This function is\n * intended to be used in places where it is impossible to\n * recover from an error. It is similar to `panic` function in\n * Rust.\n *\n * @param {string} message\n */\nexport const panic = message => {\n  throw new Failure(message)\n}\n/**\n * Creates the failing result containing an error with a given\n * `message`. Unlike `error` function it creates a very generic\n *  error with `message` & `stack` fields. The `error` function\n * is recommended over `fail` for all but the most basic use cases.\n *\n * @param {string} message\n * @returns {{error:API.Failure, ok?:undefined}}\n */\nexport const fail = message => ({ error: new Failure(message) })\n\n/**\n * @implements {API.Failure}\n */\nexport class Failure extends Error {\n  describe() {\n    return this.toString()\n  }\n  get message() {\n    return this.describe()\n  }\n  toJSON() {\n    const { name, message, stack } = this\n    return { name, message, stack }\n  }\n}\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;;AAUO,MAAM,KAAK,CAAA;IAChB,IAAI,SAAS,MAAM;QACjB,MAAM,IAAI,UAAU,CAAC,GAAG,EAAE,MAAM,yCAAyC,CAAC;IAC5E,OAAO;QACL,OAAO;YAAE,IAAI;QAAM;IACrB;AACF;AAWO,MAAM,QAAQ,CAAA;IACnB,IAAI,SAAS,MAAM;QACjB,MAAM,IAAI,UACR,CAAC,MAAM,EAAE,MAAM,mDAAmD,CAAC;IAEvE,OAAO;QACL,OAAO;YAAE,OAAO;QAAM;IACxB;AACF;AAUO,MAAM,QAAQ,CAAA;IACnB,MAAM,IAAI,QAAQ;AACpB;AAUO,MAAM,OAAO,CAAA,UAAW,CAAC;QAAE,OAAO,IAAI,QAAQ;IAAS,CAAC;AAKxD,MAAM,gBAAgB;IAC3B,WAAW;QACT,OAAO,IAAI,CAAC,QAAQ;IACtB;IACA,IAAI,UAAU;QACZ,OAAO,IAAI,CAAC,QAAQ;IACtB;IACA,SAAS;QACP,MAAM,EAAE,IAAI,EAAE,OAAO,EAAE,KAAK,EAAE,GAAG,IAAI;QACrC,OAAO;YAAE;YAAM;YAAS;QAAM;IAChC;AACF","ignoreList":[0]}},
    {"offset": {"line": 421, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/core/src/schema/schema.js"],"sourcesContent":["import * as Schema from './type.js'\nimport { ok, Failure } from '../result.js'\nexport * from './type.js'\n\nexport { ok }\n/**\n * @abstract\n * @template [T=unknown]\n * @template [I=unknown]\n * @template [Settings=void]\n * @extends {Schema.Base<T, I, Settings>}\n * @implements {Schema.Schema<T, I>}\n */\nexport class API {\n  /**\n   * @param {Settings} settings\n   */\n  constructor(settings) {\n    this.settings = settings\n  }\n\n  toString() {\n    return `new ${this.constructor.name}()`\n  }\n  /**\n   * @abstract\n   * @param {I} input\n   * @param {Settings} settings\n   * @returns {Schema.ReadResult<T>}\n   */\n  /* c8 ignore next 3 */\n  readWith(input, settings) {\n    throw new Error(`Abstract method readWith must be implemented by subclass`)\n  }\n  /**\n   * @param {I} input\n   * @returns {Schema.ReadResult<T>}\n   */\n  read(input) {\n    return this.readWith(input, this.settings)\n  }\n\n  /**\n   * @param {unknown} value\n   * @returns {value is T}\n   */\n  is(value) {\n    return !this.read(/** @type {I} */ (value))?.error\n  }\n\n  /**\n   * @param {unknown} value\n   * @return {T}\n   */\n  from(value) {\n    const result = this.read(/** @type {I} */ (value))\n    if (result.error) {\n      throw result.error\n    } else {\n      return result.ok\n    }\n  }\n\n  /**\n   * @returns {Schema.Schema<T|undefined, I>}\n   */\n  optional() {\n    return optional(this)\n  }\n\n  /**\n   * @returns {Schema.Schema<T|null, I>}\n   */\n  nullable() {\n    return nullable(this)\n  }\n\n  /**\n   * @returns {Schema.Schema<T[], I>}\n   */\n  array() {\n    return array(this)\n  }\n  /**\n   * @template U\n   * @param {Schema.Reader<U, I>} schema\n   * @returns {Schema.Schema<T | U, I>}\n   */\n\n  or(schema) {\n    return or(this, schema)\n  }\n\n  /**\n   * @template U\n   * @param {Schema.Reader<U, I>} schema\n   * @returns {Schema.Schema<T & U, I>}\n   */\n  and(schema) {\n    return and(this, schema)\n  }\n\n  /**\n   * @template {T} U\n   * @param {Schema.Reader<U, T>} schema\n   * @returns {Schema.Schema<U, I>}\n   */\n  refine(schema) {\n    return refine(this, schema)\n  }\n\n  /**\n   * @template {string} Kind\n   * @param {Kind} [kind]\n   * @returns {Schema.Schema<Schema.Branded<T, Kind>, I>}\n   */\n  brand(kind) {\n    return /** @type {Schema.Schema<Schema.Branded<T, Kind>, I>} */ (this)\n  }\n\n  /**\n   * @param {Schema.NotUndefined<T>} value\n   * @returns {Schema.DefaultSchema<Schema.NotUndefined<T>, I>}\n   */\n  default(value) {\n    // ⚠️ this.from will throw if wrong default is provided\n    const fallback = this.from(value)\n    // we also check that fallback is not undefined because that is the point\n    // of having a fallback\n    if (fallback === undefined) {\n      throw new Error(`Value of type undefined is not a valid default`)\n    }\n\n    const schema = new Default({\n      reader: /** @type {Schema.Reader<T, I>} */ (this),\n      value: /** @type {Schema.NotUndefined<T>} */ (fallback),\n    })\n\n    return /** @type {Schema.DefaultSchema<Schema.NotUndefined<T>, I>} */ (\n      schema\n    )\n  }\n}\n\n/**\n * @template [I=unknown]\n * @extends {API<never, I>}\n * @implements {Schema.Schema<never, I>}\n */\nclass Never extends API {\n  toString() {\n    return 'never()'\n  }\n  /**\n   * @param {I} input\n   * @returns {Schema.ReadResult<never>}\n   */\n  read(input) {\n    return typeError({ expect: 'never', actual: input })\n  }\n}\n\n/**\n * @template [I=unknown]\n * @returns {Schema.Schema<never, I>}\n */\nexport const never = () => new Never()\n\n/**\n * @template [I=unknown]\n * @extends API<unknown, I, void>\n * @implements {Schema.Schema<unknown, I>}\n */\nclass Unknown extends API {\n  /**\n   * @param {I} input\n   */\n  read(input) {\n    return /** @type {Schema.ReadResult<unknown>}*/ ({ ok: input })\n  }\n  toString() {\n    return 'unknown()'\n  }\n}\n\n/**\n * @template [I=unknown]\n * @returns {Schema.Schema<unknown, I>}\n */\nexport const unknown = () => new Unknown()\n\n/**\n * @template O\n * @template [I=unknown]\n * @extends {API<null|O, I, Schema.Reader<O, I>>}\n * @implements {Schema.Schema<null|O, I>}\n */\nclass Nullable extends API {\n  /**\n   * @param {I} input\n   * @param {Schema.Reader<O, I>} reader\n   */\n  readWith(input, reader) {\n    const result = reader.read(input)\n    if (result.error) {\n      return input === null\n        ? { ok: null }\n        : {\n            error: new UnionError({\n              causes: [\n                result.error,\n                typeError({ expect: 'null', actual: input }).error,\n              ],\n            }),\n          }\n    } else {\n      return result\n    }\n  }\n  toString() {\n    return `${this.settings}.nullable()`\n  }\n}\n\n/**\n * @template O\n * @template [I=unknown]\n * @param {Schema.Reader<O, I>} schema\n * @returns {Schema.Schema<O|null, I>}\n */\nexport const nullable = schema => new Nullable(schema)\n\n/**\n * @template O\n * @template [I=unknown]\n * @extends {API<O|undefined, I, Schema.Reader<O, I>>}\n * @implements {Schema.Schema<O|undefined, I>}\n */\nclass Optional extends API {\n  optional() {\n    return this\n  }\n  /**\n   * @param {I} input\n   * @param {Schema.Reader<O, I>} reader\n   * @returns {Schema.ReadResult<O|undefined>}\n   */\n  readWith(input, reader) {\n    const result = reader.read(input)\n    return result.error && input === undefined ? { ok: undefined } : result\n  }\n  toString() {\n    return `${this.settings}.optional()`\n  }\n}\n\n/**\n * @template {unknown} O\n * @template [I=unknown]\n * @extends {API<O, I, {reader:Schema.Reader<O, I>, value:O & Schema.NotUndefined<O>}>}\n * @implements {Schema.DefaultSchema<O, I>}\n */\nclass Default extends API {\n  /**\n   * @returns {Schema.DefaultSchema<O & Schema.NotUndefined<O>, I>}\n   */\n  optional() {\n    // Short circuit here as we there is no point in wrapping this in optional.\n    return /** @type {Schema.DefaultSchema<O & Schema.NotUndefined<O>, I>} */ (\n      this\n    )\n  }\n  /**\n   * @param {I} input\n   * @param {object} options\n   * @param {Schema.Reader<O|undefined, I>} options.reader\n   * @param {O} options.value\n   * @returns {Schema.ReadResult<O>}\n   */\n  readWith(input, { reader, value }) {\n    if (input === undefined) {\n      return /** @type {Schema.ReadResult<O>} */ ({ ok: value })\n    } else {\n      const result = reader.read(input)\n\n      return result.error\n        ? result\n        : result.ok !== undefined\n        ? // We just checked that result.ok is not undefined but still needs\n          // reassurance\n          /** @type {Schema.ReadResult<O>} */ (result)\n        : { ok: value }\n    }\n  }\n  toString() {\n    return `${this.settings.reader}.default(${JSON.stringify(\n      this.settings.value\n    )})`\n  }\n\n  get value() {\n    return this.settings.value\n  }\n}\n\n/**\n * @template O\n * @template [I=unknown]\n * @param {Schema.Reader<O, I>} schema\n * @returns {Schema.Schema<O|undefined, I>}\n */\nexport const optional = schema => new Optional(schema)\n\n/**\n * @template O\n * @template [I=unknown]\n * @extends {API<O[], I, Schema.Reader<O, I>>}\n * @implements {Schema.ArraySchema<O, I>}\n */\nclass ArrayOf extends API {\n  /**\n   * @param {I} input\n   * @param {Schema.Reader<O, I>} schema\n   */\n  readWith(input, schema) {\n    if (!Array.isArray(input)) {\n      return typeError({ expect: 'array', actual: input })\n    }\n    /** @type {O[]} */\n    const results = []\n    for (const [index, value] of input.entries()) {\n      const result = schema.read(value)\n      if (result.error) {\n        return memberError({ at: index, cause: result.error })\n      } else {\n        results.push(result.ok)\n      }\n    }\n    return { ok: results }\n  }\n  get element() {\n    return this.settings\n  }\n  toString() {\n    return `array(${this.element})`\n  }\n}\n\n/**\n * @template O\n * @template [I=unknown]\n * @param {Schema.Reader<O, I>} schema\n * @returns {Schema.ArraySchema<O, I>}\n */\nexport const array = schema => new ArrayOf(schema)\n\n/**\n * @template {Schema.Reader<unknown, I>} T\n * @template {[T, ...T[]]} U\n * @template [I=unknown]\n * @extends {API<Schema.InferTuple<U>, I, U>}\n * @implements {Schema.Schema<Schema.InferTuple<U>, I>}\n */\nclass Tuple extends API {\n  /**\n   * @param {I} input\n   * @param {U} shape\n   * @returns {Schema.ReadResult<Schema.InferTuple<U>>}\n   */\n  readWith(input, shape) {\n    if (!Array.isArray(input)) {\n      return typeError({ expect: 'array', actual: input })\n    }\n    if (input.length !== this.shape.length) {\n      return error(`Array must contain exactly ${this.shape.length} elements`)\n    }\n\n    const results = []\n    for (const [index, reader] of shape.entries()) {\n      const result = reader.read(input[index])\n      if (result.error) {\n        return memberError({ at: index, cause: result.error })\n      } else {\n        results[index] = result.ok\n      }\n    }\n\n    return { ok: /** @type {Schema.InferTuple<U>} */ (results) }\n  }\n\n  /** @type {U} */\n  get shape() {\n    return this.settings\n  }\n\n  toString() {\n    return `tuple([${this.shape.map(reader => reader.toString()).join(', ')}])`\n  }\n}\n\n/**\n * @template {Schema.Reader<unknown, I>} T\n * @template {[T, ...T[]]} U\n * @template [I=unknown]\n * @param {U} shape\n * @returns {Schema.Schema<Schema.InferTuple<U>, I>}\n */\nexport const tuple = shape => new Tuple(shape)\n\n/**\n * @template V\n * @template {string} K\n * @template [I=unknown]\n * @extends {API<Schema.Dictionary<K, V>, I, { key: Schema.Reader<K, string>, value: Schema.Reader<V, I> }>}\n * @implements {Schema.DictionarySchema<V, K, I>}\n */\nclass Dictionary extends API {\n  /**\n   * @param {I} input\n   * @param {object} schema\n   * @param {Schema.Reader<K, string>} schema.key\n   * @param {Schema.Reader<V, I>} schema.value\n   */\n  readWith(input, { key, value }) {\n    if (typeof input != 'object' || input === null || Array.isArray(input)) {\n      return typeError({\n        expect: 'dictionary',\n        actual: input,\n      })\n    }\n\n    const dict = /** @type {Schema.Dictionary<K, V>} */ ({})\n\n    for (const [k, v] of Object.entries(input)) {\n      const keyResult = key.read(k)\n      if (keyResult.error) {\n        return memberError({ at: k, cause: keyResult.error })\n      }\n\n      const valueResult = value.read(v)\n      if (valueResult.error) {\n        return memberError({ at: k, cause: valueResult.error })\n      }\n\n      // skip undefined because they mess up CBOR and are generally useless.\n      if (valueResult.ok !== undefined) {\n        dict[keyResult.ok] = valueResult.ok\n      }\n    }\n\n    return { ok: dict }\n  }\n  get key() {\n    return this.settings.key\n  }\n  get value() {\n    return this.settings.value\n  }\n\n  partial() {\n    const { key, value } = this.settings\n    return new Dictionary({\n      key,\n      value: optional(value),\n    })\n  }\n  toString() {\n    return `dictionary(${this.settings})`\n  }\n}\n\n/**\n * @template {string} K\n * @template {unknown} V\n * @template [I=unknown]\n * @param {object} shape\n * @param {Schema.Reader<V, I>} shape.value\n * @param {Schema.Reader<K, string>} [shape.key]\n * @returns {Schema.DictionarySchema<V, K, I>}\n */\nexport const dictionary = ({ value, key }) =>\n  new Dictionary({\n    value,\n    key: key || /** @type {Schema.Reader<K, string>} */ (string()),\n  })\n\n/**\n * @template {[unknown, ...unknown[]]} T\n * @template [I=unknown]\n * @extends {API<T[number], I, {type: string, variants:Set<T[number]>}>}\n * @implements {Schema.Schema<T[number], I>}\n */\nclass Enum extends API {\n  /**\n   * @param {I} input\n   * @param {{type:string, variants:Set<T[number]>}} settings\n   * @returns {Schema.ReadResult<T[number]>}\n   */\n  readWith(input, { variants, type }) {\n    if (variants.has(input)) {\n      return /** @type {Schema.ReadResult<T[number]>} */ ({ ok: input })\n    } else {\n      return typeError({ expect: type, actual: input })\n    }\n  }\n  toString() {\n    return this.settings.type\n  }\n}\n\n/**\n * @template {string} T\n * @template {[T, ...T[]]} U\n * @template [I=unknown]\n * @param {U} variants\n * @returns {Schema.Schema<U[number], I>}\n */\nconst createEnum = variants =>\n  new Enum({\n    type: variants.join('|'),\n    variants: new Set(variants),\n  })\nexport { createEnum as enum }\n\n/**\n * @template {Schema.Reader<unknown, I>} T\n * @template {[T, ...T[]]} U\n * @template [I=unknown]\n * @extends {API<Schema.InferUnion<U>, I, U>}\n * @implements {Schema.Schema<Schema.InferUnion<U>, I>}\n */\nclass Union extends API {\n  /**\n   * @param {I} input\n   * @param {U} variants\n   */\n  readWith(input, variants) {\n    const causes = []\n    for (const reader of variants) {\n      const result = reader.read(input)\n      if (result.error) {\n        causes.push(result.error)\n      } else {\n        return /** @type {Schema.ReadResult<Schema.InferUnion<U>>} */ (result)\n      }\n    }\n    return { error: new UnionError({ causes }) }\n  }\n\n  get variants() {\n    return this.settings\n  }\n  toString() {\n    return `union([${this.variants.map(type => type.toString()).join(', ')}])`\n  }\n}\n\n/**\n * @template {Schema.Reader<unknown, I>} T\n * @template {[T, ...T[]]} U\n * @template [I=unknown]\n * @param {U} variants\n * @returns {Schema.Schema<Schema.InferUnion<U>, I>}\n */\nexport const union = variants => new Union(variants)\n\n/**\n * @template T, U\n * @template [I=unknown]\n * @param {Schema.Reader<T, I>} left\n * @param {Schema.Reader<U, I>} right\n * @returns {Schema.Schema<T|U, I>}\n */\nexport const or = (left, right) => union([left, right])\n\n/**\n * @template {Schema.Reader<unknown, I>} T\n * @template {[T, ...T[]]} U\n * @template [I=unknown]\n * @extends {API<Schema.InferIntersection<U>, I, U>}\n * @implements {Schema.Schema<Schema.InferIntersection<U>, I>}\n */\nclass Intersection extends API {\n  /**\n   * @param {I} input\n   * @param {U} schemas\n   * @returns {Schema.ReadResult<Schema.InferIntersection<U>>}\n   */\n  readWith(input, schemas) {\n    const causes = []\n    for (const schema of schemas) {\n      const result = schema.read(input)\n      if (result.error) {\n        causes.push(result.error)\n      }\n    }\n\n    return causes.length > 0\n      ? { error: new IntersectionError({ causes }) }\n      : /** @type {Schema.ReadResult<Schema.InferIntersection<U>>} */ ({\n          ok: input,\n        })\n  }\n  toString() {\n    return `intersection([${this.settings\n      .map(type => type.toString())\n      .join(',')}])`\n  }\n}\n\n/**\n * @template {Schema.Reader<unknown, I>} T\n * @template {[T, ...T[]]} U\n * @template [I=unknown]\n * @param {U} variants\n * @returns {Schema.Schema<Schema.InferIntersection<U>, I>}\n */\nexport const intersection = variants => new Intersection(variants)\n\n/**\n * @template T, U\n * @template [I=unknown]\n * @param {Schema.Reader<T, I>} left\n * @param {Schema.Reader<U, I>} right\n * @returns {Schema.Schema<T & U, I>}\n */\nexport const and = (left, right) => intersection([left, right])\n\n/**\n * @template [I=unknown]\n * @extends {API<boolean, I>}\n */\nclass Boolean extends API {\n  /**\n   * @param {I} input\n   */\n  readWith(input) {\n    switch (input) {\n      case true:\n      case false:\n        return { ok: /** @type {boolean} */ (input) }\n      default:\n        return typeError({\n          expect: 'boolean',\n          actual: input,\n        })\n    }\n  }\n\n  toString() {\n    return `boolean()`\n  }\n}\n\n/** @type {Schema.Schema<boolean, unknown>} */\nconst anyBoolean = new Boolean()\n\nexport const boolean = () => anyBoolean\n\n/**\n * @template {number} [O=number]\n * @template [I=unknown]\n * @template [Settings=void]\n * @extends {API<O, I, Settings>}\n * @implements {Schema.NumberSchema<O, I>}\n */\nclass UnknownNumber extends API {\n  /**\n   * @param {number} n\n   */\n  greaterThan(n) {\n    return this.refine(greaterThan(n))\n  }\n  /**\n   * @param {number} n\n   */\n  lessThan(n) {\n    return this.refine(lessThan(n))\n  }\n\n  /**\n   * @template {O} U\n   * @param {Schema.Reader<U, O>} schema\n   * @returns {Schema.NumberSchema<U, I>}\n   */\n  refine(schema) {\n    return new RefinedNumber({ base: this, schema })\n  }\n}\n\n/**\n * @template [I=unknown]\n * @extends {UnknownNumber<number, I>}\n * @implements {Schema.NumberSchema<number, I>}\n */\nclass AnyNumber extends UnknownNumber {\n  /**\n   * @param {I} input\n   * @returns {Schema.ReadResult<number>}\n   */\n  readWith(input) {\n    return typeof input === 'number'\n      ? { ok: input }\n      : typeError({ expect: 'number', actual: input })\n  }\n  toString() {\n    return `number()`\n  }\n}\n\n/** @type {Schema.NumberSchema<number, unknown>} */\nconst anyNumber = new AnyNumber()\nexport const number = () => anyNumber\n\n/**\n * @template {number} [T=number]\n * @template {T} [O=T]\n * @template [I=unknown]\n * @extends {UnknownNumber<O, I, {base:Schema.Reader<T, I>, schema:Schema.Reader<O, T>}>}\n * @implements {Schema.NumberSchema<O, I>}\n */\nclass RefinedNumber extends UnknownNumber {\n  /**\n   * @param {I} input\n   * @param {{base:Schema.Reader<T, I>, schema:Schema.Reader<O, T>}} settings\n   * @returns {Schema.ReadResult<O>}\n   */\n  readWith(input, { base, schema }) {\n    const result = base.read(input)\n    return result.error ? result : schema.read(result.ok)\n  }\n  toString() {\n    return `${this.settings.base}.refine(${this.settings.schema})`\n  }\n}\n\n/**\n * @template {number} T\n * @extends {API<T, T, number>}\n */\nclass LessThan extends API {\n  /**\n   * @param {T} input\n   * @param {number} number\n   * @returns {Schema.ReadResult<T>}\n   */\n  readWith(input, number) {\n    if (input < number) {\n      return { ok: input }\n    } else {\n      return error(`Expected ${input} < ${number}`)\n    }\n  }\n  toString() {\n    return `lessThan(${this.settings})`\n  }\n}\n\n/**\n * @template {number} T\n * @param {number} n\n * @returns {Schema.Schema<T, T>}\n */\nexport const lessThan = n => new LessThan(n)\n\n/**\n * @template {number} T\n * @extends {API<T, T, number>}\n */\nclass GreaterThan extends API {\n  /**\n   * @param {T} input\n   * @param {number} number\n   * @returns {Schema.ReadResult<T>}\n   */\n  readWith(input, number) {\n    if (input > number) {\n      return { ok: input }\n    } else {\n      return error(`Expected ${input} > ${number}`)\n    }\n  }\n  toString() {\n    return `greaterThan(${this.settings})`\n  }\n}\n\n/**\n * @template {number} T\n * @param {number} n\n * @returns {Schema.Schema<T, T>}\n */\nexport const greaterThan = n => new GreaterThan(n)\n\nconst Integer = {\n  /**\n   * @param {number} input\n   * @returns {Schema.ReadResult<Schema.Integer>}\n   */\n  read(input) {\n    return Number.isInteger(input)\n      ? { ok: /** @type {Schema.Integer} */ (input) }\n      : typeError({\n          expect: 'integer',\n          actual: input,\n        })\n  },\n  toString() {\n    return `Integer`\n  },\n}\n\nconst anyInteger = anyNumber.refine(Integer)\nexport const integer = () => anyInteger\n\nconst MAX_UINT64 = 2n ** 64n - 1n\n\n/**\n * @template {bigint} [O=Schema.Uint64]\n * @template [I=unknown]\n * @extends {API<O, I, void>}\n * @implements {Schema.Schema<O, I>}\n */\nclass Uint64Schema extends API {\n  /**\n   * @param {I} input\n   * @returns {Schema.ReadResult<O>}\n   */\n  read(input) {\n    switch (typeof input) {\n      case 'bigint':\n        return input > MAX_UINT64\n          ? error(`Integer is too big for uint64, ${input} > ${MAX_UINT64}`)\n          : input < 0\n          ? error(\n              `Negative integer can not be represented as uint64, ${input} < ${0}`\n            )\n          : { ok: /** @type {I & O} */ (input) }\n\n      case 'number':\n        return !Number.isInteger(input)\n          ? typeError({\n              expect: 'uint64',\n              actual: input,\n            })\n          : input < 0\n          ? error(\n              `Negative integer can not be represented as uint64, ${input} < ${0}`\n            )\n          : { ok: /** @type {O} */ (BigInt(input)) }\n\n      default:\n        return typeError({\n          expect: 'uint64',\n          actual: input,\n        })\n    }\n  }\n\n  toString() {\n    return `uint64`\n  }\n}\n\n/** @type {Schema.Schema<Schema.Uint64, unknown>} */\nconst Uint64 = new Uint64Schema()\n\n/**\n * Creates a schema for {@link Schema.Uint64} values represented as  a`bigint`.\n *\n * ⚠️ Please note that while IPLD in principal considers the range of integers\n * to be infinite n practice, many libraries / codecs may choose to implement\n * things in such a way that numbers may have limited sizes.\n *\n * So please use this with caution and always ensure that used codecs do support\n * uint64.\n */\nexport const uint64 = () => Uint64\n\nconst Float = {\n  /**\n   * @param {number} number\n   * @returns {Schema.ReadResult<Schema.Float>}\n   */\n  read(number) {\n    return Number.isFinite(number)\n      ? { ok: /** @type {Schema.Float} */ (number) }\n      : typeError({\n          expect: 'Float',\n          actual: number,\n        })\n  },\n  toString() {\n    return 'Float'\n  },\n}\n\nconst anyFloat = anyNumber.refine(Float)\nexport const float = () => anyFloat\n\n/**\n * @template {string} [O=string]\n * @template [I=unknown]\n * @template [Settings=void]\n * @extends {API<O, I, Settings>}\n */\nclass UnknownString extends API {\n  /**\n   * @template {O|unknown} U\n   * @param {Schema.Reader<U, O>} schema\n   * @returns {Schema.StringSchema<O & U, I>}\n   */\n  refine(schema) {\n    const other = /** @type {Schema.Reader<U, O>} */ (schema)\n    const rest = new RefinedString({\n      base: this,\n      schema: other,\n    })\n\n    return /** @type {Schema.StringSchema<O & U, I>} */ (rest)\n  }\n  /**\n   * @template {string} Prefix\n   * @param {Prefix} prefix\n   */\n  startsWith(prefix) {\n    return this.refine(startsWith(prefix))\n  }\n  /**\n   * @template {string} Suffix\n   * @param {Suffix} suffix\n   */\n  endsWith(suffix) {\n    return this.refine(endsWith(suffix))\n  }\n  toString() {\n    return `string()`\n  }\n}\n\n/**\n * @template O\n * @template {string} [T=string]\n * @template [I=unknown]\n * @extends {UnknownString<T & O, I, {base:Schema.Reader<T, I>, schema:Schema.Reader<O, T>}>}\n * @implements {Schema.StringSchema<O & T, I>}\n */\nclass RefinedString extends UnknownString {\n  /**\n   * @param {I} input\n   * @param {{base:Schema.Reader<T, I>, schema:Schema.Reader<O, T>}} settings\n   * @returns {Schema.ReadResult<T & O>}\n   */\n  readWith(input, { base, schema }) {\n    const result = base.read(input)\n    return result.error\n      ? result\n      : /** @type {Schema.ReadResult<T & O>} */ (schema.read(result.ok))\n  }\n  toString() {\n    return `${this.settings.base}.refine(${this.settings.schema})`\n  }\n}\n\n/**\n * @template [I=unknown]\n * @extends {UnknownString<string, I>}\n * @implements {Schema.StringSchema<string, I>}\n */\nclass AnyString extends UnknownString {\n  /**\n   * @param {I} input\n   * @returns {Schema.ReadResult<string>}\n   */\n  readWith(input) {\n    return typeof input === 'string'\n      ? { ok: input }\n      : typeError({ expect: 'string', actual: input })\n  }\n}\n\n/** @type {Schema.StringSchema<string, unknown>} */\nconst anyString = new AnyString()\nexport const string = () => anyString\n\n/**\n * @template [I=unknown]\n * @extends {API<Uint8Array, I, void>}\n */\nclass BytesSchema extends API {\n  /**\n   * @param {I} input\n   * @returns {Schema.ReadResult<Uint8Array>}\n   */\n  readWith(input) {\n    if (input instanceof Uint8Array) {\n      return { ok: input }\n    } else {\n      return typeError({ expect: 'Uint8Array', actual: input })\n    }\n  }\n}\n\n/** @type {Schema.Schema<Uint8Array, unknown>} */\nexport const Bytes = new BytesSchema()\nexport const bytes = () => Bytes\n\n/**\n * @template {string} Prefix\n * @template {string} Body\n * @extends {API<Body & `${Prefix}${Body}`, Body, Prefix>}\n * @implements {Schema.Schema<Body & `${Prefix}${Body}`, Body>}\n */\nclass StartsWith extends API {\n  /**\n   * @param {Body} input\n   * @param {Prefix} prefix\n   */\n  readWith(input, prefix) {\n    const result = input.startsWith(prefix)\n      ? /** @type {Schema.ReadResult<Body & `${Prefix}${Body}`>} */ ({\n          ok: input,\n        })\n      : error(`Expect string to start with \"${prefix}\" instead got \"${input}\"`)\n\n    return result\n  }\n  get prefix() {\n    return this.settings\n  }\n  toString() {\n    return `startsWith(\"${this.prefix}\")`\n  }\n}\n\n/**\n * @template {string} Prefix\n * @template {string} Body\n * @param {Prefix} prefix\n * @returns {Schema.Schema<`${Prefix}${string}`, string>}\n */\nexport const startsWith = prefix => new StartsWith(prefix)\n\n/**\n * @template {string} Suffix\n * @template {string} Body\n * @extends {API<Body & `${Body}${Suffix}`, Body, Suffix>}\n */\nclass EndsWith extends API {\n  /**\n   * @param {Body} input\n   * @param {Suffix} suffix\n   */\n  readWith(input, suffix) {\n    return input.endsWith(suffix)\n      ? /** @type {Schema.ReadResult<Body & `${Body}${Suffix}`>} */ ({\n          ok: input,\n        })\n      : error(`Expect string to end with \"${suffix}\" instead got \"${input}\"`)\n  }\n  get suffix() {\n    return this.settings\n  }\n  toString() {\n    return `endsWith(\"${this.suffix}\")`\n  }\n}\n\n/**\n * @template {string} Suffix\n * @param {Suffix} suffix\n * @returns {Schema.Schema<`${string}${Suffix}`, string>}\n */\nexport const endsWith = suffix => new EndsWith(suffix)\n\n/**\n * @template T\n * @template {T} U\n * @template [I=unknown]\n * @extends {API<U, I, { base: Schema.Reader<T, I>, schema: Schema.Reader<U, T> }>}\n * @implements {Schema.Schema<U, I>}\n */\n\nclass Refine extends API {\n  /**\n   * @param {I} input\n   * @param {{ base: Schema.Reader<T, I>, schema: Schema.Reader<U, T> }} settings\n   */\n  readWith(input, { base, schema }) {\n    const result = base.read(input)\n    return result.error ? result : schema.read(result.ok)\n  }\n  toString() {\n    return `${this.settings.base}.refine(${this.settings.schema})`\n  }\n}\n\n/**\n * @template T\n * @template {T} U\n * @template [I=unknown]\n * @param {Schema.Reader<T, I>} base\n * @param {Schema.Reader<U, T>} schema\n * @returns {Schema.Schema<U, I>}\n */\nexport const refine = (base, schema) => new Refine({ base, schema })\n\n/**\n * @template {null|boolean|string|number} T\n * @template [I=unknown]\n * @extends {API<T, I, T>}\n * @implements {Schema.LiteralSchema<T, I>}\n */\nclass Literal extends API {\n  /**\n   * @param {I} input\n   * @param {T} expect\n   * @returns {Schema.ReadResult<T>}\n   */\n  readWith(input, expect) {\n    return input !== /** @type {unknown} */ (expect)\n      ? { error: new LiteralError({ expect, actual: input }) }\n      : { ok: expect }\n  }\n  get value() {\n    return /** @type {Exclude<T, undefined>} */ (this.settings)\n  }\n  /**\n   * @template {Schema.NotUndefined<T>} U\n   * @param {U} value\n   */\n  default(value = /** @type {U} */ (this.value)) {\n    return super.default(value)\n  }\n  toString() {\n    return `literal(${toString(this.value)})`\n  }\n}\n\n/**\n * @template {null|boolean|string|number} T\n * @template [I=unknown]\n * @param {T} value\n * @returns {Schema.LiteralSchema<T, I>}\n */\nexport const literal = value => new Literal(value)\n\n/**\n * @template {{[key:string]: Schema.Reader}} U\n * @template [I=unknown]\n * @extends {API<Schema.InferStruct<U>, I, U>}\n */\nclass Struct extends API {\n  /**\n   * @param {I} input\n   * @param {U} shape\n   * @returns {Schema.ReadResult<Schema.InferStruct<U>>}\n   */\n  readWith(input, shape) {\n    if (typeof input != 'object' || input === null || Array.isArray(input)) {\n      return typeError({\n        expect: 'object',\n        actual: input,\n      })\n    }\n\n    const source = /** @type {{[K in keyof U]: unknown}} */ (input)\n\n    const struct = /** @type {{[K in keyof U]: Schema.Infer<U[K]>}} */ ({})\n    const entries =\n      /** @type {{[K in keyof U]: [K & string, U[K]]}[keyof U][]} */ (\n        Object.entries(shape)\n      )\n\n    for (const [at, reader] of entries) {\n      const result = reader.read(source[at])\n      if (result.error) {\n        return memberError({ at, cause: result.error })\n      }\n      // skip undefined because they mess up CBOR and are generally useless.\n      else if (result.ok !== undefined) {\n        struct[at] = /** @type {Schema.Infer<U[typeof at]>} */ (result.ok)\n      }\n    }\n\n    return { ok: struct }\n  }\n\n  /**\n   * @returns {Schema.MapRepresentation<Partial<Schema.InferStruct<U>>> & Schema.StructSchema}\n   */\n  partial() {\n    return new Struct(\n      Object.fromEntries(\n        Object.entries(this.shape).map(([key, value]) => [key, optional(value)])\n      )\n    )\n  }\n\n  /** @type {U} */\n  get shape() {\n    // @ts-ignore - We declared `settings` private but we access it here\n    return this.settings\n  }\n\n  toString() {\n    return [\n      `struct({ `,\n      ...Object.entries(this.shape)\n        .map(([key, schema]) => `${key}: ${schema}`)\n        .join(', '),\n      ` })`,\n    ].join('')\n  }\n\n  /**\n   * @param {Schema.InferStructSource<U>} data\n   */\n  create(data) {\n    return this.from(data || {})\n  }\n\n  /**\n   * @template {{[key:string]: Schema.Reader}} E\n   * @param {E} extension\n   * @returns {Schema.StructSchema<U & E, I>}\n   */\n  extend(extension) {\n    return new Struct({ ...this.shape, ...extension })\n  }\n}\n\n/**\n * @template {null|boolean|string|number} T\n * @template {{[key:string]: T|Schema.Reader}} U\n * @template {{[K in keyof U]: U[K] extends Schema.Reader ? U[K] : Schema.LiteralSchema<U[K] & T>}} V\n * @template [I=unknown]\n * @param {U} fields\n * @returns {Schema.StructSchema<V, I>}\n */\nexport const struct = fields => {\n  const shape =\n    /** @type {{[K in keyof U]: Schema.Reader<unknown, unknown>}} */ ({})\n  /** @type {[keyof U & string, T|Schema.Reader][]} */\n  const entries = Object.entries(fields)\n\n  for (const [key, field] of entries) {\n    switch (typeof field) {\n      case 'number':\n      case 'string':\n      case 'boolean':\n        shape[key] = literal(field)\n        break\n      case 'object':\n        shape[key] = field === null ? literal(null) : field\n        break\n      default:\n        throw new Error(\n          `Invalid struct field \"${key}\", expected schema or literal, instead got ${typeof field}`\n        )\n    }\n  }\n\n  return new Struct(/** @type {V} */ (shape))\n}\n\n/**\n * @template {Schema.VariantChoices} U\n * @template [I=unknown]\n * @extends {API<Schema.InferVariant<U>, I, U>}\n * @implements {Schema.VariantSchema<U, I>}\n */\nclass Variant extends API {\n  /**\n   * @param {I} input\n   * @param {U} variants\n   * @returns {Schema.ReadResult<Schema.InferVariant<U>>}\n   */\n  readWith(input, variants) {\n    if (typeof input != 'object' || input === null || Array.isArray(input)) {\n      return typeError({\n        expect: 'object',\n        actual: input,\n      })\n    }\n\n    const keys = /** @type {Array<keyof input & keyof variants & string>} */ (\n      Object.keys(input)\n    )\n\n    const [key] = keys.length === 1 ? keys : []\n    const reader = key ? variants[key] : undefined\n\n    if (reader) {\n      const result = reader.read(input[key])\n      return result.error\n        ? memberError({ at: key, cause: result.error })\n        : { ok: /** @type {Schema.InferVariant<U>} */ ({ [key]: result.ok }) }\n    } else if (variants._) {\n      const result = variants._.read(input)\n      return result.error\n        ? result\n        : { ok: /** @type {Schema.InferVariant<U>} */ ({ _: result.ok }) }\n    } else if (key) {\n      return error(\n        `Expected an object with one of the these keys: ${Object.keys(variants)\n          .sort()\n          .join(', ')} instead got object with key ${key}`\n      )\n    } else {\n      return error(\n        'Expected an object with a single key instead got object with keys ' +\n          keys.sort().join(', ')\n      )\n    }\n  }\n\n  /**\n   * @template [E=never]\n   * @param {I} input\n   * @param {E} [fallback]\n   */\n  match(input, fallback) {\n    const result = this.read(input)\n    if (result.error) {\n      if (fallback !== undefined) {\n        return [null, fallback]\n      } else {\n        throw result.error\n      }\n    } else {\n      const [key] = Object.keys(result.ok)\n      const value = result.ok[key]\n      return /** @type {any} */ ([key, value])\n    }\n  }\n\n  /**\n   * @template {Schema.InferVariant<U>} O\n   * @param {O} source\n   * @returns {O}\n   */\n  create(source) {\n    return /** @type {O} */ (this.from(source))\n  }\n}\n\n/**\n * Defines a schema for the `Variant` type. It takes an object where\n * keys denote branches of the variant and values are schemas for the values of\n * those branches. The schema will only match objects with a single key and\n * value that matches the schema for that key. If the object has more than one\n * key or the key does not match any of the keys in the schema then the schema\n * will fail.\n *\n * The `_` branch is a special case. If such branch is present then it will be\n * used as a fallback for any object that does not match any of the variant\n * branches. The `_` branch will be used even if the object has more than one\n * key. Unlike other branches the `_` branch will receive the entire object as\n * input and not just the value of the key. Usually the `_` branch can be set\n * to `Schema.unknown` or `Schema.dictionary` to facilitate exhaustive matching.\n *\n * @example\n * ```ts\n * const Shape = Variant({\n *    circle: Schema.struct({ radius: Schema.integer() }),\n *    rectangle: Schema.struct({ width: Schema.integer(), height: Schema.integer() })\n * })\n *\n * const demo = (input:unknown) => {\n *   const [kind, value] = Schema.match(input)\n *   switch (kind) {\n *     case \"circle\":\n *       return `Circle with radius ${shape.radius}`\n *     case \"rectangle\":\n *       return `Rectangle with width ${shape.width} and height ${shape.height}`\n *    }\n * }\n *\n * const ExhaustiveShape = Variant({\n *   circle: Schema.struct({ radius: Schema.integer() }),\n *   rectangle: Schema.struct({ width: Schema.integer(), height: Schema.integer() }),\n *  _: Schema.dictionary({ value: Schema.unknown() })\n * })\n *\n * const exhastiveDemo = (input:unknown) => {\n *   const [kind, value] = Schema.match(input)\n *   switch (kind) {\n *     case \"circle\":\n *       return `Circle with radius ${shape.radius}`\n *     case \"rectangle\":\n *       return `Rectangle with width ${shape.width} and height ${shape.height}`\n *     case: \"_\":\n *       return `Unknown shape ${JSON.stringify(value)}`\n *    }\n * }\n * ```\n *\n * @template {Schema.VariantChoices} Choices\n * @template [In=unknown]\n * @param {Choices} variants\n * @returns {Schema.VariantSchema<Choices, In>}\n */\nexport const variant = variants => new Variant(variants)\n\n/**\n * @param {string} message\n * @returns {{error: Schema.Error, ok?: undefined}}\n */\nexport const error = message => ({ error: new SchemaError(message) })\n\nclass SchemaError extends Failure {\n  get name() {\n    return 'SchemaError'\n  }\n  /* c8 ignore next 3 */\n  describe() {\n    return this.name\n  }\n}\n\nclass TypeError extends SchemaError {\n  /**\n   * @param {{expect:string, actual:unknown}} data\n   */\n  constructor({ expect, actual }) {\n    super()\n    this.expect = expect\n    this.actual = actual\n  }\n  get name() {\n    return 'TypeError'\n  }\n  describe() {\n    return `Expected value of type ${this.expect} instead got ${toString(\n      this.actual\n    )}`\n  }\n}\n\n/**\n * @param {object} data\n * @param {string} data.expect\n * @param {unknown} data.actual\n * @returns {{ error: Schema.Error }}\n */\nexport const typeError = data => ({ error: new TypeError(data) })\n\n/**\n *\n * @param {unknown} value\n */\nexport const toString = value => {\n  const type = typeof value\n  switch (type) {\n    case 'boolean':\n    case 'string':\n      return JSON.stringify(value)\n    // if these types we do not want JSON.stringify as it may mess things up\n    // eg turn NaN and Infinity to null\n    case 'bigint':\n      return `${value}n`\n    case 'number':\n    case 'symbol':\n    case 'undefined':\n      return String(value)\n    case 'object':\n      return value === null\n        ? 'null'\n        : Array.isArray(value)\n        ? 'array'\n        : Symbol.toStringTag in /** @type {object} */ (value)\n        ? value[Symbol.toStringTag]\n        : 'object'\n    default:\n      return type\n  }\n}\n\nclass LiteralError extends SchemaError {\n  /**\n   * @param {{\n   * expect:string|number|boolean|null\n   * actual:unknown\n   * }} data\n   */\n  constructor({ expect, actual }) {\n    super()\n    this.expect = expect\n    this.actual = actual\n  }\n  get name() {\n    return 'LiteralError'\n  }\n  describe() {\n    return `Expected literal ${toString(this.expect)} instead got ${toString(\n      this.actual\n    )}`\n  }\n}\n\nclass ElementError extends SchemaError {\n  /**\n   * @param {{at:number, cause:Schema.Error}} data\n   */\n  constructor({ at, cause }) {\n    super()\n    this.at = at\n    this.cause = cause\n  }\n  get name() {\n    return 'ElementError'\n  }\n  describe() {\n    return [\n      `Array contains invalid element at ${this.at}:`,\n      li(this.cause.message),\n    ].join('\\n')\n  }\n}\n\nclass FieldError extends SchemaError {\n  /**\n   * @param {{at:string, cause:Schema.Error}} data\n   */\n  constructor({ at, cause }) {\n    super()\n    this.at = at\n    this.cause = cause\n  }\n  get name() {\n    return 'FieldError'\n  }\n  describe() {\n    return [\n      `Object contains invalid field \"${this.at}\":`,\n      li(this.cause.message),\n    ].join('\\n')\n  }\n}\n\n/**\n * @param {object} options\n * @param {string|number} options.at\n * @param {Schema.Error} options.cause\n * @returns {{error: Schema.Error}}\n */\nexport const memberError = ({ at, cause }) =>\n  typeof at === 'string'\n    ? { error: new FieldError({ at, cause }) }\n    : { error: new ElementError({ at, cause }) }\n\nclass UnionError extends SchemaError {\n  /**\n   * @param {{causes: Schema.Error[]}} data\n   */\n  constructor({ causes }) {\n    super()\n    this.causes = causes\n  }\n  get name() {\n    return 'UnionError'\n  }\n  describe() {\n    const { causes } = this\n    return [\n      `Value does not match any type of the union:`,\n      ...causes.map(cause => li(cause.message)),\n    ].join('\\n')\n  }\n}\n\nclass IntersectionError extends SchemaError {\n  /**\n   * @param {{causes: Schema.Error[]}} data\n   */\n  constructor({ causes }) {\n    super()\n    this.causes = causes\n  }\n  get name() {\n    return 'IntersectionError'\n  }\n  describe() {\n    const { causes } = this\n    return [\n      `Value does not match following types of the intersection:`,\n      ...causes.map(cause => li(cause.message)),\n    ].join('\\n')\n  }\n}\n\n/**\n * @param {string} message\n */\nconst indent = (message, indent = '  ') =>\n  `${indent}${message.split('\\n').join(`\\n${indent}`)}`\n\n/**\n * @param {string} message\n */\nconst li = message => indent(`- ${message}`)\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 1717, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/core/src/schema/uri.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport * as Schema from './schema.js'\n\n/**\n * @template {API.Protocol} [P=API.Protocol]\n * @typedef {{protocol: P}} Options\n */\n\n/**\n * @template {Options} O\n * @extends {Schema.API<API.URI<O['protocol']>, unknown, Partial<O>>}\n */\nclass URISchema extends Schema.API {\n  /**\n   * @param {unknown} input\n   * @param {Partial<O>} options\n   * @returns {Schema.ReadResult<API.URI<O['protocol']>>}\n   */\n  readWith(input, { protocol } = {}) {\n    if (typeof input !== 'string' && !(input instanceof URL)) {\n      return Schema.error(\n        `Expected URI but got ${input === null ? 'null' : typeof input}`\n      )\n    }\n\n    try {\n      const url = new URL(String(input))\n      if (protocol != null && url.protocol !== protocol) {\n        return Schema.error(`Expected ${protocol} URI instead got ${url.href}`)\n      } else {\n        return { ok: /** @type {API.URI<O['protocol']>} */ (url.href) }\n      }\n    } catch (_) {\n      return Schema.error(`Invalid URI`)\n    }\n  }\n}\n\nconst schema = new URISchema({})\n\n/**\n * @returns {Schema.Schema<API.URI, unknown>}\n */\nexport const uri = () => schema\n\n/**\n * @param {unknown} input\n */\nexport const read = input => schema.read(input)\n\n/**\n * @template {API.Protocol} P\n * @template {Options<P>} O\n * @param {O} options\n * @returns {Schema.Schema<API.URI<O['protocol']>, unknown>}\n */\nexport const match = options => new URISchema(options)\n\n/**\n * @template {string} [Scheme=string]\n * @param {`${Scheme}:${string}`} input\n */\nexport const from = input =>\n  /** @type {API.URI<`${Scheme}:`>} */ (schema.from(input))\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;;;AAEA;;;CAGC,GAED;;;CAGC,GACD,MAAM,kBAAkB,qLAAU;IAChC;;;;GAIC,GACD,SAAS,KAAK,EAAE,EAAE,QAAQ,EAAE,GAAG,CAAC,CAAC,EAAE;QACjC,IAAI,OAAO,UAAU,YAAY,CAAC,CAAC,iBAAiB,GAAG,GAAG;YACxD,OAAO,uLAAY,CACjB,CAAC,qBAAqB,EAAE,UAAU,OAAO,SAAS,OAAO,OAAO;QAEpE;QAEA,IAAI;YACF,MAAM,MAAM,IAAI,IAAI,OAAO;YAC3B,IAAI,YAAY,QAAQ,IAAI,QAAQ,KAAK,UAAU;gBACjD,OAAO,uLAAY,CAAC,CAAC,SAAS,EAAE,SAAS,iBAAiB,EAAE,IAAI,IAAI,EAAE;YACxE,OAAO;gBACL,OAAO;oBAAE,IAA2C,IAAI,IAAI;gBAAE;YAChE;QACF,EAAE,OAAO,GAAG;YACV,OAAO,uLAAY,CAAC,CAAC,WAAW,CAAC;QACnC;IACF;AACF;AAEA,MAAM,SAAS,IAAI,UAAU,CAAC;AAKvB,MAAM,MAAM,IAAM;AAKlB,MAAM,OAAO,CAAA,QAAS,OAAO,IAAI,CAAC;AAQlC,MAAM,QAAQ,CAAA,UAAW,IAAI,UAAU;AAMvC,MAAM,OAAO,CAAA,QACoB,OAAO,IAAI,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1769, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/core/src/schema/link.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport { create, createLegacy, isLink, parse, base32 } from '../link.js'\nimport * as Schema from './schema.js'\n\nexport { create, createLegacy, isLink, parse }\n\n/**\n * @template {number} [Code=number]\n * @template {number} [Alg=number]\n * @template {1|0} [Version=0|1]\n * @typedef {{\n * code?:Code,\n * version?:Version\n * multihash?: {code?: Alg, digest?: Uint8Array}\n * }} Settings\n */\n\n/**\n * @template {number} Code\n * @template {number} Alg\n * @template {1|0} Version\n * @extends {Schema.API<API.Link<unknown, Code, Alg, Version>, unknown, Settings<Code, Alg, Version>>}\n */\nclass LinkSchema extends Schema.API {\n  /**\n   *\n   * @param {unknown} cid\n   * @param {Settings<Code, Alg, Version>} settings\n   * @returns {Schema.ReadResult<API.Link<unknown, Code, Alg, Version>>}\n   */\n  readWith(cid, { code, multihash = {}, version }) {\n    if (cid == null) {\n      return Schema.error(`Expected link but got ${cid} instead`)\n    } else {\n      if (!isLink(cid)) {\n        return Schema.error(`Expected link to be a CID instead of ${cid}`)\n      } else {\n        if (code != null && cid.code !== code) {\n          return Schema.error(\n            `Expected link to be CID with 0x${code.toString(16)} codec`\n          )\n        }\n\n        if (multihash.code != null && cid.multihash.code !== multihash.code)\n          return Schema.error(\n            `Expected link to be CID with 0x${multihash.code.toString(\n              16\n            )} hashing algorithm`\n          )\n\n        if (version != null && cid.version !== version) {\n          return Schema.error(\n            `Expected link to be CID version ${version} instead of ${cid.version}`\n          )\n        }\n\n        const [expectDigest, actualDigest] =\n          multihash.digest != null\n            ? [\n                base32.baseEncode(multihash.digest),\n                base32.baseEncode(cid.multihash.digest),\n              ]\n            : ['', '']\n\n        if (expectDigest !== actualDigest) {\n          return Schema.error(\n            `Expected link with \"${expectDigest}\" hash digest instead of \"${actualDigest}\"`\n          )\n        }\n\n        return {\n          ok: /** @type {API.Link<unknown, any, any, any>} */ (cid),\n        }\n      }\n    }\n  }\n}\n\n/** @type {Schema.Schema<API.Link<unknown, number, number, 0|1>, unknown>}  */\nexport const schema = new LinkSchema({})\n\nexport const link = () => schema\n\n/**\n * @template {number} Code\n * @template {number} Alg\n * @template {1|0} Version\n * @param {Settings<Code, Alg, Version>} options\n * @returns {Schema.Schema<API.Link<unknown, Code, Alg, Version>>}\n */\nexport const match = (options = {}) => new LinkSchema(options)\n\n/**\n * @param {unknown} input\n */\nexport const read = input => schema.read(input)\n\nexport const optional = () => schema.optional()\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;AACA;AAAA;AAAA;AACA;;;;;AAIA;;;;;;;;;CASC,GAED;;;;;CAKC,GACD,MAAM,mBAAmB,qLAAU;IACjC;;;;;GAKC,GACD,SAAS,GAAG,EAAE,EAAE,IAAI,EAAE,YAAY,CAAC,CAAC,EAAE,OAAO,EAAE,EAAE;QAC/C,IAAI,OAAO,MAAM;YACf,OAAO,uLAAY,CAAC,CAAC,sBAAsB,EAAE,IAAI,QAAQ,CAAC;QAC5D,OAAO;YACL,IAAI,CAAC,IAAA,oMAAM,EAAC,MAAM;gBAChB,OAAO,uLAAY,CAAC,CAAC,qCAAqC,EAAE,KAAK;YACnE,OAAO;gBACL,IAAI,QAAQ,QAAQ,IAAI,IAAI,KAAK,MAAM;oBACrC,OAAO,uLAAY,CACjB,CAAC,+BAA+B,EAAE,KAAK,QAAQ,CAAC,IAAI,MAAM,CAAC;gBAE/D;gBAEA,IAAI,UAAU,IAAI,IAAI,QAAQ,IAAI,SAAS,CAAC,IAAI,KAAK,UAAU,IAAI,EACjE,OAAO,uLAAY,CACjB,CAAC,+BAA+B,EAAE,UAAU,IAAI,CAAC,QAAQ,CACvD,IACA,kBAAkB,CAAC;gBAGzB,IAAI,WAAW,QAAQ,IAAI,OAAO,KAAK,SAAS;oBAC9C,OAAO,uLAAY,CACjB,CAAC,gCAAgC,EAAE,QAAQ,YAAY,EAAE,IAAI,OAAO,EAAE;gBAE1E;gBAEA,MAAM,CAAC,cAAc,aAAa,GAChC,UAAU,MAAM,IAAI,OAChB;oBACE,+MAAM,CAAC,UAAU,CAAC,UAAU,MAAM;oBAClC,+MAAM,CAAC,UAAU,CAAC,IAAI,SAAS,CAAC,MAAM;iBACvC,GACD;oBAAC;oBAAI;iBAAG;gBAEd,IAAI,iBAAiB,cAAc;oBACjC,OAAO,uLAAY,CACjB,CAAC,oBAAoB,EAAE,aAAa,0BAA0B,EAAE,aAAa,CAAC,CAAC;gBAEnF;gBAEA,OAAO;oBACL,IAAqD;gBACvD;YACF;QACF;IACF;AACF;AAGO,MAAM,SAAS,IAAI,WAAW,CAAC;AAE/B,MAAM,OAAO,IAAM;AASnB,MAAM,QAAQ,CAAC,UAAU,CAAC,CAAC,GAAK,IAAI,WAAW;AAK/C,MAAM,OAAO,CAAA,QAAS,OAAO,IAAI,CAAC;AAElC,MAAM,WAAW,IAAM,OAAO,QAAQ","ignoreList":[0]}},
    {"offset": {"line": 1850, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/core/src/schema/principal.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport * as DID from '@ipld/dag-ucan/did'\nimport * as Schema from './schema.js'\n\n/**\n * @template {string} Method\n * @extends {Schema.API<API.PrincipalView<API.DID<Method> & API.URI<\"did:\">>, unknown, void|Method>}\n */\nclass PrincipalSchema extends Schema.API {\n  /**\n   * @param {unknown} source\n   * @param {void|Method} method\n   */\n  readWith(source, method) {\n    if (!(source instanceof Uint8Array)) {\n      return Schema.typeError({ expect: 'Uint8Array', actual: source })\n    }\n    let principal\n    try {\n      principal = DID.decode(source)\n    } catch (err) {\n      return Schema.error(`Unable to decode bytes as DID: ${err}`)\n    }\n    const prefix = method ? `did:${method}:` : `did:`\n    if (!principal.did().startsWith(prefix)) {\n      return Schema.error(\n        `Expected a ${prefix} but got \"${principal.did()}\" instead`\n      )\n    }\n    return { ok: /** @type {API.PrincipalView<API.DID<Method>>} */ (principal) }\n  }\n}\n\nconst schema = new PrincipalSchema()\n\n/** A schema that reads byte encoded DIDs. */\nexport const principal = () => schema\n\n/** @param {unknown} input */\nexport const read = input => schema.read(input)\n\n/**\n * Matches a byte encoded DID.\n *\n * @template {string} Method\n * @param {{ method?: Method }} options\n */\nexport const match = (options = {}) =>\n  /** @type {Schema.Schema<API.PrincipalView<API.DID<Method> & API.URI<\"did:\">>>} */\n  (new PrincipalSchema(options.method))\n\n/**\n * Create a Principal from any input (or throw).\n *\n * @param {unknown} input\n */\nexport const from = input => match({}).from(input)\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AACA;;;;AAEA;;;CAGC,GACD,MAAM,wBAAwB,qLAAU;IACtC;;;GAGC,GACD,SAAS,MAAM,EAAE,MAAM,EAAE;QACvB,IAAI,CAAC,CAAC,kBAAkB,UAAU,GAAG;YACnC,OAAO,2LAAgB,CAAC;gBAAE,QAAQ;gBAAc,QAAQ;YAAO;QACjE;QACA,IAAI;QACJ,IAAI;YACF,YAAY,gKAAU,CAAC;QACzB,EAAE,OAAO,KAAK;YACZ,OAAO,uLAAY,CAAC,CAAC,+BAA+B,EAAE,KAAK;QAC7D;QACA,MAAM,SAAS,SAAS,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC;QACjD,IAAI,CAAC,UAAU,GAAG,GAAG,UAAU,CAAC,SAAS;YACvC,OAAO,uLAAY,CACjB,CAAC,WAAW,EAAE,OAAO,UAAU,EAAE,UAAU,GAAG,GAAG,SAAS,CAAC;QAE/D;QACA,OAAO;YAAE,IAAuD;QAAW;IAC7E;AACF;AAEA,MAAM,SAAS,IAAI;AAGZ,MAAM,YAAY,IAAM;AAGxB,MAAM,OAAO,CAAA,QAAS,OAAO,IAAI,CAAC;AAQlC,MAAM,QAAQ,CAAC,UAAU,CAAC,CAAC,GAE/B,IAAI,gBAAgB,QAAQ,MAAM;AAO9B,MAAM,OAAO,CAAA,QAAS,MAAM,CAAC,GAAG,IAAI,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1904, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/core/src/schema/did.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport * as Schema from './schema.js'\nimport * as DID from '@ipld/dag-ucan/did'\n/**\n * @template {string} Method\n * @extends {Schema.API<API.DID<Method> & API.URI<\"did:\">, string, void|Method>}\n */\nclass DIDSchema extends Schema.API {\n  /**\n   * @param {string} source\n   * @param {void|Method} method\n   */\n  readWith(source, method) {\n    const prefix = method ? `did:${method}:` : `did:`\n    if (!source.startsWith(prefix)) {\n      return Schema.error(`Expected a ${prefix} but got \"${source}\" instead`)\n    } else {\n      return { ok: /** @type {API.DID<Method>} */ (source) }\n    }\n  }\n}\n\nconst schema = Schema.string().refine(new DIDSchema())\n\nexport const did = () => schema\n/**\n *\n * @param {unknown} input\n */\nexport const read = input => schema.read(input)\n\n/**\n * @template {string} Method\n * @param {{method?: Method}} options\n */\nexport const match = (options = {}) =>\n  /** @type {Schema.Schema<API.DID<Method> & API.URI<\"did:\">>} */ (\n    Schema.string().refine(new DIDSchema(options.method))\n  )\n\n/**\n * Create a DID string from any input (or throw)\n * @param {unknown} input\n */\nexport const from = input => match({}).from(input)\n\n/**\n * @template {string} Method\n * @extends {Schema.API<API.DID<Method> & API.URI<\"did:\">, unknown, void|Method>}\n */\nclass DIDBytesSchema extends Schema.API {\n  /**\n   * @param {unknown} source\n   * @param {void|Method} method\n   */\n  readWith(source, method) {\n    if (!(source instanceof Uint8Array)) {\n      return Schema.typeError({ expect: 'Uint8Array', actual: source })\n    }\n    let did\n    try {\n      did = DID.decode(source).did()\n    } catch (err) {\n      return Schema.error(`Unable to parse bytes as did: ${err}`)\n    }\n    const prefix = method ? `did:${method}:` : `did:`\n    if (!did.startsWith(prefix)) {\n      return Schema.error(`Expected a ${prefix} but got \"${did}\" instead`)\n    } else {\n      return { ok: /** @type {API.DID<Method>} */ (did) }\n    } \n  }\n}\n\nconst schemaBytes = new DIDBytesSchema()\n\n/**\n * @deprecated Use `Schema.principal(...)` instead.\n */\nexport const didBytes = () => schemaBytes\n\n/**\n * @deprecated Use `Schema.principal(...)` instead.\n * @param {unknown} input\n */\nexport const readBytes = input => schemaBytes.read(input)\n\n/**\n * @deprecated Use `Schema.principal(...)` instead.\n * @template {string} Method\n * @param {{method?: Method}} options\n */\nexport const matchBytes = (options = {}) =>\n  /** @type {Schema.Schema<API.DID<Method> & API.URI<\"did:\">>} */ (\n    new DIDBytesSchema(options.method)\n  )\n\n/**\n * Create a DID string from any input (or throw)\n *\n * @deprecated Use `Schema.principal(...)` instead.\n * @param {unknown} input\n */\nexport const fromBytes = input => matchBytes({}).from(input)\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;;;;AACA;;;CAGC,GACD,MAAM,kBAAkB,qLAAU;IAChC;;;GAGC,GACD,SAAS,MAAM,EAAE,MAAM,EAAE;QACvB,MAAM,SAAS,SAAS,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC;QACjD,IAAI,CAAC,OAAO,UAAU,CAAC,SAAS;YAC9B,OAAO,uLAAY,CAAC,CAAC,WAAW,EAAE,OAAO,UAAU,EAAE,OAAO,SAAS,CAAC;QACxE,OAAO;YACL,OAAO;gBAAE,IAAoC;YAAQ;QACvD;IACF;AACF;AAEA,MAAM,SAAS,wLAAa,GAAG,MAAM,CAAC,IAAI;AAEnC,MAAM,MAAM,IAAM;AAKlB,MAAM,OAAO,CAAA,QAAS,OAAO,IAAI,CAAC;AAMlC,MAAM,QAAQ,CAAC,UAAU,CAAC,CAAC,GAE9B,wLAAa,GAAG,MAAM,CAAC,IAAI,UAAU,QAAQ,MAAM;AAOhD,MAAM,OAAO,CAAA,QAAS,MAAM,CAAC,GAAG,IAAI,CAAC;AAE5C;;;CAGC,GACD,MAAM,uBAAuB,qLAAU;IACrC;;;GAGC,GACD,SAAS,MAAM,EAAE,MAAM,EAAE;QACvB,IAAI,CAAC,CAAC,kBAAkB,UAAU,GAAG;YACnC,OAAO,2LAAgB,CAAC;gBAAE,QAAQ;gBAAc,QAAQ;YAAO;QACjE;QACA,IAAI;QACJ,IAAI;YACF,MAAM,gKAAU,CAAC,QAAQ,GAAG;QAC9B,EAAE,OAAO,KAAK;YACZ,OAAO,uLAAY,CAAC,CAAC,8BAA8B,EAAE,KAAK;QAC5D;QACA,MAAM,SAAS,SAAS,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC;QACjD,IAAI,CAAC,IAAI,UAAU,CAAC,SAAS;YAC3B,OAAO,uLAAY,CAAC,CAAC,WAAW,EAAE,OAAO,UAAU,EAAE,IAAI,SAAS,CAAC;QACrE,OAAO;YACL,OAAO;gBAAE,IAAoC;YAAK;QACpD;IACF;AACF;AAEA,MAAM,cAAc,IAAI;AAKjB,MAAM,WAAW,IAAM;AAMvB,MAAM,YAAY,CAAA,QAAS,YAAY,IAAI,CAAC;AAO5C,MAAM,aAAa,CAAC,UAAU,CAAC,CAAC,GAEnC,IAAI,eAAe,QAAQ,MAAM;AAS9B,MAAM,YAAY,CAAA,QAAS,WAAW,CAAC,GAAG,IAAI,CAAC","ignoreList":[0]}},
    {"offset": {"line": 1990, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/core/src/schema/text.js"],"sourcesContent":["import * as Schema from './schema.js'\n\nconst schema = Schema.string()\n\n/**\n * @param {{pattern: RegExp}} [options]\n */\nexport const match = options =>\n  options ? schema.refine(new Match(options.pattern)) : schema\n\nexport const text = match\n\n/**\n * @param {unknown} input\n */\nexport const read = input => schema.read(input)\n\n/**\n * @extends {Schema.API<string, string, RegExp>}\n */\nclass Match extends Schema.API {\n  /**\n   * @param {string} source\n   * @param {RegExp} pattern\n   */\n  readWith(source, pattern) {\n    if (!pattern.test(source)) {\n      return Schema.error(\n        `Expected to match ${pattern} but got \"${source}\" instead`\n      )\n    } else {\n      return { ok: source }\n    }\n  }\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;;AAEA,MAAM,SAAS,wLAAa;AAKrB,MAAM,QAAQ,CAAA,UACnB,UAAU,OAAO,MAAM,CAAC,IAAI,MAAM,QAAQ,OAAO,KAAK;AAEjD,MAAM,OAAO;AAKb,MAAM,OAAO,CAAA,QAAS,OAAO,IAAI,CAAC;AAEzC;;CAEC,GACD,MAAM,cAAc,qLAAU;IAC5B;;;GAGC,GACD,SAAS,MAAM,EAAE,OAAO,EAAE;QACxB,IAAI,CAAC,QAAQ,IAAI,CAAC,SAAS;YACzB,OAAO,uLAAY,CACjB,CAAC,kBAAkB,EAAE,QAAQ,UAAU,EAAE,OAAO,SAAS,CAAC;QAE9D,OAAO;YACL,OAAO;gBAAE,IAAI;YAAO;QACtB;IACF;AACF","ignoreList":[0]}},
    {"offset": {"line": 2024, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/core/src/schema.js"],"sourcesContent":["export * as URI from './schema/uri.js'\nexport * as Link from './schema/link.js'\nexport * as Principal from './schema/principal.js'\nexport * as DID from './schema/did.js'\nexport * as Text from './schema/text.js'\nexport * from './schema/schema.js'\nexport { match as link } from './schema/link.js'\nexport { match as principal } from './schema/principal.js'\nexport { match as did, matchBytes as didBytes } from './schema/did.js'\nexport { match as uri } from './schema/uri.js'\nexport { match as text } from './schema/text.js'\n"],"names":[],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA","ignoreList":[0]}},
    {"offset": {"line": 2132, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/core/src/delegation.js"],"sourcesContent":["import * as UCAN from '@ipld/dag-ucan'\nimport * as API from '@ucanto/interface'\nimport * as Link from './link.js'\nimport * as DAG from './dag.js'\nimport * as CAR from './car.js'\nimport * as CBOR from './cbor.js'\nimport * as Schema from './schema.js'\nimport { ok, error } from './result.js'\n\n/**\n * @deprecated\n * Import `isLink` from module directly\n */\nexport const isLink =\n  /** @type {(value:API.Proof) => value is API.UCANLink} */\n  (Link.isLink)\n\n/**\n *\n * @param {API.Proof} proof\n * @return {proof is API.Delegation}\n */\nexport const isDelegation = proof => !Link.isLink(proof)\n\n/**\n * Takes one or more delegations and returns all delegated capabilities in\n * UCAN 0.10 format, expanding all the special forms like `with: ucan:*` and\n * `can: *` to explicit forms.\n *\n * Note that this function only considers included proofs and ignores linked\n * proofs. It is up to the user of this function to resolve whatever proofs it\n * needs and build delegation with them before calling this function.\n *\n * Also note that this function does not validate the delegations and may\n * produce result containing capabilities that escalate, which for the validator\n * perspective is no different from not including such capabilities.\n *\n * @template {[API.Delegation, ...API.Delegation[]]} T\n * @param {T} delegations\n * @returns {API.InferAllowedFromDelegations<T>}\n */\nexport const allows = (...delegations) => {\n  /** @type {API.Allows} */\n  let allow = {}\n  for (const delegation of delegations) {\n    for (const { with: uri, can, nb } of iterateCapabilities(delegation)) {\n      const resource = allow[uri] || (allow[uri] = {})\n      const abilities = resource[can] || (resource[can] = [])\n      abilities.push({ ...nb })\n    }\n  }\n\n  return /** @type {API.InferAllowedFromDelegations<T>} */ (allow)\n}\n\n/**\n * Function takes a delegation and iterates over all the capabilities expanding\n * all the special forms like `with: ucan:*` and `can: *`.\n *\n * Note that this function only considers proofs that are included in the\n * delegation, linked proofs will not be resolved nor considered. It is up to\n * the user of this function to resolve whatever proofs it needs to consider\n * before calling this function.\n *\n * @param {API.Delegation} delegation\n * @returns {Iterable<API.Capability>}\n */\nconst iterateCapabilities = function* ({ issuer, capabilities, proofs }) {\n  for (const own of capabilities) {\n    // If `with` field is set to  `ucan:*` it implies re-delegation of all own\n    // and delegated capabilities.\n    if (own.with === 'ucan:*') {\n      // Fist we include own capabilities. Note that we can not expand `can`\n      // because it implicitly covers all possible options in the universe.\n      yield {\n        ...own,\n        with: issuer.did(),\n      }\n\n      // Next we iterate over all delegated capabilities including ones that\n      // match ability in the `own.can` field.\n      for (const proof of proofs) {\n        // We only consider proofs that are included and ignore linked proofs.\n        if (isDelegation(proof)) {\n          for (const capability of iterateCapabilities(proof)) {\n            // We attempt to match `capability.can` against `own.can` field\n            // if there is a match we include the capability otherwise we skip\n            const can = matchAbility(capability.can, own.can)\n            if (can) {\n              yield {\n                ...capability,\n                can,\n                // We do not know capability semantics so it is impossible\n                // for us to eliminate capabilities that do not satisfy imposed\n                // caveats (`own.nb`). Therefore we optimistically assume that\n                // `own.nb` further constraints `capability.nb` and do a shallow\n                // merge of the two. As a result we may include capabilities\n                // that during validation will be considered invalid due to\n                // constraint violations. While that is not ideal validator\n                // will treat them as if they were omitted and therefore it\n                // is a reasonable compromise.\n                nb: { ...capability.nb, ...Object(own.nb) },\n              }\n            }\n          }\n        }\n      }\n    } else {\n      yield own\n    }\n  }\n}\n\n/**\n * Function takes `can` field from the delegated capability and attempts to\n * match it against `can` field of the claimed capability. If there is a match\n * the function returns more specific `can` field of two, otherwise it returns\n * `null`.\n *\n * @param {API.Ability} provided\n * @param {API.Ability} claimed\n */\nconst matchAbility = (provided, claimed) => {\n  // If provided capability delegates all abilities we can derive any `can`\n  // from it so we return `claimed` as is.\n  if (provided === '*') {\n    return claimed\n  }\n  // If claimed capability delegates all abilities that includes any `can`\n  // so we return `provided` as is.\n  if (claimed === '*') {\n    return provided\n  }\n  // If claimed `can` is a pattern that includes `provided` `can` we return\n  // `provided` as is.\n  if (claimed.endsWith('/*') && provided.startsWith(claimed.slice(0, -1))) {\n    return provided\n  }\n  // If provided `can` is a pattern that includes `claimed` `can` we can derive\n  // `claimed` from it so we return `claimed` as is.\n  if (provided.endsWith('/*') && claimed.startsWith(provided.slice(0, -1))) {\n    return claimed\n  }\n  // If `can` fields are concrete and the same we have a match and can return it.\n  if (provided === claimed) {\n    return provided\n  }\n  // otherwise two are incompatible and we return null.\n  return null\n}\n\n/**\n * Represents UCAN chain view over the set of DAG UCAN nodes. You can think of\n * this as UCAN interface of the CAR.\n *\n * @template {API.Capabilities} C\n * @implements {API.Delegation<C>}\n * @extends {DelegationView<C>}\n */\nexport class Delegation {\n  /**\n   * @param {API.UCANBlock<C>} root\n   * @param {DAG.BlockStore} [blocks]\n   */\n  constructor(root, blocks = new Map()) {\n    this.root = root\n    this.blocks = blocks\n\n    Object.defineProperties(this, {\n      blocks: {\n        enumerable: false,\n      },\n    })\n  }\n\n  /**\n   * @returns {API.AttachedLinkSet}\n   */\n  get attachedLinks() {\n    const _attachedLinks = new Set()\n    const ucanView = this.data\n\n    // Get links from capabilities nb\n    for (const capability of ucanView.capabilities) {\n      /** @type {Link[]} */\n      const links = getLinksFromObject(capability)\n\n      for (const link of links) {\n        _attachedLinks.add(`${link}`)\n      }\n    }\n\n    // Get links from facts values\n    for (const fact of ucanView.facts) {\n      if (Link.isLink(fact)) {\n        _attachedLinks.add(`${fact}`)\n      } else {\n        /** @type {Link[]} */\n        // @ts-expect-error isLink does not infer value type\n        const links = Object.values(fact).filter(e => Link.isLink(e))\n\n        for (const link of links) {\n          _attachedLinks.add(`${link}`)\n        }\n      }\n    }\n\n    return _attachedLinks\n  }\n\n  get version() {\n    return this.data.version\n  }\n  get signature() {\n    return this.data.signature\n  }\n  get cid() {\n    return this.root.cid\n  }\n  link() {\n    return this.root.cid\n  }\n  get asCID() {\n    return this.cid\n  }\n  get bytes() {\n    return this.root.bytes\n  }\n  get data() {\n    const data = decode(this.root)\n    Object.defineProperties(this, { data: { value: data, enumerable: false } })\n    return data\n  }\n  /**\n   * Attach a block to the delegation DAG so it would be included in the\n   * block iterator.\n   * ⚠️ You can only attach blocks that are referenced from the `capabilities`\n   * or `facts`.\n   *\n   * @param {API.Block} block\n   */\n  attach(block) {\n    if (!this.attachedLinks.has(`${block.cid.link()}`)) {\n      throw new Error(`given block with ${block.cid} is not an attached link`)\n    }\n    this.blocks.set(`${block.cid}`, block)\n  }\n  export() {\n    return exportDAG(this.root, this.blocks, this.attachedLinks)\n  }\n\n  /**\n   * @returns {API.Await<API.Result<Uint8Array, Error>>}\n   */\n  archive() {\n    return archive(this)\n  }\n\n  iterateIPLDBlocks() {\n    return exportDAG(this.root, this.blocks, this.attachedLinks)\n  }\n\n  /**\n   * @type {API.Proof[]}\n   */\n  get proofs() {\n    return proofs(this)\n  }\n\n  /**\n   * @type {API.Principal}\n   */\n  get issuer() {\n    return this.data.issuer\n  }\n\n  /**\n   * @type {API.Principal}\n   */\n  get audience() {\n    return this.data.audience\n  }\n\n  /**\n   * @returns {C}\n   */\n  get capabilities() {\n    return /** @type {C} */ (this.data.capabilities)\n  }\n\n  /**\n   * @returns {number}\n   */\n  get expiration() {\n    return this.data.expiration\n  }\n\n  /**\n   * @returns {undefined|number}\n   */\n  get notBefore() {\n    return this.data.notBefore\n  }\n\n  /**\n   * @returns {undefined|string}\n   */\n\n  get nonce() {\n    return this.data.nonce\n  }\n\n  /**\n   * @returns {API.Fact[]}\n   */\n  get facts() {\n    return this.data.facts\n  }\n\n  /**\n   * Iterate over the proofs\n   *\n   * @returns {IterableIterator<API.Delegation>}\n   */\n  iterate() {\n    return it(this)\n  }\n\n  delegate() {\n    return this\n  }\n\n  buildIPLDView() {\n    return this\n  }\n\n  /**\n   * @returns {API.DelegationJSON<this>}\n   */\n  toJSON() {\n    return /** @type {any} */ ({\n      ...this.data.toJSON(),\n      '/': this.cid.toString(),\n      prf: this.proofs.map(proof =>\n        isDelegation(proof) ? proof : { '/': proof.toString() }\n      ),\n    })\n  }\n}\n\n/**\n * Writes given `Delegation` chain into a content addressed archive (CAR)\n * buffer and returns it.\n *\n * @param {API.Delegation} delegation}\n * @returns {Promise<API.Result<Uint8Array, Error>>}\n */\nexport const archive = async delegation => {\n  try {\n    // Iterate over all of the blocks in the DAG and add them to the\n    // block store.\n    const store = new Map()\n    for (const block of delegation.iterateIPLDBlocks()) {\n      store.set(`${block.cid}`, block)\n    }\n\n    // Then we we create a descriptor block to describe what this DAG represents\n    // and it to the block store as well.\n    const variant = await CBOR.write({\n      [`ucan@${delegation.version}`]: delegation.root.cid,\n    })\n    store.set(`${variant.cid}`, variant)\n\n    // And finally we encode the whole thing into a CAR.\n    const bytes = CAR.encode({\n      roots: [variant],\n      blocks: store,\n    })\n\n    return ok(bytes)\n  } catch (cause) {\n    return error(/** @type {Error} */ (cause))\n  }\n}\n\nexport const ArchiveSchema = Schema.variant({\n  'ucan@0.9.1': /** @type {Schema.Schema<API.UCANLink>} */ (\n    Schema.link({ version: 1 })\n  ),\n})\n\n/**\n * Extracts a `Delegation` chain from a given content addressed archive (CAR)\n * buffer. Assumes that the CAR contains a single root block corresponding to\n * the delegation variant.\n *\n * @param {Uint8Array} archive\n */\nexport const extract = async archive => {\n  try {\n    const { roots, blocks } = CAR.decode(archive)\n    const [root] = roots\n    if (root == null) {\n      return Schema.error('CAR archive does not contain a root block')\n    }\n    const { bytes } = root\n    const variant = CBOR.decode(bytes)\n    const [, link] = ArchiveSchema.match(variant)\n    return ok(view({ root: link, blocks }))\n  } catch (cause) {\n    return error(/** @type {Error} */ (cause))\n  }\n}\n\n/**\n * @param {API.Delegation} delegation\n * @returns {IterableIterator<API.Delegation>}\n */\nconst it = function* (delegation) {\n  for (const proof of delegation.proofs) {\n    if (isDelegation(proof)) {\n      yield* it(proof)\n      yield proof\n    }\n  }\n}\n\nconst decodeCache = new WeakMap()\n/**\n * @template {API.Capabilities} C\n * @param {API.UCANBlock<C>} block\n * @returns {UCAN.View<C>}\n */\nconst decode = ({ bytes }) => {\n  const data = decodeCache.get(bytes)\n  if (!data) {\n    const data = UCAN.decode(bytes)\n    decodeCache.set(bytes, data)\n    return data\n  }\n  return data\n}\n\n/**\n * Creates a new signed token with a given `options.issuer`. If expiration is\n * not set it defaults to 30 seconds from now. Returns UCAN in primary - IPLD\n * representation.\n *\n * @template {API.Capabilities} C\n * @param {API.DelegationOptions<C>} data\n * @param {API.EncodeOptions} [options]\n * @returns {Promise<API.Delegation<C>>}\n */\n\nexport const delegate = async (\n  { issuer, audience, proofs = [], attachedBlocks = new Map(), ...input },\n  options\n) => {\n  const links = []\n  const blocks = new Map()\n  for (const proof of proofs) {\n    if (!isDelegation(proof)) {\n      links.push(proof)\n    } else {\n      links.push(proof.cid)\n      for (const block of proof.export()) {\n        blocks.set(block.cid.toString(), block)\n      }\n    }\n  }\n\n  const data = await UCAN.issue({\n    ...input,\n    issuer,\n    audience,\n    proofs: links,\n  })\n  const { cid, bytes } = await UCAN.write(data, options)\n  decodeCache.set(cid, data)\n\n  /** @type {API.Delegation<C>} */\n  const delegation = new Delegation({ cid, bytes }, blocks)\n  Object.defineProperties(delegation, { proofs: { value: proofs } })\n\n  for (const block of attachedBlocks.values()) {\n    delegation.attach(block)\n  }\n\n  return delegation\n}\n\n/**\n * @template {API.Capabilities} C\n * @param {API.UCANBlock<C>} root\n * @param {DAG.BlockStore} blocks\n * @param {API.AttachedLinkSet} attachedLinks\n * @returns {IterableIterator<API.Block>}\n */\n\nexport const exportDAG = function* (root, blocks, attachedLinks) {\n  for (const link of decode(root).proofs) {\n    // Check if block is included in this delegation\n    const root = /** @type {UCAN.Block} */ (blocks.get(`${link}`))\n    if (root) {\n      yield* exportSubDAG(root, blocks)\n    }\n  }\n\n  for (const link of attachedLinks.values()) {\n    const block = blocks.get(link)\n\n    if (block) {\n      // @ts-expect-error can get blocks with v0 and v1\n      yield block\n    }\n  }\n\n  yield root\n}\n\n/**\n * @template {API.Capabilities} C\n * @param {API.UCANBlock<C>} root\n * @param {DAG.BlockStore} blocks\n * @returns {IterableIterator<API.Block>}\n */\nconst exportSubDAG = function* (root, blocks) {\n  for (const link of decode(root).proofs) {\n    // Check if block is included in this delegation\n    const root = /** @type {UCAN.Block} */ (blocks.get(`${link}`))\n    if (root) {\n      yield* exportSubDAG(root, blocks)\n    }\n  }\n\n  yield root\n}\n\n/**\n * @template {API.Capabilities} C\n * @param {Iterable<API.Block>} dag\n * @returns {API.Delegation<C>}\n */\nexport const importDAG = dag => {\n  /** @type {Array<[string, API.Block]>} */\n  let entries = []\n  for (const block of dag) {\n    entries.push([block.cid.toString(), block])\n  }\n\n  const last = entries.pop()\n  if (!last) {\n    throw new RangeError('Empty DAG can not be turned into a delegation')\n  } else {\n    const [, root] = last\n\n    return new Delegation(\n      /** @type {API.UCANBlock<C>} */ (root),\n      new Map(entries)\n    )\n  }\n}\n\n/**\n * @template {API.Capabilities} C\n * @param {object} dag\n * @param {API.UCANBlock<C>} dag.root\n * @param {DAG.BlockStore} [dag.blocks]\n * @returns {API.Delegation<C>}\n */\nexport const create = ({ root, blocks }) => new Delegation(root, blocks)\n\n/**\n * @template {API.Capabilities} C\n * @template [E=never]\n * @param {object} dag\n * @param {API.UCANLink<C>} dag.root\n * @param {DAG.BlockStore} dag.blocks\n * @param {E} [fallback]\n * @returns {API.Delegation<C>|E}\n */\nexport const view = ({ root, blocks }, fallback) => {\n  const block = DAG.get(root, blocks, null)\n  if (block == null) {\n    return fallback !== undefined ? fallback : DAG.notFound(root)\n  }\n  return create({ root: block, blocks })\n}\n\n/**\n * @param {API.Delegation} delegation\n */\nconst proofs = delegation => {\n  /** @type {API.Proof[]} */\n  const proofs = []\n  const { root, blocks } = delegation\n  // Iterate over proof links and materialize Delegation views.\n  for (const link of decode(root).proofs) {\n    // Check if linked proof is included in our blocks if so create delegation\n    // view otherwise use a link\n    const root = /** @type {UCAN.Block} */ (blocks.get(link.toString()))\n    proofs.push(root ? create({ root, blocks }) : link)\n  }\n\n  // we cache result of this computation as this property may get accessed\n  // more than once.\n  Object.defineProperty(delegation, 'proofs', { value: proofs })\n  return proofs\n}\n\n/**\n * @param {API.Capability<API.Ability, `${string}:${string}`, unknown>} obj\n */\nfunction getLinksFromObject(obj) {\n  /** @type {Link[]} */\n  const links = []\n\n  /**\n   * @param {object} obj\n   */\n  function recurse(obj) {\n    for (const key in obj) {\n      // @ts-expect-error record type not inferred\n      const value = obj[key]\n      if (Link.isLink(value)) {\n        // @ts-expect-error isLink does not infer value type\n        links.push(value)\n      } else if (value && typeof value === 'object') {\n        recurse(value)\n      }\n    }\n  }\n\n  recurse(obj)\n\n  return links\n}\n\nexport { Delegation as View }\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 2661, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/core/src/invocation.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport { delegate, Delegation, isDelegation } from './delegation.js'\nimport * as DAG from './dag.js'\n\n/**\n * Takes invocation link or a reference and returns `true` if value\n * passed is a reference, returns `false` if value is a link.\n *\n * @param {API.Invocation | API.Link} value\n * @return {value is API.Invocation}\n */\nexport const isInvocation = value => isDelegation(value)\n\n/**\n * @template {API.Capability} Capability\n * @param {API.InvocationOptions<Capability>} options\n * @return {API.IssuedInvocationView<Capability>}\n */\nexport const invoke = options => new IssuedInvocation(options)\n\n/**\n * @template {API.Capability} C\n * @param {object} dag\n * @param {API.UCANBlock<[C]>} dag.root\n * @param {DAG.BlockStore} [dag.blocks]\n * @returns {API.Invocation<C>}\n */\nexport const create = ({ root, blocks }) => new Invocation(root, blocks)\n\n/**\n * Takes a link of the `root` block and a map of blocks and constructs an\n * `Invocation` from it. If `root` is not included in the provided blocks\n * provided fallback is returned and if not provided than throws an error.\n * If root points to wrong block (that is not an invocation) it will misbehave\n * and likely throw some errors on field access.\n *\n * @template {API.Capability} C\n * @template {API.Invocation} Invocation\n * @template [T=never]\n * @param {object} dag\n * @param {API.UCANLink<[C]>} dag.root\n * @param {DAG.BlockStore} dag.blocks\n * @param {T} [fallback]\n * @returns {API.Invocation<C>|T}\n */\nexport const view = ({ root, blocks }, fallback) => {\n  const block = DAG.get(root, blocks, null)\n  if (block == null) {\n    return fallback !== undefined ? fallback : DAG.notFound(root)\n  }\n\n  return /** @type {API.Invocation<C>} */ (create({ root: block, blocks }))\n}\n\n/**\n * @template {API.Capability} Capability\n * @implements {API.IssuedInvocationView<Capability>}\n * @implements {API.IssuedInvocation<Capability>}\n */\nclass IssuedInvocation {\n  /**\n   * @param {API.InvocationOptions<Capability>} data\n   */\n  constructor({\n    issuer,\n    audience,\n    capability,\n    proofs = [],\n    expiration,\n    lifetimeInSeconds,\n    notBefore,\n    nonce,\n    facts = [],\n    attachedBlocks,\n  }) {\n    /** @readonly */\n    this.issuer = issuer\n    /** @readonly */\n    this.audience = audience\n    /** @readonly */\n    this.proofs = proofs\n\n    /**\n     * @readonly\n     * @type {[Capability]}\n     */\n    this.capabilities = [capability]\n\n    this.expiration = expiration\n    this.lifetimeInSeconds = lifetimeInSeconds\n    this.notBefore = notBefore\n    this.nonce = nonce\n    this.facts = facts\n\n    /** @type {API.BlockStore<unknown>} */\n    this.attachedBlocks = attachedBlocks || new Map()\n  }\n\n  /**\n   * @param {API.Block} block\n   */\n  attach(block) {\n    this.attachedBlocks.set(`${block.cid}`, block)\n  }\n\n  delegate() {\n    return delegate(this)\n  }\n\n  buildIPLDView() {\n    return delegate(this)\n  }\n\n  /**\n   * @template {API.InvocationService<Capability>} Service\n   * @param {API.ConnectionView<Service>} connection\n   * @returns {Promise<API.InferReceipt<Capability, Service>>}\n   */\n  async execute(connection) {\n    /** @type {API.ServiceInvocation<Capability, Service>} */\n    // @ts-expect-error - Our `API.InvocationService<Capability>` constraint\n    // does not seem to be enough to convince TS that `this` is valid\n    // `ServiceInvocations<Service>`.\n    const invocation = this\n    const [result] = await connection.execute(invocation)\n    return result\n  }\n}\n\n/**\n * @template {API.Capability} Capability\n * @implements {API.Invocation<Capability>}\n * @extends {Delegation<[Capability]>}\n */\nexport class Invocation extends Delegation {}\n"],"names":[],"mappings":";;;;;;;;;;;;AAAA;AACA;AACA;;;;AASO,MAAM,eAAe,CAAA,QAAS,IAAA,wKAAY,EAAC;AAO3C,MAAM,SAAS,CAAA,UAAW,IAAI,iBAAiB;AAS/C,MAAM,SAAS,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,GAAK,IAAI,WAAW,MAAM;AAkB1D,MAAM,OAAO,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,EAAE;IACrC,MAAM,QAAQ,wKAAO,CAAC,MAAM,QAAQ;IACpC,IAAI,SAAS,MAAM;QACjB,OAAO,aAAa,YAAY,WAAW,6KAAY,CAAC;IAC1D;IAEA,OAAyC,OAAO;QAAE,MAAM;QAAO;IAAO;AACxE;AAEA;;;;CAIC,GACD,MAAM;IACJ;;GAEC,GACD,YAAY,EACV,MAAM,EACN,QAAQ,EACR,UAAU,EACV,SAAS,EAAE,EACX,UAAU,EACV,iBAAiB,EACjB,SAAS,EACT,KAAK,EACL,QAAQ,EAAE,EACV,cAAc,EACf,CAAE;QACD,cAAc,GACd,IAAI,CAAC,MAAM,GAAG;QACd,cAAc,GACd,IAAI,CAAC,QAAQ,GAAG;QAChB,cAAc,GACd,IAAI,CAAC,MAAM,GAAG;QAEd;;;KAGC,GACD,IAAI,CAAC,YAAY,GAAG;YAAC;SAAW;QAEhC,IAAI,CAAC,UAAU,GAAG;QAClB,IAAI,CAAC,iBAAiB,GAAG;QACzB,IAAI,CAAC,SAAS,GAAG;QACjB,IAAI,CAAC,KAAK,GAAG;QACb,IAAI,CAAC,KAAK,GAAG;QAEb,oCAAoC,GACpC,IAAI,CAAC,cAAc,GAAG,kBAAkB,IAAI;IAC9C;IAEA;;GAEC,GACD,OAAO,KAAK,EAAE;QACZ,IAAI,CAAC,cAAc,CAAC,GAAG,CAAC,GAAG,MAAM,GAAG,EAAE,EAAE;IAC1C;IAEA,WAAW;QACT,OAAO,IAAA,oKAAQ,EAAC,IAAI;IACtB;IAEA,gBAAgB;QACd,OAAO,IAAA,oKAAQ,EAAC,IAAI;IACtB;IAEA;;;;GAIC,GACD,MAAM,QAAQ,UAAU,EAAE;QACxB,uDAAuD,GACvD,wEAAwE;QACxE,iEAAiE;QACjE,iCAAiC;QACjC,MAAM,aAAa,IAAI;QACvB,MAAM,CAAC,OAAO,GAAG,MAAM,WAAW,OAAO,CAAC;QAC1C,OAAO;IACT;AACF;AAOO,MAAM,mBAAmB,sKAAU;AAAE","ignoreList":[0]}},
    {"offset": {"line": 2764, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/core/src/receipt.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport * as DID from '@ipld/dag-ucan/did'\nimport * as Invocation from './invocation.js'\nimport * as Delegation from './delegation.js'\nimport * as Signature from '@ipld/dag-ucan/signature'\nimport * as DAG from './dag.js'\nimport * as CBOR from './cbor.js'\nimport { sha256 } from 'multiformats/hashes/sha2'\n\n/**\n * @template {{}} Ok\n * @template {{}} Error\n * @template {API.Invocation} Ran\n * @template [E=never]\n * @param {object} input\n * @param {API.Link<API.ReceiptModel<Ok, Error, Ran>>} input.root\n * @param {DAG.BlockStore} input.blocks\n * @param {E} [fallback]\n */\nexport const view = ({ root, blocks }, fallback) => {\n  const block = DAG.get(root, blocks, null)\n  if (block == null) {\n    return fallback !== undefined ? fallback : DAG.notFound(root)\n  }\n  const data = CBOR.decode(block.bytes)\n\n  return new Receipt({ root: { ...block, data }, store: blocks })\n}\n\n/**\n * Represents a UCAN invocation receipt view over some block store e.g. in\n * memory CAR. It incrementally decodes proofs, ran invocation etc. on access\n * which reduces overhead but potentially defers errors if references blocks\n * do not conform to the expected IPLD schema.\n *\n * @template {{}} Ok\n * @template {{}} Error\n * @template {API.Invocation} Ran\n * @template {API.SigAlg} [SigAlg=API.SigAlg]\n * @implements {API.Receipt<Ok, Error, Ran, SigAlg>}\n */\nclass Receipt {\n  /**\n   * @param {object} input\n   * @param {Required<API.Block<API.ReceiptModel<Ok, Error, Ran>>>} input.root\n   * @param {DAG.BlockStore} input.store\n   * @param {API.Meta} [input.meta]\n   * @param {Ran|ReturnType<Ran['link']>} [input.ran]\n   * @param {API.EffectsModel} [input.fx]\n   * @param {API.SignatureView<API.OutcomeModel<Ok, Error, Ran>, SigAlg>} [input.signature]\n   * @param {API.UCAN.Principal} [input.issuer]\n   * @param {API.Proof[]} [input.proofs]\n   */\n  constructor({ root, store, ran, issuer, signature, proofs }) {\n    this.store = store\n\n    this.root = root\n    this._ran = ran\n\n    // Field is materialized on demand when `fx` getter is first accessed.\n    /** @type {API.Effects|undefined} */\n    this._fx = undefined\n    this._signature = signature\n    this._proofs = proofs\n    this._issuer = issuer\n  }\n\n  /**\n   * @returns {Ran|ReturnType<Ran['link']>}\n   */\n  get ran() {\n    const ran = this._ran\n    if (!ran) {\n      const ran = /** @type {Ran} */ (\n        Invocation.view(\n          {\n            root: this.root.data.ocm.ran,\n            blocks: this.store,\n          },\n          this.root.data.ocm.ran\n        )\n      )\n      this._ran = ran\n      return ran\n    } else {\n      return ran\n    }\n  }\n  get proofs() {\n    const proofs = this._proofs\n    if (proofs) {\n      return proofs\n    } else {\n      const { store, root } = this\n      const { prf } = root.data.ocm\n      const proofs = []\n      if (prf) {\n        for (const link of prf) {\n          const proof = Delegation.view({ root: link, blocks: store }, link)\n          proofs.push(proof)\n        }\n      }\n\n      this._proofs = proofs\n      return proofs\n    }\n  }\n  link() {\n    return this.root.cid\n  }\n  get meta() {\n    return this.root.data.ocm.meta\n  }\n  get issuer() {\n    const issuer = this._issuer\n    if (issuer) {\n      return issuer\n    } else {\n      const { iss } = this.root.data.ocm\n      if (iss) {\n        const issuer = DID.parse(iss)\n        this._issuer = issuer\n        return issuer\n      }\n    }\n  }\n\n  get out() {\n    return this.root.data.ocm.out\n  }\n\n  get fx() {\n    let fx = this._fx\n    if (!fx) {\n      const { store: blocks } = this\n      const { fork, join } = this.root.data.ocm.fx\n\n      fx = {\n        fork: fork.map(root => Invocation.view({ root, blocks }, root)),\n      }\n\n      if (join) {\n        fx.join = Invocation.view({ root: join, blocks }, join)\n      }\n\n      this._fx = fx\n    }\n    return fx\n  }\n\n  get signature() {\n    const signature = this._signature\n    if (signature) {\n      return signature\n    } else {\n      const signature =\n        /** @type {API.SignatureView<API.OutcomeModel<Ok, Error, Ran>, SigAlg>} */ (\n          Signature.view(this.root.data.sig)\n        )\n      this._signature = signature\n      return signature\n    }\n  }\n\n  /**\n   * @param {API.Crypto.Verifier} signingPrincipal\n   */\n  verifySignature(signingPrincipal) {\n    return this.signature.verify(\n      signingPrincipal,\n      CBOR.encode(this.root.data.ocm)\n    )\n  }\n\n  buildIPLDView() {\n    return this\n  }\n\n  *iterateIPLDBlocks() {\n    const { ran, fx, proofs, root } = this\n\n    yield* DAG.iterate(ran)\n\n    for (const fork of fx.fork) {\n      yield* DAG.iterate(fork)\n    }\n\n    if (fx.join) {\n      yield* DAG.iterate(fx.join)\n    }\n\n    for (const proof of proofs) {\n      yield* DAG.iterate(proof)\n    }\n\n    yield root\n  }\n}\n\n/**\n * Represents a receipt builder that can be used to create a receipt that later\n * can be encoded into desired IPLD codec and hasher. In the future we may make\n * this an incremental builder so you could set some fields later on.\n *\n * @template {{}} Ok\n * @template {{}} Error\n * @template {API.Invocation} Ran\n * @template {API.SigAlg} SigAlg\n * @implements {API.IPLDViewBuilder<API.Receipt<Ok, Error, Ran, SigAlg>>}\n */\nclass ReceptBuilder {\n  /**\n   * @param {object} options\n   * @param {API.Signer<API.DID, SigAlg>} options.issuer\n   * @param {Ran|ReturnType<Ran['link']>} options.ran\n   * @param {API.Result<Ok, Error>} options.result\n   * @param {API.Effects} [options.fx]\n   * @param {API.Proof[]} [options.proofs]\n   * @param {Record<string, unknown>} [options.meta]\n   */\n  constructor({ issuer, result, ran, fx = NOFX, proofs = [], meta = {} }) {\n    this.issuer = issuer\n    this.result = result\n    this.ran = ran\n    this.fx = fx\n    this.proofs = proofs\n    this.meta = meta\n  }\n  async buildIPLDView({ hasher = sha256, codec = CBOR } = {}) {\n    const store = DAG.createStore()\n\n    // copy invocation blocks int\n    DAG.addEveryInto(DAG.iterate(this.ran), store)\n\n    // copy proof blocks into store\n    const prf = []\n    for (const proof of this.proofs) {\n      DAG.addEveryInto(DAG.iterate(proof), store)\n      prf.push(proof.link())\n    }\n\n    // copy blocks from the embedded fx\n    /** @type {{fork: API.Run[], join?:API.Run}}  */\n    const fx = { fork: [] }\n    for (const fork of this.fx.fork) {\n      DAG.addEveryInto(DAG.iterate(fork), store)\n      fx.fork.push(fork.link())\n    }\n\n    if (this.fx.join) {\n      DAG.addEveryInto(DAG.iterate(this.fx.join), store)\n      fx.join = this.fx.join.link()\n    }\n\n    /** @type {API.OutcomeModel<Ok, Error, Ran>} */\n    const outcome = {\n      ran: /** @type {ReturnType<Ran['link']>} */ (this.ran.link()),\n      out: this.result,\n      fx,\n      meta: this.meta,\n      iss: this.issuer.did(),\n      prf,\n    }\n\n    const signature = await this.issuer.sign(CBOR.encode(outcome))\n\n    /** @type {API.ReceiptModel<Ok, Error, Ran>} */\n    const model = {\n      ocm: outcome,\n      sig: signature,\n    }\n    const root = await DAG.writeInto(model, store, {\n      hasher,\n      codec,\n    })\n\n    return new Receipt({\n      root,\n      store,\n      signature,\n      proofs: this.proofs,\n      ran: this.ran,\n    })\n  }\n}\n\nconst NOFX = Object.freeze({ fork: Object.freeze([]) })\n\n/**\n * Creates a receipt in CBOR with sha256 hashed links.\n *\n * @template {{}} Ok\n * @template {{}} Error\n * @template {API.Invocation} Ran\n * @template {API.SigAlg} SigAlg\n * @param {object} options\n * @param {API.Signer<API.DID, SigAlg>} options.issuer\n * @param {Ran|ReturnType<Ran['link']>} options.ran\n * @param {API.Result<Ok, Error>} options.result\n * @param {API.Effects} [options.fx]\n * @param {API.Proof[]} [options.proofs]\n * @param {Record<string, unknown>} [options.meta]\n * @returns {Promise<API.Receipt<Ok, Error, Ran, SigAlg>>}\n */\nexport const issue = options => new ReceptBuilder(options).buildIPLDView()\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3028, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/core/src/message.js"],"sourcesContent":["import * as API from '@ucanto/interface'\nimport * as DAG from './dag.js'\nimport { Invocation, panic } from './lib.js'\nimport * as Receipt from './receipt.js'\nimport * as Schema from './schema.js'\n\nexport const MessageSchema = Schema.variant({\n  'ucanto/message@7.0.0': Schema.struct({\n    execute: Schema.link().array().optional(),\n    delegate: Schema.dictionary({\n      key: Schema.string(),\n      value: /** @type {API.Reader<API.Link<API.ReceiptModel>>} */ (\n        Schema.link()\n      ),\n    })\n      .array()\n      .optional(),\n  }),\n})\n\n/**\n * @template {API.Tuple<API.IssuedInvocation>} I\n * @template {API.Tuple<API.Receipt>} R\n * @param {object} source\n * @param {I} [source.invocations]\n * @param {R} [source.receipts]\n * @returns {Promise<API.AgentMessage<{ In: API.InferInvocations<I>, Out: R }>>}\n */\nexport const build = ({ invocations, receipts }) =>\n  new MessageBuilder({ invocations, receipts }).buildIPLDView()\n\n/**\n * @template [E=never]\n * @param {object} source\n * @param {API.Link} source.root\n * @param {DAG.BlockStore} source.store\n * @param {E} [fallback]\n * @returns {API.AgentMessage|E}\n */\nexport const view = ({ root, store }, fallback) => {\n  const block = DAG.get(root, store, null)\n  if (block === null) {\n    return fallback !== undefined ? fallback : DAG.notFound(root)\n  }\n  const data = DAG.CBOR.decode(block.bytes)\n  const [branch, value] = MessageSchema.match(data, fallback)\n  switch (branch) {\n    case 'ucanto/message@7.0.0':\n      return new Message({ root: { ...block, data }, store })\n    default:\n      return value\n  }\n}\n\n/**\n * @template {API.Tuple<API.IssuedInvocation>} I\n * @template {API.Tuple<API.Receipt>} R\n * @implements {API.AgentMessageBuilder<{In: API.InferInvocations<I>, Out: R }>}\n *\n */\nclass MessageBuilder {\n  /**\n   * @param {object} source\n   * @param {I} [source.invocations]\n   * @param {R} [source.receipts]\n   */\n  constructor({ invocations, receipts }) {\n    this.invocations = invocations\n    this.receipts = receipts\n  }\n  /**\n   *\n   * @param {API.BuildOptions} [options]\n   * @returns {Promise<Message<{ In: API.InferInvocations<I>, Out: R }>>}\n   */\n  async buildIPLDView(options) {\n    const store = new Map()\n\n    const { invocations, ...executeField } = await writeInvocations(\n      this.invocations || [],\n      store\n    )\n\n    const { receipts, ...receiptsField } = await writeReceipts(\n      this.receipts || [],\n      store\n    )\n\n    const root = await DAG.writeInto(\n      /** @type {API.AgentMessageModel<{ In: API.InferInvocations<I>, Out: R }>} */\n      ({\n        'ucanto/message@7.0.0': {\n          ...executeField,\n          ...receiptsField,\n        },\n      }),\n      store,\n      options\n    )\n\n    return new Message({ root, store }, { receipts, invocations })\n  }\n}\n\n/**\n *\n * @param {API.IssuedInvocation[]} run\n * @param {Map<string, API.Block>} store\n */\nconst writeInvocations = async (run, store) => {\n  const invocations = []\n  const execute = []\n  for (const invocation of run) {\n    const view = await invocation.buildIPLDView()\n    execute.push(view.link())\n    invocations.push(view)\n    for (const block of view.iterateIPLDBlocks()) {\n      store.set(`${block.cid}`, block)\n    }\n  }\n\n  return { invocations, ...(execute.length > 0 ? { execute } : {}) }\n}\n\n/**\n * @param {API.Receipt[]} source\n * @param {Map<string, API.Block>} store\n */\nconst writeReceipts = async (source, store) => {\n  if (source.length === 0) {\n    return {}\n  }\n\n  const receipts = new Map()\n  /** @type {Record<API.ToString<API.ReceiptModel['ocm']['ran']>, API.Link<API.ReceiptModel>>} */\n  const report = {}\n\n  for (const [n, receipt] of source.entries()) {\n    const view = await receipt.buildIPLDView()\n    for (const block of view.iterateIPLDBlocks()) {\n      store.set(`${block.cid}`, block)\n    }\n\n    const key = `${view.ran.link()}`\n    if (!(key in report)) {\n      report[key] = view.root.cid\n      receipts.set(key, view)\n    } else {\n      // In theory we could have gotten the same invocation twice and both\n      // should get same receipt. In legacy code we send tuple of results\n      // as opposed to a map keyed by invocation to keep old clients working\n      // we just stick the receipt in the map with a unique key so that when\n      // legacy encoder maps entries to array it will get both receipts in\n      // the right order.\n      receipts.set(`${key}@${n}`, view)\n    }\n  }\n\n  return { receipts, report }\n}\n\n/**\n * @template {{ In: API.Invocation[], Out: API.Receipt[] }} T\n * @implements {API.AgentMessage<T>}\n */\nclass Message {\n  /**\n   * @param {object} source\n   * @param {Required<API.Block<API.AgentMessageModel<T>>>} source.root\n   * @param {DAG.BlockStore} source.store\n   * @param {object} build\n   * @param {API.Invocation[]} [build.invocations]\n   * @param {Map<string, API.Receipt>} [build.receipts]\n   */\n  constructor({ root, store }, { invocations, receipts } = {}) {\n    this.root = root\n    this.store = store\n    this._invocations = invocations\n    this._receipts = receipts\n  }\n  *iterateIPLDBlocks() {\n    for (const invocation of this.invocations) {\n      yield* invocation.iterateIPLDBlocks()\n    }\n\n    for (const receipt of this.receipts.values()) {\n      yield* receipt.iterateIPLDBlocks()\n    }\n\n    yield this.root\n  }\n  /**\n   * @template [E=never]\n   * @param {API.Link} link\n   * @param {E} [fallback]\n   * @returns {API.Receipt|E}\n   */\n  get(link, fallback) {\n    const receipts = this.root.data['ucanto/message@7.0.0'].report || {}\n    const receipt = receipts[`${link}`]\n    if (receipt) {\n      return Receipt.view({ root: receipt, blocks: this.store })\n    } else {\n      return fallback !== undefined\n        ? fallback\n        : panic(`Message does not include receipt for ${link}`)\n    }\n  }\n\n  get invocationLinks() {\n    return this.root.data['ucanto/message@7.0.0'].execute || []\n  }\n\n  get invocations() {\n    let invocations = this._invocations\n    if (!invocations) {\n      invocations = this.invocationLinks.map(link => {\n        return Invocation.view({ root: link, blocks: this.store })\n      })\n    }\n\n    return invocations\n  }\n\n  get receipts() {\n    let receipts = this._receipts\n    if (!receipts) {\n      receipts = new Map()\n      const report = this.root.data['ucanto/message@7.0.0'].report || {}\n      for (const [key, link] of Object.entries(report)) {\n        const receipt = Receipt.view({ root: link, blocks: this.store })\n        receipts.set(`${receipt.ran.link()}`, receipt)\n      }\n    }\n\n    return receipts\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}},
    {"offset": {"line": 3254, "column": 0}, "map": {"version":3,"sources":["file:///home/driemworks/fangorn/website/node_modules/%40ucanto/core/src/lib.js"],"sourcesContent":["export * as API from '@ucanto/interface'\nexport * as Delegation from './delegation.js'\nexport * as Invocation from './invocation.js'\nexport * as Message from './message.js'\nexport * as Receipt from './receipt.js'\nexport * as DAG from './dag.js'\nexport * as CBOR from './cbor.js'\nexport * as CAR from './car.js'\nexport { delegate, isDelegation } from './delegation.js'\nexport { invoke } from './invocation.js'\nexport {\n  create as createLink,\n  createLegacy as createLegacyLink,\n  isLink,\n  parse as parseLink,\n  decode as decodeLink,\n} from './link.js'\nexport { sha256 } from 'multiformats/hashes/sha2'\nexport { base58btc } from 'multiformats/bases/base58'\nexport * as UCAN from '@ipld/dag-ucan'\nexport * as DID from '@ipld/dag-ucan/did'\nexport * as Signature from '@ipld/dag-ucan/signature'\nexport * from './result.js'\nexport * as Schema from './schema.js'\n"],"names":[],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA","ignoreList":[0]}}]
}